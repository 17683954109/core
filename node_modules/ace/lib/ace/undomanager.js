/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define(function(require, exports, module) {
"use strict";

/**
 * This object maintains the undo stack for an [[EditSession `EditSession`]].
 * @class UndoManager
 **/

/**
 * Resets the current undo state and creates a new `UndoManager`.
 * 
 * @constructor
 **/
var UndoManager = function() {
    this.reset();
};

(function() {

    /**
     * Provides a means for implementing your own undo manager. `options` has one property, `args`, an [[Array `Array`]], with two elements:
     *
     * - `args[0]` is an array of deltas
     * - `args[1]` is the document to associate with
     *
     * @param {Object} options Contains additional properties
     *
     **/
    this.add = function(delta, doc) {
        // Normalize deltas for storage.
        // var deltaSets = this.$serializeDeltas(options.args[0]);
        
        // Add deltas to undo stack.
        this.$doc = doc;
        // if (options.merge && this.hasUndo()){
        //     this.dirtyCounter--;
        //     deltaSets = this.$undoStack.pop().concat(deltaSets);
        // }
        if (doc.mergeUndoDeltas === false || !this.lastDeltas) {
            this.lastDeltas = [];
            this.$undoStack.push(this.lastDeltas);
        }
        this.lastDeltas.push(delta);
        
        // Reset redo stack.
        this.$redoStack = [];
        if (this.dirtyCounter < 0) {
            // The user has made a change after undoing past the last clean state.
            // We can never get back to a clean state now until markClean() is called.
            this.dirtyCounter = NaN;
        }
        this.dirtyCounter++;
    };
    
    this.startGroup = function() {
        this.lastDeltas = null;
    };

    /**
     * [Perform an undo operation on the document, reverting the last change.]{: #UndoManager.undo}
     * @param {Boolean} dontSelect {:dontSelect}
     *
     * @returns {Range} The range of the undo.
     **/
    this.undo = function() {
        this.lastDeltas = null;
        var stack = this.$undoStack;
        UndoManager.rebase(stack, stack.length);
        var deltaSet = stack.pop();
        var undoSelectionRange = null;
        if (deltaSet) {
            undoSelectionRange = this.$doc.undoChanges(deltaSet);
            this.$redoStack.push(deltaSet);
            this.dirtyCounter--;
        }

        return undoSelectionRange;
    };
    
    /**
     * [Perform a redo operation on the document, reimplementing the last change.]{: #UndoManager.redo}
     * @param {Boolean} dontSelect {:dontSelect}
     *
     **/
    this.redo = function(dontSelect) {
        this.lastDeltas = null;
        var deltaSet = this.$redoStack.pop();
        var redoSelectionRange = null;
        if (deltaSet) {
            redoSelectionRange = this.$doc.redoChanges(deltaSet);
            this.$undoStack.push(deltaSet);
            this.dirtyCounter++;
        }
        return redoSelectionRange;
    };

    /**
     * Destroys the stack of undo and redo redo operations.
     **/
    this.reset = function() {
        this.$undoStack = [];
        this.$redoStack = [];
        this.dirtyCounter = 0;
    };

    /**
     * Returns `true` if there are undo operations left to perform.
     * @returns {Boolean}
     **/
    this.hasUndo = function() {
        return this.$undoStack.length > 0;
    };

    /**
     * Returns `true` if there are redo operations left to perform.
     * @returns {Boolean}
     **/
    this.hasRedo = function() {
        return this.$redoStack.length > 0;
    };

    /**
     * Marks the current status clean
     **/
    this.markClean = function() {
        this.dirtyCounter = 0;
    };

    /**
     * Returns if the current status is clean
     * @returns {Boolean}
     **/
    this.isClean = function() {
        return this.dirtyCounter === 0;
    };
    
    // // Serializes deltaSets to reduce memory usage.
    // this.$serializeDeltas = function(deltaSets) {
    //     return cloneDeltaSetsObj(deltaSets, $serializeDelta);
    // };
    
    // // Deserializes deltaSets to allow application to the document.
    // this.$deserializeDeltas = function(deltaSets) {
    //     return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
    // };

}).call(UndoManager.prototype);

UndoManager.rebase = function(stack, pos) {
    for (var i = pos; i--; ) {
        var deltaSet = stack[i];
        if (deltaSet && !deltaSet[0].disabled) {
            while(i < pos - 1) {
                var swapped = swapGroups(stack[i], stack[i + 1]);
                stack[i] = swapped[0];
                stack[i + 1] = swapped[1];
                i++;
            }
            break;
        }
    }
};

    
/*
 * i i  d1  d2
 *      |/  |/  d2.s >= d1.e shift(d2, d1, -1)
 *              d2.s <= d1.s shift(d1, d2, +1)
 *       d1.s < d2.s < d1.e // can split
 * 
 * i r  d1  d2
 *      |/  |\  d2.s >= d1.e shift(d2, d1, -1)
 *              d2.e <= d1.s shift(d1, d2, -1)
 *       else // can't swap
 * 
 * r i  d1  d2
 *      |\  |/  d2.s >= d1.s shift(d2, d1, +1)
 *              d2.s <= d1.s shift(d1, d2, +1)
 *       // no else
 * 
 * r r  d1  d2
 *      |\  |\  d2.s >= d1.s shift(d2, d1, +1)
 *              d2.e <= d1.s shift(d1, d2, -1)
 *       d2.s < d1.s < d2.e // can split
 */
var Range = require("./range").Range;
var cmp = Range.comparePoints;
function swap(d1, d2) {
    var i1 = d1.action == "insert";
    var i2 = d2.action == "insert";
    
    if (i1 && i2) {
        if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
        } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, +1);
        } else {
            return null;
        }
    } else if (i1 && !i2) {
        if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
        } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
        } else {
            return null;
        }
    } else if (!i1 && i2) {
        if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, +1);
        } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, +1);
        } else {
            return null;
        }
    } else if (!i1 && !i2) {
        if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, +1);
        } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
        } else {
            return null;
        }
    }
    return [d2, d1];
    
    function shift(d1, d2, dir) {
        shiftPos(d1.start, d2.start, d2.end, dir);
        shiftPos(d1.end, d2.start, d2.end, dir);
    }
    function shiftPos(pos, start, end, dir) {
        if (pos.row == (dir == 1 ? start : end).row) {
            pos.column += dir * (end.column - start.column);
        }
        pos.row += dir * (end.row - start.row);
    }
}
function clonePos(pos) {
    return {row: pos.row,column: pos.column};
}
function cloneDelta(d) {
    return {
        start: clonePos(d.start),
        end: clonePos(d.end),
        action: d.action,
        lines: d.lines.slice(),
        toString: logDelta
    };
}
function logDelta(d) {
    d = d || this;
    var type = d.action == "insert" ? "+" : "-";
    return type + "[" + d.lines + "]" 
    + d.start.row + ":" + d.start.column + "=>" 
    + d.end.row + ":" + d.end.column;
}
function swapGroups(ds1, ds2) {
    for (var i = ds1.length; i--; ) {
        for (var j = 0; j < ds2.length; j++) {
            if (!swap(ds1[i], ds2[j])) {
                // rollback, we have to undo ds2 first
                while (i < ds1.length) {
                    while (j--) {
                        swap(ds2[j], ds1[i]);
                    }
                    j = ds2.length;
                    i++;
                }                
                return [ds1, ds2];
            }
        }
    }
    ds1.selectionBefore = ds2.selectionBefore = 
    ds1.selectionAfter = ds2.selectionAfter = null;
    return [ds2, ds1];
}

UndoManager.swapGroups = swapGroups;
exports.UndoManager = UndoManager;
});
