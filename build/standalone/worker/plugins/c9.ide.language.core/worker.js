"no use strict";
;(function(window) {
if (typeof window.window != "undefined" && window.document)
    return;
if (window.require && window.define)
    return;

if (!window.console) {
    window.console = function() {
        var msgs = Array.prototype.slice.call(arguments, 0);
        postMessage({type: "log", data: msgs});
    };
    window.console.error =
    window.console.warn = 
    window.console.log =
    window.console.trace = window.console;
}
window.window = window;
window.ace = window;

window.onerror = function(message, file, line, col, err) {
    postMessage({type: "error", data: {
        message: message,
        data: err.data,
        file: file,
        line: line, 
        col: col,
        stack: err.stack
    }});
};

window.normalizeModule = function(parentId, moduleName) {
    if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return window.normalizeModule(parentId, chunks[0]) + "!" + window.normalizeModule(parentId, chunks[1]);
    }
    if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        moduleName = (base ? base + "/" : "") + moduleName;
        
        while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/^\.\//, "").replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
    }
    
    return moduleName;
};

window.require = function require(parentId, id) {
    if (!id) {
        id = parentId;
        parentId = null;
    }
    if (!id.charAt)
        throw new Error("worker.js require() accepts only (parentId, id) as arguments");

    id = window.normalizeModule(parentId, id);

    var module = window.require.modules[id];
    if (module) {
        if (!module.initialized) {
            module.initialized = true;
            module.exports = module.factory().exports;
        }
        return module.exports;
    }
   
    if (!window.require.tlns)
        return console.log("unable to load " + id);
    
    var path = resolveModuleId(id, window.require.tlns);
    if (path.slice(-3) != ".js") path += ".js";
    
    window.require.id = id;
    window.require.modules[id] = {}; // prevent infinite loop on broken modules
    importScripts(path);
    return window.require(parentId, id);
};
function resolveModuleId(id, paths) {
    var testPath = id, tail = "";
    while (testPath) {
        var alias = paths[testPath];
        if (typeof alias == "string") {
            return alias + tail;
        } else if (alias) {
            return  alias.location.replace(/\/*$/, "/") + (tail || alias.main || alias.name);
        } else if (alias === false) {
            return "";
        }
        var i = testPath.lastIndexOf("/");
        if (i === -1) break;
        tail = testPath.substr(i) + tail;
        testPath = testPath.slice(0, i);
    }
    return id;
}
window.require.modules = {};
window.require.tlns = {};

window.define = function(id, deps, factory) {
    if (arguments.length == 2) {
        factory = deps;
        if (typeof id != "string") {
            deps = id;
            id = window.require.id;
        }
    } else if (arguments.length == 1) {
        factory = id;
        deps = [];
        id = window.require.id;
    }
    
    if (typeof factory != "function") {
        window.require.modules[id] = {
            exports: factory,
            initialized: true
        };
        return;
    }

    if (!deps.length)
        deps = ["require", "exports", "module"];

    var req = function(childId) {
        return window.require(id, childId);
    };

    window.require.modules[id] = {
        exports: {},
        factory: function() {
            var module = this;
            var returnExports = factory.apply(this, deps.map(function(dep) {
                switch (dep) {
                    case "require": return req;
                    case "exports": return module.exports;
                    case "module":  return module;
                    default:        return req(dep);
                }
            }));
            if (returnExports)
                module.exports = returnExports;
            return module;
        }
    };
};
window.define.amd = {};
require.tlns = {};
window.initBaseUrls  = function initBaseUrls(topLevelNamespaces) {
    for (var i in topLevelNamespaces)
        require.tlns[i] = topLevelNamespaces[i];
};

window.initSender = function initSender() {

    var EventEmitter = window.require("ace/lib/event_emitter").EventEmitter;
    var oop = window.require("ace/lib/oop");
    
    var Sender = function() {};
    
    (function() {
        
        oop.implement(this, EventEmitter);
                
        this.callback = function(data, callbackId) {
            postMessage({
                type: "call",
                id: callbackId,
                data: data
            });
        };
    
        this.emit = function(name, data) {
            postMessage({
                type: "event",
                name: name,
                data: data
            });
        };
        
    }).call(Sender.prototype);
    
    return new Sender();
};

var main = window.main = null;
var sender = window.sender = null;

window.onmessage = function(e) {
    var msg = e.data;
    if (msg.event && sender) {
        sender._signal(msg.event, msg.data);
    }
    else if (msg.command) {
        if (main && main[msg.command])
            main[msg.command].apply(main, msg.args);
        else if (window[msg.command])
            window[msg.command].apply(window, msg.args);
        else
            throw new Error("Unknown command:" + msg.command);
    }
    else if (msg.init) {
        window.initBaseUrls(msg.tlns);
        require("ace/lib/es5-shim");
        require("ace/lib/es6-shim");
        sender = window.sender = window.initSender();
        var clazz = require(msg.module)[msg.classname];
        main = window.main = new clazz(sender);
    }
};
})(this);

define("require",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;

var requirejs, require, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.1.4',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        ap = Array.prototype,
        apsp = ap.splice,
        isBrowser = !!(typeof window !== 'undefined' && navigator && document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value !== 'string') {
                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }
    if (typeof require !== 'undefined' && !isFunction(require)) {
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                pkgs: {},
                shim: {},
                map: {},
                config: {}
            },
            registry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            requireCounter = 1,
            unnormalizedCounter = 1;
        function trimDots(ary) {
            var i, part;
            for (i = 0; ary[i]; i += 1) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }
        function normalize(name, baseName, applyMap) {
            var pkgName, pkgConfig, mapValue, nameParts, i, j, nameSegment,
                foundMap, foundI, foundStarMap, starI,
                baseParts = baseName && baseName.split('/'),
                normalizedBaseParts = baseParts,
                map = config.map,
                starMap = map && map['*'];
            if (name && name.charAt(0) === '.') {
                if (baseName) {
                    if (getOwn(config.pkgs, baseName)) {
                        normalizedBaseParts = baseParts = [baseName];
                    } else {
                        normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    }

                    name = normalizedBaseParts.concat(name.split('/'));
                    trimDots(name);
                    pkgConfig = getOwn(config.pkgs, (pkgName = name[0]));
                    name = name.join('/');
                    if (pkgConfig && name === pkgName + '/' + pkgConfig.main) {
                        name = pkgName;
                    }
                } else if (name.indexOf('./') === 0) {
                    name = name.substring(2);
                }
            }
            if (applyMap && (baseParts || starMap) && map) {
                nameParts = name.split('/');

                for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    foundMap = mapValue;
                                    foundI = i;
                                    break;
                                }
                            }
                        }
                    }

                    if (foundMap) {
                        break;
                    }
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            return name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                removeScript(id);
                pathConfig.shift();
                context.require.undef(id);
                context.require([id]);
                return true;
            }
        }
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        normalizedName = normalize(name, parentName, applyMap);
                    }
                } else {
                    normalizedName = normalize(name, parentName, applyMap);
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                getModule(depMap).on(name, fn);
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }
        function takeGlobalQueue() {
            if (globalDefQueue.length) {
                apsp.apply(defQueue,
                           [defQueue.length - 1, 0].concat(globalDefQueue));
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return mod.exports;
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return (config.config && getOwn(config.config, mod.map.id)) || {};
                        },
                        exports: defined[mod.map.id]
                    });
                }
            }
        };

        function cleanRegistry(id) {
            delete registry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var map, modId, err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;
            eachProp(registry, function (mod) {
                map = mod.map;
                modId = map.id;
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }
            if ((!expired || usingPathFallback) && stillLoading) {
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    this.on('error', errback);
                } else if (this.events.error) {
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;
                this.inited = true;

                this.ignore = options.ignore;
                if (options.enabled || this.enabled) {
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    this.fetch();
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            if (this.events.error) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            if (this.map.isDefine) {
                                cjsModule = this.module;
                                if (cjsModule &&
                                        cjsModule.exports !== undefined &&
                                        cjsModule.exports !== this.exports) {
                                    exports = cjsModule.exports;
                                } else if (exports === undefined && this.usingExports) {
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = [this.map.id];
                                err.requireType = 'define';
                                return onError((this.error = err));
                            }

                        } else {
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }
                        delete registry[id];

                        this.defined = true;
                    }
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    pluginMap = makeModuleMap(map.prefix);
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });
                    if (this.map.unnormalized) {
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });
                    load.fromText = bind(this, function (text, textAlt) {
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;
                        if (textAlt) {
                            text = textAlt;
                        }
                        if (hasInteractive) {
                            useInteractive = false;
                        }
                        getModule(moduleMap);
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }
                        this.depMaps.push(moduleMap);
                        context.completeLoad(moduleName);
                        localRequire([moduleName], load);
                    });
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                this.enabled = true;
                this.enabling = true;
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', this.errback);
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            if (node.detachEvent && !isOpera) {
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }
        function getScriptData(evt) {
            var node = evt.currentTarget || evt.srcElement;
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;
            takeGlobalQueue();
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                } else {
                    callGetModule(args);
                }
            }
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            configure: function (cfg) {
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }
                var pkgs = config.pkgs,
                    shim = config.shim,
                    objs = {
                        paths: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (prop === 'map') {
                            mixin(config[prop], value, true, true);
                        } else {
                            mixin(config[prop], value, true);
                        }
                    } else {
                        config[prop] = value;
                    }
                });
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;
                        location = pkgObj.location;
                        pkgs[pkgObj.name] = {
                            name: pkgObj.name,
                            location: location || pkgObj.name,
                            main: (pkgObj.main || 'main')
                                  .replace(currDirRegExp, '')
                                  .replace(jsSuffixRegExp, '')
                        };
                    });
                    config.pkgs = pkgs;
                }
                eachProp(registry, function (mod, id) {
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id);
                    }
                });
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }
                        if (req.get) {
                            return req.get(context, deps, relMap);
                        }
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }
                    intakeDefines();
                    context.nextTick(function () {
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,
                    toUrl: function (moduleNamePlusExt) {
                        var ext, url,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        url = context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext || '.fake');
                        return ext ? url : url.substring(0, url.length - 5);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });
                if (!relMap) {
                    localRequire.undef = function (id) {
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        if (mod) {
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        found = true;
                    }

                    callGetModule(args);
                }
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },
            nameToUrl: function (moduleName, ext) {
                var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url,
                    parentPath;
                if (req.jsExtRegExp.test(moduleName)) {
                    url = moduleName + (ext || '');
                } else {
                    paths = config.paths;
                    pkgs = config.pkgs;

                    syms = moduleName.split('/');
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');
                        pkg = getOwn(pkgs, parentModule);
                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        } else if (pkg) {
                            if (moduleName === pkg.name) {
                                pkgPath = pkg.location + '/' + pkg.main;
                            } else {
                                pkgPath = pkg.location;
                            }
                            syms.splice(0, i, pkgPath);
                            break;
                        }
                    }
                    url = syms.join('/');
                    url += (ext || (/\?/.test(url) ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                                        ((url.indexOf('?') === -1 ? '?' : '&') +
                                         config.urlArgs) : url;
            },
            load: function (id, url) {
                req.load(context, id, url);
            },
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },
            onScriptLoad: function (evt) {
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    interactiveScript = null;
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error', evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }
    req = requirejs = function (deps, callback, errback, optional) {
        var context, config,
            contextName = defContextName;
        if (!isArray(deps) && typeof deps !== 'string') {
            config = deps;
            if (isArray(callback)) {
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };
    req.config = function (config) {
        return req(config);
    };
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };
    if (!require) {
        require = req;
    }

    req.version = version;
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };
    req({});
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }
    req.onError = function (err) {
        throw err;
    };
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            node = config.xhtml ?
                    document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                    document.createElement('script');
            node.type = config.scriptType || 'text/javascript';
            node.charset = 'utf-8';
            node.async = true;

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);
            if (node.attachEvent &&
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            importScripts(url);
            context.completeLoad(moduleName);
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }
    if (isBrowser) {
        eachReverse(scripts(), function (script) {
            if (!head) {
                head = script.parentNode;
            }
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                if (!cfg.baseUrl) {
                    src = dataMain.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/') + '/' : './';

                    cfg.baseUrl = subPath;
                    dataMain = mainScript;
                }
                dataMain = dataMain.replace(jsSuffixRegExp, '');
                cfg.deps = cfg.deps ? cfg.deps.concat(dataMain) : [dataMain];

                return true;
            }
        });
    }
    define = function (name, deps, callback) {
        var node, context;
        if (typeof name !== 'string') {
            callback = deps;
            deps = name;
            name = null;
        }
        if (!isArray(deps)) {
            callback = deps;
            deps = [];
        }
        if (!deps.length && isFunction(callback)) {
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }
        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
    };

    define.amd = {
        jQuery: true
    };
    req.exec = function (text) {
        return eval(text);
    };
    req(cfg);
}(this));

});

define("acorn/dist/acorn",["require", "exports", "module"], function(require, exports, module) {

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/src\\expression.js":[function(_dereq_,module,exports){
//
//
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var pp = _state.Parser.prototype;
pp.checkPropClash = function (prop, propHash) {
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
  var key = prop.key;var name = undefined;
  switch (key.type) {
    case "Identifier":
      name = key.name;break;
    case "Literal":
      name = String(key.value);break;
    default:
      return;
  }
  var kind = prop.kind;

  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var isGetSet = kind !== "init";
    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raiseRecoverable(key.start, "Redefinition of property");
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp.parseExpression = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === _tokentype.types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) return this.parseYield();

  var validateDestructuring = false;
  if (!refDestructuringErrors) {
    refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
    validateDestructuring = true;
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.type.isAssign) {
    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true);
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
    refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return left;
};
pp.parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  if (this.eat(_tokentype.types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(_tokentype.types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp.parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
};
pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
    if (prec > minPrec) {
      var logical = this.type === _tokentype.types.logicalOR || this.type === _tokentype.types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start,
          startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }
  return left;
};

pp.buildBinary = function (startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
  var startPos = this.start,
      startLoc = this.startLoc,
      expr = undefined;
  if (this.type.prefix) {
    var node = this.startNode(),
        update = this.type === _tokentype.types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raiseRecoverable(node.start, "Deleting local variable in strict mode");else sawUnary = true;
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.prefix = false;
      node.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(_tokentype.types.starstar)) return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);else return expr;
};
pp.parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
  return this.parseSubscripts(expr, startPos, startLoc);
};

pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  for (;;) {
    if (this.eat(_tokentype.types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseIdent(true);
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.eat(_tokentype.types.bracketL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.expect(_tokentype.types.bracketR);
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      node.arguments = this.parseExprList(_tokentype.types.parenR, false);
      base = this.finishNode(node, "CallExpression");
    } else if (this.type === _tokentype.types.backQuote) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate();
      base = this.finishNode(node, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};
pp.parseExprAtom = function (refDestructuringErrors) {
  var node = undefined,
      canBeArrow = this.potentialArrowAt == this.start;
  switch (this.type) {
    case _tokentype.types._super:
      if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");

    case _tokentype.types._this:
      var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case _tokentype.types.name:
      if (this.value == "async" && /^[ \t]*(function\b|\(|\w+[ \t]*=>)/.test(this.input.slice(this.end))) {
        node = this.startNode();
        this.next();
        this.potentialArrowAt = this.start;
        return this.parseExprAtom(refDestructuringErrors);
      }
      if (this.value == "await" && /^[ \t]+[\w\x1f-\uffff]/.test(this.input.slice(this.end))) {
        node = this.startNode();
        this.next();
        return this.parseExprAtom(refDestructuringErrors);
      }

      var startPos = this.start,
          startLoc = this.startLoc;
      var id = this.parseIdent(this.type !== _tokentype.types.name);
      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
      return id;

    case _tokentype.types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;

    case _tokentype.types.num:case _tokentype.types.string:
      return this.parseLiteral(this.value);

    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
      node = this.startNode();
      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case _tokentype.types.parenL:
      return this.parseParenAndDistinguishExpression(canBeArrow);

    case _tokentype.types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");

    case _tokentype.types.braceL:
      return this.parseObj(false, refDestructuringErrors);

    case _tokentype.types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case _tokentype.types._class:
      return this.parseClass(this.startNode(), false);

    case _tokentype.types._new:
      return this.parseNew();

    case _tokentype.types.backQuote:
      return this.parseTemplate();

    default:
      this.unexpected();
  }
};

pp.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal");
};

pp.parseParenExpression = function () {
  this.expect(_tokentype.types.parenL);
  var val = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  return val;
};

pp.parseParenAndDistinguishExpression = function (canBeArrow) {
  var startPos = this.start,
      startLoc = this.startLoc,
      val = undefined;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start,
        innerStartLoc = this.startLoc;
    var exprList = [],
        first = true;
    var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 },
        spreadStart = undefined,
        innerParenStart = undefined;
    while (this.type !== _tokentype.types.parenR) {
      first ? first = false : this.expect(_tokentype.types.comma);
      if (this.type === _tokentype.types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRest()));
        break;
      } else {
        if (this.type === _tokentype.types.parenL && !innerParenStart) {
          innerParenStart = this.start;
        }
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start,
        innerEndLoc = this.startLoc;
    this.expect(_tokentype.types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, true);
      if (innerParenStart) this.unexpected(innerParenStart);
      return this.parseParenArrowList(startPos, startLoc, exprList);
    }

    if (!exprList.length) this.unexpected(this.lastTokStart);
    if (spreadStart) this.unexpected(spreadStart);
    this.checkExpressionErrors(refDestructuringErrors, true);

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};

pp.parseParenItem = function (item) {
  return item;
};

pp.parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
};
var empty = [];

pp.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
    if (!this.inFunction) this.raiseRecoverable(node.start, "new.target can only be used in functions");
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;
  return this.finishNode(node, "NewExpression");
};
pp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
    cooked: this.value
  };
  this.next();
  elem.tail = this.type === _tokentype.types.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(_tokentype.types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(_tokentype.types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement());
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp.parseObj = function (isPattern, refDestructuringErrors) {
  var node = this.startNode(),
      first = true,
      propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var prop = this.startNode(),
        isGenerator = undefined,
        startPos = undefined,
        startLoc = undefined;
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
    }
    this.parsePropertyName(prop);
    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
    this.checkPropClash(prop, propHash);
    node.properties.push(this.finishNode(prop, "Property"));
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
  if (this.eat(_tokentype.types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
    if (isPattern) this.unexpected();
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator);
  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {
    if (isGenerator || isPattern) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
    }
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    prop.kind = "init";
    if (isPattern) {
      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) || this.inGenerator && prop.key.name == "yield") this.raiseRecoverable(prop.key.start, "Binding " + prop.key.name);
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === _tokentype.types.eq && refDestructuringErrors) {
      if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else this.unexpected();
};

pp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(_tokentype.types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(_tokentype.types.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
};
pp.initFunction = function (node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
};
pp.parseMethod = function (isGenerator) {
  var node = this.startNode(),
      oldInGen = this.inGenerator;
  this.inGenerator = isGenerator;
  this.initFunction(node);
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
  if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
  this.parseFunctionBody(node, false);
  this.inGenerator = oldInGen;
  return this.finishNode(node, "FunctionExpression");
};
pp.parseArrowExpression = function (node, params) {
  var oldInGen = this.inGenerator;
  this.inGenerator = false;
  this.initFunction(node);
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);
  this.inGenerator = oldInGen;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp.parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    var oldInFunc = this.inFunction,
        oldLabels = this.labels;
    this.inFunction = true;this.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.inFunction = oldInFunc;this.labels = oldLabels;
  }
  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
    var oldStrict = this.strict;
    this.strict = true;
    if (node.id) this.checkLVal(node.id, true);
    this.checkParams(node);
    this.strict = oldStrict;
  } else if (isArrowFunction) {
    this.checkParams(node);
  }
};
pp.checkParams = function (node) {
  var nameHash = {};
  for (var i = 0; i < node.params.length; i++) {
    this.checkLVal(node.params[i], true, nameHash);
  }
};
pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
        refDestructuringErrors.trailingComma = this.lastTokStart;
      }
      if (allowTrailingComma && this.afterTrailingComma(close)) break;
    } else first = false;

    var elt = undefined;
    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refDestructuringErrors);else elt = this.parseMaybeAssign(false, refDestructuringErrors);
    elts.push(elt);
  }
  return elts;
};
pp.parseIdent = function (liberal) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved == "never") liberal = false;
  if (this.type === _tokentype.types.name) {
    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved");
    if (!liberal && this.inGenerator && this.value === "yield") this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator");
    node.name = this.value;
  } else if (liberal && this.type.keyword) {
    node.name = this.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "Identifier");
};
pp.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(_tokentype.types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js"}],"/src\\identifier.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierChar = isIdentifierChar;
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  7: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

exports.reservedWords = reservedWords;
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};

exports.keywords = keywords;
function isIdentifierStart(code, astral) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  return code >= 0xaa;
}
function isIdentifierChar(code, astral) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  return code >= 0xaa;
}

},{}],"/src\\index.js":[function(_dereq_,module,exports){
//
//
//
//
//
//
//
"use strict";

exports.__esModule = true;
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;

var _state = _dereq_("./state");

_dereq_("./parseutil");

_dereq_("./statement");

_dereq_("./lval");

_dereq_("./expression");

_dereq_("./location");

exports.Parser = _state.Parser;
exports.plugins = _state.plugins;

var _options = _dereq_("./options");

exports.defaultOptions = _options.defaultOptions;

var _locutil = _dereq_("./locutil");

exports.Position = _locutil.Position;
exports.SourceLocation = _locutil.SourceLocation;
exports.getLineInfo = _locutil.getLineInfo;

var _node = _dereq_("./node");

exports.Node = _node.Node;

var _tokentype = _dereq_("./tokentype");

exports.TokenType = _tokentype.TokenType;
exports.tokTypes = _tokentype.types;

var _tokencontext = _dereq_("./tokencontext");

exports.TokContext = _tokencontext.TokContext;
exports.tokContexts = _tokencontext.types;

var _identifier = _dereq_("./identifier");

exports.isIdentifierChar = _identifier.isIdentifierChar;
exports.isIdentifierStart = _identifier.isIdentifierStart;

var _tokenize = _dereq_("./tokenize");

exports.Token = _tokenize.Token;

var _whitespace = _dereq_("./whitespace");

exports.isNewLine = _whitespace.isNewLine;
exports.lineBreak = _whitespace.lineBreak;
exports.lineBreakG = _whitespace.lineBreakG;
var version = "3.0.2";

exports.version = version;
//
function parse(input, options) {
  return new _state.Parser(options, input).parse();
}
function parseExpressionAt(input, pos, options) {
  var p = new _state.Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression();
}
function tokenizer(input, options) {
  return new _state.Parser(options, input);
}

},{"./expression":"/src\\expression.js","./identifier":"/src\\identifier.js","./location":"/src\\location.js","./locutil":"/src\\locutil.js","./lval":"/src\\lval.js","./node":"/src\\node.js","./options":"/src\\options.js","./parseutil":"/src\\parseutil.js","./state":"/src\\state.js","./statement":"/src\\statement.js","./tokencontext":"/src\\tokencontext.js","./tokenize":"/src\\tokenize.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\location.js":[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var pp = _state.Parser.prototype;
pp.raise = function (pos, message) {
  var loc = _locutil.getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
  throw err;
};

pp.raiseRecoverable = pp.raise;

pp.curPosition = function () {
  if (this.options.locations) {
    return new _locutil.Position(this.curLine, this.pos - this.lineStart);
  }
};

},{"./locutil":"/src\\locutil.js","./state":"/src\\state.js"}],"/src\\locutil.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getLineInfo = getLineInfo;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _whitespace = _dereq_("./whitespace");
var Position = (function () {
  function Position(line, col) {


    this.line = line;
    this.column = col;
  }

  Position.prototype.offset = function offset(n) {
    return new Position(this.line, this.column + n);
  };

  return Position;
})();

exports.Position = Position;

var SourceLocation = function SourceLocation(p, start, end) {


  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) this.source = p.sourceFile;
};

exports.SourceLocation = SourceLocation;
function getLineInfo(input, offset) {
  for (var line = 0, cur = 0;;) {
    _whitespace.lineBreakG.lastIndex = cur;
    var match = _whitespace.lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
}

},{"./whitespace":"/src\\whitespace.js"}],"/src\\lval.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _util = _dereq_("./util");

var pp = _state.Parser.prototype;
pp.toAssignable = function (node, isBinding) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var i = 0; i < node.properties.length; i++) {
          var prop = node.properties[i];
          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
          this.toAssignable(prop.value, isBinding);
        }
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator
          ;
        } else {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
          break;
        }

      case "AssignmentPattern":
        if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value");
        break;

      case "ParenthesizedExpression":
        node.expression = this.toAssignable(node.expression, isBinding);
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  }
  return node;
};
pp.toAssignableList = function (exprList, isBinding) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type == "RestElement") {
      --end;
    } else if (last && last.type == "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
      --end;
    }

    if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this.toAssignable(elt, isBinding);
  }
  return exprList;
};
pp.parseSpread = function (refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};

pp.parseRest = function (allowNonIdent) {
  var node = this.startNode();
  this.next();
  if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();

  return this.finishNode(node, "RestElement");
};
pp.parseBindingAtom = function () {
  if (this.options.ecmaVersion < 6) return this.parseIdent();
  switch (this.type) {
    case _tokentype.types.name:
      return this.parseIdent();

    case _tokentype.types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern");

    case _tokentype.types.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

pp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (first) first = false;else this.expect(_tokentype.types.comma);
    if (allowEmpty && this.type === _tokentype.types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === _tokentype.types.ellipsis) {
      var rest = this.parseRest(allowNonIdent);
      this.parseBindingListItem(rest);
      elts.push(rest);
      this.expect(close);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};

pp.parseBindingListItem = function (param) {
  return param;
};
pp.parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp.checkLVal = function (expr, isBinding, checkClashes) {
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      if (checkClashes) {
        if (_util.has(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
        checkClashes[expr.name] = true;
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var i = 0; i < expr.properties.length; i++) {
        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
      }break;

    case "ArrayPattern":
      for (var i = 0; i < expr.elements.length; i++) {
        var elem = expr.elements[i];
        if (elem) this.checkLVal(elem, isBinding, checkClashes);
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes);
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes);
      break;

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, isBinding, checkClashes);
      break;

    default:
      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
  }
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./util":"/src\\util.js"}],"/src\\node.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var Node = function Node(parser, pos, loc) {


  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
  if (parser.options.ranges) this.range = [pos, 0];
};

exports.Node = Node;
var pp = _state.Parser.prototype;

pp.startNode = function () {
  return new Node(this, this.start, this.startLoc);
};

pp.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) node.loc.end = loc;
  if (this.options.ranges) node.range[1] = pos;
  return node;
}

pp.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};

},{"./locutil":"/src\\locutil.js","./state":"/src\\state.js"}],"/src\\options.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getOptions = getOptions;

var _util = _dereq_("./util");

var _locutil = _dereq_("./locutil");
var defaultOptions = {
  ecmaVersion: 6,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowHashBang: false,
  locations: true,
  onToken: null,
  onComment: null,
  //
  ranges: false,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: false,
  plugins: {}
};

exports.defaultOptions = defaultOptions;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;

  if (_util.isArray(options.onToken)) {
    (function () {
      var tokens = options.onToken;
      options.onToken = function (token) {
        return tokens.push(token);
      };
    })();
  }
  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
    if (options.ranges) comment.range = [start, end];
    array.push(comment);
  };
}

},{"./locutil":"/src\\locutil.js","./util":"/src\\util.js"}],"/src\\parseutil.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var pp = _state.Parser.prototype;
pp.isUseStrict = function (stmt) {
  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
};
pp.eat = function (type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp.isContextual = function (name) {
  return this.type === _tokentype.types.name && this.value === name;
};
pp.eatContextual = function (name) {
  return this.value === name && this.eat(_tokentype.types.name);
};
pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) this.unexpected();
};
pp.canInsertSemicolon = function () {
  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    return true;
  }
};
pp.semicolon = function () {
  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
};

pp.afterTrailingComma = function (tokType) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    this.next();
    return true;
  }
};
pp.expect = function (type) {
  this.eat(type) || this.unexpected();
};
pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

pp.checkPatternErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.trailingComma;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Trailing comma is not permitted in destructuring patterns");
};

pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\state.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var _options = _dereq_("./options");
var plugins = {};

exports.plugins = plugins;
function keywordRegexp(words) {
  return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
}

var Parser = (function () {
  function Parser(options, input, startPos) {


    this.options = options = _options.getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
    var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
    this.reservedWords = keywordRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
    this.reservedWordsStrict = keywordRegexp(reservedStrict);
    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
    this.input = String(input);
    this.containsEsc = false;
    this.loadPlugins(options.plugins);
    if (startPos) {
      this.pos = startPos;
      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 0;
    }
    this.type = _tokentype.types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;
    this.context = this.initialContext();
    this.exprAllowed = true;
    this.strict = this.inModule = options.sourceType === "module";
    this.potentialArrowAt = -1;
    this.inFunction = this.inGenerator = false;
    this.labels = [];
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
  }
  Parser.prototype.isKeyword = function isKeyword(word) {
    return this.keywords.test(word);
  };

  Parser.prototype.isReservedWord = function isReservedWord(word) {
    return this.reservedWords.test(word);
  };

  Parser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
    for (var _name in pluginConfigs) {
      var plugin = plugins[_name];
      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
      plugin(this, pluginConfigs[_name]);
    }
  };

  Parser.prototype.parse = function parse() {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node);
  };

  return Parser;
})();

exports.Parser = Parser;

},{"./identifier":"/src\\identifier.js","./options":"/src\\options.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\statement.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var _identifier = _dereq_("./identifier");

var pp = _state.Parser.prototype;
pp.parseTopLevel = function (node) {
  var first = true;
  if (!node.body) node.body = [];
  while (this.type !== _tokentype.types.eof) {
    var stmt = this.parseStatement(true, true);
    node.body.push(stmt);
    if (first) {
      if (this.isUseStrict(stmt)) this.setStrict(true);
      first = false;
    }
  }
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

var loopLabel = { kind: "loop" },
    switchLabel = { kind: "switch" };

pp.isLet = function () {
  if (this.type !== _tokentype.types.name || this.options.ecmaVersion < 6 || this.value != "let") return false;
  _whitespace.skipWhiteSpace.lastIndex = this.pos;
  var skip = _whitespace.skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length,
      nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh == 123) return true; // '{' and '['
  if (_identifier.isIdentifierStart(nextCh, true)) {
    for (var pos = next + 1; _identifier.isIdentifierChar(this.input.charCodeAt(pos, true)); ++pos) {}
    var ident = this.input.slice(next, pos);
    if (!this.isKeyword(ident)) return true;
  }
  return false;
};
//
pp.parseStatement = function (declaration, topLevel) {
  var starttype = this.type,
      node = this.startNode(),
      kind = undefined;

  if (this.isLet()) {
    starttype = _tokentype.types._var;
    kind = "let";
  }
  switch (starttype) {
    case _tokentype.types._break:case _tokentype.types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case _tokentype.types._debugger:
      return this.parseDebuggerStatement(node);
    case _tokentype.types._do:
      return this.parseDoStatement(node);
    case _tokentype.types._for:
      return this.parseForStatement(node);
    case _tokentype.types._function:
      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
      return this.parseFunctionStatement(node);
    case _tokentype.types._class:
      if (!declaration) this.unexpected();
      return this.parseClass(node, true);
    case _tokentype.types._if:
      return this.parseIfStatement(node);
    case _tokentype.types._return:
      return this.parseReturnStatement(node);
    case _tokentype.types._switch:
      return this.parseSwitchStatement(node);
    case _tokentype.types._throw:
      return this.parseThrowStatement(node);
    case _tokentype.types._try:
      return this.parseTryStatement(node);
    case _tokentype.types._const:case _tokentype.types._var:
      kind = kind || this.value;
      if (!declaration && kind != "var") this.unexpected();
      return this.parseVarStatement(node, kind);
    case _tokentype.types._while:
      return this.parseWhileStatement(node);
    case _tokentype.types._with:
      return this.parseWithStatement(node);
    case _tokentype.types.braceL:
      return this.parseBlock();
    case _tokentype.types.semi:
      return this.parseEmptyStatement(node);
    case _tokentype.types._export:
    case _tokentype.types._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
        if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
      }
      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);
    case _tokentype.types.at:
      this.next();
      return this.parseExpression();
    default:
      var maybeName = this.value,
          expr = this.parseExpression();
      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
  }
};

pp.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword == "break";
  this.next();
  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  for (var i = 0; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(_tokentype.types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
  return this.finishNode(node, "DoWhileStatement");
};
pp.parseForStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  this.expect(_tokentype.types.parenL);
  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
  var isLet = this.isLet();
  if (this.type === _tokentype.types._var || this.type === _tokentype.types._const || isLet) {
    var _init = this.startNode(),
        kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(_init, true, kind);
    this.finishNode(_init, "VariableDeclaration");
    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(kind !== "var" && _init.declarations[0].init)) return this.parseForIn(node, _init);
    return this.parseFor(node, _init);
  }
  var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
    this.checkPatternErrors(refDestructuringErrors, true);
    this.toAssignable(init);
    this.checkLVal(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return this.parseFor(node, init);
};

pp.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

pp.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
  this.next();
  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
    node.argument = this.parseExpression();this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};

pp.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(_tokentype.types.braceL);
  this.labels.push(switchLabel);
  for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {
    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
      var isCase = this.type === _tokentype.types._case;
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(_tokentype.types.colon);
    } else {
      if (!cur) this.unexpected();
      cur.consequent.push(this.parseStatement(true));
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp.parseThrowStatement = function (node) {
  this.next();
  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty = [];

pp.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === _tokentype.types._catch) {
    var clause = this.startNode();
    this.next();
    this.expect(_tokentype.types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true);
    this.expect(_tokentype.types.parenR);
    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
  return this.finishNode(node, "TryStatement");
};

pp.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp.parseWithStatement = function (node) {
  if (this.strict) this.raise(this.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp.parseLabeledStatement = function (node, maybeName, expr) {
  for (var i = 0; i < this.labels.length; ++i) {
    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label = this.labels[i];
    if (label.statementStart == node.start) {
      label.statementStart = this.start;
      label.kind = kind;
    } else break;
  }
  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
  node.body = this.parseStatement(true);
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp.parseBlock = function (allowStrict) {
  var node = this.startNode(),
      first = true,
      oldStrict = undefined;
  node.body = [];
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    var stmt = this.parseStatement(true);
    node.body.push(stmt);
    if (first && allowStrict && this.isUseStrict(stmt)) {
      oldStrict = this.strict;
      this.setStrict(this.strict = true);
    }
    first = false;
  }
  if (oldStrict === false) this.setStrict(false);
  return this.finishNode(node, "BlockStatement");
};
pp.parseFor = function (node, init) {
  node.init = init;
  this.expect(_tokentype.types.semi);
  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
  this.expect(_tokentype.types.semi);
  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp.parseForIn = function (node, init) {
  var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type);
};
pp.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl);
    if (this.eat(_tokentype.types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(_tokentype.types.comma)) break;
  }
  return node;
};

pp.parseVarId = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true);
};
pp.parseFunction = function (node, isStatement, allowExpressionBody) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
  var oldInGen = this.inGenerator;
  this.inGenerator = node.generator;
  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);
  this.inGenerator = oldInGen;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp.parseFunctionParams = function (node) {
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true);
};
pp.parseClass = function (node, isStatement) {
  this.next();
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(_tokentype.types.braceL);
  var decorators = [];
  while (!this.eat(_tokentype.types.braceR)) {
    if (this.eat(_tokentype.types.semi)) continue;
    if (this.type == _tokentype.types.at) {
      this.next();
      var expr = this.parseMaybeAssign(true);
      decorators.push(expr);
      continue;
    }
    var method = this.startNode();
    var isGenerator = this.eat(_tokentype.types.star);
    var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
    this.parsePropertyName(method);
    method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
    if (method["static"]) {
      if (isGenerator) this.unexpected();
      isGenerator = this.eat(_tokentype.types.star);
      this.parsePropertyName(method);
    }
    method.kind = "method";
    var isGetSet = false;
    if (!method.computed) {
      var key = method.key;

      if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) {
        isGetSet = true;
        method.kind = key.name;
        key = this.parsePropertyName(method);
      }
      if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
        method.kind = "constructor";
        hadConstructor = true;
      }
    }
    this.parseClassMethod(classBody, method, isGenerator);
    if (decorators.length) {
      var body = method.value.body.body;
      if (body) body.unshift.apply(body, decorators);
      decorators = [];
    }
    if (isGetSet) {
      var paramCount = method.kind === "get" ? 0 : 1;
      if (method.value.params.length !== paramCount) {
        var start = method.value.start;
        if (method.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
      }
      if (method.kind === "set" && method.value.params[0].type === "RestElement") this.raise(method.value.params[0].start, "Setter cannot use rest params");
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp.parseClassMethod = function (classBody, method, isGenerator) {
  method.value = this.parseMethod(isGenerator);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp.parseClassId = function (node, isStatement) {
  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
};

pp.parseClassSuper = function (node) {
  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
};
pp.parseExport = function (node) {
  this.next();
  if (this.eat(_tokentype.types.star)) {
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(_tokentype.types._default)) {
    var parens = this.type == _tokentype.types.parenL;
    var expr = this.parseMaybeAssign();
    var needsSemi = true;
    if (!parens && (expr.type == "FunctionExpression" || expr.type == "ClassExpression")) {
      needsSemi = false;
      if (expr.id) {
        expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
      }
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    if (this.eatContextual("from")) {
      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    } else {
      for (var i = 0; i < node.specifiers.length; i++) {
        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
          this.unexpected(node.specifiers[i].local.start);
        }
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp.shouldParseExportStatement = function () {
  return this.type.keyword || this.isLet();
};
pp.parseExportSpecifiers = function () {
  var nodes = [],
      first = true;
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.local = this.parseIdent(this.type === _tokentype.types._default);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes;
};
pp.parseImport = function (node) {
  this.next();
  if (this.type === _tokentype.types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp.parseImportSpecifiers = function () {
  var nodes = [],
      first = true;
  if (this.type === _tokentype.types.name) {
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(_tokentype.types.comma)) return nodes;
  }
  if (this.type === _tokentype.types.star) {
    var node = this.startNode();
    this.next();
    this.expectContextual("as");
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.imported = this.parseIdent(true);
    if (this.eatContextual("as")) {
      node.local = this.parseIdent();
    } else {
      node.local = node.imported;
      if (this.isKeyword(node.local.name)) this.unexpected(node.local.start);
      if (this.reservedWordsStrict.test(node.local.name)) this.raise(node.local.start, "The keyword '" + node.local.name + "' is reserved");
    }
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportSpecifier"));
  }
  return nodes;
};

},{"./identifier":"/src\\identifier.js","./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokencontext.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {


  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

exports.TokContext = TokContext;
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", true),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  f_expr: new TokContext("function", true)
};

exports.types = types;
var pp = _state.Parser.prototype;

pp.initialContext = function () {
  return [types.b_stat];
};

pp.braceIsBlock = function (prevType) {
  if (prevType === _tokentype.types.colon) {
    var _parent = this.curContext();
    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
  }
  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
  return !this.exprAllowed;
};

pp.updateContext = function (prevType) {
  var update = undefined,
      type = this.type;
  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
};
_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
  if (this.context.length == 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext() === types.f_expr) {
    this.context.pop();
    this.exprAllowed = false;
  } else if (out === types.b_tmpl) {
    this.exprAllowed = true;
  } else {
    this.exprAllowed = !out.isExpr;
  }
};

_tokentype.types.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

_tokentype.types.dollarBraceL.updateContext = function () {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

_tokentype.types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

_tokentype.types.incDec.updateContext = function () {};

_tokentype.types._function.updateContext = function () {
  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
  this.exprAllowed = false;
};

_tokentype.types.backQuote.updateContext = function () {
  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
  this.exprAllowed = false;
};
},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokenize.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var _whitespace = _dereq_("./whitespace");
var Token = function Token(p) {


  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
  if (p.options.ranges) this.range = [p.start, p.end];
};

exports.Token = Token;
var pp = _state.Parser.prototype;
var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";
pp.next = function () {
  if (this.options.onToken) this.options.onToken(new Token(this));

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp.getToken = function () {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
  var self = this;
  return { next: function next() {
      var token = self.getToken();
      return {
        done: token.type === _tokentype.types.eof,
        value: token
      };
    } };
};
pp.setStrict = function (strict) {
  this.strict = strict;
  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
  this.pos = this.start;
  if (this.options.locations) {
    while (this.pos < this.lineStart) {
      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
      --this.curLine;
    }
  }
  this.nextToken();
};

pp.curContext = function () {
  return this.context[this.context.length - 1];
};
pp.nextToken = function () {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) this.skipSpace();

  this.start = this.pos;
  if (this.options.locations) this.startLoc = this.curPosition();
  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);

  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
};

pp.readToken = function (code) {
  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

  return this.getTokenFromCode(code);
};

pp.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) return code;
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00;
};

pp.skipBlockComment = function () {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos,
      end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
  this.pos = end + 2;
  if (this.options.locations) {
    _whitespace.lineBreakG.lastIndex = start;
    var match = undefined;
    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};

pp.skipLineComment = function (startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
    ++this.pos;
    ch = this.input.charCodeAt(this.pos);
  }
  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};
pp.skipSpace = function () {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:case 8232:case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function (type, val) {
  this.end = this.pos;
  if (this.options.locations) this.endLoc = this.curPosition();
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};
//
//
pp.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) return this.readNumber(true);
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(_tokentype.types.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(_tokentype.types.dot);
  }
};

pp.readToken_slash = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;return this.readRegexp();
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.slash, 1);
};

pp.readToken_mult_modulo_exp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? _tokentype.types.star : _tokentype.types.modulo;
  if (this.options.ecmaVersion >= 7 && next === 42) {
    ++size;
    tokentype = _tokentype.types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) return this.finishOp(_tokentype.types.assign, size + 1);
  return this.finishOp(tokentype, size);
};

pp.readToken_pipe_amp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
};

pp.readToken_caret = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.bitwiseXOR, 1);
};

pp.readToken_plus_min = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(_tokentype.types.incDec, 2);
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.plusMin, 1);
};

pp.readToken_lt_gt = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
    return this.finishOp(_tokentype.types.bitShift, size);
  }
  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
    if (this.inModule) this.unexpected();
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) size = 2;
  return this.finishOp(_tokentype.types.relational, size);
};

pp.readToken_eq_excl = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(_tokentype.types.arrow);
  }
  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
};

pp.getTokenFromCode = function (code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;return this.finishToken(_tokentype.types.parenL);
    case 41:
      ++this.pos;return this.finishToken(_tokentype.types.parenR);
    case 59:
      ++this.pos;return this.finishToken(_tokentype.types.semi);
    case 44:
      ++this.pos;return this.finishToken(_tokentype.types.comma);
    case 91:
      ++this.pos;return this.finishToken(_tokentype.types.bracketL);
    case 93:
      ++this.pos;return this.finishToken(_tokentype.types.bracketR);
    case 123:
      ++this.pos;return this.finishToken(_tokentype.types.braceL);
    case 125:
      ++this.pos;return this.finishToken(_tokentype.types.braceR);
    case 58:
      ++this.pos;return this.finishToken(_tokentype.types.colon);
    case 63:
      ++this.pos;return this.finishToken(_tokentype.types.question);

    case 96:
      if (this.options.ecmaVersion < 6) break;
      ++this.pos;
      return this.finishToken(_tokentype.types.backQuote);

    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number
        ;
      }
    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
      return this.readNumber(false);
    case 34:case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();

    case 37:case 42:
      return this.readToken_mult_modulo_exp(code);

    case 124:case 38:
      return this.readToken_pipe_amp(code);

    case 94:
      return this.readToken_caret();

    case 43:case 45:
      return this.readToken_plus_min(code);

    case 60:case 62:
      return this.readToken_lt_gt(code);

    case 61:case 33:
      return this.readToken_eq_excl(code);

    case 126:
      return this.finishOp(_tokentype.types.prefix, 1);
    case 64:
      ++this.pos;return this.finishToken(_tokentype.types.at);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
function tryCreateRegexp(src, flags, throwErrorAt, parser) {
  try {
    return new RegExp(src, flags);
  } catch (e) {
    if (throwErrorAt !== undefined) {
      if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
      throw e;
    }
  }
}

var regexpUnicodeSupport = false; // !!tryCreateRegexp("\uffff", "u");

pp.readRegexp = function () {
  var _this = this;

  var escaped = undefined,
      inClass = undefined,
      start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
    var ch = this.input.charAt(this.pos);
    if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
    if (!escaped) {
      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
      escaped = ch === "\\";
    } else escaped = false;
    ++this.pos;
  }
  var content = this.input.slice(start, this.pos);
  ++this.pos;
  var mods = this.readWord1();
  var tmp = content;
  if (mods) {
    var validFlags = /^[gim]*$/;
    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;
    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    if (mods.indexOf("u") >= 0 && !regexpUnicodeSupport) {
      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
        code = Number("0x" + code);
        if (code > 0x10FFFF) _this.raise(start + offset + 3, "Code point out of bounds");
        return "x";
      });
      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
    }
  }
  var value = null;
  if (!isRhino) {
    tryCreateRegexp(tmp, undefined, start, this);
    value = tryCreateRegexp(content, mods);
  }
  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });
};
pp.readInt = function (radix, len) {
  var start = this.pos,
      total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos),
        val = undefined;
    if (code >= 97) val = code - 97 + 10 // a
    ;else if (code >= 65) val = code - 65 + 10 // A
    ;else if (code >= 48 && code <= 57) val = code - 48 // 0-9
    ;else val = Infinity;
    if (val >= radix) break;
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) return null;

  return total;
};

pp.readRadixNumber = function (radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
  return this.finishToken(_tokentype.types.num, val);
};
pp.readNumber = function (startsWithDot) {
  var start = this.pos,
      isFloat = false,
      octal = this.input.charCodeAt(this.pos) === 48;
  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
  var next = this.input.charCodeAt(this.pos);
  if (next === 46) {
    ++this.pos;
    this.readInt(10);
    isFloat = true;
    next = this.input.charCodeAt(this.pos);
  }
  if (next === 69 || next === 101) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) ++this.pos; // '+-'
    if (this.readInt(10) === null) this.raise(start, "Invalid number");
    isFloat = true;
  }
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

  var str = this.input.slice(start, this.pos),
      val = undefined;
  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
  return this.finishToken(_tokentype.types.num, val);
};
pp.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
      code = undefined;

  if (ch === 123) {
    if (this.options.ecmaVersion < 6) this.unexpected();
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
  } else {
    code = this.readHexChar(4);
  }
  return code;
};

function codePointToString(code) {
  if (code <= 0xFFFF) return String.fromCharCode(code);
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}

pp.readString = function (quote) {
  var out = "",
      chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) break;
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(_tokentype.types.string, out);
};
pp.readTmplToken = function () {
  var out = "",
      chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && this.type === _tokentype.types.template) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(_tokentype.types.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(_tokentype.types.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(_tokentype.types.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (_whitespace.isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n"; // 'n' -> '\n'
    case 114:
      return "\r"; // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2)); // 'x'
    case 117:
      return codePointToString(this.readCodePoint()); // 'u'
    case 116:
      return "\t"; // 't' -> '\t'
    case 98:
      return "\b"; // 'b' -> '\b'
    case 118:
      return "\u000b"; // 'v' -> '\u000b'
    case 102:
      return "\f"; // 'f' -> '\f'
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;++this.curLine;
      }
      return "";
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        if (octalStr !== "0" && (this.strict || inTemplate)) {
          this.raise(this.pos - 2, "Octal literal in strict mode");
        }
        this.pos += octalStr.length - 1;
        return String.fromCharCode(octal);
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function (len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) this.raise(codePos, "Bad character escape sequence");
  return n;
};
//
pp.readWord1 = function () {
  this.containsEsc = false;
  var word = "",
      first = true,
      chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (_identifier.isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) != 117) // "u"
        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function () {
  var word = this.readWord1();
  var type = _tokentype.types.name;
  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];
  return this.finishToken(type, word);
};

},{"./identifier":"/src\\identifier.js","./locutil":"/src\\locutil.js","./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokentype.js":[function(_dereq_,module,exports){
//
//
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TokenType = function TokenType(label) {
  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

exports.TokenType = TokenType;

function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true },
    startsExpr = { startsExpr: true };

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

  at: new TokenType("@", { beforeExpr: true, startsExpr: true }),
  //
  //
  //
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=", 6),
  relational: binop("</>", 7),
  bitShift: binop("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true })
};

exports.types = types;
var keywords = {};

exports.keywords = keywords;
function kw(name) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  options.keyword = name;
  keywords[name] = types["_" + name] = new TokenType(name, options);
}

kw("break");
kw("case", beforeExpr);
kw("catch");
kw("continue");
kw("debugger");
kw("default", beforeExpr);
kw("do", { isLoop: true, beforeExpr: true });
kw("else", beforeExpr);
kw("finally");
kw("for", { isLoop: true });
kw("function", startsExpr);
kw("if");
kw("return", beforeExpr);
kw("switch");
kw("throw", beforeExpr);
kw("try");
kw("var");
kw("const");
kw("while", { isLoop: true });
kw("with");
kw("new", { beforeExpr: true, startsExpr: true });
kw("this", startsExpr);
kw("super", startsExpr);
kw("class");
kw("extends", beforeExpr);
kw("export");
kw("import");
kw("null", startsExpr);
kw("true", startsExpr);
kw("false", startsExpr);
kw("in", { beforeExpr: true, binop: 7 });
kw("instanceof", { beforeExpr: true, binop: 7 });
kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

},{}],"/src\\util.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isArray = isArray;
exports.has = has;

function isArray(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
}
function has(obj, propName) {
  return Object.prototype.hasOwnProperty.call(obj, propName);
}

},{}],"/src\\whitespace.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isNewLine = isNewLine;
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
exports.lineBreak = lineBreak;
var lineBreakG = new RegExp(lineBreak.source, "g");

exports.lineBreakG = lineBreakG;

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

exports.nonASCIIwhitespace = nonASCIIwhitespace;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
exports.skipWhiteSpace = skipWhiteSpace;

},{}]},{},["/src\\index.js"])("/src\\index.js")
});
});

define("acorn/dist/acorn_loose",["require", "exports", "module", "./acorn"], function(require, exports, module) {

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).loose = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/src\\index.js":[function(_dereq_,module,exports){
"use strict";

module.exports = typeof acorn != 'undefined' ? acorn : require("./acorn");

},{}],"/src\\loose\\expression.js":[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _parseutil = _dereq_("./parseutil");

var _ = _dereq_("..");

var lp = _state.LooseParser.prototype;

lp.checkLVal = function (expr) {
  if (!expr) return expr;
  switch (expr.type) {
    case "Identifier":
    case "MemberExpression":
      return expr;

    case "ParenthesizedExpression":
      expr.expression = this.checkLVal(expr.expression);
      return expr;

    default:
      return this.dummyIdent();
  }
};

lp.parseExpression = function (noIn) {
  var start = this.storeCurrentPos();
  var expr = this.parseMaybeAssign(noIn);
  if (this.tok.type === _.tokTypes.comma) {
    var node = this.startNodeAt(start);
    node.expressions = [expr];
    while (this.eat(_.tokTypes.comma)) node.expressions.push(this.parseMaybeAssign(noIn));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

lp.parseParenExpression = function () {
  this.pushCx();
  this.expect(_.tokTypes.parenL);
  var val = this.parseExpression();
  this.popCx();
  this.expect(_.tokTypes.parenR);
  return val;
};

lp.parseMaybeAssign = function (noIn) {
  if (this.toks.isContextual("yield")) {
    var node = this.startNode();
    this.next();
    if (this.semicolon() || this.canInsertSemicolon() || this.tok.type != _.tokTypes.star && !this.tok.type.startsExpr) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(_.tokTypes.star);
      node.argument = this.parseMaybeAssign();
    }
    return this.finishNode(node, "YieldExpression");
  }

  var start = this.storeCurrentPos();
  var left = this.parseMaybeConditional(noIn);
  if (this.tok.type.isAssign) {
    var node = this.startNodeAt(start);
    node.operator = this.tok.value;
    node.left = this.tok.type === _.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  }
  return left;
};

lp.parseMaybeConditional = function (noIn) {
  var start = this.storeCurrentPos();
  var expr = this.parseExprOps(noIn);
  if (this.eat(_.tokTypes.question)) {
    var node = this.startNodeAt(start);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    node.alternate = this.expect(_.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

lp.parseExprOps = function (noIn) {
  var start = this.storeCurrentPos();
  var indent = this.curIndent,
      line = this.curLineStart;
  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line);
};

lp.parseExprOp = function (left, start, minPrec, noIn, indent, line) {
  if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) return left;
  var prec = this.tok.type.binop;
  if (prec != null && (!noIn || this.tok.type !== _.tokTypes._in)) {
    if (prec > minPrec) {
      var node = this.startNodeAt(start);
      node.left = left;
      node.operator = this.tok.value;
      this.next();
      if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
        node.right = this.dummyIdent();
      } else {
        var rightStart = this.storeCurrentPos();
        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);
      }
      this.finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, start, minPrec, noIn, indent, line);
    }
  }
  return left;
};

lp.parseMaybeUnary = function (sawUnary) {
  var start = this.storeCurrentPos(),
      expr = undefined;
  if (this.tok.type.prefix) {
    var node = this.startNode(),
        update = this.tok.type === _.tokTypes.incDec;
    if (!update) sawUnary = true;
    node.operator = this.tok.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(true);
    if (update) node.argument = this.checkLVal(node.argument);
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (this.tok.type === _.tokTypes.ellipsis) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(sawUnary);
    expr = this.finishNode(node, "SpreadElement");
  } else {
    expr = this.parseExprSubscripts();
    while (this.tok.type.postfix && !this.canInsertSemicolon()) {
      var node = this.startNodeAt(start);
      node.operator = this.tok.value;
      node.prefix = false;
      node.argument = this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(_.tokTypes.starstar)) {
    var node = this.startNodeAt(start);
    node.operator = "**";
    node.left = expr;
    node.right = this.parseMaybeUnary(false);
    return this.finishNode(node, "BinaryExpression");
  }

  return expr;
};

lp.parseExprSubscripts = function () {
  var start = this.storeCurrentPos();
  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);
};

lp.parseSubscripts = function (base, start, noCalls, startIndent, line) {
  for (;;) {
    if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) {
      if (this.tok.type == _.tokTypes.dot && this.curIndent == startIndent) --startIndent;else return base;
    }

    if (this.eat(_.tokTypes.dot)) {
      var node = this.startNodeAt(start);
      node.object = base;
      if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) node.property = this.dummyIdent();else node.property = this.parsePropertyAccessor() || this.dummyIdent();
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.tok.type == _.tokTypes.bracketL) {
      this.pushCx();
      this.next();
      var node = this.startNodeAt(start);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.popCx();
      this.expect(_.tokTypes.bracketR);
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.tok.type == _.tokTypes.parenL) {
      var node = this.startNodeAt(start);
      node.callee = base;
      node.arguments = this.parseExprList(_.tokTypes.parenR);
      base = this.finishNode(node, "CallExpression");
    } else if (this.tok.type == _.tokTypes.backQuote) {
      var node = this.startNodeAt(start);
      node.tag = base;
      node.quasi = this.parseTemplate();
      base = this.finishNode(node, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

lp.parseExprAtom = function () {
  var node = undefined;
  switch (this.tok.type) {
    case _.tokTypes._this:
    case _.tokTypes._super:
      var type = this.tok.type === _.tokTypes._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case _.tokTypes.name:
      if (this.tok.value == "async" && /^[ \t]*(function\b|\(|\w+[ \t]*=>)/.test(this.input.slice(this.tok.end))) {
        node = this.startNode();
        this.next();
        return this.parseExprAtom();
      }
      if (this.tok.value == "await" && /^[ \t]+[\w\x1f-\uffff]/.test(this.input.slice(this.tok.end))) {
        node = this.startNode();
        this.next();
        return this.parseExprAtom();
      }
      var start = this.storeCurrentPos();
      var id = this.parseIdent();
      return this.eat(_.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id]) : id;

    case _.tokTypes.regexp:
      node = this.startNode();
      var val = this.tok.value;
      node.regex = { pattern: val.pattern, flags: val.flags };
      node.value = val.value;
      node.raw = this.input.slice(this.tok.start, this.tok.end);
      this.next();
      return this.finishNode(node, "Literal");

    case _.tokTypes.num:case _.tokTypes.string:
      node = this.startNode();
      node.value = this.tok.value;
      node.raw = this.input.slice(this.tok.start, this.tok.end);
      this.next();
      return this.finishNode(node, "Literal");

    case _.tokTypes._null:case _.tokTypes._true:case _.tokTypes._false:
      node = this.startNode();
      node.value = this.tok.type === _.tokTypes._null ? null : this.tok.type === _.tokTypes._true;
      node.raw = this.tok.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case _.tokTypes.parenL:
      var parenStart = this.storeCurrentPos();
      this.next();
      var inner = this.parseExpression();
      this.expect(_.tokTypes.parenR);
      if (this.eat(_.tokTypes.arrow)) {
        return this.parseArrowExpression(this.startNodeAt(parenStart), inner.expressions || (_parseutil.isDummy(inner) ? [] : [inner]));
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(parenStart);
        par.expression = inner;
        inner = this.finishNode(par, "ParenthesizedExpression");
      }
      return inner;

    case _.tokTypes.bracketL:
      node = this.startNode();
      node.elements = this.parseExprList(_.tokTypes.bracketR, true);
      return this.finishNode(node, "ArrayExpression");

    case _.tokTypes.braceL:
      return this.parseObj();

    case _.tokTypes._class:
      return this.parseClass();

    case _.tokTypes._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case _.tokTypes._new:
      return this.parseNew();

    case _.tokTypes.backQuote:
      return this.parseTemplate();

    default:
      return this.dummyIdent();
  }
};

lp.parseNew = function () {
  var node = this.startNode(),
      startIndent = this.curIndent,
      line = this.curLineStart;
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(_.tokTypes.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    return this.finishNode(node, "MetaProperty");
  }
  var start = this.storeCurrentPos();
  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);
  if (this.tok.type == _.tokTypes.parenL) {
    node.arguments = this.parseExprList(_.tokTypes.parenR);
  } else {
    node.arguments = [];
  }
  return this.finishNode(node, "NewExpression");
};

lp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.tok.start, this.tok.end).replace(/\r\n?/g, "\n"),
    cooked: this.tok.value
  };
  this.next();
  elem.tail = this.tok.type === _.tokTypes.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

lp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.next();
    node.expressions.push(this.parseExpression());
    if (this.expect(_.tokTypes.braceR)) {
      curElt = this.parseTemplateElement();
    } else {
      curElt = this.startNode();
      curElt.value = { cooked: "", raw: "" };
      curElt.tail = true;
    }
    node.quasis.push(curElt);
  }
  this.expect(_.tokTypes.backQuote);
  return this.finishNode(node, "TemplateLiteral");
};

lp.parseObj = function () {
  var node = this.startNode();
  node.properties = [];
  this.pushCx();
  var indent = this.curIndent + 1,
      line = this.curLineStart;
  this.eat(_.tokTypes.braceL);
  if (this.curIndent + 1 < indent) {
    indent = this.curIndent;line = this.curLineStart;
  }
  while (!this.closes(_.tokTypes.braceR, indent, line)) {
    var prop = this.startNode(),
        isGenerator = undefined,
        start = undefined;
    if (this.options.ecmaVersion >= 6) {
      start = this.storeCurrentPos();
      prop.method = false;
      prop.shorthand = false;
      isGenerator = this.eat(_.tokTypes.star);
    }
    this.parsePropertyName(prop);
    if (_parseutil.isDummy(prop.key)) {
      if (_parseutil.isDummy(this.parseMaybeAssign())) this.next();this.eat(_.tokTypes.comma);continue;
    }
    if (this.eat(_.tokTypes.colon)) {
      prop.kind = "init";
      prop.value = this.parseMaybeAssign();
    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === _.tokTypes.parenL || this.tok.type === _.tokTypes.braceL)) {
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator);
    } else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" && !prop.computed && (prop.key.name === "get" || prop.key.name === "set") && (this.tok.type != _.tokTypes.comma && this.tok.type != _.tokTypes.braceR)) {
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
    } else {
      prop.kind = "init";
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(_.tokTypes.eq)) {
          var assign = this.startNodeAt(start);
          assign.operator = "=";
          assign.left = prop.key;
          assign.right = this.parseMaybeAssign();
          prop.value = this.finishNode(assign, "AssignmentExpression");
        } else {
          prop.value = prop.key;
        }
      } else {
        prop.value = this.dummyIdent();
      }
      prop.shorthand = true;
    }
    node.properties.push(this.finishNode(prop, "Property"));
    this.eat(_.tokTypes.comma);
  }
  this.popCx();
  if (!this.eat(_.tokTypes.braceR)) {
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }
  return this.finishNode(node, "ObjectExpression");
};

lp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(_.tokTypes.bracketL)) {
      prop.computed = true;
      prop.key = this.parseExpression();
      this.expect(_.tokTypes.bracketR);
      return;
    } else {
      prop.computed = false;
    }
  }
  var key = this.tok.type === _.tokTypes.num || this.tok.type === _.tokTypes.string ? this.parseExprAtom() : this.parseIdent();
  prop.key = key || this.dummyIdent();
};

lp.parsePropertyAccessor = function () {
  if (this.tok.type === _.tokTypes.name || this.tok.type.keyword) return this.parseIdent();
};

lp.parseIdent = function () {
  var name = this.tok.type === _.tokTypes.name ? this.tok.value : this.tok.type.keyword;
  if (!name) return this.dummyIdent();
  var node = this.startNode();
  this.next();
  node.name = name;
  return this.finishNode(node, "Identifier");
};

lp.initFunction = function (node) {
  node.id = null;
  node.params = [];
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
};
lp.toAssignable = function (node, binding) {
  if (!node || node.type == "Identifier" || node.type == "MemberExpression" && !binding) {} else if (node.type == "ParenthesizedExpression") {
    node.expression = this.toAssignable(node.expression, binding);
  } else if (this.options.ecmaVersion < 6) {
    return this.dummyIdent();
  } else if (node.type == "ObjectExpression") {
    node.type = "ObjectPattern";
    var props = node.properties;
    for (var i = 0; i < props.length; i++) {
      props[i].value = this.toAssignable(props[i].value, binding);
    }
  } else if (node.type == "ArrayExpression") {
    node.type = "ArrayPattern";
    this.toAssignableList(node.elements, binding);
  } else if (node.type == "SpreadElement") {
    node.type = "RestElement";
    node.argument = this.toAssignable(node.argument, binding);
  } else if (node.type == "AssignmentExpression") {
    node.type = "AssignmentPattern";
    delete node.operator;
  } else {
    return this.dummyIdent();
  }
  return node;
};

lp.toAssignableList = function (exprList, binding) {
  for (var i = 0; i < exprList.length; i++) {
    exprList[i] = this.toAssignable(exprList[i], binding);
  }return exprList;
};

lp.parseFunctionParams = function (params) {
  params = this.parseExprList(_.tokTypes.parenR);
  return this.toAssignableList(params, true);
};

lp.parseMethod = function (isGenerator) {
  var node = this.startNode();
  this.initFunction(node);
  node.params = this.parseFunctionParams();
  node.generator = isGenerator || false;
  node.expression = this.options.ecmaVersion >= 6 && this.tok.type !== _.tokTypes.braceL;
  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
  return this.finishNode(node, "FunctionExpression");
};

lp.parseArrowExpression = function (node, params) {
  this.initFunction(node);
  node.params = this.toAssignableList(params, true);
  node.expression = this.tok.type !== _.tokTypes.braceL;
  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
  return this.finishNode(node, "ArrowFunctionExpression");
};

lp.parseExprList = function (close, allowEmpty) {
  this.pushCx();
  var indent = this.curIndent,
      line = this.curLineStart,
      elts = [];
  this.next(); // Opening bracket
  while (!this.closes(close, indent + 1, line)) {
    if (this.eat(_.tokTypes.comma)) {
      elts.push(allowEmpty ? null : this.dummyIdent());
      continue;
    }
    var elt = this.parseMaybeAssign();
    if (_parseutil.isDummy(elt)) {
      if (this.closes(close, indent, line)) break;
      this.next();
    } else {
      elts.push(elt);
    }
    this.eat(_.tokTypes.comma);
  }
  this.popCx();
  if (!this.eat(close)) {
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }
  return elts;
};
},{"..":"/src\\index.js","./parseutil":"/src\\loose\\parseutil.js","./state":"/src\\loose\\state.js"}],"/src\\loose\\index.js":[function(_dereq_,module,exports){
//
//
//
//
//
//
//
"use strict";

exports.__esModule = true;
exports.parse_dammit = parse_dammit;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _ = _dereq_("..");

var acorn = _interopRequireWildcard(_);

var _state = _dereq_("./state");

_dereq_("./tokenize");

_dereq_("./statement");

_dereq_("./expression");

exports.LooseParser = _state.LooseParser;
exports.pluginsLoose = _state.pluginsLoose;

acorn.defaultOptions.tabSize = 4;

function parse_dammit(input, options) {
  var p = new _state.LooseParser(input, options);
  p.next();
  return p.parseTopLevel();
}

acorn.parse_dammit = parse_dammit;
acorn.LooseParser = _state.LooseParser;
acorn.pluginsLoose = _state.pluginsLoose;

},{"..":"/src\\index.js","./expression":"/src\\loose\\expression.js","./state":"/src\\loose\\state.js","./statement":"/src\\loose\\statement.js","./tokenize":"/src\\loose\\tokenize.js"}],"/src\\loose\\parseutil.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isDummy = isDummy;

function isDummy(node) {
  return node.name == "✖";
}

},{}],"/src\\loose\\state.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = _dereq_("..");
var pluginsLoose = {};

exports.pluginsLoose = pluginsLoose;

var LooseParser = (function () {
  function LooseParser(input, options) {


    this.toks = _.tokenizer(input, options);
    this.options = this.toks.options;
    this.input = this.toks.input;
    this.tok = this.last = { type: _.tokTypes.eof, start: 0, end: 0 };
    if (this.options.locations) {
      var here = this.toks.curPosition();
      this.tok.loc = new _.SourceLocation(this.toks, here, here);
    }
    this.ahead = []; // Tokens ahead
    this.context = []; // Indentation contexted
    this.curIndent = 0;
    this.curLineStart = 0;
    this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
    this.options.pluginsLoose = options.pluginsLoose || {};
    this.loadPlugins(this.options.pluginsLoose);
  }

  LooseParser.prototype.startNode = function startNode() {
    return new _.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);
  };

  LooseParser.prototype.storeCurrentPos = function storeCurrentPos() {
    return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;
  };

  LooseParser.prototype.startNodeAt = function startNodeAt(pos) {
    if (this.options.locations) {
      return new _.Node(this.toks, pos[0], pos[1]);
    } else {
      return new _.Node(this.toks, pos);
    }
  };

  LooseParser.prototype.finishNode = function finishNode(node, type) {
    node.type = type;
    node.end = this.last.end;
    if (this.options.locations) node.loc.end = this.last.loc.end;
    if (this.options.ranges) node.range[1] = this.last.end;
    return node;
  };

  LooseParser.prototype.dummyNode = function dummyNode(type) {
    var dummy = this.startNode();
    dummy.type = type;
    dummy.end = dummy.start;
    if (this.options.locations) dummy.loc.end = dummy.loc.start;
    if (this.options.ranges) dummy.range[1] = dummy.start;
    this.last = { type: _.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc };
    return dummy;
  };

  LooseParser.prototype.dummyIdent = function dummyIdent() {
    var dummy = this.dummyNode("Identifier");
    dummy.name = "✖";
    return dummy;
  };

  LooseParser.prototype.dummyString = function dummyString() {
    var dummy = this.dummyNode("Literal");
    dummy.value = dummy.raw = "✖";
    return dummy;
  };

  LooseParser.prototype.eat = function eat(type) {
    if (this.tok.type === type) {
      this.next();
      return true;
    } else {
      return false;
    }
  };

  LooseParser.prototype.isContextual = function isContextual(name) {
    return this.tok.type === _.tokTypes.name && this.tok.value === name;
  };

  LooseParser.prototype.eatContextual = function eatContextual(name) {
    return this.tok.value === name && this.eat(_.tokTypes.name);
  };

  LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon() {
    return this.tok.type === _.tokTypes.eof || this.tok.type === _.tokTypes.braceR || _.lineBreak.test(this.input.slice(this.last.end, this.tok.start));
  };

  LooseParser.prototype.semicolon = function semicolon() {
    return this.eat(_.tokTypes.semi);
  };

  LooseParser.prototype.expect = function expect(type) {
    if (this.eat(type)) return true;
    for (var i = 1; i <= 2; i++) {
      if (this.lookAhead(i).type == type) {
        for (var j = 0; j < i; j++) {
          this.next();
        }return true;
      }
    }
  };

  LooseParser.prototype.pushCx = function pushCx() {
    this.context.push(this.curIndent);
  };

  LooseParser.prototype.popCx = function popCx() {
    this.curIndent = this.context.pop();
  };

  LooseParser.prototype.lineEnd = function lineEnd(pos) {
    while (pos < this.input.length && !_.isNewLine(this.input.charCodeAt(pos))) ++pos;
    return pos;
  };

  LooseParser.prototype.indentationAfter = function indentationAfter(pos) {
    for (var count = 0;; ++pos) {
      var ch = this.input.charCodeAt(pos);
      if (ch === 32) ++count;else if (ch === 9) count += this.options.tabSize;else return count;
    }
  };

  LooseParser.prototype.closes = function closes(closeTok, indent, line, blockHeuristic) {
    if (this.tok.type === closeTok || this.tok.type === _.tokTypes.eof) return true
    ;
  };

  LooseParser.prototype.tokenStartsLine = function tokenStartsLine() {
    for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {
      var ch = this.input.charCodeAt(p);
      if (ch !== 9 && ch !== 32) return false;
    }
    return true;
  };

  LooseParser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  LooseParser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
    for (var _name in pluginConfigs) {
      var plugin = pluginsLoose[_name];
      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
      plugin(this, pluginConfigs[_name]);
    }
  };

  return LooseParser;
})();

exports.LooseParser = LooseParser;

},{"..":"/src\\index.js"}],"/src\\loose\\statement.js":[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _parseutil = _dereq_("./parseutil");

var _ = _dereq_("..");

var lp = _state.LooseParser.prototype;

lp.parseTopLevel = function () {
  var node = this.startNodeAt(this.options.locations ? [0, _.getLineInfo(this.input, 0)] : 0);
  node.body = [];
  while (this.tok.type !== _.tokTypes.eof) node.body.push(this.parseStatement());
  this.last = this.tok;
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

lp.parseStatement = function () {
  var starttype = this.tok.type,
      node = this.startNode(),
      kind = undefined;

  if (this.toks.isLet()) {
    starttype = _.tokTypes._var;
    kind = "let";
  }

  switch (starttype) {
    case _.tokTypes._break:case _.tokTypes._continue:
      this.next();
      var isBreak = starttype === _.tokTypes._break;
      if (this.semicolon() || this.canInsertSemicolon()) {
        node.label = null;
      } else {
        node.label = this.tok.type === _.tokTypes.name ? this.parseIdent() : null;
        this.semicolon();
      }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

    case _.tokTypes._debugger:
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");

    case _.tokTypes._do:
      this.next();
      node.body = this.parseStatement();
      node.test = this.eat(_.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();
      this.semicolon();
      return this.finishNode(node, "DoWhileStatement");

    case _.tokTypes._for:
      this.next();
      this.pushCx();
      this.expect(_.tokTypes.parenL);
      if (this.tok.type === _.tokTypes.semi) return this.parseFor(node, null);
      var isLet = this.toks.isLet();
      if (isLet || this.tok.type === _.tokTypes._var || this.tok.type === _.tokTypes._const) {
        var _init = this.parseVar(true, isLet ? "let" : this.tok.value);
        if (_init.declarations.length === 1 && (this.tok.type === _.tokTypes._in || this.isContextual("of"))) {
          return this.parseForIn(node, _init);
        }
        return this.parseFor(node, _init);
      }
      var init = this.parseExpression(true);
      if (this.tok.type === _.tokTypes._in || this.isContextual("of")) return this.parseForIn(node, this.toAssignable(init));
      return this.parseFor(node, init);

    case _.tokTypes._function:
      this.next();
      return this.parseFunction(node, true);

    case _.tokTypes._if:
      this.next();
      node.test = this.parseParenExpression();
      node.consequent = this.parseStatement();
      node.alternate = this.eat(_.tokTypes._else) ? this.parseStatement() : null;
      return this.finishNode(node, "IfStatement");

    case _.tokTypes._return:
      this.next();
      if (this.eat(_.tokTypes.semi) || this.canInsertSemicolon()) node.argument = null;else {
        node.argument = this.parseExpression();this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");

    case _.tokTypes._switch:
      var blockIndent = this.curIndent,
          line = this.curLineStart;
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.pushCx();
      this.expect(_.tokTypes.braceL);

      var cur = undefined;
      while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) {
        if (this.tok.type === _.tokTypes._case || this.tok.type === _.tokTypes._default) {
          var isCase = this.tok.type === _.tokTypes._case;
          if (cur) this.finishNode(cur, "SwitchCase");
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) cur.test = this.parseExpression();else cur.test = null;
          this.expect(_.tokTypes.colon);
        } else {
          if (!cur) {
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            cur.test = null;
          }
          cur.consequent.push(this.parseStatement());
        }
      }
      if (cur) this.finishNode(cur, "SwitchCase");
      this.popCx();
      this.eat(_.tokTypes.braceR);
      return this.finishNode(node, "SwitchStatement");

    case _.tokTypes._throw:
      this.next();
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");

    case _.tokTypes._try:
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.tok.type === _.tokTypes._catch) {
        var clause = this.startNode();
        this.next();
        this.expect(_.tokTypes.parenL);
        clause.param = this.toAssignable(this.parseExprAtom(), true);
        this.expect(_.tokTypes.parenR);
        clause.body = this.parseBlock();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(_.tokTypes._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) return node.block;
      return this.finishNode(node, "TryStatement");

    case _.tokTypes._var:
    case _.tokTypes._const:
      return this.parseVar(false, kind || this.tok.value);

    case _.tokTypes._while:
      this.next();
      node.test = this.parseParenExpression();
      node.body = this.parseStatement();
      return this.finishNode(node, "WhileStatement");

    case _.tokTypes._with:
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement();
      return this.finishNode(node, "WithStatement");

    case _.tokTypes.braceL:
      return this.parseBlock();

    case _.tokTypes.semi:
      this.next();
      return this.finishNode(node, "EmptyStatement");

    case _.tokTypes._class:
      return this.parseClass(true);

    case _.tokTypes._import:
      return this.parseImport();

    case _.tokTypes._export:
      return this.parseExport();
    case _.tokTypes.at:
      this.next();
      return this.parseExpression();

    default:
      var expr = this.parseExpression();
      if (_parseutil.isDummy(expr)) {
        this.next();
        if (this.tok.type === _.tokTypes.eof) return this.finishNode(node, "EmptyStatement");
        return this.parseStatement();
      } else if (starttype === _.tokTypes.name && expr.type === "Identifier" && this.eat(_.tokTypes.colon)) {
        node.body = this.parseStatement();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      } else {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
  }
};

lp.parseBlock = function () {
  var node = this.startNode();
  this.pushCx();
  this.expect(_.tokTypes.braceL);
  var blockIndent = this.curIndent,
      line = this.curLineStart;
  node.body = [];
  while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) node.body.push(this.parseStatement());
  this.popCx();
  this.eat(_.tokTypes.braceR);
  return this.finishNode(node, "BlockStatement");
};

lp.parseFor = function (node, init) {
  node.init = init;
  node.test = node.update = null;
  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.semi) node.test = this.parseExpression();
  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.parenR) node.update = this.parseExpression();
  this.popCx();
  this.expect(_.tokTypes.parenR);
  node.body = this.parseStatement();
  return this.finishNode(node, "ForStatement");
};

lp.parseForIn = function (node, init) {
  var type = this.tok.type === _.tokTypes._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.popCx();
  this.expect(_.tokTypes.parenR);
  node.body = this.parseStatement();
  return this.finishNode(node, type);
};

lp.parseVar = function (noIn, kind) {
  var node = this.startNode();
  node.kind = kind;
  this.next();
  node.declarations = [];
  do {
    var decl = this.startNode();
    decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();
    decl.init = this.eat(_.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
  } while (this.eat(_.tokTypes.comma));
  if (!node.declarations.length) {
    var decl = this.startNode();
    decl.id = this.dummyIdent();
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
  }
  if (!noIn) this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

lp.parseClass = function (isStatement) {
  var node = this.startNode();
  this.next();
  if (this.tok.type === _.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();else node.id = null;
  node.superClass = this.eat(_.tokTypes._extends) ? this.parseExpression() : null;
  node.body = this.startNode();
  node.body.body = [];
  this.pushCx();
  var indent = this.curIndent + 1,
      line = this.curLineStart;
  this.eat(_.tokTypes.braceL);
  var decorators = [];
  if (this.curIndent + 1 < indent) {
    indent = this.curIndent;line = this.curLineStart;
  }
  while (!this.closes(_.tokTypes.braceR, indent, line)) {
    if (this.semicolon()) continue;
    if (this.tok.type == _.tokTypes.at) {
      this.next();
      var expr = this.parseMaybeAssign(true);
      decorators.push(expr);
      continue;
    }
    var method = this.startNode(),
        isGenerator = undefined;
    if (this.options.ecmaVersion >= 6) {
      method["static"] = false;
      isGenerator = this.eat(_.tokTypes.star);
    }
    this.parsePropertyName(method);
    if (_parseutil.isDummy(method.key)) {
      if (_parseutil.isDummy(this.parseMaybeAssign())) this.next();this.eat(_.tokTypes.comma);continue;
    }
    if (method.key.type === "Identifier" && !method.computed && method.key.name === "static" && (this.tok.type != _.tokTypes.parenL && this.tok.type != _.tokTypes.braceL)) {
      method["static"] = true;
      isGenerator = this.eat(_.tokTypes.star);
      this.parsePropertyName(method);
    } else {
      method["static"] = false;
    }
    if (this.options.ecmaVersion >= 5 && method.key.type === "Identifier" && !method.computed && (method.key.name === "get" || method.key.name === "set") && this.tok.type !== _.tokTypes.parenL && this.tok.type !== _.tokTypes.braceL) {
      method.kind = method.key.name;
      this.parsePropertyName(method);
      method.value = this.parseMethod(false);
    } else {
      if (!method.computed && !method["static"] && !isGenerator && (method.key.type === "Identifier" && method.key.name === "constructor" || method.key.type === "Literal" && method.key.value === "constructor")) {
        method.kind = "constructor";
      } else {
        method.kind = "method";
      }
      method.value = this.parseMethod(isGenerator);
    }

    if (decorators.length) {
      var body = method.value.body.body;
      if (body) body.unshift.apply(body, decorators);
      decorators = [];
    }
    node.body.body.push(this.finishNode(method, "MethodDefinition"));
  }
  this.popCx();
  if (!this.eat(_.tokTypes.braceR)) {
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }
  this.semicolon();
  this.finishNode(node.body, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

lp.parseFunction = function (node, isStatement) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = this.eat(_.tokTypes.star);
  }
  if (this.tok.type === _.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();
  node.params = this.parseFunctionParams();
  node.body = this.parseBlock();
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

lp.parseExport = function () {
  var node = this.startNode();
  this.next();
  if (this.eat(_.tokTypes.star)) {
    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(_.tokTypes._default)) {
    var expr = this.parseMaybeAssign();
    if (expr.id) {
      switch (expr.type) {
        case "FunctionExpression":
          expr.type = "FunctionDeclaration";break;
        case "ClassExpression":
          expr.type = "ClassDeclaration";break;
      }
    }
    node.declaration = expr;
    this.semicolon();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.tok.type.keyword || this.toks.isLet()) {
    node.declaration = this.parseStatement();
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifierList();
    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

lp.parseImport = function () {
  var node = this.startNode();
  this.next();
  if (this.tok.type === _.tokTypes.string) {
    node.specifiers = [];
    node.source = this.parseExprAtom();
    node.kind = "";
  } else {
    var elt = undefined;
    if (this.tok.type === _.tokTypes.name && this.tok.value !== "from") {
      elt = this.startNode();
      elt.local = this.parseIdent();
      this.finishNode(elt, "ImportDefaultSpecifier");
      this.eat(_.tokTypes.comma);
    }
    node.specifiers = this.parseImportSpecifierList();
    node.source = this.eatContextual("from") && this.tok.type == _.tokTypes.string ? this.parseExprAtom() : this.dummyString();
    if (elt) node.specifiers.unshift(elt);
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

lp.parseImportSpecifierList = function () {
  var elts = [];
  if (this.tok.type === _.tokTypes.star) {
    var elt = this.startNode();
    this.next();
    if (this.eatContextual("as")) elt.local = this.parseIdent();
    elts.push(this.finishNode(elt, "ImportNamespaceSpecifier"));
  } else {
    var indent = this.curIndent,
        line = this.curLineStart,
        continuedLine = this.nextLineStart;
    this.pushCx();
    this.eat(_.tokTypes.braceL);
    if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
    while (!this.closes(_.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
      var elt = this.startNode();
      if (this.eat(_.tokTypes.star)) {
        elt.local = this.eatContextual("as") ? this.parseIdent() : this.dummyIdent();
        this.finishNode(elt, "ImportNamespaceSpecifier");
      } else {
        if (this.isContextual("from")) break;
        elt.imported = this.parseIdent();
        if (_parseutil.isDummy(elt.imported)) break;
        elt.local = this.eatContextual("as") ? this.parseIdent() : elt.imported;
        this.finishNode(elt, "ImportSpecifier");
      }
      elts.push(elt);
      this.eat(_.tokTypes.comma);
    }
    this.eat(_.tokTypes.braceR);
    this.popCx();
  }
  return elts;
};

lp.parseExportSpecifierList = function () {
  var elts = [];
  var indent = this.curIndent,
      line = this.curLineStart,
      continuedLine = this.nextLineStart;
  this.pushCx();
  this.eat(_.tokTypes.braceL);
  if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
  while (!this.closes(_.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
    if (this.isContextual("from")) break;
    var elt = this.startNode();
    elt.local = this.parseIdent();
    if (_parseutil.isDummy(elt.local)) break;
    elt.exported = this.eatContextual("as") ? this.parseIdent() : elt.local;
    this.finishNode(elt, "ExportSpecifier");
    elts.push(elt);
    this.eat(_.tokTypes.comma);
  }
  this.eat(_.tokTypes.braceR);
  this.popCx();
  return elts;
};

},{"..":"/src\\index.js","./parseutil":"/src\\loose\\parseutil.js","./state":"/src\\loose\\state.js"}],"/src\\loose\\tokenize.js":[function(_dereq_,module,exports){
"use strict";

var _ = _dereq_("..");

var _state = _dereq_("./state");

var lp = _state.LooseParser.prototype;

function isSpace(ch) {
  return ch < 14 && ch > 8 || ch === 32 || ch === 160 || _.isNewLine(ch);
}

lp.next = function () {
  this.last = this.tok;
  if (this.ahead.length) this.tok = this.ahead.shift();else this.tok = this.readToken();

  if (this.tok.start >= this.nextLineStart) {
    while (this.tok.start >= this.nextLineStart) {
      this.curLineStart = this.nextLineStart;
      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
    }
    this.curIndent = this.indentationAfter(this.curLineStart);
  }
};

lp.readToken = function () {
  for (;;) {
    try {
      this.toks.next();
      if (this.toks.type === _.tokTypes.dot && this.input.substr(this.toks.end, 1) === "." && this.options.ecmaVersion >= 6) {
        this.toks.end++;
        this.toks.type = _.tokTypes.ellipsis;
      }
      return new _.Token(this.toks);
    } catch (e) {
      if (!(e instanceof SyntaxError)) throw e;
      var msg = e.message,
          pos = e.raisedAt,
          replace = true;
      if (/unterminated/i.test(msg)) {
        pos = this.lineEnd(e.pos + 1);
        if (/string/.test(msg)) {
          replace = { start: e.pos, end: pos, type: _.tokTypes.string, value: this.input.slice(e.pos + 1, pos) };
        } else if (/regular expr/i.test(msg)) {
          var re = this.input.slice(e.pos, pos);
          try {
            re = new RegExp(re);
          } catch (e) {}
          replace = { start: e.pos, end: pos, type: _.tokTypes.regexp, value: re };
        } else if (/template/.test(msg)) {
          replace = { start: e.pos, end: pos,
            type: _.tokTypes.template,
            value: this.input.slice(e.pos, pos) };
        } else {
          replace = false;
        }
      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {
        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos;
      } else if (/character escape|expected hexadecimal/i.test(msg)) {
        while (pos < this.input.length) {
          var ch = this.input.charCodeAt(pos++);
          if (ch === 34 || ch === 39 || _.isNewLine(ch)) break;
        }
      } else if (/unexpected character/i.test(msg)) {
        pos++;
        replace = false;
      } else if (/regular expression/i.test(msg)) {
        replace = true;
      } else {
        throw e;
      }
      this.resetTo(pos);
      if (replace === true) replace = { start: pos, end: pos, type: _.tokTypes.name, value: "✖" };
      if (replace) {
        if (this.options.locations) replace.loc = new _.SourceLocation(this.toks, _.getLineInfo(this.input, replace.start), _.getLineInfo(this.input, replace.end));
        return replace;
      }
    }
  }
};

lp.resetTo = function (pos) {
  this.toks.pos = pos;
  var ch = this.input.charAt(pos - 1);
  this.toks.exprAllowed = !ch || /[\[\{\(,;:?\/*=+\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(pos - 10, pos));

  if (this.options.locations) {
    this.toks.curLine = 1;
    this.toks.lineStart = _.lineBreakG.lastIndex = 0;
    var match = undefined;
    while ((match = _.lineBreakG.exec(this.input)) && match.index < pos) {
      ++this.toks.curLine;
      this.toks.lineStart = match.index + match[0].length;
    }
  }
};

lp.lookAhead = function (n) {
  while (n > this.ahead.length) this.ahead.push(this.readToken());
  return this.ahead[n - 1];
};

},{"..":"/src\\index.js","./state":"/src\\loose\\state.js"}]},{},["/src\\loose\\index.js"])("/src\\loose\\index.js")
});
});

define("treehugger/tree",[], function(require, exports, module) {

function inRange(p, pos, exclusive) {
    if(p && p.sl <= pos.line && pos.line <= p.el) {
        if(p.sl < pos.line && pos.line < p.el)
            return true;
        else if(p.sl == pos.line && pos.line < p.el)
            return p.sc <= pos.col;
        else if(p.sl == pos.line && p.el === pos.line)
            return p.sc <= pos.col && pos.col <= p.ec + (exclusive ? 1 : 0);
        else if(p.sl < pos.line && p.el === pos.line)
            return pos.col <= p.ec + (exclusive ? 1 : 0);
    }
}
function Node() {
}

Node.prototype.toPrettyString = function(prefix) {
    prefix = prefix || "";
    return prefix + this.toString();
};

Node.prototype.setAnnotation = function(name, value) {
    this.annos = this.annos || {};
    this.annos[name] = value;
};

Node.prototype.getAnnotation = function(name) {
    return this.annos ? this.annos[name] : undefined;
};

Node.prototype.$pos = null;
Node.prototype.getPos = function() {
    if(this.annos && this.annos.pos) {
        return this.annos.pos;
    } else {
        var p = this.$pos;
        return p && {
            sl : p.start.line, sc : p.start.column,
            el : p.end.line, ec : p.end.column
        };
    }
};

Node.prototype.findNode = function(pos) {
    var p = this.getPos();
    if(inRange(p, pos)) {
        return this;
    } else {
        return null;
    }
};
function ConsNode(cons, children) {
    this.cons = cons;
    for(var i = 0; i < children.length; i++) {
        this[i] = children[i];
    }
    this.length = children.length;
}

ConsNode.prototype = new Node();
ConsNode.prototype.toString = function(prefix) {
    try {
        var s = this.cons + "(";
        for ( var i = 0; i < this.length; i++) {
            s += this[i].toString() + ",";
        }
        if (this.length > 0) {
            s = s.substring(0, s.length - 1);
        }
        return s + ")";
    } catch(e) {
        console.error("Something went wrong: ", this, e);
    }
};
ConsNode.prototype.toPrettyString = function(prefix) {
    prefix = prefix || "";
    try {
        if(this.length === 0) {
            return prefix + this.cons + "()";
        }
        if(this.length === 1 && (this[0] instanceof StringNode || this[0] instanceof NumNode)) {
            return prefix + this.cons + "(" + this[0].toString() + ")";
        }
        var s = prefix + this.cons + "(\n";
        for ( var i = 0; i < this.length; i++) {
            s += this[i].toPrettyString(prefix + "    ") + ",\n";
        }
        s = s.substring(0, s.length - 2);
        s += "\n";
        return s + prefix + ")";
    } catch(e) {
        console.error("Something went wrong: ", this, e);
    }
};
ConsNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof ConsNode) {
        if (this.cons === t.cons) {
            if (this.length === t.length) {
                for ( var i = 0; i < this.length; i++) {
                    if (!this[i].match(t[i], matches)) {
                        return false;
                    }
                }
                return matches;
            }
        }
    }
    return false;
};
ConsNode.prototype.build = function(values) {
    var children = [];
    for ( var i = 0; i < this.length; i++) {
        children.push(this[i].build(values));
    }
    return new ConsNode(this.cons, children);
};
ConsNode.prototype.toJSON = function() {
    var l = [];
    for(var i = 0; i < this.length; i++) {
        l.push(this[i]);
    }
    return {cons: this.cons, children: l};
};

ConsNode.prototype.getPos = function() {
    if (this.$pos && this.$pos.start && this.$pos.end) {
        var p = this.$pos;
        return {sl : p.start.line, sc : p.start.column,
                el : p.end.line, ec : p.end.column};
    }

    var nodePos = this.getAnnotation("pos");
    var result = nodePos
        ? {sl : nodePos.sl, sc : nodePos.sc, el : nodePos.el, ec : nodePos.ec}
        : {sl : Number.MAX_VALUE, sc : Number.MAX_VALUE, el : 0, ec : 0};
    
    var hasSl = false;
    var hasSc = false;
    
    for (var i = 0; i < this.length; i++) {
        var p = this[i].getPos();

        if (p) {
            if (p.sl < Number.MAX_VALUE && !hasSl) {
                result.sl = p.sl;
                hasSl = true;
            }
            if (p.sc < Number.MAX_VALUE && !hasSc) {
                result.sc = p.sc;
                hasSc = true;
            }
            result.el = p.el || result.el;
            result.ec = p.ec || result.ec;
        }
    }
    
    return result;
};

ConsNode.prototype.$pos = null;

ConsNode.prototype.findNode = function(pos) {
    var p = this.getPos();

    if(inRange(p, pos)) {
        for(var i = 0; i < this.length; i++) {
            var p2 = this[i].getPos();
            if(inRange(p2, pos)) {
                var node = this[i].findNode(pos);
                if(node)
                    return node instanceof StringNode ? this : node;
                else
                    return this[i];
            }
        }
    } else {
        return null;
    }
};
exports.cons = function(name, children) {
    return new ConsNode(name, children);
};
function ListNode (children) {
    for(var i = 0; i < children.length; i++)
        this[i] = children[i];
    this.length = children.length;
}

ListNode.prototype = new Node();

ListNode.prototype.toString = function() {
    var s = "[";
    for (var i = 0; i < this.length; i++)
        s += this[i].toString() + ",";
    if (this.length > 0)
        s = s.substring(0, s.length - 1);
    return s + "]";
};

ListNode.prototype.toPrettyString = function(prefix) {
    prefix = prefix || "";
    try {
        if(this.length === 0)
            return prefix + "[]";
        var s = prefix + "[\n";
        for ( var i = 0; i < this.length; i++)
            s += this[i].toPrettyString(prefix + "  ") + ",\n";
        s = s.substring(0, s.length - 2);
        s += "\n";
        return s + prefix + "]";
    } catch(e) {
        console.error("Something went wrong: ", this);
    }
};

ListNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof ListNode) {
        if (this.length === t.length) {
            for ( var i = 0; i < this.length; i++)
                if (!this[i].match(t[i], matches))
                    return false;
            return matches;
        }
        else
            return false;
    }
    else
        return false;
};

ListNode.prototype.build = function(values) {
    var children = [];
    for (var i = 0; i < this.length; i++)
        children.push(this[i].build(values));
    return new ListNode(children);
};

ListNode.prototype.getPos = ConsNode.prototype.getPos;
ListNode.prototype.findNode = ConsNode.prototype.findNode;
ListNode.prototype.forEach = function(fn) {
    for(var i = 0; i < this.length; i++) {
        fn.call(this[i], this[i], i);
    }
};
ListNode.prototype.isEmpty = function() {
    return this.length === 0;
};
ListNode.prototype.contains = function(el) {
    for(var i = 0; i < this.length; i++)
        if(el.match(this[i]))
            return true;
    return false;
};
ListNode.prototype.concat = function(l) {
    var ar = [];
    for(var i = 0; i < this.length; i++)
        ar.push(this[i]);
    for(i = 0; i < l.length; i++)
        ar.push(l[i]);
    return exports.list(ar);
};

ListNode.prototype.toJSON = function() {
    var l = [];
    for(var i = 0; i < this.length; i++)
        l.push(this[i]);
    return l;
};
ListNode.prototype.removeDuplicates = function() {
    var newList = [];
    lbl: for(var i = 0; i < this.length; i++) {
        for(var j = 0; j < newList.length; j++)
            if(newList[j].match(this[i]))
                continue lbl;
        newList.push(this[i]);
    }
    return new exports.list(newList);
};

ListNode.prototype.toArray = ListNode.prototype.toJSON;
exports.list = function(elements) {
    return new ListNode(elements);
};

function NumNode (value) {
    this.value = value;
}

NumNode.prototype = new Node();

NumNode.prototype.toString = function() {
    return ""+this.value;
};

NumNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof NumNode)
        return this.value === t.value ? matches : false;
    else
        return false;
};

NumNode.prototype.build = function(values) {
    return this;
};

exports.num = function(value) {
    return new NumNode(value);
};

function StringNode (value) {
    this.value = value;
}

StringNode.prototype = new Node();

StringNode.prototype.toString = function() {
    return '"' + this.value + '"';
};

StringNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof StringNode)
        return this.value === t.value ? matches : false;
    else
        return false;
};

StringNode.prototype.build = function(values) {
    return this;
};

exports.string = function(value) {
    return new StringNode(value);
};

function PlaceholderNode(id) {
    this.id = id;
}

PlaceholderNode.prototype = new Node();

PlaceholderNode.prototype.toString = function() {
    return this.id;
};

PlaceholderNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if(this.id === '_')
        return matches;
    if(matches[this.id]) // already bound
        return matches[this.id].match(t);
    else {
        matches[this.id] = t;
        return matches;
    }
};

PlaceholderNode.prototype.build = function(values) {
    return values[this.id];
};

exports.placeholder = function(n) {
    return new PlaceholderNode(n);
};


function parse (s) {
    var idx = 0;
    function accept (str) {
        for ( var i = 0; i < str.length && idx + i < s.length; i++) {
            if (str[i] != s[idx + i]) {
                return false;
            }
        }
        return i == str.length;
    }
    function lookAheadLetter() {
        return s[idx] >= 'a' && s[idx] <= 'z' || s[idx] >= 'A' && s[idx] <= 'Z' || s[idx] === '_' || s[idx] >= '0' && s[idx] <= '9';
    }
    function skipWhitespace () {
        while (idx < s.length && (s[idx] === " " || s[idx] === "\n" || s[idx] === "\r" || s[idx] === "\t")) {
            idx++;
        }
    }
    function parseInt () {
        var pos = idx;
        if (s[idx] >= '0' && s[idx] <= '9') {
            var ns = s[idx];
            idx++;
            while (idx < s.length && s[idx] >= '0' && s[idx] <= '9') {
                ns += s[idx];
                idx++;
            }
            skipWhitespace();
            return new NumNode(+ns, pos);
        } else {
            return null;
        }
    }
    function parseString () {
        var pos = idx;
        if (accept('"')) {
            var ns = "";
            idx++;
            while (!accept('"') || (accept('"') && s[idx - 1] == '\\')) {
                ns += s[idx];
                idx++;
            }
            var ns2 = '';
            for ( var i = 0; i < ns.length; i++) {
                if (ns[i] == "\\") {
                    i++;
                    switch (ns[i]) {
                        case 'n':
                            ns2 += "\n";
                            break;
                        case 't':
                            ns2 += "\t";
                            break;
                        default:
                            ns2 += ns[i];
                    }
                } else {
                    ns2 += ns[i];
                }
            }
            idx++;
            skipWhitespace();
            return new StringNode(ns2, pos);
        } else {
          return null;
        }
    }
    function parsePlaceholder() {
        var pos = idx;
        if (lookAheadLetter() && s[idx].toLowerCase() === s[idx]) {
            var ns = "";
            while (lookAheadLetter() && idx < s.length) {
                ns += s[idx];
                idx++;
            }
            skipWhitespace();
            return new PlaceholderNode(ns, pos);
        }
        else {
            return null;
        }
    }
    function parseList() {
        var pos = idx;
        if (accept('[')) {
            var items = [];
            idx++;
            skipWhitespace();
            while (!accept(']') && idx < s.length) {
                items.push(parseExp());
                if (accept(',')) {
                    idx++; // skip comma
                    skipWhitespace();
                }
            }
            idx++;
            skipWhitespace();
            return new ListNode(items, pos);
        }
        else {
            return null;
        }
    }
    function parseCons () {
        var pos = idx;
        var ns = "";
        while (!accept('(')) {
            ns += s[idx];
            idx++;
        }
        idx++; // skip (
        var items = [];
        while (!accept(')') && idx < s.length) {
            items.push(parseExp());
            if (accept(',')) {
                idx++; // skip comma
                skipWhitespace();
            }
        }
        idx++;
        skipWhitespace();
        return new ConsNode(ns, items, pos);
    }

    function parseExp() {
        var r = parseInt();
        if (r) return r;
        r = parseString();
        if (r) return r;
        r = parseList();
        if (r) return r;
        r = parsePlaceholder();
        if (r) return r;
        return parseCons();
    }
    return parseExp();
}

var parseCache = {};
function parseCached (s) {
    if(typeof s !== 'string') {
        return null;
    }
    if(s.length > 200) {
        return parse();
    }
    return parseCache[s] || (parseCache[s] = parse(s));
}

exports.Node = Node;
exports.ConsNode = ConsNode;
exports.ListNode = ListNode;
exports.NumNode = NumNode;
exports.StringNode = StringNode;
exports.PlaceholderNode = PlaceholderNode;
exports.parse = parseCached;
exports.inRange = inRange;

});

define("treehugger/js/parse",[], function(require, exports, module) {

var parser = require("acorn/dist/acorn_loose");
var tree = require('treehugger/tree');
exports.parse = function(s) {
    var result = parser.parse_dammit(
        s,
        {
            locations: true,
            ecmaVersion: 6,
            allowReturnOutsideFunction: true
        }
    );
    var node = exports.transform(result);
    if(result.error)
        node.setAnnotation("error", result.error);
    return node;
};


function setIdPos(n, resultNode) {
    if(n.loc) {        
        resultNode.setAnnotation("pos", {
            sl: n.loc.start.line, sc: n.loc.start.column,
            el: n.loc.end.line, ec: n.loc.end.column
        }); 
    }
    return resultNode;
}
function id(n, val) {
    var s = tree.string(val || (n && n.name) || "");
    s.$pos = n && n.loc;
    return s;
}

exports.transform = function transform(n) {
    if (!n) {
        return tree.cons("None", []);
    }
    if (Array.isArray(n)) {
        return tree.list(n.map(transform));
    }
    var nodeName = n.type;
    
    var resultNode;
    
    switch(nodeName) {
        case "Program":
            resultNode = tree.list(n.body.map(transform));
            break;
        case "VariableDeclaration":
            if (n.kind === "var") {
                var VarDecls = "VarDecls", VarDeclInit = "VarDeclInit", VarDecl = "VarDecl";
            } else if (n.kind === "let") {
                var VarDecls = "LetDecls", VarDeclInit = "LetDeclInit", VarDecl = "LetDecl";
            } else if (n.kind === "const") {
                var VarDecls = "ConstDecls", VarDeclInit = "ConstDeclInit", VarDecl = "ConstDecl";
            }
            resultNode = tree.cons(VarDecls, [tree.list(n.declarations.map(function(varNode) {
                var idNode = id(varNode.id);
                if(varNode.init)
                    return tree.cons(VarDeclInit, [idNode, transform(varNode.init)]);
                else
                    return tree.cons(VarDecl, [idNode]);
            }))]);
            break;
        case "ExpressionStatement":
            return transform(n.expression);
        case "CallExpression":
            resultNode = tree.cons("Call", [transform(n.callee), tree.list(n.arguments.map(transform))]);
            break;
        case "ReturnStatement":
            resultNode = tree.cons("Return", [transform(n.argument)]);
            break;
        case "NewExpression":
            resultNode = tree.cons("New", [transform(n.callee), tree.list(n.arguments.map(transform))]);
            break;
        case "ObjectExpression":
            resultNode = tree.cons("ObjectInit", [tree.list(n.properties.map(function(propInit) {
                var key = propInit.key;
                var result = tree.cons("PropertyInit", [id(key, key.name || key.value), transform(propInit.value)]);
                result.kind = propInit.kind;
                return result;
            }))]);
            break;
        case "ArrayExpression":
            resultNode = tree.cons("Array", [tree.list(n.elements.map(transform))]);
            break;
        case "ConditionalExpression":
            resultNode = tree.cons("TernaryIf", [transform(n.test), transform(n.consequent), transform(n.alternate)]);
            break;
        case "LabeledStatement":
            resultNode = tree.cons("Label", [id(n.label), transform(n.body)]);
            break;
        case "AssignmentExpression":
            if(n.operator != "=") {
                resultNode = tree.cons("OpAssign", [tree.string(n.operator[0]), transform(n.left), transform(n.right)]);
            } else {
                resultNode = tree.cons("Assign", [transform(n.left), transform(n.right)]);
            }
            break;
        case "MemberExpression":
            resultNode = n.computed
                ? tree.cons("Index", [transform(n.object), transform(n.property)])
                : tree.cons("PropAccess", [transform(n.object), id(n.property)]);
            break;
        case "Identifier":
            resultNode = tree.cons("Var", [id(n)]);
            break;
        case "ThisExpression":
            resultNode = tree.cons("Var", [tree.string("this")]);
            break;
        case "FunctionDeclaration":
            resultNode = tree.cons("Function", [id(n.id), tree.list(n.params.map(function(arg) {
                return setIdPos(arg, tree.cons("FArg", [id(arg)]));
            })), tree.list(n.body.body.map(transform))]);
            break;
        case "FunctionExpression":
            var funName = id(n.id);
            var fargs = tree.list(n.params.map(function(arg) {
                return setIdPos(arg, tree.cons("FArg", [id(arg)]));
            }));
            resultNode = tree.cons("Function", [funName, fargs, tree.list((n.body.body||[]).map(transform))]);
            break;
        case "LogicalExpression":
        case "BinaryExpression":
            resultNode = tree.cons("Op", [tree.string(n.operator), transform(n.left), transform(n.right)]);
            break;
        case "UpdateExpression":
        case "UnaryExpression":
            resultNode = tree.cons(n.prefix ? "PrefixOp" : "PostfixOp", [tree.string(n.operator), transform(n.argument)]);
            break;
        case "sub":
            resultNode = tree.cons("Index", [transform(n[1]), transform(n[2])]);
            break;
        case "ForStatement":
            resultNode = tree.cons("For", [transform(n.init), transform(n.test), transform(n.update), transform(n.body)]);
            break;
        case "ForInStatement":
            resultNode = tree.cons("ForIn", [transform(n.left), transform(n.right), transform(n.body)]);
            break;
        case "ForOfStatement":
            resultNode = tree.cons("ForOf", [transform(n.left), transform(n.right), transform(n.body)]);
            break;
        case "WhileStatement":
            resultNode = tree.cons("While", [transform(n.test), transform(n.body)]);
            break;
        case "DoWhileStatement": 
            resultNode = tree.cons("Do", [transform(n.body), transform(n.test)]);
            break;
        case "SwitchStatement":
            resultNode = tree.cons("Switch", [transform(n.discriminant), tree.list(n.cases.map(function(opt) {
                return tree.cons("Case", [transform(opt.test), tree.list(opt.consequent.map(transform))]);
            }))]);
            break;
        case "ContinueStatement":
            resultNode = tree.cons("Continue", [id(n.label)]);
            break;
        case "BreakStatement":
            resultNode = tree.cons("Break", [id(n.label)]);
            break;
        case "SequenceExpression":  // todo can we get rid of nesting?
            resultNode = n.expressions.reduceRight(function(a, b) {                
                return a ? tree.cons("Seq", [transform(b), a]) : transform(b);
            }, "");
            break;
        case "IfStatement":
            resultNode = tree.cons("If", [transform(n.test), transform(n.consequent), transform(n.alternate)]);
            break;
        case "EmptyStatement":
        case "BlockStatement":
            resultNode = tree.cons("Block", [tree.list(n.body ? n.body.map(transform) : [])]);
            break;
        case "ThrowStatement":
            resultNode = tree.cons("Throw", [transform(n.argument)]);
            break;
        case "DebuggerStatement":
            resultNode = tree.cons("Debugger", [transform(n.argument)]);
            break;
        case "TryStatement":
            resultNode = tree.cons("Try", [tree.list(n.block.body.map(transform)),
                tree.list(n.handler ? [tree.cons("Catch", [
                    id(n.handler.param), tree.list(n.handler.body.body.map(transform))
                ])] : []),
                n.finalizer ? tree.list(n.finalizer.body.map(transform)) : tree.cons("None", [])
            ]);
            break;
        case "WithStatement":
            resultNode = tree.cons("With", [transform(n.object), tree.list((n.body.body||[]).map(transform))]);
            break;
        case "Literal":
            var litType = typeof n.value;
            if (litType == "number") {
                resultNode = tree.cons("Num", [id(n, n.raw)]);
            } else if (litType == "string") {
                resultNode = tree.cons("String", [id(n, n.value)]);
            } else {
                var val = n.raw;
                if (val[0] == "/") {
                    var i = val.lastIndexOf("/");
                    resultNode = tree.cons("RegExp", [tree.string(val.slice(1, i)), tree.string(val.substr(i + 1))]);
                } else {
                    resultNode = tree.cons("Var", [tree.string(n.value + "")]);
                }
            }
            break;
        case "ERROR":
            resultNode = tree.cons("ERROR", []);
            break;
        case "ArrowFunctionExpression":
            resultNode = tree.cons("Arrow", [tree.list(n.params.map(function(arg) {
                return setIdPos(arg, tree.cons("FArg", [id(arg)]));
            })), tree.list(n.body.body ? n.body.body.map(transform) : transform(n.body))]);
            break;
        case "YieldExpression":
            resultNode = tree.cons("Yield", [transform(n.argument)]);
            break; 
        case "ImportDeclaration":
            resultNode = tree.cons("ImportDecls", [
                tree.list(n.specifiers.map(transform)),
                transform(n.source)
            ]);
            break;
        case "ImportSpecifier":
            resultNode = tree.cons("ImportDecl", [transform(n.id), transform(n.name)]);
            break;
        case "ExportSpecifier":
            resultNode = tree.cons("ExporDecl", [transform(n.id), transform(n.name)]);
            break;
        case "ImportBatchSpecifier":
            resultNode = tree.cons("ImportBatchDecl", [transform(n.name)]);
            break;
        case "ExportDeclaration":
            resultNode = tree.cons("ExportDecl", [
                n.default ? tree.list([tree.cons("Default", [])]) : tree.list([]),
                n.declaration ? transform(n.declaration) : transform(n.specifiers),
                transform(n.source)
            ]);
            break;
        case "SpreadElement":
            resultNode = tree.cons("Spread", [transform(n.argument)]);
            break;
        case "ArrayPattern":
            resultNode = tree.cons("ArrayPattern", transform(n.elements));
            break;
        case "ClassDeclaration":
            resultNode = tree.cons("Class", [id(n.id), id(n.superClass), transform(n.body)]);
            break;
        case "ClassBody":
            resultNode = tree.list(transform(n.body));
            break;
        case "MethodDefinition":
            resultNode = tree.cons("Method", [id(n.key), transform(n.value)]);
            break;
        case "ComprehensionBlock":
        case "ComprehensionExpression":
        default:
            resultNode = tree.cons(tree.string(nodeName), [tree.string(JSON.stringify(n, function(key, val) {
                if (key !== "loc") 
                    return val;
            }, 4))]);
    }

    resultNode.setAnnotation("origin", n);
    resultNode.$pos = n.loc;
    return resultNode;
};
});

define("treehugger/traverse",[], function(require, exports, module) {

var tree = require('treehugger/tree');

if (!Function.prototype.curry) {
    Function.prototype.curry = function() {
        var fn = this,
            args = Array.prototype.slice.call(arguments);
        return function() {
            return fn.apply(this, args.concat(Array.prototype.slice.call(arguments)));
        };
    };
}

function normalizeArgs(args) {
    if (args.length === 1 && args[0].apply) { // basic, one function, shortcut!
        return args[0];
    }
    args = Array.prototype.slice.call(args, 0);
    if (args[0] && Object.prototype.toString.call(args[0]) === '[object Array]') {
        args = args[0];
    }
    return function normalizeArgsHelper() {
        var result;
        for (var i = 0; i < args.length; i++) {
            if (typeof args[i] === 'string') {
                var parsedPattern = tree.parse(args[i]);
                var bindings = parsedPattern.match(this);
                if (bindings) {
                    while (args[i + 1]) {
                        if (args[i + 1].apply)
                            break;
                        i++;
                    }
                    if (args[i + 1] && args[i + 1].apply) {
                        result = args[i + 1].call(this, bindings, this);
                        i++;
                    }
                    else
                        result = this;
                    if (result)
                        return result;
                }
                else if (args[i + 1] && args[i + 1].apply)
                    i++;
            }
            else if (args[i].apply) {
                result = args[i].call(this, this);
                if (result)
                    return result;
            }
            else
                throw Error("Invalid argument: ", args[i]);
        }
        return false;
    };
}

exports.traverseAll = function(fn) {
    var result, i;
    fn = normalizeArgs(arguments);
    if (this instanceof tree.ConsNode || this instanceof tree.ListNode) {
        for (i = 0; i < this.length; i++) {
            result = fn.call(this[i]);
            if (!result)
                return false;
        }
    }
    return this;
};
function seq() {
    var fn;
    var t = this;
    for (var i = 0; i < arguments.length; i++) {
        fn = arguments[i];
        t = fn.call(t);
        if (!t)
            return false;
    }
    return this;
}
exports.attempt = function(fn) {
    fn = normalizeArgs(arguments);
    var result = fn.call(this);
    return !result ? this : result;
};

exports.debug = function(pretty) {
    console.log(pretty ? this.toPrettyString("") : this.toString());
    return this;
};
function traverseTopDown(fn) {
    var result, i;
    result = fn.call(this);
    if(result)
        return result;
    if (this instanceof tree.ConsNode || this instanceof tree.ListNode) {
        for (i = 0; i < this.length; i++) {
            traverseTopDown.call(this[i], fn);
        }
    }
    return this;
}

exports.traverseTopDown = function(fn) {
    fn = normalizeArgs(arguments);
    return traverseTopDown.call(this, fn);
};
exports.traverseUp = function(fn) {
    fn = normalizeArgs(arguments);
    var result = fn.call(this);
    if(result)
        return result;
    if (!this.parent)
        return false;
    return this.parent.traverseUp(fn);
};

exports.collectTopDown = function(fn) {
    fn = normalizeArgs(arguments);
    var results = [];
    this.traverseTopDown(function() {
        var r = fn.call(this);
        if (r) {
            results.push(r);
        }
        return r;
    });
    return tree.list(results);
};

exports.map = function(fn) {
    fn = normalizeArgs(arguments);
    var result, results = [];
    for (var i = 0; i < this.length; i++) {
        result = fn.call(this[i], this[i]);
        if (result) {
            results.push(result);
        }
        else {
            throw Error("Mapping failed: ", this[i]);
        }
    }
    return tree.list(results);
};

exports.each = function(fn) {
    fn = normalizeArgs(arguments);
    for (var i = 0; i < this.length; i++) {
        fn.call(this[i], this[i]);
    }
};
exports.filter = function(fn) {
    fn = normalizeArgs(arguments);
    var matching = [];
    this.forEach(function(el) {
        var result = fn.call(el);
        if (result) {
            matching.push(result);
        }
    });
    return tree.list(matching);
};

exports.rewrite = function(fn) {
    fn = normalizeArgs(arguments);
    return fn.call(this);
};

exports.isMatch = function(pattern) {
    return !!this.rewrite(pattern);
};
for (var p in exports) {
    if (exports.hasOwnProperty(p)) {
        tree.Node.prototype[p] = exports[p];
    }
}

exports.addParentPointers = function(node) {
    return node.traverseTopDown(function() {
        var that = this;
        this.traverseAll(function() {
            this.parent = that;
            return this;
        });
    });
};

});

define("plugins/c9.ide.language/base_handler",[], function(require, exports, module) {

module.exports = {
    HANDLES_ANY: 0,
    HANDLES_EDITOR: 1,
    HANDLES_IMMEDIATE: 2,
    HANDLES_EDITOR_AND_IMMEDIATE: 3,
    language: null,
    path: null,
    workspaceDir: null,
    doc: null,
    $disableZeroLengthCompletion: false,
    $recacheCompletionLength: null,
    isFeatureEnabled: function(name) {
        return !disabledFeatures[name];
    },
    $getIdentifierRegex: function() {
        return null;
    },
    getEmitter: function(overridePath) {
        throw new Error("getEmitter() is not available yet, please call after init()");
    },
    handlesLanguage: function(language) {
        throw new Error("base_handler.handlesLanguage() is not overridden");
    },
    handlesEditor: function() {
        return this.HANDLES_EDITOR;
    },
    getMaxFileSizeSupported: function() {
        return 10 * 1000 * 80;
    },
    getIdentifierRegex: function() {
        return null;
    },
    getCompletionRegex: function() {
        return null;
    },
    getTooltipRegex: function() {
        return null;
    },
    getCacheCompletionRegex: function() {
        return null;
    },
    parse: function(docValue, options, callback) {
        callback();
    },
    findNode: function(ast, pos, callback) {
        callback();
    },
    getPos: function(node, callback) {
        callback();
    },
    init: function(callback) {
        callback();
    },
    onUpdate: function(doc, callback) {
        callback();
    },
    onDocumentOpen: function(path, doc, oldPath, callback) {
        callback();
    },
    onDocumentClose: function(path, callback) {
        callback();
    },
    onCursorMove: function(doc, ast, cursorPos, options, callback) {
        callback();
    },
    tooltip: function(doc, ast, cursorPos, options, callback) {
        callback();
    },
    highlightOccurrences: function(doc, ast, cursorPos, options, callback) {
        callback();
    },
    getRefactorings: function(doc, ast, cursorPos, options, callback) {
        callback();
    },
    outline: function(doc, ast, callback) {
        callback();
    },
    hierarchy: function(doc, cursorPos, callback) {
        callback();
    },
    complete: function(doc, ast, pos, options, callback) {
        callback();
    },
    predictNextCompletion: function(doc, ast, pos, options, callback) {
        callback();
    },
    analyze: function(doc, ast, options, callback) {
        callback();
    },
    getRenamePositions: function(doc, ast, pos, options, callback) {
        callback();
    },
    onRenameBegin: function(doc, callback) {
        callback();
    },
    commitRename: function(doc, oldName, newName, isGeneric, callback) {
        callback();
    },
    onRenameCancel: function(callback) {
        callback();
    },
    codeFormat: function(doc, callback) {
        callback();
    },
    jumpToDefinition: function(doc, ast, pos, options, callback) {
        callback();
    },
    getQuickfixes: function(doc, ast, pos, options, callback) {
        callback();
    },
    getInspectExpression: function(doc, ast, pos, options, callback) {
        callback();
    }
};
for (var f in module.exports) {
    if (typeof module.exports[f] === "function")
        module.exports[f].base_handler = true;
}

});

define("plugins/c9.ide.test.mocha/mocha_outline_worker",[], function(require, exports, module) {

var parser = require("treehugger/js/parse");
var traverse = require("treehugger/traverse");
var baseLanguageHandler = require("plugins/c9.ide.language/base_handler");

var handler = module.exports = Object.create(baseLanguageHandler);

handler.init = function() {
    handler.sender.on("mocha_outline", function(e) {
        var code = e.data.code.replace(/^(#!.*\n)/, "//$1");
        var ast = parser.parse(code);
        
        handler.sender.emit("mocha_outline_result", {
            id: e.data.id, // Some unique id for this request
            result: getTestCases(ast)
        });
    });
};

handler.handlesLanguage = function() {
    return false;
};
function parseBDD(ast, items) {
    ast.traverseTopDown( 
        'Call(Var("before"), _)', function(b, node) {
            items.push({
                label: "before all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("beforeEach"), _)', function(b, node) {
            items.push({
                label: "before each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("after"), _)', function(b, node) {
            items.push({
                label: "after all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("afterEach"), _)', function(b, node) {
            items.push({
                label: "before each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("it"), [String(description), _])', function(b, node) {
            items.push({
                label: b.description.value,
                kind: "it",
                type: "test",
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return true;
        },
        'Call(PropAccess(Var("it"), "only"), [String(description), _])', function(b, node) {
            items.push({
                label: b.description.value,
                kind: "it",
                type: "test",
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("describe"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseBDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        },
        'Call(PropAccess(Var("describe"), "only"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseBDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        },
        'Call(Var("context"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseBDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        },
        'Call(PropAccess(Var("context"), "only"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseBDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        }
    );
    
    return items;
}

function parseTDD(ast, items) {
    ast.traverseTopDown( 
        'Call(Var("setup"), _)', function(b, node) {
            items.push({
                label: "setup",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("teardown"), _)', function(b, node) {
            items.push({
                label: "teardown",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("suiteSetup"), _)', function(b, node) {
            items.push({
                label: "suite setup",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("suiteTeardown"), _)', function(b, node) {
            items.push({
                label: "suite teardown",
                type: "prepare",
                pos: node.getPos()
            });
        },
        'Call(Var("test"), [String(description), _])', function(b, node) {
            items.push({
                label: b.description.value,
                type: "test",
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("suite"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseTDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        }
    );
    
    return items;
}

function parseExports(ast, items) {
    ast.traverseTopDown(
        'Assign(PropAccess(Var("module"), "exports"), body)', function(b) {
            parseExports(b.body, items); 
            return true;
        },
        'PropertyInit("before", _)', function(b, node) {
            items.push({
                label: "before all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'PropertyInit("after", _)', function(b, node) {
            items.push({
                label: "after all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'PropertyInit("beforeEach", _)', function(b, node) {
            items.push({
                label: "before each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'PropertyInit("afterEach", _)', function(b, node) {
            items.push({
                label: "after each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'PropertyInit(name, ObjectInit(body))', function(b, node) {
           items.push({
                label: b.name.value,
                items: parseExports(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.name.getPos(),
                pos: node.getPos()
            });
           return true;
        },
        'PropertyInit(name, Function(_))', function(b, node) {
           items.push({
                label: b.name.value,
                type: "test",
                selpos: b.name.getPos(),
                pos: node.getPos()
            });
            return true;
        }
    );
    
    return items;
}

function parseQUnit(ast, items) {
    var context = items;
    
    ast.traverseTopDown( 
        'Call(Var("before"), _)', function(b, node) {
            context.push({
                label: "before all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("after"), _)', function(b, node) {
            context.push({
                label: "after all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("beforeEach"), _)', function(b, node) {
            context.push({
                label: "before each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("afterEach"), _)', function(b, node) {
            context.push({
                label: "after each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("test"), [String(description), _])', function(b, node) {
            context.push({
                label: b.description.value,
                type: "test",
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("suite"), [String(description)])', function(b, node) {
            context.push({
                label: b.description.value,
                items: context = [],
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        }
    );
}

function getTestCases(ast) {
    var items = [];
    ast.traverseTopDown(
        'Call(Var("describe"), [_, body])', function(b, node) {
            parseBDD(ast, items);
            return true;
        },
        'Call(Var("suite"), [_, body])', function(b, node) {
            parseTDD(ast, items);
            return true;
        },
        'Assign(PropAccess(Var("module"), "exports"), body)', function(b) {
            parseExports(b.body, items);
            return true;
        },
        'Call(Var("suite"), [_])', function(b, node) {
            parseQUnit(ast, items);
            return true;
        }
    );
    
    return items;
}

});

define("ace/lib/es5-shim",[], function(require, exports, module) {

//
//
function Empty() {}

if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) { // .length is 1
        var target = this;
        if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
        }
        var args = slice.call(arguments, 1); // for normal call
        var bound = function () {

            if (this instanceof bound) {
                var result = target.apply(
                    this,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );

            }

        };
        if(target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }
        //
        return bound;
    };
}
var call = Function.prototype.call;
var prototypeOfArray = Array.prototype;
var prototypeOfObject = Object.prototype;
var slice = prototypeOfArray.slice;
var _toString = call.bind(prototypeOfObject.toString);
var owns = call.bind(prototypeOfObject.hasOwnProperty);
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}

//
//
if ([1,2].splice(0).length != 2) {
    if(function() { // test IE < 9 to splice bug - see issue #138
        function makeArray(l) {
            var a = new Array(l+2);
            a[0] = a[1] = 0;
            return a;
        }
        var array = [], lengthBefore;
        
        array.splice.apply(array, makeArray(20));
        array.splice.apply(array, makeArray(26));

        lengthBefore = array.length; //46
        array.splice(5, 0, "XXX"); // add one element

        lengthBefore + 1 == array.length

        if (lengthBefore + 1 == array.length) {
            return true;// has right splice implementation without bugs
        }
    }()) {//IE 6/7
        var array_splice = Array.prototype.splice;
        Array.prototype.splice = function(start, deleteCount) {
            if (!arguments.length) {
                return [];
            } else {
                return array_splice.apply(this, [
                    start === void 0 ? 0 : start,
                    deleteCount === void 0 ? (this.length - start) : deleteCount
                ].concat(slice.call(arguments, 2)))
            }
        };
    } else {//IE8
        Array.prototype.splice = function(pos, removeCount){
            var length = this.length;
            if (pos > 0) {
                if (pos > length)
                    pos = length;
            } else if (pos == void 0) {
                pos = 0;
            } else if (pos < 0) {
                pos = Math.max(length + pos, 0);
            }

            if (!(pos+removeCount < length))
                removeCount = length - pos;

            var removed = this.slice(pos, pos+removeCount);
            var insert = slice.call(arguments, 2);
            var add = insert.length;            
            if (pos === length) {
                if (add) {
                    this.push.apply(this, insert);
                }
            } else {
                var remove = Math.min(removeCount, length - pos);
                var tailOldPos = pos + remove;
                var tailNewPos = tailOldPos + add - remove;
                var tailCount = length - tailOldPos;
                var lengthAfterRemove = length - remove;

                if (tailNewPos < tailOldPos) { // case A
                    for (var i = 0; i < tailCount; ++i) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } else if (tailNewPos > tailOldPos) { // case B
                    for (i = tailCount; i--; ) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } // else, add == remove (nothing to do)

                if (add && pos === lengthAfterRemove) {
                    this.length = lengthAfterRemove; // truncate array
                    this.push.apply(this, insert);
                } else {
                    this.length = lengthAfterRemove + add; // reserves space
                    for (i = 0; i < add; ++i) {
                        this[pos+i] = insert[i];
                    }
                }
            }
            return removed;
        };
    }
}
if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
        return _toString(obj) == "[object Array]";
    };
}
var boxedString = Object("a"),
    splitString = boxedString[0] != "a" || !(0 in boxedString);

if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                fun.call(thisp, self[i], i, object);
            }
        }
    };
}
if (!Array.prototype.map) {
    Array.prototype.map = function map(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            result = Array(length),
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self)
                result[i] = fun.call(thisp, self[i], i, object);
        }
        return result;
    };
}
if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                    object,
            length = self.length >>> 0,
            result = [],
            value,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self) {
                value = self[i];
                if (fun.call(thisp, value, i, object)) {
                    result.push(value);
                }
            }
        }
        return result;
    };
}
if (!Array.prototype.every) {
    Array.prototype.every = function every(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, object)) {
                return false;
            }
        }
        return true;
    };
}
if (!Array.prototype.some) {
    Array.prototype.some = function some(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, object)) {
                return true;
            }
        }
        return false;
    };
}
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        if (!length && arguments.length == 1) {
            throw new TypeError("reduce of empty array with no initial value");
        }

        var i = 0;
        var result;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i++];
                    break;
                }
                if (++i >= length) {
                    throw new TypeError("reduce of empty array with no initial value");
                }
            } while (true);
        }

        for (; i < length; i++) {
            if (i in self) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        }

        return result;
    };
}
if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        if (!length && arguments.length == 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
        }

        var result, i = length - 1;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i--];
                    break;
                }
                if (--i < 0) {
                    throw new TypeError("reduceRight of empty array with no initial value");
                }
            } while (true);
        }

        do {
            if (i in this) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        } while (i--);

        return result;
    };
}
if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    };
}
if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }
        var i = length - 1;
        if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
        }
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
                return i;
            }
        }
        return -1;
    };
}

//
//
if (!Object.getPrototypeOf) {
    Object.getPrototypeOf = function getPrototypeOf(object) {
        return object.__proto__ || (
            object.constructor ?
            object.constructor.prototype :
            prototypeOfObject
        );
    };
}
if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
                         "non-object: ";
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT + object);
        if (!owns(object, property))
            return;

        var descriptor, getter, setter;
        descriptor =  { enumerable: true, configurable: true };
        if (supportsAccessors) {
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;

            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            object.__proto__ = prototype;

            if (getter || setter) {
                if (getter) descriptor.get = getter;
                if (setter) descriptor.set = setter;
                return descriptor;
            }
        }
        descriptor.value = object[property];
        return descriptor;
    };
}
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}
if (!Object.create) {
    var createEmpty;
    if (Object.prototype.__proto__ === null) {
        createEmpty = function () {
            return { "__proto__": null };
        };
    } else {
        createEmpty = function () {
            var empty = {};
            for (var i in empty)
                empty[i] = null;
            empty.constructor =
            empty.hasOwnProperty =
            empty.propertyIsEnumerable =
            empty.isPrototypeOf =
            empty.toLocaleString =
            empty.toString =
            empty.valueOf =
            empty.__proto__ = null;
            return empty;
        }
    }

    Object.create = function create(prototype, properties) {
        var object;
        if (prototype === null) {
            object = createEmpty();
        } else {
            if (typeof prototype != "object")
                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
            var Type = function () {};
            Type.prototype = prototype;
            object = new Type();
            object.__proto__ = prototype;
        }
        if (properties !== void 0)
            Object.defineProperties(object, properties);
        return object;
    };
}
function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, "sentinel", {});
        return "sentinel" in object;
    } catch (exception) {
    }
}
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" ||
        doesDefinePropertyWork(document.createElement("div"));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty;
    }
}

if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
                                      "on this javascript engine";

    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
            }
        }
        if (owns(descriptor, "value")) {

            if (supportsAccessors && (lookupGetter(object, property) ||
                                      lookupSetter(object, property)))
            {
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                delete object[property];
                object[property] = descriptor.value;
                object.__proto__ = prototype;
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors)
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            if (owns(descriptor, "get"))
                defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set"))
                defineSetter(object, property, descriptor.set);
        }

        return object;
    };
}
if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
        for (var property in properties) {
            if (owns(properties, property))
                Object.defineProperty(object, property, properties[property]);
        }
        return object;
    };
}
if (!Object.seal) {
    Object.seal = function seal(object) {
        return object;
    };
}
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        return object;
    };
}
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function freeze(freezeObject) {
        return function freeze(object) {
            if (typeof object == "function") {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    })(Object.freeze);
}
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        return object;
    };
}
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        return false;
    };
}
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        return false;
    };
}
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        if (Object(object) === object) {
            throw new TypeError(); // TODO message
        }
        var name = '';
        while (owns(object, name)) {
            name += '?';
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}
if (!Object.keys) {
    var hasDontEnumBug = true,
        dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ],
        dontEnumsLength = dontEnums.length;

    for (var key in {"toString": null}) {
        hasDontEnumBug = false;
    }

    Object.keys = function keys(object) {

        if (
            (typeof object != "object" && typeof object != "function") ||
            object === null
        ) {
            throw new TypeError("Object.keys called on a non-object");
        }

        var keys = [];
        for (var name in object) {
            if (owns(object, name)) {
                keys.push(name);
            }
        }

        if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                var dontEnum = dontEnums[i];
                if (owns(object, dontEnum)) {
                    keys.push(dontEnum);
                }
            }
        }
        return keys;
    };

}

//
//
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}


//
//
var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
    "\u2029\uFEFF";
if (!String.prototype.trim || ws.trim()) {
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
        trimEndRegexp = new RegExp(ws + ws + "*$");
    String.prototype.trim = function trim() {
        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
    };
}

//
//
function toInteger(n) {
    n = +n;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function isPrimitive(input) {
    var type = typeof input;
    return (
        input === null ||
        type === "undefined" ||
        type === "boolean" ||
        type === "number" ||
        type === "string"
    );
}

function toPrimitive(input) {
    var val, valueOf, toString;
    if (isPrimitive(input)) {
        return input;
    }
    valueOf = input.valueOf;
    if (typeof valueOf === "function") {
        val = valueOf.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    toString = input.toString;
    if (typeof toString === "function") {
        val = toString.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    throw new TypeError();
}
var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert "+o+" to object");
    }
    return Object(o);
};

});

define("ace/lib/es6-shim",[], function(require, exports, module) {
    function defineProp(obj, name, val) {
        Object.defineProperty(obj, name, {
            value: val,
            enumerable: false,
            writable: true,
            configurable: true,
        });
    }
    if (!String.prototype.startsWith) {
        defineProp(String.prototype, "startsWith", function(searchString, position) {
            position = position || 0;
            return this.lastIndexOf(searchString, position) === position;
        });
    }
    if (!String.prototype.endsWith) {
        defineProp(String.prototype, "endsWith", function(searchString, position) {
            var subjectString = this;
            if (position === undefined || position > subjectString.length) {
                position = subjectString.length;
            }
            position -= searchString.length;
            var lastIndex = subjectString.indexOf(searchString, position);
            return lastIndex !== -1 && lastIndex === position;
        });
    }
    if (!String.prototype.repeat) {
        defineProp(String.prototype, "repeat", function(count) {
            var result = "";
            var string = this;
            while (count > 0) {
                if (count & 1)
                    result += string;
        
                if (count >>= 1)
                    string += string;
            }
            return result;
        });
    }
    if (!String.prototype.includes) {
        defineProp(String.prototype, "includes", function(str, position) {
            return this.indexOf(str, position != -1);
        });
    }
    if (!Object.assign) {
        Object.assign = function (target) {
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && source !== null) {
                    Object.keys(source).forEach(function(key) {
                        output[key] = source[key];
                    });
                }
            }
            return output;
        };
    }

});

define("ace/lib/oop",[], function(require, exports, module) {
"use strict";

exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};

exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};

});

define("ace/range",[], function(require, exports, module) {
"use strict";
var comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
var Range = function(startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };

    this.end = {
        row: endRow,
        column: endColumn
    };
};

(function() {
    this.isEqual = function(range) {
        return this.start.row === range.start.row &&
            this.end.row === range.end.row &&
            this.start.column === range.start.column &&
            this.end.column === range.end.column;
    };
    this.toString = function() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    };

    this.contains = function(row, column) {
        return this.compare(row, column) == 0;
    };
    this.compareRange = function(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    };
    this.comparePoint = function(p) {
        return this.compare(p.row, p.column);
    };
    this.containsRange = function(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };
    this.intersects = function(range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function(row, column) {
        return this.end.row == row && this.end.column == column;
    };
    this.isStart = function(row, column) {
        return this.start.row == row && this.start.column == column;
    };
    this.setStart = function(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    this.setEnd = function(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    this.inside = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideStart = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideEnd = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.compare = function(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            }
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    };
    this.compareStart = function(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareEnd = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareInside = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.clipRows = function(firstRow, lastRow) {
        if (this.end.row > lastRow)
            var end = {row: lastRow + 1, column: 0};
        else if (this.end.row < firstRow)
            var end = {row: firstRow, column: 0};

        if (this.start.row > lastRow)
            var start = {row: lastRow + 1, column: 0};
        else if (this.start.row < firstRow)
            var start = {row: firstRow, column: 0};

        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.isEmpty = function() {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
    };
    this.isMultiLine = function() {
        return (this.start.row !== this.end.row);
    };
    this.clone = function() {
        return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
        else
            return new Range(this.start.row, 0, this.end.row, 0)
    };
    this.toScreenRange = function(session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    };
    this.moveBy = function(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };

}).call(Range.prototype);
Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;

Range.comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};


exports.Range = Range;
});

define("ace/apply_delta",[], function(require, exports, module) {
"use strict";

function throwDeltaError(delta, errorText){
    console.log("Invalid Delta:", delta);
    throw "Invalid Delta: " + errorText;
}

function positionInDocument(docLines, position) {
    return position.row    >= 0 && position.row    <  docLines.length &&
           position.column >= 0 && position.column <= docLines[position.row].length;
}

function validateDelta(docLines, delta) {
    if (delta.action != "insert" && delta.action != "remove")
        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, "delta.lines must be an Array");
    if (!delta.start || !delta.end)
       throwDeltaError(delta, "delta.start/end must be an present");
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, "delta.start must be contained in document");
    var end = delta.end;
    if (delta.action == "remove" && !positionInDocument(docLines, end))
        throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, "delta.range must match delta lines");
}

exports.applyDelta = function(docLines, delta, doNotValidate) {
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || "";
    switch (delta.action) {
        case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
                docLines.splice(
                    row, endRow - row + 1,
                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
                );
            }
            break;
    }
}
});

define("ace/lib/event_emitter",[], function(require, exports, module) {
"use strict";

var EventEmitter = {};
var stopPropagation = function() { this.propagationStopped = true; };
var preventDefault = function() { this.defaultPrevented = true; };

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    if (typeof e != "object" || !e)
        e = {};

    if (!e.type)
        e.type = eventName;
    if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
    if (!e.preventDefault)
        e.preventDefault = preventDefault;

    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
            break;
    }
    
    if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
};


EventEmitter._signal = function(eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++)
        listeners[i](e, this);
};

EventEmitter.once = function(eventName, callback) {
    var _self = this;
    callback && this.addEventListener(eventName, function newCallback() {
        _self.removeEventListener(eventName, newCallback);
        callback.apply(null, arguments);
    });
};


EventEmitter.setDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers
    if (!handlers)
        handlers = this._defaultHandlers = {_disabled_: {}};
    
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1) 
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    
    if (handlers[eventName] == callback) {
        var old = handlers[eventName];
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
    return callback;
};

EventEmitter.off =
EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};

EventEmitter.removeAllListeners = function(eventName) {
    if (this._eventRegistry) this._eventRegistry[eventName] = [];
};

exports.EventEmitter = EventEmitter;

});

define("ace/anchor",[], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var Anchor = exports.Anchor = function(doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    
    if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};

(function() {

    oop.implement(this, EventEmitter);
    this.getPosition = function() {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function() {
        return this.document;
    };
    this.$insertRight = false;
    this.onChange = function(delta) {
        if (delta.start.row == delta.end.row && delta.start.row != this.row)
            return;

        if (delta.start.row > this.row)
            return;
            
        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    };
    
    function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
    }
            
    function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
                row: point.row,
                column: point.column
            };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
                row: point.row + deltaRowShift,
                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
        }
        return {
            row: deltaStart.row,
            column: deltaStart.column
        };
    }
    this.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        } else {
            pos = this.$clipPositionToDocument(row, column);
        }

        if (this.row == pos.row && this.column == pos.column)
            return;

        var old = {
            row: this.row,
            column: this.column
        };

        this.row = pos.row;
        this.column = pos.column;
        this._signal("change", {
            old: old,
            value: pos
        });
    };
    this.detach = function() {
        this.document.removeEventListener("change", this.$onChange);
    };
    this.attach = function(doc) {
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
    };
    this.$clipPositionToDocument = function(row, column) {
        var pos = {};

        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }

        if (column < 0)
            pos.column = 0;

        return pos;
    };

}).call(Anchor.prototype);

});

define("ace/document",[], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var applyDelta = require("./apply_delta").applyDelta;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Anchor = require("./anchor").Anchor;

var Document = function(textOrLines) {
    this.$lines = [""];
    if (textOrLines.length === 0) {
        this.$lines = [""];
    } else if (Array.isArray(textOrLines)) {
        this.insertMergedLines({row: 0, column: 0}, textOrLines);
    } else {
        this.insert({row: 0, column:0}, textOrLines);
    }
};

(function() {

    oop.implement(this, EventEmitter);
    this.setValue = function(text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({row: 0, column: 0}, text);
    };
    this.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function(row, column) {
        return new Anchor(this, row, column);
    };
    if ("aaa".split(/a/).length === 0) {
        this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
        };
    } else {
        this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
        };
    }


    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
        this._signal("changeNewLineMode");
    };
    this.getNewLineCharacter = function() {
        switch (this.$newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this.$autoNewLine || "\n";
        }
    };

    this.$autoNewLine = "";
    this.$newLineMode = "auto";
    this.setNewLineMode = function(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
        this._signal("changeNewLineMode");
    };
    this.getNewLineMode = function() {
        return this.$newLineMode;
    };
    this.isNewLine = function(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    };
    this.getLine = function(row) {
        return this.$lines[row] || "";
    };
    this.getLines = function(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function() {
        return this.getLines(0, this.getLength());
    };
    this.getLength = function() {
        return this.$lines.length;
    };
    this.getTextRange = function(range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    this.getLinesForRange = function(range) {
        var lines;
        if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        } else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    };
    this.insertLines = function(row, lines) {
        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
        return this.insertFullLines(row, lines);
    };
    this.removeLines = function(firstRow, lastRow) {
        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
        return this.removeFullLines(firstRow, lastRow);
    };
    this.insertNewLine = function(position) {
        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
        return this.insertMergedLines(position, ["", ""]);
    };
    this.insert = function(position, text) {
        if (this.getLength() <= 1)
            this.$detectNewLine(text);
        
        return this.insertMergedLines(position, this.$split(text));
    };
    this.insertInLine = function(position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
        }, true);
        
        return this.clonePos(end);
    };
    
    this.clippedPos = function(row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        } else if (row < 0) {
            row = 0;
        } else if (row >= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return {row: row, column: column};
    };
    
    this.clonePos = function(pos) {
        return {row: pos.row, column: pos.column};
    };
    
    this.pos = function(row, column) {
        return {row: row, column: column};
    };
    
    this.$clipPosition = function(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    };
    this.insertFullLines = function(row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row < this.getLength()) {
            lines = lines.concat([""]);
            column = 0;
        } else {
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        this.insertMergedLines({row: row, column: column}, lines);
    };
    this.insertMergedLines = function(position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
        });
        
        return this.clonePos(end);
    };
    this.remove = function(range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        });
        return this.clonePos(start);
    };
    this.removeInLine = function(row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        }, true);
        
        return this.clonePos(start);
    };
    this.removeFullLines = function(firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
        var deleteLastNewLine  = lastRow  < this.getLength() - 1;
        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
        var range = new Range(startRow, startCol, endRow, endCol);
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
        });
        return deletedLines;
    };
    this.removeNewLine = function(row) {
        if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
            });
        }
    };
    this.replace = function(range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 && range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        
        return end;
    };
    this.applyDeltas = function(deltas) {
        for (var i=0; i<deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    };
    this.revertDeltas = function(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            this.revertDelta(deltas[i]);
        }
    };
    this.applyDelta = function(delta, doNotValidate) {
        var isInsert = delta.action == "insert";
        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        
        if (isInsert && delta.lines.length > 20000)
            this.$splitAndapplyLargeDelta(delta, 20000);
        applyDelta(this.$lines, delta, doNotValidate);
        this._signal("change", delta);
    };
    
    this.$splitAndapplyLargeDelta = function(delta, MAX) {
        var lines = delta.lines;
        var l = lines.length;
        var row = delta.start.row; 
        var column = delta.start.column;
        var from = 0, to = 0;
        do {
            from = to;
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            if (to > l) {
                delta.lines = chunk;
                delta.start.row = row + from;
                delta.start.column = column;
                break;
            }
            chunk.push("");
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        } while(true);
    };
    this.revertDelta = function(delta) {
        this.applyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == "insert" ? "remove" : "insert"),
            lines: delta.lines.slice()
        });
    };
    this.indexToPosition = function(index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
                return {row: i, column: index + lines[i].length + newlineLength};
        }
        return {row: l-1, column: lines[l-1].length};
    };
    this.positionToIndex = function(pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;

        return index + pos.column;
    };

}).call(Document.prototype);

exports.Document = Document;
});

define("ace/lib/lang",[], function(require, exports, module) {
"use strict";

exports.last = function(a) {
    return a[a.length - 1];
};

exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
        if (count & 1)
            result += string;

        if (count >>= 1)
            string += string;
    }
    return result;
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};

exports.copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
        else 
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== "[object Object]")
        return obj;
    
    copy = {};
    for (var key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

exports.createMap = function(props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.escapeHTML = function(str) {
    return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
};

exports.getMatchOffsets = function(string, regExp) {
    var matches = [];

    string.replace(regExp, function(str) {
        matches.push({
            offset: arguments[arguments.length-2],
            length: str.length
        });
    });

    return matches;
};
exports.deferredCall = function(fcn) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    
    deferred.isPending = function() {
        return timer;
    };

    return deferred;
};


exports.delayedCall = function(fcn, defaultTimeout) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var _self = function(timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };

    _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;

    _self.call = function() {
        this.cancel();
        fcn();
    };

    _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
    };

    _self.isPending = function() {
        return timer;
    };

    return _self;
};
});

define("ace/worker/mirror",[], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var Document = require("../document").Document;
var lang = require("../lib/lang");
    
var Mirror = exports.Mirror = function(sender) {
    this.sender = sender;
    var doc = this.doc = new Document("");
    
    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));
    
    var _self = this;
    sender.on("change", function(e) {
        var data = e.data;
        if (data[0].start) {
            doc.applyDeltas(data);
        } else {
            for (var i = 0; i < data.length; i += 2) {
                var d, err; 
                if (Array.isArray(data[i+1])) {
                    d = {action: "insert", start: data[i], lines: data[i+1]};
                } else {
                    d = {action: "remove", start: data[i], end: data[i+1]};
                }
                
                if ((d.action == "insert" ? d.start : d.end).row >= doc.$lines.length) {
                    err = new Error("Invalid delta");
                    err.data = {
                        path: _self.$path,
                        linesLength: doc.$lines.length,
                        start: d.start,
                        end: d.end
                    };
                    throw err;
                }

                doc.applyDelta(d, true);
            }
        }
        if (_self.$timeout)
            return deferredUpdate.schedule(_self.$timeout);
        _self.onUpdate();
    });
};

(function() {
    
    this.$timeout = 500;
    
    this.setTimeout = function(timeout) {
        this.$timeout = timeout;
    };
    
    this.setValue = function(value) {
        this.doc.setValue(value);
        this.deferredUpdate.schedule(this.$timeout);
    };
    
    this.getValue = function(callbackId) {
        this.sender.callback(this.doc.getValue(), callbackId);
    };
    
    this.onUpdate = function() {
    };
    
    this.isPending = function() {
        return this.deferredUpdate.isPending();
    };
    
}).call(Mirror.prototype);

});

define("plugins/c9.ide.language.core/syntax_detector",[], function(require, exports, module) {

var mixedLanguages = {
    php: {
        "default": "html",
        "php-start": /<\?(?:php|\=)?/,
        "php-end": /\?>/,
        "css-start": /<style[^>]*>/,
        "css-end": /<\/style>/,
        "javascript-start": /<script(?:\"[^\"]*\"|'[^']*'|[^'">])*>/,
        "javascript-end": /<\/script>/
    },
    html: {
        "css-start": /<style[^>]*>/,
        "css-end": /<\/style>/,
        "javascript-start": /<script(?:\"[^\"]*\"|'[^']*'|[^'">])*>/,
        "javascript-end": /<\/script>/
    }
};
mixedLanguages.handlebars = mixedLanguages.html;
var scriptTypeTests = {
    javascript: function(v) {
        var m = /type\s*=\s*("[^"]+"|'[^']+'|[^\s'">]+)/.exec(v);
        if (m && !/javascript|ecmascript/i.test(m[1]))
            return false;
        return true;
    }
};
function getSyntaxRegions(doc, originalSyntax) {
     if (!mixedLanguages[originalSyntax])
        return [{
            syntax: originalSyntax,
            sl: 0,
            sc: 0,
            el: doc.getLength() - 1,
            ec: doc.getLine(doc.getLength() - 1).length
        }];

    var lines = doc.getAllLines();
    var type = mixedLanguages[originalSyntax];
    var defaultSyntax = type["default"] || originalSyntax;
    var starters = Object.keys(type).filter(function (m) {
        return m.indexOf("-start") === m.length - 6;
    });
    var syntax = defaultSyntax;
    var regions = [{ syntax: syntax, sl: 0, sc: 0 }];
    var starter, endLang;
    var tempS, tempM;
    var i, m, cut, inLine = 0;

    for (var row = 0; row < lines.length; row++) {
        var line = lines[row];
        m = null;
        if (endLang) {
            m = endLang.exec(line);
            if (m) {
                endLang = null;
                syntax = defaultSyntax;
                regions[regions.length - 1].el = row;
                regions[regions.length - 1].ec = m.index + inLine;
                regions.push({
                    syntax: syntax,
                    sl: row,
                    sc: m.index + inLine
                });
                cut = m.index + m[0].length;
                lines[row] = line.substring(cut);
                inLine += cut;
                row--; // continue processing of the line
            }
            else {
                inLine = 0;
            }
        }
        else {
            for (i = 0; i < starters.length; i++) {
                tempS = starters[i];
                tempM = type[tempS].exec(line);
                if (tempM && (!m || m.index > tempM.index)) {
                    m = tempM;
                    starter = tempS;
                }
            }
            if (m) {
                syntax = starter.replace("-start", "");
                if (scriptTypeTests[syntax] && !scriptTypeTests[syntax](m[0]))
                    syntax = defaultSyntax;
                endLang = type[syntax + "-end"];
                regions[regions.length - 1].el = row;
                regions[regions.length - 1].ec = inLine + m.index + m[0].length;
                regions.push({
                    syntax: syntax,
                    sl: row,
                    sc: inLine + m.index + m[0].length
                });
                cut = m.index + m[0].length;
                lines[row] = line.substring(m.index + m[0].length);
                row--; // continue processing of the line
                inLine += cut;
            }
            else {
                inLine = 0;
            }
        }
    }
    regions[regions.length - 1].el = lines.length;
    regions[regions.length - 1].ec = lines[lines.length - 1].length;
    return regions;
}

function getContextSyntaxPart(doc, pos, originalSyntax) {
     if (!mixedLanguages[originalSyntax]) {
        var value;
        var result = {
            language: originalSyntax,
            region: getSyntaxRegions(doc, originalSyntax)[0],
            index: 0,
            getLine: function(l) {
                return doc.getLine(l);
            },
            getLines: function(firstRow, lastRow) {
                return doc.getLines(firstRow, lastRow);
            },
            getAllLines: function() {
                return doc.getAllLines();
            },
            getValue: function() {
                if (!value)
                    value = doc.getValue();
                return value;
            },
            getLength: function() {
                return doc.getLength();
            }
        };
        result.__defineGetter__("value", function() {
            console.error("part.value is deprecated: use getValue() instead");
            return this.getValue();
        });
        return result;
    }
    var regions = getSyntaxRegions(doc, originalSyntax);
    for (var i = 0; i < regions.length; i++) {
        var region = regions[i];
        if ((pos.row > region.sl && pos.row < region.el) ||
            (pos.row === region.sl && pos.column >= region.sc && pos.column <= region.ec))
            return regionToCodePart(doc, region, i);
    }
    return null; // should never happen
}

function getContextSyntax(doc, pos, originalSyntax) {
    var part = getContextSyntaxPart(doc, pos, originalSyntax);
    return part && part.language; // should never happen
}

function regionToCodePart(doc, region, index) {
    var lines = doc.getLines(region.sl, region.el);
    if (!lines.length) {
        console.error("region and document state are not consistent!!!");
        lines = [""];
    }
    var allLines;
    var value;
    var result = {
        language: region.syntax,
        region: region,
        index: index,
        getLines: function(firstRow, lastRow) {
            return this.getAllLines().slice(firstRow, lastRow + 1);
        },
        getLine: function(l) {
            if (region.sl === region.el)
                return lines[0].substring(region.sc, region.ec);
            if (l === 0)
                return lines[0].substring(region.sc);
            if (l === lines.length - 1)
                return lines[lines.length - 1].substring(0, region.ec);
            return lines[l];
        },
        getAllLines: function() {
            if (!allLines)
                allLines = region.sl === region.el
                    ? [lines[0].substring(region.sc, region.ec)]
                    : [lines[0].substring(region.sc)].concat(lines.slice(1, lines.length - 1)).concat([lines[lines.length - 1].substring(0, region.ec)]);
            return allLines;
        },
        getValue: function() {
            if (!value)
                value = this.getAllLines().join(doc.getNewLineCharacter());
            return value;
        },
        getLength: function() {
            return region.el - region.sl + 1;
        }
    };
    result.__defineGetter__("value", function() {
        console.error("part.value is deprecated: use getValue() instead");
        return this.getValue();
    });
    return result;
}

function getCodeParts(doc, originalSyntax) {
    var regions = getSyntaxRegions(doc, originalSyntax);
    return regions.map(function (region, i) {
        return regionToCodePart(doc, region, i);
    });
}

function posToRegion(region, pos) {
    if ("row" in pos)
        return {
            row: pos.row - region.sl,
            column: pos.column,
            path: pos.path
        };
    return {
        sl: pos.sl - region.sl,
        column: pos.sc,
        el: pos.el - region.sl,
        ec: pos.ec,
        path: pos.path
    };
}

function posFromRegion(region, pos) {
    if ("row" in pos)
        return {
            row: pos.row + region.sl,
            column: pos.column,
            path: pos.path
        };
    return {
        sl: pos.sl + region.sl,
        sc: pos.sc,
        el: pos.el + region.sl,
        ec: pos.ec,
        path: pos.path
    };
}

exports.getContextSyntax = getContextSyntax;
exports.getContextSyntaxPart = getContextSyntaxPart;
exports.getSyntaxRegions = getSyntaxRegions;
exports.getCodeParts = getCodeParts;
exports.posToRegion = posToRegion;
exports.posFromRegion = posFromRegion;

});

define("plugins/c9.ide.language/complete_util",[], function(require, exports, module) {

var ID_REGEX = /[a-zA-Z_0-9\$]/;
var REQUIRE_ID_REGEX = /(?!["'])./;
var staticPrefix = "";

function retrievePrecedingIdentifier(line, offset, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = offset - 1; i >= 0 && line; i--) {
        if (regex.test(line[i]))
            buf.push(line[i]);
        else
            break;
    }
    return buf.reverse().join("");
}

function retrieveFollowingIdentifier(line, offset, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = offset; line && i < line.length; i++) {
        if (regex.test(line[i]))
            buf.push(line[i]);
        else
            break;
    }
    return buf.join("");
}

function prefixBinarySearch(items, prefix) {
    var startIndex = 0;
    var stopIndex = items.length - 1;
    var middle = Math.floor((stopIndex + startIndex) / 2);
    
    while (stopIndex > startIndex && middle >= 0 && items[middle].indexOf(prefix) !== 0) {
        if (prefix < items[middle]) {
            stopIndex = middle - 1;
        }
        else if (prefix > items[middle]) {
            startIndex = middle + 1;
        }
        middle = Math.floor((stopIndex + startIndex) / 2);
    }
    while (middle > 0 && items[middle - 1].indexOf(prefix) === 0)
        middle--;
    return middle >= 0 ? middle : 0; // ensure we're not returning a negative index
}

function findCompletions(prefix, allIdentifiers) {
    allIdentifiers.sort();
    var startIdx = prefixBinarySearch(allIdentifiers, prefix);
    var matches = [];
    for (var i = startIdx; i < allIdentifiers.length && allIdentifiers[i].indexOf(prefix) === 0; i++)
        matches.push(allIdentifiers[i]);
    return matches;
}

function fetchTextSync(path) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', staticPrefix + "/" + path, false);
    try {
        xhr.send();
    }
    catch (e) {
        return false;
    }
    if (xhr.status === 200 || xhr.responseText) // when loading from file:// status is always 0
        return xhr.responseText;
    else
        return false;
}

function fetchText(path, callback) {
    var xhr = new XMLHttpRequest();
    try {
        xhr.open('GET', staticPrefix + "/" + path, true);
    } catch (e) {
        return done(e);
    }
    xhr.onload = function (e) {
        if (xhr.readyState !== 4)
            return;
        if (xhr.status !== 200 && xhr.status !== 0)
            return done(new Error(xhr.statusText));
        done(null, xhr.responseText);
    };
    xhr.onerror = done;
    xhr.send(null);
    
    function done(err, result) {
        callback && callback(err, result);
        callback = null;
        if (err) {
            err.data = { path: path };
            setTimeout(function() { throw err; });
        }
    }
}

function setStaticPrefix(url) {
    staticPrefix = url;
}
function canCompleteForChangedLine(oldLine, newLine, oldPos, newPos, identifierRegex) {
    if (newLine.indexOf(oldLine.substr(0, oldPos.column)) !== 0)
        return false;
    
    for (var i = oldPos.column; i < newPos.column; i++) {
        if (!identifierRegex.test(newLine[i]))
            return false;
    }
    return true;
}

function precededByIdentifier(line, column, postfix, ace) {
    var id = retrievePrecedingIdentifier(line, column);
    if (postfix) id += postfix;
    return id !== "" && !(id[0] >= '0' && id[0] <= '9') 
        && (inCompletableCodeContext(line, column, id, ace) 
        || isRequireJSCall(line, column, id, ace));
}

function isRequireJSCall(line, column, identifier, ace, noQuote) {
    if (["javascript", "jsx"].indexOf(ace.getSession().syntax) === -1)
        return false;
    var id = identifier == null ? retrievePrecedingIdentifier(line, column, REQUIRE_ID_REGEX) : identifier;
    var LENGTH = 'require("'.length - (noQuote ? 1 : 0);
    var start = column - id.length - LENGTH;
    var substr = line.substr(start, LENGTH) + (noQuote ? '"' : '');

    return start >= 0 && substr.match(/require\(["']/)
        || line.substr(start + 1, LENGTH).match(/require\(["']/);
}
function inCompletableCodeContext(line, column, id, ace) {
    if (["javascript", "jsx"].indexOf(ace.getSession().syntax) === -1)
        return true;
    var isJavaScript = true;
    var inMode = null;
    for (var i = 0; i < column; i++) {
        if (line[i] === '"' && !inMode)
            inMode = '"';
        else if (line[i] === '"' && inMode === '"' && line[i - 1] !== "\\")
            inMode = null;
        else if (line[i] === "'" && !inMode)
            inMode = "'";
        else if (line[i] === "'" && inMode === "'" && line[i - 1] !== "\\")
            inMode = null;
        else if (line[i] === "/" && line[i + 1] === "/") {
            inMode = '//';
            i++;
        }
        else if (line[i] === "/" && line[i + 1] === "*" && !inMode) {
            if (line.substr(i + 2, 6) === "global")
                continue;
            inMode = '/*';
            i++;
        }
        else if (line[i] === "*" && line[i + 1] === "/" && inMode === "/*") {
            inMode = null;
            i++;
        }
        else if (line[i] === "/" && !inMode && isJavaScript)
            inMode = "/";
        else if (line[i] === "/" && inMode === "/" && line[i - 1] !== "\\")
            inMode = null;
    }
    return inMode != "/";
}
exports.precededByIdentifier = precededByIdentifier;
exports.isRequireJSCall = isRequireJSCall;
exports.retrievePrecedingIdentifier = retrievePrecedingIdentifier;
exports.retrieveFollowingIdentifier = retrieveFollowingIdentifier;
exports.findCompletions = findCompletions;
exports.fetchText = fetchText;
exports.fetchTextSync = fetchTextSync;
exports.setStaticPrefix = setStaticPrefix;
exports.DEFAULT_ID_REGEX = ID_REGEX;
exports.canCompleteForChangedLine = canCompleteForChangedLine;
});

define("plugins/c9.ide.language.generic/local_completer",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var completeUtil = require("plugins/c9.ide.language/complete_util");

var MAX_SIZE_BYTES = 5 * 1000 * 1000;
var DEFAULT_SPLIT_REGEX = /[^a-zA-Z_0-9\$]+/;
var MAX_SCORE = 1000000;
var TRUNCATE_LINES = 10000;

var completer = module.exports = Object.create(baseLanguageHandler);
    
completer.handlesLanguage = function(language) {
    return true;
};

completer.handlesEditor = function() {
    return this.HANDLES_ANY;
};

completer.getMaxFileSizeSupported = function() {
    return MAX_SIZE_BYTES;
};
function wordDistanceAnalyzer(doc, pos, prefix, suffix) {
    var splitRegex = getSplitRegex(pos);
    var linesBefore = doc.getLines(Math.max(0, pos.row - TRUNCATE_LINES / 2), pos.row - 1);
    var linesAfter = doc.getLines(pos.row + 1, Math.min(doc.getLength(), pos.row + TRUNCATE_LINES / 2));
    var textBefore = linesBefore.join("\n");
    var textAfter = linesAfter.join("\n");
    var line = getFilteredLine(doc.getLine(pos.row), pos.column, prefix, suffix);
    var identifiers = textBefore.split(splitRegex);
    var prefixPosition = identifiers.length;
    identifiers = identifiers.concat(line.split(splitRegex), textAfter.split(splitRegex));
    var identDict = Object.create(null);
    for (var i = 0; i < identifiers.length; i++) {
        var ident = identifiers[i];
        if (ident.length === 0)
            continue;
        var distance = Math.max(prefixPosition, i) - Math.min(prefixPosition, i);
        if (identDict[ident])
            identDict[ident] = Math.max(MAX_SCORE - distance, identDict[ident]);
        else
            identDict[ident] = MAX_SCORE - distance;
        
    }
    return identDict;
}

function getSplitRegex(pos) {
    var idRegex = completer.$getIdentifierRegex(pos);
    if (!idRegex || !idRegex.source.match(/\[[^^][^\]]*\]/))
        return DEFAULT_SPLIT_REGEX;
    return new RegExp("[^" + idRegex.source.substr(1, idRegex.source.length - 2) + "]+");
}

function getFilteredLine(line, column, prefix, suffix) {
    return line.substr(0, column - prefix.length)
        + line.substr(column + suffix.length);
}

function analyze(doc, pos) {
    var line = doc.getLine(pos.row);
    var prefix = completeUtil.retrievePrecedingIdentifier(line, pos.column, completer.$getIdentifierRegex());
    var suffix = completeUtil.retrieveFollowingIdentifier(line, pos.column, completer.$getIdentifierRegex());
    return wordDistanceAnalyzer(doc, pos, prefix, suffix);
}
    
completer.complete = function(doc, fullAst, pos, options, callback) {
    var identDict = analyze(doc, pos);
    var line = doc.getLine(pos.row);
    var regex = this.$getIdentifierRegex(pos);
    var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, regex);
    var fullIdentifier = identifier + completeUtil.retrieveFollowingIdentifier(line, pos.column, regex);
         
    var allIdentifiers = [];
    for (var ident in identDict) {
        allIdentifiers.push(ident);
    }
    var matches = completeUtil.findCompletions(identifier, allIdentifiers);
    
    matches = matches.slice(0, 100); // limits results for performance

    var allowSlashes = regex && regex.source.match(/^\[.*\/.*]/);
    var allowDollars = regex && regex.source.match(/\$\$/);
    
    callback(null, matches.filter(function(m) {
        if (allowDollars) {
            return !m.match(allowSlashes ? /^([0-9_\/]|\/[^\/])/ : /^[0-9_\/]/);
        }  
        else {
            return !m.match(allowSlashes ? /^([0-9$_\/]|\/[^\/])/ : /^[0-9$_\/]/);
        }
    }).map(function(m) {
        return {
          name: m,
          replaceText: m,
          icon: null,
          score: m === fullIdentifier ? MAX_SCORE : identDict[m],
          isGeneric: true,
          priority: 0,
          $source: "local"
        };
    }));
};

});

define("plugins/c9.ide.language.generic/open_files_local_completer",[], function(require, exports, module) {

var completeUtil = require("plugins/c9.ide.language/complete_util");

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var analysisCache = {}; // path => {identifier: 3, ...}
var globalWordIndex = {}; // word => frequency
var globalWordFiles = {}; // word => [path]
var precachedPath;
var precachedDoc;

var completer = module.exports = Object.create(baseLanguageHandler);

completer.handlesLanguage = function(language) {
    return true;
};

completer.handlesEditor = function() {
    return this.HANDLES_ANY;
};

completer.getMaxFileSizeSupported = function() {
    return 1000 * 1000;
};

function frequencyAnalyzer(path, text, identDict, fileDict) {
    var identifiers = text.split(/[^a-zA-Z_0-9\$]+/);
    for (var i = 0; i < identifiers.length; i++) {
        var ident = identifiers[i];
        if (!ident)
            continue;
            
        if (Object.prototype.hasOwnProperty.call(identDict, ident)) {
            identDict[ident]++;
            fileDict[ident][path] = true;
        }
        else {
            identDict[ident] = 1;
            fileDict[ident] = {};
            fileDict[ident][path] = true;
        }
    }
    return identDict;
}

function removeDocumentFromCache(path) {
    var analysis = analysisCache[path];
    if (!analysis) return;

    for (var id in analysis) {
        globalWordIndex[id] -= analysis[id];
        delete globalWordFiles[id][path];
        if (globalWordIndex[id] === 0) {
            delete globalWordIndex[id];
            delete globalWordFiles[id];
        }
    }
    delete analysisCache[path];
}

function analyzeDocument(path, allCode) {
    if (!analysisCache[path]) {
        if (allCode.size > 80 * 10000) {
            delete analysisCache[path];
            return;
        }
        analysisCache[path] = frequencyAnalyzer(path, allCode, {}, {});
        frequencyAnalyzer(path, allCode, globalWordIndex, globalWordFiles);
    }
}

completer.onDocumentOpen = function(path, doc, oldPath, callback) {
    if (!analysisCache[path]) {
        analyzeDocument(path, doc.getValue());
    }
    callback();
};
    
completer.onDocumentClose = function(path, callback) {
    removeDocumentFromCache(path);
    if (path == precachedPath)
        precachedDoc = null;
    callback();
};

completer.analyze = function(doc, ast, callback) {
    if (precachedDoc && this.path !== precachedPath) {
        removeDocumentFromCache(precachedPath);
        analyzeDocument(precachedPath, precachedDoc);
        precachedDoc = null;
    }
    precachedPath = this.path;
    precachedDoc = doc;
    callback();
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    var line = doc.getLine(pos.row);
    var regex = this.$getIdentifierRegex(pos);
    var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, regex);
    var identDict = globalWordIndex;
    
    var allIdentifiers = [];
    for (var ident in identDict) {
        allIdentifiers.push(ident);
    }
    var matches = completeUtil.findCompletions(identifier, allIdentifiers);
    
    var currentPath = options.path;
    matches = matches.filter(function(m) {
        return !globalWordFiles[m][currentPath];
    });
    
    matches = matches.slice(0, 100); // limits results for performance

    callback(null, matches.filter(function(m) {
        return !m.match(/^[0-9$_\/]/);
    }).map(function(m) {
        var path = Object.keys(globalWordFiles[m])[0] || "[unknown]";
        var pathParts = path.split("/");
        var foundInFile = pathParts[pathParts.length - 1];
        return {
          name: m,
          replaceText: m,
          icon: null,
          score: identDict[m],
          meta: foundInFile,
          priority: 0,
          isGeneric: true,
          $source: "open_files",
        };
    }));
};

});

//
//
//
define("util",[], function(require, exports, module) {

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    exports._extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      value.inspect !== exports.inspect &&
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return false;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

});

//
//
//
//
//
define("assert",[], function(require, exports, module) {
var util = require('util');
var pSlice = Array.prototype.slice;
var assert = module.exports = ok;
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this);
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err = new Error();
    this.stack = err.stack;
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}
assert.fail = fail;
function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;
assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};
assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  if (a.prototype !== b.prototype) return false;
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = Object.keys(a),
        kb = Object.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  if (ka.length != kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}
assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

});

define("c9/assert",[], function(require, exports, module) {
        
    var assert = function(value, message) {
        if (!value)
            throw new Error("Assertion failed: " + (message || value));
    };
    
    var assertEqual = function(value1, value2, message) {
        if (value1 != value2)
            throw new Error("Assertion failed. " + (message || "") + " got\n  " + value1 + "expected\n  " + value2);
    };
    
    module.exports = function(value, message) {
        assert(value, message);
    };
    
    module.exports.equal = function(value1, value2, message) {
        assertEqual(value1, value2, message);
    };
    
    if (typeof process === "undefined")
        return;
        
    if (process.versions && process.versions['node-webkit'])
        return;
    require(["assert"], function(nodeAssert) {
        assert = nodeAssert;
        assertEqual = nodeAssert.equal;
    });
    if (Error.captureStackTrace) {
        assert = require("assert");
        assertEqual = assert.equal;
    }
});

define("plugins/c9.ide.language.core/worker",[], function(require, exports, module) {

require("ace/lib/es5-shim");
require("ace/lib/es6-shim");

var oop = require("ace/lib/oop");
var Mirror = require("ace/worker/mirror").Mirror;
var tree = require('treehugger/tree');
var EventEmitter = require("ace/lib/event_emitter").EventEmitter;
var syntaxDetector = require("plugins/c9.ide.language.core/syntax_detector");
var completeUtil = require("plugins/c9.ide.language/complete_util");
var localCompleter = require("plugins/c9.ide.language.generic/local_completer");
var openFilesCompleter = require("plugins/c9.ide.language.generic/open_files_local_completer");
var base_handler = require("plugins/c9.ide.language/base_handler");
var assert = require("c9/assert");

var isInWebWorker = typeof window == "undefined" || !window.location || !window.document;

var WARNING_LEVELS = {
    error: 3,
    warning: 2,
    info: 1
};

var UPDATE_TIMEOUT_MIN = !isInWebWorker && window.c9Test ? 5 : 200;
var UPDATE_TIMEOUT_MAX = 15000;
var DEBUG = !isInWebWorker; // set to true by setDebug() for c9.dev/cloud9beta.com
var STATS = false;
disabledFeatures = {};

var ServerProxy = function(sender) {

  this.emitter = Object.create(EventEmitter);
  this.emitter.emit = this.emitter._dispatchEvent;

  this.send = function(data) {
      sender.emit("serverProxy", data);
  };

  this.once = function(messageType, messageSubtype, callback) {
    var channel = messageType;
    if (messageSubtype)
       channel += (":" + messageSubtype);
    this.emitter.once(channel, callback);
  };

  this.subscribe = function(messageType, messageSubtype, callback) {
    var channel = messageType;
    if (messageSubtype)
       channel += (":" + messageSubtype);
    this.emitter.addEventListener(channel, callback);
  };

  this.unsubscribe = function(messageType, messageSubtype, f) {
    var channel = messageType;
    if (messageSubtype)
       channel += (":" + messageSubtype);
    this.emitter.removeEventListener(channel, f);
  };

  this.onMessage = function(msg) {
    var channel = msg.type;
    if (msg.subtype)
      channel += (":" + msg.subtype);
    this.emitter.emit(channel, msg.body);
  };
};

exports.createUIWorkerClient = function() {
    var emitter = Object.create(require("ace/lib/event_emitter").EventEmitter);
    var result = new LanguageWorker(emitter);
    result.on = function(name, f) {
        emitter.on.call(result, name, f);
    };
    result.once = function(name, f) {
        emitter.once.call(result, name, f);
    };
    result.removeEventListener = function(f) {
        emitter.removeEventListener.call(result, f);
    };
    result.call = function(cmd, args, callback) {
        if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
        }
        this.send(cmd, args);
    };
    result.send = function(cmd, args) {
        setTimeout(function() { result[cmd].apply(result, args); }, 0);
    };
    result.emit = function(event, data) {
        emitter._dispatchEvent.call(emitter, event, data);
    };
    emitter.emit = function(event, data) {
        emitter._dispatchEvent.call(result, event, { data: data });
    };
    result.changeListener = function(e) {
        this.emit("change", { data: [e.data]});
    }; 
    return result;
};

var LanguageWorker = exports.LanguageWorker = function(sender) {
    var _self = this;
    this.$keys = {};
    this.handlers = [];
    this.$warningLevel = "info";
    this.$openDocuments = {};
    this.$initedRegexes = {};
    this.lastUpdateTime = 0;
    sender.once = EventEmitter.once;
    this.serverProxy = new ServerProxy(sender);

    Mirror.call(this, sender);
    this.setTimeout(0);
    exports.sender = sender;
    exports.$lastWorker = this;

    sender.on("hierarchy", function(event) {
        _self.hierarchy(event);
    });
    sender.on("code_format", function(event) {
        _self.codeFormat();
    });
    sender.on("outline", applyEventOnce(function(event) {
        _self.outline(event);
    }));
    sender.on("complete", applyEventOnce(function(data) {
        _self.complete(data);
    }), true);
    sender.on("documentClose", function(event) {
        _self.documentClose(event);
    });
    sender.on("analyze", applyEventOnce(function(event) {
        _self.analyze(false, function() {});
    }));
    sender.on("cursormove", function(event) {
        _self.onCursorMove(event);
    });
    sender.on("inspect", applyEventOnce(function(event) {
        _self.inspect(event);
    }));
    sender.on("jumpToDefinition", applyEventOnce(function(event) {
        _self.jumpToDefinition(event);
    }));
    sender.on("quickfixes", applyEventOnce(function(event) {
        _self.quickfix(event);
    }));
    sender.on("isJumpToDefinitionAvailable", applyEventOnce(function(event) {
        _self.isJumpToDefinitionAvailable(event);
    }));
    sender.on("refactorings", function(event) {
        _self.getRefactorings(event);
    });
    sender.on("renamePositions", function(event) {
        _self.getRenamePositions(event);
    });
    sender.on("onRenameBegin", function(event) {
        _self.onRenameBegin(event);
    });
    sender.on("commitRename", function(event) {
        _self.commitRename(event);
    });
    sender.on("onRenameCancel", function(event) {
        _self.onRenameCancel(event);
    });
    sender.on("serverProxy", function(event) {
        _self.serverProxy.onMessage(event.data);
    });
    sender.on("quickfix_key", function(e) {
        _self.$keys.quickfix = e.data;
    });
};
function applyEventOnce(eventHandler, waitForMirror) {
    var timer;
    var mirror = this;
    return function(e) {
        var _arguments = [].slice.apply(arguments);
        if (timer && !(e && e.data.predictOnly))
            clearTimeout(timer);
        timer = setTimeout(function() {
            if (waitForMirror && mirror.isPending())
                return setTimeout(function() { applyEventOnce(eventHandler, true); }, 0);
            eventHandler.apply(eventHandler, _arguments);
        }, 0);
    };
}

oop.inherits(LanguageWorker, Mirror);

var asyncForEach = module.exports.asyncForEach = function(array, fn, test, callback) {
    if (!callback) {
        callback = test;
        test = null;
    }

    array = array.slice(); // copy before use
    
    var nested = false, callNext = true;
    loop();
    
    function loop() {
        while (callNext && !nested) {
            callNext = false;
            while (array.length > 0 && test && !test(array[0]))
                array.shift();

            var item = array.shift();
            if (!item)
                return callback && callback();

            nested = true;
            fn(item, loop);
            nested = false;
        }
        callNext = true;
    }
};

function startTime() {
    if (!STATS)
        return;
    
    return Date.now();
}

function endTime(t, message, indent) {
    if (!STATS)
        return;

    var spaces = indent ? indent * 2 : 0;
    var time = String(Date.now() - t);
    spaces += Math.max(4 - time.length, 0);
    var prefix = "";
    for (var i = 0; i < spaces; i++)
        prefix += " ";

    console.log(prefix + time, message);
}

(function() {
    
    var identifierRegexes = {};
    var cacheCompletionRegexes = {};
    
    this.enableFeature = function(name, value) {
        disabledFeatures[name] = !value;
    };

    this.setWarningLevel = function(level) {
        this.$warningLevel = level;
    };
    
    this.setStaticPrefix = completeUtil.setStaticPrefix;

    this.setDebug = function(value) {
        DEBUG = value;
    };
    this.register = function(path, contents, callback) {
        var _self = this;
        function onRegistered(handler) {
            handler.$source = path;
            handler.proxy = _self.serverProxy;
            handler.sender = _self.sender;
            handler.$isInited = false;
            handler.getEmitter = function(overridePath) {
                return _self.$createEmitter(overridePath || path);
            };
            _self.completionCache = _self.completionPrediction = null;
            _self.handlers.push(handler);
            _self.$initHandler(handler, null, true, function() {
                _self.sender.emit("registered", { path: path });
                callback && callback();
            });
        }
        if (contents) {
            try {
                eval.call(null, contents);
            } catch (e) {
                console.error("Could not load language handler " + path + ": " + e);
                _self.sender.emit("registered", { path: path, err: e });
                callback && callback(e);
                throw e;
            }
        }
        var handler;
        try {
            handler = require(path);
            if (!handler)
                throw new Error("Unable to load required module: " + path);
        } catch (e) {
            if (isInWebWorker) {
                console.error("Could not load language handler " + path + ": " + e);
                _self.sender.emit("registered", { path: path, err: e.message });
                callback && callback(e);
                throw e;
            }
            require([path], function(handler) {
                if (!handler) {
                    _self.sender.emit("registered", { path: path, err: "Could not load" });
                    callback && callback("Could not load");
                    throw new Error("Could not load language handler " + path);
                }
                onRegistered(handler);
            });
            return;
        }
        onRegistered(handler);
    };
    
    this.$createEmitter = function(path) {
        var sender = this.sender;
        return {
            on: function(event, listener) {
                sender.on(path + "/" + event, function(e) {
                    listener(e.data);
                });
            },
            once: function(event, listener) {
                sender.once(path + "/" + event, function(e) {
                    listener(e.data);
                });
            },
            off: function(event, listener) {
                sender.off(path + "/" + event, listener);
            },
            emit: function(event, data) {
                sender.emit(path + "/" + event, data);
            }
        };
    };
    
    this.unregister = function(modulePath, callback) {
        if (window.require)
            window.require.modules[modulePath] = null;
        this.handlers = this.handlers.filter(function(h) {
            return h.$source !== modulePath;
        });
        callback && callback();
    };

    this.asyncForEachHandler = function(options, fn, callback) {
        var that = this;
        var part = options.part;
        var method = options.method;
        var ignoreSize = options.ignoreSize;
        asyncForEach(
            this.handlers,
            fn,
            function(handler) {
                return that.isHandlerMatch(handler, part, method, ignoreSize);
            },
            callback
        );
    };
    
    this.isHandlerMatch = function(handler, part, method, ignoreSize) {
        if (!handler[method]) {
            reportError(new Error("Handler " + handler.$source + " does not have method " + method), {
                keys: Object.keys(handler),
                protoKeys: handler.__proto__ && Object.keys(handler.__proto__)
            });
            return false;
        }
        if (handler[method].base_handler)
            return;
        switch (handler.handlesEditor()) {
            case base_handler.HANDLES_EDITOR: 
                if (this.immediateWindow)
                    return;
                break; 
            case base_handler.HANDLES_IMMEDIATE:
                if (!this.immediateWindow)
                    return;
        }
        if (!handler.handlesLanguage(part ? part.language : this.$language, part))
            return;
        var docLength = ignoreSize ? null : part
            ? part.getValue().length
            : this.doc.$lines.reduce(function(t, l) { return t + l.length; }, 0);
        return ignoreSize || docLength < handler.getMaxFileSizeSupported();
    };

    this.parse = function(part, callback, allowCached, forceCached) {
        var value = (part || this.doc).getValue();
        var language = part ? part.language : this.$language;

        if (allowCached && this.cachedAsts) {
            var cached = this.cachedAsts[part.index];
            if (cached && cached.ast && cached.part.language === language)
                return callback(cached.ast);
        }
        if (forceCached)
            return callback(null);

        var resultAst = null;
        this.asyncForEachHandler(
            { part: part, method: "parse" },
            function parseNext(handler, next) {
                if (handler.parse.length === 2) // legacy signature
                    return handler.parse(value, handleCallbackError(function onParse(ast) {
                        if (ast) resultAst = ast;
                        next();
                    }));

                handler.parse(value, {}, handleCallbackError(function onParse(ast) {
                    if (ast)
                        resultAst = ast;
                    next();
                }));
            },
            function() {
                callback(resultAst);
            }
        );
    };
    this.findNode = function(ast, pos, callback) {
        if (!ast)
            return callback();
        assert(!pos.line, "Internal error: providing line/col instead of row/column");
        
        var _self = this;
        var part = syntaxDetector.getContextSyntaxPart(_self.doc, pos, _self.$language);
        if (!part)
            return; // cursor position no longer current
        var posInPart = syntaxDetector.posToRegion(part.region, pos);
        var result;
        this.asyncForEachHandler(
            { part: part, method: "findNode" },
            function(handler, next) {
                handler.findNode(ast, posInPart, handleCallbackError(function(node) {
                    if (node)
                        result = node;
                    next();
                }));
            },
            function() { callback(result); }
        );
    };

    this.outline = function(event) {
        var _self = this;
        this.getOutline(function(result, isUnordered) {
            _self.sender.emit(
                "outline",
                {
                    body: result && (result.body || result.items) || [],
                    path: _self.$path,
                    isUnordered: isUnordered
                }
            );
        });
    };
    
    this.getOutline = function(callback) {
        var _self = this;
        var result;
        var isUnordered = false;
        var applySort = false;
        this.parse(null, function(ast) {
            _self.asyncForEachHandler({ method: "outline" }, function(handler, next) {
                if (handler.outline.length === 3) // legacy signature
                    return handler.outline(_self.doc, ast, handleCallbackError(processResult));
                handler.outline(_self.doc, ast, {}, handleCallbackError(processResult));
                    
                function processResult(outline) {
                    if (!outline)
                        return next();
                    if (!result || (!outline.isGeneric && result.isGeneric)) {
                        result = outline;
                        isUnordered = outline.isUnordered;
                        return next();
                    }
                    if (result && outline.isGeneric && !result.isGeneric) {
                        return next();
                    }
                    applySort = true;
                    [].push.apply(result.items, outline.items);
                    result.isGeneric = outline.isGeneric;
                    next();
                }
            }, function() {
                if (applySort && result)
                    result.items = result.items.sort(function(a, b) {
                        return a.pos.sl - b.pos.sl;
                    });
                
                callback(result, isUnordered);
            });
        });
    };

    this.hierarchy = function(event) {
        var data = event.data;
        var _self = this;
        asyncForEach(this.handlers, function(handler, next) {
            if (_self.isHandlerMatch(handler, null, "hierarchy")) {
                handler.hierarchy(_self.doc, data.pos, handleCallbackError(function(hierarchy) {
                    if (hierarchy)
                        return _self.sender.emit("hierarchy", hierarchy);
                    else
                        next();
                }));
            }
            else
                next();
        });
    };

    this.codeFormat = function() {
        var _self = this;
        asyncForEach(_self.handlers, function(handler, next) {
            if (_self.isHandlerMatch(handler, null, "codeFormat", true)) {
                handler.codeFormat(_self.doc, function(optionalErr, newSource) {
                    if (typeof optionalErr === "string")
                        newSource = optionalErr;
                    else if (optionalErr)
                        console.error(optionalErr.stack || optionalErr);
                    if (newSource)
                        return _self.sender.emit("code_format", newSource);
                    else
                        next();
                });
            }
            else
                next();
        });
    };

    this.scheduleEmit = function(messageType, data) {
        data.path = this.$path;
        this.sender.emit(messageType, data);
    };
    function filterMarkersAroundError(ast, markers) {
        if (!ast || !ast.getAnnotation)
            return;
        var error = ast.getAnnotation("error");
        if (!error)
            return;
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i];
            if (marker.type !== 'error' && marker.pos.sl >= error.line && marker.pos.el <= error.line + 2) {
                markers.splice(i, 1);
                i--;
            }
        }
    }

    this.analyze = function(minimalAnalysis, callback) {
        var _self = this;
        var parts = syntaxDetector.getCodeParts(this.doc, this.$language);
        var markers = [];
        var cachedAsts = {};
        var t0 = startTime();
        asyncForEach(parts, function analyzePart(part, nextPart) {
            var partMarkers = [];
            _self.part = part;
            _self.$lastAnalyzer = "parse()";
            _self.parse(part, function analyzeParsed(ast) {
                cachedAsts[part.index] = { part: part, ast: ast };

                _self.asyncForEachHandler(
                    { part: part, method: "analyze" },
                    function(handler, next) {
                        handler.language = part.language;
                        var t = startTime();
                        _self.$lastAnalyzer = handler.$source + ".analyze()";
                        
                        if (handler.analyze.length === 3 || /^[^)]+minimalAnalysis/.test(handler.analyze.toString())) {
                            return handler.analyze(part.getValue(), ast, handleCallbackError(doNext), minimalAnalysis);
                        }
                        
                        handler.analyze(part.getValue(), ast, { path: _self.$path, minimalAnalysis: minimalAnalysis }, handleCallbackError(doNext));
                        
                        function doNext(result) {
                            endTime(t, "Analyze: " + handler.$source.replace("plugins/", ""));
                            if (result)
                                partMarkers = partMarkers.concat(result);
                            next();
                        }
                    },
                    function() {
                        filterMarkersAroundError(ast, partMarkers);
                        var region = part.region;
                        partMarkers.forEach(function(marker) {
                            if (marker.skipMixed)
                                return;
                            var pos = marker.pos;
                            if (!pos)
                                return console.error("Invalid marker, no position:", marker);
                            pos.sl = pos.el = pos.sl + region.sl;
                            if (pos.sl === region.sl) {
                                pos.sc += region.sc;
                                pos.ec += region.sc;
                            }
                        });
                        markers = markers.concat(partMarkers);
                        nextPart();
                    }
                );
            });
        }, function() {
            endTime(t0, "Analyzed all");
            _self.cachedAsts = cachedAsts;
            if (!minimalAnalysis) {
                _self.scheduleEmit("markers", _self.filterMarkersBasedOnLevel(markers));
            }
            callback();
        });
    };

    this.filterMarkersBasedOnLevel = function(markers) {
        if (disabledFeatures.hints)
            return [];
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i];
            if (marker.level && WARNING_LEVELS[marker.level] < WARNING_LEVELS[this.$warningLevel]) {
                markers.splice(i, 1);
                i--;
            }
        }
        return markers;
    };

    this.getPart = function (pos) {
        return syntaxDetector.getContextSyntaxPart(this.doc, pos, this.$language);
    };
    this.inspect = function (event) {
        var _self = this;
        var pos = { row: event.data.row, column: event.data.column };
        var part = this.getPart({ row: event.data.row, column: event.data.col });
        if (!part)
            return; // cursor position no longer current
        var partPos = syntaxDetector.posToRegion(part.region, pos);
        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(node) {
                _self.getPos(node, function(fullPos) {
                    if (!fullPos) {
                        var postfix = completeUtil.retrieveFollowingIdentifier(_self.doc.getLine(pos.row), pos.column);
                        var prefix = completeUtil.retrievePrecedingIdentifier(_self.doc.getLine(pos.row), pos.column);
                        fullPos = { sl: partPos.row, sc: partPos.column - prefix.length, el: partPos.row, ec: partPos.column + postfix.length };
                    }
                    _self.nodeToString(node, function(result) {
                        var lastResult = {
                            pos: fullPos,
                            value: result
                        };
                        var rejected;
                        asyncForEach(_self.handlers, function(handler, next) {
                            if (_self.isHandlerMatch(handler, part, "getInspectExpression")) {
                                handler.language = part.language;
                                handler.getInspectExpression(part, ast, partPos, { node: node, path: _self.$path }, handleCallbackError(function(result) {
                                    if (result) {
                                        result.pos = syntaxDetector.posFromRegion(part.region, result.pos);
                                        lastResult = result || lastResult;
                                    }
                                    else if (!rejected) {
                                        lastResult = {};
                                        rejected = true;
                                    }
                                    next();
                                }));
                            }
                            else {
                                next();
                            }
                        }, function () {
                            if (!lastResult.pos && !lastResult.value)
                                return _self.scheduleEmit("inspect", lastResult);
                            var pos = lastResult.pos;
                            var text = _self.doc.getTextRange({ start: { column: pos.sc, row: pos.sl }, end: { column: pos.ec, row: pos.el }});
                            if (text != lastResult.value) {
                                console.warn("inspect expected ", text, " got ", lastResult.value);
                                lastResult.value = text;
                            }
                            _self.scheduleEmit("inspect", lastResult);
                        });
                    });
                });
            });
        }, true);
    };
    
    this.nodeToString = function(node, callback) {
        if (!node)
            return callback();
        var _self = this;
        this.getPos(node, function(pos) {
            if (!pos)
                return callback();
            var doc = _self.doc;
            if (pos.sl === pos.el)
                return callback(doc.getLine(pos.sl).substring(pos.sc, pos.ec));
            
            var result = doc.getLine(pos.sl).substr(pos.sc);
            for (var i = pos.sl + 1; i < pos.el; i++) {
                result += doc.getLine(i);
            }
            result += doc.getLine(pos.el).substr(0, pos.ec);
            callback(result);
        });
    };
    
    this.getPos = function(node, callback) {
        if (!node)
            return callback();
        var done = false;
        var _self = this;
        this.handlers.forEach(function (h) {
            if (!done && _self.isHandlerMatch(h, null, "getPos", true)) {
                h.getPos(node, function(result) {
                    if (!result)
                        return;
                    done = true;
                    callback(result);
                });
            }
        });
        if (!done)
            callback();
    };
    
    this.getIdentifierRegex = function(pos) {
        var part = pos && this.getPart(pos);
        return identifierRegexes[part ? part.language : this.$language] || completeUtil.DEFAULT_ID_REGEX;
    };
    
    this.getCacheCompletionRegex = function(pos) {
        var part = pos && this.getPart(pos);
        return cacheCompletionRegexes[part ? part.language : this.$language] || completeUtil.DEFAULT_ID_REGEX;
    };
    this.onCursorMove = function(event) {
        var _self = this;
        var pos = event.data.pos;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var line = this.doc.getLine(pos.row);
        
        if (line != event.data.line) {
            return this.scheduleEmit("hint", { line: null });
        }

        var result = {
            markers: [],
            hint: null,
            displayPos: null
        };
        
        this.initAllRegexes(part.language);
        
        var posInPart = syntaxDetector.posToRegion(part.region, pos);
        this.parse(part, function(ast) {
            if (!ast)
                return callHandlers(ast, null);
            _self.findNode(ast, pos, function(currentNode) {
                callHandlers(ast, currentNode);
            });
        }, true, true);
        
        function callHandlers(ast, currentNode) {
            asyncForEach(_self.handlers,
                function(handler, next) {
                    if ((pos != _self.lastCurrentPosUnparsed || pos.force) && _self.isHandlerMatch(handler, part, "onCursorMove")) {
                        handler.onCursorMove(part, ast, posInPart, { node: currentNode, path: _self.$path }, handleCallbackError(function(response) {
                            processCursorMoveResponse(response, part, result);
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                },
                function() {
                    _self.lastCurrentPosUnparsed = pos;
                    if (result.markers.length) {
                        _self.scheduleEmit("highlightMarkers", disabledFeatures.instanceHighlight
                            ? []
                            : result.markers
                        );
                        event.data.addedMarkers = result.markers;
                    }
                    if (result.hint !== null) {
                        _self.scheduleEmit("hint", {
                            pos: result.pos,
                            displayPos: result.displayPos,
                            message: result.hint,
                            line: line
                        });
                    }
                    _self.onCursorMoveAnalyzed(event);
                }
            );
        }
    };
    this.onCursorMoveAnalyzed = function(event) {
        var _self = this;
        var pos = event.data.pos;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var line = this.doc.getLine(pos.row);
        
        if (line != event.data.line) {
            return this.scheduleEmit("hint", { line: null });
        }
        if (this.updateScheduled) {
            this.postponedCursorMove = event;
            if (event.data.now)
                this.onUpdate(true);
            return;
        }

        var result = {
            markers: event.data.addedMarkers || [],
            hint: null,
            displayPos: null
        };

        var posInPart = syntaxDetector.posToRegion(part.region, pos);
        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                if (pos != _self.lastCurrentPos || currentNode !== _self.lastCurrentNode || pos.force) {
                    callHandlers(ast, currentNode);
                }
            });
        }, true);
        
        function callHandlers(ast, currentNode) {
            asyncForEach(_self.handlers, function(handler, next) {
                if (_self.updateScheduled) {
                    _self.postponedCursorMove = event;
                    return;
                }
                if (_self.isHandlerMatch(handler, part, "tooltip") || _self.isHandlerMatch(handler, part, "highlightOccurrences")) {
                    assert(!handler.onCursorMovedNode, "handler implements onCursorMovedNode; no longer exists");
                    asyncForEach(["tooltip", "highlightOccurrences"], function(method, nextMethod) {
                        handler[method](part, ast, posInPart, { node: currentNode, path: _self.$path }, function(response) {
                            result = processCursorMoveResponse(response, part, result);
                            nextMethod();
                        });
                    }, next);
                }
                else {
                    next();
                }
            }, function() {
                _self.scheduleEmit("highlightMarkers", disabledFeatures.instanceHighlight
                    ? []
                    : result.markers
                );
                _self.lastCurrentNode = currentNode;
                _self.lastCurrentPos = pos;
                _self.scheduleEmit("hint", {
                    pos: result.pos,
                    displayPos: result.displayPos,
                    message: result.hint,
                    line: line
                });
            });
        }
    };
        
    function processCursorMoveResponse(response, part, result) {
        if (!response)
            return result;
        if (response.markers && (!result.markers.found || !response.isGeneric)) {
            if (result.markers.isGeneric)
                result.markers = [];
            result.markers = result.markers.concat(response.markers.map(function (m) {
                var start = syntaxDetector.posFromRegion(part.region, { row: m.pos.sl, column: m.pos.sc });
                var end = syntaxDetector.posFromRegion(part.region, { row: m.pos.el, column: m.pos.ec });
                m.pos = {
                    sl: start.row,
                    sc: start.column,
                    el: end.row,
                    ec: end.column
                };
                return m;
            }));
            result.markers.found = true;
            result.markers.isGeneric = response.isGeneric;
        }
        if (response.hint) {
            if (result.hint)
                result.hint += "\n" + response.hint;
            else
                result.hint = response.hint;
        }
        if (response.pos)
            result.pos = response.pos;
        if (response.displayPos)
            result.displayPos = response.displayPos;
        
        return result;
    }

    this.$getDefinitionDeclarations = function (row, col, callback) {
        var pos = { row: row, column: col };
        var allResults = [];

        var _self = this;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var posInPart = syntaxDetector.posToRegion(part.region, pos);

        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                asyncForEach(_self.handlers, function jumptodefNext(handler, next) {
                    if (_self.isHandlerMatch(handler, part, "jumpToDefinition")) {
                        handler.jumpToDefinition(part, ast, posInPart, { node: currentNode, path: _self.$path, language: _self.$language }, handleCallbackError(function(results) {
                            handler.path = _self.$path;
                            if (results)
                                allResults = allResults.concat(results);
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                }, function () {
                    callback(allResults.map(function (pos) {
                        var globalPos = syntaxDetector.posFromRegion(part.region, pos);
                        pos.row = globalPos.row;
                        pos.column = globalPos.column;
                        return pos;
                    }));
                });
            });
        }, true);
    };

    this.jumpToDefinition = function(event) {
        var _self = this;
        var pos = event.data;
        var line = this.doc.getLine(pos.row);
        var regex = this.getIdentifierRegex(pos);
        var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, regex)
            + completeUtil.retrieveFollowingIdentifier(line, pos.column, regex);

        _self.$getDefinitionDeclarations(pos.row, pos.column, function(results) {
            _self.sender.emit(
                "definition",
                {
                    pos: pos,
                    results: results || [],
                    path: _self.$path,
                    identifier: identifier
                }
            );
        });
    };
    
    this.quickfix = function(event) {
        var _self = this;
        var pos = event.data;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var partPos = syntaxDetector.posToRegion(part.region, pos);
        var allResults = [];
        
        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                asyncForEach(_self.handlers, function(handler, next) {
                    if (_self.isHandlerMatch(handler, part, "getQuickfixes")) {
                        handler.getQuickfixes(part, ast, partPos, { node: currentNode, path: _self.$path }, handleCallbackError(function(results) {
                            if (results)
                                allResults = allResults.concat(results);
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                }, function() {
                    _self.sender.emit("quickfixes_result", {
                        path: _self.$path,
                        results: allResults
                    });
                });
            });
        });
    };

    this.isJumpToDefinitionAvailable = function(event) {
        var _self = this;
        var pos = event.data;

        _self.$getDefinitionDeclarations(pos.row, pos.column, function(results) {
            _self.sender.emit(
                "isJumpToDefinitionAvailableResult",
                { value: !!(results && results.length), path: _self.$path, pos: pos }
            );
        });
    };
    
    this.getRefactorings = function(event) {
        var _self = this;
        var pos = event.data;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var partPos = syntaxDetector.posToRegion(part.region, pos);
        
        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                var result;
                asyncForEach(_self.handlers, function(handler, next) {
                    if (_self.isHandlerMatch(handler, part, "getRefactorings")) {
                        handler.getRefactorings(part, ast, partPos, { node: currentNode, path: _self.$path }, handleCallbackError(function(response) {
                            if (response) {
                                assert(!response.enableRefactorings, "Use refactorings instead of enableRefactorings");
                                if (!result || result.isGeneric)
                                    result = response;
                            }
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                }, function() {
                    _self.sender.emit("refactoringsResult", result && result.refactorings || []);
                });
            });
        });
    };

    this.getRenamePositions = function(event) {
        var _self = this;
        var pos = event.data;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var partPos = syntaxDetector.posToRegion(part.region, pos);

        function posFromRegion(pos) {
            return syntaxDetector.posFromRegion(part.region, pos);
        }

        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                var result;
                asyncForEach(_self.handlers, function(handler, next) {
                    if (_self.isHandlerMatch(handler, part, "getRenamePositions")) {
                        assert(!handler.getVariablePositions, "handler implements getVariablePositions, should implement getRenamePositions instead");
                        handler.getRenamePositions(part, ast, partPos, { node: currentNode, path: _self.$path }, handleCallbackError(function(response) {
                            if (response) {
                                if (!result || result.isGeneric)
                                    result = response;
                            }
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                }, function() {
                    if (!result)
                        return _self.sender.emit("renamePositionsResult");
                    result.uses = (result.uses || []).map(posFromRegion);
                    result.declarations = (result.declarations || []).map(posFromRegion);
                    result.others = (result.others || []).map(posFromRegion);
                    result.pos = posFromRegion(result.pos);
                    _self.sender.emit("renamePositionsResult", result);
                });
            });
        }, true);
    };

    this.onRenameBegin = function(event) {
        var _self = this;
        this.handlers.forEach(function(handler) {
            if (_self.isHandlerMatch(handler, null, "onRenameBegin"))
                handler.onRenameBegin(_self.doc, function() {});
        });
    };

    this.commitRename = function(event) {
        var _self = this;
        var oldId = event.data.oldId;
        var newName = event.data.newName;
        var isGeneric = event.data.isGeneric;
        var commited = false;
        
        if (oldId.value === newName)
          return this.sender.emit("commitRenameResult", {});

        asyncForEach(this.handlers, function(handler, next) {
            if (_self.isHandlerMatch(handler, null, "commitRename")) {
                handler.commitRename(_self.doc, oldId, newName, isGeneric, handleCallbackError(function(response) {
                    if (response) {
                        commited = true;
                        _self.sender.emit("commitRenameResult", { err: response, oldName: oldId.value, newName: newName });
                    } else {
                        next();
                    }
                }));
            }
            else
                next();
            },
            function() {
                if (!commited)
                    _self.sender.emit("commitRenameResult", {});
            }
        );
    };

    this.onRenameCancel = function(event) {
        var _self = this;
        asyncForEach(this.handlers, function(handler, next) {
            if (_self.isHandlerMatch(handler, null, "onRenameCancel")) {
                handler.onRenameCancel(handleCallbackError(function() {
                    next();
                }));
            }
            else {
                next();
            }
        });
    };

    var updateRunning;
    var updateWatchDog;
    this.onUpdate = function(now) {
        var _self = this;
        
        if (updateRunning) {
            this.updateAgain = { now: now || this.updateAgain && this.updateAgain.now };
            return;
        }
        
        if (this.updateScheduled && !now) {
            return;
        }
        this.updateAgain = null;
        clearTimeout(updateWatchDog);
        clearTimeout(this.updateScheduled);
        this.updateScheduled = null;

        updateWatchDog = setTimeout(function() {
            if (DEBUG)
                return console.error("Warning: worker analysis taking too long or failed to call back (" + _self.$lastAnalyzer + ")");
            _self.updateScheduled = updateRunning = null;
            console.error("Warning: worker analysis taking too long or failed to call back (" + _self.$lastAnalyzer + "), rescheduling");
        }, UPDATE_TIMEOUT_MAX + this.lastUpdateTime);
        
        if (now) {
            doUpdate(function() {
                _self.onUpdate();
            });
            return;
        }
        
        this.updateScheduled = setTimeout(function() {
            _self.updateScheduled = null;
            doUpdate(function() {
                if (_self.updateAgain)
                    _self.onUpdate(_self.updateAgain.now);
            });
        }, UPDATE_TIMEOUT_MIN + Math.min(this.lastUpdateTime, UPDATE_TIMEOUT_MAX));
        
        function doUpdate(done) {
            updateRunning = true;
            var beginUpdate = new Date().getTime();
            _self.asyncForEachHandler(
                { method: "onUpdate" },
                function(handler, next) {
                    var t = startTime();
                    handler.onUpdate(_self.doc, handleCallbackError(function() {
                        endTime(t, "Update: " + handler.$source);
                        next();
                    }));
                },
                function() {
                    _self.analyze(now, function() {
                        if (_self.postponedCursorMove) {
                            _self.onCursorMoveAnalyzed(_self.postponedCursorMove);
                            _self.postponedCursorMove = null;
                        }
                        _self.lastUpdateTime = DEBUG ? 0 : new Date().getTime() - beginUpdate;
                        clearTimeout(updateWatchDog);
                        updateRunning = false;
                        done && done();
                    });
                }
            );
        }
    };
    
    this.$documentToString = function(document) {
        if (!document)
            return "";
        if (Array.isArray(document))
            return document.join("\n");
        if (typeof document == "string")
            return document;
        var array = [];
        for (var i = 0; i < document.byteLength; i++) {
            array.push(document[i]);
        }
        return array.join("\n");
    };

    this.switchFile = function(path, immediateWindow, language, document, pos, workspaceDir) {
        var _self = this;
        var oldPath = this.$path;
        var code = this.$documentToString(document);
        this.$workspaceDir = workspaceDir === "" ? "/" : workspaceDir;
        this.$path = path;
        this.$language = language;
        this.doc.$language = language;
        this.immediateWindow = immediateWindow;
        this.lastCurrentNode = null;
        this.lastCurrentPos = null;
        this.lastCurrentPosUnparsed = null;
        this.cachedAsts = null;
        this.setValue(code);
        this.lastUpdateTime = 0;
        asyncForEach(this.handlers, function(handler, next) {
            _self.$initHandler(handler, oldPath, false, next);
        }, function() {
            _self.onUpdate(true);
        });
    };

    this.$initHandler = function(handler, oldPath, onDocumentOpen, callback) {
        var _self = this;
        handler.path = this.$path;
        handler.language = this.$language;
        handler.workspaceDir = this.$workspaceDir;
        handler.doc = this.doc;
        handler.sender = this.sender;
        handler.completeUpdate = this.completeUpdate.bind(this);
        handler.immediateWindow = this.immediateWindow;
        handler.$getIdentifierRegex = this.getIdentifierRegex.bind(this);
        this.initRegexes(handler, this.$language);
        if (!handler.$isInited) {
            handler.$isInited = true;
            handler.init(handleCallbackError(function() {
                if (handler.handlesLanguage(_self.$language))
                    handler.onDocumentOpen(_self.$path, _self.doc, oldPath, function() {});
                handler.$isInitCompleted = true;
                callback();
            }));
        }
        else if (onDocumentOpen) {
            if (handler.handlesLanguage(_self.$language))
                handler.onDocumentOpen(_self.$path, _self.doc, oldPath, function() {});
            callback();
        }
        else {
            callback();
        }
    };
    
    this.initAllRegexes = function(language) {
        if (this.$initedRegexes[language])
            return;
        this.$initedRegexes[language] = true;
        var that = this;
        this.handlers.forEach(function(h) {
            that.initRegexes(h, language);
        });
    };
    
    this.initRegexes = function(handler, language) {
        if (!handler.handlesLanguage(language))
            return;
        if (handler.getIdentifierRegex()) {
            this.sender.emit("setIdentifierRegex", { language: language, identifierRegex: handler.getIdentifierRegex() });
            identifierRegexes[language] = handler.getIdentifierRegex();
        }
        if (handler.getCacheCompletionRegex()) {
            var regex = handler.getCacheCompletionRegex();
            if (!/\$$/.test(regex.source))
                regex = new RegExp(regex.source + "$");
            this.sender.emit("setCacheCompletionRegex", { language: language, cacheCompletionRegex: regex });
            cacheCompletionRegexes[language] = regex;
        }
        if (handler.getCompletionRegex())
            this.sender.emit("setCompletionRegex", { language: language, completionRegex: handler.getCompletionRegex() });
        if (handler.getTooltipRegex())
            this.sender.emit("setTooltipRegex", { language: language, tooltipRegex: handler.getTooltipRegex() });
    };

    this.documentOpen = function(path, immediateWindow, language, document) {
        this.$openDocuments["_" + path] = path;
        var _self = this;
        var code = this.$documentToString(document);
        var doc = { getValue: function() { return code; } };
        asyncForEach(_self.handlers, function(handler, next) {
            if (!handler.handlesLanguage(language))
                return next();
            handler.onDocumentOpen(path, doc, _self.path, next);
        });
    };
    
    this.documentClose = function(event) {
        var path = event.data;
        delete this.$openDocuments["_" + path];
        this.asyncForEachHandler({ method: "onDocumentClose" }, function(handler, next) {
            handler.onDocumentClose(path, next);
        }, function() {});
    };
    function removeDuplicateMatches(matches) {
        matches.sort(function(a, b) {
            if (a.name < b.name)
                return -1;
            else if (a.name > b.name)
                return 1;
            else
                return 0;
        });
        for (var i = 0; i < matches.length - 1; i++) {
            var a = matches[i];
            var b = matches[i + 1];
            
            if (a.name === b.name || (a.id || a.name) === (b.id || b.name)) {
                if (a.isContextual && !b.isContextual)
                    matches.splice(i + 1, 1);
                else if (!a.isContextual && b.isContextual)
                    matches.splice(i, 1);
                else if (a.isGeneric && !b.isGeneric)
                    matches.splice(i, 1);
                else if (!a.isGeneric && b.isGeneric)
                    matches.splice(i + 1, 1);
                else if (a.priority < b.priority)
                    matches.splice(i, 1);
                else if (a.priority > b.priority)
                    matches.splice(i + 1, 1);
                else if (a.score < b.score)
                    matches.splice(i, 1);
                else if (a.score > b.score)
                    matches.splice(i + 1, 1);
                else
                    matches.splice(i, 1);
                i--;
            }
        }
    }

    this.complete = function(event) {
        var _self = this;
        var options = event.data;
        var pos = options.pos;
        
        _self.waitForCompletionSync(options, function doComplete(identifierRegex) {
            var cacheCompletionRegex = _self.getCacheCompletionRegex(pos);
            var overrideLine = cacheCompletionRegex && _self.tryShortenCompletionPrefix(_self.doc.getLine(pos.row), pos.column, identifierRegex);
            var overridePos = overrideLine != null && { row: pos.row, column: pos.column - 1 };
        
            var newCache = _self.tryCachedCompletion(overridePos || pos, overrideLine, identifierRegex, cacheCompletionRegex, options);
            if (!newCache || options.predictOnly) {
                if (options.predictOnly || _self.completionCache.result)
                    _self.predictNextCompletion(_self.completionCache, pos, identifierRegex, cacheCompletionRegex, options);
                return;
            }
            
            _self.completionCache = newCache;
            _self.getCompleteHandlerResult(overridePos || pos, overrideLine, identifierRegex, options, function(result) {
                if (!result) return;
                _self.sender.emit("complete", result);
                newCache.setResult(result);
                _self.predictNextCompletion(newCache, pos, identifierRegex, cacheCompletionRegex, options);
            });
        });
    };
    
    this.tryShortenCompletionPrefix = function(line, offset, identifierRegex) {
        for (var i = 0; i < this.handlers.length; i++) {
            if (this.handlers[i].$disableZeroLengthCompletion && this.handlers[i].handlesLanguage(this.$language))
                return;
        }
        if (identifierRegex.test(line[offset - 1] || "") && !identifierRegex.test(line[offset - 2] || ""))
            return line.substr(0, offset - 1) + line.substr(offset);
    };
    this.getCompleteHandlerResult = function(pos, overrideLine, identifierRegex, options, callback) {
        var _self = this;
        var matches = [];
        var hadError = false;
        var originalLine = _self.doc.getLine(pos.row);
        var line = overrideLine != null ? overrideLine : originalLine;
        var part = syntaxDetector.getContextSyntaxPart(_self.doc, pos, _self.$language);
        if (!part)
            return callback(); // cursor position not current
        var partPos = syntaxDetector.posToRegion(part.region, pos);
        var tStart = startTime();
        
        startOverrideLine();
        _self.parse(part, function(ast) {
            endTime(tStart, "Complete: parser");
            _self.findNode(ast, pos, function(currentNode) {
                var handlerOptions = {
                    noDoc: options.noDoc,
                    node: currentNode,
                    language: _self.$language,
                    path: _self.$path,
                    line: line,
                    get identifierPrefix() {
                        return completeUtil.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
                    },
                };
                _self.asyncForEachHandler(
                    { part: part, method: "complete" },
                    function(handler, next) {
                        handler.language = part.language;
                        handler.workspaceDir = _self.$workspaceDir;
                        handler.path = _self.$path;
                        var t = startTime();

                        var originalLine2 = _self.doc.getLine(pos.row);
                        startOverrideLine();
                        handler.complete(part, ast, partPos, handlerOptions, handleCallbackError(function(completions, handledErr) {
                            endTime(t, "Complete: " + handler.$source.replace("plugins/", ""), 1);
                            if (completions && completions.length)
                                matches = matches.concat(completions);
                            hadError = !!(hadError || handledErr);
                            next();
                        }));
                        endOverrideLine(originalLine2);
                    },
                    function() {
                        removeDuplicateMatches(matches);
                        matches.sort(function(a, b) {
                            if (a.priority < b.priority)
                                return 1;
                            else if (a.priority > b.priority)
                                return -1;
                            else if (a.score < b.score)
                                return 1;
                            else if (a.score > b.score)
                                return -1;
                            else if (a.id && a.id === b.id) {
                                if (a.isFunction)
                                    return -1;
                                else if (b.isFunction)
                                    return 1;
                            }
                            if (a.name < b.name)
                                return -1;
                            else if (a.name > b.name)
                                return 1;
                            else
                                return 0;
                        });
                        endTime(tStart, "COMPLETED!");
                        callback({
                            pos: pos,
                            matches: matches,
                            isUpdate: options.isUpdate,
                            noDoc: options.noDoc,
                            hadError: hadError,
                            line: line,
                            path: _self.$path,
                            forceBox: options.forceBox,
                            deleteSuffix: options.deleteSuffix
                        }
                    );
                });
            });
        });
        endOverrideLine(originalLine);
        function startOverrideLine() {
            if (overrideLine != null)
                _self.doc.$lines[pos.row] = overrideLine;
            
            _self.$overrideLine = overrideLine;
            _self.$lastCompleteRow = pos.row;
        }
        
        function endOverrideLine(line) {
            _self.$overrideLine = null;
            _self.doc.$lines[pos.row] = line;
        }
    };
    this.tryCachedCompletion = function(pos, overrideLine, identifierRegex, cacheCompletionRegex, options) {
        var that = this;
        var cacheKey = this.getCompleteCacheKey(pos, overrideLine, identifierRegex, cacheCompletionRegex, options);
        
        if (options.isUpdate) {
            if (cacheKey.isCompatible(this.completionCache))
                return this.completionCache;
            if (cacheKey.isCompatible(this.completionPrediction))
                return this.completionPrediction;
        }
    
        if (cacheKey.isCompatible(this.completionCache) && !isRecompletionRequired(this.completionCache)) {
            if (this.completionCache.result)
                cacheHit(this.completionCache);
            else
                this.completionCache.resultCallbacks.push(cacheHit);
            return;
        }
    
        if (cacheKey.isCompatible(this.completionPrediction) && !isRecompletionRequired(this.completionPrediction)) {
            this.completionCache = this.completionPrediction;
            if (this.completionCache.result)
                cacheHit(this.completionCache);
            else
                this.completionCache.resultCallbacks.push(cacheHit);
            return;
        }
        
        return cacheKey;
            
        function cacheHit(cache) {
            if (options.predictOnly)
                return;
                
            updateLocalCompletions(that.doc, that.$path, pos, cache.result.matches, function sendCached(err, matches) {
                if (err) {
                    console.error(err);
                    matches = cache.result.matches;
                }
                that.sender.emit("complete", {
                    line: overrideLine != null ? overrideLine : that.doc.getLine(pos.row),
                    forceBox: options.forceBox,
                    isUpdate: options.isUpdate,
                    matches: matches,
                    path: that.$path,
                    pos: pos,
                    noDoc: cache.result.noDoc,
                    deleteSuffix: options.deleteSuffix,
                });
            });
        }
        
        function isRecompletionRequired(cache) {
            var recomputeLength = -1;
            var recomputeAtOffset1 = false;
            for (var i = 0; i < that.handlers.length; i++) {
                if (that.handlers[i].$recacheCompletionLength && that.handlers[i].handlesLanguage(that.$language))
                    recomputeLength = that.handlers[i].$recacheCompletionLength;
                if (that.handlers[i].$disableZeroLengthCompletion && that.handlers[i].handlesLanguage(that.$language))
                    recomputeAtOffset1 = true;
            }
            
            if (recomputeAtOffset1 && cacheKey.prefix.length >= 1 && cache.prefix.length === 0)
                return true;
            
            return cacheKey.prefix.length >= recomputeLength && cache.prefix.length < recomputeLength;
        }
    };
    this.predictNextCompletion = function(cacheKey, pos, identifierRegex, cacheCompletionRegex, options) {
        if (options.isUpdate)
            return;
        
        var _self = this;
        var predictedString;
        var showEarly;
        var line = _self.doc.getLine(pos.row);
        var prefix = completeUtil.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
        
        this.asyncForEachHandler(
            { method: "predictNextCompletion" },
            function preparePredictionInput(handler, next) {
                var handlerOptions = {
                    matches: options.predictOnly ? [] : getFilteredMatches(),
                    path: _self.$path,
                    language: _self.$language,
                    line: line,
                    identifierPrefix: prefix,
                };
                handler.predictNextCompletion(_self.doc, null, pos, handlerOptions, handleCallbackError(function(result) {
                    if (result != null) {
                        predictedString = result.predicted;
                        showEarly = result.showEarly;
                    }
                    next();
                }));
            },
            function computePrediction() {
                if (predictedString == null)
                    return;
                
                var predictedLine = line.substr(0, pos.column - prefix.length)
                    + predictedString
                    + line.substr(pos.column);
                var predictedPos = { row: pos.row, column: pos.column - prefix.length + predictedString.length };
                
                var predictionKey = _self.getCompleteCacheKey(predictedPos, predictedLine, identifierRegex, cacheCompletionRegex, options);
                if (_self.completionPrediction && _self.completionPrediction.isCompatible(predictionKey))
                    return;
                if (_self.completionCache && _self.completionCache.isCompatible(predictionKey))
                    return;
                _self.completionPrediction = predictionKey;

                _self.getCompleteHandlerResult(predictedPos, predictedLine, identifierRegex, options, function(result) {
                    predictionKey.setResult(result);
                    if (showEarly && cacheKey.isCompatible(_self.completionCache))
                        showPredictionsEarly(result);
                });
            }
        );
        
        var filteredMatches;
        function getFilteredMatches() {
            if (filteredMatches)
                return filteredMatches;
            var prefix = completeUtil.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
            filteredMatches = cacheKey.result.matches.filter(function(m) {
                m.replaceText = m.replaceText || m.name;
                return m.replaceText.indexOf(prefix) === 0;
            });
            return filteredMatches;
        }
        
        function showPredictionsEarly(prediction) {
            var newMatches = prediction.matches.filter(function(m) { return m.isContextual; });
            if (!newMatches.length)
                return;
            [].push.apply(_self.completionCache.result.matches, newMatches.map(function(m) {
                m = Object.assign({}, m);
                m.replaceText = predictedString + m.replaceText;
                m.name = predictedString + m.name;
                return m;
            }));
            _self.sender.emit("complete", _self.completionCache.result);
        }
    };
    this.getCompleteCacheKey = function(pos, overrideLine, identifierRegex, cacheCompletionRegex, options) {
        var worker = this;
        var doc = this.doc;
        var path = this.$path;
        var originalLine = doc.getLine(pos.row);
        var line = overrideLine != null ? overrideLine : originalLine;
        var prefix = completeUtil.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
        var suffix = completeUtil.retrieveFollowingIdentifier(line, pos.column, identifierRegex);
        var completeLine = removeCacheCompletionPrefix(
            line.substr(0, pos.column - prefix.length) + line.substr(pos.column + suffix.length));
        
        var completeLines = doc.$lines.slice();
        completeLines[pos.row] = null;
        
        var completePos = { row: pos.row, column: pos.column - prefix.length };
        return {
            result: null,
            resultCallbacks: [],
            line: completeLine,
            lines: completeLines,
            pos: completePos,
            prefix: prefix,
            path: path,
            noDoc: options.noDoc,
            setResult: function(result) {
                var cacheKey = this;
                this.result = result;
                this.resultCallbacks.forEach(function(c) {
                    c(cacheKey);
                });
                if (result.hadError && worker.completionCache === this)
                    worker.completionCache = null;
                if (result.hadError && worker.completionPrediction === this)
                    worker.completionPrediction = null;
            },
            isCompatible: function(other) {
                return other
                    && other.path === this.path
                    && other.pos.row === this.pos.row
                    && other.pos.column === this.pos.column
                    && other.line === this.line
                    && (!other.noDoc || this.noDoc)
                    && this.prefix.indexOf(other.prefix) === 0 // match if they're like foo and we're fooo
                    && other.lines.length === completeLines.length
                    && other.lines[this.pos.row - 1] === completeLines[this.pos.row - 1]
                    && other.lines[this.pos.row + 1] === completeLines[this.pos.row + 1]
                    && other.lines.every(function(l, i) {
                        return l === completeLines[i];
                    });
            }
        };
        
        function removeCacheCompletionPrefix(line) {
            if (!cacheCompletionRegex)
                return line;
            var match = cacheCompletionRegex.exec(line.substr(0, pos.column - prefix.length));
            if (!match)
                return line;
            pos = { row: pos.row, column: pos.column - match[0].length };
            return line.substr(0, line.length - match[0].length);
        }
    };
    this.waitForCompletionSync = function(options, runCompletion) {
        var _self = this;
        var pos = options.pos;
        var line = _self.doc.getLine(pos.row);
        this.waitForCompletionSyncThread = this.waitForCompletionSyncThread || 0;
        var threadId = ++this.waitForCompletionSyncThread;
        var identifierRegex = this.getIdentifierRegex(pos);
        if (!completeUtil.canCompleteForChangedLine(line, options.line, pos, pos, identifierRegex)) {
            setTimeout(function() {
                if (threadId !== _self.waitForCompletionSyncThread)
                    return;
                line = _self.doc.getLine(pos.row);
                if (!completeUtil.canCompleteForChangedLine(line, options.line, pos, pos, identifierRegex)) {
                    setTimeout(function() {
                        if (threadId !== _self.waitForCompletionSyncThread)
                            return;
                        line = _self.doc.getLine(pos.row);
                        if (!completeUtil.canCompleteForChangedLine(line, options.line, pos, pos, identifierRegex)) {
                            if (!line) { // sanity check
                                console.log("worker: seeing an empty line in my copy of the document, won't complete");
                            }
                            return console.log("worker: dropped completion request as my copy of the document said: " + line); // ugh give up already
                        }
                        runCompletion(identifierRegex);
                    }, 20);
                    return;
                }
                runCompletion(identifierRegex);
            }, 5);
            return;
        }
        runCompletion(identifierRegex);
    };
    this.completeUpdate = function(pos, line) {
        assert(line !== undefined);
        this.completionCache = null;
        if (!isInWebWorker) { // Avoid making the stack too deep in ?noworker=1 mode
            var _self = this;
            setTimeout(function onCompleteUpdate() {
                _self.complete({ data: { pos: pos, line: line, isUpdate: true }});
            }, 0);
        }
        else {
            this.complete({ data: { pos: pos, line: line, isUpdate: true, forceBox: true }});
        }
    };
    function updateLocalCompletions(doc, path, pos, matches, callback) {
        if (matches.some(function(m) {
            return m.isContextual;
        }))
            return callback(null, matches);

        localCompleter.complete(doc, null, pos, null, function(err, results1) {
            if (err) return callback(err);
            openFilesCompleter.complete(doc, null, pos, { path: path }, function(err, results2) {
                if (err) console.error(err);

                callback(null, matches.filter(function(m) {
                    return m.$source !== "local" && m.$source !== "open_files";
                }).concat(results1, results2));
            });
        });
    }
    
    function reportError(exception, data) {
        if (data)
            exception.data = data;
        setTimeout(function() {
            throw exception; // throw bare exception so it gets reported
        });
    }
    
    function handleCallbackError(callback) {
        return function(optionalErr, result) {
            if (optionalErr &&
                (optionalErr instanceof Error || typeof optionalErr === "string" || optionalErr.stack || optionalErr.code)) {
                if (optionalErr.code !== "ESUPERSEDED")
                    console.error(optionalErr.stack || optionalErr);
                return callback(null, optionalErr);
            }
            callback(optionalErr || result);
        };
    }

}).call(LanguageWorker.prototype);

});

define("plugins/c9.ide.language.javascript/JSResolver",[], function(require, exports, module) {
  "use strict";

  var Range = require("ace/range").Range;

  var JSResolver = function(value, ast) {
    this.addResolutions = function(markers) {
      var _self = this;
      markers.forEach(function(curMarker) {
        curMarker.resolutions = _self.getResolutions(curMarker);
      });
    };
    
    this.getResolutions = function(marker) {
      var type = this.getType(marker);
      if (type) {
        if (typeof this[type] === 'function') {
          return this[type](marker);
        }
      }
      return [];
    }; 

    this.getType = function(marker) {
        var msg = marker.message;
        if (msg.indexOf("Missing semicolon") !== -1) {
            return "missingSemicolon";
        }
        else if (msg.indexOf("Unnecessary semicolon") !== -1) {
            return "unnecessarySemicolon";
        }
    }; 
    
    this.missingSemicolon = function(marker) {
        var message = "Add semicolon";
        var image = "";
        var row = marker.pos.sl;
        var column = marker.pos.sc;
        
        var lines = value.split("\n");
        var before = lines[row].substring(0, column);
        var after = lines[row].substring(column);
        var preview = "<b>Add semicolon</b><p>" + before + "<b>; </b>" + after + "</p>";
        
        var insert = ";";
        if (after.length) {
            insert += " ";
        }

        var delta = {
            action: "insert",
            range: new Range(row, column, row, column + insert.length),
            text: insert
        };
        
        return [{
            message: message,
            image: image,
            previewHtml: preview,
            deltas: [delta]
        }];
    };
    
    this.unnecessarySemicolon = function(marker) {
        var message = "Remove semicolon";
        var image = "";
        var row = marker.pos.sl;
        var column = marker.pos.sc;
        
        var lines = value.split("\n");
        var before = lines[row].substring(0, column);
        var after = lines[row].substring(column + 1);
        var preview = "<b>Remove semicolon</b><p>" + before + "<del>;</del>" + after + "</p>";

        var delta = {
            action: "removeText",
            range: new Range(row, column, row, column + 1)
        };
        
        return [{
            message: message,
            image: image,
            preview: preview,
            deltas: [delta]
        }];
    };

  };

  exports.JSResolver = JSResolver;

});

define("plugins/c9.ide.language.javascript/scope_analyzer",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var completeUtil = require("plugins/c9.ide.language/complete_util");
var handler = module.exports = Object.create(baseLanguageHandler);
var JSResolver = require('plugins/c9.ide.language.javascript/JSResolver').JSResolver;
require("treehugger/traverse"); // add traversal functions to trees

var CALLBACK_METHODS = ["forEach", "map", "reduce", "filter", "every", "some",
    "__defineGetter__", , "__defineSetter__"];
var CALLBACK_FUNCTIONS = ["require", "setTimeout", "setInterval"];
var PROPER = module.exports.PROPER = 80;
var MAYBE_PROPER = module.exports.MAYBE_PROPER = 1;
var NOT_PROPER = module.exports.NOT_PROPER = 0;
var KIND_EVENT = module.exports.KIND_EVENT = "event";
var KIND_PACKAGE = module.exports.KIND_PACKAGE = "package";
var KIND_HIDDEN = module.exports.KIND_HIDDEN = "hidden";
var KIND_DEFAULT = module.exports.KIND_DEFAULT = undefined;
var IN_CALLBACK_DEF = 1;
var IN_CALLBACK_BODY = 2;
var IN_CALLBACK_BODY_MAYBE = 3;

var lastValue;
var lastAST;
var GLOBALS = {
    "true": true,
    "false": true,
    "undefined": true,
    "null": true,
    "arguments": true,
    "Infinity": true,
    onmessage: true,
    postMessage: true,
    importScripts: true,
    "continue": true,
    "return": true,
    "else": true,
    ArrayBuffer: true,
    Attr: true,
    Audio: true,
    addEventListener: true,
    applicationCache: true,
    blur: true,
    clearInterval: true,
    clearTimeout: true,
    close: true,
    closed: true,
    DataView: true,
    defaultStatus: true,
    document: true,
    event: true,
    FileReader: true,
    Float32Array: true,
    Float64Array: true,
    FormData: true,
    getComputedStyle: true,
    Int16Array: true,
    Int32Array: true,
    Int8Array: true,
    parent: true,
    print: true,
    removeEventListener: true,
    resizeBy: true,
    resizeTo: true,
    self: true,
    screen: true,
    scroll: true,
    scrollBy: true,
    scrollTo: true,
    sessionStorage: true,
    setInterval: true,
    setTimeout: true,
    SharedWorker: true,
    Uint16Array: true,
    Uint32Array: true,
    Uint8Array: true,
    WebSocket: true,
    window: true,
    Worker: true,
    XMLHttpRequest: true,
    alert: true,
    confirm: true,
    console: true,
    prompt: true,
    define: true,
    __filename: true,
    __dirname: true,
    Buffer: true,
    exports: true,
    GLOBAL: true,
    global: true,
    module: true,
    process: true,
    require: true,
    Array: true,
    Boolean: true,
    Date: true,
    decodeURI: true,
    decodeURIComponent: true,
    encodeURI: true,
    encodeURIComponent: true,
    Error: true,
    'eval': true,
    EvalError: true,
    Function: true,
    hasOwnProperty: true,
    isFinite: true,
    isNaN: true,
    JSON: true,
    Math: true,
    Number: true,
    Object: true,
    parseInt: true,
    parseFloat: true,
    RangeError: true,
    ReferenceError: true,
    RegExp: true,
    String: true,
    requestAnimationFrame: true,
    SyntaxError: true,
    TypeError: true,
    URIError: true,
    escape: true,
    unescape: true,
    Match: true,
    MeteorSubscribeHandle: true,
    Accounts: true,
    Blaze: true,
    DDP: true,
    EJSON: true,
    Meteor: true,
    Mongo: true,
    Tracker: true,
    Assets: true,
    App: true,
    Plugin: true,
    Package: true,
    Npm: true,
    Cordova: true,
    currentUser: true,
    loggingIn: true,
    Template: true,
    MethodInvocation: true,
    Subscription: true,
    CompileStep: true,
    check: true,
    Email: true,
    HTTP: true,
    ReactiveVar: true,
    Session: true,
    PackageAPI: true,
};

var KEYWORDS = [
    "break",
    "const",
    "continue",
    "delete",
    "do",
    "while",
    "export",
    "for",
    "in",
    "function",
    "if",
    "else",
    "import",
    "instanceof",
    "new",
    "return",
    "switch",
    "this",
    "throw",
    "try",
    "catch",
    "typeof",
    "void",
    "with",
    "debugger"
];
handler.GLOBALS = GLOBALS;

handler.addGlobals = function(globals) {
    globals.forEach(function(g) {
        GLOBALS[g] = true;
    });
};

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};
 
handler.getResolutions = function(value, ast, markers, callback) {
    var resolver = new JSResolver(value, ast);
    resolver.addResolutions(markers);
    callback(markers);
};

handler.getMaxFileSizeSupported = function() {
    return .25 * 10 * 1000 * 80;
};

var scopeId = 0;

var Variable = module.exports.Variable = function Variable(declaration) {
    this.declarations = [];
    if (declaration)
        this.declarations.push(declaration);
    this.uses = [];
    this.values = [];
};

Variable.prototype.addUse = function(node) {
    this.uses.push(node);
};

Variable.prototype.addDeclaration = function(node) {
    this.declarations.push(node);
};

Variable.prototype.markProperDeclaration = function(confidence) {
    if (!confidence)
        return;
    else if (!this.properDeclarationConfidence)
        this.properDeclarationConfidence = confidence;
    else if (this.properDeclarationConfidence < PROPER)
        this.properDeclarationConfidence += confidence;
};

Variable.prototype.isProperDeclaration = function() {
    return this.properDeclarationConfidence > MAYBE_PROPER;
};
var Scope = module.exports.Scope = function Scope(parent) {
    this.id = scopeId++;
    this.parent = parent;
    this.vars = {};
};
Scope.prototype.declare = function(name, resolveNode, properDeclarationConfidence, kind) {
    var result;
    var vars = this.getVars(kind);
    if (!vars['_' + name]) {
        result = vars['_' + name] = new Variable(resolveNode);
    }
    else if (resolveNode) {
        result = vars['_' + name];
        result.addDeclaration(resolveNode);
    }
    if (result) {
        result.markProperDeclaration(properDeclarationConfidence);
        result.kind = kind;
    }
    return result;
};

Scope.prototype.declareAlias = function(kind, originalName, newName) {
    var vars = this.getVars(kind);
    vars["_" + newName] = vars["_" + originalName];
};

Scope.prototype.getVars = function(kind) {
    if (kind)
        return this.vars[kind] = this.vars[kind] || {};
    else
        return this.vars;
};

Scope.prototype.isDeclared = function(name) {
    return !!this.get(name);
};
Scope.prototype.get = function(name, kind) {
    var vars = this.getVars(kind);
    if (vars['_' + name])
        return vars['_' + name];
    else if (this.parent)
        return this.parent.get(name, kind);
};

Scope.prototype.getVariableNames = function() {
    return this.getNamesByKind(KIND_DEFAULT);
};

Scope.prototype.getNamesByKind = function(kind) {
    var results = [];
    var vars = this.getVars(kind);
    for (var v in vars) {
        if (vars.hasOwnProperty(v) && v !== KIND_HIDDEN && v !== KIND_PACKAGE)
            results.push(v.slice(1));
    }
    if (this.parent) {
        var namesFromParent = this.parent.getNamesByKind(kind);
        for (var i = 0; i < namesFromParent.length; i++) {
            results.push(namesFromParent[i]);
        }
    }
    return results;
};

var SCOPE_ARRAY = Object.keys(GLOBALS).concat(KEYWORDS);

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z_0-9\$\/]/);
};

handler.complete = function(doc, ast, pos, options, callback) {
    if (!options.node || options.node.cons === "Var" || options.line[pos.column] === ".")
        return callback();

    var identifier = options.identifierPrefix;
    
    var matches = completeUtil.findCompletions(identifier, SCOPE_ARRAY);
    callback(matches.map(function(m) {
        return {
          name: m,
          replaceText: m,
          icon: null,
          meta: "EcmaScript",
          priority: 0,
          isGeneric: true
        };
    }));
};
handler.analyze = function(value, ast, callback, minimalAnalysis) {
    var handler = this;
    var markers = [];
    
    if (minimalAnalysis && value === lastValue && lastAST == ast)
        return callback();
    lastValue = value;
    lastAST = ast;
    function preDeclareHoisted(scope, node) {
        node.traverseTopDown(
            'VarDecl(x)', 'ConstDecl(x)', 'LetDecl(x)', function(b, node) {
                node.setAnnotation("scope", scope);
                scope.declare(b.x.value, b.x, PROPER);
                return node;
            },
            'VarDeclInit(x, e)', 'ConstDeclInit(x, e)', 'LetDeclInit(x, e)', function(b, node) {
                node.setAnnotation("scope", scope);
                scope.declare(b.x.value, b.x, PROPER);
            },
            'Function(x, _, _)', function(b, node) {
                node.setAnnotation("scope", scope);
                if (b.x.value) {
                    scope.declare(b.x.value, b.x, PROPER);
                }
                return node;
            },
            'ImportDecl(_, x)', 'ImportBatchDecl(x)', function(b, node) {
                if (b.x.cons !== "Var")
                    return node;
                scope.declare(b.x[0].value, b.x[0], PROPER);
                return node;
            }
        );
    }
    
    function scopeAnalyzer(scope, node, parentLocalVars, inCallback) {
        preDeclareHoisted(scope, node);
        node.setAnnotation("scope", scope);
        function analyze(scope, node, inCallback) {
            node.traverseTopDown(
                'Assign(Var(x), e)', function(b, node) {		
                    if (scope.isDeclared(b.x.value)) {
                        node[0].setAnnotation("scope", scope);		
                        scope.get(b.x.value).addUse(node[0]);		
                    }		
                    analyze(scope, b.e, inCallback);		
                    return node;		
                },
                'ImportDecl(_, x)', 'ImportBatchDecl(x)', function(b, node) {
                    return node;
                },
                'Var(x)', function(b, node) {
                    node.setAnnotation("scope", scope);
                    if (scope.isDeclared(b.x.value)) {
                        scope.get(b.x.value).addUse(node);
                    }
                    else if (b.x.value === "self"
                        && !scope.isDeclared(b.x.value)
                        && handler.isFeatureEnabled("undeclaredVars")) {
                        markers.push({
                            pos: this.getPos(),
                            level: 'warning',
                            type: 'warning',
                            message: "Use 'window.self' to refer to the 'self' global."
                        });
                        return;
                    }
                    return node;
                },
                'Function(x, fargs, body)', function(b, node) {
                    var newScope = new Scope(scope);
                    node.setAnnotation("localScope", newScope);
                    newScope.declare("this");
                    b.fargs.forEach(function(farg) {
                        farg.setAnnotation("scope", newScope);
                        newScope.declare(farg[0].value, farg);
                    });
                    var inBody = inCallback === IN_CALLBACK_DEF ? IN_CALLBACK_BODY : isCallback(node);
                    scopeAnalyzer(newScope, b.body, null, inBody);
                    return node;
                },
                'Arrow(fargs, body)', function(b, node) {
                    var newScope = new Scope(scope);
                    node.setAnnotation("localScope", newScope);
                    newScope.declare("this");
                    b.fargs.forEach(function(farg) {
                        farg.setAnnotation("scope", newScope);
                        newScope.declare(farg[0].value, farg);
                    });
                    scopeAnalyzer(newScope, b.body, null, inCallback);
                    return node;
                },
                'Catch(x, body)', function(b, node) {
                    var oldVar = scope.get(b.x.value);
                    scope.vars["_" + b.x.value] = new Variable(b.x);
                    scopeAnalyzer(scope, b.body, parentLocalVars, inCallback);
                    scope.vars["_" + b.x.value] = oldVar;
                    return node;
                },
                'If(Var("err"), Call(fn, args), None())', function(b, node) {
                    if (b.args.collectTopDown('Var("err")').length > 0 &&
                        !b.fn.isMatch('PropAccess(Var("console"), _)') &&
                        !b.fn.isMatch('PropAccess(_, "log")'))
                        markers.push({
                            pos: b.fn.getPos(),
                            type: 'warning',
                            level: 'warning',
                            message: "Did you forget a 'return' here?"
                        });
                },
                'PropAccess(_, "lenght")', function(b, node) {
                    markers.push({
                        pos: node.getPos(),
                        type: 'warning',
                        level: 'warning',
                        message: "Did you mean 'length'?"
                    });
                },
                'Call(PropAccess(e1, "bind"), e2)', function(b) {
                    analyze(scope, b.e1, 0);
                    analyze(scope, b.e2, inCallback);
                    return this;
                },
                'Call(e, args)', function(b, node) {
                    analyze(scope, b.e, inCallback);
                    var newInCallback = inCallback || (isCallbackCall(node) ? IN_CALLBACK_DEF : 0);
                    analyze(scope, b.args, newInCallback);
                    return node;
                },
                'Block(_)', function(b, node) {
                    node.setAnnotation("scope", scope);
                },
                'For(e1, e2, e3, body)', function(b) {
                    analyze(scope, b.e1, inCallback);
                    analyze(scope, b.e2, inCallback);
                    analyze(scope, b.body, inCallback);
                    analyze(scope, b.e3, inCallback);
                    return node;
                },
                'ForIn(e1, e2, body)', 'ForOf(e1, e2, body)', function(b) {
                    analyze(scope, b.e2, inCallback);
                    analyze(scope, b.e1, inCallback);
                    analyze(scope, b.body, inCallback);
                    return node;
                }
            );
        }
        analyze(scope, node, inCallback);
    }
    
    if (ast) {
        var rootScope = new Scope();
        scopeAnalyzer(rootScope, ast);
        addDefineWarnings(ast, markers);
    }
    return callback(markers);
};

function addDefineWarnings(ast, markers) {
    var isArchitect;
    var outerStrictNode;
    ast.forEach(function(node) {
        node.rewrite(
            'String("use strict")', function(b, node) {
                outerStrictNode = node;
            },
            'Call(Var("define"), [Function(_, _, body)])', function(b, node) {
                b.body.forEach(function(node) {
                    if (outerStrictNode) {
                        markers.push({
                            pos: outerStrictNode.getPos(),
                            type: 'warning',
                            level: 'warning',
                            message: '"use strict" outside define()'
                        });
                    }

                    node.rewrite(
                        'Assign(PropAccess(Var("main"), "provides"),_)', function(b, node) {
                            isArchitect = true;
                        },
                        'Function("main", _, body)', function(b, node) {
                            if (!isArchitect)
                                return;
                            addCloud9PluginWarnings(b.body, markers);
                        }
                    );
                });
            }
        );
    });
}

function addCloud9PluginWarnings(body, markers) {
    var isCoreSource = /plugins\/c9\./.test(handler.path);
    var pluginVars = {};
    var unloadFunction;
    var unloadReference;
    var maybeUnloadFunction;

    body.forEach(function(node) {
        node.rewrite(
            'VarDecls(vars)', function(b, node) {
                b.vars.forEach(function(v) {
                    v.rewrite(
                        'VarDecl(x)', 'LetDecl(x)',
                        'VarDeclInit(x, _)', 'LetDeclInit(x, _)',
                        function(b, node) {
                            pluginVars[b.x.value] = node;
                        }
                    );
                });
            },
            'Call(PropAccess(Var("plugin"), "on"), [String("unload"), Function(_, _, fn)])', function(b, node) {
                unloadFunction = b.fn;
            },
            'Call(PropAccess(Var("plugin"), "on"), [String("unload"), ref])', function(b, node) {
                unloadReference = b.ref;
            },
            'Function("unload", _, fn)', function(b, node) {
                maybeUnloadFunction = b.fn;
            }
        );
    });

    if (!unloadFunction && unloadReference && maybeUnloadFunction
        && unloadReference[0] && unloadReference[0].value === "unload")
        unloadFunction = maybeUnloadFunction;

    if (!unloadFunction) {
        if (pluginVars.plugin && !unloadReference) {
            markers.push({
                pos: pluginVars.plugin.getPos(),
                type: isCoreSource ? "info" : "warning",
                message:
                    isCoreSource
                        ? "No plugin.on(\"load\", function() {}) and/or plugin.on(\"unload\", function() {}) found"
                        : "Missing plugin.on(\"load\", function() {}) or plugin.on(\"unload\", function() {})"
            });
        }
        return;
    }

    var mustUninitVars = {};
    body.traverseTopDown(
        'Assign(Var(x), _)', 'Call(Var(x), "push", _)', function(b, node) {
            if (pluginVars[b.x.value])
                mustUninitVars[b.x.value] = pluginVars[b.x.value];
        }
    );
    
    unloadFunction.traverseTopDown(
        'Var(x)', function(b, node) {
            delete mustUninitVars[b.x.value];
        }
    );

    for (var v in mustUninitVars) {
        if (v === v.toUpperCase())
            continue;
        markers.push({
            pos: mustUninitVars[v].getPos(),
            type: isCoreSource ? "info" : "warning",
            message: "Plugin state; please uninit/reset '" + v + "' in plugin unload function"
        });
    }
}
var isCallbackCall = function(node) {
    var result;
    node.rewrite(
        'Call(PropAccess(_, p), args)', function(b) {
            if (b.args.length === 1 && CALLBACK_METHODS.indexOf(b.p.value) !== -1)
                result = true;
        },
        'Call(Var(f), _)', function(b) {
            if (CALLBACK_FUNCTIONS.indexOf(b.f.value) !== -1)
                result = true;
        }
    );
    return result;
};
var isCallback = function(node) {
    var parent = node.parent;
    var parentParent = parent && parent.parent;
    if (!parentParent)
        return false;
    try {
        if (!parentParent.isMatch)
            console.log("isCallback debug:", JSON.stringify(parentParent));
    } catch (e) {
    }
    if (parent.isMatch('PropAccess(_, "call")')
        || parent.isMatch('PropAccess(_, "apply")')
        || parent.isMatch('PropAccess(_, "bind")')
        || !parentParent.isMatch('Call(_, _)')
        || (parentParent.cons === "Call" &&
            parentParent[0].cons === "PropAccess" &&
            parentParent[1].length > 1 &&
            CALLBACK_METHODS.indexOf(parentParent[0][1].value) > -1)
        )
        return false;
    var result = 0;
    node.rewrite(
        'Function(_, fargs, _)', function(b) {
            if (b.fargs.length === 0 || b.fargs[0].cons !== 'FArg')
                return result = IN_CALLBACK_BODY_MAYBE;
            var name = b.fargs[0][0].value;
            result = name === 'err' || name === 'error' || name === 'exc'
                ? IN_CALLBACK_BODY
                : IN_CALLBACK_BODY_MAYBE;
        }
    );
    return result;
};

handler.getRefactorings =
handler.highlightOccurrences = function(doc, fullAst, cursorPos, options, callback) {
    if (!options.node)
        return callback();
    
    if (!fullAst.annos.scope) {
        return handler.analyze(doc.getValue(), fullAst, function() {
            handler.highlightOccurrences(doc, fullAst, cursorPos, options, callback);
        }, true);
    }

    var markers = [];
    var enableRefactorings = [];
    
    function highlightVariable(v) {
        if (!v)
            return;
        v.declarations.forEach(function(decl) {
            if (decl.getPos())
                markers.push({
                    pos: decl.getPos(),
                    type: 'occurrence_main'
                });
        });
        v.uses.forEach(function(node) {
            markers.push({
                pos: node.getPos(),
                type: 'occurrence_other'
            });
        });
    }
    options.node.rewrite(
        'Var(x)', function(b, node) {
            var scope = node.getAnnotation("scope");
            if (!scope)
                return;
            var v = scope.get(b.x.value);
            highlightVariable(v);
            if (b.x.value !== "this" && v)
                enableRefactorings.push("rename");
        },
        'VarDeclInit(x, _)', 'ConstDeclInit(x, _)', 'LetDeclInit(x, _)', function(b) {
            highlightVariable(this.getAnnotation("scope").get(b.x.value));
            enableRefactorings.push("rename");
        },
        'VarDecl(x)', 'ConstDecl(x)', 'LetDecl(x)', function(b) {
            highlightVariable(this.getAnnotation("scope").get(b.x.value));
            enableRefactorings.push("rename");
        },
        'FArg(x)', function(b) {
            highlightVariable(this.getAnnotation("scope").get(b.x.value));
            enableRefactorings.push("rename");
        },
        'Function(x, _, _)', function(b, node) {
            if (!b.x.value || !node.getAnnotation("scope"))
                return;
            highlightVariable(node.getAnnotation("scope").get(b.x.value));
            enableRefactorings.push("rename");
        }
    );

    callback({
        markers: markers,
        refactorings: enableRefactorings
    });
};

handler.getRenamePositions = function(doc, fullAst, cursorPos, options, callback) {
    var currentNode = options.node;
    if (!fullAst || !currentNode)
        return callback();
    
    if (!fullAst.annos.scope) {
        return handler.analyze(doc.getValue(), fullAst, function() {
            handler.getRenamePositions(doc, fullAst, cursorPos, options, callback);
        }, true);
    }

    var v;
    var mainNode;
    currentNode.rewrite(
        'VarDeclInit(x, _)', 'ConstDeclInit(x, _)', 'LetDeclInit(x, _)', function(b, node) {
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = b.x;
        },
        'VarDecl(x)', 'ConstDecl(x)', 'LetDecl(x)', function(b, node) {
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = b.x;
        },
        'FArg(x)', function(b, node) {
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = node;
        },
        'Function(x, _, _)', function(b, node) {
            if (!b.x.value)
                return;
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = b.x;
        },
        'Var(x)', function(b, node) {
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = node;
        }
    );
    if (!mainNode) {
        return callback();
    }
    
    var pos = mainNode.getPos();
    var declarations = [];
    var uses = [];

    var length = pos.ec - pos.sc;
    v && v.declarations.forEach(function(node) {
         if (node !== currentNode[0]) {
            var pos = node.getPos();
            declarations.push({ column: pos.sc, row: pos.sl });
        }
    });
    
    v && v.uses.forEach(function(node) {
        if (node !== currentNode) {
            var pos = node.getPos();
            uses.push({ column: pos.sc, row: pos.sl });
        }
    });
    callback({
        length: length,
        pos: {
            row: pos.sl,
            column: pos.sc
        },
        others: declarations.concat(uses),
        declarations: declarations,
        uses: uses
    });
};

});

define("plugins/c9.ide.language/worker_util",[], function(require, exports, module) {

var worker = require("plugins/c9.ide.language.core/worker");
var completeUtil = require("./complete_util");

var MAX_MEMO_DICT_SIZE = 3000;
var msgId = 0;
var docCache = { row: null, entries: {}};

module.exports = {
    isFeatureEnabled: function(name) {
        return !disabledFeatures[name];
    },
    getIdentifierRegex: function(offset) {
        return worker.$lastWorker.getIdentifierRegex(offset);
    },
    completeUpdate: function(pos, line) {
        return worker.$lastWorker.completeUpdate(pos, line);
    },
    execFile: function(path, options, callback) {
        if (typeof options === "function")
            return this.execFile(path, {}, arguments[1]);
        
        var id = msgId++;
        worker.sender.emit("execFile", { path: path, options: options, id: id });
        worker.sender.on("execFileResult", function onExecFileResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("execFileResult", onExecFileResult);
            callback && callback(event.data.err, event.data.stdout, event.data.stderr);
        });
    },
    spawn: function(path, options, callback) {
        if (typeof options === "function")
            return this.execFile(path, {}, arguments[1]);
        
        var id = msgId++;
        worker.sender.emit("spawn", { path: path, options: options, id: id });
        worker.sender.on("spawnResult", function onSpawnResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("spawnResult", onSpawnResult);
            callback && callback(event.data.err, {
                stdout: { on: listen.bind(null, "stdout") },
                stderr: { on: listen.bind(null, "stderr") },
                on: listen.bind(null, "child"),
                kill: function(signal) {
                    worker.sender.emit("spawn_kill$" + id, { signal: signal });
                }
            });
            
            function listen(sourceName, event, listener) {
                worker.sender.on("spawnEvent$" + id + sourceName + event, function(e) {
                    listener(e.data);
                });
                worker.sender.on("spawnEvent$" + id + "childexit", function gc() {
                    setTimeout(function() {
                        worker.sender.off("spawnEvent$" + id + sourceName + event, listener);
                        worker.sender.off("spawnEvent$" + id + "childexit", gc);
                    });
                });
            }
        });
    },
    execAnalysis: function(command, options, callback) {
        if (typeof options === "function")
            return this.execAnalysis(command, {}, arguments[1]);
        
        var myWorker = worker.$lastWorker;
        options.command = command;
        options.path = options.path || (myWorker.$path && myWorker.$path[0] === "/" ? myWorker.$path.substr(1) : myWorker.$path);
        options.cwd = options.cwd || getRelativeDirname(options.path);
        options.maxBuffer = options.maxBuffer || 200 * 1024;
        var maxCallInterval = options.maxCallInterval || 50;
        if (myWorker.$overrideLine) {
            maxCallInterval = 0;
            options.overrideLineRow = myWorker.$lastCompleteRow;
            options.overrideLine = options.overrideLine || myWorker.$overrideLine;
        }
        else {
            options.overrideLineRow = myWorker.$lastCompleteRow;
            options.overrideLine = options.overrideLine || myWorker.doc.getLine(options.overrideLineRow);
        }
        if (options.path && options.path[0] === "/")
            return callback(new Error("Only workspace-relative paths are supported"));
        var id = msgId++;
        worker.sender.emit("jsonalyzerCallServer", {
            id: id,
            handlerPath: "plugins/c9.ide.language.jsonalyzer/server/invoke_helper",
            method: "invoke",
            filePath: options.path && (options.path[0] === "~" ? options.path : "/" + options.path),
            maxCallInterval: maxCallInterval,
            timeout: options.timeout || 30000,
            semaphore: "semaphore" in options
                ? options.semaphore
                : command + "|" + myWorker.$language,
            args: [options.path, null, null, options]
        });
        worker.sender.on("jsonalyzerCallServerResult", function onResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("jsonalyzerCallServerResult", onResult);
            var stdout = tryParseJSON(event.data.result[1]);
            var stderr = tryParseJSON(event.data.result[2]);
            callback(event.data.result[0], stdout, stderr, {
                serverTime: event.data.result[3],
            });
        });
        
        function getRelativeDirname(file) {
            return file && file.replace(/([\/\\]|^)[^\/\\]+$/, "").replace(/^\//, "");
        }
        
        function tryParseJSON(string) {
            try {
                return options.json ? JSON.parse(string) : string;
            }
            catch (e) {
                return string;
            }
        }
    },
    readFile: function(path, options, callback) {
        if (!callback) { // fix arguments
            callback = options;
            options = null;
        }
        
        if (worker.$lastWorker.$path === path) {
            callback && setTimeout(callback.bind(null, null, worker.$lastWorker.doc.getValue()), 0);
            return;
        }
        
        if (path.match(/\/$/) || path === ".") { // fail fast
            var err = new Error("File is a directory");
            err.code = "EISDIR";
            return callback(err);
        }
        
        var id = msgId++;
        worker.sender.on("readFileResult", function onReadFileResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("readFileResult", onReadFileResult);
            callback && callback(event.data.err && JSON.parse(event.data.err), event.data.data);
        });
        worker.sender.emit("readFile", { path: path, options: options, id: id });
    },
   stat: function(path, callback) {
        var id = msgId++;
        worker.sender.on("statResult", function onReadFileResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("statResult", onReadFileResult);
            callback && callback(event.data.err && JSON.parse(event.data.err), event.data.data);
        });
        worker.sender.emit("stat", { path: path, id: id });
    },
    filterDocumentation: function(doc) {
        if (docCache.entries["_" + doc])
            return docCache.entries["_" + doc];
        var lastRow = worker.$lastWorker.$lastCompleteRow;
        if (docCache.row !== lastRow)
            docCache.entries = {};
        docCache.row = lastRow;
        
        var result = escapeHtml(doc)
            .replace(/(\n|^)[ \t]*\*+[ \t]*/g, "\n")
            .trim()
            .replace(/@(param|public|private|platform|event|method|function|class|constructor|fires?|throws?|returns?|internal|ignore)/, "<br/>@$1")
            .replace(/\n\n(?!@)/g, "<br/><br/>")
            .replace(/@(param|public|private|platform|event|method|function|class|constructor|fires?|throws?|returns?|internal|ignore) ({[\w\.]+} )?(\[?[\w\.]+\]?)/g, "<br><b>@$1</b> <i>$2$3</i>&nbsp;")
            .replace(/\n@(\w+)/g, "<br/>\n<b>@$1</b>")
            .replace(/&lt;(\/?)code&gt;/g, "<$1tt>")
            .replace(/&lt;(\/?)(b|i|em|br|a) ?\/?&gt;/g, "<$1$2>")
            .replace(/&lt;(a\s+(target=('|&quot;)[^"'&]*('|&quot;)\s+)?href=('|&quot;)(https?:\/\/|#)[^"'&]*('|&quot;)\s*(target=('|&quot;)[^"'&]*('|&quot;)\s*)?)&gt;/g, '<$1 target="_docs">');
        docCache.entries["_" + doc] = result;
        return result;

        function escapeHtml(str) {
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;");
        }
    },
    showError: function(message, timeout, info) {
        if (message.stack) {
            console.error(message.stack);
            message = message.message;
        }
        var id = msgId++;
        var token;
        worker.sender.once("showErrorResult", function onResult(e) {
            token = e.token;
        });
        worker.sender.emit("showError", { message: message, timeout: timeout, id: id, info: info });
        return {
            hide: function hide() {
                if (token)
                    return worker.sender.emit("showError", { token: token });
                setTimeout(hide, 50);
            }
        };
    },
    showInfo: function(message, timeout) {
        return this.showError(message, timeout, true);
    },
    asyncForEach: function(array, fn, callback) {
        worker.asyncForEach(array, fn, callback);
    },
    getOpenFiles: function() {
        var results = [];
        var set = worker.$lastWorker.$openDocuments;
        Object.keys(set).forEach(function(e) {
            results.push(set[e]);
        });
        return results;
    },
    refreshAllMarkers: function() {
        worker.sender.emit("refreshAllMarkers");
    },
    getPrecedingIdentifier: function(line, offset, regex) {
        regex = regex || this.getIdentifierRegex(offset);
        return completeUtil.retrievePrecedingIdentifier(line, offset, regex);
    },
    getFollowingIdentifier: function(line, offset, regex) {
        regex = regex || this.getIdentifierRegex(offset);
        return completeUtil.retrieveFollowingIdentifier(line, offset, regex);
    },
    getIdentifier: function(line, offset, regex) {
        regex = regex || this.getIdentifierRegex(offset);
        return this.getPrecedingIdentifier(line, offset, regex)
            + this.getFollowingIdentifier(line, offset, regex);
    },
    getTokens: function(doc, identifiers, callback) {
        var id = msgId++;
        worker.sender.emit("getTokens", {
            path: worker.$lastWorker.$path,
            identifiers: identifiers,
            id: id,
            region: doc.region
        });
        worker.sender.on("getTokensResult", function onResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("getTokensResult", onResult);
            callback(event.data.err, event.data.results);
        });
    },
    
    getQuickfixKey: function() {
        return worker.$lastWorker.$keys.quickfix;
    },
    $watchDir: function(path, plugin) {
        worker.sender.emit("watchDir", { path: path });
    },
    $unwatchDir: function(path, plugin) {
        worker.sender.emit("watchDir", { path: path });
    },
    $onWatchDirChange: function(listener) {
        worker.sender.on("watchDirResult", listener);
    },
    $offWatchDirChange: function(listener) {
        worker.sender.off("watchDirResult", listener);
    }
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/semantic_index",[], function(require, exports, module) {

var handler /*: require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker")*/;
var scopeAnalyzer = require('plugins/c9.ide.language.javascript/scope_analyzer');
var workerUtil = require("plugins/c9.ide.language/worker_util");
var KIND_PACKAGE = scopeAnalyzer.KIND_PACKAGE;
var KIND_HIDDEN = scopeAnalyzer.KIND_HIDDEN;
var GC_INTERVAL = 5 * 60 * 1000;

var index = module.exports;

var analyzedFiles = {};
var pathGuids = {};
var accessedSinceGC = {};
var summaries = {};
var imports = {};
    
index.init = function(_handler) {
    handler = _handler;
    
    var _self = this;
    setInterval(function() {
        _self.gc();
    }, GC_INTERVAL);
};
index.getAny = function(guidsOrPaths) {
    return guidsOrPaths.map(index.get.bind(index)).filter(function(i) {
        return !!i;
    });
};
index.get = function(guidOrPath) {
    accessedSinceGC["_" + guidOrPath] = true;
    var guid = pathGuids["_" + guidOrPath];
    return guid ? summaries["_" + guid] : summaries["_" + guidOrPath];
};
index.getImports = function(guidOrPath, excludeAnalyzed) {
    accessedSinceGC["_" + guidOrPath] = true;
    var guid = pathGuids["_" + guidOrPath];
    var results = guid ? imports["_" + guid] : imports["_" + guidOrPath];
    if (!results)
        return [];
    if (excludeAnalyzed)
        results = results.filter(function(r) { return !index.get(r); });
    return results;
};
index.set = function(path, guidPrefix, summary, pathImports) {
    var guid = summary && summary.guid || guidPrefix + path;
    pathGuids["_" + path] = guid;
    if (summary) {
        summary.path = path;
        summaries["_" + guid] = summary;
    }
    if (pathImports)
        imports["_" + guid] = pathImports;
};
index.setBroken = function(path, reason) {
    var guid = "broken:" + path;
    pathGuids["_" + path] = guid;
    summaries["_" + guid] = {
        broken: reason || "broken"
    };
    imports["_" + guid] = [];
};
index.flattenSummary = function(summary, result) {
    if (!summary)
        return {};
    result = result || {};
    
    var that = this;
    if (Array.isArray(summary)) {
        summary.forEach(function(e) { that.flattenSummary(e, result);});
        return result;
    }
    if (!summary || !summary.properties)
        return result;
    
    for (var p in summary.properties) {
        if (!result[p])
            result[p] = summary.properties[p];
        else
            result[p] = result[p].concat(summary.properties[p]);
        this.flattenSummary(summary.properties[p], result);
    }
    
    return result;
};
index.findEntries = function(summary, entry, matchByPrefix, dontFindAll) {
    function findUnderscoreEntries(properties, uentry) {
        if (!matchByPrefix && properties[uentry]) {
            result[uentry] = (result[uentry] || []).concat(properties[uentry]);
            if (dontFindAll)
                return;
        }
        
        for (var p in properties) {
            if (matchByPrefix && p.indexOf(uentry) === 0) {
                result[p] = (result[p] || []).concat(properties[p]);
                if (dontFindAll)
                    return;
            }
            if (!properties[p].properties)
                continue;
            findUnderscoreEntries(properties[p].properties, uentry);
        }
    }
    
    if (!summary.properties)
        return {};
    if (entry === "" && matchByPrefix)
        return this.flattenSummary(summary);
        
    var result = {};
    findUnderscoreEntries(summary.properties, "_" + entry);
    return result;
};

index.hasEntries = function(summary, entry, matchByPrefix) {
    return !!Object.keys(this.findEntries(summary, entry, matchByPrefix, true)).length;
};

index.removeByPath = function(path) {
    var guid = pathGuids["_" + path];
    if (!guid)
        return;

    delete analyzedFiles["_" + path];
    delete pathGuids["_" + guid];
    delete summaries[guid];
};

index.removeByPathPrefix = function(pathPrefixes) {
    for (var upath in pathGuids) {
        var matches = pathPrefixes.filter(function(p) {
            return upath.indexOf(p) === 1;
        });
        if (matches.length === 0)
            continue;
        
        var uguid = "_" + pathGuids[upath];
        delete summaries[uguid];
        delete imports[uguid];
        delete pathGuids[upath];
    }
};
index.gc = function() {
    var openFiles = workerUtil.getOpenFiles();
    for (var upath in pathGuids) {
        var guid = pathGuids[upath];
        
        if (accessedSinceGC[upath])
            continue;
        if (accessedSinceGC["_" + guid] || openFiles.indexOf(upath.substr(1)) > -1)
            continue;
        
        delete pathGuids[upath];
        delete summaries["_" + guid];
        delete imports["_" + guid];
    }
    accessedSinceGC = {};
};

index.clear = function() {
    pathGuids = {};
    summaries = {};
    imports = {};
    accessedSinceGC = {};
};

index.markStale = function(handler) {
    if (!handler)
        return;
    for (s in summaries) {
        if (summaries[s].handler === handler)
            summaries[s].stale = true;
    }
};

index.$clearAccessedSinceGC = function() {
    accessedSinceGC = {};
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/file_indexer",[], function(require, exports, module) {

var indexer = module.exports;
var index = require("./semantic_index");
var languageWorker = require("plugins/c9.ide.language.core/worker");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var assert = require("c9/assert");
var worker;

var QUEUE_DELAY = 5 * 1000;
var QUEUE_MAX_TIME = 120 * 1000;

var queueSet = {};
var queueTimer;
var queueWatcher;
var isJobActive = false;
var queueCallbacks = [];
var lastPath;
var lastDocValue;

indexer.init = function(_worker) {
    worker = _worker;
};
indexer.analyzeCurrent = function(path, docValue, ast, options, callback) {
    var entry = index.get(path);
    if (entry && !entry.stale &&
        (languageWorker.$lastWorker.updateScheduled || languageWorker.$lastWorker.updateAgain)) {
        entry.stale = true; // only do this once
        return callback(null, entry, index.getImports(path), entry.markers);
    }
    if (entry && !entry.stale && path === lastPath && docValue === lastDocValue)
        return callback(null, entry, index.getImports(path), entry.markers);
    
    lastPath = path;
    lastDocValue = docValue;
    
    var language = worker.language;
    var plugin = worker.getHandlerFor(path, language);
    options.language = language;
    
    var watcher = setTimeout(function() {
        console.log("Warning: did not receive a response for 20 seconds from " + plugin.$source);
    }, 20000);
    return plugin.analyzeCurrent(path, docValue, ast, options, function(err, indexEntry, markers) {
        clearTimeout(watcher);
        if (err) {
            index.setBroken(path, err);
            return callback(err);
        }
        assert(indexEntry || markers, "jsonalyzer handler must return a summary and/or markers");
        
        indexEntry = indexEntry || index.get(path) || {};
        markers = indexEntry.markers = indexEntry.markers || markers;
        indexEntry.handler = plugin;
        
        if (!options.service) {
            index.set(path, plugin.guidName + ":", indexEntry);
        }
        else {
            var oldEntry = index.get(path);
            if (oldEntry)
                oldEntry.stale = true;
        }
        
        plugin.findImports(path, docValue, ast, options, function(err, imports) {
            if (err) {
                console.error("[jsonalyzer] error finding imports for " + path + ": " + err);
                imports = [];
            }
            imports = (imports || []).filter(function(i) {
                return i !== path;
            });
            index.set(path, plugin.guidName + ":", null, imports);
            callback(null, indexEntry, imports, markers);
        });
    });
};
var enqueue = indexer.analyzeOthers = function(paths, now, callback) {
    if (callback)
        queueCallbacks.push(callback);
    
    for (var i = 0; i < paths.length; i++) {
        queueSet["_" + paths[i]] = paths[i];
    }
    
    if (now)
        return consumeQueue();
    
    if (!queueTimer)
        queueTimer = setTimeout(consumeQueue, QUEUE_DELAY);
};

function consumeQueue() {
    queueTimer = null;
    if (isJobActive)
        return;
    isJobActive = true;
    updateQueueWatcher();
    
    var paths = [];
    for (var item in queueSet) {
        if (index.get(queueSet[item]))
            continue;
        paths.push(queueSet[item]);
    }
    queueSet = {};
    
    var pathsPerPlugin = {};
    for (var i = 0; i < paths.length; i++) {
        var plugin = worker.getHandlerFor(paths[i]);
        if (!plugin) // path added when not fully initialized yet
            continue;
        if (!pathsPerPlugin[plugin.guidName]) {
            pathsPerPlugin[plugin.guidName] = {
                plugin: plugin,
                paths: []
            };
        }
        pathsPerPlugin[plugin.guidName].paths.push(paths[i]);
    }
    
    workerUtil.asyncForEach(
        Object.keys(pathsPerPlugin),
        function(guidName, next) {
            var task = pathsPerPlugin[guidName];
            task.paths = task.paths.filter(function(path) {
                var entry = index.get(path);
                return !entry || entry.stale;
            });
                 
            task.plugin.analyzeOthers(task.paths, {}, function(errs, results) {
                assert(!errs || Array.isArray(errs));
                updateQueueWatcher();
                
                if (!results)
                    return next();
                var pathsCopy = task.paths.slice();
                var resultsCopy = (results || []).slice();
                var errsCopy = (errs || []).slice();
                
                while (pathsCopy.length) {
                    var err = errsCopy.pop();
                    var path = pathsCopy.pop();
                    var result = resultsCopy.pop();
                    if (err) {
                        index.setBroken(path, err);
                        console.log("[jsonalyzer] Warning: failed to import " + path + ": " + err);
                        continue;
                    }
                    assert(result);
                    result.handler = task.plugin;
                    index.set(path, guidName + ":", result);
                }
                
                next();
            });
        },
        done
    );
    
    function done() {
        isJobActive = false;
        clearTimeout(queueWatcher);
        var callbacks = queueCallbacks;
        queueCallbacks = [];
        callbacks.forEach(function(callback) { callback(); });
    }
    
    function updateQueueWatcher() {
        clearTimeout(queueWatcher);
        queueWatcher = setTimeout(function() {
            isJobActive = false;
            console.error("Warning: file_indexer plugin timeout, restarting");
            consumeQueue();
        }, QUEUE_MAX_TIME);
    }
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/jumptodef",[], function(require, exports, module) {

var index = require("./semantic_index");
var handler;
var worker = require("plugins/c9.ide.language.core/worker");
var fileIndexer = require("./file_indexer");
var workerUtil = require("plugins/c9.ide.language/worker_util");

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    var line = doc.getLine(pos.row);
    var docValue = doc.getValue();
    var identifier = workerUtil.getIdentifier(line, pos.column);
    var indexOptions = {};
    var that = this;
    fileIndexer.analyzeCurrent(handler.path, docValue, fullAst, indexOptions, function(err, summary, imports) {
        if (err) {
            if (err.code === "ESUPERSEDED")
                return that.jumpToDefinition(doc, fullAst, pos, options, callback);
            console.error(err);
            return callback(); // can't pass error to this callback
        }
        worker.$lastWorker.getOutline(function(outline) {
            var results = [];
            if (outline && outline.items)
                results = findInOutline(outline.items, identifier);
            if (!results.length)
                results = findInSummaries([summary], identifier, results);
            var needAllImports = !results.length;
            if (needAllImports)
                fileIndexer.analyzeOthers(imports, needAllImports, done);
            else
                done();
            
            function done() {
                var summaries = index.getAny(imports);
                results = findInSummaries(summaries, identifier, results);
                if (doc.region)
                    results.forEach(function(result) {
                        result.row -= doc.region.sl;
                    });
                callback(results);
            }
        });
    });
};

function findInSummaries(summaries, identifier, results) {
    summaries.forEach(function(summary) {
        var entries = index.findEntries(summary, identifier);
        for (var uname in entries) {
            entries[uname].forEach(function(entry) {
                results.push({
                    row: entry.row,
                    column: entry.column,
                    path: summary.path,
                    icon: entry.icon
                        || entry.kind === "package" && "package"
                        || entry.kind === "event" && "event"
                        || "unknown2",
                    isGeneric: true
                });
            });
        }
    });
    return results;
}

function isNameMatch(identifier, indexName) {
    return identifier === indexName
        || indexName.replace && identifier === indexName.replace(/(.*\.)?([^.]*?)(\([^\]]*\))?$/, "$2");
}

function findInOutline(outline, identifier, results) {
    if (!results)
        results = [];
    for (var i = 0; i < outline.length; i++) {
        if (isNameMatch(identifier, outline[i].name)) {
            results.push({
                row: outline[i].pos.sl,
                column: outline[i].pos.sc,
                icon: outline[i].icon,
                isGeneric: true
            });
        }
        if (outline[i].items)
            findInOutline(outline[i].items, identifier, results);
    }
    return results;
}

function getPropertyName(node) {
    var result;
    node.rewrite(
        'PropAccess(o, p)', function(b) {
            result = b.p.value; 
        }
    );
    return result;
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util",[], function(require, exports, module) {

var assert = require("c9/assert");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var jsonalyzer;

var MAX_DOCHEAD_LENGTH = 80;
var EXTENSION_GROUPS;

module.exports.MAX_DOCHEAD_LENGTH = MAX_DOCHEAD_LENGTH;

module.exports.EXTENSION_GROUPS = EXTENSION_GROUPS;

module.exports.init = function(ctags, _jsonalyzer) {
    if (typeof _jsonalyzer === "function") {
        return _jsonalyzer();
    }
    
    jsonalyzer = _jsonalyzer || jsonalyzer;
    EXTENSION_GROUPS = ctags.LANGUAGES.map(function(l) { return l.extensions; });
};

module.exports.extractDocumentationAtRow = function(lines, row) {
    var prevRow = row > 0 ? row - 1 : 0;
    var line = lines[prevRow];
    if (line && line.match(/^\s*#/)) {
        line = line.match(/^\s*#\s*(.*)/)[1];
        var results = [line];
        for (var start = prevRow - 1; start >= 0; start--) {
            line = lines[start];
            if (!line.match(/^\s*#/))
                break;
            results.push(line.match(/^\s*#\s*(.*)/)[1]);
        }
        return workerUtil.filterDocumentation(results.join("\n"));
    }
    if (lines[row + 1] && lines[row + 1].match(/^\s*"""/)) {
        var result = "";
        for (var cur = row + 1; lines[cur]; cur++) {
            result += lines[cur].replace(/^\s*|\s*"""\s*/g, "") + "\n";
            if (lines[cur].match(/[^\s"]+\s*"""/))
                break;
        }
        return result;
    }
    var end = null;
    for (var cur = prevRow; cur >= 0; cur--) {
        line = lines[cur];
        for (var col = line.length - 2; col >= 0; col--) {
            if (!end) {
                if (line.substr(col, 2) === "*/") {
                    end = { sl: cur, sc: col };
                    col--;
                } else if (!line[col].match(/[\s\/]/)) {
                    return;
                }
            } else if (line.substr(col, 2) === "/*") {
                var rows = ["", line.substr(col + 3)];
                for (var r = cur + 1; r < end.sl; r++)
                    rows.push(lines[r]);
                rows.push(lines[end.sl].substr(0, end.sc));
                if (end.sl === cur)
                    rows = ["", line.substring(col + 3, end.sc)];
                return workerUtil.filterDocumentation(rows.join("\n"));
            }
        }
    }
};
module.exports.findMatchingTags = function(path, docValue, tag, guessFargs, extractDocumentation, results) {
    assert(tag.regex.global, "Regex must use /g flag: " + tag.regex);
    var _self = this;
    var lines = path === jsonalyzer.path && jsonalyzer.doc
        ? jsonalyzer.doc.getAllLines()
        : docValue.split(/\n/);
    
    docValue.replace(tag.regex, function(fullMatch, name, offset) {
        assert(typeof offset === "number", "Regex must have exactly one capture group: " + tag.regex);
        
        var addedOffset = fullMatch.indexOf(name);
        var row = getOffsetRow(docValue, offset + (addedOffset === -1 ? 0 : addedOffset));
        var line = lines[row];
        
        var doc, docHead;
        if (extractDocumentation && line) {
            docHead = line.length > MAX_DOCHEAD_LENGTH
                ? line.substr(line.length - MAX_DOCHEAD_LENGTH) + "..."
                : line;
            doc = _self.extractDocumentationAtRow(lines, row);
        }
        
        results["_" + name] = results["_" + name] || [];
        
        if (tag.docOnly) { // HACK: tag that only contributes documentation
            if (!doc)
                return;
            if (results["_" + name][0]) {
                results["_" + name][0].doc = doc;
                return;
            }
        }
        
        results["_" + name].push({
            row: row,
            docHead: docHead,
            guessFargs: guessFargs,
            doc: doc,
            kind: tag.kind,
            indent: tag.indent,
        });
        return fullMatch;
    });
    
    return results;
};
module.exports.findMatchingOpenFiles = function(path) {
    var openFiles = workerUtil.getOpenFiles();
    var extension = getExtension(path);
    var supported = getCompatibleExtensions(extension);
    var imports = openFiles.filter(function(path) {
        return supported.indexOf(getExtension(path)) > -1;
    });
    return imports;
};

module.exports.guessFargs = function(line, name) {
    if (!line)
        return "";
    var guess = /\([A-Za-z0-9$_,\s]*(\))?/;
    guess.lastIndex = line.indexOf(name) + name.length;
    var match = guess.exec(line);
    return match && match[0] + (match[1] ? "" : "...") || "";
};

function getExtension(path) {
    return path.match(/[^\.\\\/]*$/)[0];
}
function getCompatibleExtensions(extension) {
    for (var i = 0; i < EXTENSION_GROUPS.length; i++) {
        if (EXTENSION_GROUPS[i].indexOf(extension) > -1)
            return EXTENSION_GROUPS[i];
    }
    return [extension];
}

var getOffsetRow = module.exports.getOffsetRow = function(contents, offset) {
    var result = 0;
    var lastIndex = offset + 1;
    for (;;) {
        lastIndex = lastIndex === 0
            ? -1
            : contents.lastIndexOf("\n", lastIndex - 1);
        if (lastIndex < 0)
            return result;
        result++;
    }
};
module.exports.filterDocumentation = workerUtil.filterDocumentation;

module.exports.getParameterDocs = function(doc) {
    var result = {};
    doc && doc.replace(
        /@param (?:\{[^}]*\} )?([^ ]*)\s+([^@]*)/g,
        function(input, name, description) {
            result["_" + name] = workerUtil.filterDocumentation(description);
            return input;
        }
    );
    return result;
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/complete",[], function(require, exports, module) {

var index = require("./semantic_index");
var fileIndexer = require("./file_indexer");
var completeUtil = require("plugins/c9.ide.language/complete_util");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var ctagsUtil = require("./ctags/ctags_util");
var handler;

var PRIORITY_LOW = 1;
var PRIORITY_HIGH = 2;

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.complete = function(doc, fullAst, pos, options, callback) {
    if (options.node && options.node.cons === "PropertyInit") // HACK for javascript
        return callback();

    var lines = doc.getAllLines();
    var line = lines[pos.row];
    var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, workerUtil.getIdentifierRegex());
    if (line[pos.column - identifier.length - 1] === ".")
        return callback();
    
    getCurrentLazy(handler.path, doc, fullAst, function(err, result, imports) {
        if (err)
            console.log("[jsonalyzer] Warning: could not analyze " + handler.path + ": " + err);
        var currentFile = result;
        var currentResults = getCompletionResults(null, PRIORITY_HIGH, identifier, currentFile, pos, line);
        var otherResults = [];
        imports.forEach(function(path) {
            var summary = index.get(path);
            if (summary)
                otherResults = otherResults.concat(
                    getCompletionResults(path, PRIORITY_LOW, identifier, summary));
        });
        callback(currentResults.concat(otherResults));
        var unresolved = imports.filter(function(i) { return !index.get(i); });
        if (unresolved.length) {
            fileIndexer.analyzeOthers(unresolved, true, function() {
                if (index.getAny(unresolved).length)
                    workerUtil.completeUpdate(pos, line);
            });
        }
    });
};

function getCurrentLazy(path, doc, fullAst, callback) {
    var result = index.get(path);
    if (result)
        return callback(null, result, index.getImports(path));
    fileIndexer.analyzeCurrent(handler.path, doc.getValue(), fullAst, { service: "complete" }, callback);
}

function getCompletionResults(path, priority, identifier, summary, skipPos, skipLine) {
    if (!summary)
        return [];
    var entries = index.findEntries(summary, identifier, true);
    var file = path && path.match(/[^\/]*$/)[0];
    
    var results = [];
    for (var uname in entries) {
        entries[uname].forEach(function(e) {
            var name = uname.substr(1);
            if (skipPos && e.row === skipPos.row && !isDefinedInLine(skipLine, name, skipPos, identifier))
                return;
            if (e.noComplete)
                return;
            results.push(toCompletionResult(file, name, priority, e));
        });
    }
    return results;
}

function isDefinedInLine(line, name, skipPos, skipPrefix) {
    var first = line.indexOf(name);
    var last = line.lastIndexOf(name);
    if (first !== last)
        return true;
    return first !== skipPos.column - skipPrefix.length;
}

function toCompletionResult(file, name, priority, entry) {
    var fullName = entry.guessFargs
        ? name + ctagsUtil.guessFargs(entry.docHead, name)
        : name;
    var braces = fullName !== name ? "(^^)" : "";
    
    return {
        id: name,
        name: fullName,
        replaceText: name + braces,
        icon: "kind" in entry ? entry.kind : "unknown2",
        meta: file,
        doc: entry.doc,
        docHead: entry.docHead,
        priority: priority,
        isGeneric: true,
        guessTooltip: true,
    };
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/outline",[], function(require, exports, module) {

var fileIndexer = require("./file_indexer");
var assert = require("c9/assert");
var ctagsUtil = require("./ctags/ctags_util");
var handler;

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.outline = function(doc, ast, callback) {
    return fileIndexer.analyzeCurrent(handler.path, doc.getValue(), ast, { service: "outline" }, function(err, entry) {
        if (err) {
            console.error(err);
            return callback(); // can't pass error to this callback
        }
        
        var result = createOutline(null, entry, -1);
        var rootInfo = {
            displayPos: { el: doc.getLength() - 1 }
        };
        result = addDisplayPos(result, rootInfo);
        result.isGeneric = true;
        callback(result);
    });
};

function createOutline(name, entry, defaultIndent, parent) {
    var indent = entry.indent || defaultIndent;
    var fullName = entry.guessFargs
        ? name + ctagsUtil.guessFargs(entry.docHead, name)
        : name;
    var result = {
        icon: entry.icon || entry.kind,
        name: fullName,
        pos: { sl: entry.row, sc: entry.column },
        items: [],
        indent: indent,
        parent: parent,
    };
    if (!entry.properties)
        return result;
    assert(!Array.isArray(entry.properties));
    
    for (var uname in entry.properties) {
        entry.properties[uname].forEach(function(prop) {
            result.items.push(createOutline(uname.substr(1), prop, indent + 1, result));
        });
    }
    result.items = sortOutline(result.items);
    var candidateParent;
    result.items = result.items.filter(function(prop) {
        var parent = findParent(prop, candidateParent);
        if (parent !== result)
            parent.items.push(prop);
        else
            candidateParent = prop;
        return parent === result;
    });
    return result;
    
    function findParent(prop, parent) {
        if (!prop.indent || prop.indent <= indent || !parent)
            return result;
        
        if (parent.indent >= prop.indent)
            return findParent(prop, parent.parent);
            
        return parent;
    }
}

function sortOutline(items) {
    return items.sort(function(a, b) {
        return a.pos.sl - b.pos.sl;
    });
}

function addDisplayPos(outline, parent) {
    if (!outline.items)
        return outline;
    outline.displayPos = outline.displayPos || outline.pos;
    for (var i = 0; i < outline.items.length; i++) {
        var item = outline.items[i];
        var next = outline.items[i + 1];
        var nextLine = next ? next.pos.sl : parent.displayPos.el;
        item.displayPos = item.pos;
        item.pos = {
            sl: item.pos.sl,
            sc: item.pos.sc,
            el: nextLine,
            ec: nextLine > item.pos.sl ? 0 : item.pos.ec
        };
        addDisplayPos(item, outline);
    }
    return outline;
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/refactor",[], function(require, exports, module) {

var index = require("./semantic_index");
var fileIndexer = require("./file_indexer");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var handler;
var lastSummary;

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.getRefactorings = function(doc, fullAst, pos, options, callback) {
    findEntries(doc, fullAst, pos, function(pos, identifier, hasEntries) {
        callback({ refactorings: hasEntries ? ["renameVariable"] : []});
    });
};

module.exports.getRenamePositions = function(doc, fullAst, pos, options, callback) {
    findEntries(doc, fullAst, pos, function(pos, identifier, hasEntries) {
        if (!hasEntries)
            return callback();
        workerUtil.getTokens(doc, [identifier, identifier + "()"], function(err, results) {
            if (err)
                callback();
            callback({
                length: identifier.length,
                pos: pos,
                others: results,
                isGeneric: true
            });
        });
    });
};

module.exports.commitRename = function(doc, oldId, newName, isGeneric, callback) {
    if (!isGeneric)
        return callback();
    if (!lastSummary)
        return callback();
    var matchingDef = !!Object.keys(index.findEntries(lastSummary, newName)).length;
    callback(matchingDef && "Name '" + newName + "' is already used.");
};

function findEntries(doc, fullAst, pos, callback) {
    if (handler.language === "javascript") // optimization
        return callback();
    
    var docValue = doc.getValue();
    var line = doc.getLine(pos.row);
    var identifier = workerUtil.getIdentifier(line, pos.column);
    var prefix = workerUtil.getPrecedingIdentifier(line, pos.column);
    var realPos = { row: pos.row, column: pos.column - prefix.length };
    
    fileIndexer.analyzeCurrent(handler.path, docValue, fullAst, { service: "refactor" }, function(err, result) {
        if (err)
            console.log("[jsonalyzer] Warning: could not analyze " + handler.path + ": " + err);
        lastSummary = result;
        callback(realPos, identifier, index.hasEntries(result, identifier));
    });
    
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/highlight_occurrences",[], function(require, exports, module) {

var index = require("./semantic_index");
var handler;
var fileIndexer = require("./file_indexer");
var workerUtil = require("plugins/c9.ide.language/worker_util");

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.highlightOccurrences = function(doc, fullAst, pos, options, callback) {
    var summary = index.get(handler.path);
    if (!summary)
        return callback(); // we're closed, come back later
        
    var line = doc.getLine(pos.row);
    var identifier = workerUtil.getIdentifier(line, pos.column);
    
    var entries = index.findEntries(summary, identifier);
    if (Object.keys(entries).length)
        return callback(getOccurrences(doc, pos, identifier, entries["_" + identifier]));
    
    var imports = index.getImports(handler.path);
    var others = index.getAny(imports);
    for (var i = 0; i < others.length; i++) {
        if (index.hasEntries(others[i], identifier))
            return callback(getOccurrences(doc, pos, identifier, []));
    }
    
    callback();
};

function getOccurrences(doc, pos, identifier, entryList) {
    var line = doc.getLine(pos.row);
    var prefix = workerUtil.getPrecedingIdentifier(line, pos.column);
    var realColumn = pos.column - prefix.length;
    
    var results = [{
        pos: {
            sl: pos.row,
            el: pos.row,
            sc: realColumn,
            ec: realColumn + identifier.length
        },
        type: "occurrence_other"
    }];
    
    var foundSelf = false;
    entryList.forEach(function(entry) {
        if (!entry.column) { // guess the column
            var entryLine = doc.getLine(entry.row);
            entry.column = entryLine.indexOf(identifier);
            if (entry.column < 0)
                return;
        }
        if (entry.row === pos.row && entry.column === realColumn)
            return foundSelf = true;
        results.push({
            pos: {
                sl: entry.row,
                el: entry.row,
                sc: entry.column,
                ec: entry.column + identifier.length
            },
            type: "occurrence_main"
        });
    });
    return { markers: foundSelf ? [] : results, isGeneric: true };
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/directory_indexer",[], function(require, exports, module) {

var indexer = module.exports;
var index = require("./semantic_index");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var handler;

var PARANOID_CHECK_INTERVAL = 60 * 1000;
var QUEUE_DELAY = 2000;
var PARANOID_CHECK_SET = [
    ".git/index",
    ".hg/dirstate",
    ".svn/.wc.db",
    "node_modules/*",
    "package.json"
];

var isJobActive = false;
var lastParanoidResult = "";
var queueTimer;
var queueCallbacks = [];
var queuePaths = [];

indexer.init = function(_handler) {
    handler = _handler;
    
    enqueue("/", false);
    setInterval(function() {
        if (!queuePaths.length)
            enqueue("/", true);
    }, PARANOID_CHECK_INTERVAL);
};

var enqueue = indexer.enqueue = function(path, paranoid, callback) {
    callback && queueCallbacks.push(callback);
    queuePaths.push(path);
    
    if (queuePaths.indexOf("/") > -1)
        return; // we queued the world already
    if (paranoid === undefined && path === "/")
        paranoid = true;
    
    if (paranoid) {
        return isChangedParanoid(function(err, result) {
            if (err)
                return console.error("[jsonalyzer] directory_indexer err: " + err);
            enqueue(result ? path : "$$no-path$$", false);
        });
    }
    
    if (!queueTimer)
        queueTimer = setTimeout(consumeQueue);
};

var consumeQueue = indexer.$consumeQueue = function() {
    queueTimer = null;
    var myQueue = queuePaths;
    var myCallbacks = queueCallbacks;
    queuePaths = [];
    queueCallbacks = [];

    index.removeByPathPrefix(myQueue);
    
    workerUtil.asyncForEach(
        handler.getAllHandlers(),
        function(plugin, next) {
            plugin.analyzeWorkspaceRoot(next);
        },
        done
    );
    
    function done() {
        isJobActive = false;
        var callbacks = myCallbacks;
        myCallbacks = [];
        callbacks.forEach(function(callback) { callback(); });
    }
};
function isChangedParanoid(callback) {
    workerUtil.execFile(
        "bash",
        {
            args: [
                "-c",
                "ls -l"
                + " " + PARANOID_CHECK_SET.join(" ")
                + " `find . -maxdepth 1 -type d | grep -Ev '^\\./\\.c9|^\\.$' || echo ''`"
            ]
        },
        function(err, stdout) {
            if (err)
                return callback(err);
            if (lastParanoidResult === stdout)
                return callback(null, false);
            lastParanoidResult = stdout;
            return callback(null, true);
        }
    );
}

});

define("path",[], function(require, exports, module) {
//
//
//
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}
var splitPathRe =
  /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;
  
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : '/';
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }
  
    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }
  resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  
  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = path.substr(-1) === '/';
  path = normalizeArray(path.split('/').filter(function(p) {
    return !!p;
  }), !isAbsolute).join('/');
  
  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(paths.filter(function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);
  
  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }
  
    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }
  
    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }
  
  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }
  
  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }
  
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  
  return outputParts.join('/');
};

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    return '.';
  }

  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};

exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

exports._makeLong = function(path) {
  return path;
};

});

"disable compress";(function() {
var ctagsInput;
var submitNewContents;
var Module;
var logged = "";

(function() {
var process;
if (typeof window !== "undefined")
    process = "process is changed to type string for compatibility, sorry";

function stringToArrayBuffer(string, callback) {
    var blob = new Blob([string]);
    var f = new FileReader();
    f.onload = function(e) {
        callback(e.target.result);
    }
    f.readAsArrayBuffer(blob);
}
var sysConsole = console;
var console = {
	log: function() {
		arguments = Array.prototype.slice.call(arguments);
		logged += arguments.map(function(a) {
			return typeof a === "object" ? JSON.stringify(a) : a;
		}).join(" ") + "\n";
		sysConsole.log.apply(sysConsole, arguments)
	},
	error: function() {
		arguments = Array.prototype.slice.call(arguments);
		logged += arguments.map(function(a) {
			return typeof a === "object" ? JSON.stringify(a) : a;
		}).join(" ") + "\n";
		sysConsole.err.apply(sysConsole, arguments)
	}
}
var print = console.log;

function aa(b){throw b}var ba=void 0,ca=!0,da=null,fa=!1,a={noInitialRun:ca,noExitRuntime:ca};try{this.Module=a}catch(ha){this.Module=a={}}var ja="object"===typeof process&&"function"===typeof require,la="object"===typeof window,ma="function"===typeof importScripts,na=!la&&!ja&&!ma;if(ja){a.print=(function(b){process.stdout.write(b+"\n")});a.printErr=(function(b){process.stderr.write(b+"\n")});var oa=require("fs"),pa=require("path");a.read=(function(b){var b=pa.normalize(b),d=oa.readFileSync(b).toString();!d&&b!=pa.resolve(b)&&(b=path.join(__dirname,"..","src",b),d=oa.readFileSync(b).toString());return d});a.load=(function(b){qa(read(b))});a.arguments||(a.arguments=process.argv.slice(2))}na&&(a.print=print,"undefined"!=typeof printErr&&(a.printErr=printErr),a.read="undefined"!=typeof read?read:(function(b){snarf(b)}),a.arguments||("undefined"!=typeof scriptArgs?a.arguments=scriptArgs:"undefined"!=typeof arguments&&(a.arguments=arguments)));la&&!ma&&(a.print||(a.print=(function(b){console.log(b)})),a.printErr||(a.printErr=(function(b){console.log(b)})));if(la||ma){a.read=(function(b){var d=new XMLHttpRequest;d.open("GET",b,fa);d.send(da);return d.responseText}),a.arguments||"undefined"!=typeof arguments&&(a.arguments=arguments)}ma&&(a.print||(a.print=(function(){})),a.load=importScripts);!ma&&!la&&!ja&&!na&&aa("Unknown runtime environment. Where are we?");function qa(b){eval.call(da,b)}"undefined"==!a.load&&a.read&&(a.load=(function(b){qa(a.read(b))}));a.print||(a.print=(function(){}));a.printErr||(a.printErr=a.print);a.arguments||(a.arguments=[]);a.print=a.print;a.h=a.printErr;a.preRun||(a.preRun=[]);a.postRun||(a.postRun=[]);function sa(b){if(1==ta){return 1}var d={"%i1":1,"%i8":1,"%i16":2,"%i32":4,"%i64":8,"%float":4,"%double":8}["%"+b];d||("*"==b.charAt(b.length-1)?d=ta:"i"==b[0]&&(b=parseInt(b.substr(1)),ua(0==b%8),d=b/8));return d}var va;function wa(){var b=[],d=0;this.C=(function(c){c&=255;d&&(b.push(c),d--);if(0==b.length){if(128>c){return String.fromCharCode(c)}b.push(c);d=191<c&&224>c?1:2;return""}if(0<d){return""}var c=b[0],e=b[1],f=b[2],c=191<c&&224>c?String.fromCharCode((c&31)<<6|e&63):String.fromCharCode((c&15)<<12|(e&63)<<6|f&63);b.length=0;return c});this.K=(function(b){for(var b=unescape(encodeURIComponent(b)),d=[],f=0;f<b.length;f++){d.push(b.charCodeAt(f))}return d})}function xa(b){var d=j;j+=b;j=j+3>>2<<2;return d}function ya(b){var d=za;za+=b;za=za+3>>2<<2;za>=Aa&&Ba("Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value ( "+Aa+"), (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.");return d}var ta=4,Ca={},Da=1,Ea={},k,Fa,Ga;function Ba(b){a.print(b+":\n"+Error().stack);aa("Assertion: "+b)}function ua(b,d){b||Ba("Assertion failed: "+d)}var Ha=this;a.ccall=(function(b,d,c,e){return Ja(Ka(b),d,c,e)});function Ka(b){try{var d=eval("_"+b)}catch(c){try{d=Ha.Module["_"+b]}catch(e){}}ua(d,"Cannot call unknown function "+b+" (perhaps LLVM optimizations or closure removed it?)");return d}function Ja(b,d,c,e){function f(b,c){if("string"==c){if(b===da||b===ba||0===b){return 0}g||(g=j);var d=xa(b.length+1);La(b,d);return d}return"array"==c?(g||(g=j),d=xa(b.length),Ma(b,d),d):b}var g=0,h=0,e=e?e.map((function(b){return f(b,c[h++])})):[];b=b.apply(da,e);"string"==d?d=Na(b):(ua("array"!=d),d=b);g&&(j=g);return d}a.cwrap=(function(b,d,c){var e=Ka(b);return(function(){return Ja(e,d,c,Array.prototype.slice.call(arguments))})});function Oa(b,d,c){c=c||"i8";"*"===c.charAt(c.length-1)&&(c="i32");switch(c){case"i1":l[b]=d;break;case"i8":l[b]=d;break;case"i16":Pa[b>>1]=d;break;case"i32":t[b>>2]=d;break;case"i64":Ga=[d>>>0,Math.min(Math.floor(d/4294967296),4294967295)];t[b>>2]=Ga[0];t[b+4>>2]=Ga[1];break;case"float":Ra[b>>2]=d;break;case"double":Ta[0]=d;t[b>>2]=Ua[0];t[b+4>>2]=Ua[1];break;default:Ba("invalid type for setValue: "+c)}}a.setValue=Oa;a.getValue=(function(b,d){d=d||"i8";"*"===d.charAt(d.length-1)&&(d="i32");switch(d){case"i1":return l[b];case"i8":return l[b];case"i16":return Pa[b>>1];case"i32":return t[b>>2];case"i64":return t[b>>2];case"float":return Ra[b>>2];case"double":return Ua[0]=t[b>>2],Ua[1]=t[b+4>>2],Ta[0];default:Ba("invalid type for setValue: "+d)}return da});var Va=1,x=2,Wa=3;a.ALLOC_NORMAL=0;a.ALLOC_STACK=Va;a.ALLOC_STATIC=x;a.ALLOC_NONE=Wa;function y(b,d,c,e){var f,g;"number"===typeof b?(f=ca,g=b):(f=fa,g=b.length);var h="string"===typeof d?d:da,c=c==Wa?e:[Xa,xa,ya][c===ba?x:c](Math.max(g,h?1:d.length));if(f){return Ya(c,g),c}for(f=0;f<g;){var i=b[f];"function"===typeof i&&(i=Ca.S(i));e=h||d[f];0===e?f++:("i64"==e&&(e="i32"),Oa(c+f,i,e),f+=sa(e))}return c}a.allocate=y;function Na(b,d){for(var c=new wa,e="undefined"==typeof d,f="",g=0,h;;){h=$a[b+g];if(e&&0==h){break}f+=c.C(h);g+=1;if(!e&&g==d){break}}return f}a.Pointer_stringify=Na;a.Array_stringify=(function(b){for(var d="",c=0;c<b.length;c++){d+=String.fromCharCode(b[c])}return d});var ab,cb=4096,l,$a,Pa,db,t,eb,Ra,fb,j,hb,za,ib=a.TOTAL_STACK||5242880,Aa=a.TOTAL_MEMORY||10485760;ua(!!Int32Array&&!!Float64Array&&!!(new Int32Array(1)).subarray&&!!(new Int32Array(1)).set,"Cannot fallback to non-typed array case: Code is too specialized");var jb=new ArrayBuffer(Aa);l=new Int8Array(jb);Pa=new Int16Array(jb);t=new Int32Array(jb);$a=new Uint8Array(jb);db=new Uint16Array(jb);eb=new Uint32Array(jb);Ra=new Float32Array(jb);fb=new Float64Array(jb);t[0]=255;ua(255===$a[0]&&0===$a[3],"Typed arrays 2 must be run on a little-endian system");a.HEAP=ba;a.HEAP8=l;a.HEAP16=Pa;a.HEAP32=t;a.HEAPU8=$a;a.HEAPU16=db;a.HEAPU32=eb;a.HEAPF32=Ra;a.HEAPF64=fb;hb=(j=4*Math.ceil(.25))+ib;var kb=8*Math.ceil(hb/8);l.subarray(kb);var Ua=t.subarray(kb>>2);Ra.subarray(kb>>2);var Ta=fb.subarray(kb>>3);hb=kb+8;za=hb+4095>>12<<12;ua(za<Aa);var mb=y(lb("(null)"),"i8",x);function nb(b){for(;0<b.length;){var d=b.shift(),c=d.t;"number"===typeof c&&(c=ab[c]);c(d.G===ba?da:d.G)}}var pb=[],qb=[],rb=[];function tb(b){for(var d=b;l[d++];){}return d-b-1}a.String_len=tb;function lb(b,d,c){b=(new wa).K(b);c&&(b.length=c);d||b.push(0);return b}a.intArrayFromString=lb;a.intArrayToString=(function(b){for(var d=[],c=0;c<b.length;c++){var e=b[c];255<e&&(e&=255);d.push(String.fromCharCode(e))}return d.join("")});function La(b,d,c){b=lb(b,c);for(c=0;c<b.length;){l[d+c]=b[c],c+=1}}a.writeStringToMemory=La;function Ma(b,d){for(var c=0;c<b.length;c++){l[d+c]=b[c]}}a.writeArrayToMemory=Ma;function ub(b,d){return 0<=b?b:32>=d?2*Math.abs(1<<d-1)+b:Math.pow(2,d)+b}function vb(b,d){if(0>=b){return b}var c=32>=d?Math.abs(1<<d-1):Math.pow(2,d-1);if(b>=c&&(32>=d||b>c)){b=-2*c+b}return b}var xb=0,zb={},Ab=fa,Bb=da;function Cb(b){xb++;a.monitorRunDependencies&&a.monitorRunDependencies(xb);b?(ua(!zb[b]),zb[b]=1,Bb===da&&"undefined"!==typeof setInterval&&(Bb=setInterval((function(){var b=fa,c;for(c in zb){b||(b=ca,a.h("still waiting on run dependencies:")),a.h("dependency: "+c)}b&&a.h("(end of list)")}),6e3))):a.h("warning: run dependency added without ID")}a.addRunDependency=Cb;function Gb(b){xb--;a.monitorRunDependencies&&a.monitorRunDependencies(xb);b?(ua(zb[b]),delete zb[b]):a.h("warning: run dependency removed without ID");0==xb&&(Bb!==da&&(clearInterval(Bb),Bb=da),Ab||Hb())}a.removeRunDependency=Gb;a.preloadedImages={};a.preloadedAudios={};var Ib,Jb,z,Kb,Lb,Mb,Nb,Ob,Wb,Xb,Yb,Zb,$b,dc,ec,fc,gc,hc,ic,jc,oc,pc,qc,rc,sc,tc,yc,zc,Ac,Bc,Cc,Dc,Ec,Fc,Gc,Hc,Ic,Jc,Kc,Lc,Tc,Uc,Vc,Wc,Xc,Yc,Zc,ld,md,nd,od,pd,qd,rd,sd,td,ud,zd,Ad,Bd,Cd,Dd,Ed,Fd,Gd,Ud,Vd,Wd,Xd,Yd,Zd,$d,ae,be,ce,re,se,te,ue,ve,we,xe,ye,ze,Ae,Be,Ce,De,Ee,Fe,Ge,Ie,Je,Ke,Le,Me,Ne,Oe,Pe,Qe,Re,Se,Te,Ue,Ve,We,Xe,Ye,Ze,$e,af,bf,cf,df,ef,ff,gf,kf,lf,mf,nf,of,pf,qf,rf,sf,tf,uf,vf,wf,xf,yf,zf,Af,Bf,Cf,Df,Ef,Ff,Gf,Hf,If,Jf,Kf,Lf,Mf,Nf,Of,Pf,Qf,Rf,Sf,Tf,Uf,Vf,Wf,Xf,Yf,Zf,$f,ag,bg,cg,dg,eg,fg,gg,hg,ig,jg,kg,lg,mg,ng,og,pg,qg,rg,sg,tg,ug,vg,wg,xg,yg,zg,Bg,Cg,Dg,Eg,Fg,Gg,Hg,Ig,Jg,Kg,Lg,Mg,Ng,Og,Pg,Qg,Rg,Sg,Tg,Ug,Vg,Wg,Xg,Yg,Zg,$g,ah,bh,ch,dh,eh,fh,gh,hh,ih,jh,kh,lh,mh,nh,oh,ph,qh,rh,sh,th,uh,vh,wh,xh,yh,zh,Ah,Bh,Ch,Dh,Eh,Fh,Gh,Hh,Ih,Jh,Kh,Lh,Mh,Nh,Oh,Ph,Qh,Rh,Sh,Th,Uh,Vh,Wh,Xh,Yh,Zh,$h,ai,bi,ci,di,ei,fi,gi,hi,ii,ji,ki,li,mi,ni,oi,pi,qi,ri,si,ti,ui,vi,wi,xi,yi,zi,Ai,Bi,Ci,Di,Ei,Fi,Gi,Hi,Ii,Ji,Ki,Li,Mi,Ni,Oi,Pi,Qi,Ri,Si,Ti,Ui,Vi,Wi,Xi,Yi,Zi,$i,aj,bj,cj,dj,ej,fj,gj,hj,ij,jj,kj,lj,mj,nj,oj,pj,qj,rj,sj,tj,uj,vj,wj,xj,yj,zj,Aj,Bj,Cj,Dj,Ej,Fj,Gj,Hj,Ij,Jj,Kj,Lj,Mj,Nj,Oj,Pj,Qj,Rj,Sj,Tj,Uj,Vj,Wj,Xj,Yj,Zj,$j,ak,bk,ck,dk,ek,fk,gk,hk,ik,jk,kk,lk,mk,nk,ok,pk,qk,rk,sk,tk,uk,vk,wk,xk,yk,zk,Ak,Bk,Ck,Dk,Ek,Fk,Gk,Hk,Ik,Jk,Kk,Lk,Mk,Nk,Ok,Pk,Qk,Rk,Sk,Tk,Uk,Vk,Wk,Xk,Yk,Zk,$k,al,bl,cl,dl,el,fl,gl,hl,il,jl,kl,ll,ml,nl,ol,pl,ql,rl,sl,tl,ul,vl,wl,xl,yl,zl,Al,Bl,Cl,Dl,El,Fl,Gl,Hl,Il,Jl,Kl,Ll,Ml,Nl,Ol,Pl,Ql,Rl,Sl,Tl,Ul,Vl,Wl,Xl,Yl,Zl,$l,am,bm,cm,dm,em,fm,gm,hm,im,jm,km,lm,mm,nm,om,pm,qm,rm,sm,tm,um,vm,wm,xm,ym,zm,Am,Bm,Cm,Dm,Em,Fm,Gm,Hm,Im,Jm,Km,Lm,Mm,Nm,Om,Pm,Qm,Rm,Sm,Tm,Um,Vm,Wm,Xm,Ym,Zm,$m,an,bn,cn,dn,en,fn,gn,hn,jn,kn,ln,mn,nn,on,pn,qn,rn,sn,tn,un,vn,wn,xn,yn,zn,An,Bn,Cn,Dn,En,Fn,Gn,Hn,In,Jn,Kn,Ln,Mn,Nn,On,Pn,Qn,Rn,Sn,Tn,Un,Vn,Wn,Xn,Yn,Zn,$n,ao,bo,co,eo,fo,go,ho,io,jo,ko,lo,mo,no,oo,po,qo,ro,so,to,uo,vo,wo,xo,yo,zo,Ao,Bo,Co,Do,Eo,Fo,Go,Ho,Io,Jo,Ko,Lo,Mo,No,Oo,Po,Qo,Ro,So,To,Uo,Vo,Wo,Xo,Yo,Zo,$o,ap,bp,cp,dp,ep,fp,gp,hp,ip,jp,kp,lp,mp,np,op,pp,qp,rp,sp,tp,up,vp,wp,xp,yp,zp,Ap,Bp,Cp,Dp,Ep,Fp,Gp,Hp,Ip,Jp,Kp,Lp,Mp,Np,Op,Pp,Qp,Rp,Sp,Tp,Up,Vp,Wp,Zp,$p,aq,bq,cq,dq,eq,fq,gq,hq,iq,jq,kq,lq,mq,nq,oq,pq,qq,rq,sq,tq,uq,vq,wq,xq,yq,zq,Aq,Bq,Cq,Dq,Eq,Fq,Gq,Hq,Iq,Jq,Kq,Lq,Mq,Nq,Oq,Pq,Qq,Rq,Sq,Tq,Uq,Vq,Wq,Xq,Yq,Zq,$q,ar,br,cr,dr,er,fr,gr,hr,ir,jr,kr,lr,mr,nr,or,pr,qr,rr,sr,tr,ur,vr,wr,xr,yr,zr,Ar,Br,Cr,Dr,Er,Fr,Gr,Hr,Ir,Jr,Kr,Lr,Mr,Nr,Or,Pr,Qr,Rr,Sr,Tr,Ur,Vr,Wr,Xr,Yr,Zr,$r,as,bs,cs,ds,es,fs,gs,hs,is,js,ks,ls,ms,ns,os,ps,qs,rs,ss,ts,us,vs,ws,xs,ys,zs,As,Bs,Cs,Ds,Es,Fs,Gs,Hs,Is,Js,Ks,Ls,Ms,Ns,Os,Ps,Qs,Rs,Ss,Ts,Us,Vs,Ws,Xs,Ys,Zs,$s,at,bt,ct,dt,et,ft,gt,ht,it,jt,kt,lt,mt,nt,ot,pt,qt,rt,st,tt,ut,vt,wt,xt,yt,zt,At,Bt,Ct,Dt,Et,Ft,Gt,Ht,It,Jt,Kt,Lt,Mt,Nt,Ot,Pt,Qt,Rt,St,Tt,Ut,Vt,Wt,Xt,Yt,Zt,$t,au,bu,cu,du,eu,fu,gu,hu,iu,ju,ku,lu,mu,nu,ou,pu,qu,ru,su,tu,uu,vu,wu,xu,yu,zu,Au,Bu,Cu,Du,Eu,Fu,Gu,Hu,Iu,Ju,Ku,Lu,Mu,Nu,Ou,Pu,Qu,Ru,Su,Tu,Uu,Vu,Wu,Xu,Yu,Zu,$u,av,bv,cv,dv,ev,fv,gv,hv,iv,jv,kv,lv,mv,nv,ov,pv,qv,rv,sv,tv,uv,vv,wv,xv,yv,zv,Av,Bv,Cv,Dv,Ev,Fv,Gv,Hv,Iv,Jv,Kv,Lv,Mv,Nv,Ov,Pv,Qv,Rv,Sv,Tv,Uv,Vv,Wv,Xv,Yv,Zv,$v,aw,bw,cw,dw,ew,fw,gw,hw,iw,jw,kw,lw,mw,nw,ow,pw,qw,rw,sw,tw,uw,vw,ww,xw,yw,zw,Aw,Bw,Cw,Dw,Ew,Fw,Gw,Hw,Iw,Jw,Kw,Lw,Mw,Nw,Ow,Pw,Qw,Rw,Sw,Tw,Uw,Vw,Ww,Xw,Yw,Zw,$w,ax,bx,cx,dx,ex,fx,gx,hx,ix,jx,kx,lx,mx,nx,ox,px,qx,rx,sx,tx,ux,vx,wx,xx,D,yx,zx,Ax,Bx,Cx,E,Dx,Ex,Fx,Gx,Hx,Ix,Jx,Kx,Lx,Mx,Nx,Ox,Px,Qx,F,Rx,Sx,Tx,Ux,Vx,Wx,Xx,Yx,Zx,$x,ay,by,cy,dy,ey,fy,gy,hy,iy,jy,ky,ly,my,ny,oy,py,qy,ry,sy,ty,uy,vy,wy,xy,yy,zy,Ay,By,Cy,Dy,Ey,Fy,Gy,Hy,Iy,Jy,Ky,Ly,My,Ny,Oy,Py,Qy,Ry,Sy,Ty,Uy,H,Vy,Wy,Xy,Yy,Zy,$y,az,bz,cz,dz,ez,fz,gz,hz,iz,J,jz,kz,lz,K,mz,nz,oz,pz,qz,rz,sz,tz,uz,vz,wz,xz,yz,zz,Az,Bz,Cz,Dz,Ez,Fz,Gz,Hz,Iz,Jz,Kz,Lz,Mz,Nz,Oz,Pz,Qz,Rz,Sz,Tz,Uz,Vz,Wz,Xz,Yz,Zz,$z,aA,bA,cA,dA,eA,fA,gA,hA,iA,jA,kA,lA;Ib=y(4,"i8",x);Jb=y(4,"i8",x);z=y(4,"i8",x);Kb=y(4,"i8",x);Lb=y(80,"i8",x);Mb=y(4,"i8",x);Nb=y(4,"i8",x);Xb=y(4,"i8",x);Yb=y(4096,"i8",x);Zb=y(4,"i8",x);$b=y([-1],["i32",0,0,0],x);dc=y([0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0],x);ec=y(4,"i8",x);fc=y(4,"i8",x);gc=y(4,"i8",x);hc=y(116,"i8",x);ic=y(4,"i8",x);jc=y(4,"i8",x);oc=y(4,"i8",x);pc=y(4,"i8",x);qc=y(4,"i8",x);rc=y(4,"i8",x);sc=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);tc=y(4,"i8",x);yc=y(4,"i8",x);zc=y(24,"i8",x);Ac=y(4,"i8",x);Bc=y(4,"i8",x);Cc=y(8,"i8",x);Dc=y(4,"i8",x);Ec=y(4,"i8",x);Fc=y(44,"i8",x);Gc=y(1024,"i8",x);Hc=y(4,"i8",x);Ic=y(16,"i8",x);Jc=y(4,"i8",x);Kc=y(4,"i8",x);Lc=y([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"i8",x);Tc=y([122],["void (%struct.sVString*, i32)*",0,0,0],x);Uc=y(4,"i8",x);Vc=y([1],["i32",0,0,0],x);Wc=y(4,"i8",x);Xc=y([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,1,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0],x);Yc=y(4,"i8",x);Zc=y(4,"i8",x);ld=y(32,"i8",x);md=y(4,"i8",x);nd=y(4,"i8",x);od=y(4,"i8",x);pd=y(4,"i8",x);qd=y(4,"i8",x);rd=y(4,"i8",x);sd=y([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0],x);td=y(24,"i8",x);ud=y([115,113,108,0],"i8",x);zd=y([109,97,105,110,0],"i8",x);Ad=y([115,101,116,0],"i8",x);Bd=y([99,111,110,115,116,97,110,116,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Cd=y([109,108,116,97,98,108,101,0],"i8",x);Dd=y([115,121,110,99,104,114,111,110,105,122,101,100,0],"i8",x);Ed=y([100,101,114,105,118,101,100,32,116,121,112,101,115,32,97,110,100,32,115,116,114,117,99,116,117,114,101,115,0],"i8",x);Fd=y([99,100,101,102,32,0],"i8",x);Gd=y([115,121,110,111,110,121,109,115,0],"i8",x);Ud=y([105,44,105,110,116,101,114,102,97,99,101,44,105,110,116,101,114,102,97,99,101,115,0],"i8",x);Vd=y([120,111,114,0],"i8",x);Wd=y([118,105,101,119,115,0],"i8",x);Xd=y([115,109,108,0],"i8",x);Yd=y([112,114,111,103,114,97,109,115,0],"i8",x);Zd=y([64,101,110,99,111,100,101,0],"i8",x);$d=y([115,108,0],"i8",x);ae=y([120,110,111,114,0],"i8",x);be=y([100,111,109,97,105,110,115,0],"i8",x);ce=y([101,120,112,111,114,116,0],"i8",x);re=y([115,116,114,105,110,103,0],"i8",x);se=y([110,97,109,101,108,105,115,116,115,0],"i8",x);te=y([116,104,105,115,0],"i8",x);ue=y([102,44,102,117,110,99,116,105,111,110,44,74,97,118,97,83,99,114,105,112,116,32,102,117,110,99,116,105,111,110,115,0],"i8",x);ve=y([119,105,116,104,0],"i8",x);we=y([115,101,114,118,105,99,101,115,0],"i8",x);xe=y([115,104,0],"i8",x);ye=y([119,104,105,108,101,0],"i8",x);ze=y([112,117,98,108,105,99,97,116,105,111,110,115,0],"i8",x);Ae=y([115,116,97,116,101,0],"i8",x);Be=y([83,67,77,0],"i8",x);Ce=y([97,117,116,111,109,97,116,105,99,0],"i8",x);De=y([108,111,99,97,108,44,32,99,111,109,109,111,110,32,98,108,111,99,107,44,32,97,110,100,32,110,97,109,101,108,105,115,116,32,118,97,114,105,97,98,108,101,115,0],"i8",x);Ee=y([115,105,103,110,101,100,0],"i8",x);Fe=y([119,104,101,110,0],"i8",x);Ge=y([98,101,116,0],"i8",x);Ie=y([109,97,99,114,111,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);Je=y([119,97,105,116,0],"i8",x);Ke=y([105,110,100,101,120,101,115,0],"i8",x);Le=y([115,101,108,101,99,116,111,114,0],"i8",x);Me=y([115,104,111,114,116,0],"i8",x);Ne=y([102,105,108,101,0],"i8",x);Oe=y([94,91,32,9,93,42,91,70,83,82,93,68,91,32,9,93,43,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,92,46,0],"i8",x);Pe=y([68,72,79,66,0],"i8",x);Qe=y([112,97,114,115,101,114,32,100,101,102,105,110,105,116,105,111,110,32,109,117,115,116,32,99,111,110,116,97,105,110,32,110,97,109,101,10,0],"i8",x);Re=y([101,110,100,102,111,0],"i8",x);Se=y([97,114,99,104,105,116,101,99,116,117,114,101,0],"i8",x);Te=y([111,117,116,112,117,116,0],"i8",x);Ue=y([105,110,99,108,117,100,101,0],"i8",x);Ve=y([112,114,111,116,101,99,116,101,100,0],"i8",x);We=y([118,97,114,105,97,98,108,101,115,0],"i8",x);Xe=y([97,108,108,32,112,97,116,116,101,114,110,115,0],"i8",x);Ye=y([115,104,97,100,111,119,0],"i8",x);Ze=y([117,115,101,0],"i8",x);$e=y([116,114,105,103,103,101,114,115,0],"i8",x);af=y([97,108,105,103,110,0],"i8",x);bf=y([99,111,110,102,105,103,117,114,101,0],"i8",x);cf=y([116,121,112,101,32,97,110,100,32,115,116,114,117,99,116,117,114,101,32,99,111,109,112,111,110,101,110,116,115,0],"i8",x);df=y([117,110,116,105,108,0],"i8",x);ef=y([116,97,98,108,101,115,0],"i8",x);ff=y([117,110,108,101,115,115,0],"i8",x);gf=y([99,108,97,115,115,32,0],"i8",x);kf=y([118,97,114,105,97,98,108,101,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);lf=y([117,110,105,116,115,0],"i8",x);mf=y([115,117,98,116,121,112,101,115,0],"i8",x);nf=y([115,117,98,0],"i8",x);of=y([117,110,99,116,105,111,110,0],"i8",x);pf=y([105,110,116,101,114,102,97,99,101,32,99,111,110,116,101,110,116,115,44,32,103,101,110,101,114,105,99,32,110,97,109,101,115,44,32,97,110,100,32,111,112,101,114,97,116,111,114,115,0],"i8",x);qf=y([118,97,114,105,97,98,108,101,0],"i8",x);rf=y([117,110,97,102,102,101,99,116,101,100,0],"i8",x);sf=y([114,101,99,111,114,100,115,0],"i8",x);tf=y([99,109,100,0],"i8",x);uf=y([64,112,114,111,116,111,99,111,108,0],"i8",x);vf=y([109,97,112,115,0],"i8",x);wf=y([116,121,112,101,0],"i8",x);xf=y([101,110,116,114,121,32,112,111,105,110,116,115,0],"i8",x);yf=y([102,117,110,99,116,105,111,110,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);zf=y([116,114,97,110,115,112,111,114,116,0],"i8",x);Af=y([112,97,99,107,97,103,101,115,0],"i8",x);Bf=y([99,111,109,109,111,110,32,98,108,111,99,107,115,0],"i8",x);Cf=y([102,117,110,99,116,105,111,110,0],"i8",x);Df=y([116,111,0],"i8",x);Ef=y([98,108,111,99,107,32,108,97,98,101,108,0],"i8",x);Ff=y([97,115,115,105,103,110,109,101,110,116,0],"i8",x);Gf=y([98,108,111,99,107,32,100,97,116,97,0],"i8",x);Hf=y([117,115,101,114,45,100,101,102,105,110,101,100,32,99,111,109,109,97,110,100,115,0],"i8",x);If=y([116,104,101,110,0],"i8",x);Jf=y([112,97,99,107,101,100,0],"i8",x);Kf=y([42,67,99,33,35,36,68,100,0],"i8",x);Lf=y([99,111,109,109,97,110,100,0],"i8",x);Mf=y([115,117,98,116,121,112,101,0],"i8",x);Nf=y([108,111,99,97,108,32,118,97,114,105,97,98,108,101,115,0],"i8",x);Of=y([112,114,97,103,109,97,0],"i8",x);Pf=y([112,121,0],"i8",x);Qf=y([37,115,58,32,117,110,116,101,114,109,105,110,97,116,101,100,32,99,104,97,114,97,99,116,101,114,32,115,116,114,105,110,103,32,97,116,32,108,105,110,101,32,37,108,117,10,0],"i8",x);Rf=y([73,110,115,116,97,108,108,105,110,103,32,112,97,114,115,101,114,115,58,32,0],"i8",x);Sf=y([101,110,100,0],"i8",x);Tf=y([97,110,100,0],"i8",x);Uf=y([109,111,100,117,108,101,0],"i8",x);Vf=y([100,101,102,97,117,108,116,0],"i8",x);Wf=y([115,117,98,112,97,114,97,103,114,97,112,104,0],"i8",x);Xf=y([97,117,116,111,99,111,109,109,97,110,100,32,103,114,111,117,112,115,0],"i8",x);Yf=y([112,117,98,108,105,99,0],"i8",x);Zf=y([115,114,108,0],"i8",x);$f=y([114,101,99,111,114,100,32,102,105,101,108,100,115,0],"i8",x);ag=y([112,97,116,116,101,114,110,0],"i8",x);bg=y([42,47,43,61,60,62,0],"i8",x);cg=y([97,117,103,114,111,117,112,0],"i8",x);dg=y([115,114,97,0],"i8",x);eg=y([102,105,101,108,100,0],"i8",x);fg=y([111,118,101,114,108,111,97,100,0],"i8",x);gg=y([65,115,109,0],"i8",x);hg=y([97,98,115,116,121,112,101,0],"i8",x);ig=y([110,44,110,97,109,101,115,112,97,99,101,44,110,97,109,101,115,112,97,99,101,115,0],"i8",x);jg=y([112,104,112,0],"i8",x);kg=y([99,110,111,114,101,109,97,112,0],"i8",x);lg=y([115,108,105,0],"i8",x);mg=y([61,0],"i8",x);ng=y([100,101,102,32,0],"i8",x);og=y([99,110,111,114,101,109,97,0],"i8",x);pg=y([115,108,97,0],"i8",x);qg=y([94,91,32,9,93,42,105,110,116,101,114,102,97,99,101,91,32,9,93,43,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,0],"i8",x);rg=y([95,95,69,78,68,95,95,0],"i8",x);sg=y([114,111,99,101,100,117,114,101,0],"i8",x);tg=y([97,110,111,110,121,109,111,117,115,0],"i8",x);ug=y([99,110,111,114,101,109,0],"i8",x);vg=y([115,104,97,114,101,100,0],"i8",x);wg=y([110,101,119,99,111,118,0],"i8",x);xg=y([100,105,109,0],"i8",x);yg=y([100,111,110,101,0],"i8",x);zg=y([64,105,110,116,101,114,102,97,99,101,0],"i8",x);Bg=y([45,0],"i8",x);Cg=y([99,110,111,114,101,0],"i8",x);Dg=y([115,105,103,110,97,108,0],"i8",x);Eg=y([99,117,114,115,111,114,115,0],"i8",x);Fg=y([101,110,100,101,102,0],"i8",x);Gg=y([112,108,0],"i8",x);Hg=y([37,115,58,32,110,111,116,32,102,105,120,101,100,32,115,111,117,114,99,101,32,102,111,114,109,59,32,114,101,116,114,121,32,97,115,32,102,114,101,101,32,115,111,117,114,99,101,32,102,111,114,109,10,0],"i8",x);Ig=y([94,91,32,9,93,42,102,117,110,99,116,105,111,110,91,32,9,93,42,40,91,65,45,90,97,45,122,48,45,57,95,93,43,41,91,32,9,93,42,92,40,0],"i8",x);Jg=y([99,110,111,114,0],"i8",x);Kg=y([115,101,118,101,114,105,116,121,0],"i8",x);Lg=y([110,97,116,105,118,101,0],"i8",x);Mg=y([102,117,110,99,0],"i8",x);Ng=y([112,0],"i8",x);Og=y([99,110,111,0],"i8",x);Pg=y([115,101,108,101,99,116,0],"i8",x);Qg=y([103,111,0],"i8",x);Rg=y([97,108,108,111,99,97,116,97,98,108,101,0],"i8",x);Sg=y([119,104,101,114,101,0],"i8",x);Tg=y([108,110,111,114,101,109,97,112,0],"i8",x);Ug=y([114,111,114,0],"i8",x);Vg=y([99,114,101,97,116,101,0],"i8",x);Wg=y([118,111,108,97,116,105,108,101,0],"i8",x);Xg=y([97,116,116,97,99,104,101,100,0],"i8",x);Yg=y([108,110,111,114,101,109,97,0],"i8",x);Zg=y([114,111,108,0],"i8",x);$g=y([99,111,109,109,101,110,116,0],"i8",x);ah=y([109,95,116,114,97,110,115,0],"i8",x);bh=y([100,44,100,97,116,97,44,100,97,116,97,32,105,116,101,109,115,0],"i8",x);ch=y([101,110,100,105,102,0],"i8",x);dh=y([47,0],"i8",x);eh=y([42,46,91,120,88,93,91,54,56,93,91,54,56,93,0],"i8",x);fh=y([108,101,116,0],"i8",x);gh=y([105,110,116,101,103,101,114,0],"i8",x);hh=y([63,0],"i8",x);ih=y([112,97,114,97,103,114,97,112,104,0],"i8",x);jh=y([108,110,111,114,101,109,0],"i8",x);kh=y([105,116,99,108,58,58,99,108,97,115,115,0],"i8",x);lh=y([114,101,116,117,114,110,0],"i8",x);mh=y([104,97,110,100,108,101,114,0],"i8",x);nh=y([100,101,99,108,97,114,101,0],"i8",x);oh=y([102,114,97,103,109,101,110,116,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);ph=y([109,95,115,116,97,116,101,0],"i8",x);qh=y([108,110,111,114,101,0],"i8",x);rh=y([114,101,106,101,99,116,0],"i8",x);sh=y([115,121,110,111,110,121,109,0],"i8",x);th=y([109,95,98,97,100,95,116,114,97,110,115,0],"i8",x);uh=y([97,115,109,0],"i8",x);vh=y([102,114,97,103,109,101,110,116,0],"i8",x);wh=y([33,37,38,36,35,43,45,60,62,61,47,63,64,92,126,39,94,124,42,95,0],"i8",x);xh=y([94,91,32,9,93,42,105,109,112,108,101,109,101,110,116,115,91,32,9,93,43,92,40,91,32,9,93,42,34,40,91,94,34,93,42,41,34,91,32,9,93,42,92,41,91,32,9,93,42,59,0],"i8",x);yh=y([83,104,0],"i8",x);zh=y([83,99,104,101,109,101,0],"i8",x);Ah=y([108,110,111,114,0],"i8",x);Bh=y([114,101,103,105,115,116,101,114,0],"i8",x);Ch=y([118,105,101,119,0],"i8",x);Dh=y([109,95,98,97,100,95,115,116,97,116,101,0],"i8",x);Eh=y([115,44,115,117,98,114,111,117,116,105,110,101,44,115,117,98,114,111,117,116,105,110,101,115,0],"i8",x);Fh=y([117,110,105,111,110,0],"i8",x);Gh=y([108,110,111,0],"i8",x);Hh=y([114,101,99,111,114,100,0],"i8",x);Ih=y([100,114,111,112,0],"i8",x);Jh=y([99,44,99,108,97,115,115,44,99,108,97,115,115,101,115,0],"i8",x);Kh=y([108,111,110,103,0],"i8",x);Lh=y([95,95,68,65,84,65,95,95,0],"i8",x);Mh=y([101,115,116,114,117,99,116,111,114,0],"i8",x);Nh=y([108,111,99,97,108,32,101,110,116,105,116,105,101,115,0],"i8",x);Oh=y([105,110,111,114,101,109,97,112,0],"i8",x);Ph=y([114,97,110,103,101,0],"i8",x);Qh=y([116,101,109,112,111,114,97,114,121,0],"i8",x);Rh=y([100,105,109,32,97,115,0],"i8",x);Sh=y([109,108,0],"i8",x);Th=y([102,101,97,116,117,114,101,115,0],"i8",x);Uh=y([64,105,109,112,108,101,109,101,110,116,97,116,105,111,110,0],"i8",x);Vh=y([105,110,111,114,101,109,97,0],"i8",x);Wh=y([112,117,114,101,0],"i8",x);Xh=y([76,105,115,112,0],"i8",x);Yh=y([116,97,114,103,101,116,0],"i8",x);Zh=y([105,110,111,114,101,109,0],"i8",x);$h=y([112,114,111,99,101,115,115,0],"i8",x);ai=y([109,108,95,97,100,100,95,112,114,111,112,101,114,116,121,0],"i8",x);bi=y([105,110,111,114,101,0],"i8",x);ci=y([112,114,111,99,101,100,117,114,101,0],"i8",x);di=y([109,108,95,97,100,100,95,108,97,110,103,95,99,111,110,110,95,115,99,114,105,112,116,95,99,104,107,0],"i8",x);ei=y([70,111,114,116,114,97,110,0],"i8",x);fi=y([66,73,84,0],"i8",x);gi=y([105,110,111,114,0],"i8",x);hi=y([112,111,115,116,112,111,110,101,100,0],"i8",x);ii=y([109,108,95,97,100,100,95,106,97,118,97,95,99,111,110,110,101,99,116,105,111,110,95,115,99,114,105,112,116,0],"i8",x);ji=y([105,110,116,0],"i8",x);ki=y([115,116,100,99,97,108,108,0],"i8",x);li=y([97,115,115,105,103,110,0],"i8",x);mi=y([105,110,111,0],"i8",x);ni=y([115,101,116,91,32,9,93,43,40,91,65,45,90,97,45,122,95,48,45,57,93,43,41,91,32,9,93,42,61,0],"i8",x);oi=y([112,111,114,116,0],"i8",x);pi=y([109,108,95,97,100,100,95,100,110,101,116,95,99,111,110,110,101,99,116,105,111,110,95,115,99,114,105,112,116,0],"i8",x);qi=y([102,111,110,116,45,102,97,99,101,0],"i8",x);ri=y([98,97,115,0],"i8",x);si=y([70,97,105,108,117,114,101,32,111,110,32,97,116,116,101,109,112,116,32,116,111,32,114,101,97,100,32,102,105,108,101,0],"i8",x);ti=y([101,108,115,101,0],"i8",x);ui=y([65,110,32,101,120,99,101,112,116,105,111,110,0],"i8",x);vi=y([32,32,32,32,37,115,58,32,0],"i8",x);wi=y([115,116,97,116,105,99,0],"i8",x);xi=y([109,0],"i8",x);yi=y([97,117,103,0],"i8",x);zi=y([42,46,91,54,56,93,91,54,56,93,91,107,75,115,83,120,88,93,0],"i8",x);Ai=y([97,108,105,97,115,0],"i8",x);Bi=y([105,110,112,117,116,0],"i8",x);Ci=y([112,97,114,116,0],"i8",x);Di=y([111,110,111,114,101,109,97,112,0],"i8",x);Ei=y([99,120,120,0],"i8",x);Fi=y([99,108,97,115,115,0],"i8",x);Gi=y([112,97,99,107,97,103,101,0],"i8",x);Hi=y([109,108,95,97,100,100,95,108,97,110,103,95,99,111,110,110,101,99,116,105,111,110,95,115,99,114,105,112,116,0],"i8",x);Ii=y([99,117,114,115,111,114,0],"i8",x);Ji=y([69,120,99,101,112,116,105,111,110,0],"i8",x);Ki=y([115,101,113,117,101,110,99,101,0],"i8",x);Li=y([118,97,114,105,97,110,116,0],"i8",x);Mi=y([111,110,111,114,101,109,97,0],"i8",x);Ni=y([111,117,116,0],"i8",x);Oi=y([109,108,95,97,100,100,95,99,111,110,110,101,99,116,105,111,110,95,115,99,114,105,112,116,0],"i8",x);Pi=y([116,44,116,97,114,103,101,116,44,116,97,114,103,101,116,115,0],"i8",x);Qi=y([99,111,110,116,101,120,116,115,0],"i8",x);Ri=y([83,76,79,84,0],"i8",x);Si=y([65,32,39,115,116,114,117,99,116,117,114,101,39,32,102,105,101,108,100,0],"i8",x);Ti=y([105,0],"i8",x);Ui=y([122,115,104,0],"i8",x);Vi=y([115,109,0],"i8",x);Wi=y([91,77,109,93,97,107,101,102,105,108,101,0],"i8",x);Xi=y([46,0],"i8",x);Yi=y([111,110,111,114,101,109,0],"i8",x);Zi=y([111,116,104,101,114,115,0],"i8",x);$i=y([109,108,95,97,100,100,95,108,97,110,103,95,116,97,98,108,101,95,115,99,114,105,112,116,95,99,104,107,0],"i8",x);aj=y([100,101,115,99,114,105,98,101,115,0],"i8",x);bj=y([108,117,97,0],"i8",x);cj=y([82,101,99,111,114,100,32,102,105,101,108,100,0],"i8",x);dj=y([115,97,118,101,0],"i8",x);ej=y([80,121,116,104,111,110,0],"i8",x);fj=y([111,110,111,114,101,0],"i8",x);gj=y([111,114,0],"i8",x);hj=y([109,108,95,97,100,100,95,106,97,118,97,95,116,97,98,108,101,95,115,99,114,105,112,116,0],"i8",x);ij=y([99,108,0],"i8",x);jj=y([105,109,112,108,101,109,101,110,116,115,0],"i8",x);kj=y([92,51,0],"i8",x);lj=y([115,105,110,103,108,101,116,111,110,32,109,101,116,104,111,100,115,0],"i8",x);mj=y([65,32,99,111,110,115,116,114,117,99,116,111,114,0],"i8",x);nj=y([61,99,117,116,0],"i8",x);oj=y([111,110,115,116,114,117,99,116,111,114,0],"i8",x);pj=y([114,101,99,117,114,115,105,118,101,0],"i8",x);qj=y([117,110,100,101,102,105,110,101,0],"i8",x);rj=y([111,110,111,114,0],"i8",x);sj=y([111,112,101,110,0],"i8",x);tj=y([109,108,95,97,100,100,95,100,110,101,116,95,116,97,98,108,101,95,115,99,114,105,112,116,0],"i8",x);uj=y([115,105,110,103,108,101,116,111,110,32,109,101,116,104,111,100,0],"i8",x);vj=y([67,111,110,115,116,114,117,99,116,111,114,0],"i8",x);wj=y([101,110,117,109,0],"i8",x);xj=y([103,111,116,111,0],"i8",x);yj=y([111,110,111,0],"i8",x);zj=y([109,108,95,97,100,100,95,108,97,110,103,95,116,97,98,108,101,95,115,99,114,105,112,116,0],"i8",x);Aj=y([97,119,107,0],"i8",x);Bj=y([108,115,112,0],"i8",x);Cj=y([65,32,102,117,110,99,116,105,111,110,0],"i8",x);Dj=y([79,98,106,101,99,116,0],"i8",x);Ej=y([97,44,97,110,99,104,111,114,44,110,97,109,101,100,32,97,110,99,104,111,114,115,0],"i8",x);Fj=y([118,110,111,114,101,109,97,112,0],"i8",x);Gj=y([111,102,0],"i8",x);Hj=y([109,108,95,97,100,100,95,116,97,98,108,101,95,115,99,114,105,112,116,0],"i8",x);Ij=y([84,121,112,101,32,110,97,109,101,0],"i8",x);Jj=y([115,116,114,105,112,0],"i8",x);Kj=y([118,110,111,114,101,109,97,0],"i8",x);Lj=y([110,117,108,108,0],"i8",x);Mj=y([102,111,114,101,105,103,110,0],"i8",x);Nj=y([102,114,105,101,110,100,0],"i8",x);Oj=y([102,57,53,0],"i8",x);Pj=y([71,108,111,98,97,108,32,118,97,114,105,97,98,108,101,0],"i8",x);Qj=y([115,101,112,97,114,97,116,101,0],"i8",x);Rj=y([118,110,111,114,101,109,0],"i8",x);Sj=y([110,111,116,0],"i8",x);Tj=y([99,111,110,115,116,114,97,105,110,116,0],"i8",x);Uj=y([108,111,97,100,0],"i8",x);Vj=y([102,111,114,101,97,99,104,0],"i8",x);Wj=y([118,97,114,0],"i8",x);Xj=y([112,114,111,103,114,97,109,0],"i8",x);Yj=y([106,115,0],"i8",x);Zj=y([118,110,111,114,101,0],"i8",x);$j=y([99,104,101,99,107,0],"i8",x);ak=y([112,97,103,101,0],"i8",x);bk=y([96,0],"i8",x);ck=y([78,85,76,76,32,102,105,108,101,32,112,111,105,110,116,101,114,0],"i8",x);dk=y([101,108,105,102,0],"i8",x);ek=y([94,91,32,9,93,42,91,48,45,57,93,43,91,32,9,93,43,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,91,32,9,93,43,40,66,76,65,78,75,124,79,67,67,85,82,83,124,73,83,124,74,85,83,84,124,80,73,67,124,82,69,68,69,70,73,78,69,83,124,82,69,78,65,77,69,83,124,83,73,71,78,124,83,89,78,67,124,85,83,65,71,69,124,86,65,76,85,69,41,0],"i8",x);fk=y([77,111,100,117,108,101,32,111,114,32,102,117,110,99,116,111,114,0],"i8",x);gk=y([111,117,116,32,111,102,32,109,101,109,111,114,121,0],"i8",x);hk=y([102,117,0],"i8",x);ik=y([104,116,109,0],"i8",x);jk=y([114,101,116,114,121,0],"i8",x);kk=y([97,102,116,101,114,0],"i8",x);lk=y([42,46,50,57,91,107,75,93,0],"i8",x);mk=y([115,117,98,115,117,98,115,101,99,116,105,111,110,0],"i8",x);nk=y([118,110,111,114,0],"i8",x);ok=y([112,114,111,99,0],"i8",x);pk=y([110,101,120,116,0],"i8",x);qk=y([99,112,112,0],"i8",x);rk=y([117,110,105,113,117,101,0],"i8",x);sk=y([102,108,111,97,116,0],"i8",x);tk=y([33,126,0],"i8",x);uk=y([79,98,106,101,99,116,39,115,32,109,101,116,104,111,100,0],"i8",x);vk=y([112,114,101,99,105,115,105,111,110,0],"i8",x);wk=y([100,101,102,0],"i8",x);xk=y([118,110,111,0],"i8",x);yk=y([110,101,119,0],"i8",x);zk=y([114,101,102,101,114,101,110,99,101,115,0],"i8",x);Ak=y([102,105,110,97,108,0],"i8",x);Bk=y([94,91,32,9,93,42,60,91,32,9,93,42,116,97,114,103,101,116,91,94,62,93,43,110,97,109,101,61,34,40,91,94,34,93,43,41,34,46,42,0],"i8",x);Ck=y([61,126,0],"i8",x);Dk=y([40,42,0],"i8",x);Ek=y([102,44,102,117,110,99,116,105,111,110,44,102,117,110,99,116,105,111,110,115,0],"i8",x);Fk=y([107,115,104,0],"i8",x);Gk=y([115,99,109,0],"i8",x);Hk=y([112,111,105,110,116,101,114,0],"i8",x);Ik=y([114,101,115,99,117,101,0],"i8",x);Jk=y([105,110,99,0],"i8",x);Kk=y([110,110,111,114,101,109,97,112,0],"i8",x);Lk=y([110,97,110,100,0],"i8",x);Mk=y([112,114,105,109,97,114,121,0],"i8",x);Nk=y([33,61,0],"i8",x);Ok=y([61,101,110,100,0],"i8",x);Pk=y([94,40,91,65,45,90,97,45,122,48,45,57,64,35,36,92,46,33,63,95,93,43,41,91,32,9,93,42,58,0],"i8",x);Qk=y([79,67,97,109,108,32,77,97,120,105,109,117,109,32,100,101,112,116,104,32,114,101,97,99,104,101,100,0],"i8",x);Rk=y([65,32,112,114,101,112,114,111,99,101,115,115,111,114,32,109,97,99,114,111,0],"i8",x);Sk=y([112,103,108,111,98,97,108,0],"i8",x);Tk=y([114,101,113,117,105,114,101,0],"i8",x);Uk=y([115,99,111,110,115,0],"i8",x);Vk=y([104,43,43,0],"i8",x);Wk=y([110,110,111,114,101,109,97,0],"i8",x);Xk=y([109,111,100,0],"i8",x);Yk=y([101,120,116,101,110,100,115,0],"i8",x);Zk=y([94,91,32,9,93,42,40,40,102,105,110,97,108,124,97,98,115,116,114,97,99,116,41,91,32,9,93,43,41,42,99,108,97,115,115,91,32,9,93,43,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,0],"i8",x);$k=y([61,61,61,0],"i8",x);al=y([98,101,103,105,110,47,101,110,100,0],"i8",x);bl=y([80,101,114,108,0],"i8",x);cl=y([102,111,114,119,97,114,100,0],"i8",x);dl=y([112,101,120,116,101,114,110,97,108,0],"i8",x);el=y([114,101,110,97,109,101,0],"i8",x);fl=y([104,120,120,0],"i8",x);gl=y([110,110,111,114,101,109,0],"i8",x);hl=y([97,116,0],"i8",x);il=y([101,120,112,108,105,99,105,116,0],"i8",x);jl=y([61,61,0],"i8",x);kl=y([105,109,112,111,114,116,115,0],"i8",x);ll=y([77,111,100,117,108,101,0],"i8",x);ml=y([65,110,32,101,110,117,109,101,114,97,116,105,111,110,0],"i8",x);nl=y([66,97,115,105,99,0],"i8",x);ol=y([112,97,115,99,97,108,0],"i8",x);pl=y([114,101,100,101,102,105,110,101,0],"i8",x);ql=y([104,112,112,0],"i8",x);rl=y([110,110,111,114,101,0],"i8",x);sl=y([108,111,111,112,0],"i8",x);tl=y([101,120,99,101,112,116,105,111,110,0],"i8",x);ul=y([77,97,107,101,0],"i8",x);vl=y([60,61,62,0],"i8",x);wl=y([110,97,109,101,115,112,97,99,101,0],"i8",x);xl=y([108,105,115,112,0],"i8",x);yl=y([65,32,116,121,112,101,32,115,116,114,117,99,116,117,114,101,0],"i8",x);zl=y([112,114,101,102,105,120,0],"i8",x);Al=y([104,104,0],"i8",x);Bl=y([110,110,111,114,0],"i8",x);Cl=y([108,105,116,101,114,97,108,0],"i8",x);Dl=y([62,61,0],"i8",x);El=y([99,111,110,115,116,0],"i8",x);Fl=y([102,97,108,115,101,0],"i8",x);Gl=y([65,32,116,121,112,101,32,97,108,105,97,115,0],"i8",x);Hl=y([111,112,116,105,111,110,97,108,0],"i8",x);Il=y([72,0],"i8",x);Jl=y([110,110,111,0],"i8",x);Kl=y([108,105,110,107,97,103,101,0],"i8",x);Ll=y([62,0],"i8",x);Ml=y([99,108,97,115,115,32,109,101,109,98,101,114,115,0],"i8",x);Nl=y([102,57,48,0],"i8",x);Ol=y([116,114,117,101,0],"i8",x);Pl=y([65,32,112,114,111,112,101,114,116,121,0],"i8",x);Ql=y([111,112,101,114,97,116,111,114,0],"i8",x);Rl=y([111,110,99,101,0],"i8",x);Sl=y([104,0],"i8",x);Tl=y([110,111,114,101,109,97,112,0],"i8",x);Ul=y([108,105,98,114,97,114,121,0],"i8",x);Vl=y([69,114,108,97,110,103,0],"i8",x);Wl=y([60,0],"i8",x);Xl=y([45,62,0],"i8",x);Yl=y([112,114,111,112,101,114,116,121,0],"i8",x);Zl=y([110,97,109,101,108,105,115,116,0],"i8",x);$l=y([111,108,100,0],"i8",x);am=y([32,32,32,32,83,101,116,116,105,110,103,32,100,101,102,97,117,108,116,32,104,101,97,100,101,114,32,101,120,116,101,110,115,105,111,110,115,58,32,0],"i8",x);bm=y([110,111,114,101,109,97,0],"i8",x);cm=y([108,97,98,101,108,0],"i8",x);dm=y([116,97,115,107,115,0],"i8",x);em=y([101,120,116,101,114,110,97,108,0],"i8",x);fm=y([100,101,108,101,116,101,0],"i8",x);gm=y([60,61,0],"i8",x);hm=y(1,"i8",x);im=y([105,102,0],"i8",x);jm=y([67,111,98,111,108,0],"i8",x);km=y([97,115,114,0],"i8",x);lm=y([37,115,46,37,115,0],"i8",x);mm=y([108,44,108,97,98,101,108,44,108,97,98,101,108,115,0],"i8",x);nm=y([109,120,116,97,103,115,0],"i8",x);om=y([99,111,109,0],"i8",x);pm=y([111,98,115,111,108,101,116,101,0],"i8",x);qm=y([97,99,99,101,115,115,0],"i8",x);rm=y([32,32,32,32,97,100,100,105,110,103,32,101,120,99,108,117,100,101,32,112,97,116,116,101,114,110,58,32,37,115,10,0],"i8",x);sm=y([115,117,98,115,101,99,116,105,111,110,0],"i8",x);tm=y([110,111,114,101,109,0],"i8",x);um=y([84,99,108,0],"i8",x);vm=y([105,115,0],"i8",x);wm=y([114,101,103,105,115,116,101,114,32,100,97,116,97,32,116,121,112,101,115,0],"i8",x);xm=y([99,112,0],"i8",x);ym=y([105,110,116,101,114,110,97,108,0],"i8",x);zm=y([42,46,65,53,49,0],"i8",x);Am=y([100,101,108,101,103,97,116,101,0],"i8",x);Bm=y([124,0],"i8",x);Cm=y([34,34,34,0],"i8",x);Dm=y([108,115,114,32,0],"i8",x);Em=y([109,120,116,97,103,0],"i8",x);Fm=y([32,32,32,32,97,100,100,105,110,103,32,101,120,99,108,117,100,101,32,112,97,116,116,101,114,110,115,32,102,114,111,109,32,37,115,10,0],"i8",x);Gm=y([110,111,114,101,0],"i8",x);Hm=y([105,110,111,117,116,0],"i8",x);Im=y([117,114,108,0],"i8",x);Jm=y([112,44,112,114,111,106,101,99,116,44,112,114,111,106,101,99,116,115,0],"i8",x);Km=y([94,0],"i8",x);Lm=y([39,39,39,0],"i8",x);Mm=y([42,41,0],"i8",x);Nm=y([108,115,108,32,0],"i8",x);Om=y([79,98,106,101,99,116,32,102,105,101,108,100,0],"i8",x);Pm=y([80,82,79,71,82,65,77,0],"i8",x);Qm=y([98,97,115,104,0],"i8",x);Rm=y([115,99,104,101,109,101,0],"i8",x);Sm=y([108,111,103,105,99,97,108,0],"i8",x);Tm=y([110,111,114,0],"i8",x);Um=y([105,110,101,114,116,105,97,108,0],"i8",x);Vm=y([112,111,114,116,115,0],"i8",x);Wm=y([114,101,115,117,108,116,0],"i8",x);Xm=y([38,0],"i8",x);Ym=y([99,112,100,101,102,0],"i8",x);Zm=y([61,98,101,103,105,110,0],"i8",x);$m=y([82,69,88,88,0],"i8",x);an=y([108,120,111,114,32,0],"i8",x);bn=y([105,110,116,114,105,110,115,105,99,0],"i8",x);cn=y([112,120,105,0],"i8",x);dn=y([46,115,118,110,0],"i8",x);en=y([105,110,0],"i8",x);fn=y([100,97,116,97,116,121,112,101,0],"i8",x);gn=y([99,111,118,101,114,97,103,101,95,100,101,102,0],"i8",x);hn=y([80,72,80,0],"i8",x);jn=y([60,60,0],"i8",x);kn=y([99,100,101,102,0],"i8",x);ln=y([108,111,114,32,0],"i8",x);mn=y([112,101,114,108,0],"i8",x);nn=y([108,105,107,101,0],"i8",x);on=y([83,67,67,83,0],"i8",x);pn=y([99,109,97,112,0],"i8",x);qn=y([105,109,112,117,114,101,0],"i8",x);rn=y([110,101,116,32,100,97,116,97,32,116,121,112,101,115,0],"i8",x);sn=y([100,111,109,97,105,110,0],"i8",x);tn=y([99,111,118,101,114,97,103,101,95,98,108,111,99,107,0],"i8",x);un=y([62,62,0],"i8",x);vn=y([108,97,110,100,32,0],"i8",x);wn=y([112,98,0],"i8",x);xn=y([105,110,116,101,110,116,0],"i8",x);yn=y([116,121,112,101,100,101,102,0],"i8",x);zn=y([82,69,83,89,78,67,0],"i8",x);An=y([99,109,97,0],"i8",x);Bn=y([110,101,116,0],"i8",x);Cn=y([115,101,114,118,105,99,101,0],"i8",x);Dn=y([97,115,112,0],"i8",x);En=y([109,107,0],"i8",x);Fn=y([65,119,107,0],"i8",x);Gn=y([102,114,111,109,0],"i8",x);Hn=y([108,0],"i8",x);In=y([115,117,98,114,111,117,116,105,110,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Jn=y([109,111,100,32,0],"i8",x);Kn=y([67,108,97,115,115,39,32,109,101,116,104,111,100,0],"i8",x);Ln=y([70,117,110,99,116,105,111,110,0],"i8",x);Mn=y([105,110,118,97,114,105,97,110,116,0],"i8",x);Nn=y([60,97,40,91,32,9,93,43,91,97,45,122,93,43,61,34,63,91,94,62,34,93,42,34,63,41,42,91,32,9,93,43,110,97,109,101,61,34,63,40,91,94,62,34,93,43,41,34,63,40,91,32,9,93,43,91,97,45,122,93,43,61,34,63,91,94,62,34,93,42,34,63,41,42,91,32,9,93,42,62,0],"i8",x);On=y([82,67,83,0],"i8",x);Pn=y([99,109,0],"i8",x);Qn=y([103,117,97,114,100,101,100,0],"i8",x);Rn=y([109,111,100,117,108,101,115,0],"i8",x);Sn=y([112,117,98,108,105,99,97,116,105,111,110,0],"i8",x);Tn=y([116,121,112,101,115,32,40,115,116,114,117,99,116,115,32,97,110,100,32,114,101,99,111,114,100,115,41,0],"i8",x);Un=y([43,0],"i8",x);Vn=y([101,120,116,101,114,110,0],"i8",x);Wn=y([115,117,98,114,111,117,116,105,110,101,32,100,101,99,108,97,114,97,116,105,111,110,0],"i8",x);Xn=y([105,110,108,105,110,101,0],"i8",x);Yn=y([105,110,115,112,101,99,116,0],"i8",x);Zn=y([80,69,78,68,73,78,71,0],"i8",x);$n=y([108,109,97,112,0],"i8",x);ao=y([103,114,111,117,112,0],"i8",x);bo=y([102,117,110,99,116,105,111,110,115,0],"i8",x);co=y([37,0],"i8",x);eo=y([115,117,98,114,111,117,116,105,110,101,115,0],"i8",x);fo=y([102,55,55,0],"i8",x);go=y([105,110,104,101,114,105,116,0],"i8",x);ho=y([46,104,103,0],"i8",x);io=y([99,104,97,114,0],"i8",x);jo=y([108,109,97,0],"i8",x);ko=y([103,101,110,101,114,105,99,0],"i8",x);lo=y([101,118,101,110,116,115,0],"i8",x);mo=y([105,110,100,101,120,0],"i8",x);no=y([72,82,76,0],"i8",x);oo=y([115,117,98,114,111,117,116,105,110,101,0],"i8",x);po=y([105,109,112,108,105,99,105,116,0],"i8",x);qo=y([105,110,102,105,120,0],"i8",x);ro=y([46,103,105,116,0],"i8",x);so=y([108,109,0],"i8",x);to=y([103,101,110,101,114,97,116,101,0],"i8",x);uo=y([99,111,110,115,116,97,110,116,115,32,40,100,101,102,105,110,101,44,32,112,97,114,97,109,101,116,101,114,44,32,115,112,101,99,112,97,114,97,109,41,0],"i8",x);vo=y([94,58,40,91,65,45,90,97,45,122,95,48,45,57,93,43,41,0],"i8",x);wo=y([42,0],"i8",x);xo=y([108,97,109,98,100,97,0],"i8",x);yo=y([105,110,99,108,117,100,101,32,0],"i8",x);zo=y([117,110,100,101,102,0],"i8",x);Ao=y([67,79,66,0],"i8",x);Bo=y([118,105,114,116,117,97,108,0],"i8",x);Co=y([32,58,32,37,115,0],"i8",x);Do=y([80,114,111,116,111,99,111,108,0],"i8",x);Eo=y([32,0],"i8",x);Fo=y([92,49,0],"i8",x);Go=y([99,111,109,99,0],"i8",x);Ho=y([105,110,100,101,120,105,110,103,0],"i8",x);Io=y([97,98,115,0],"i8",x);Jo=y([101,118,101,110,116,0],"i8",x);Ko=y([69,73,70,71,69,78,0],"i8",x);Lo=y([101,110,118,0],"i8",x);Mo=y([115,101,99,116,105,111,110,0],"i8",x);No=y([105,109,97,112,0],"i8",x);Oo=y([105,116,99,108,0],"i8",x);Po=y([116,114,105,103,103,101,114,0],"i8",x);Qo=y([99,99,0],"i8",x);Ro=y([83,0],"i8",x);So=y([100,101,102,105,110,101,115,0],"i8",x);To=y([101,110,117,109,101,114,97,116,105,111,110,115,0],"i8",x);Uo=y([45,64,0],"i8",x);Vo=y([108,97,98,101,108,115,0],"i8",x);Wo=y([112,114,111,116,111,99,111,108,0],"i8",x);Xo=y([102,97,108,0],"i8",x);Yo=y([111,118,101,114,114,105,100,101,0],"i8",x);Zo=y([105,109,112,108,105,101,115,0],"i8",x);$o=y([46,100,101,112,115,0],"i8",x);ap=y([105,109,97,0],"i8",x);bp=y([102,111,114,0],"i8",x);cp=y([116,97,98,108,101,0],"i8",x);dp=y([43,64,0],"i8",x);ep=y([83,77,76,0],"i8",x);fp=y([99,108,97,115,115,32,105,109,112,108,101,109,101,110,116,97,116,105,111,110,0],"i8",x);gp=y([94,46,42,100,101,102,105,110,101,91,32,9,93,43,40,91,65,45,90,95,93,91,65,45,90,48,45,57,95,93,42,41,91,94,59,93,42,36,0],"i8",x);hp=y([98,115,104,0],"i8",x);ip=y([76,73,66,0],"i8",x);jp=y([115,99,104,0],"i8",x);kp=y([102,120,0],"i8",x);lp=y([95,36,0],"i8",x);mp=y([95,100,97,114,99,115,0],"i8",x);np=y([105,109,0],"i8",x);op=y([98,111,111,108,101,97,110,0],"i8",x);pp=y([101,114,108,0],"i8",x);qp=y([115,0],"i8",x);rp=y([126,0],"i8",x);sp=y([95,95,105,110,105,116,95,95,0],"i8",x);tp=y([82,117,98,121,0],"i8",x);up=y([102,111,114,109,97,116,115,0],"i8",x);vp=y([114,120,0],"i8",x);wp=y([105,109,112,108,101,109,101,110,116,97,116,105,111,110,0],"i8",x);xp=y([103,108,111,98,97,108,32,118,97,114,105,97,98,108,101,115,0],"i8",x);yp=y([109,120,0],"i8",x);zp=y([102,114,111,122,101,110,0],"i8",x);Ap=y([112,120,100,0],"i8",x);Bp=y([46,99,118,115,105,103,110,111,114,101,0],"i8",x);Cp=y([111,109,97,112,0],"i8",x);Dp=y([98,105,116,0],"i8",x);Ep=y([101,120,105,116,0],"i8",x);Fp=y([114,101,116,117,114,110,115,0],"i8",x);Gp=y([95,36,63,0],"i8",x);Hp=y([112,104,116,109,108,0],"i8",x);Ip=y([33,0],"i8",x);Jp=y([95,95,0],"i8",x);Kp=y([99,111,110,115,116,97,110,116,115,0],"i8",x);Lp=y([116,114,121,0],"i8",x);Mp=y([99,108,97,115,115,32,105,110,116,101,114,102,97,99,101,0],"i8",x);Np=y([112,108,120,0],"i8",x);Op=y([80,97,115,99,97,108,0],"i8",x);Pp=y([101,113,117,105,118,97,108,101,110,99,101,0],"i8",x);Qp=y([99,100,97,116,97,0],"i8",x);Rp=y([67,86,83,0],"i8",x);Sp=y([111,109,97,0],"i8",x);Tp=y([98,105,110,100,95,118,97,114,0],"i8",x);Up=y([101,110,116,105,116,121,0],"i8",x);Vp=y([119,111,114,0],"i8",x);Wp=y([42,47,0],"i8",x);Zp=y([42,42,0],"i8",x);$p=y([109,101,109,98,101,114,0],"i8",x);aq=y([32,9,0],"i8",x);bq=y([79,67,97,109,108,0],"i8",x);cq=y([105,110,116,101,114,102,97,99,101,0],"i8",x);dq=y([112,114,111,112,101,114,116,105,101,115,0],"i8",x);eq=y([98,98,0],"i8",x);fq=y([101,110,116,114,121,0],"i8",x);gq=y([115,99,114,105,112,116,0],"i8",x);hq=y([102,101,97,116,117,114,101,0],"i8",x);iq=y([79,98,106,101,99,116,105,118,101,67,0],"i8",x);jq=y([46,98,122,114,105,103,110,111,114,101,0],"i8",x);kq=y([111,109,0],"i8",x);lq=y([98,105,110,100,0],"i8",x);mq=y([119,105,114,101,0],"i8",x);nq=y([114,101,109,0],"i8",x);oq=y([47,42,0],"i8",x);pq=y([118,97,108,117,101,32,98,105,110,100,105,110,103,115,0],"i8",x);qq=y([109,97,107,0],"i8",x);rq=y([91,93,61,0],"i8",x);sq=y([101,108,0],"i8",x);tq=y([109,97,119,107,0],"i8",x);uq=y([115,116,114,117,99,116,0],"i8",x);vq=y([110,97,109,101,0],"i8",x);wq=y([46,98,122,114,0],"i8",x);xq=y([72,84,77,76,0],"i8",x);yq=y([118,109,97,112,0],"i8",x);zq=y([98,97,100,95,116,114,97,110,115,0],"i8",x);Aq=y([101,108,115,105,102,0],"i8",x);Bq=y([119,97,110,100,0],"i8",x);Cq=y([114,101,102,0],"i8",x);Dq=y([59,42,64,0],"i8",x);Eq=y([118,97,108,117,101,0],"i8",x);Fq=y([91,93,0],"i8",x);Gq=y([58,0],"i8",x);Hq=y([101,108,101,109,101,110,116,97,108,0],"i8",x);Iq=y([105,100,0],"i8",x);Jq=y([10,0],"i8",x);Kq=y([66,105,116,75,101,101,112,101,114,0],"i8",x);Lq=y([118,109,97,0],"i8",x);Mq=y([98,97,100,95,115,116,97,116,101,0],"i8",x);Nq=y([116,114,105,114,101,103,0],"i8",x);Oq=y([111,98,106,101,99,116,0],"i8",x);Pq=y([63,33,61,0],"i8",x);Qq=y([65,115,112,0],"i8",x);Rq=y([102,116,110,0],"i8",x);Sq=y([114,101,99,0],"i8",x);Tq=y([64,114,101,113,117,105,114,101,100,0],"i8",x);Uq=y([97,108,108,0],"i8",x);Vq=y([100,111,117,98,108,101,0],"i8",x);Wq=y([70,108,101,120,0],"i8",x);Xq=y([97,117,116,111,109,52,116,101,46,99,97,99,104,101,0],"i8",x);Yq=y([118,109,0],"i8",x);Zq=y([97,98,115,116,114,97,99,116,0],"i8",x);$q=y([100,111,119,110,116,111,0],"i8",x);ar=y([116,114,105,111,114,0],"i8",x);br=y([110,111,0],"i8",x);cr=y([70,97,108,99,111,110,0],"i8",x);dr=y([115,116,114,117,99,116,117,114,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);er=y([104,114,108,0],"i8",x);fr=y([95,0],"i8",x);gr=y([98,114,34,0],"i8",x);hr=y([111,110,0],"i8",x);ir=y([112,111,100,0],"i8",x);jr=y([64,111,112,116,105,111,110,97,108,0],"i8",x);kr=y([121,0],"i8",x);lr=y([101,120,112,97,110,100,101,100,0],"i8",x);mr=y([46,97,114,99,104,45,105,110,118,101,110,116,111,114,121,0],"i8",x);nr=y([110,109,97,112,0],"i8",x);or=y([95,95,97,116,116,114,105,98,117,116,101,95,95,0],"i8",x);pr=y([100,105,115,99,111,110,110,101,99,116,0],"i8",x);qr=y([116,114,105,0],"i8",x);rr=y([68,111,115,66,97,116,99,104,0],"i8",x);sr=y([102,0],"i8",x);tr=y([115,105,103,110,97,116,117,114,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);ur=y([109,101,100,105,97,0],"i8",x);vr=y([32,44,34,46,35,95,63,33,61,39,47,45,0],"i8",x);wr=y([79,80,69,78,73,78,71,32,37,115,32,97,115,32,37,115,32,108,97,110,103,117,97,103,101,32,37,115,102,105,108,101,10,0],"i8",x);xr=y([98,114,39,0],"i8",x);yr=y([92,50,46,92,51,0],"i8",x);zr=y([100,101,102,105,110,101,0],"i8",x);Ar=y([67,66,76,0],"i8",x);Br=y([98,97,99,107,0],"i8",x);Cr=y([44,32,0],"i8",x);Dr=y([64,100,121,110,97,109,105,99,0],"i8",x);Er=y([101,0],"i8",x);Fr=y([94,40,91,65,45,90,97,45,122,93,91,65,45,90,97,45,122,95,48,45,57,93,43,41,91,32,9,93,42,58,0],"i8",x);Gr=y([100,108,108,95,105,109,112,111,114,116,0],"i8",x);Hr=y([99,111,109,112,0],"i8",x);Ir=y([101,110,115,117,114,101,0],"i8",x);Jr=y([86,72,68,76,0],"i8",x);Kr=y([96,100,101,102,105,110,101,0],"i8",x);Lr=y([46,97,114,99,104,45,105,100,115,0],"i8",x);Mr=y([105,103,110,111,114,105,110,103,32,37,115,32,40,108,97,110,103,117,97,103,101,32,100,105,115,97,98,108,101,100,41,10,0],"i8",x);Nr=y([99,104,97,112,116,101,114,0],"i8",x);Or=y([110,109,97,0],"i8",x);Pr=y([86,101,114,97,0],"i8",x);Qr=y([119,105,115,104,0],"i8",x);Rr=y([99,111,110,115,116,97,110,116,0],"i8",x);Sr=y([116,114,105,97,110,100,0],"i8",x);Tr=y([99,43,43,0],"i8",x);Ur=y([97,115,0],"i8",x);Vr=y([102,117,110,99,116,111,114,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);Wr=y([95,46,63,33,61,0],"i8",x);Xr=y([117,114,34,0],"i8",x);Yr=y([40,94,124,91,32,9,93,41,40,91,65,45,90,97,45,122,48,45,57,95,46,93,43,41,92,46,40,91,65,45,90,97,45,122,48,45,57,95,93,43,41,91,32,9,93,42,61,91,32,9,93,42,102,117,110,99,116,105,111,110,91,32,9,93,42,92,40,0],"i8",x);Zr=y([98,97,116,0],"i8",x);$r=y([105,116,101,109,0],"i8",x);as=y([102,111,114,109,97,116,0],"i8",x);bs=y([109,117,116,97,98,108,101,0],"i8",x);cs=y([64,115,121,110,116,104,101,115,105,122,101,0],"i8",x);ds=y([102,105,101,108,100,115,0],"i8",x);es=y([100,108,108,95,101,120,112,111,114,116,0],"i8",x);fs=y([123,97,114,99,104,125,0],"i8",x);gs=y([105,103,110,111,114,105,110,103,32,37,115,32,40,117,110,107,110,111,119,110,32,108,97,110,103,117,97,103,101,41,10,0],"i8",x);hs=y([110,109,0],"i8",x);is=y([118,114,104,0],"i8",x);js=y([99,111,110,102,105,103,117,114,97,116,105,111,110,0],"i8",x);ks=y([116,114,105,49,0],"i8",x);ls=y([94,91,32,9,93,42,60,91,32,9,93,42,112,114,111,106,101,99,116,91,94,62,93,43,110,97,109,101,61,34,40,91,94,34,93,43,41,34,46,42,0],"i8",x);ms=y([117,114,39,0],"i8",x);ns=y([106,44,106,115,102,117,110,99,116,105,111,110,44,106,97,118,97,115,99,114,105,112,116,32,102,117,110,99,116,105,111,110,115,0],"i8",x);os=y([111,118,101,114,0],"i8",x);ps=y([115,105,103,0],"i8",x);qs=y([64,112,114,111,116,101,99,116,101,100,0],"i8",x);rs=y([83,76,97,110,103,0],"i8",x);ss=y([83,72,0],"i8",x);ts=y([99,115,115,0],"i8",x);us=y([83,77,0],"i8",x);vs=y([66,69,84,65,0],"i8",x);ws=y([100,105,109,101,110,115,105,111,110,0],"i8",x);xs=y([32,32,73,110,115,116,97,108,108,105,110,103,32,100,101,102,97,117,108,116,32,101,120,99,108,117,100,101,32,112,97,116,116,101,114,110,115,58,10,0],"i8",x);ys=y([109,97,112,0],"i8",x);zs=y([118,114,105,0],"i8",x);As=y([99,111,109,112,111,110,101,110,116,0],"i8",x);Bs=y([116,114,105,48,0],"i8",x);Cs=y([105,110,99,108,117,100,101,115,0],"i8",x);Ds=y([99,97,108,108,0],"i8",x);Es=y([98,34,0],"i8",x);Fs=y([40,94,124,91,32,9,93,41,40,91,65,45,90,97,45,122,48,45,57,95,93,43,41,91,32,9,93,42,91,61,58,93,91,32,9,93,42,102,117,110,99,116,105,111,110,91,32,9,93,42,92,40,0],"i8",x);Gs=y([103,108,111,98,97,108,0],"i8",x);Hs=y([114,117,98,121,0],"i8",x);Is=y([104,101,97,100,52,0],"i8",x);Js=y([114,101,120,120,0],"i8",x);Ks=y([85,110,107,110,111,119,110,32,102,105,108,101,32,101,120,116,101,110,115,105,111,110,58,32,37,115,10,0],"i8",x);Ls=y([64,112,117,98,108,105,99,0],"i8",x);Ms=y([102,105,110,97,108,108,121,0],"i8",x);Ns=y([114,98,0],"i8",x);Os=y([100,97,116,97,0],"i8",x);Ps=y([115,44,115,101,99,116,105,111,110,44,115,101,99,116,105,111,110,115,0],"i8",x);Qs=y([112,121,120,0],"i8",x);Rs=y([58,61,0],"i8",x);Ss=y([32,32,73,110,115,116,97,108,108,105,110,103,32,100,101,102,97,117,108,116,32,108,97,110,103,117,97,103,101,32,109,97,112,112,105,110,103,115,58,10,0],"i8",x);Ts=y([60,115,112,101,99,105,97,108,62,0],"i8",x);Us=y([118,114,0],"i8",x);Vs=y([99,97,115,101,0],"i8",x);Ws=y([116,105,109,101,0],"i8",x);Xs=y([115,117,98,112,97,114,97,103,114,97,112,104,115,0],"i8",x);Ys=y([119,101,97,107,0],"i8",x);Zs=y([100,111,0],"i8",x);$s=y([65,83,77,0],"i8",x);at=y([101,120,99,101,112,116,105,111,110,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);bt=y([112,104,112,51,0],"i8",x);ct=y([98,39,0],"i8",x);dt=y([94,91,32,9,93,42,40,40,118,97,114,124,112,117,98,108,105,99,124,112,114,111,116,101,99,116,101,100,124,112,114,105,118,97,116,101,124,115,116,97,116,105,99,41,91,32,9,93,43,41,43,92,36,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,91,32,9,93,42,91,61,59,93,0],"i8",x);et=y([110,101,119,108,105,115,116,0],"i8",x);ft=y([104,101,97,100,51,0],"i8",x);gt=y([109,97,116,99,104,0],"i8",x);ht=y([64,112,97,99,107,97,103,101,0],"i8",x);it=y([99,98,108,0],"i8",x);jt=y([112,109,0],"i8",x);kt=y([99,97,116,99,104,0],"i8",x);lt=y([101,120,116,101,114,110,97,108,32,97,110,100,32,102,111,114,119,97,114,100,32,118,97,114,105,97,98,108,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);mt=y([112,97,115,0],"i8",x);nt=y([117,110,105,111,110,32,110,97,109,101,115,0],"i8",x);ot=y([99,111,110,116,97,105,110,115,0],"i8",x);pt=y([46,46,46,0],"i8",x);qt=y([37,115,58,32,99,111,110,102,117,115,105,110,103,32,97,114,103,117,109,101,110,116,32,100,101,99,108,97,114,97,116,105,111,110,115,32,98,101,103,105,110,110,105,110,103,32,97,116,32,108,105,110,101,32,37,108,117,10,0],"i8",x);rt=y([94,91,32,9,93,42,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,91,32,9,93,43,83,69,67,84,73,79,78,92,46,0],"i8",x);st=y([83,101,116,116,105,110,103,32,111,112,116,105,111,110,32,100,101,102,97,117,108,116,115,10,0],"i8",x);tt=y([60,101,120,112,114,62,0],"i8",x);ut=y([74,97,118,97,0],"i8",x);vt=y([98,117,115,0],"i8",x);wt=y([116,97,115,107,0],"i8",x);xt=y([112,97,114,97,103,114,97,112,104,115,0],"i8",x);yt=y([114,101,103,101,120,0],"i8",x);zt=y([123,59,44,61,0],"i8",x);At=y([44,59,0],"i8",x);Bt=y([118,97,108,0],"i8",x);Ct=y([60,62,0],"i8",x);Dt=y([114,34,0],"i8",x);Et=y([118,44,118,97,114,105,97,98,108,101,44,118,97,114,105,97,98,108,101,115,0],"i8",x);Ft=y([59,0],"i8",x);Gt=y([104,101,97,100,50,0],"i8",x);Ht=y([37,115,58,32,37,115,0],"i8",x);It=y([40,59,0],"i8",x);Jt=y([109,108,105,0],"i8",x);Kt=y([64,112,114,105,118,97,116,101,0],"i8",x);Lt=y([43,45,42,47,37,94,38,124,126,33,61,60,62,44,91,93,0],"i8",x);Mt=y([40,41,0],"i8",x);Nt=y([99,111,109,112,108,101,120,0],"i8",x);Ot=y([112,117,114,101,32,118,105,114,116,117,97,108,0],"i8",x);Pt=y([98,105,0],"i8",x);Qt=y([100,101,116,97,99,104,97,98,108,101,0],"i8",x);Rt=y([80,44,112,114,111,103,114,97,109,44,112,114,111,103,114,97,109,32,105,100,115,0],"i8",x);St=y([37,115,58,37,108,100,58,32,110,117,108,108,32,101,120,112,97,110,115,105,111,110,32,111,102,32,110,97,109,101,32,112,97,116,116,101,114,110,32,34,37,115,34,0],"i8",x);Tt=y([116,121,112,101,115,0],"i8",x);Ut=y([60,117,110,105,113,117,101,62,0],"i8",x);Vt=y([98,117,102,102,101,114,0],"i8",x);Wt=y([106,97,118,97,0],"i8",x);Xt=y([115,117,112,112,108,121,49,0],"i8",x);Yt=y([112,97,114,116,115,0],"i8",x);Zt=y([71,78,85,109,97,107,101,102,105,108,101,0],"i8",x);$t=y([76,117,97,0],"i8",x);au=y([95,95,97,110,111,110,37,100,0],"i8",x);bu=y([114,39,0],"i8",x);cu=y([99,108,105,115,112,0],"i8",x);du=y([92,50,0],"i8",x);eu=y([104,101,97,100,49,0],"i8",x);fu=y([123,125,0],"i8",x);gu=y([103,97,119,107,0],"i8",x);hu=y([64,99,108,97,115,115,0],"i8",x);iu=y([37,115,58,32,117,110,101,120,112,101,99,116,101,100,32,99,108,111,115,105,110,103,32,98,114,97,99,101,32,97,116,32,108,105,110,101,32,37,108,117,10,0],"i8",x);ju=y([115,119,105,116,99,104,0],"i8",x);ku=y([37,115,58,32,114,101,116,114,121,105,110,103,32,102,105,108,101,32,119,105,116,104,32,102,97,108,108,98,97,99,107,32,98,114,97,99,101,32,109,97,116,99,104,105,110,103,32,97,108,103,111,114,105,116,104,109,10,0],"i8",x);lu=y([115,116,114,117,99,116,117,114,101,32,110,97,109,101,115,0],"i8",x);mu=y([99,111,109,109,111,110,0],"i8",x);nu=y([74,97,118,97,83,99,114,105,112,116,0],"i8",x);ou=y([100,101,102,101,114,114,101,100,0],"i8",x);pu=y([94,91,32,9,93,42,80,82,79,71,82,65,77,45,73,68,92,46,91,32,9,93,43,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,92,46,0],"i8",x);y([114,101,103,99,111,109,112,32,37,115,58,32,37,115,0],"i8",x);qu=y([78,79,78,69,0],"i8",x);ru=y([104,116,109,108,0],"i8",x);su=y([60,115,99,114,105,112,116,62,0],"i8",x);tu=y([98,111,100,121,0],"i8",x);uu=y([67,35,0],"i8",x);vu=y([115,117,112,112,108,121,48,0],"i8",x);wu=y([115,117,98,115,117,98,115,101,99,116,105,111,110,115,0],"i8",x);xu=y([112,114,111,99,101,100,117,114,101,115,0],"i8",x);yu=y([110,97,109,101,115,112,97,99,101,115,0],"i8",x);zu=y([101,113,117,0],"i8",x);Au=y([115,116,114,117,99,116,117,114,101,0],"i8",x);Bu=y([99,111,110,116,101,120,116,0],"i8",x);Cu=y([71,111,0],"i8",x);Du=y([117,34,0],"i8",x);Eu=y([94,91,32,9,93,42,40,92,36,124,58,58,92,36,124,92,36,116,104,105,115,45,62,41,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,91,32,9,93,42,61,0],"i8",x);Fu=y([83,84,68,79,85,84,0],"i8",x);Gu=y([112,117,98,108,105,99,32,102,117,110,99,116,105,111,110,0],"i8",x);Hu=y([64,100,101,102,115,0],"i8",x);Iu=y([109,97,99,114,111,115,0],"i8",x);Ju=y([105,110,116,101,114,102,97,99,101,115,0],"i8",x);Ku=y([101,110,117,109,32,116,121,112,101,115,0],"i8",x);Lu=y([117,110,107,110,111,119,110,0],"i8",x);Mu=y([99,104,97,114,97,99,116,101,114,0],"i8",x);Nu=y([100,101,98,117,103,0],"i8",x);Ou=y([101,110,117,109,32,99,111,110,115,116,97,110,116,115,0],"i8",x);Pu=y([112,44,112,97,114,97,103,114,97,112,104,44,112,97,114,97,103,114,97,112,104,115,0],"i8",x);Qu=y([117,110,107,110,111,119,110,32,114,101,103,101,120,32,102,108,97,103,58,32,39,37,99,39,0],"i8",x);Ru=y([60,115,105,108,101,110,116,62,0],"i8",x);Su=y([98,108,111,99,107,0],"i8",x);Tu=y([99,115,0],"i8",x);Uu=y([115,112,101,99,112,97,114,97,109,0],"i8",x);Vu=y([115,117,98,115,101,99,116,105,111,110,115,0],"i8",x);Wu=y([101,110,117,109,32,99,111,110,115,116,97,110,116,0],"i8",x);Xu=y([101,120,116,101,114,110,97,108,32,118,97,114,105,97,98,108,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Yu=y([101,110,100,115,0],"i8",x);Zu=y([115,105,103,110,97,116,117,114,101,0],"i8",x);$u=y([101,120,116,101,114,110,118,97,114,0],"i8",x);av=y([100,101,115,99,114,105,98,101,0],"i8",x);bv=y([117,39,0],"i8",x);cv=y([112,114,105,118,97,116,101,32,102,117,110,99,116,105,111,110,0],"i8",x);dv=y([97,115,97,0],"i8",x);ev=y([64,101,110,100,0],"i8",x);fv=y([116,121,112,101,100,101,102,115,0],"i8",x);gv=y([118,105,109,0],"i8",x);hv=y([102,117,110,99,116,105,111,110,32,112,114,111,116,111,116,121,112,101,115,0],"i8",x);iv=y([99,103,108,111,98,97,108,0],"i8",x);jv=y([114,101,99,111,114,100,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);kv=y([99,117,114,114,101,110,116,0],"i8",x);lv=y([109,120,109,108,0],"i8",x);mv=y([94,91,32,9,93,42,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,92,46,0],"i8",x);nv=y([60,98,117,102,102,101,114,62,0],"i8",x);ov=y([98,101,103,105,110,0],"i8",x);pv=y([67,43,43,0],"i8",x);qv=y([114,101,103,0],"i8",x);rv=y([115,101,99,116,105,111,110,115,0],"i8",x);sv=y([109,101,116,104,111,100,115,0],"i8",x);tv=y([112,97,116,116,101,114,110,115,32,40,118,105,114,116,117,97,108,32,111,114,32,114,101,98,111,117,110,100,41,0],"i8",x);uv=y([99,108,97,115,115,44,32,115,116,114,117,99,116,44,32,97,110,100,32,117,110,105,111,110,32,109,101,109,98,101,114,115,0],"i8",x);vv=y([102,116,100,0],"i8",x);wv=y([101,110,100,112,0],"i8",x);xv=y([102,117,110,0],"i8",x);yv=y([69,82,76,0],"i8",x);zv=y([94,91,32,9,93,42,40,40,115,116,97,116,105,99,124,112,117,98,108,105,99,124,112,114,111,116,101,99,116,101,100,124,112,114,105,118,97,116,101,41,91,32,9,93,43,41,42,102,117,110,99,116,105,111,110,91,32,9,93,43,38,63,91,32,9,93,42,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,0],"i8",x);Av=y([101,110,117,109,101,114,97,116,105,111,110,32,110,97,109,101,115,0],"i8",x);Bv=y([58,58,0],"i8",x);Cv=y([112,117,98,108,105,99,32,115,117,98,0],"i8",x);Dv=y([64,115,101,108,101,99,116,111,114,0],"i8",x);Ev=y([37,115,58,32,102,97,105,108,101,100,32,116,111,32,102,105,110,100,32,109,97,116,99,104,32,102,111,114,32,39,37,99,39,32,97,116,32,108,105,110,101,32,37,108,117,10,0],"i8",x);Fv=y([101,110,117,109,101,114,97,116,111,114,115,32,40,118,97,108,117,101,115,32,105,110,115,105,100,101,32,97,110,32,101,110,117,109,101,114,97,116,105,111,110,41,0],"i8",x);Gv=y([101,110,117,109,101,114,97,116,111,114,0],"i8",x);Hv=y([99,101,120,116,101,114,110,97,108,0],"i8",x);Iv=y([99,114,101,97,116,105,111,110,0],"i8",x);Jv=y([105,100,101,110,116,105,116,105,101,115,0],"i8",x);Kv=y([103,44,103,114,111,117,112,44,103,114,111,117,112,32,105,116,101,109,115,0],"i8",x);Lv=y([118,104,100,108,0],"i8",x);Mv=y([69,105,102,102,101,108,0],"i8",x);Nv=y([60,76,101,97,100,101,114,62,0],"i8",x);Ov=y([97,116,116,114,105,98,117,116,101,0],"i8",x);Pv=y([114,101,97,108,116,105,109,101,0],"i8",x);Qv=y([99,104,97,112,116,101,114,115,0],"i8",x);Rv=y([99,108,97,115,115,101,115,0],"i8",x);Sv=y([101,108,115,101,105,102,0],"i8",x);Tv=y([119,99,104,97,114,95,116,0],"i8",x);Uv=y([102,117,110,99,116,111,114,0],"i8",x);Vv=y([67,83,83,0],"i8",x);Wv=y([114,0],"i8",x);Xv=y([99,97,110,110,111,116,32,111,112,101,110,32,34,37,115,34,0],"i8",x);Yv=y([105,109,112,111,114,116,0],"i8",x);Zv=y([109,97,99,114,111,0],"i8",x);$v=y([100,44,100,101,102,105,110,101,44,99,111,110,115,116,97,110,116,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);aw=y([118,111,105,100,0],"i8",x);bw=y([99,111,98,0],"i8",x);cw=y([37,115,37,115,0],"i8",x);dw=y([112,114,105,118,97,116,101,32,115,117,98,0],"i8",x);ew=y([118,0],"i8",x);fw=y([87,97,114,110,105,110,103,58,32,0],"i8",x);gw=y([64,115,121,110,99,104,114,111,110,105,122,101,100,0],"i8",x);hw=y([46,45,95,0],"i8",x);iw=y([117,115,105,110,103,0],"i8",x);jw=y([117,115,104,111,114,116,0],"i8",x);kw=y([99,104,97,110,0],"i8",x);lw=y([37,115,40,37,115,41,0],"i8",x);mw=y([89,65,67,67,0],"i8",x);nw=y([117,110,115,105,103,110,101,100,0],"i8",x);ow=y([116,101,120,0],"i8",x);pw=y([98,121,116,101,0],"i8",x);qw=y([86,105,109,0],"i8",x);rw=y([116,99,108,0],"i8",x);sw=y([118,104,100,0],"i8",x);tw=y([117,108,111,110,103,0],"i8",x);uw=y([94,91,32,9,93,42,91,48,45,57,93,43,91,32,9,93,43,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,92,46,0],"i8",x);vw=y([86,101,114,105,108,111,103,0],"i8",x);ww=y([84,101,120,0],"i8",x);xw=y([60,83,73,68,62,0],"i8",x);yw=y([116,107,0],"i8",x);zw=y([97,115,115,101,114,116,0],"i8",x);Aw=y([114,101,97,108,0],"i8",x);Bw=y([109,101,116,104,111,100,0],"i8",x);Cw=y([108,111,99,97,108,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);Dw=y([115,108,111,116,115,32,40,102,114,97,103,109,101,110,116,32,117,115,101,115,41,0],"i8",x);Ew=y([117,105,110,116,0],"i8",x);Fw=y([67,0],"i8",x);Gw=y([108,111,99,97,108,0],"i8",x);Hw=y([83,81,76,0],"i8",x);Iw=y([116,121,112,101,110,97,109,101,0],"i8",x);Jw=y([101,110,100,109,0],"i8",x);Kw=y([115,101,116,115,0],"i8",x);Lw=y([112,97,99,107,97,103,101,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);Mw=y([99,112,100,101,102,32,0],"i8",x);Nw=y([112,114,111,99,101,100,117,114,101,32,112,114,111,116,111,116,121,112,101,115,32,97,110,100,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Ow=y([94,91,32,9,93,42,100,101,102,105,110,101,91,32,9,93,42,92,40,91,32,9,93,42,91,39,34,93,63,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,0],"i8",x);Pw=y([116,114,97,110,115,105,101,110,116,0],"i8",x);Qw=y([102,117,110,99,116,105,111,110,32,112,114,111,116,111,116,121,112,101,115,32,97,110,100,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Rw=y([99,0],"i8",x);Sw=y([64,112,114,111,112,101,114,116,121,0],"i8",x);Tw=y([112,114,111,116,111,116,121,112,101,115,0],"i8",x);Uw=y([58,63,43,0],"i8",x);Vw=y([116,114,97,110,115,105,116,105,111,110,0],"i8",x);Ww=y([112,114,111,116,111,116,121,112,101,0],"i8",x);Xw=y([116,114,97,110,115,0],"i8",x);Yw=y([99,111,109,112,111,110,101,110,116,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Zw=y([77,111,98,105,76,105,110,107,32,80,114,111,112,101,114,116,105,101,115,32,0],"i8",x);$w=y([116,104,114,111,119,115,0],"i8",x);ax=y([101,110,116,105,116,121,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);bx=y([109,108,112,114,111,112,0],"i8",x);cx=y([116,104,114,111,119,0],"i8",x);dx=y([99,111,110,118,101,114,116,0],"i8",x);ex=y([114,101,99,111,114,100,32,110,97,109,101,115,0],"i8",x);fx=y([77,111,98,105,76,105,110,107,32,67,111,110,110,32,83,99,114,105,112,116,115,0],"i8",x);gx=y([115,101,108,101,99,116,111,114,115,0],"i8",x);hx=y([102,44,102,105,108,101,44,102,105,108,101,32,100,101,115,99,114,105,112,116,105,111,110,115,32,40,70,68,44,32,83,68,44,32,82,68,41,0],"i8",x);ix=y([37,115,32,112,97,114,115,101,114,32,100,101,102,105,110,105,116,105,111,110,32,109,117,115,116,32,100,101,102,105,110,101,32,111,110,101,32,97,110,100,32,111,110,108,121,32,111,110,101,32,112,97,114,115,105,110,103,32,114,111,117,116,105,110,101,10,0],"i8",x);jx=y([101,110,100,102,0],"i8",x);kx=y([97,114,114,97,121,0],"i8",x);lx=y([112,97,114,97,109,101,116,101,114,0],"i8",x);mx=y([104,112,0],"i8",x);nx=y([112,114,105,118,97,116,101,0],"i8",x);ox=y([115,117,98,116,121,112,101,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);px=y([109,108,99,111,110,110,0],"i8",x);qx=y([115,108,111,116,0],"i8",x);rx=y([116,101,109,112,108,97,116,101,0],"i8",x);sx=y([112,114,111,103,114,97,109,32,40,103,108,111,98,97,108,41,32,97,110,100,32,109,111,100,117,108,101,32,118,97,114,105,97,98,108,101,115,0],"i8",x);tx=y([116,121,112,101,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);ux=y([77,111,98,105,76,105,110,107,32,84,97,98,108,101,32,83,99,114,105,112,116,115,0],"i8",x);vx=y([101,110,100,109,97,99,114,111,0],"i8",x);wx=y([65,110,116,0],"i8",x);xx=y([98,117,105,108,100,46,120,109,108,0],"i8",x);D=y(468,"i8",x);yx=y(8,"i8",x);zx=y(8,"i8",x);Ax=y([1,0,0,0,97,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Bx=y(12,"i8",x);Cx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,84,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);E=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,35,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,61,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,63,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,65,0,0,0,0,0,0,0,66,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0,68,0,0,0,0,0,0,0,69,0,0,0,0,0,0,0,70,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,73,0,0,0,0,0,0,0,74,0,0,0,0,0,0,0,75,0,0,0,0,0,0,0,76,0,0,0,0,0,0,0,77,0,0,0,0,0,0,0,78,0,0,0,0,0,0,0,79,0,0,0,0,0,0,0,80,0,0,0,0,0,0,0,81,0,0,0,0,0,0,0,82,0,0,0,0,0,0,0,83,0,0,0,0,0,0,0,84,0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,86,0,0,0,0,0,0,0,87,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,89,0,0,0,0,0,0,0,90,0,0,0,0,0,0,0,91,0,0,0,0,0,0,0,92,0,0,0,0,0,0,0,93,0,0,0,0,0,0,0,94,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Dx=y(8,"i8",x);Ex=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Fx=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Gx=y(16,"i8",x);Hx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,84,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Ix=y(4,"i8",x);Jx=y(4,"i8",x);Kx=y(8,"i8",x);Lx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,117,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,98,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,71,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Mx=y(20,"i8",x);Nx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Ox=y(4,"i8",x);Px=y(8,"i8",x);Qx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,76,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,84,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,82,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,68,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,86,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,121,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,122,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);F=y([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,35,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,61,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,63,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,65,0,0,0,0,0,0,0,66,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0,68,0,0,0,0,0,0,0,69,0,0,0,0,0,0,0,70,0,0,0,0,0,0,0,71,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Rx=y(12,"i8",x);Sx=y([1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Tx=y([0,0,0,0,5,0,0,0,0,0,0,0,-2,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Ux=y(8,"i8",x);Vx=y(4,"i8",x);Wx=y(28,"i8",x);Xx=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Yx=y(4,"i8",x);Zx=y([-1],["i32",0,0,0],x);$x=y(28,"i8",x);ay=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);by=y(12,"i8",x);cy=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,70,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,67,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);dy=y(16,"i8",x);ey=y(24,"i8",x);fy=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);gy=y(16,"i8",x);hy=y(20,"i8",x);iy=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);jy=y(12,"i8",x);ky=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);ly=y(4,"i8",x);my=y(4,"i8",x);ny=y(4,"i8",x);oy=y([0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0],x);py=y([0,0,0,0,-1,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,-1,0,0,0,3,0,0,0,-1,0,0,0,4,0,0,0,-1,0,0,0,5,0,0,0,-1,0,0,0,6,0,0,0,-1,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,1,0,0,0,10,0,0,0,2,0,0,0,11,0,0,0,1,0,0,0,12,0,0,0,3,0,0,0,13,0,0,0,-1,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,3,0,0,0],["i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0],x);qy=y(12,"i8",x);ry=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,77,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,67,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);sy=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,41,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);ty=y(12,"i8",x);uy=y([1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,73,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,70,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,77,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);vy=y(12,"i8",x);wy=y(12,"i8",x);xy=y([1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);yy=y(8,"i8",x);zy=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Ay=y(28,"i8",x);By=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Cy=y(4,"i8",x);Dy=y(4,"i8",x);Ey=y(4,"i8",x);Fy=y(4,"i8",x);Gy=y(4,"i8",x);Hy=y(4,"i8",x);Iy=y(4,"i8",x);Jy=y(4,"i8",x);Ky=y(4,"i8",x);Ly=y(4,"i8",x);My=y(4,"i8",x);Ny=y(4,"i8",x);Oy=y(4,"i8",x);Py=y(4,"i8",x);Qy=y(4,"i8",x);Ry=y(4,"i8",x);Sy=y(4,"i8",x);Ty=y(4,"i8",x);Uy=y(4,"i8",x);H=y([0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,9,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,13,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,20,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,17,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,22,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,23,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,24,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,25,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,29,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,30,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,34,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,35,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,38,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,39,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,46,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,51,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,53,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,56,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,58,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,61,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,63,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,65,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,66,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,67,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,68,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,69,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,71,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,72,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,70,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,73,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,74,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,75,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,76,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,77,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,78,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,79,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,80,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,81,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,82,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,84,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,83,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,86,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,87,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,88,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,89,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,90,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,91,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,92,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,93,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,94,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,95,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,96,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,97,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,98,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,99,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0],["*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8"],x);Vy=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Wy=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Xy=y(8,"i8",x);Yy=y(8,"i8",x);Zy=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);$y=y(12,"i8",x);az=y(36,"i8",x);bz=y(4,"i8",x);cz=y(8,"i8",x);dz=y([1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);ez=y(4,"i8",x);fz=y(4,"i8",x);gz=y(4,"i8",x);hz=y(28,"i8",x);iz=y([1,0,0,0,98,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,107,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);J=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,35,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,61,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,63,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,65,0,0,0,0,0,0,0,66,0,0,0,0,0,0,0,67,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);jz=y(12,"i8",x);kz=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);lz=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);K=y(60,"i8",x);mz=y(12,"i8",x);nz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);oz=y(4,"i8",x);pz=y(40,"i8",x);qz=y(40,"i8",x);rz=y(40,"i8",x);sz=y(40,"i8",x);tz=y(40,"i8",x);uz=y(40,"i8",x);vz=y(40,"i8",x);wz=y(40,"i8",x);xz=y(40,"i8",x);yz=y(40,"i8",x);zz=y(20,"i8",x);Az=y([1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Bz=y(8,"i8",x);Cz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Dz=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,35,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,60,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Ez=y(12,"i8",x);Fz=y(4,"i8",x);Gz=y(8,"i8",x);Hz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Iz=y(8,"i8",x);Jz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,69,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Kz=y(48,"i8",x);Lz=y(352,"i8",x);Mz=y(4,"i8",x);Nz=y(4,"i8",x);Oz=y(4,"i8",x);Pz=y(20,"i8",x);Qz=y(4,"i8",x);Rz=y(4,"i8",x);Sz=y(8,"i8",x);Tz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,117,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Uz=y([240,0,0,0,242,0,0,0,258,0,0,0,178,0,0,0,302,0,0,0,98,0,0,0,196,0,0,0,184,0,0,0,290,0,0,0,42,0,0,0,76,0,0,0,214,0,0,0,112,0,0,0,28,0,0,0,72,0,0,0,264,0,0,0,40,0,0,0,136,0,0,0,32,0,0,0,80,0,0,0,34,0,0,0,106,0,0,0,90,0,0,0,200,0,0,0,138,0,0,0,292,0,0,0,58,0,0,0,56,0,0,0,6,0,0,0,146,0,0,0,218,0,0,0,252,0,0,0,52,0,0,0,30,0,0,0,222,0,0,0,96,0,0,0,262,0,0,0,54,0,0,0,182,0,0,0,152,0,0,0,220,0,0,0,226,0,0,0,206,0,0,0,244,0,0,0],["*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0],x);Vz=y(4,"i8",x);Wz=y(8,"i8",x);Xz=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Yz=y(20,"i8",x);Zz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);$z=y(16,"i8",x);aA=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);bA=y(12,"i8",x);cA=y([1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);dA=y(20,"i8",x);eA=y(20,"i8",x);fA=y([1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);gA=y([0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);hA=y(8,"i8",x);iA=y(4,"i8",x);jA=y(4,"i8",x);kA=y(4,"i8",x);lA=y(4,"i8",x);t[dc>>2]=et|0;t[dc+12>>2]=Gs|0;t[dc+24>>2]=xg|0;t[dc+36>>2]=ci|0;t[dc+48>>2]=cq|0;t[dc+60>>2]=Au|0;t[hc>>2]=Fq|0;t[hc+4>>2]=rq|0;t[hc+8>>2]=Zp|0;t[hc+12>>2]=Ip|0;t[hc+16>>2]=rp|0;t[hc+20>>2]=dp|0;t[hc+24>>2]=Uo|0;t[hc+28>>2]=wo|0;t[hc+32>>2]=dh|0;t[hc+36>>2]=co|0;t[hc+40>>2]=Un|0;t[hc+44>>2]=Bg|0;t[hc+48>>2]=un|0;t[hc+52>>2]=jn|0;t[hc+56>>2]=Xm|0;t[hc+60>>2]=Km|0;t[hc+64>>2]=Bm|0;t[hc+68>>2]=gm|0;t[hc+72>>2]=Wl|0;t[hc+76>>2]=Ll|0;t[hc+80>>2]=Dl|0;t[hc+84>>2]=vl|0;t[hc+88>>2]=jl|0;t[hc+92>>2]=$k|0;t[hc+96>>2]=Nk|0;t[hc+100>>2]=Ck|0;t[hc+104>>2]=tk|0;t[hc+108>>2]=bk|0;t[sc>>2]=yn|0;t[sc+8>>2]=uq|0;t[sc+16>>2]=wj|0;t[sc+24>>2]=Uh|0;t[sc+32>>2]=zg|0;t[sc+40>>2]=uf|0;t[sc+48>>2]=Zd|0;t[sc+56>>2]=Sw|0;t[sc+64>>2]=gw|0;t[sc+72>>2]=Dv|0;t[sc+80>>2]=ev|0;t[sc+88>>2]=Hu|0;t[sc+96>>2]=hu|0;t[sc+104>>2]=Kt|0;t[sc+112>>2]=ht|0;t[sc+120>>2]=Ls|0;t[sc+128>>2]=qs|0;t[sc+136>>2]=cs|0;t[sc+144>>2]=Dr|0;t[sc+152>>2]=jr|0;t[sc+160>>2]=Tq|0;t[Cc>>2]=134;t[Cc+4>>2]=204;t[Fc>>2]=eu|0;t[Fc+4>>2]=Gt|0;t[Fc+8>>2]=ft|0;t[Fc+12>>2]=Is|0;t[Fc+16>>2]=os|0;t[Fc+20>>2]=$r|0;t[Fc+24>>2]=Br|0;t[Fc+28>>2]=ir|0;t[Fc+32>>2]=ov|0;t[Fc+36>>2]=Sf|0;t[Fc+40>>2]=bp|0;t[Ic>>2]=hh|0;t[Ic+4>>2]=Zq|0;t[Ic+8>>2]=Bo|0;t[Ic+12>>2]=Ot|0;t[Xc>>2]=El|0;t[Xc+12>>2]=Rh|0;t[Xc+24>>2]=xg|0;t[Xc+36>>2]=mu|0;t[Xc+48>>2]=Cf|0;t[Xc+60>>2]=nf|0;t[Xc+72>>2]=dw|0;t[Xc+84>>2]=Cv|0;t[Xc+96>>2]=cv|0;t[Xc+108>>2]=Gu|0;t[Xc+120>>2]=wf|0;t[Xc+132>>2]=wj|0;t[sd>>2]=El|0;t[sd+12>>2]=Gs|0;t[sd+24>>2]=xg|0;t[sd+36>>2]=Cf|0;t[sd+48>>2]=wf|0;t[td>>2]=hh|0;t[td+4>>2]=Gw|0;t[td+8>>2]=nx|0;t[td+12>>2]=Ve|0;t[td+16>>2]=Yf|0;t[td+20>>2]=Vf|0;t[yx>>2]=kr|0;t[zx>>2]=gv|0;t[Ax+8>>2]=cg|0;t[Ax+12>>2]=Xf|0;t[Ax+24>>2]=Lf|0;t[Ax+28>>2]=Hf|0;t[Ax+40>>2]=Cf|0;t[Ax+44>>2]=yf|0;t[Ax+56>>2]=ys|0;t[Ax+60>>2]=vf|0;t[Ax+72>>2]=qf|0;t[Ax+76>>2]=kf|0;t[Bx>>2]=Lv|0;t[Bx+4>>2]=sw|0;t[Cx+8>>2]=Rr|0;t[Cx+12>>2]=Bd|0;t[Cx+24>>2]=wf|0;t[Cx+28>>2]=tx|0;t[Cx+40>>2]=Mf|0;t[Cx+44>>2]=ox|0;t[Cx+56>>2]=Hh|0;t[Cx+60>>2]=ex|0;t[Cx+72>>2]=Up|0;t[Cx+76>>2]=ax|0;t[Cx+88>>2]=As|0;t[Cx+92>>2]=Yw|0;t[Cx+104>>2]=Ww|0;t[Cx+108>>2]=Tw|0;t[Cx+120>>2]=Cf|0;t[Cx+124>>2]=Qw|0;t[Cx+136>>2]=ci|0;t[Cx+140>>2]=Nw|0;t[Cx+152>>2]=Gi|0;t[Cx+156>>2]=Lw|0;t[Cx+168>>2]=Gw|0;t[Cx+172>>2]=Cw|0;t[E>>2]=Io|0;t[E+8>>2]=qm|0;t[E+16>>2]=kk|0;t[E+24>>2]=Ai|0;t[E+32>>2]=Uq|0;t[E+40>>2]=Tf|0;t[E+48>>2]=Se|0;t[E+56>>2]=kx|0;t[E+64>>2]=zw|0;t[E+72>>2]=Ov|0;t[E+80>>2]=ov|0;t[E+88>>2]=Su|0;t[E+96>>2]=tu|0;t[E+104>>2]=Vt|0;t[E+112>>2]=vt|0;t[E+120>>2]=Vs|0;t[E+128>>2]=As|0;t[E+136>>2]=js|0;t[E+144>>2]=Rr|0;t[E+152>>2]=pr|0;t[E+160>>2]=$q|0;t[E+168>>2]=ti|0;t[E+176>>2]=Aq|0;t[E+184>>2]=Sf|0;t[E+192>>2]=Up|0;t[E+200>>2]=Ep|0;t[E+208>>2]=Ne|0;t[E+216>>2]=bp|0;t[E+224>>2]=Cf|0;t[E+232>>2]=to|0;t[E+240>>2]=ko|0;t[E+248>>2]=ao|0;t[E+256>>2]=Qn|0;t[E+264>>2]=im|0;t[E+272>>2]=qn|0;t[E+280>>2]=en|0;t[E+288>>2]=Um|0;t[E+296>>2]=Hm|0;t[E+304>>2]=vm|0;t[E+312>>2]=cm|0;t[E+320>>2]=Ul|0;t[E+328>>2]=Kl|0;t[E+336>>2]=Cl|0;t[E+344>>2]=sl|0;t[E+352>>2]=ys|0;t[E+360>>2]=Xk|0;t[E+368>>2]=Lk|0;t[E+376>>2]=yk|0;t[E+384>>2]=pk|0;t[E+392>>2]=Tm|0;t[E+400>>2]=Sj|0;t[E+408>>2]=Lj|0;t[E+416>>2]=Gj|0;t[E+424>>2]=hr|0;t[E+432>>2]=sj|0;t[E+440>>2]=gj|0;t[E+448>>2]=Zi|0;t[E+456>>2]=Ni|0;t[E+464>>2]=Gi|0;t[E+472>>2]=oi|0;t[E+480>>2]=hi|0;t[E+488>>2]=ci|0;t[E+496>>2]=$h|0;t[E+504>>2]=Wh|0;t[E+512>>2]=Ph|0;t[E+520>>2]=Hh|0;t[E+528>>2]=Bh|0;t[E+536>>2]=rh|0;t[E+544>>2]=lh|0;t[E+552>>2]=Zg|0;t[E+560>>2]=Ug|0;t[E+568>>2]=Pg|0;t[E+576>>2]=Kg|0;t[E+584>>2]=Dg|0;t[E+592>>2]=vg|0;t[E+600>>2]=pg|0;t[E+608>>2]=lg|0;t[E+616>>2]=dg|0;t[E+624>>2]=Zf|0;t[E+632>>2]=Mf|0;t[E+640>>2]=If|0;t[E+648>>2]=Df|0;t[E+656>>2]=zf|0;t[E+664>>2]=wf|0;t[E+672>>2]=rf|0;t[E+680>>2]=lf|0;t[E+688>>2]=df|0;t[E+696>>2]=Ze|0;t[E+704>>2]=qf|0;t[E+712>>2]=Je|0;t[E+720>>2]=Fe|0;t[E+728>>2]=ye|0;t[E+736>>2]=ve|0;t[E+744>>2]=ae|0;t[E+752>>2]=Vd|0;t[Dx>>2]=ew|0;t[Ex+8>>2]=Rr|0;t[Ex+12>>2]=uo|0;t[Ex+24>>2]=Jo|0;t[Ex+28>>2]=lo|0;t[Ex+40>>2]=Cf|0;t[Ex+44>>2]=bo|0;t[Ex+56>>2]=Uf|0;t[Ex+60>>2]=Rn|0;t[Ex+72>>2]=Bn|0;t[Ex+76>>2]=rn|0;t[Ex+88>>2]=oi|0;t[Ex+92>>2]=Vm|0;t[Ex+104>>2]=Bh|0;t[Ex+108>>2]=wm|0;t[Ex+120>>2]=wt|0;t[Ex+124>>2]=dm|0;t[Fx>>2]=Kr|0;t[Fx+8>>2]=Jo|0;t[Fx+16>>2]=Cf|0;t[Fx+24>>2]=Hm|0;t[Fx+32>>2]=Bi|0;t[Fx+40>>2]=gh|0;t[Fx+48>>2]=Uf|0;t[Fx+56>>2]=Te|0;t[Fx+64>>2]=lx|0;t[Fx+72>>2]=Aw|0;t[Fx+80>>2]=Pv|0;t[Fx+88>>2]=qv|0;t[Fx+96>>2]=Uu|0;t[Fx+104>>2]=vu|0;t[Fx+112>>2]=Xt|0;t[Fx+120>>2]=wt|0;t[Fx+128>>2]=Ws|0;t[Fx+136>>2]=Bs|0;t[Fx+144>>2]=ks|0;t[Fx+152>>2]=Sr|0;t[Fx+160>>2]=qr|0;t[Fx+168>>2]=ar|0;t[Fx+176>>2]=Nq|0;t[Fx+184>>2]=Bq|0;t[Fx+192>>2]=mq|0;t[Fx+200>>2]=Vp|0;t[Gx>>2]=Us|0;t[Gx+4>>2]=zs|0;t[Gx+8>>2]=is|0;t[Hx+8>>2]=Fi|0;t[Hx+12>>2]=Rv|0;t[Hx+24>>2]=Zv|0;t[Hx+28>>2]=Ie|0;t[Hx+40>>2]=Gv|0;t[Hx+44>>2]=Fv|0;t[Hx+56>>2]=Cf|0;t[Hx+60>>2]=yf|0;t[Hx+72>>2]=wj|0;t[Hx+76>>2]=Av|0;t[Hx+88>>2]=Gw|0;t[Hx+92>>2]=Nf|0;t[Hx+104>>2]=$p|0;t[Hx+108>>2]=uv|0;t[Hx+120>>2]=Xj|0;t[Hx+124>>2]=Yd|0;t[Hx+136>>2]=Ww|0;t[Hx+140>>2]=hv|0;t[Hx+152>>2]=wt|0;t[Hx+156>>2]=dm|0;t[Hx+168>>2]=yn|0;t[Hx+172>>2]=fv|0;t[Hx+184>>2]=qf|0;t[Hx+188>>2]=kf|0;t[Hx+200>>2]=$u|0;t[Hx+204>>2]=Xu|0;t[Kx>>2]=ow|0;t[Lx+8>>2]=Nr|0;t[Lx+12>>2]=Qv|0;t[Lx+24>>2]=Mo|0;t[Lx+28>>2]=rv|0;t[Lx+40>>2]=sm|0;t[Lx+44>>2]=Vu|0;t[Lx+56>>2]=mk|0;t[Lx+60>>2]=wu|0;t[Lx+72>>2]=Ci|0;t[Lx+76>>2]=Yt|0;t[Lx+88>>2]=ih|0;t[Lx+92>>2]=xt|0;t[Lx+104>>2]=Wf|0;t[Lx+108>>2]=Xs|0;t[Lx+120>>2]=Ue|0;t[Lx+124>>2]=Cs|0;t[Mx>>2]=rw|0;t[Mx+4>>2]=yw|0;t[Mx+8>>2]=Qr|0;t[Mx+12>>2]=Oo|0;t[Nx+8>>2]=Fi|0;t[Nx+12>>2]=Rv|0;t[Nx+24>>2]=Bw|0;t[Nx+28>>2]=sv|0;t[Nx+40>>2]=ci|0;t[Nx+44>>2]=xu|0;t[Px>>2]=ud|0;t[Qx+8>>2]=Ii|0;t[Qx+12>>2]=Eg|0;t[Qx+24>>2]=Ww|0;t[Qx+28>>2]=Tw|0;t[Qx+40>>2]=Cf|0;t[Qx+44>>2]=bo|0;t[Qx+56>>2]=eg|0;t[Qx+60>>2]=$f|0;t[Qx+72>>2]=Gw|0;t[Qx+76>>2]=Nf|0;t[Qx+88>>2]=cm|0;t[Qx+92>>2]=Ef|0;t[Qx+104>>2]=Gi|0;t[Qx+108>>2]=Af|0;t[Qx+120>>2]=ci|0;t[Qx+124>>2]=xu|0;t[Qx+136>>2]=Hh|0;t[Qx+140>>2]=sf|0;t[Qx+152>>2]=Mf|0;t[Qx+156>>2]=mf|0;t[Qx+168>>2]=cp|0;t[Qx+172>>2]=ef|0;t[Qx+184>>2]=Po|0;t[Qx+188>>2]=$e|0;t[Qx+200>>2]=qf|0;t[Qx+204>>2]=We|0;t[Qx+216>>2]=mo|0;t[Qx+220>>2]=Ke|0;t[Qx+232>>2]=Jo|0;t[Qx+236>>2]=lo|0;t[Qx+248>>2]=Sn|0;t[Qx+252>>2]=ze|0;t[Qx+264>>2]=Cn|0;t[Qx+268>>2]=we|0;t[Qx+280>>2]=sn|0;t[Qx+284>>2]=be|0;t[Qx+296>>2]=Ch|0;t[Qx+300>>2]=Wd|0;t[Qx+312>>2]=sh|0;t[Qx+316>>2]=Gd|0;t[Qx+328>>2]=Cd|0;t[Qx+332>>2]=ux|0;t[Qx+344>>2]=px|0;t[Qx+348>>2]=fx|0;t[Qx+360>>2]=bx|0;t[Qx+364>>2]=Zw|0;t[F>>2]=Ur|0;t[F+8>>2]=vm|0;t[F+16>>2]=ov|0;t[F+24>>2]=tu|0;t[F+32>>2]=Ii|0;t[F+40>>2]=nh|0;t[F+48>>2]=Sf|0;t[F+56>>2]=Cf|0;t[F+64>>2]=im|0;t[F+72>>2]=ti|0;t[F+80>>2]=Sv|0;t[F+88>>2]=ch|0;t[F+96>>2]=sl|0;t[F+104>>2]=ye|0;t[F+112>>2]=Vs|0;t[F+120>>2]=bp|0;t[F+128>>2]=Zs|0;t[F+136>>2]=Ds|0;t[F+144>>2]=Gi|0;t[F+152>>2]=Of|0;t[F+160>>2]=ci|0;t[F+168>>2]=Hh|0;t[F+176>>2]=Oq|0;t[F+184>>2]=Cq|0;t[F+192>>2]=nq|0;t[F+200>>2]=lh|0;t[F+208>>2]=Fp|0;t[F+216>>2]=Mf|0;t[F+224>>2]=cp|0;t[F+232>>2]=Po|0;t[F+240>>2]=wf|0;t[F+248>>2]=mo|0;t[F+256>>2]=Jo|0;t[F+264>>2]=Sn|0;t[F+272>>2]=Cn|0;t[F+280>>2]=sn|0;t[F+288>>2]=fn|0;t[F+296>>2]=Wm|0;t[F+304>>2]=Im|0;t[F+312>>2]=ym|0;t[F+320>>2]=em|0;t[F+328>>2]=Fe|0;t[F+336>>2]=If|0;t[F+344>>2]=qf|0;t[F+352>>2]=tl|0;t[F+360>>2]=hl|0;t[F+368>>2]=hr|0;t[F+376>>2]=Mk|0;t[F+384>>2]=zk|0;t[F+392>>2]=rk|0;t[F+400>>2]=$j|0;t[F+408>>2]=Tj|0;t[F+416>>2]=Mj|0;t[F+424>>2]=Hj|0;t[F+432>>2]=zj|0;t[F+440>>2]=tj|0;t[F+448>>2]=hj|0;t[F+456>>2]=$i|0;t[F+464>>2]=Oi|0;t[F+472>>2]=Hi|0;t[F+480>>2]=pi|0;t[F+488>>2]=ii|0;t[F+496>>2]=di|0;t[F+504>>2]=ai|0;t[F+512>>2]=Gw|0;t[F+520>>2]=Qh|0;t[F+528>>2]=Ih|0;t[F+536>>2]=Ch|0;t[F+544>>2]=sh|0;t[F+552>>2]=mh|0;t[F+560>>2]=$g|0;t[F+568>>2]=Vg|0;t[F+576>>2]=Qg|0;t[Rx>>2]=Xd|0;t[Rx+4>>2]=ps|0;t[Sx+8>>2]=tl|0;t[Sx+12>>2]=at|0;t[Sx+24>>2]=Cf|0;t[Sx+28>>2]=yf|0;t[Sx+40>>2]=Uv|0;t[Sx+44>>2]=Vr|0;t[Sx+56>>2]=Zu|0;t[Sx+60>>2]=tr|0;t[Sx+72>>2]=Au|0;t[Sx+76>>2]=dr|0;t[Sx+88>>2]=wf|0;t[Sx+92>>2]=tx|0;t[Sx+104>>2]=Eq|0;t[Sx+108>>2]=pq|0;t[Tx>>2]=hg|0;t[Tx+8>>2]=Tf|0;t[Tx+16>>2]=fn|0;t[Tx+24>>2]=tl|0;t[Tx+32>>2]=Uv|0;t[Tx+40>>2]=xv|0;t[Tx+48>>2]=Zu|0;t[Tx+56>>2]=Au|0;t[Tx+64>>2]=wf|0;t[Tx+72>>2]=Bt|0;t[Ux>>2]=$d|0;t[Wx>>2]=xe|0;t[Wx+4>>2]=ss|0;t[Wx+8>>2]=hp|0;t[Wx+12>>2]=Qm|0;t[Wx+16>>2]=Fk|0;t[Wx+20>>2]=Ui|0;t[Xx+8>>2]=Cf|0;t[Xx+12>>2]=bo|0;t[$x>>2]=Be|0;t[$x+4>>2]=us|0;t[$x+8>>2]=jp|0;t[$x+12>>2]=Rm|0;t[$x+16>>2]=Gk|0;t[$x+20>>2]=Vi|0;t[ay+8>>2]=Cf|0;t[ay+12>>2]=bo|0;t[ay+24>>2]=Ad|0;t[ay+28>>2]=Kw|0;t[by>>2]=Ns|0;t[by+4>>2]=Hs|0;t[cy+8>>2]=Fi|0;t[cy+12>>2]=Rv|0;t[cy+24>>2]=Bw|0;t[cy+28>>2]=sv|0;t[cy+40>>2]=Uf|0;t[cy+44>>2]=Rn|0;t[cy+56>>2]=uj|0;t[cy+60>>2]=lj|0;t[cy+72>>2]=av|0;t[cy+76>>2]=aj|0;t[cy+88>>2]=Bu|0;t[cy+92>>2]=Qi|0;t[dy>>2]=tf|0;t[dy+4>>2]=Js|0;t[dy+8>>2]=vp|0;t[ey>>2]=Pf|0;t[ey+4>>2]=Qs|0;t[ey+8>>2]=Ap|0;t[ey+12>>2]=cn|0;t[ey+16>>2]=Uk|0;t[fy+8>>2]=Fi|0;t[fy+12>>2]=Rv|0;t[fy+24>>2]=Cf|0;t[fy+28>>2]=bo|0;t[fy+40>>2]=$p|0;t[fy+44>>2]=Ml|0;t[fy+56>>2]=qf|0;t[fy+60>>2]=We|0;t[fy+72>>2]=wl|0;t[fy+76>>2]=kl|0;t[gy>>2]=jg|0;t[gy+4>>2]=bt|0;t[gy+8>>2]=Hp|0;t[hy>>2]=Gg|0;t[hy+4>>2]=jt|0;t[hy+8>>2]=Np|0;t[hy+12>>2]=mn|0;t[iy+8>>2]=Rr|0;t[iy+12>>2]=Kp|0;t[iy+24>>2]=as|0;t[iy+28>>2]=up|0;t[iy+40>>2]=cm|0;t[iy+44>>2]=Vo|0;t[iy+56>>2]=Gi|0;t[iy+60>>2]=Af|0;t[iy+72>>2]=oo|0;t[iy+76>>2]=eo|0;t[iy+88>>2]=Wn|0;t[iy+92>>2]=In|0;t[jy>>2]=Ng|0;t[jy+4>>2]=mt|0;t[ky+8>>2]=Cf|0;t[ky+12>>2]=bo|0;t[ky+24>>2]=ci|0;t[ky+28>>2]=xu|0;t[qy>>2]=Sh|0;t[qy+4>>2]=Jt|0;t[ry+8>>2]=Fi|0;t[ry+12>>2]=Rv|0;t[ry+24>>2]=Bw|0;t[ry+28>>2]=uk|0;t[ry+40>>2]=Uf|0;t[ry+44>>2]=fk|0;t[ry+56>>2]=Wj|0;t[ry+60>>2]=Pj|0;t[ry+72>>2]=wf|0;t[ry+76>>2]=Ij|0;t[ry+88>>2]=Cf|0;t[ry+92>>2]=Cj|0;t[ry+104>>2]=vj|0;t[ry+108>>2]=mj|0;t[ry+120>>2]=cj|0;t[ry+124>>2]=Si|0;t[ry+136>>2]=Ji|0;t[ry+140>>2]=ui|0;t[sy>>2]=Tf|0;t[sy+8>>2]=ov|0;t[sy+16>>2]=Fi|0;t[sy+24>>2]=Zs|0;t[sy+32>>2]=yg|0;t[sy+40>>2]=ti|0;t[sy+48>>2]=Sf|0;t[sy+56>>2]=tl|0;t[sy+64>>2]=bp|0;t[sy+72>>2]=xv|0;t[sy+80>>2]=Cf|0;t[sy+88>>2]=Uv|0;t[sy+96>>2]=en|0;t[sy+104>>2]=fh|0;t[sy+112>>2]=gt|0;t[sy+120>>2]=Bw|0;t[sy+128>>2]=Uf|0;t[sy+136>>2]=bs|0;t[sy+144>>2]=Oq|0;t[sy+152>>2]=Gj|0;t[sy+160>>2]=Sq|0;t[sy+168>>2]=ps|0;t[sy+176>>2]=uq|0;t[sy+184>>2]=If|0;t[sy+192>>2]=Lp|0;t[sy+200>>2]=wf|0;t[sy+208>>2]=Bt|0;t[sy+216>>2]=Eq|0;t[sy+224>>2]=Bo|0;t[sy+232>>2]=ye|0;t[sy+240>>2]=ve|0;t[sy+248>>2]=gj|0;t[sy+256>>2]=Jn|0;t[sy+264>>2]=vn|0;t[sy+272>>2]=ln|0;t[sy+280>>2]=an|0;t[sy+288>>2]=Nm|0;t[sy+296>>2]=Dm|0;t[sy+304>>2]=km|0;t[sy+312>>2]=Xl|0;t[sy+320>>2]=Ol|0;t[sy+328>>2]=Fl|0;t[ty>>2]=xi|0;t[ty+4>>2]=Sl|0;t[uy+8>>2]=cq|0;t[uy+12>>2]=Mp|0;t[uy+24>>2]=wp|0;t[uy+28>>2]=fp|0;t[uy+40>>2]=Wo|0;t[uy+44>>2]=Do|0;t[uy+56>>2]=Bw|0;t[uy+60>>2]=uk|0;t[uy+72>>2]=Fi|0;t[uy+76>>2]=Kn|0;t[uy+88>>2]=Wj|0;t[uy+92>>2]=Pj|0;t[uy+104>>2]=eg|0;t[uy+108>>2]=Om|0;t[uy+120>>2]=Cf|0;t[uy+124>>2]=Cj|0;t[uy+136>>2]=Yl|0;t[uy+140>>2]=Pl|0;t[uy+152>>2]=yn|0;t[uy+156>>2]=Gl|0;t[uy+168>>2]=uq|0;t[uy+172>>2]=yl|0;t[uy+184>>2]=wj|0;t[uy+188>>2]=ml|0;t[uy+200>>2]=Zv|0;t[uy+204>>2]=Rk|0;t[vy>>2]=Wi|0;t[vy+4>>2]=Zt|0;t[wy>>2]=qq|0;t[wy+4>>2]=En|0;t[xy+8>>2]=Zv|0;t[xy+12>>2]=Iu|0;t[yy>>2]=bj|0;t[zy+8>>2]=Cf|0;t[zy+12>>2]=bo|0;t[Ay>>2]=ij|0;t[Ay+4>>2]=cu|0;t[Ay+8>>2]=sq|0;t[Ay+12>>2]=Hn|0;t[Ay+16>>2]=xl|0;t[Ay+20>>2]=Bj|0;t[By+8>>2]=Cf|0;t[By+12>>2]=bo|0;t[H>>2]=or|0;t[H+20>>2]=Zq|0;t[H+40>>2]=Mq|0;t[H+60>>2]=zq|0;t[H+80>>2]=lq|0;t[H+100>>2]=Tp|0;t[H+120>>2]=Dp|0;t[H+140>>2]=op|0;t[H+160>>2]=pw|0;t[H+180>>2]=Vs|0;t[H+200>>2]=kt|0;t[H+220>>2]=io|0;t[H+240>>2]=Fi|0;t[H+260>>2]=El|0;t[H+280>>2]=Tj|0;t[H+300>>2]=tn|0;t[H+320>>2]=gn|0;t[H+340>>2]=Zs|0;t[H+360>>2]=Vf|0;t[H+380>>2]=Am|0;t[H+400>>2]=fm|0;t[H+420>>2]=Vq|0;t[H+440>>2]=ti|0;t[H+460>>2]=wj|0;t[H+480>>2]=Jo|0;t[H+500>>2]=il|0;t[H+520>>2]=Yk|0;t[H+540>>2]=Vn|0;t[H+560>>2]=Ak|0;t[H+580>>2]=sk|0;t[H+600>>2]=bp|0;t[H+620>>2]=Vj|0;t[H+640>>2]=Nj|0;t[H+660>>2]=Cf|0;t[H+680>>2]=xj|0;t[H+700>>2]=im|0;t[H+720>>2]=jj|0;t[H+740>>2]=Yv|0;t[H+760>>2]=Xn|0;t[H+780>>2]=Hm|0;t[H+800>>2]=Bi|0;t[H+820>>2]=ji|0;t[H+840>>2]=gh|0;t[H+860>>2]=cq|0;t[H+880>>2]=ym|0;t[H+900>>2]=Gw|0;t[H+920>>2]=Kh|0;t[H+940>>2]=Dh|0;t[H+960>>2]=th|0;t[H+980>>2]=ph|0;t[H+1e3>>2]=ah|0;t[H+1020>>2]=bs|0;t[H+1040>>2]=wl|0;t[H+1060>>2]=Lg|0;t[H+1080>>2]=yk|0;t[H+1100>>2]=wg|0;t[H+1120>>2]=Ql|0;t[H+1140>>2]=Te|0;t[H+1160>>2]=fg|0;t[H+1180>>2]=Yo|0;t[H+1200>>2]=Gi|0;t[H+1220>>2]=Jf|0;t[H+1240>>2]=oi|0;t[H+1260>>2]=nx|0;t[H+1280>>2]=Xj|0;t[H+1300>>2]=Ve|0;t[H+1320>>2]=Yf|0;t[H+1340>>2]=Bh|0;t[H+1360>>2]=lh|0;t[H+1380>>2]=Ye|0;t[H+1400>>2]=Me|0;t[H+1420>>2]=Ee|0;t[H+1440>>2]=Ae|0;t[H+1460>>2]=wi|0;t[H+1480>>2]=re|0;t[H+1500>>2]=uq|0;t[H+1520>>2]=ju|0;t[H+1540>>2]=Dd|0;t[H+1560>>2]=wt|0;t[H+1580>>2]=rx|0;t[H+1600>>2]=te|0;t[H+1620>>2]=cx|0;t[H+1640>>2]=$w|0;t[H+1660>>2]=Xw|0;t[H+1680>>2]=Vw|0;t[H+1700>>2]=Pw|0;t[H+1720>>2]=Lp|0;t[H+1740>>2]=yn|0;t[H+1760>>2]=Iw|0;t[H+1780>>2]=Ew|0;t[H+1800>>2]=tw|0;t[H+1820>>2]=Fh|0;t[H+1840>>2]=nw|0;t[H+1860>>2]=jw|0;t[H+1880>>2]=iw|0;t[H+1900>>2]=Bo|0;t[H+1920>>2]=aw|0;t[H+1940>>2]=Wg|0;t[H+1960>>2]=Tv|0;t[H+1980>>2]=ye|0;t[Vy+8>>2]=Cf|0;t[Vy+12>>2]=bo|0;t[Vy+24>>2]=Fi|0;t[Vy+28>>2]=Rv|0;t[Vy+40>>2]=Bw|0;t[Vy+44>>2]=sv|0;t[Vy+56>>2]=Yl|0;t[Vy+60>>2]=dq|0;t[Vy+72>>2]=qf|0;t[Vy+76>>2]=xp|0;t[Wy>>2]=Cf|0;t[Wy+8>>2]=Ln|0;t[Wy+16>>2]=Oq|0;t[Wy+24>>2]=Dj|0;t[Wy+32>>2]=Ww|0;t[Wy+40>>2]=Wj|0;t[Wy+48>>2]=yk|0;t[Wy+56>>2]=te|0;t[Wy+64>>2]=bp|0;t[Wy+72>>2]=ye|0;t[Wy+80>>2]=Zs|0;t[Wy+88>>2]=im|0;t[Wy+96>>2]=ti|0;t[Wy+104>>2]=ju|0;t[Wy+112>>2]=Lp|0;t[Wy+120>>2]=kt|0;t[Wy+128>>2]=Ms|0;t[Xy>>2]=Yj|0;t[Yy>>2]=Wt|0;t[Zy+8>>2]=Fi|0;t[Zy+12>>2]=Rv|0;t[Zy+24>>2]=Wu|0;t[Zy+28>>2]=Ou|0;t[Zy+40>>2]=eg|0;t[Zy+44>>2]=ds|0;t[Zy+56>>2]=wj|0;t[Zy+60>>2]=Ku|0;t[Zy+72>>2]=cq|0;t[Zy+76>>2]=Ju|0;t[Zy+88>>2]=Gw|0;t[Zy+92>>2]=Nf|0;t[Zy+104>>2]=Bw|0;t[Zy+108>>2]=sv|0;t[Zy+120>>2]=Gi|0;t[Zy+124>>2]=Af|0;t[$y>>2]=ik|0;t[$y+4>>2]=ru|0;t[az>>2]=Sl|0;t[az+4>>2]=Il|0;t[az+8>>2]=Al|0;t[az+12>>2]=ql|0;t[az+16>>2]=fl|0;t[az+20>>2]=Vk|0;t[az+24>>2]=Jk|0;t[az+28>>2]=wk|0;t[cz>>2]=Qg|0;t[dz+8>>2]=Gi|0;t[dz+12>>2]=Af|0;t[dz+24>>2]=Mg|0;t[dz+28>>2]=bo|0;t[dz+40>>2]=El|0;t[dz+44>>2]=Kp|0;t[dz+56>>2]=wf|0;t[dz+60>>2]=Tt|0;t[dz+72>>2]=Wj|0;t[dz+76>>2]=We|0;t[hz>>2]=sr|0;t[hz+4>>2]=bp|0;t[hz+8>>2]=Rq|0;t[hz+12>>2]=fo|0;t[hz+16>>2]=Nl|0;t[hz+20>>2]=Oj|0;t[iz+8>>2]=Gf|0;t[iz+12>>2]=Gf|0;t[iz+24>>2]=mu|0;t[iz+28>>2]=Bf|0;t[iz+40>>2]=fq|0;t[iz+44>>2]=xf|0;t[iz+56>>2]=Cf|0;t[iz+60>>2]=bo|0;t[iz+72>>2]=cq|0;t[iz+76>>2]=pf|0;t[iz+88>>2]=As|0;t[iz+92>>2]=cf|0;t[iz+104>>2]=cm|0;t[iz+108>>2]=Vo|0;t[iz+120>>2]=Gw|0;t[iz+124>>2]=De|0;t[iz+136>>2]=Uf|0;t[iz+140>>2]=Rn|0;t[iz+152>>2]=Zl|0;t[iz+156>>2]=se|0;t[iz+168>>2]=Xj|0;t[iz+172>>2]=Yd|0;t[iz+184>>2]=oo|0;t[iz+188>>2]=eo|0;t[iz+200>>2]=wf|0;t[iz+204>>2]=Ed|0;t[iz+216>>2]=qf|0;t[iz+220>>2]=sx|0;t[J>>2]=Rg|0;t[J+8>>2]=Ff|0;t[J+16>>2]=Ce|0;t[J+24>>2]=Su|0;t[J+32>>2]=pw|0;t[J+40>>2]=Hv|0;t[J+48>>2]=iv|0;t[J+56>>2]=Mu|0;t[J+64>>2]=mu|0;t[J+72>>2]=Nt|0;t[J+80>>2]=ot|0;t[J+88>>2]=Os|0;t[J+96>>2]=ws|0;t[J+104>>2]=es|0;t[J+112>>2]=Gr|0;t[J+120>>2]=Zs|0;t[J+128>>2]=Vq|0;t[J+136>>2]=Hq|0;t[J+144>>2]=Sf|0;t[J+152>>2]=fq|0;t[J+160>>2]=Pp|0;t[J+168>>2]=em|0;t[J+176>>2]=as|0;t[J+184>>2]=Cf|0;t[J+192>>2]=im|0;t[J+200>>2]=po|0;t[J+208>>2]=Ue|0;t[J+216>>2]=Xn|0;t[J+224>>2]=gh|0;t[J+232>>2]=xn|0;t[J+240>>2]=cq|0;t[J+248>>2]=bn|0;t[J+256>>2]=Sm|0;t[J+264>>2]=ys|0;t[J+272>>2]=Uf|0;t[J+280>>2]=Zl|0;t[J+288>>2]=Ql|0;t[J+296>>2]=Hl|0;t[J+304>>2]=lx|0;t[J+312>>2]=ol|0;t[J+320>>2]=dl|0;t[J+328>>2]=Sk|0;t[J+336>>2]=Hk|0;t[J+344>>2]=vk|0;t[J+352>>2]=nx|0;t[J+360>>2]=Xj|0;t[J+368>>2]=Yf|0;t[J+376>>2]=Wh|0;t[J+384>>2]=Aw|0;t[J+392>>2]=Hh|0;t[J+400>>2]=pj|0;t[J+408>>2]=dj|0;t[J+416>>2]=Pg|0;t[J+424>>2]=Ki|0;t[J+432>>2]=wi|0;t[J+440>>2]=ki|0;t[J+448>>2]=Au|0;t[J+456>>2]=oo|0;t[J+464>>2]=Yh|0;t[J+472>>2]=If|0;t[J+480>>2]=wf|0;t[J+488>>2]=Fh|0;t[J+496>>2]=Ze|0;t[J+504>>2]=Eq|0;t[J+512>>2]=Bo|0;t[J+520>>2]=Wg|0;t[J+528>>2]=Sg|0;t[J+536>>2]=ye|0;t[jz>>2]=Ur|0;t[jz+4>>2]=lv|0;t[kz+8>>2]=Cf|0;t[kz+12>>2]=bo|0;t[kz+24>>2]=Fi|0;t[kz+28>>2]=Rv|0;t[kz+40>>2]=Bw|0;t[kz+44>>2]=sv|0;t[kz+56>>2]=Yl|0;t[kz+60>>2]=dq|0;t[kz+72>>2]=qf|0;t[kz+76>>2]=xp|0;t[kz+88>>2]=Em|0;t[kz+92>>2]=nm|0;t[lz>>2]=Cf|0;t[lz+8>>2]=Ln|0;t[lz+16>>2]=Oq|0;t[lz+24>>2]=Dj|0;t[lz+32>>2]=Ww|0;t[lz+40>>2]=Wj|0;t[lz+48>>2]=yk|0;t[lz+56>>2]=te|0;t[lz+64>>2]=bp|0;t[lz+72>>2]=ye|0;t[lz+80>>2]=Zs|0;t[lz+88>>2]=im|0;t[lz+96>>2]=ti|0;t[lz+104>>2]=ju|0;t[lz+112>>2]=Lp|0;t[lz+120>>2]=kt|0;t[lz+128>>2]=Ms|0;t[lz+136>>2]=Yf|0;t[lz+144>>2]=nx|0;t[lz+152>>2]=wi|0;t[lz+160>>2]=Fi|0;t[lz+168>>2]=Iq|0;t[lz+176>>2]=vq|0;t[lz+184>>2]=gq|0;t[lz+192>>2]=Qp|0;t[lz+200>>2]=yp|0;t[lz+208>>2]=kp|0;t[lz+216>>2]=Yo|0;t[mz>>2]=Xo|0;t[mz+4>>2]=vv|0;t[nz+8>>2]=Fi|0;t[nz+12>>2]=Rv|0;t[nz+24>>2]=Cf|0;t[nz+28>>2]=bo|0;t[nz+40>>2]=$p|0;t[nz+44>>2]=Ml|0;t[nz+56>>2]=qf|0;t[nz+60>>2]=We|0;t[nz+72>>2]=wl|0;t[nz+76>>2]=kl|0;t[zz>>2]=pp|0;t[zz+4>>2]=yv|0;t[zz+8>>2]=er|0;t[zz+12>>2]=no|0;t[Az+8>>2]=Zv|0;t[Az+12>>2]=Ie|0;t[Az+24>>2]=Cf|0;t[Az+28>>2]=bo|0;t[Az+40>>2]=Uf|0;t[Az+44>>2]=Rn|0;t[Az+56>>2]=Hh|0;t[Az+60>>2]=jv|0;t[Bz>>2]=Er|0;t[Cz+8>>2]=Fi|0;t[Cz+12>>2]=Rv|0;t[Cz+24>>2]=hq|0;t[Cz+28>>2]=Th|0;t[Cz+40>>2]=Gw|0;t[Cz+44>>2]=Nh|0;t[Dz>>2]=Ai|0;t[Dz+8>>2]=Uq|0;t[Dz+16>>2]=Tf|0;t[Dz+24>>2]=Ur|0;t[Dz+32>>2]=li|0;t[Dz+40>>2]=Xg|0;t[Dz+48>>2]=$j|0;t[Dz+56>>2]=Fi|0;t[Dz+64>>2]=dx|0;t[Dz+72>>2]=Vg|0;t[Dz+80>>2]=Iv|0;t[Dz+88>>2]=kv|0;t[Dz+96>>2]=Nu|0;t[Dz+104>>2]=ou|0;t[Dz+112>>2]=Qt|0;t[Dz+120>>2]=Zs|0;t[Dz+128>>2]=ti|0;t[Dz+136>>2]=Sv|0;t[Dz+144>>2]=Sf|0;t[Dz+152>>2]=Ir|0;t[Dz+160>>2]=lr|0;t[Dz+168>>2]=ce|0;t[Dz+176>>2]=em|0;t[Dz+184>>2]=Fl|0;t[Dz+192>>2]=hq|0;t[Dz+200>>2]=Gn|0;t[Dz+208>>2]=zp|0;t[Dz+216>>2]=im|0;t[Dz+224>>2]=Zo|0;t[Dz+232>>2]=Ho|0;t[Dz+240>>2]=qo|0;t[Dz+248>>2]=go|0;t[Dz+256>>2]=Yn|0;t[Dz+264>>2]=Mn|0;t[Dz+272>>2]=vm|0;t[Dz+280>>2]=nn|0;t[Dz+288>>2]=Gw|0;t[Dz+296>>2]=sl|0;t[Dz+304>>2]=Sj|0;t[Dz+312>>2]=pm|0;t[Dz+320>>2]=$l|0;t[Dz+328>>2]=Rl|0;t[Dz+336>>2]=gj|0;t[Dz+344>>2]=zl|0;t[Dz+352>>2]=pl|0;t[Dz+360>>2]=el|0;t[Dz+368>>2]=Tk|0;t[Dz+376>>2]=Ik|0;t[Dz+384>>2]=Wm|0;t[Dz+392>>2]=jk|0;t[Dz+400>>2]=Pg|0;t[Dz+408>>2]=Qj|0;t[Dz+416>>2]=Jj|0;t[Dz+424>>2]=If|0;t[Dz+432>>2]=Ol|0;t[Dz+440>>2]=qj|0;t[Dz+448>>2]=rk|0;t[Dz+456>>2]=df|0;t[Dz+464>>2]=Li|0;t[Dz+472>>2]=Fe|0;t[Dz+480>>2]=Vd|0;t[Ez>>2]=Zr|0;t[Ez+4>>2]=tf|0;t[Gz>>2]=ts|0;t[Hz+8>>2]=Fi|0;t[Hz+12>>2]=Rv|0;t[Hz+24>>2]=Le|0;t[Hz+28>>2]=gx|0;t[Hz+40>>2]=Iq|0;t[Hz+44>>2]=Jv|0;t[Iz>>2]=Tu|0;t[Jz+8>>2]=Fi|0;t[Jz+12>>2]=Rv|0;t[Jz+24>>2]=Zv|0;t[Jz+28>>2]=Ie|0;t[Jz+40>>2]=Gv|0;t[Jz+44>>2]=Fv|0;t[Jz+56>>2]=Jo|0;t[Jz+60>>2]=lo|0;t[Jz+72>>2]=eg|0;t[Jz+76>>2]=ds|0;t[Jz+88>>2]=wj|0;t[Jz+92>>2]=Av|0;t[Jz+104>>2]=cq|0;t[Jz+108>>2]=Ju|0;t[Jz+120>>2]=Gw|0;t[Jz+124>>2]=Nf|0;t[Jz+136>>2]=Bw|0;t[Jz+140>>2]=sv|0;t[Jz+152>>2]=wl|0;t[Jz+156>>2]=yu|0;t[Jz+168>>2]=Yl|0;t[Jz+172>>2]=dq|0;t[Jz+184>>2]=uq|0;t[Jz+188>>2]=lu|0;t[Jz+200>>2]=yn|0;t[Jz+204>>2]=fv|0;t[Kz>>2]=Tr|0;t[Kz+4>>2]=Qo|0;t[Kz+8>>2]=xm|0;t[Kz+12>>2]=qk|0;t[Kz+16>>2]=Ei|0;t[Kz+20>>2]=Sl|0;t[Kz+24>>2]=Vk|0;t[Kz+28>>2]=Al|0;t[Kz+32>>2]=mx|0;t[Kz+36>>2]=ql|0;t[Kz+40>>2]=fl|0;t[Pz>>2]=it|0;t[Pz+4>>2]=bw|0;t[Pz+8>>2]=Ar|0;t[Pz+12>>2]=Ao|0;t[Sz>>2]=Rw|0;t[Tz+8>>2]=Fi|0;t[Tz+12>>2]=Rv|0;t[Tz+24>>2]=Zv|0;t[Tz+28>>2]=Ie|0;t[Tz+40>>2]=Gv|0;t[Tz+44>>2]=Fv|0;t[Tz+56>>2]=Cf|0;t[Tz+60>>2]=yf|0;t[Tz+72>>2]=wj|0;t[Tz+76>>2]=Av|0;t[Tz+88>>2]=Gw|0;t[Tz+92>>2]=Nf|0;t[Tz+104>>2]=$p|0;t[Tz+108>>2]=uv|0;t[Tz+120>>2]=wl|0;t[Tz+124>>2]=yu|0;t[Tz+136>>2]=Ww|0;t[Tz+140>>2]=hv|0;t[Tz+152>>2]=uq|0;t[Tz+156>>2]=lu|0;t[Tz+168>>2]=yn|0;t[Tz+172>>2]=fv|0;t[Tz+184>>2]=Fh|0;t[Tz+188>>2]=nt|0;t[Tz+200>>2]=qf|0;t[Tz+204>>2]=kf|0;t[Tz+216>>2]=$u|0;t[Tz+220>>2]=lt|0;t[Wz>>2]=Ge|0;t[Xz+8>>2]=vh|0;t[Xz+12>>2]=oh|0;t[Xz+24>>2]=ag|0;t[Xz+28>>2]=Xe|0;t[Xz+40>>2]=qx|0;t[Xz+44>>2]=Dw|0;t[Xz+56>>2]=Bo|0;t[Xz+60>>2]=tv|0;t[Yz>>2]=ri|0;t[Yz+4>>2]=Pt|0;t[Yz+8>>2]=eq|0;t[Yz+12>>2]=wn|0;t[Zz+8>>2]=Rr|0;t[Zz+12>>2]=Kp|0;t[Zz+24>>2]=Cf|0;t[Zz+28>>2]=bo|0;t[Zz+40>>2]=cm|0;t[Zz+44>>2]=Vo|0;t[Zz+56>>2]=wf|0;t[Zz+60>>2]=Tt|0;t[Zz+72>>2]=qf|0;t[Zz+76>>2]=We|0;t[Zz+88>>2]=wj|0;t[Zz+92>>2]=To|0;t[$z>>2]=Aj|0;t[$z+4>>2]=gu|0;t[$z+8>>2]=tq|0;t[aA+8>>2]=Cf|0;t[aA+12>>2]=bo|0;t[bA>>2]=Dn|0;t[bA+4>>2]=dv|0;t[cA+8>>2]=Rr|0;t[cA+12>>2]=Kp|0;t[cA+24>>2]=Fi|0;t[cA+28>>2]=Rv|0;t[cA+40>>2]=Cf|0;t[cA+44>>2]=bo|0;t[cA+56>>2]=oo|0;t[cA+60>>2]=eo|0;t[cA+72>>2]=qf|0;t[cA+76>>2]=We|0;t[dA>>2]=zm|0;t[dA+4>>2]=lk|0;t[dA+8>>2]=zi|0;t[dA+12>>2]=eh|0;t[eA>>2]=uh|0;t[eA+4>>2]=$s|0;t[eA+8>>2]=qp|0;t[eA+12>>2]=Ro|0;t[fA+8>>2]=zr|0;t[fA+12>>2]=So|0;t[fA+24>>2]=cm|0;t[fA+28>>2]=Vo|0;t[fA+40>>2]=Zv|0;t[fA+44>>2]=Iu|0;t[fA+56>>2]=wf|0;t[fA+60>>2]=Tn|0;t[gA>>2]=af|0;t[gA+8>>2]=vx|0;t[gA+16>>2]=Jw|0;t[gA+24>>2]=Sf|0;t[gA+32>>2]=wv|0;t[gA+40>>2]=Yu|0;t[gA+48>>2]=zu|0;t[gA+56>>2]=cm|0;t[gA+64>>2]=Zv|0;t[gA+72>>2]=Rs|0;t[gA+80>>2]=mg|0;t[gA+88>>2]=ok|0;t[gA+96>>2]=Hh|0;t[gA+104>>2]=rv|0;t[gA+112>>2]=Ad|0;t[gA+120>>2]=uq|0;t[hA>>2]=xx|0;function L(b){return b in{32:0,9:0,10:0,11:0,12:0,13:0}}function mA(b,d){b--;do{b++;var c=l[b];if(c==d){return b}}while(c);return 0}function N(b,d,c){for(var e=0;e<c;){var f=$a[b+e],g=$a[d+e];if(f==g&&0==f){break}if(0==f){return-1}if(0==g){return 1}if(f==g){e++}else{return f>g?1:-1}}return 0}function nA(b){return 97<=b&&122>=b?b-97+65:b}function oA(b){return 48<=b&&57>=b||97<=b&&122>=b||65<=b&&90>=b}function pA(b){return 97<=b&&122>=b||65<=b&&90>=b}function qA(b,d){return N(b,d,Aa)}function rA(b){return 65<=b&&90>=b?b-65+97:b}function sA(b,d,c){for(var e=0;e<c;){var f=rA($a[b+e]),g=rA($a[d+e]);if(f==g&&0==f){break}if(0==f){return-1}if(0==g){return 1}if(f==g){e++}else{return f>g?1:-1}}return 0}function tA(b,d){var c=0,e;do{c||(e=b,c=d);var f=l[b++],g=l[c++];if(0==g){return e}g!=f&&(b=e+1,c=0)}while(f);return 0}var uA=13,vA=9,wA=17,xA=22,yA=5,zA=21,AA=2,BA=6,CA=32,DA=34,EA=29;function FA(b){GA||(GA=y([0],"i32",x));t[GA>>2]=b}var GA,HA=0;Wb=Ob=0;var IA=2,JA=[da],KA=ca;function LA(b,d){if("string"!==typeof b){return da}d===ba&&(d="/");b&&"/"==b[0]&&(d="");for(var c=(d+"/"+b).split("/").reverse(),e=[""];c.length;){var f=c.pop();""==f||"."==f||(".."==f?1<e.length&&e.pop():e.push(f))}return 1==e.length?"/":e.join("/")}function MA(b,d,c){var e={J:fa,s:fa,error:0,name:da,path:da,object:da,v:fa,w:da,o:da},b=LA(b);if("/"==b){e.J=ca,e.s=e.v=ca,e.name="/",e.path=e.w="/",e.object=e.o=NA}else{if(b!==da){for(var c=c||0,b=b.slice(1).split("/"),f=NA,g=[""];b.length;){1==b.length&&f.d&&(e.v=ca,e.w=1==g.length?"/":g.join("/"),e.o=f,e.name=b[0]);var h=b.shift();if(f.d){if(f.q){if(!f.a.hasOwnProperty(h)){e.error=AA;break}}else{e.error=uA;break}}else{e.error=20;break}f=f.a[h];if(f.link&&!(d&&0==b.length)){if(40<c){e.error=40;break}e=LA(f.link,g.join("/"));e=MA([e].concat(b).join("/"),d,c+1);break}g.push(h);0==b.length&&(e.s=ca,e.path=g.join("/"),e.object=f)}}}return e}function OA(b,d){PA();var c=MA(b,d);if(c.s){return c.object}FA(c.error);return da}function QA(b,d,c,e,f){b||(b="/");"string"===typeof b&&(b=OA(b));b||(FA(uA),aa(Error("Parent path must exist.")));b.d||(FA(20),aa(Error("Parent must be a folder.")));!b.write&&!KA&&(FA(uA),aa(Error("Parent folder must be writeable.")));if(!d||"."==d||".."==d){FA(AA),aa(Error("Name must not be empty."))}
b.a[d]={q:e===ba?ca:e,write:f===ba?fa:f,timestamp:Date.now(),u:IA++};for(var g in c){c.hasOwnProperty(g)&&(b.a[d][g]=c[g])}return b.a[d]}function RA(b,d,c,e){return QA(b,d,{d:ca,b:fa,a:{}},c,e)}function SA(b,d,c,e){b=OA(b);b===da&&aa(Error("Invalid parent."));for(d=d.split("/").reverse();d.length;){var f=d.pop();f&&(b.a.hasOwnProperty(f)||RA(b,f,c,e),b=b.a[f])}return b}function TA(b,d,c,e,f){c.d=fa;return QA(b,d,c,e,f)}function UA(b,d,c,e,f){if("string"===typeof c){for(var g=Array(c.length),h=0,i=c.length;h<i;++h){g[h]=c.charCodeAt(h)}c=g}c={b:fa,a:c.subarray?c.subarray(0):c};return TA(b,d,c,e,f)}function VA(b,d,c,e,f,g,h,i){function m(b){return{jpg:"image/jpeg",png:"image/png",bmp:"image/bmp",ogg:"audio/ogg",wav:"audio/wav",mp3:"audio/mpeg"}[b.substr(-3)]}function n(c){function m(c){i||UA(b,d,c,e,f);g&&g();Gb("cp "+p)}var n=fa;a.preloadPlugins.forEach((function(b){!n&&b.canHandle(p)&&(b.handle(c,p,m,(function(){h&&h();Gb("cp "+p)})),n=ca)}));n||m(c)}if(!WA){WA=ca;try{new Blob,XA=ca}catch(q){XA=fa,console.log("warning: no blob constructor, cannot create blobs with mimetypes")}YA="undefined"!=typeof MozBlobBuilder?MozBlobBuilder:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:!XA?console.log("warning: no BlobBuilder"):da;ZA="undefined"!=typeof window?window.URL?window.URL:window.webkitURL:console.log("warning: cannot create object URLs");a.preloadPlugins||(a.preloadPlugins=[]);a.preloadPlugins.push({canHandle:(function(b){return b.substr(-4)in{".jpg":1,".png":1,".bmp":1}}),handle:(function(b,c,d,e){var f=da;if(XA){try{f=new Blob([b],{type:m(c)})}catch(g){var h="Blob constructor present but fails: "+g+"; falling back to blob builder";va||(va={});va[h]||(va[h]=1,a.h(h))}}f||(f=new YA,f.append((new Uint8Array(b)).buffer),f=f.getBlob());var i=ZA.createObjectURL(f);ua("string"==typeof i,"createObjectURL must return a url as a string");var n=new Image;n.onload=(function(){ua(n.complete,"Image "+c+" could not be decoded");var e=document.createElement("canvas");e.width=n.width;e.height=n.height;e.getContext("2d").drawImage(n,0,0);a.preloadedImages[c]=e;ZA.revokeObjectURL(i);d&&d(b)});n.onerror=(function(){console.log("Image "+i+" could not be decoded");e&&e()});n.src=i})});a.preloadPlugins.push({canHandle:(function(b){return b.substr(-4)in{".ogg":1,".wav":1,".mp3":1}}),handle:(function(b,c,d,e){function f(e){h||(h=ca,a.preloadedAudios[c]=e,d&&d(b))}function g(){h||(h=ca,a.preloadedAudios[c]=new Audio,e&&e())}var h=fa;if(XA){try{var i=new Blob([b],{type:m(c)})}catch(n){return g()}i=ZA.createObjectURL(i);ua("string"==typeof i,"createObjectURL must return a url as a string");var p=new Audio;p.addEventListener("canplaythrough",(function(){f(p)}),fa);p.onerror=(function(){if(!h){console.log("warning: browser could not fully decode audio "+c+", trying slower base64 approach");for(var d="",e=0,g=0,i=0;i<b.length;i++){e=e<<8|b[i];for(g+=8;6<=g;){var m=e>>g-6&63,g=g-6,d=d+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[m]}}2==g?(d+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(e&3)<<4],d+="=="):4==g&&(d+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(e&15)<<2],d+="=");p.src="data:audio/x-"+c.substr(-3)+";base64,"+d;f(p)}});p.src=i;setTimeout((function(){f(p)}),1e4)}else{return g()}})})}for(var p,s=[b,d],r=s[0],u=1;u<s.length;u++){"/"!=r[r.length-1]&&(r+="/"),r+=s[u]}"/"==r[0]&&(r=r.substr(1));p=r;Cb("cp "+p);if("string"==typeof c){var v=h,w=(function(){v?v():aa('Loading data file "'+c+'" failed.')}),C=new XMLHttpRequest;C.open("GET",c,ca);C.responseType="arraybuffer";C.onload=(function(){if(200==C.status){var b=C.response;ua(b,'Loading data file "'+c+'" failed (no arrayBuffer).');b=new Uint8Array(b);n(b);Gb("al "+c)}else{w()}});C.onerror=w;C.send(da);Cb("al "+c)}else{n(c)}}function $A(b,d,c,e){!c&&!e&&aa(Error("A device must have at least one callback defined."));return TA(b,d,{b:ca,input:c,k:e},Boolean(c),Boolean(e))}function aB(b){if(b.b||b.d||b.link||b.a){return ca}var d=ca;"undefined"!==typeof XMLHttpRequest&&aa(Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."));if(a.read){try{b.a=lb(a.read(b.url),ca)}catch(c){d=fa}}else{aa(Error("Cannot load without read() or XMLHttpRequest."))}d||FA(yA);return d}function PA(){NA||(NA={q:ca,write:ca,d:ca,b:fa,timestamp:Date.now(),u:1,a:{}})}var bB,NA;function cB(b){return Number(JA[b]&&JA[b].c)}function dB(b,d){aa({f:ca,id:t[b>>2],value:d||1})}function eB(b,d){function c(b){var c;"double"===b?c=(Ua[0]=t[d+f>>2],Ua[1]=t[d+(f+4)>>2],Ta[0]):"i64"==b?c=[t[d+f>>2],t[d+(f+4)>>2]]:(b="i32",c=t[d+f>>2]);f+=Math.max(sa(b),ta);return c}for(var e=b,f=0,g=[],h,i;;){var m=e;h=l[e];if(0===h){break}i=l[e+1];if(37==h){var n=fa,q=fa,p=fa,s=fa;a:for(;;){switch(i){case 43:n=ca;break;case 45:q=ca;break;case 35:p=ca;break;case 48:if(s){break a}else{s=ca;break};default:break a}e++;i=l[e+1]}var r=0;if(42==i){r=c("i32"),e++,i=l[e+1]}else{for(;48<=i&&57>=i;){r=10*r+(i-48),e++,i=l[e+1]}}var u=fa;if(46==i){var v=0,u=ca;e++;i=l[e+1];if(42==i){v=c("i32"),e++}else{for(;;){i=l[e+1];if(48>i||57<i){break}v=10*v+(i-48);e++}}i=l[e+1]}else{v=6}var w;switch(String.fromCharCode(i)){case"h":i=l[e+2];104==i?(e++,w=1):w=2;break;case"l":i=l[e+2];108==i?(e++,w=8):w=4;break;case"L":;case"q":;case"j":w=8;break;case"z":;case"t":;case"I":w=4;break;default:w=da}w&&e++;i=l[e+1];if(-1!="diuoxXp".split("").indexOf(String.fromCharCode(i))){m=100==i||105==i;w=w||4;var C=h=c("i"+8*w),A;8==w&&(h=117==i?(h[0]>>>0)+4294967296*(h[1]>>>0):(h[0]>>>0)+4294967296*(h[1]|0));4>=w&&(h=(m?vb:ub)(h&Math.pow(256,w)-1,8*w));var I=Math.abs(h),m="";if(100==i||105==i){A=8==w&&fB?fB.stringify(C[0],C[1],da):vb(h,8*w).toString(10)}else{if(117==i){A=8==w&&fB?fB.stringify(C[0],C[1],ca):ub(h,8*w).toString(10),h=Math.abs(h)}else{if(111==i){A=(p?"0":"")+I.toString(8)}else{if(120==i||88==i){m=p?"0x":"";if(8==w&&fB){A=(C[1]>>>0).toString(16)+(C[0]>>>0).toString(16)}else{if(0>h){h=-h;A=(I-1).toString(16);C=[];for(p=0;p<A.length;p++){C.push((15-parseInt(A[p],16)).toString(16))}for(A=C.join("");A.length<2*w;){A="f"+A}}else{A=I.toString(16)}}88==i&&(m=m.toUpperCase(),A=A.toUpperCase())}else{112==i&&(0===I?A="(nil)":(m="0x",A=I.toString(16)))}}}}if(u){for(;A.length<v;){A="0"+A}}for(n&&(m=0>h?"-"+m:"+"+m);m.length+A.length<r;){q?A+=" ":s?A="0"+A:m=" "+m}A=m+A;A.split("").forEach((function(b){g.push(b.charCodeAt(0))}))}else{if(-1!="fFeEgG".split("").indexOf(String.fromCharCode(i))){h=c("double");if(isNaN(h)){A="nan",s=fa}else{if(isFinite(h)){u=fa;w=Math.min(v,20);if(103==i||71==i){u=ca,v=v||1,w=parseInt(h.toExponential(w).split("e")[1],10),v>w&&-4<=w?(i=(103==i?"f":"F").charCodeAt(0),v-=w+1):(i=(103==i?"e":"E").charCodeAt(0),v--),w=Math.min(v,20)}if(101==i||69==i){A=h.toExponential(w),/[eE][-+]\d$/.test(A)&&(A=A.slice(0,-1)+"0"+A.slice(-1))}else{if(102==i||70==i){A=h.toFixed(w)}}m=A.split("e");if(u&&!p){for(;1<m[0].length&&-1!=m[0].indexOf(".")&&("0"==m[0].slice(-1)||"."==m[0].slice(-1));){m[0]=m[0].slice(0,-1)}}else{for(p&&-1==A.indexOf(".")&&(m[0]+=".");v>w++;){m[0]+="0"}}A=m[0]+(1<m.length?"e"+m[1]:"");69==i&&(A=A.toUpperCase());n&&0<=h&&(A="+"+A)}else{A=(0>h?"-":"")+"inf",s=fa}}for(;A.length<r;){A=q?A+" ":s&&("-"==A[0]||"+"==A[0])?A[0]+"0"+A.slice(1):(s?"0":" ")+A}97>i&&(A=A.toUpperCase());A.split("").forEach((function(b){g.push(b.charCodeAt(0))}))}else{if(115==i){n=c("i8*")||mb;s=tb(n);u&&(s=Math.min(s,v));if(!q){for(;s<r--;){g.push(32)}}for(p=0;p<s;p++){g.push($a[n++])}if(q){for(;s<r--;){g.push(32)}}}else{if(99==i){for(q&&g.push(c("i8"));0<--r;){g.push(32)}q||g.push(c("i8"))}else{if(110==i){q=c("i32*"),t[q>>2]=g.length}else{if(37==i){g.push(h)}else{for(p=m;p<e+2;p++){g.push(l[p])}}}}}}}e+=2}else{g.push(h),e+=1}}return g}function gB(b,d){var c=b+tb(b);do{if(l[c]==d){return c}c--}while(c>=b);return 0}function hB(b,d,c){if(20<=c&&d%2==b%2){if(d%4==b%4){for(c=d+c;d%4;){l[b++]=l[d++]}for(var d=d>>2,b=b>>2,e=c>>2;d<e;){t[b++]=t[d++]}d<<=2;for(b<<=2;d<c;){l[b++]=l[d++]}}else{c=d+c;d%2&&(l[b++]=l[d++]);d>>=1;b>>=1;for(e=c>>1;d<e;){Pa[b++]=Pa[d++]}d<<=1;b<<=1;d<c&&(l[b++]=l[d++])}}else{for(;c--;){l[b++]=l[d++]}}}function iB(b,d,c){for(var e=fa,f,g=0;g<c;g++){f=e?0:l[d+g],l[b+g]=f,e=e||0==l[d+g]}}function jB(b){var d=tb(b),c=Xa(d+1);hB(c,b,d);l[c+d]=0;return c}function kB(b,d,c){var e=JA[b];if(e){if(e.j){if(0>c){return FA(xA),-1}if(e.object.b){if(e.object.k){for(var f=0;f<c;f++){try{e.object.k(l[d+f])}catch(g){return FA(yA),-1}}e.object.timestamp=Date.now();return f}FA(BA);return-1}f=e.position;b=JA[b];if(!b||b.object.b){FA(vA),d=-1}else{if(b.j){if(b.object.d){FA(zA),d=-1}else{if(0>c||0>f){FA(xA),d=-1}else{for(var h=b.object.a;h.length<f;){h.push(0)}for(var i=0;i<c;i++){h[f+i]=$a[d+i]}b.object.timestamp=Date.now();d=i}}}else{FA(uA),d=-1}}-1!=d&&(e.position+=d);return d}FA(uA);return-1}FA(vA);return-1}function lB(b,d,c){var e=eB(d,c),d=j;c=y(e,"i8",Va);e=1*e.length;0==e?b=0:(c=kB(b,c,e),-1==c?(JA[b]&&(JA[b].error=ca),b=0):b=Math.floor(c/1));j=d;return b}function mB(b,d){return lB(t[Ob>>2],b,d)}function nB(b,d){JA[b]?(b=JA[b],b.object.b?FA(EA):(t[d>>2]=b.position,t[d+4>>2]=(b.c?1:0)+(b.error?2:0))):FA(vA)}function oB(b,d){if(JA[b]){if(JA[b].object.b){FA(CA)}else{JA[b].position=t[d>>2];var c=t[d+4>>2];JA[b].c=Boolean(c&1);JA[b].error=Boolean(c&2)}}else{FA(vA)}}function pB(b,d){var c=ub(b&255);l[pB.l]=c;return-1==kB(d,pB.l,1)?(JA[d]&&(JA[d].error=ca),-1):c}var qB=pB,rB=da;function sB(b,d){var c=y([511,0,0,0],"i32",Va),e=t[c>>2],c=d&3,f=0!=c,g=1!=c,h=Boolean(d&512),i=Boolean(d&2048),m=Boolean(d&1024),n=Boolean(d&8),b=MA(Na(b));if(!b.v){return FA(b.error),-1}if(c=b.object||da){if(h&&i){return FA(wA),-1}if((f||h||m)&&c.d){return FA(zA),-1}if(g&&!c.q||f&&!c.write){return FA(uA),-1}if(m&&!c.b){c.a=[]}else{if(!aB(c)){return FA(yA),-1}}e=b.path}else{if(!h){return FA(AA),-1}if(!b.o.write){return FA(uA),-1}c=UA(b.o,b.name,[],e&256,e&128);e=b.w+"/"+b.name}h=JA.length;if(c.d){f=0;rB&&(f=Xa(rB.R));var g=[],q;for(q in c.a){g.push(q)}JA[h]={path:e,object:c,position:-2,i:ca,j:fa,n:fa,error:fa,c:fa,e:[],a:g,A:f}}else{JA[h]={path:e,object:c,position:0,i:g,j:f,n:n,error:fa,c:fa,e:[]}}return h}function tB(b,d){var c,d=Na(d);if("r"==d[0]){c=-1!=d.indexOf("+")?2:0}else{if("w"==d[0]){c=-1!=d.indexOf("+")?2:1,c|=1536}else{if("a"==d[0]){c=-1!=d.indexOf("+")?2:1,c|=512,c|=8}else{return FA(xA),0}}}c=sB(b,c);return-1==c?0:c}function uB(b){JA[b]||FA(vA);JA[b]?(JA[b].A&&vB(JA[b].A),JA[b]=da):FA(vA)}var wB=mB;function Ya(b,d){var c=0;if(20<=d){for(var e=b+d;b%4;){l[b++]=c}0>c&&(c+=256);for(var f=b>>2,g=e>>2,h=c|c<<8|c<<16|c<<24;f<g;){t[f++]=h}for(b=f<<2;b<e;){l[b++]=c}}else{for(;d--;){l[b++]=c}}}var xB=lB,yB={1:"Operation not permitted",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"Input/output error",6:"No such device or address",8:"Exec format error",9:"Bad file descriptor",10:"No child processes",11:"Resource temporarily unavailable",12:"Cannot allocate memory",13:"Permission denied",14:"Bad address",16:"Device or resource busy",17:"File exists",18:"Invalid cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Inappropriate ioctl for device",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read-only file system",31:"Too many links",32:"Broken pipe",33:"Numerical argument out of domain",34:"Numerical result out of range",35:"Resource deadlock avoided",36:"File name too long",37:"No locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many levels of symbolic links",42:"No message of desired type",43:"Identifier removed",60:"Device not a stream",61:"No data available",62:"Timer expired",63:"Out of streams resources",67:"Link has been severed",71:"Protocol error",72:"Multihop attempted",74:"Bad message",75:"Value too large for defined data type",84:"Invalid or incomplete multibyte or wide character",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Protocol not supported",95:"Operation not supported",97:"Address family not supported by protocol",98:"Address already in use",99:"Cannot assign requested address",100:"Network is down",101:"Network is unreachable",102:"Network dropped connection on reset",103:"Software caused connection abort",104:"Connection reset by peer",105:"No buffer space available",106:"Transport endpoint is already connected",107:"Transport endpoint is not connected",110:"Connection timed out",111:"Connection refused",113:"No route to host",114:"Operation already in progress",115:"Operation now in progress",116:"Stale NFS file handle",122:"Disk quota exceeded",125:"Operation canceled",130:"Owner died",131:"State not recoverable"},zB;function AB(b,d){var c=0;do{l[b+c]=l[d+c],c++}while(0!=l[d+(c-1)])}var BB=0,CB=4,DB=8,EB=12,FB=16,GB=20,HB=24,IB=28,JB=32,KB=40,LB=48,MB=56,NB=60,OB={};function PB(b,d,c){b=OA(Na(b),c);if(b===da||!aB(b)){return-1}t[d+EB>>2]=1;t[d+FB>>2]=0;t[d+GB>>2]=0;t[d+MB>>2]=4096;t[d+CB>>2]=b.u;c=Math.floor(b.timestamp/1e3);if(JB===ba){JB=OB.O.F;KB=OB.Q.F;LB=OB.P.F;var e=1e3*(b.timestamp%1e3);t[d+OB.O.D>>2]=e;t[d+OB.Q.D>>2]=e;t[d+OB.P.D>>2]=e}t[d+JB>>2]=c;t[d+KB>>2]=c;t[d+LB>>2]=c;var f=0,g=c=0,h=e=0;b.b?(e=h=b.u,c=g=0,f=8192):(e=1,h=0,b.d?(c=4096,g=1,f=16384):(f=b.a||b.link,c=f.length,g=Math.ceil(f.length/4096),f=b.link===ba?32768:40960));t[d+BB>>2]=e;t[d+HB>>2]=h;t[d+IB>>2]=c;t[d+NB>>2]=g;b.q&&(f|=365);b.write&&(f|=146);t[d+DB>>2]=f;return 0}var QB=da,RB=da,SB={};function TB(b){for(var d="",c=0,e;e=$a[b+c];){d+=String.fromCharCode(e),c++}return d}function UB(b,d,c,e){var f=JA[b];if(!f||f.object.b){return FA(vA),-1}if(f.i){if(f.object.d){return FA(zA),-1}if(0>c||0>e){return FA(xA),-1}for(b=0;f.e.length&&0<c;){l[d++]=f.e.pop(),c--,b++}f=f.object.a;c=Math.min(f.length-e,c);if(f.subarray||f.slice){for(var g=0;g<c;g++){l[d+g]=f[e+g]}}else{for(g=0;g<c;g++){l[d+g]=f.get(e+g)}}return b+c}FA(uA);return-1}function VB(b){var d=WB.l,c=1,e=JA[b];if(e){if(e.i){if(0>c){return FA(xA),-1}if(e.object.b){if(e.object.input){for(b=0;e.e.length&&0<c;){l[d++]=e.e.pop(),c--,b++}for(var f=0;f<c;f++){try{var g=e.object.input()}catch(h){return FA(yA),-1}if(g===da||g===ba){break}b++;l[d+f]=g}return b}FA(BA);return-1}g=e.e.length;b=UB(b,d,c,e.position);-1!=b&&(e.position+=e.e.length-g+b);return b}FA(uA);return-1}FA(vA);return-1}function WB(b){if(!JA[b]){return-1}var d=JA[b];if(d.c||d.error){return-1}b=VB(b);return 0==b?(d.c=ca,-1):-1==b?(d.error=ca,-1):$a[WB.l]}var XB=WB;function YB(b){var d=t[K+16>>2];JA[d]&&(b=ub(b&255),JA[d].e.push(b))}function O(){aa("abort() at "+Error().stack)}function ZB(){switch(8){case 8:return cb;case 54:;case 56:;case 21:;case 61:;case 63:;case 22:;case 67:;case 23:;case 24:;case 25:;case 26:;case 27:;case 69:;case 28:;case 101:;case 70:;case 71:;case 29:;case 30:;case 199:;case 75:;case 76:;case 32:;case 43:;case 44:;case 80:;case 46:;case 47:;case 45:;case 48:;case 49:;case 42:;case 82:;case 33:;case 7:;case 108:;case 109:;case 107:;case 112:;case 119:;case 121:return 200809;case 13:;case 104:;case 94:;case 95:;case 34:;case 35:;case 77:;case 81:;case 83:;case 84:;case 85:;case 86:;case 87:;case 88:;case 89:;case 90:;case 91:;case 94:;case 95:;case 110:;case 111:;case 113:;case 114:;case 115:;case 116:;case 117:;case 118:;case 120:;case 40:;case 16:;case 79:;case 19:return-1;case 92:;case 93:;case 5:;case 72:;case 6:;case 74:;case 92:;case 93:;case 96:;case 97:;case 98:;case 99:;case 102:;case 103:;case 105:return 1;case 38:;case 66:;case 50:;case 51:;case 4:return 1024;case 15:;case 64:;case 41:return 32;case 55:;case 37:;case 17:return 2147483647;case 18:;case 1:return 47839;case 59:;case 57:return 99;case 68:;case 58:return 2048;case 0:return 2097152;case 3:return 65536;case 14:return 32768;case 73:return 32767;case 39:return 16384;case 60:return 1e3;case 106:return 700;case 52:return 256;case 62:return 255;case 2:return 100;case 65:return 64;case 36:return 20;case 100:return 16;case 20:return 6;case 53:return 4}FA(xA);return-1}function $B(b){aC||(za=za+4095>>12<<12,aC=ca);var d=za;0!=b&&ya(b);return d}var aC;function bC(b,d,c){for(var d=ub(d),e=0;e<c;e++){if(l[b]==d){return b}b++}return 0}var cC=fa,WA,XA,YA,ZA;pb.unshift({t:(function(){if(!a.noFSInit&&!bB){var b,d,c,e=(function(b){b===da||10===b?(d.p(d.buffer.join("")),d.buffer=[]):d.buffer.push(i.C(b))});ua(!bB,"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");bB=ca;PA();b=b||a.stdin;d=d||a.stdout;c=c||a.stderr;var f=ca,g=ca,h=ca;b||(f=fa,b=(function(){if(!b.r||!b.r.length){var c;"undefined"!=typeof window&&"function"==typeof window.prompt?(c=window.prompt("Input: "),c===da&&(c=String.fromCharCode(0))):"function"==typeof readline&&(c=readline());c||(c="");b.r=lb(c+"\n",ca)}return b.r.shift()}));var i=new wa;d||(g=fa,d=e);d.p||(d.p=a.print);d.buffer||(d.buffer=[]);c||(h=fa,c=e);c.p||(c.p=a.print);c.buffer||(c.buffer=[]);try{RA("/","tmp",ca,ca)}catch(m){}var e=RA("/","dev",ca,ca),n=$A(e,"stdin",b),q=$A(e,"stdout",da,d);c=$A(e,"stderr",da,c);$A(e,"tty",b,d);JA[1]={path:"/dev/stdin",object:n,position:0,i:ca,j:fa,n:fa,B:!f,error:fa,c:fa,e:[]};JA[2]={path:"/dev/stdout",object:q,position:0,i:fa,j:ca,n:fa,B:!g,error:fa,c:fa,e:[]};JA[3]={path:"/dev/stderr",object:c,position:0,i:fa,j:ca,n:fa,B:!h,error:fa,c:fa,e:[]};HA=y([1],"void*",Va);Ob=y([2],"void*",Va);Wb=y([3],"void*",Va);SA("/","dev/shm/tmp",ca,ca);for(f=JA.length;f<Math.max(HA,Ob,Wb)+4;f++){JA[f]=da}JA[HA]=JA[1];JA[Ob]=JA[2];JA[Wb]=JA[3];y([y([0,0,0,0,HA,0,0,0,Ob,0,0,0,Wb,0,0,0],"void*",x)],"void*",x)}})});qb.push({t:(function(){KA=fa})});rb.push({t:(function(){bB&&(JA[2]&&0<JA[2].object.k.buffer.length&&JA[2].object.k(10),JA[3]&&0<JA[3].object.k.buffer.length&&JA[3].object.k(10))})});a.FS_createFolder=RA;a.FS_createPath=SA;a.FS_createDataFile=UA;a.FS_createPreloadedFile=VA;a.FS_createLazyFile=(function(b,d,c,e,f){if("undefined"!==typeof XMLHttpRequest){ma||aa("Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc");var g=(function(b,c){this.length=c;this.z=b;this.m=[]});g.prototype.get=(function(b){if(!(b>this.length-1||0>b)){var c=b%n;return this.I(Math.floor(b/n))[c]}});g.prototype.N=(function(b){this.I=b});var h=new XMLHttpRequest;h.open("HEAD",c,fa);h.send(da);200<=h.status&&300>h.status||304===h.status||aa(Error("Couldn't load "+c+". Status: "+h.status));var i=Number(h.getResponseHeader("Content-length")),m,n=1048576;if(!((m=h.getResponseHeader("Accept-Ranges"))&&"bytes"===m)){n=i}var q=new g(n,i);q.N((function(b){var d=b*q.z,e=(b+1)*q.z-1,e=Math.min(e,i-1);if("undefined"===typeof q.m[b]){var f=q.m;d>e&&aa(Error("invalid range ("+d+", "+e+") or no bytes requested!"));e>i-1&&aa(Error("only "+i+" bytes available! programmer error!"));var g=new XMLHttpRequest;g.open("GET",c,fa);i!==n&&g.setRequestHeader("Range","bytes="+d+"-"+e);"undefined"!=typeof Uint8Array&&(g.responseType="arraybuffer");g.overrideMimeType&&g.overrideMimeType("text/plain; charset=x-user-defined");g.send(da);200<=g.status&&300>g.status||304===g.status||aa(Error("Couldn't load "+c+". Status: "+g.status));d=g.response!==ba?new Uint8Array(g.response||[]):lb(g.responseText||"",ca);f[b]=d}"undefined"===typeof q.m[b]&&aa(Error("doXHR failed!"));return q.m[b]}));g={b:fa,a:q}}else{g={b:fa,url:c}}return TA(b,d,g,e,f)});a.FS_createLink=(function(b,d,c,e,f){return TA(b,d,{b:fa,link:c},e,f)});a.FS_createDevice=$A;FA(0);pB.l=y([0],"i8",x);a.CTags_getLanguage=(function(b){b=y(lb(b),"i8",Va);b=a._getLanguage(b);return Na(b)});a.CTags_parseFile=(function(b){a.FS_createPath("/",b.substr(0,b.lastIndexOf("/")),ca,ca);b=y(lb(b),"i8",Va);a._parseURL(b)});a.CTags_setOnParsingCompleted=(function(b){RB=b});a.CTags_setOnTagEntry=(function(b){QB=b});WB.l=y([0],"i8",x);a.requestFullScreen=(function(){function b(){}function d(){var b=fa;if((document.webkitFullScreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.mozFullscreenElement||document.fullScreenElement||document.fullscreenElement)===c){c.M=c.requestPointerLock||c.mozRequestPointerLock||c.webkitRequestPointerLock,c.M(),b=ca}if(a.onFullScreen){a.onFullScreen(b)}}var c=a.canvas;document.addEventListener("fullscreenchange",d,fa);document.addEventListener("mozfullscreenchange",d,fa);document.addEventListener("webkitfullscreenchange",d,fa);document.addEventListener("pointerlockchange",b,fa);document.addEventListener("mozpointerlockchange",b,fa);document.addEventListener("webkitpointerlockchange",b,fa);c.L=c.requestFullScreen||c.mozRequestFullScreen||(c.webkitRequestFullScreen?(function(){c.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT)}):da);c.L()});a.requestAnimationFrame=(function(b){window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||window.oRequestAnimationFrame||window.setTimeout);window.requestAnimationFrame(b)});a.pauseMainLoop=(function(){});a.resumeMainLoop=(function(){cC&&(cC=fa,da())});function dC(){var b=P(),d=P(),c=eC();if(0!=(c|0)){for(var e=b|0,f=0,g=c;;){var c=0==(L(l[g]&255)|0)&1,h=l[g],h=0==h<<24>>24?1:0==(bC(Dq|0,h&255,4)|0),i=0==(N(g,oq|0,2)|0),m=i?1:f,i=i?g+2|0:g,n=0==(m|0);a:do{if(n){g=i}else{for(f=i;0!=(N(f,Wp|0,2)|0);){if(f=f+1|0,0==l[f]<<24>>24){g=f;f=m;break a}}g=f+2|0}f=0}while(0);h&=0==(f|0);a:do{if(h){if(i=l[g],35==i<<24>>24){fC(g+1|0)}else{for(m=g;;){n=m+1|0;if(0==(L(i&255)|0)){break}m=n;i=l[n]}i=gC(m,b);0==(t[e>>2]|0)?m=c:(m=(n=58==l[i]<<24>>24)?1:c,i=n?i+1|0:i);do{if(0==(L(l[i]&255)|0)){if(0==l[i]<<24>>24){n=i}else{break a}}else{n=i}}while(0);for(;0!=(L(l[n]&255)|0);){n=n+1|0}i=hC(n,d);if(0==(t[e>>2]|0)){for(;0!=(L(l[i]&255)|0);){i=i+1|0}gC(i,b);var q=1}else{q=0}var i=b,n=d,p=j;j+=4;if(0!=(t[i>>2]|0)){var s=iC(n,p);0!=(t[p>>2]|0)?-1!=(s|0)&&jC(i,fA|0,s):0!=((0==(t[n>>2]|0)?0:68!=(nA(l[t[n+8>>2]]&255)|0)?0:2==(t[n>>2]|0)?1:4==(t[n>>2]|0)?46==l[t[n+8>>2]+2|0]<<24>>24:5!=(t[n>>2]|0)?0:46==l[t[n+8>>2]+3|0]<<24>>24)&1|0)?0==(q|0)&&jC(i,fA|0,0):0!=(m|0)&&(iC(i,p),0==(t[p>>2]|0)&&jC(i,fA|0,1))}j=p}}}while(0);c=eC();if(0==(c|0)){break}else{g=c}}}Q(b);Q(d)}dC.X=1;function fC(b){var d,c,e=P(),f=0==(kC(l[b]&255)|0);c=(e|0)>>2;var g=t[c];d=(e+4|0)>>2;var h=(g+1|0)==(t[d]|0);a:do{if(f){var i=b,m=h,n=g}else{for(var q=e+8|0,p=b,s=h,r=g;;){if(s&&(R(e),r=t[c]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[d]|0),0==(kC(l[p]&255)|0)){i=p;m=s;n=r;break a}}}}while(0);m?(R(e),f=t[c]):f=n;b=(e+8|0)>>2;l[t[b]+f|0]=0;if(0==(qA(t[b],zr|0)|0)){for(;0!=(L(l[i]&255)|0);){i=i+1|0}S(e);f=0==(kC(l[i]&255)|0);g=t[c];h=(g+1|0)==(t[d]|0);a:do{if(f){var u=h,v=g}else{m=i;q=h;for(n=g;;){if(q&&(R(e),n=t[c]),l[t[b]+n|0]=l[m],0!=l[m]<<24>>24&&(n=t[c]+1|0,t[c]=n,l[t[b]+n|0]=0),m=m+1|0,n=t[c],q=(n+1|0)==(t[d]|0),0==(kC(l[m]&255)|0)){u=q;v=n;break a}}}}while(0);u?(R(e),d=t[c]):d=v;l[t[b]+d|0]=0;jC(e,fA|0,0)}Q(e)}fC.X=1;function gC(b,d){var c;S(d);if(0==((0==(l[b]&255|0)?0:0!=(pA(l[b]&255)|0)?1:0!=(bC(lp|0,l[b]&255,3)|0))&1|0)){return b}var e=0==(kC(l[b]&255)|0);c=(d|0)>>2;var f=t[c],g=d+4|0,h=(f+1|0)==(t[g>>2]|0);a:do{if(e){var i=b,m=h,n=f}else{for(var q=d+8|0,p=b,s=h,r=f;;){if(s&&(R(d),r=t[c]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[g>>2]|0),0==(kC(l[p]&255)|0)){i=p;m=s;n=r;break a}}}}while(0);m?(R(d),c=t[c]):c=n;l[t[d+8>>2]+c|0]=0;return i}gC.X=1;function hC(b,d){var c,e,f;S(d);e=(d|0)>>2;var g=d+4|0;c=(d+8|0)>>2;for(var h=b;;){var i=l[h];if(0==i<<24>>24){f=74;break}var m=t[e],n=(m+1|0)==(t[g>>2]|0);if(0!=(L(i&255)|0)){f=81;break}n?(R(d),i=t[e]):i=m;l[t[c]+i|0]=l[h];0!=l[h]<<24>>24&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);h=h+1|0}if(81==f){if(n){f=82}else{var q=m}}else{74==f&&(m=t[e],(m+1|0)==(t[g>>2]|0)?f=82:q=m)}82==f&&(R(d),q=t[e]);l[t[c]+q|0]=0;return h}hC.X=1;function iC(b,d){var c=P();lC(c,t[b>>2],t[b+4>>2],t[b+8>>2]);var e=mC(t[c+8>>2],t[Sy>>2]);Q(c);c=-1!=(e|0);t[d>>2]=c&1;return!c?-1:e=t[py+(e<<3)+4>>2]}function kC(b){return(0==(b|0)?0:0!=(oA(b)|0)?1:0!=(bC(Gp|0,b,4)|0))&1}function nC(){var b,d,c,e,f=P(),g=eC();if(0!=(g|0)){c=(f|0)>>2;d=(f+4|0)>>2;b=(f+8|0)>>2;var h=g;a:for(;;){var i=l[h];do{if(0!=i<<24>>24){for(var m=h,n=i;;){var q=m+1|0;if(0==(L(n&255)|0)){break}m=q;n=l[q]}var p=l[m];if(34==p<<24>>24){for(var s=m;;){var r=s+1|0,u=l[r];if(34==u<<24>>24||0==u<<24>>24){h=r;continue a}else{s=r}}}else{if(39==p<<24>>24){break}}if(0==(sA(m,Sf|0,3)|0)){var v=m+3|0;if(0==(L(l[v]&255)|0)){h=v;continue a}else{var w=v}for(;0!=(L(l[w]&255)|0);){w=w+1|0}if(0==(sA(w,Cf|0,8)|0)){break}if(0==(sA(w,nf|0,3)|0)){break}else{h=w;continue a}}if(0==(sA(m,Ep|0,4)|0)){var C=m+4|0;if(0==(L(l[C]&255)|0)){h=C;continue a}else{var A=C}for(;0!=(L(l[A]&255)|0);){A=A+1|0}if(0==(sA(A,Cf|0,8)|0)){break}if(0==(sA(A,nf|0,3)|0)){break}else{h=A;continue a}}if(0==(sA(m,Yf|0,6)|0)){var I=m+6|0;if(0==(L(l[I]&255)|0)){h=I;continue a}else{var M=I}for(;0!=(L(l[M]&255)|0);){M=M+1|0}if(0==(sA(M,Cf|0,8)|0)){for(var B=M+8|0;;){if(0==(L(l[B]&255)|0)){var G=B;break}else{B=B+1|0}}b:for(;;){do{if(0==(oA(l[G]&255)|0)){var Z=t[c],X=(Z+1|0)==(t[d]|0);if(95!=l[G]<<24>>24){break b}if(X){e=145}else{var ga=Z}}else{var ra=t[c];(ra+1|0)==(t[d]|0)?e=145:ga=ra}}while(0);145==e&&(e=0,R(f),ga=t[c]);l[t[b]+ga|0]=l[G];if(0!=l[G]<<24>>24){var ka=t[c]+1|0;t[c]=ka;l[t[b]+ka|0]=0}G=G+1|0}if(X){R(f);var ia=t[c]}else{ia=Z}l[t[b]+ia|0]=0;jC(f,cA|0,2);S(f);h=G;continue a}if(0!=(sA(M,nf|0,3)|0)){var ea=M;b:for(;;){do{if(0==(oA(l[ea]&255)|0)){var wb=t[c],sb=(wb+1|0)==(t[d]|0);if(95!=l[ea]<<24>>24){break b}if(sb){e=170}else{var Db=wb}}else{var Za=t[c];(Za+1|0)==(t[d]|0)?e=170:Db=Za}}while(0);170==e&&(e=0,R(f),Db=t[c]);l[t[b]+Db|0]=l[ea];if(0!=l[ea]<<24>>24){var kc=t[c]+1|0;t[c]=kc;l[t[b]+kc|0]=0}ea=ea+1|0}if(sb){R(f);var $c=t[c]}else{$c=wb}l[t[b]+$c|0]=0;jC(f,cA|0,4);S(f);h=ea;continue a}for(var Ia=M+3|0;;){if(0==(L(l[Ia]&255)|0)){var Eb=Ia;break}else{Ia=Ia+1|0}}b:for(;;){do{if(0==(oA(l[Eb]&255)|0)){var Pb=t[c],He=(Pb+1|0)==(t[d]|0);if(95!=l[Eb]<<24>>24){break b}if(He){e=159}else{var Hd=Pb}}else{var de=t[c];(de+1|0)==(t[d]|0)?e=159:Hd=de}}while(0);159==e&&(e=0,R(f),Hd=t[c]);l[t[b]+Hd|0]=l[Eb];if(0!=l[Eb]<<24>>24){var ee=t[c]+1|0;t[c]=ee;l[t[b]+ee|0]=0}Eb=Eb+1|0}if(He){R(f);var Id=t[c]}else{Id=Pb}l[t[b]+Id|0]=0;jC(f,cA|0,3);S(f);h=Eb;continue a}if(0==(sA(m,nx|0,7)|0)){var Jd=m+7|0;if(0==(L(l[Jd]&255)|0)){h=Jd;continue a}else{var uc=Jd}for(;0!=(L(l[uc]&255)|0);){uc=uc+1|0}if(0==(sA(uc,Cf|0,8)|0)){for(var Kd=uc+8|0;;){if(0==(L(l[Kd]&255)|0)){var Qb=Kd;break}else{Kd=Kd+1|0}}b:for(;;){do{if(0==(oA(l[Qb]&255)|0)){var Mc=t[c],ad=(Mc+1|0)==(t[d]|0);if(95!=l[Qb]<<24>>24){break b}if(ad){e=187}else{var bb=Mc}}else{var Qa=t[c];(Qa+1|0)==(t[d]|0)?e=187:bb=Qa}}while(0);187==e&&(e=0,R(f),bb=t[c]);l[t[b]+bb|0]=l[Qb];if(0!=l[Qb]<<24>>24){var Rb=t[c]+1|0;t[c]=Rb;l[t[b]+Rb|0]=0}Qb=Qb+1|0}if(ad){R(f);var vc=t[c]}else{vc=Mc}l[t[b]+vc|0]=0;jC(f,cA|0,2);S(f);h=Qb;continue a}if(0!=(sA(uc,nf|0,3)|0)){var Sb=uc;b:for(;;){do{if(0==(oA(l[Sb]&255)|0)){var fe=t[c],vd=(fe+1|0)==(t[d]|0);if(95!=l[Sb]<<24>>24){break b}if(vd){e=212}else{var lc=fe}}else{var Nc=t[c];(Nc+1|0)==(t[d]|0)?e=212:lc=Nc}}while(0);212==e&&(e=0,R(f),lc=t[c]);l[t[b]+lc|0]=l[Sb];if(0!=l[Sb]<<24>>24){var ge=t[c]+1|0;t[c]=ge;l[t[b]+ge|0]=0}Sb=Sb+1|0}if(vd){R(f);var he=t[c]}else{he=fe}l[t[b]+he|0]=0;jC(f,cA|0,4);S(f);h=Sb;continue a}for(var Tb=uc+3|0;;){if(0==(L(l[Tb]&255)|0)){var Ub=Tb;break}else{Tb=Tb+1|0}}b:for(;;){do{if(0==(oA(l[Ub]&255)|0)){var bd=t[c],cd=(bd+1|0)==(t[d]|0);if(95!=l[Ub]<<24>>24){break b}if(cd){e=201}else{var ac=bd}}else{var ie=t[c];(ie+1|0)==(t[d]|0)?e=201:ac=ie}}while(0);201==e&&(e=0,R(f),ac=t[c]);l[t[b]+ac|0]=l[Ub];if(0!=l[Ub]<<24>>24){var Ld=t[c]+1|0;t[c]=Ld;l[t[b]+Ld|0]=0}Ub=Ub+1|0}if(cd){R(f);var gb=t[c]}else{gb=bd}l[t[b]+gb|0]=0;jC(f,cA|0,3);S(f);h=Ub;continue a}if(0==(sA(m,Cf|0,8)|0)){var dd=m+8|0;if(0==(L(l[dd]&255)|0)){h=dd;continue a}else{var Vb=dd}for(;;){if(0==(L(l[Vb]&255)|0)){var Sa=Vb;break}else{Vb=Vb+1|0}}b:for(;;){do{if(0==(oA(l[Sa]&255)|0)){var Oc=t[c],Pc=(Oc+1|0)==(t[d]|0);if(95!=l[Sa]<<24>>24){break b}if(Pc){e=226}else{var Md=Oc}}else{var ed=t[c];(ed+1|0)==(t[d]|0)?e=226:Md=ed}}while(0);226==e&&(e=0,R(f),Md=t[c]);l[t[b]+Md|0]=l[Sa];if(0!=l[Sa]<<24>>24){var je=t[c]+1|0;t[c]=je;l[t[b]+je|0]=0}Sa=Sa+1|0}if(Pc){R(f);var ke=t[c]}else{ke=Oc}l[t[b]+ke|0]=0;jC(f,cA|0,2);S(f);h=Sa;continue a}if(0==(sA(m,nf|0,3)|0)){var wd=m+3|0;if(0==(L(l[wd]&255)|0)){h=wd;continue a}else{var xd=wd}for(;;){if(0==(L(l[xd]&255)|0)){var ob=xd;break}else{xd=xd+1|0}}b:for(;;){do{if(0==(oA(l[ob]&255)|0)){var Fb=t[c],fd=(Fb+1|0)==(t[d]|0);if(95!=l[ob]<<24>>24){break b}if(fd){e=240}else{var le=Fb}}else{var gd=t[c];(gd+1|0)==(t[d]|0)?e=240:le=gd}}while(0);240==e&&(e=0,R(f),le=t[c]);l[t[b]+le|0]=l[ob];if(0!=l[ob]<<24>>24){var yd=t[c]+1|0;t[c]=yd;l[t[b]+yd|0]=0}ob=ob+1|0}if(fd){R(f);var Nd=t[c]}else{Nd=Fb}l[t[b]+Nd|0]=0;jC(f,cA|0,3);S(f);h=ob;continue a}if(0==(sA(m,xg|0,3)|0)){var Od=m+3|0;if(0==(L(l[Od]&255)|0)){h=Od;continue a}else{var wc=Od}for(;;){if(0==(L(l[wc]&255)|0)){var xc=wc;break}else{wc=wc+1|0}}b:for(;;){do{if(0==(oA(l[xc]&255)|0)){var hd=t[c],Pd=(hd+1|0)==(t[d]|0);if(95!=l[xc]<<24>>24){break b}if(Pd){e=254}else{var bc=hd}}else{var me=t[c];(me+1|0)==(t[d]|0)?e=254:bc=me}}while(0);254==e&&(e=0,R(f),bc=t[c]);l[t[b]+bc|0]=l[xc];if(0!=l[xc]<<24>>24){var Qd=t[c]+1|0;t[c]=Qd;l[t[b]+Qd|0]=0}xc=xc+1|0}if(Pd){R(f);var ne=t[c]}else{ne=hd}l[t[b]+ne|0]=0;jC(f,cA|0,4);S(f);h=xc;continue a}if(0==(sA(m,Fi|0,5)|0)){var cc=m+5|0;if(0==(L(l[cc]&255)|0)){h=cc;continue a}else{var id=cc}for(;;){if(0==(L(l[id]&255)|0)){var yb=id;break}else{id=id+1|0}}b:for(;;){do{if(0==(oA(l[yb]&255)|0)){var Rd=t[c],oe=(Rd+1|0)==(t[d]|0);if(95!=l[yb]<<24>>24){break b}if(oe){e=268}else{var jd=Rd}}else{var Qc=t[c];(Qc+1|0)==(t[d]|0)?e=268:jd=Qc}}while(0);268==e&&(e=0,R(f),jd=t[c]);l[t[b]+jd|0]=l[yb];if(0!=l[yb]<<24>>24){var mc=t[c]+1|0;t[c]=mc;l[t[b]+mc|0]=0}yb=yb+1|0}if(oe){R(f);var pe=t[c]}else{pe=Rd}l[t[b]+pe|0]=0;jC(f,cA|0,1);S(f);h=yb;continue a}if(0!=(sA(m,El|0,5)|0)){h=0==p<<24>>24?m:q;continue a}var Rc=m+5|0;if(0==(L(l[Rc]&255)|0)){h=Rc;continue a}else{var kd=Rc}for(;;){if(0==(L(l[kd]&255)|0)){var nc=kd;break}else{kd=kd+1|0}}b:for(;;){do{if(0==(oA(l[nc]&255)|0)){var Sd=t[c],Sc=(Sd+1|0)==(t[d]|0);if(95!=l[nc]<<24>>24){break b}if(Sc){e=282}else{var Td=Sd}}else{var qe=t[c];(qe+1|0)==(t[d]|0)?e=282:Td=qe}}while(0);282==e&&(e=0,R(f),Td=t[c]);l[t[b]+Td|0]=l[nc];if(0!=l[nc]<<24>>24){var hf=t[c]+1|0;t[c]=hf;l[t[b]+hf|0]=0}nc=nc+1|0}if(Sc){R(f);var jf=t[c]}else{jf=Sd}l[t[b]+jf|0]=0;jC(f,cA|0,0);S(f);h=nc;continue a}}while(0);var Ag=eC();if(0==(Ag|0)){break}else{h=Ag}}}Q(f)}nC.X=1;function oC(){var b,d,c,e=P(),f=eC();if(0!=(f|0)){d=(e|0)>>2;var g=e+4|0;for(b=(e+8|0)>>2;;){do{if(0==(N(f,Cf|0,8)|0)){var h=f+8|0;if(0!=(L(l[h]&255)|0)){for(;;){if(0==(L(l[h]&255)|0)){var i=h;break}else{h=h+1|0}}a:for(;;){do{if(0==(oA(l[i]&255)|0)){var m=t[d],n=(m+1|0)==(t[g>>2]|0);if(95!=l[i]<<24>>24){break a}if(n){c=304}else{var q=m}}else{h=t[d],(h+1|0)==(t[g>>2]|0)?c=304:q=h}}while(0);304==c&&(c=0,R(e),q=t[d]);l[t[b]+q|0]=l[i];0!=l[i]<<24>>24&&(h=t[d]+1|0,t[d]=h,l[t[b]+h|0]=0);i=i+1|0}n?(R(e),h=t[d]):h=m;l[t[b]+h|0]=0;for(h=i;0!=(L(l[h]&255)|0);){h=h+1|0}40==l[h]<<24>>24&&jC(e,aA|0,0);S(e)}}}while(0);f=eC();if(0==(f|0)){break}}}Q(e)}oC.X=1;function pC(b,d){for(var c,e,f,g=b;0!=(L(l[g]<<24>>24)|0);){g=g+1|0}S(d);e=(d|0)>>2;var h=d+4|0;for(c=(d+8|0)>>2;;){var i=l[g];if(0==i<<24>>24){f=360;break}if(0!=(L(i<<24>>24)|0)){f=360;break}var i=l[g],m=t[e],n=(m+1|0)==(t[h>>2]|0);if(44==i<<24>>24||40==i<<24>>24){f=367;break}if(n){R(d);var i=l[g],q=t[e]}else{q=m}l[t[c]+q|0]=i;0!=l[g]<<24>>24&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);g=g+1|0}if(360==f){if(m=t[e],(m+1|0)!=(t[h>>2]|0)){return c=t[c],c=c+m|0,l[c]=0,g}}else{if(367==f&&!n){return c=t[c],c=c+m|0,l[c]=0,g}}R(d);e=t[e];c=t[c];c=c+e|0;l[c]=0;return g}pC.X=1;function qC(){var b,d,c,e=P();d=(e|0)>>2;var f=e+4|0;b=(e+8|0)>>2;for(var g=0==(t[Xz+16>>2]|0),h=0==(t[Xz+48>>2]|0),i=0;;){for(S(e);;){var m=T();if(-1==(m|0)||10==(m|0)||13==(m|0)){break}var n=t[d];(n+1|0)==(t[f>>2]|0)&&(R(e),n=t[d]);l[t[b]+n|0]=m&255;0!=(m|0)&&(m=t[d]+1|0,t[d]=m,l[t[b]+m|0]=0)}m=t[d];(m+1|0)==(t[f>>2]|0)&&(R(e),m=t[d]);l[t[b]+m|0]=0;for(m=t[d];;){var q=m-1|0;if(0==(q|0)){var p=0;break}if(0==(L(l[t[b]+q|0]<<24>>24)|0)){p=0;break}else{m=q}}for(;(p|0)<(q|0)&&0!=(L(l[t[b]+p|0]<<24>>24)|0);){p=p+1|0}do{if(4<(q-p|0)){if(n=t[b],45!=l[n+p|0]<<24>>24){c=408}else{if(45!=l[p+(n+1)|0]<<24>>24){c=408}else{if(45!=l[n+q|0]<<24>>24){c=408}else{if(45!=l[n+(m-2)|0]<<24>>24){c=408}else{if(0!=(i|0)){var s=i}else{for(var s=p+2|0,r=m-3|0;;){if(0==(r|0)){var u=0;break}if(58==l[n+r|0]<<24>>24){u=r;break}else{r=r-1|0}}for(;;){if(0==(u|0)){var v=s;break}n=u-1|0;if(0==(L(l[t[b]+n|0]<<24>>24)|0)){v=s;break}else{u=n}}for(;(v|0)<(u|0)&&!(0==(L(l[t[b]+v|0]<<24>>24)|0)&&45!=l[t[b]+v|0]<<24>>24);){v=v+1|0}(v|0)<(u-1|0)&&(l[t[b]+u|0]=0,s=t[b]+v|0,0!=(sA(ip|0,s,Aa)|0)&&0!=(sA(Pm|0,s,Aa)|0)&&rC(s,0));s=0}}}}}}else{c=408}}while(0);a:do{if(408==c){c=0;m=t[d];n=m-1|0;if(0==(i|0)){var w=0}else{var C=i,A=0;c=409}b:for(;;){if(409==c){c=0;for(var I=A;;){if((I|0)>=(m|0)){s=C;break a}var M=t[b],r=l[M+I|0];if(42==r<<24>>24){var B=I+1|0;if((I|0)>=(n|0)){I=B;continue}if(41==l[M+B|0]<<24>>24){break}else{I=B}}else{I=I+1|0}if(125==r<<24>>24){w=I;continue b}}w=I+2|0}if((w|0)>=(m|0)){s=0;break a}r=t[b];I=r+w|0;M=l[I];do{if(39==M<<24>>24){for(B=w;;){var G=B+1|0;if((G|0)>=(m|0)){s=0;break a}var Z=l[r+G|0];if(92==Z<<24>>24){B=(G|0)<(n|0)?B+2|0:G}else{if(39!=Z<<24>>24){B=G}else{B=B+2|0;if((B|0)>=(m|0)){w=B;continue b}if(39!=l[r+B|0]<<24>>24){w=B;continue b}}}}}else{if(123==M<<24>>24){C=1;A=w+1|0;c=409;continue b}else{if(40==M<<24>>24){if((w|0)<(n|0)){if(42!=l[w+(r+1)|0]<<24>>24){X=w}else{C=1;A=w+2|0;c=409;continue b}}else{var X=w}}else{if(60==M<<24>>24){if(B=w+1|0,(B|0)<(m|0)){if(60!=l[r+B|0]<<24>>24){X=w}else{if(0==(tA(I,un|0)|0)){X=w}else{for(B=w+2|0;(B|0)<(m|0)&&0!=(L(l[t[b]+B|0]<<24>>24)|0);){B=B+1|0}G=B+4|0;for(B=(G|0)>(m|0)?B:0==(sA(t[b]+B|0,Ri|0,4)|0)?G:B;;){if((B|0)>=(m|0)){var ga=B;break}if(0==(L(l[t[b]+B|0]<<24>>24)|0)){ga=B;break}else{B=B+1|0}}for(;(ga|0)<(m|0);){G=t[b];Z=l[G+ga|0];if(62==Z<<24>>24||58==Z<<24>>24){var ra=G;c=430;break}if(0==(L(Z<<24>>24)|0)){ga=ga+1|0}else{c=429;break}}429==c&&(ra=t[b],c=430);430==c&&(c=0,l[ra+ga|0]=0,B=t[b]+B|0,0!=(sA(ip|0,B,Aa)|0)&&0!=(sA(Pm|0,B,Aa)|0)&&0!=(sA(Ri|0,B,Aa)|0)&&rC(B,2));B=ga+1|0;if((B|0)<(m|0)){c=t[b];var ka=B,ia=c,ea=l[c+B|0];c=436}else{X=m}}}}else{X=w}}else{ka=w,ia=r,ea=M,c=436}}}}}while(0);c:do{if(436==c){if(c=0,58!=ea<<24>>24){X=ka}else{do{if(g){if(h){X=ka;break c}w=l[ka+(ia+1)|0];if(58==w<<24>>24||60==w<<24>>24){w=ka}else{X=ka;break c}}else{w=ka}}while(0);for(;;){if(0==(w|0)){var wb=0;break}r=w-1|0;if(0==(L(l[t[b]+r|0]<<24>>24)|0)){wb=w;break}else{w=r}}w=wb;for(r=t[b];;){l[r+w|0]=0;for(r=w;0!=(r|0)&&!(I=r-1|0,0==l[Lc+(l[t[b]+I|0]&255)|0]<<24>>24);){r=I}if((r|0)==(w|0)){X=ka;break c}rC(t[b]+r|0,1);for(w=r;;){if(0==(w|0)){X=ka;break c}var sb=w-1|0;if(0==(L(l[t[b]+sb|0]<<24>>24)|0)){break}else{w=sb}}r=t[b];if(44!=l[r+sb|0]<<24>>24){X=ka;break c}}}}}while(0);w=X+1|0}}}while(0);if(0==(cB(t[K+16>>2])|0)){i=s}else{break}}Q(e)}qC.X=1;function rC(b,d){var c=j;j+=80;0!=(t[Xz+(d<<4)>>2]|0)&&(sC(c,b),t[c+36>>2]=t[Xz+(d<<4)+8>>2],l[c+40|0]=t[Xz+(d<<4)+4>>2]&255,tC(c));j=c}function uC(b,d){for(var c=0;!(0!=Pa[((d<<1)+H+8>>1)+(10*c|0)]<<16>>16&&vC(t[(H>>2)+(5*c|0)],b,t[(H+4>>2)+(5*c|0)]),c=c+1|0,100==(c|0));){}}function wC(){var b=t[Fz>>2],d=t[b+80>>2],c=b+48|0;xC(t[c>>2]);t[c>>2]=0;c=b+52|0;xC(t[c>>2]);t[c>>2]=0;c=b+56|0;xC(t[c>>2]);t[c>>2]=0;c=b+64|0;xC(t[c>>2]);t[c>>2]=0;c=b+60|0;xC(t[c>>2]);t[c>>2]=0;c=b+76|0;Q(t[c>>2]);t[c>>2]=0;vB(b);t[Fz>>2]=d}function xC(b){0!=(b|0)&&(Q(t[b+8>>2]),vB(b))}function yC(b,d){var c=j,e,f=zC(84);e=f>>2;t[e+12]=AC();t[e+13]=AC();t[e+14]=AC();t[e+15]=AC();t[e+16]=AC();t[e+19]=P();t[f+80>>2]=d;e=t[f+80>>2];0==(e|0)?e=0:(e=t[e+4>>2],e=3==(e|0)?(t[Ly>>2]|0)==(t[K+56>>2]|0)?4:0:2==(e|0)?(t[Ly>>2]|0)==(t[K+56>>2]|0)?5:2:14==(e|0)||7==(e|0)||12==(e|0)?4:0);t[f+72>>2]=e;t[f+68>>2]=e;BC(f,0);t[Fz>>2]=f;e=f+44|0;for(var g=b+1|0;;){for(var h=f,i=ba,m=h+44|0,n=h+12|0;;){var q=CC();if(91==(q|0)){DC(Fq|0)}else{if(40==(q|0)){EC(h)}else{if(59==(q|0)){FC(h,11)}else{if(60==(q|0)){GC()}else{if(42==(q|0)){t[n>>2]=0}else{if(-1==(q|0)){i=668;break}else{if(123==(q|0)){FC(h,3)}else{if(58==(q|0)){HC(h)}else{if(125==(q|0)){FC(h,2)}else{if(61==(q|0)){var q=h,p=t[q+80>>2],p=0==(p|0)?0:3==(t[p+4>>2]|0)&1,s=IC();if(61!=(s|0)){JC(s);a:{for(var s=j,r=ba,u=q+40|0,v=q+80|0,w=1;;){var C;if(!w){r=1442;break}w=CC();if(48==(w|0)){2==(t[u>>2]|0)&&(t[u>>2]=3),C=48,w=1}else{if(-1==(w|0)){r=1430;break}else{if(91==(w|0)){DC(Fq|0),C=91,w=1}else{if(40==(w|0)){DC(Mt|0),C=40,w=1}else{if(44==(w|0)||59==(w|0)){C=w,w=0}else{if(123==(w|0)){DC(fu|0),C=123,w=1}else{if(125==(w|0)){if(w=t[v>>2],0!=(w|0)&&3==(t[w+4>>2]|0)){C=125,w=0}else{if(0==(t[Vz>>2]|0)){r=1441;break}else{C=125,w=1}}}else{60==(w|0)?(GC(),C=60):C=w,w=1}}}}}}}}if(1441==r){s=t[t[K+40>>2]+8>>2],r=t[K+20>>2],KC(iu|0,(k=j,j+=8,t[k>>2]=s,t[k+4>>2]=r,k)),dB(yz|0,3)}else{if(1442==r){j=s;s=C;break a}1430==r&&dB(yz|0,2)}s=ba}t[q+32>>2]=1;125==(s|0)?0!=(p|0)&&(JC(125),FC(q,5)):59==(s|0)?FC(q,11):44==(s|0)&&FC(q,5);q|=0;2==(t[q>>2]|0)&&(t[q>>2]=0)}}else{44==(q|0)?FC(h,5):LC(h,q)}}}}}}}}}}if(0!=(t[t[h+(t[m>>2]<<2)+48>>2]>>2]|0)){i=681;break}}668==i&&dB(yz|0,1);h=t[f+(t[e>>2]<<2)+48>>2]|0;i=t[h>>2];if(2==(i|0)){break}else{if(6==(i|0)){h=MC(f,1);i=ba;8==(t[h>>2]|0)&&(i=(f+60|0)>>2,m=t[t[i]+8>>2],0!=(t[m>>2]|0)&&(n=t[K+56>>2],(t[Ry>>2]|0)==(n|0)|(t[Qy>>2]|0)==(n|0)?U(m,Bv|0):(t[Ly>>2]|0)==(n|0)|(t[Py>>2]|0)==(n|0)&&U(m,Xi|0)),U(t[t[i]+8>>2],t[t[h+8>>2]+8>>2]),t[t[i]>>2]=8);NC(f);continue}}OC(f);if(3==(t[h>>2]|0)){h=f;i=g;m=ba;n=t[h+4>>2];if(2==(n|0)||3==(n|0)||7==(n|0)||8==(n|0)||9==(n|0)||12==(n|0)||14==(n|0)){yC(i,h)}else{if(5==(n|0)||13==(n|0)){t[h+28>>2]=1}m=599}599==m&&(0==(PC(8,0)|0)?DC(fu|0):yC(i,h));NC(h);FC(h,2)}h=f;5==(t[t[h+(t[h+44>>2]<<2)+48>>2]>>2]|0)?BC(h,1):(i=t[t[h+(t[h+44>>2]<<2)+48>>2]>>2],11==(i|0)?i=1:2==(i|0)?(i=t[K+56>>2],i=((t[Ly>>2]|0)==(i|0)|(t[Py>>2]|0)==(i|0)?1:0==(QC(h)|0))&1):i=0,0==(i|0)?(t[Lz+8>>2]=1,NC(h)):(BC(h,0),t[Lz+8>>2]=0))}0==(b|0)?(c=t[t[K+40>>2]+8>>2],f=t[K+20>>2],KC(iu|0,(k=j,j+=8,t[k>>2]=c,t[k+4>>2]=f,k)),dB(yz|0,3)):(wC(),j=c)}function RC(b){return 1==(b|0)?0:2==(b|0)?5:3==(b|0)?2:4==(b|0)?3:5==(b|0)?4:7==(b|0)?6:8==(b|0)?7:10==(b|0)?8:11==(b|0)?9:14==(b|0)?10:16==(b|0)?11:18==(b|0)?12:-1}function SC(b){return 1==(b|0)?0:2==(b|0)?3:3==(b|0)?1:5==(b|0)?2:7==(b|0)?4:8==(b|0)?5:10==(b|0)?6:12==(b|0)?7:-1}function MC(b,d){return t[b+(((3-d+t[b+44>>2]|0)>>>0)%3<<2)+48>>2]}function QC(b){0==(b|0)?b=0:(b=t[b+4>>2],b=2==(b|0)||3==(b|0)||7==(b|0)||8==(b|0)||12==(b|0)||14==(b|0)?1:0);return b}function NC(b){var d=b+44|0,c=t[d>>2],c=1<c>>>0?0:c+1|0;t[d>>2]=c;TC(t[b+(c<<2)+48>>2])}function OC(b){var d,c,e=b>>2,f=j;j+=20;var g,h=t[((t[e+11]<<2)+48>>2)+e],i=MC(b,1);d=MC(b,2);c=d>>2;var m=h|0,n=t[m>>2];if(8==(n|0)){i=t[e+20],0!=(i|0)&&3==(t[i+4>>2]|0)&&8==(t[h>>2]|0)&&UC(h,b,1,3)}else{if(3==(n|0)){if(m=t[i>>2],1==(m|0)){0!=(t[e+3]|0)&&((t[Gy>>2]|0)!=(t[K+56>>2]|0)&&(t[e+1]=5),8==(t[c]|0)&&VC(t[e+16],d),WC(b,d))}else{if(0==(QC(b)|0)&&(d=t[e+1],!(8==(d|0)||11==(d|0)))){if((t[Py>>2]|0)!=(t[K+56>>2]|0)){j=f;return}UC(i,b,0,14);j=f;return}if(8==(m|0)){VC(t[e+16],i)}else{e=f|0;d=t[iA>>2]+1|0;t[iA>>2]=d;d=(k=j,j+=4,t[k>>2]=d,k);d=eB(au|0,d);c=d.length;for(m=0;m<c;m++){l[e+m]=d[m]}l[e+m]=0;d=(b+64|0)>>2;V(t[t[d]+8>>2],e);t[t[d]>>2]=8;t[t[d]+4>>2]=-1}e=t[b+4>>2];if((2==(e|0)||3==(e|0)||7==(e|0)||8==(e|0)||11==(e|0)||12==(e|0)||14==(e|0))&&8==(t[i>>2]|0)){e=XC(t[b+4>>2]),d=t[K+56>>2],d=(t[Ly>>2]|0)==(d|0)|(t[Py>>2]|0)==(d|0)?0:(t[Gy>>2]|0)!=(d|0),0!=(e|0)&&UC(i,b,d&1,e)}}}else{if(11==(n|0)||5==(n|0)){h=b+80|0,n=t[h>>2],0==(n|0)?g=568:3!=(t[n+4>>2]|0)&&(g=568),568==g&&(g=t[i>>2],8==(g|0)?0==((12==(t[c+1]|0)||23==(t[c+1]|0)||43==(t[c+1]|0)||52==(t[c+1]|0)||75==(t[c+1]|0)||91==(t[c+1]|0)?1:0)|0)?YC(b,i):UC(i,b,1,21):1==(g|0)&&8==(t[c]|0)&&(0==(t[e+6]|0)?8==(t[d>>2]|0)&&(i=t[K+56>>2],(t[Ly>>2]|0)==(i|0)|(t[Py>>2]|0)==(i|0)?WC(b,d):4==(t[b>>2]|0)?UC(d,b,1,18):0!=(ZC(t[b+4>>2])|0)&&UC(d,b,1,15)):YC(b,d))),(t[Ly>>2]|0)==(t[K+56>>2]|0)&&11==(t[m>>2]|0)&&(b=t[h>>2],0!=(b|0)&&(b=b+4|0,3==(t[b>>2]|0)&&(t[b>>2]=2)))}}}j=f}OC.X=1;function BC(b,d){var c=b>>2,e=0!=(d|0);if(e){var f=t[c+20]}else{t[c]=0,f=t[c+20],t[(b+4|0)>>2]=0==(QC(f)|0)?0:1}for(var g=(b+8|0)>>2,h=g+10;g<h;g++){t[g]=0}0==(f|0)||(t[c+7]=t[f+28>>2]);TC(t[c+12]);TC(t[c+13]);TC(t[c+14]);TC(t[c+15]);e?S(t[c+19]):(TC(t[c+16]),S(t[c+19]),t[c+17]=t[c+18])}BC.X=1;function TC(b){b>>=2;t[b]=0;t[b+1]=-1;t[b+3]=t[K+48>>2];t[b+4]=t[K+24>>2];S(t[b+2])}function PC(b,d){if(!(0==(d|0)|0!=(t[oy+8>>2]|0))){var c;return 0}c=t[K+56>>2];return(t[Py>>2]|0)==(c|0)?c=t[Jz+(RC(b)<<4)>>2]:(t[Ly>>2]|0)==(c|0)?c=t[Zy+(SC(b)<<4)>>2]:c=(t[Gy>>2]|0)==(c|0)?t[Hx+($C(b)<<4)>>2]:t[Tz+(aD(b)<<4)>>2]}function FC(b,d){var c=t[b+(t[b+44>>2]<<2)+48>>2];TC(c);t[c>>2]=d}function CC(){for(var b=0;;){var d=IC();if(0==(L(d)|0)){break}else{b=1}}if(0==(b|0)|l[Oz]^1){return d}var b=t[Vx>>2],c=t[b>>2];if((c+1|0)==(t[b+4>>2]|0)){R(b);var b=c=t[Vx>>2],e=t[c>>2]}else{e=c}c=b+8|0;l[t[c>>2]+e|0]=32;b|=0;e=t[b>>2]+1|0;t[b>>2]=e;l[t[c>>2]+e|0]=0;return d}function bD(){for(var b=IC(),d=IC();;){if(10==(b|0)){if(125==(d|0)){break}}else{if(-1==(b|0)){break}}b=d;d=IC()}}function DC(b){var d=j,c,e=0==(qA(fu|0,b)|0),f=e&0!=(t[Vz>>2]|0),g=t[Lz+28>>2],h=l[b]<<24>>24,i=l[b+1|0]<<24>>24,b=t[K+20>>2],m=0,n=1;a:for(;;){for(var q=0<(n|0),p=m;;){if(!q){var s=p;c=699;break a}var r=CC();if(-1==(r|0)){break a}if(l[Oz]){var p=t[Vx>>2],u=t[p>>2];if((u+1|0)==(t[p+4>>2]|0)){R(p);var p=u=t[Vx>>2],v=t[u>>2]}else{v=u}u=p+8|0;l[t[u>>2]+v|0]=r&255;0!=(r|0)&&(p|=0,v=t[p>>2]+1|0,t[p>>2]=v,l[t[u>>2]+v|0]=0)}if((r|0)==(h|0)){c=692;break}if((r|0)==(i|0)){c=696;break}else{p=r}}if(696==c){if(c=0,n=n-1|0,f){if((t[Lz+28>>2]|0)==(g|0)){m=r}else{c=698;break}}else{m=r}}else{if(692==c){if(c=0,n=n+1|0,f){if((t[Lz+28>>2]|0)==(g|0)){m=r}else{c=694;break}}else{m=r}}}}698==c?(bD(),s=i,c=699):694==c&&(bD(),s=h,c=699);699==c&&-1!=(s|0)?j=d:(d=t[t[K+40>>2]+8>>2],KC(Ev|0,(k=j,j+=12,t[k>>2]=d,t[k+4>>2]=h,t[k+8>>2]=b,k)),e?dB(yz|0,3):dB(yz|0,2))}DC.X=1;function $C(b){return 17==(b|0)?9:1==(b|0)?0:2==(b|0)?4:6==(b|0)?3:9==(b|0)?6:3==(b|0)?2:18==(b|0)?10:13==(b|0)?7:20==(b|0)?11:8==(b|0)?5:15==(b|0)?8:21==(b|0)?12:-1}function aD(b){return 21==(b|0)?13:8==(b|0)?5:9==(b|0)?6:11==(b|0)?7:15==(b|0)?8:6==(b|0)?3:2==(b|0)?4:19==(b|0)?11:3==(b|0)?2:18==(b|0)?10:20==(b|0)?12:1==(b|0)?0:16==(b|0)?9:-1}function ZC(b){return 1==(b|0)||2==(b|0)||3==(b|0)||4==(b|0)||12==(b|0)||14==(b|0)?1:0}function VC(b,d){var c=d>>2,e=b>>2;t[e]=t[c];t[e+1]=t[c+1];t[e+4]=t[c+4];t[e+3]=t[c+3];V(t[e+2],t[t[c+2]+8>>2])}function WC(b,d){if(8==(t[d>>2]|0)){var c=t[K+56>>2];UC(d,b,(2==(t[b+68>>2]|0)?1:0!=(cD(b)|0)?0:1==(t[b>>2]|0))&1,(t[Ly>>2]|0)==(c|0)|(t[Py>>2]|0)==(c|0)?10:(t[Gy>>2]|0)==(c|0)&&13==(t[b+4>>2]|0)?17:6)}}function UC(b,d,c,e){var f,g=j;j+=80;f=g>>2;var h=(0==(c|0)?0:0==(t[K+52>>2]|0))&1;if(8==(t[b>>2]|0)){var i=b+8|0;if(0!=(t[t[i>>2]>>2]|0)&&0!=(PC(e,h)|0)){var c=P(),m=P();sC(g,t[t[i>>2]+8>>2]);t[f+1]=t[b+12>>2];t[f+2]=t[b+16>>2];t[f+4]=h;t[f+9]=dD(e);b=t[K+56>>2];l[g+40|0]=t[((t[Py>>2]|0)==(b|0)?(RC(e)<<4)+Jz+4|0:(t[Ly>>2]|0)==(b|0)?(SC(e)<<4)+Zy+4|0:(t[Gy>>2]|0)==(b|0)?($C(e)<<4)+Hx+4|0:(aD(e)<<4)+Tz+4|0)>>2]&255;eD(c,d);fD(g,e,d,c,m);tC(g);if(!(0==(t[oy+4>>2]|0)|0==(c|0))&&0!=(t[c>>2]|0)){d=P();b=t[c+8>>2];do{if(3==(e|0)){if(f=gB(b,58),0!=(f|0)){for(i=f;;){if(58==l[i]<<24>>24&i>>>0>b>>>0){i=i-1|0}else{break}}f=d;h=b;i=i+1-b|0;S(f);gD(f,h,i)}}else{V(d,b)}}while(0);0!=(t[d>>2]|0)&&(hD(d),e=g+32|0,U(d,t[e>>2]),t[e>>2]=t[d+8>>2],tC(g));Q(d)}Q(c);Q(m)}}j=g}UC.X=1;function YC(b,d){var c=b>>2;if(8==(t[d>>2]|0)){var e=t[c];if(4==(e|0)){UC(d,b,1,18)}else{var f=t[c+1];10==(f|0)?UC(d,b,0,12):4==(f|0)?UC(d,b,2==(t[c+17]|0)&1,4):0!=(ZC(f)|0)&&0==(t[c+9]|0)&&(0!=(cD(b)|0)?(f=t[K+56>>2],(t[Ly>>2]|0)==(f|0)|(t[Py>>2]|0)==(f|0)?UC(d,b,2==(t[c+17]|0)&1,5):2>e>>>0&&UC(d,b,1,9)):2!=(e|0)&&0!=(t[c+3]|0)?(e=1==(e|0)&1,0==(t[c+7]|0)?UC(d,b,e,20):UC(d,b,e,8)):UC(d,b,0,21))}}}YC.X=1;function cD(b){if(8==(t[t[b+60>>2]>>2]|0)){return 1}b=t[b+80>>2];return b=(0==(b|0)?0:0!=(QC(b)|0))&1}function dD(b){var d=t[K+56>>2];return t[((t[Py>>2]|0)==(d|0)?(RC(b)<<4)+Jz+8|0:(t[Ly>>2]|0)==(d|0)?(SC(b)<<4)+Zy+8|0:(t[Gy>>2]|0)==(d|0)?($C(b)<<4)+Hx+8|0:(aD(b)<<4)+Tz+8|0)>>2]}function eD(b,d){var c,e;S(b);var f=t[d+60>>2];8==(t[f>>2]|0)&&V(b,t[t[f+8>>2]+8>>2]);var g=d+80|0;if(0!=(t[g>>2]|0)){var f=P(),g=t[g>>2],h=0==(g|0);a:do{if(!h){var i=b+8|0,m=f|0,n=f+8|0,q=g;for(c=q>>2;;){if(0==(QC(q)|0)){if(q=t[c+1],8==(q|0)||11==(q|0)){e=848}}else{e=848}848==e&&(e=0,V(f,t[i>>2]),S(b),q=t[c+15],8==(t[q>>2]|0)&&(q=t[q+8>>2],0!=(t[q>>2]|0)&&(U(b,t[q+8>>2]),hD(b))),U(b,t[t[t[c+16]+8>>2]+8>>2]),0!=(t[m>>2]|0)&&hD(b),U(b,t[n>>2]));c=t[c+20];if(0==(c|0)){break a}else{q=c,c=q>>2}}}}while(0);Q(f)}}eD.X=1;function fD(b,d,c,e,f){var g=c>>2,b=b>>2,h;if(6==(d|0)||10==(d|0)||15==(d|0)){h=860}else{if(1==(d|0)||2==(d|0)||3==(d|0)||4==(d|0)||5==(d|0)||7==(d|0)||9==(d|0)||11==(d|0)||14==(d|0)||16==(d|0)||17==(d|0)||18==(d|0)||19==(d|0)){h=862}else{if(20!=(d|0)){return}}}860==h&&(h=t[Vx>>2],0!=(t[h>>2]|0)&&(t[b+17]=t[h+8>>2]),h=862);if(862==h){if(0!=(t[e>>2]|0)&&!(0==(cD(c)|0)&&8!=(t[t[g+20]+4>>2]|0))){if(8==(t[t[g+15]>>2]|0)){t[b+15]=dD(1)}else{var i=t[g+20];t[b+15]=dD(XC(0==(i|0)?0:t[i+4>>2]))}t[b+16]=t[e+8>>2]}if(16==(d|0)||7==(d|0)||1==(d|0)){i=t[g+19],0!=(t[i>>2]|0)&&(t[b+14]=t[i+8>>2])}i=t[g+10];if(0!=(i|0)){var m=t[K+56>>2];(t[Qy>>2]|0)==(m|0)|(t[Py>>2]|0)==(m|0)|(t[Ly>>2]|0)==(m|0)&&(t[b+13]=t[Ic+(i<<2)>>2])}if(0!=(cD(c)|0)){var n;if((t[Qy>>2]|0)==(t[K+56>>2]|0)){if(3==(t[c>>2]|0)){var q=Nj|0}else{n=932}}else{n=932}932==n&&(n=t[c+68>>2],q=0==(n|0)?0:t[td+(n<<2)>>2]);t[b+11]=q}if(!(20==(d|0)||18==(d|0)||9==(d|0))){return}}if(0!=(QC(c)|0)){t[b+18]=dD(XC(t[g+1]));d=t[t[t[g+16]+8>>2]+8>>2];if(0==(d|0)){h=883}else{if(0==l[d]<<24>>24){h=883}else{var p=d}}883==h&&(c=MC(c,2),p=8!=(t[c>>2]|0)?d:t[t[c+8>>2]+8>>2]);0==(t[e>>2]|0)?e=p:(V(f,t[e+8>>2]),hD(f),U(f,p),e=t[f+8>>2]);t[b+19]=e}}fD.X=1;function XC(b){return 2==(b|0)?1:13==(b|0)?17:12==(b|0)?16:14==(b|0)?19:4==(b|0)?b:8==(b|0)?11:11==(b|0)?13:3==(b|0)?2:5==(b|0)?6:7==(b|0)?b:0}function hD(b){var d=t[K+56>>2];(t[Ry>>2]|0)==(d|0)|(t[Qy>>2]|0)==(d|0)?U(b,Bv|0):(t[Ly>>2]|0)==(d|0)|(t[Py>>2]|0)==(d|0)&&U(b,Xi|0)}function EC(b){var d,c=b>>2,e=j;j+=28;d=e>>2;var f=MC(b,1);0!=(t[c+7]|0)&&0==(t[c+8]|0)&&(t[c+9]=1);if(0!=(t[f>>2]|0)){var f=t[((t[c+11]<<2)+48>>2)+c],g=e>>2;t[g]=0;t[g+1]=1;t[g+2]=(t[Ry>>2]|0)==(t[K+56>>2]|0)&1;t[g+3]=1;t[g+4]=0;t[g+5]=0;t[g+6]=0;iD(b,e);g=CC();JC(g);if(0!=(t[d+4]|0)){BC(b,0)}else{var h=0==(t[d+3]|0);a:do{if(!h){var i=f|0;if(10==(t[i>>2]|0)){var m=b+16|0;if(0==(t[m>>2]|0)){do{if(0!=(t[d+1]|0)&&!(0==(t[c+3]|0)|40==(g|0))&&!(61==(g|0)&&2!=(t[c+10]|0))){if(0!=(t[c+1]|0)){break a}if(0==(bC(At|0,g,3)|0)){break a}}}while(0);t[i>>2]=8;jD(b);t[m>>2]=1;if(40==(g|0)&&0!=(t[d+5]|0)){j=e;return}t[c+6]=t[d];j=e;return}}}}while(0);f=b+20|0;if(0==(t[f>>2]|0)&&0!=(t[d+1]|0)){t[f>>2]=1;FC(b,1);NC(b);if(4==(t[c]|0)){j=e;return}d=j;c=t[K+20>>2];f=CC();JC(f);if(0!=(bC(zt|0,f,5)|0)){j=d}else{if((t[Ly>>2]|0)==(t[K+56>>2]|0)){var n,c=t[b+(t[b+44>>2]<<2)+48>>2],f=CC();if(0==(pA(f)|0)){if(126==(f|0)||95==(f|0)||36==(f|0)){n=1421}else{var q=f}}else{n=1421}a:do{if(1421==n){if(kD(c,f),82!=(t[c+4>>2]|0)){q=f}else{for(;;){g=CC();if(0==(pA(g)|0)){if(126==(g|0)||95==(g|0)||36==(g|0)){n=1424}else{var p=g}}else{n=1424}1424==n&&(n=0,kD(c,g),p=CC());if(!(46==(p|0)||44==(p|0))){q=p;break a}}}}}while(0);JC(q);FC(b,0);j=d}else{0==(lD(b,e)|0)?(b=t[t[K+40>>2]+8>>2],KC(qt|0,(k=j,j+=8,t[k>>2]=b,t[k+4>>2]=c,k)),dB(yz|0,2)):j=d}}j=e;return}FC(b,0)}}j=e}EC.X=1;function GC(){var b=IC();if(62!=(b|0)){var d=t[K+56>>2];(t[Qy>>2]|0)==(d|0)|(t[Py>>2]|0)==(d|0)?d=1:(d=(t[Ly>>2]|0)==(d|0),d&=1);0!=(d|0)&&1<(b-60|0)>>>0?(JC(b),DC(Ct|0)):60!=(b|0)?JC(b):(b=IC(),61!=(b|0)&&JC(b))}}function HC(b){var d=(t[Qy>>2]|0)==(t[K+56>>2]|0)?IC():CC();if(58==(d|0)){FC(b,6),t[b+12>>2]=0}else{if(JC(d),d=t[K+56>>2],(t[Qy>>2]|0)==(d|0)|(t[Py>>2]|0)==(d|0)&&0!=((12==(t[b+4>>2]|0)||2==(t[b+4>>2]|0)||7==(t[b+4>>2]|0)?1:3==(t[b+4>>2]|0)?(t[Py>>2]|0)==(t[K+56>>2]|0)&1:0)|0)){mD(b,58)}else{var d=t[b+80>>2],c=0==(d|0);!c&&12==(t[d+4>>2]|0)?(d=nD(At|0),59==(d|0)?FC(b,11):44==(d|0)&&FC(b,5)):(17==(t[MC(b,1)+4>>2]|0)||9==(t[MC(b,2)+4>>2]|0)|c^1)&&BC(b,0)}}}HC.X=1;function LC(b,d){var c=b>>2,e=MC(b,1);if(0==(pA(d)|0)&&!(126==(d|0)||95==(d|0)||36==(d|0))){var f=(t[Ly>>2]|0)==(t[K+56>>2]|0);if(!(-1!=(d|0)&f&191<(d&192)>>>0)){e=45==(d|0);if(2>(d-45|0)>>>0){0==(t[c+8]|0)&&(t[c+9]=1);if(!e){return}c=IC();if(62==(c|0)){return}JC(c);return}if(211==(d|0)){if(0!=(t[c+3]|0)){return}e=b|0;if(2!=(t[e>>2]|0)){return}t[c+1]=9;t[e>>2]=0}else{if(64==(d|0)){if(!f){return}oD(b)}else{if(62==(d|0)||33==(d|0)){c=IC();if(61==(c|0)){return}JC(c)}}}return}}f=t[b+(t[b+44>>2]<<2)+48>>2];kD(f,d);0!=(t[f>>2]|0)&&pD(f,b);f=t[c+15];8==(t[f>>2]|0)&&8==(t[t[((t[c+11]<<2)+48>>2)+c]>>2]|0)&&8==(t[e>>2]|0)&&TC(f)}LC.X=1;function oD(b){var d=t[b+(t[b+44>>2]<<2)+48>>2];kD(d,CC());43==(t[d+4>>2]|0)?t[b+4>>2]=7:qD()}function kD(b,d){var c,e,f=t[b+8>>2];TC(b);e=(f|0)>>2;if((t[Qy>>2]|0)==(t[K+56>>2]|0)&126==(d|0)){c=t[e];var g=f+4|0;if((c+1|0)==(t[g>>2]|0)){R(f);var h=t[e]}else{h=c}c=f+8|0;l[t[c>>2]+h|0]=126;h=t[e]+1|0;t[e]=h;l[t[c>>2]+h|0]=0;h=CC()}else{h=d,g=f+4|0,c=f+8|0}c>>=2;for(var i=1;;){var m=t[e];if((m+1|0)==(t[g>>2]|0)){R(f);var n=t[e]}else{n=m}m=h&255;l[t[c]+n|0]=m;h=0==(h|0);h||(n=t[e]+1|0,t[e]=n,l[t[c]+n|0]=0);if(l[Oz]){if(0==(i|0)){i=t[Vx>>2];n=t[i>>2];if((n+1|0)==(t[i+4>>2]|0)){R(i);var i=n=t[Vx>>2],q=t[n>>2]}else{q=n}n=i+8|0;l[t[n>>2]+q|0]=m;h||(m=i|0,h=t[m>>2]+1|0,t[m>>2]=h,l[t[n>>2]+h|0]=0)}h=0}else{h=i}m=IC();if(0!=(oA(m)|0)){i=h,h=m}else{if(95==(m|0)||36==(m|0)){i=h,h=m}else{i=t[K+56>>2];if(!((t[Ly>>2]|0)==(i|0)|(t[Py>>2]|0)==(i|0))){break}if(-1!=(m|0)&191<(m&192)>>>0|46==(m|0)){i=h,h=m}else{break}}}}h=t[e];(h+1|0)!=(t[g>>2]|0)?(f=t[c],e=f+h|0):(R(f),e=t[e],f=t[c],e=f+e|0);l[e]=0;JC(m);a:{e=j;j+=8;var p,g=e+4,f=b+8|0;c=t[f>>2];m=t[c+8>>2];t[e>>2]=0;t[g>>2]=0;if((t[Ly>>2]|0)==(t[K+56>>2]|0)){var s=c;p=1115}else{if(0==(rD(m,g,e)|0)){if(g=t[e>>2],0==(g|0)){s=t[f>>2],p=1115}else{var r=mC(g,t[K+56>>2]);t[b+4>>2]=r}}else{TC(b);if(0==(t[g>>2]|0)){j=e;break a}if(40!=(CC()|0)){j=e;break a}DC(Mt|0);j=e;break a}}1115==p&&(p=mC(t[s+8>>2],t[K+56>>2]),r=t[b+4>>2]=p);t[(b|0)>>2]=-1==(r|0)?8:7;j=e}}kD.X=1;function qD(){var b=CC();40==(b|0)?DC(Mt|0):JC(b)}function jD(b){var d=b+8|0;if(0!=(t[d>>2]|0)){var c=b+4|0;0==(t[c>>2]|0)&&(t[c>>2]=1)}t[d>>2]=1;t[b+12>>2]=1}function pD(b,d){var c=d>>2,e=t[b+4>>2];if(13==(e|0)){t[c+1]=1}else{if(72==(e|0)){t[c+1]=1}else{if(78==(e|0)){t[c+1]=13}else{if(92==(e|0)){t[c+1]=1}else{if(94==(e|0)){sD(d)}else{if(68==(e|0)){sD(d)}else{if(71==(e|0)){t[c+1]=1}else{if(32==(e|0)){t[c]=3}else{if(27==(e|0)){(t[Py>>2]|0)==(t[K+56>>2]|0)&&(t[c+1]=4)}else{if(87==(e|0)){BC(d,0),t[c]=4}else{if(25==(e|0)){(t[Py>>2]|0)==(t[K+56>>2]|0)&&0!=(t[c+2]|0)||(BC(d,0),t[c]=2,t[c+1]=1)}else{if(6==(e|0)){t[c+1]=1}else{if(10==(e|0)){qD(),c=CC(),123==(c|0)?DC(fu|0):JC(c)}else{if(82==(e|0)){for(c=CC();0!=(pA(c)|0)||126==(c|0)||95==(c|0)||36==(c|0);){kD(b,c),c=CC(),c=46==(c|0)||44==(c|0)?CC():c}JC(c)}else{91==(e|0)?t[c+1]=14:1==(e|0)?t[c+10]=1:56==(e|0)?tD(d):63==(e|0)?uD(d,2):46==(e|0)?t[c+1]=1:36==(e|0)?(mD(d,46),FC(d,0)):65==(e|0)?uD(d,3):66==(e|0)?uD(d,4):73==(e|0)?(e=t[K+56>>2],(t[Ly>>2]|0)==(e|0)|(t[Py>>2]|0)==(e|0)||(BC(d,0),t[c]=1,t[c+1]=1)):8==(e|0)?t[c+1]=1:30==(e|0)||31==(e|0)||35==(e|0)||76==(e|0)||99==(e|0)?40==(CC()|0)&&DC(Mt|0):33==(e|0)?t[c+1]=1:75==(e|0)?t[c+1]=12:74==(e|0)?t[c+1]=1:26==(e|0)?(mD(d,46),FC(d,0)):21==(e|0)?t[c+1]=1:42==(e|0)?t[c+1]=1:43==(e|0)?t[d+4>>2]=7:45==(e|0)?uD(d,1):-1==(e|0)?jD(d):0==(e|0)?(qD(),TC(b)):39==(e|0)?t[c+1]=1:12==(e|0)?t[c+1]=2:23==(e|0)?t[c+1]=3:96==(e|0)?t[c+1]=1:97==(e|0)?t[c+1]=1:98==(e|0)?t[c+1]=1:52==(e|0)?vD(d,8):62==(e|0)?vD(d,10):37==(e|0)?sD(d):95==(e|0)?t[c+10]=2:64==(e|0)?t[c+1]=11:11==(e|0)?t[c+1]=1:29==(e|0)?t[c+1]=1:34==(e|0)&&sD(d)}}}}}}}}}}}}}}}pD.X=1;function mD(b,d){var c,e,f=AC(),g=AC();c=(g+8|0)>>2;var h=f|0,i=f+8|0,m=d&255,n=0==(d|0);a:for(;;){var q=CC();do{if(0==(pA(q)|0)){if(126==(q|0)||95==(q|0)||36==(q|0)){e=1248}else{if((q|0)==(d|0)){var p=t[c],s=t[p>>2];(s+1|0)==(t[p+4>>2]|0)&&(R(p),p=s=t[c],s=t[s>>2]);l[t[p+8>>2]+s|0]=m;if(n){continue a}p=t[c]|0;s=t[p>>2]+1|0;t[p>>2]=s;l[t[t[c]+8>>2]+s|0]=0}else{if(60==(q|0)){DC(Ct|0);continue a}8==(t[h>>2]|0)&&(wD(b,g),TC(g))}}}else{e=1248}}while(0);1248==e&&(e=0,kD(f,q),8==(t[h>>2]|0)?U(t[c],t[t[i>>2]+8>>2]):(wD(b,g),TC(g)));if(-1==(q|0)||123==(q|0)){break}}JC(q);xC(g);xC(f)}mD.X=1;function sD(b){t[b+4>>2]=6;nD(Ft|0)}function uD(b,d){if(0!=(cD(b)|0)){if((t[Qy>>2]|0)==(t[K+56>>2]|0)){var c=CC();58==(c|0)?BC(b,0):JC(c);t[b+72>>2]=d}t[b+68>>2]=d}}function tD(b){var d,c,e,f,g,h;c=MC(b,1);h=t[b+(t[b+44>>2]<<2)+48>>2]>>2;var i=t[h+2],m=CC();7==(t[c>>2]|0)?(c=t[c+4>>2],23==(c|0)||75==(c|0)||91==(c|0)?d=m:f=1275):f=1275;a:do{if(1275==f){if(40==(m|0)){41!=(IC()|0)?(DC(Mt|0),d=IC()):(d=(i|0)>>2,c=t[d],(c+1|0)==(t[i+4>>2]|0)?(R(i),e=t[d]):e=c,c=i+8|0,l[t[c>>2]+e|0]=32,e=t[d]+1|0,t[d]=e,l[t[c>>2]+e|0]=0,d=CC(),40==(d|0)&&(U(i,Mt|0),d=40))}else{do{if(0==(pA(m)|0)&&!(126==(m|0)||95==(m|0)||36==(m|0))){if(0==(bC(Lt|0,m,17)|0)){d=m;break a}d=(i|0)>>2;f=t[d];g=(i+4|0)>>2;(f+1|0)==(t[g]|0)?(R(i),c=t[d]):c=f;f=(i+8|0)>>2;l[t[f]+c|0]=32;c=t[d]+1|0;t[d]=c;for(l[t[f]+c|0]=0;;){var n=t[d];(n+1|0)==(t[g]|0)&&(R(i),n=t[d]);l[t[f]+n|0]=m&255;0!=(m|0)&&(n=t[d]+1|0,t[d]=n,l[t[f]+n|0]=0);n=IC();if(0==(bC(Lt|0,n,17)|0)){break}else{m=n}}m=t[d];(m+1|0)==(t[g]|0)?(R(i),i=t[d]):i=m;l[t[f]+i|0]=0;d=n;break a}}while(0);e=(i|0)>>2;c=(i+4|0)>>2;d=(i+8|0)>>2;for(var q=1,p=m;;){if(0==(L(p)|0)?(0!=(q|0)&&(g=t[e],(g+1|0)==(t[c]|0)&&(R(i),g=t[e]),l[t[d]+g|0]=32,g=t[e]+1|0,t[e]=g,l[t[d]+g|0]=0),g=t[e],(g+1|0)==(t[c]|0)&&(R(i),g=t[e]),l[t[d]+g|0]=p&255,0!=(p|0)&&(g=t[e]+1|0,t[e]=g,l[t[d]+g|0]=0),p=0):p=1,g=IC(),0==(bC(It|0,g,3)|0)&-1!=(g|0)){q=p,p=g}else{break}}p=t[e];(p+1|0)==(t[c]|0)?(R(i),c=t[e]):c=p;l[t[d]+c|0]=0;d=g}}}while(0);JC(d);t[h]=8;t[h+1]=-1;jD(b)}tD.X=1;function vD(b,d){var c=b>>2;t[c+1]=d;if(!(8==(d|0)&&(t[Py>>2]|0)!=(t[K+56>>2]|0))){var e=t[((t[c+11]<<2)+48>>2)+c];xD(e,CC());t[e>>2]=8;t[c+2]=1;t[c+3]=1}}function xD(b,d){var c,e,f=t[b+8>>2];TC(b);e=(f|0)>>2;var g=f+4|0;c=(f+8|0)>>2;for(var h=d;0!=(oA(h)|0)||95==(h|0)||36==(h|0)||46==(h|0);){var i=t[e];(i+1|0)==(t[g>>2]|0)&&(R(f),i=t[e]);l[t[c]+i|0]=h&255;0!=(h|0)&&(h=t[e]+1|0,t[e]=h,l[t[c]+h|0]=0);h=IC()}i=t[e];(i+1|0)!=(t[g>>2]|0)?(c=t[c],c=c+i|0):(R(f),e=t[e],c=t[c],c=c+e|0);l[c]=0;JC(h)}xD.X=1;function nD(b){for(var d;;){var c=IC();if(-1==(c|0)||0==(c|0)){d=1351;break}if(0!=(mA(b,c)|0)){d=1350;break}}if(1350==d||1351==d){return c}}function AC(){var b=zC(20);t[b+8>>2]=P();TC(b);return b}function wD(b,d){var c,e=d+8|0,f=t[e>>2];c=(b+76|0)>>2;if(0==(t[f>>2]|0)){e=f}else{var g=t[c],h=t[g>>2];0==(h|0)?e=f:((h+1|0)==(t[g+4>>2]|0)?(R(g),f=h=t[c],h=t[h>>2]):f=g,l[t[f+8>>2]+h|0]=44,h=t[c]|0,f=t[h>>2]+1|0,t[h>>2]=f,l[t[t[c]+8>>2]+f|0]=0,e=t[e>>2])}U(t[c],t[e+8>>2])}function iD(b,d){var c,e,f,g,h,i,m=t[b+(t[b+44>>2]<<2)+48>>2];l[Oz]=1;f=t[Vx>>2];S(f);e=t[f>>2];(e+1|0)==(t[f+4>>2]|0)?(R(f),f=e=t[Vx>>2],g=t[e>>2]):g=e;e=f+8|0;l[t[e>>2]+g|0]=40;f|=0;g=t[f>>2]+1|0;t[f>>2]=g;l[t[e>>2]+g|0]=0;h=(d+24|0)>>2;t[h]=1;g=(d+4|0)>>2;f=(d+8|0)>>2;e=(d+12|0)>>2;var n=d+16|0;c=(m|0)>>2;var q=m+4|0,p=d+20|0,s=d|0,r=1,u=1,v=0;a:for(;;){var w=CC(),C=t[Vx>>2],A=t[C>>2];if((A+1|0)==(t[C+4>>2]|0)){R(C);var C=A=t[Vx>>2],I=t[A>>2]}else{I=A}A=C+8|0;l[t[A>>2]+I|0]=w&255;do{if(0==(w|0)){i=1395}else{var I=C|0,M=t[I>>2]+1|0;t[I>>2]=M;l[t[A>>2]+M|0]=0;if(38==(w|0)||42==(w|0)){t[s>>2]=1;t[f]=0;0==(v|0)&&(t[g]=0);TC(m);var B=u,G=v}else{if(44==(w|0)){t[e]=0,0==(t[f]|0)?(B=u,G=v):(t[h]=t[h]+1|0,B=u,G=0)}else{if(61==(w|0)){if(t[f]=0,t[e]=0,0==(r|0)){B=u,G=v}else{i=1378;break a}}else{if(91==(w|0)){t[f]=0,DC(Fq|0),B=u,G=v}else{if(60==(w|0)){t[f]=0,GC(),B=u,G=v}else{if(41==(w|0)){0!=(r|0)&&(t[h]=0),B=u-1|0,G=v}else{if(40==(w|0)){t[f]=0;if(0!=(r|0)){i=1385;break a}10!=(t[c]|0)?B=u+1|0:(B=CC(),42!=(B|0)?(JC(B),JC(40),t[p>>2]=1):(DC(Mt|0),B=CC(),40==(B|0)?DC(Mt|0):JC(B)),B=u);G=v}else{64==(w|0)?(t[Ly>>2]|0)!=(t[K+56>>2]|0)?i=1395:(oD(b),B=u,G=v):58==(w|0)?(t[f]=0,B=u,G=v):46==(w|0)?(t[e]=0,B=IC(),46!=(B|0)?(JC(B),t[f]=0):(B=IC(),46==(B|0)?U(t[Vx>>2],pt|0):(JC(B),t[f]=0)),B=u,G=v):i=1395}}}}}}}}}while(0);b:do{if(1395==i){i=0;do{if(0==(pA(w)|0)&&!(126==(w|0)||95==(w|0)||36==(w|0))){t[g]=0;t[f]=0;t[e]=0;t[n>>2]=1;B=u;G=v;break b}}while(0);var Z=v+1|0;1<Z>>>0&&(t[f]=0);kD(m,w);B=t[c];8==(B|0)?0!=(t[e]|0)&&(t[c]=10):7==(B|0)&&(B=t[q>>2],13==(B|0)||97==(B|0)||(t[f]=0,t[e]=0));B=u;G=Z}}while(0);u=t[p>>2];Z=0==(B|0);if(0!=(u|0)|Z){var X=u;i=1408;break}if(0!=(t[f]|0)){r=0,u=B,v=G}else{if(0==(t[e]|0)){X=0;i=1408;break}else{r=0,u=B,v=G}}}a:do{if(1378==i){t[g]=0,yD(b)}else{if(1385==i){t[e]=0,JC(40),S(C),yD(b),zD(t[Vx>>2])}else{if(1408==i&&!(0!=(X|0)|Z)){for(G=B;;){if(DC(Mt|0),G=G-1|0,0==(G|0)){break a}}}}}}while(0);0==(t[e]|0)&&TC(m);i=t[Vx>>2];m=t[i>>2];(m+1|0)==(t[i+4>>2]|0)&&(R(i),i=m=t[Vx>>2],m=t[m>>2]);l[t[i+8>>2]+m|0]=0;0!=(t[f]|0)&&S(i);l[Oz]=0}iD.X=1;function lD(b,d){var c,e=t[b+(t[b+44>>2]<<2)+48>>2],f=d+24|0,g=t[f>>2],h=e+4|0,i=e|0,m=d+8|0,n=e+8|0,q=CC(),p=0,s=0;a:for(;;){do{if(123==(q|0)){c=1463;break a}else{if(91==(q|0)){DC(Fq|0);var r=s,u=g,v=p}else{if(58==(q|0)){r=e;for(u=ba;;){var w=CC();b:for(;;){do{if(0==(pA(w)|0)){if(36==(w|0)||95==(w|0)||126==(w|0)){u=1494}else{if(60==(w|0)){u=1496;break b}else{if(58!=(w|0)){var C=w;break b}}}}else{58!=(w|0)&&(u=1494)}}while(0);1494==u&&(u=0,kD(r,w));w=CC()}1496==u&&(u=0,DC(Ct|0),C=CC());40==(C|0)?(DC(Mt|0),w=CC()):w=C;if(44!=(w|0)){break}}JC(w);r=s;u=g;v=p}else{if(40==(q|0)){DC(Mt|0),r=0==(s|0)?0:s+1|0,u=g,v=p}else{if(59==(q|0)){if(0==(g|0)|2>s>>>0){c=1467;break a}var A=g-1|0,I=0==(A|0)&1,M=p,B=s;c=1481}else{if(61==(q|0)){c=1462;break a}else{if(125==(q|0)){c=1464;break a}else{if(41==(q|0)){r=s,u=g,v=p}else{if(0==(pA(q)|0)&&!(126==(q|0)||95==(q|0)||36==(q|0))){r=s,u=g,v=p}else{kD(e,q);var G=t[h>>2];if(0==(G|0)){qD(),r=s,u=g,v=p}else{if(10==(G|0)||12==(G|0)||24==(G|0)||25==(G|0)||32==(G|0)||38==(G|0)||51==(G|0)||52==(G|0)||53==(G|0)||54==(G|0)||56==(G|0)||58==(G|0)||63==(G|0)||65==(G|0)||66==(G|0)||73==(G|0)||79==(G|0)||87==(G|0)||88==(G|0)||94==(G|0)||95==(G|0)){var Z=q;break a}else{if(81==(G|0)){qD(),r=s,u=g,v=p}else{if(86==(G|0)){r=s,u=g,v=p}else{if(13==(G|0)||97==(G|0)){r=t[Vx>>2],u=t[r>>2],0!=(u|0)&&((u+1|0)==(t[r+4>>2]|0)?(R(r),r=u=t[Vx>>2],v=t[u>>2]):v=u,u=r+8|0,l[t[u>>2]+v|0]=32,v=r|0,G=t[v>>2]+1|0,t[v>>2]=G,l[t[u>>2]+G|0]=0,U(r,t[t[n>>2]+8>>2])),r=s,u=g,v=p}else{if(0==(t[i>>2]|0)){r=s,u=g,v=p}else{if(0==(t[m>>2]|0)){Z=q;break a}M=0==(t[f>>2]|0);I=c=M&1;M=M?1:p;A=g;B=(c^1)+s|0;c=1481}}}}}}}}}}}}}}}}while(0);if(1481==c){if(c=0,0==(I|0)){r=B,u=A,v=M}else{var X=M,ga=q;c=1483;break}}q=CC();if(-1==(q|0)){X=v;ga=-1;c=1483;break}else{p=v,g=u,s=r}}1463==c?(JC(123),X=p,ga=123,c=1483):1462==c?(JC(61),X=p,ga=61,c=1483):1467==c?(JC(59),X=p,ga=59,c=1483):1464==c&&(JC(125),X=p,ga=125,c=1483);if(1483==c){if(0!=(X|0)){Z=ga}else{return FC(b,0),Z=-1!=(ga|0),Z&1}}e=AC();f=b+44|0;VC(e,t[b+(t[f>>2]<<2)+48>>2]);BC(b,0);f=t[b+(t[f>>2]<<2)+48>>2];VC(f,e);xC(e);pD(f,b);Z=-1!=(Z|0);return Z&1}lD.X=1;function yD(b){if(8==(t[MC(b,2)>>2]|0)){var d=b+44|0,c=t[d>>2];t[d>>2]=0==(c|0)?2:c-1|0;FC(b,0)}DC(Mt|0)}function AD(b,d){var c,e,f=j;j+=4;var g;e=f>>2;var h=d,i=b;a:for(;;){t[e]=i;i=l[i];if(0==i<<24>>24){var m=h;g=1561;break}i=0==(L(i&255)|0);b:do{if(!i){for(;;){var n=t[e]+1|0;t[e]=n;if(0==(L(l[n]&255)|0)){break b}}}}while(0);do{if(6==(h|0)||7==(h|0)){for(var q=t[e];;){var p=l[q];if(59==p<<24>>24||0==p<<24>>24){break}var s=q+1|0,q=t[e]=s}s=59==p<<24>>24?0:h}else{if(10==(h|0)){m=10;g=1562;break a}else{if(1==(h|0)){i=t[e],47!=l[i]<<24>>24?(s=1,q=i):(c=42!=l[i-1|0]<<24>>24&1,g=1558)}else{if(5==(h|0)){for(q=t[e];;){var r=l[q];if(123==r<<24>>24||0==r<<24>>24){break}s=q+1|0;q=t[e]=s}s=123==r<<24>>24?0:5}else{if(0==(h|0)){if(0!=(oA(l[t[e]]&255)|0)){c=BD(f,1),g=1558}else{if(i=t[e],n=l[i],46==n<<24>>24){c=BD(f,0),g=1558}else{if(35==n<<24>>24){c=BD(f,2),g=1558}else{if(64==n<<24>>24){t[e]=i+1|0;g=P();i=0==(L(l[t[e]]&255)|0);c=(g|0)>>2;var n=t[c],u=g+4|0,v=(n+1|0)==(t[u>>2]|0);b:do{if(i){for(var w=g+8|0,C=v,A=n;;){C&&(R(g),A=t[c]);l[t[w>>2]+A|0]=l[t[e]];A=t[e];0!=l[A]<<24>>24&&(A=t[c]+1|0,t[c]=A,l[t[w>>2]+A|0]=0,A=t[e]);C=A+1|0;t[e]=C;var A=t[c],I=(A+1|0)==(t[u>>2]|0);if(0==(L(l[C]&255)|0)){C=I}else{var M=I,B=A;break b}}}else{M=v,B=n}}while(0);M?(R(g),c=t[c]):c=B;i=g+8|0;l[t[i>>2]+c|0]=0;c=t[i>>2];c=0==(qA(c,ur|0)|0)?5:0==(qA(c,Yv|0)|0)?6:0==(qA(c,wl|0)|0)?7:0==(qA(c,ak|0)|0)?8:0==(qA(c,qi|0)|0)?9:0;Q(g);g=1558}else{42==n<<24>>24?(c=47==l[i-1|0]<<24>>24&1,g=1558):(s=0,q=i)}}}}}else{8==(h|0)||9==(h|0)||4==(h|0)?(i=t[e],n=l[i],39==n<<24>>24?(c=2,g=1558):125==n<<24>>24?(s=0,q=i):(c=34==n<<24>>24?3:h,g=1558)):3==(h|0)?(i=t[e],34!=l[i]<<24>>24?(s=3,q=i):(c=92==l[i-1|0]<<24>>24?3:4,g=1558)):2==(h|0)?(i=t[e],39!=l[i]<<24>>24?(s=2,q=i):(c=92==l[i-1|0]<<24>>24?2:4,g=1558)):(c=h,g=1558)}}}}}}while(0);1558==g&&(g=0,s=c,q=t[e]);if(0==(q|0)){m=s;g=1563;break}else{h=s,i=q+1|0}}if(1563==g||1561==g||1562==g){return j=f,m}}AD.X=1;function BD(b,d){var c,e=b>>2,f,g=P();c=(g|0)>>2;var h=g+4|0,i=g+8|0,m=t[e];a:for(;;){if(0==(oA(l[m]&255)|0)){if(0!=(L(l[m]&255)|0)){var n=1}else{n=l[m],n=95==n<<24>>24||45==n<<24>>24||43==n<<24>>24||62==n<<24>>24||123==n<<24>>24||46==n<<24>>24||44==n<<24>>24||58==n<<24>>24||42==n<<24>>24||35==n<<24>>24?1:0}}else{n=1}var n=0==(n|0),q=l[m];do{if(n){if(0==q<<24>>24){f=1568}else{f=1577;break a}}else{if(0==q<<24>>24){f=1568}else{if(44==q<<24>>24){f=1570;break a}else{if(123==q<<24>>24){f=1571;break a}else{var p=m}}}}}while(0);if(1568==f&&(f=0,p=eC(),0==(p|0))){f=1569;break}m=t[c];(m+1|0)==(t[h>>2]|0)&&(R(g),m=t[c]);l[t[i>>2]+m|0]=l[p];0!=l[p]<<24>>24&&(m=t[c]+1|0,t[c]=m,l[t[i>>2]+m|0]=0);m=p+1|0}if(1570==f){return CD(g,d),t[e]=m+1|0,0}if(1571==f){return CD(g,d),t[e]=m+1|0,4}if(1569==f){return CD(g,d),t[e]=0,10}if(1577==f){return CD(g,d),t[e]=m,0}}BD.X=1;function CD(b,d){0==(d|0)&&DD(b);var c=b|0,e=t[c>>2];(e+1|0)==(t[b+4>>2]|0)?(R(b),c=t[c>>2]):c=e;l[t[b+8>>2]+c|0]=0;jC(b,Hz|0,d);S(b);Q(b)}function ED(){var b,d=zC(24);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=1;t[b+3]=P();t[b+4]=P();t[b+5]=P();return d}function FD(b,d){var c=b+4|0;if((t[c>>2]|0)!=(d|0)){for(;!(GD(b),(t[c>>2]|0)==(d|0));){}}}function HD(b){Q(t[b+12>>2]);Q(t[b+16>>2]);Q(t[b+20>>2]);vB(b)}function ID(b){for(var d=b|0,c=0;;){var e=t[d>>2];15==(e|0)?(GD(b),c=c+1|0):4==(e|0)?(GD(b),c=c-1|0):JD(b);if(0==(c|0)){break}}}function KD(b){var d,c;if(0==(LD(b)|0)){return 0}for(c=(b|0)>>2;!(MD(b),GD(b),7==(t[c]|0)&&GD(b),0==(LD(b)|0));){}d=(b+4|0)>>2;0==(t[d]|0)&&(GD(b),22==(t[c]|0)&&MD(b),GD(b));var e=t[c];if(16==(e|0)){e=b|0;if(5!=(t[e>>2]|0)){for(;!(GD(b),5==(t[e>>2]|0));){}}GD(b);e=t[c]}6==(e|0)&&ND(b);e=t[d];4==(e|0)?(GD(b),GD(b),d=t[d]):d=e;39==(d|0)&&(GD(b),22==(t[c]|0)&&GD(b));a:{var f;c=(b+4|0)>>2;e=t[c];if(d=34==(e|0)){GD(b),e=t[c]}if(13==(e|0)||15==(e|0)||22==(e|0)||36==(e|0)||39==(e|0)||41==(e|0)||46==(e|0)){f=1;for(d=e;;){if(36==(d|0)){d=b;GD(d);for(var e=d+4|0,g=d|0;;){var h=t[e>>2];if(15==(h|0)||41==(h|0)){break}11==(t[g>>2]|0)&&OD(d);GD(d);6==(t[g>>2]|0)&&ND(d)}}else{f=18==(d|0)?f-1|0:6==(d|0)||12==(d|0)||25==(d|0)||27==(d|0)||32==(d|0)?f+1|0:f}GD(b);if(0>=(f|0)){break}d=t[c]}}else{c=17==(t[b>>2]|0);if(d){c&&(f=1714)}else{if(c){f=1714}else{break a}}1714==f&&GD(b);GD(b)}}return 1}KD.X=1;function LD(b){var d=b+4|0;26==(t[d>>2]|0)&&GD(b);var c=b|0;if(11==(t[c>>2]|0)){b=1}else{if(d=t[d>>2],4==(d|0)){b=1}else{if(30!=(d|0)&&43!=(d|0)){b=0}else{return GD(b),22==(t[c>>2]|0)&1}}}return b}function MD(b){var d,c,e,f=j;j+=80;e=f>>2;if(0!=(t[Cz+16>>2]|0)&&(c=b+8|0,0!=(t[oy+8>>2]|t[c>>2]|0))){var g=b+12|0;sC(f,t[t[g>>2]+8>>2]);t[e+4]=0==(t[c>>2]|0)&1;t[e+9]=t[Cz+24>>2];l[f+40|0]=t[Cz+20>>2]&255;t[e+15]=t[Cz+8>>2];c=b+16|0;t[e+16]=t[t[c>>2]+8>>2];tC(f);if(0!=(t[oy+4>>2]|0)){var h=PD(t[t[c>>2]+8>>2]);c=(h|0)>>2;d=t[c];if((d+1|0)==(t[h+4>>2]|0)){R(h);var i=t[c]}else{i=d}d=(h+8|0)>>2;l[t[d]+i|0]=46;i=t[c]+1|0;t[c]=i;l[t[d]+i|0]=0;U(h,t[t[g>>2]+8>>2]);t[e+8]=t[d];tC(f);Q(h)}}V(t[b+20>>2],t[t[b+12>>2]+8>>2]);j=f}MD.X=1;function ND(b){GD(b);var d=t[b>>2];(1==(d|0)||19==(d|0))&&GD(b);JD(b)}function GD(b){var d,c;d=(b|0)>>2;t[d]=0;var e=b+4|0;t[e>>2]=-1;b=(b+12|0)>>2;for(S(t[b]);;){var f=T();if(92==(f|0)){c=1761;break}else{if(34==(f|0)){c=1765;break}else{if(39==(f|0)){c=1766;break}else{if(36==(f|0)){c=1729;break}else{if(41==(f|0)){c=1727;break}else{if(32==(f|0)||10==(f|0)||9==(f|0)){continue}else{if(62==(f|0)){c=1753;break}else{if(46==(f|0)){c=1730;break}else{if(63==(f|0)||58==(f|0)){c=1742;break}else{if(93==(f|0)){c=1726;break}else{if(33==(f|0)){c=1724;break}else{if(125==(f|0)){c=1725;break}else{if(126==(f|0)){c=1734;break}else{if(44==(f|0)){c=1728;break}else{if(-1==(f|0)){c=1722;break}else{if(59==(f|0)){c=1723;break}else{if(40==(f|0)){c=1733;break}else{if(91==(f|0)){c=1732;break}else{if(43==(f|0)||42==(f|0)||94==(f|0)||61==(f|0)){c=1735;break}else{if(47==(f|0)){c=1757;break}else{if(60==(f|0)){c=1749;break}else{if(123==(f|0)){c=1731;break}else{if(45!=(f|0)){c=1767;break}}}}}}}}}}}}}}}}}}}}}}}var g=T();if(62==(g|0)){c=1737;break}else{if(45!=(g|0)){c=1739;break}}QD(10)}if(1739==c){0==(L(g)|0)&&W(g),t[d]=17}else{if(1761==c){var h=T();92!=(h|0)&&0==(L(h)|0)&&W(h);t[d]=17}else{if(1765==c){t[d]=22,RD(t[b])}else{if(1766==c){t[d]=2,37==(T()|0)&&SD(),39!=(T()|0)&&QD(10)}else{if(1729==c){t[d]=10}else{if(1727==c){t[d]=5}else{if(1753==c){h=T(),1<(h-61|0)>>>0&&0==(L(h)|0)&&W(h),t[d]=17}else{if(1730==c){t[d]=9}else{if(1742==c){h=T(),61==(h|0)?t[d]=17:(0==(L(h)|0)&&W(h),t[d]=58==(f|0)?6:19)}else{if(1726==c){t[d]=4}else{if(1724==c){t[d]=1}else{if(1725==c){t[d]=3}else{if(1734==c){t[d]=23}else{if(1767==c){if(0!=(pA(f)|0)){TD(t[b],f),h=UD(t[b],t[Oy>>2]),t[e>>2]=h,t[d]=-1==(h|0)?11:12}else{if(10>(f-48|0)>>>0){h=VD(f),U(t[b],t[h+8>>2]),Q(h),t[d]=13}else{if(124==(f|0)||64==(f|0)||38==(f|0)||35==(f|0)){b=t[b];c=(b|0)>>2;g=b+4|0;for(e=(b+8|0)>>2;;){if(h=t[c],(h+1|0)==(t[g>>2]|0)&&(R(b),h=t[c]),l[t[e]+h|0]=f&255,0!=(f|0)&&(h=t[c]+1|0,t[c]=h,l[t[e]+h|0]=0),h=T(),32<(h|0)){f=h}else{break}}f=t[c];(f+1|0)==(t[g>>2]|0)&&(R(b),f=t[c]);l[t[e]+f|0]=0;0==(L(h)|0)&&W(h);t[d]=17}else{t[d]=0}}}}else{1728==c?t[d]=7:1722==c?dB(tz|0,1):1723==c?t[d]=20:1733==c?t[d]=16:1732==c?t[d]=15:1735==c?t[d]=17:1757==c?(h=T(),!(61==(h|0)||47==(h|0))&&0==(L(h)|0)&&W(h),t[d]=17):1737==c?t[d]=8:1749==c?(h=T(),1<(h-61|0)>>>0&&0==(L(h)|0)&&W(h),t[d]=17):1731==c&&(t[d]=14)}}}}}}}}}}}}}}}GD.X=1;function OD(b){var d,c,e,f=j;j+=80;e=f>>2;if(0!=(t[Cz+32>>2]|0)&0!=(t[oy+8>>2]|0)){c=t[t[b+12>>2]+8>>2];var g=P();sC(f,c);t[e+4]=1;t[e+9]=t[Cz+40>>2];l[f+40|0]=t[Cz+36>>2]&255;V(g,t[t[b+16>>2]+8>>2]);c=(g|0)>>2;d=t[c];if((d+1|0)==(t[g+4>>2]|0)){R(g);var h=t[c]}else{h=d}d=(g+8|0)>>2;l[t[d]+h|0]=46;h=t[c]+1|0;t[c]=h;l[t[d]+h|0]=0;U(g,t[t[b+20>>2]+8>>2]);t[e+15]=t[Cz+24>>2];t[e+16]=t[d];tC(f);Q(g)}j=f}OD.X=1;function JD(b){var d,c,e=ED();c=e>>2;WD(e,b);GD(b);d=(b|0)>>2;6==(t[d]|0)&&(GD(e),GD(b));var f=t[c+1];if(35==(f|0)){if(11!=(t[d]|0)&&11!=(t[b+4>>2]|0)){HD(e);return}GD(b)}else{if(5==(f|0)||14==(f|0)||20==(f|0)){WD(e,b),GD(b)}11==(t[c]|0)&&(15==(t[d]|0)?ID(b):0==(qA(fi|0,t[t[c+3]+8>>2])|0)&&GD(b))}HD(e)}function WD(b,d){var c=d>>2,e=b>>2;t[e]=t[c];t[e+1]=t[c+1];t[e+2]=t[c+2];V(t[e+3],t[t[c+3]+8>>2]);V(t[e+4],t[t[c+4]+8>>2]);V(t[e+5],t[t[c+5]+8>>2])}function QD(b){for(;;){var d=T();if(-1==(d|0)|(d|0)==(b|0)){break}}}function RD(b){var d,c,e,f,g,h,i,m=P(),n=P();h=(n+8|0)>>2;g=(m+8|0)>>2;f=(m|0)>>2;var q=m+4|0;e=(b+8|0)>>2;c=(b|0)>>2;var p=b+4|0;d=(n|0)>>2;var s=n+4|0,r=0,u=0,v=0;a:for(;;){var v=91==(v|0),w=0;b:for(;;){for(var C=0==(r|0),A=w;;){if(0!=(A|0)){break a}A=T();if(10==(A|0)){i=1866;break b}else{if(37==(A|0)){i=1874;break b}else{if(-1==(A|0)){A=1;continue}else{if(34!=(A|0)){var I=u,M=r,B=A;break b}}}}if(C){r=0;w=1;continue b}if(A=0==(qA(t[h],t[g])|0)){A&=1}else{I=u;M=r;B=34;break b}}}b:do{if(1866==i){if(i=0,C||S(n),v?(S(m),S(n),w=t[f],(w+1|0)==(t[q>>2]|0)&&(R(m),w=t[f]),l[t[g]+w|0]=93,w=t[f]+1|0,t[f]=w,l[t[g]+w|0]=0,gD(m,t[e],t[c]-1|0),S(b),A=w=1):(w=r,A=u),0==(w|0)|0==(A|0)){I=A,M=w,B=10}else{for(;;){var G=T();if(0==(L(G)|0)){I=A;M=w;B=G;break b}}}}else{1874==i&&(i=0,I=u,M=r,B=SD())}}while(0);u=t[c];(u+1|0)==(t[p>>2]|0)?(R(b),v=t[c]):v=u;u=B&255;l[t[e]+v|0]=u;v=0==(B|0);v||(r=t[c]+1|0,t[c]=r,l[t[e]+r|0]=0);0==(M|0)?r=0:(r=t[d],(r+1|0)==(t[s>>2]|0)&&(R(n),r=t[d]),l[t[h]+r|0]=u,v||(u=t[d]+1|0,t[d]=u,l[t[h]+u|0]=0),u=t[d],(u+1|0)==(t[s>>2]|0)&&(R(n),u=t[d]),l[t[h]+u|0]=0,r=M);u=I;v=B}d=t[c];(d+1|0)!=(t[p>>2]|0)?(e=t[e],e=e+d|0):(R(b),b=t[c],e=t[e],e=e+b|0);l[e]=0;Q(n);Q(m)}RD.X=1;function TD(b,d){var c,e;e=(b|0)>>2;var f=b+4|0;c=(b+8|0)>>2;for(var g=d;;){var h=t[e];(h+1|0)==(t[f>>2]|0)&&(R(b),h=t[e]);l[t[c]+h|0]=g&255;0!=(g|0)&&(g=t[e]+1|0,t[e]=g,l[t[c]+g|0]=0);h=T();if(0!=(oA(h)|0)|95==(h|0)){g=h}else{break}}g=t[e];(g+1|0)==(t[f>>2]|0)?(R(b),e=t[e]):e=g;l[t[c]+e|0]=0;0==(L(h)|0)&&W(h)}TD.X=1;function VD(b){var d,c=P();d=c>>2;b=XD(b);V(c,t[b+8>>2]);Q(b);b=T();if(46==(b|0)){var e=XD(0),b=(c|0)>>2,f=t[b];if((f+1|0)==(t[d+1]|0)){R(c);var g=t[b]}else{g=f}f=c+8|0;l[t[f>>2]+g|0]=46;g=t[b]+1|0;t[b]=g;l[t[f>>2]+g|0]=0;U(c,t[e+8>>2]);Q(e);f=T()}else{f=b}if(101==(rA(f)|0)){e=XD(0);b=(c|0)>>2;g=t[b];if((g+1|0)==(t[d+1]|0)){R(c);var h=t[b]}else{h=g}g=c+8|0;l[t[g>>2]+h|0]=f&255;0!=(f|0)&&(f=t[b]+1|0,t[b]=f,l[t[g>>2]+f|0]=0);U(c,t[e+8>>2]);Q(e)}else{0==(L(f)|0)&&W(f)}e=c|0;b=t[e>>2];if((b+1|0)!=(t[d+1]|0)){return d=t[(c+8|0)>>2],d=d+b|0,l[d]=0,c}R(c);b=t[e>>2];d=t[(c+8|0)>>2];d=d+b|0;l[d]=0;return c}VD.X=1;function XD(b){var d,c,e=P(),b=0==(b|0)?T():b;if(45==(b|0)){b=(e|0)>>2;d=t[b];if((d+1|0)==(t[e+4>>2]|0)){R(e);var f=t[b]}else{f=d}d=e+8|0;l[t[d>>2]+f|0]=45;f=t[b]+1|0;t[b]=f;l[t[d>>2]+f|0]=0;var g=T()}else{g=10>(b-48|0)>>>0?b:T()}d=(e|0)>>2;f=e+4|0;for(b=(e+8|0)>>2;;){if(-1==(g|0)){c=1953;break}var h=t[d],i=(h+1|0)==(t[f>>2]|0);if(!(95==(g|0)|10>(g-48|0)>>>0)){c=1960;break}if(i){R(e);var m=t[d]}else{m=h}l[t[b]+m|0]=g&255;0!=(g|0)&&(g=t[d]+1|0,t[d]=g,l[t[b]+g|0]=0);g=T()}if(1953==c){var n=t[d];if((n+1|0)==(t[f>>2]|0)){n=-1}else{return c=t[b],h=c+n|0,l[h]=0,W(-1),e}}else{if(1960==c){if(i){n=g}else{return c=t[b],h=c+h|0,l[h]=0,W(g),e}}}R(e);h=t[d];c=t[b];h=c+h|0;l[h]=0;W(n);return e}XD.X=1;function SD(){var b=T();if(72==(b|0)){b=92}else{if(66==(b|0)){b=8}else{if(82==(b|0)){b=13}else{if(81==(b|0)){b=96}else{if(76==(b|0)){b=126}else{if(70==(b|0)){b=12}else{if(86==(b|0)){b=124}else{if(84==(b|0)){b=9}else{if(41==(b|0)){b=93}else{if(62==(b|0)){b=125}else{if(65==(b|0)){b=64}else{if(78==(b|0)){b=10}else{if(83==(b|0)){b=35}else{if(37!=(b|0)&&39!=(b|0)){if(68==(b|0)){b=36}else{if(60==(b|0)){b=123}else{if(34!=(b|0)){if(10==(b|0)){QD(37),b=0}else{if(40==(b|0)){b=91}else{if(47==(b|0)){var b=XD(0),d;for(d=t[b+8>>2];L(l[d]);){d++}var c=1;45==l[d]?(c=-1,d++):43==l[d]&&d++;var e=10;!e&&48==l[d]&&(120==l[d+1]||88==l[d+1]?(e=16,d+=2):(e=8,d++));e||(e=10);for(var f,g=0;0!=(f=l[d])&&!(f=parseInt(String.fromCharCode(f),e),isNaN(f));){g=g*e+f,d++}g*=c;if(2147483647<g||-2147483648>g){g=2147483647<g?2147483647:-2147483648,FA(DA)}d=g;Q(b);return 47==(T()|0)&256>d>>>0?d:0}b=67==(b|0)?94:0}}}}}}}}}}}}}}}}}}}return b}function YD(b,d){var c;S(d);var e=0==((0!=(oA(l[b]&255)|0)|95==(l[b]&255|0)|58==(l[b]&255|0))&1|0);c=(d|0)>>2;var f=t[c],g=d+4|0,h=(f+1|0)==(t[g>>2]|0);a:do{if(e){var i=b,m=h,n=f}else{for(var q=d+8|0,p=b,s=h,r=f;;){if(s&&(R(d),r=t[c]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[g>>2]|0),0==((0!=(oA(l[p]&255)|0)|95==(l[p]&255|0)|58==(l[p]&255|0))&1|0)){i=p;m=s;n=r;break a}}}}while(0);if(!m){return c=t[(d+8|0)>>2],n=c+n|0,l[n]=0,i}R(d);n=t[c];c=t[(d+8|0)>>2];n=c+n|0;l[n]=0;return i}YD.X=1;function ZD(b,d){var c=P();YD(b,c);jC(c,Az|0,d);Q(c)}function $D(){var b,d,c,e=P(),f=eC();if(0!=(f|0)){c=(e|0)>>2;d=(e+4|0)>>2;for(b=(e+8|0)>>2;;){do{if(35!=l[f]<<24>>24){if(0==(N(f,Cf|0,8)|0)){var g=aE(f+8|0),h=0==(bE(l[g]&255)|0),i=t[c],m=(i+1|0)==(t[d]|0);a:do{if(h){var n=m,q=i}else{for(var p=g,s=m,r=i;;){if(s&&(R(e),r=t[c]),l[t[b]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[b]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[d]|0),0==(bE(l[p]&255)|0)){n=s;q=r;break a}}}}while(0);n?(R(e),g=t[c]):g=q;l[t[b]+g|0]=0;jC(e,nz|0,1);S(e)}else{if(0==(N(f,Fi|0,5)|0)){g=aE(f+5|0);h=0==(bE(l[g]&255)|0);i=t[c];m=(i+1|0)==(t[d]|0);a:do{if(h){var u=m,v=i}else{p=g;s=m;for(r=i;;){if(s&&(R(e),r=t[c]),l[t[b]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[b]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[d]|0),0==(bE(l[p]&255)|0)){u=s;v=r;break a}}}}while(0);u?(R(e),g=t[c]):g=v;l[t[b]+g|0]=0;jC(e,nz|0,0);S(e)}else{if(0==(N(f,Uj|0,4)|0)){g=aE(f+4|0);h=0==(bE(l[g]&255)|0);i=t[c];m=(i+1|0)==(t[d]|0);a:do{if(h){var w=m,C=i}else{p=g;s=m;for(r=i;;){if(s&&(R(e),r=t[c]),l[t[b]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[b]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[d]|0),0==(bE(l[p]&255)|0)){w=s;C=r;break a}}}}while(0);w?(R(e),g=t[c]):g=C;l[t[b]+g|0]=0;jC(e,nz|0,4);S(e)}}}}}while(0);f=eC();if(0==(f|0)){break}}}Q(e)}$D.X=1;function aE(b){for(;0!=(L(l[b]<<24>>24)|0);){b=b+1|0}return b}function bE(b){return(95==(b|0)|0!=(oA(b)|0))&1}function cE(){var b,d=zC(36);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+6]=0;t[b+8]=0;t[b+7]=0;t[b+4]=t[K+48>>2];t[b+5]=t[K+24>>2];return d}function dE(b){Q(t[b+8>>2]);Q(t[b+12>>2]);vB(b)}function eE(b){var d,c=cE(),e=cE();Y(b);var f=b+4|0;if(23==(t[f>>2]|0)){for(var g=b|0;;){Y(b);var h=t[g>>2];if(23==(h|0)){d=2104;break}else{if(20==(h|0)){d=2103;break}else{if(21==(h|0)){d=2120;break}}}}if(2104==d){Y(b);f=(b|0)>>2;22!=(t[f]|0)?fE(b):(Y(b),15==(t[f]|0)&&(Y(b),24==(t[b+4>>2]|0)&&(Y(b),17==(t[f]|0)&&(fE(b),18==(t[f]|0)&&(Y(b),18==(t[f]|0)&&Y(b))))));Y(b);if(20!=(t[g>>2]|0)){dE(c);dE(e);return}Y(b);Y(b);dE(c);dE(e);return}if(2103==d){Y(b);Y(b);dE(c);dE(e);return}if(2120==d){dE(c);dE(e);return}}gE(e,b);Y(b);g=b|0;d=c+8|0;for(var h=e+8|0,i=1,m=t[g>>2];;){i=23==(m|0)?0:i;a:do{if(19==(m|0)){eE(b)}else{if(22==(m|0)){hE(b)}else{do{if(0!=(i|0)&&2>(t[f>>2]-21|0)>>>0){var n=0==(t[t[d>>2]>>2]|0);Y(b);if(!n){break a}Y(b);gE(c,b);iE(c,t[h>>2]);n=c;if(0==(t[n+28>>2]|0)){var m=P(),q=t[n+12>>2];0==(t[q>>2]|0)?V(m,t[t[n+8>>2]+8>>2]):(V(m,t[q+8>>2]),U(m,Xi|0),U(m,t[t[n+8>>2]+8>>2]));var q=m|0,p=t[q>>2];(p+1|0)==(t[m+4>>2]|0)?(R(m),q=t[q>>2]):q=p;l[t[m+8>>2]+q|0]=0;jE(n,5);Q(m)}break a}}while(0)}}Y(b)}while(0);n=t[g>>2];if(1<(n-20|0)>>>0){m=n}else{break}}20==(n|0)&&(Y(b),Y(b));dE(c);dE(e)}eE.X=1;function fE(b){var d,c,e;c=(b|0)>>2;for(d=(b+4|0)>>2;;){Y(b);var f=t[c];22==(f|0)&&(Y(b),f=t[c]);if(19==(f|0)){eE(b)}else{if(20==(f|0)){break}else{if(6==(f|0)){f=t[d];if(18==(f|0)||17==(f|0)||27==(f|0)){Y(b),f=t[d]}if(18==(f|0)||17==(f|0)||27==(f|0)){Y(b),f=t[d]}0==(f|0)?kE(b):lE(b)}else{if(18==(f|0)){if(Y(b),18==(t[c]|0)&&(Y(b),23==(t[c]|0))){e=2142;break}}else{lE(b)}}}}}2142!=e&&(Y(b),Y(b))}function kE(b){var d,c=cE();0==(t[b+4>>2]|0)&&Y(b);gE(c,b);Y(b);d=(b|0)>>2;var e=t[d];7==(e|0)&&(mE(b),e=t[d]);4==(e|0)?(Y(b),Y(b),d=t[d]):d=e;12==(d|0)&&(nE(b),oE(c));pE(b);dE(c)}function lE(b){if(6==(t[b>>2]|0)){var d=t[b+4>>2];11==(d|0)||12==(d|0)||14==(d|0)||15==(d|0)||16==(d|0)?b=qE(b):(13==(d|0)?rE(b):8==(d|0)||9==(d|0)||10==(d|0)?sE(b):tE(b),b=1)}else{b=tE(b)}return b}function sE(b){var d=b+4|0,c=t[d>>2];if(10==(c|0)){Y(b),c=b|0,12==(t[c>>2]|0)?nE(b):lE(b),Y(b),9==(t[d>>2]|0)&&(Y(b),7==(t[c>>2]|0)&&mE(b))}else{if(8==(c|0)||9==(c|0)){Y(b),d=b|0,c=t[d>>2],7==(c|0)?(mE(b),d=t[d>>2]):d=c,12==(d|0)?nE(b):lE(b)}}}function qE(b){var d,c,e=b+4|0;for(d=(b|0)>>2;;){Y(b);11==(t[e>>2]|0)&&Y(b);var f=t[d];7==(f|0)&&(mE(b),f=t[d]);if(12==(f|0)){c=2188;break}pE(b);if(13==(t[d]|0)){var g=0;break}Y(b);if(13==(t[d]|0)){g=0;break}if(12!=(t[e>>2]|0)){g=1;break}}2188==c&&(nE(b),g=1);return g}function rE(b){var d;Y(b);d=(b|0)>>2;var c=t[d];7==(c|0)&&(mE(b),c=t[d]);if(12==(c|0)){for(;!(Y(b),c=t[d],21==(c|0)||20==(c|0)||13==(c|0)||23==(c|0));){}}}function Y(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+16|0)>>2;b=(b+20|0)>>2;a:for(;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(40==(h|0)){f=2203;break}else{if(63==(h|0)){f=2214;break}else{if(46==(h|0)){f=2207;break}else{if(125==(h|0)){f=2210;break}else{if(62==(h|0)){f=2258;break}else{if(33==(h|0)){f=2259;break}else{if(41==(h|0)){f=2204;break}else{if(-1==(h|0)){f=2202;break}else{if(93==(h|0)){f=2213;break}else{if(32==(h|0)||10==(h|0)||9==(h|0)){continue}else{if(92==(h|0)){f=2216;break}else{if(44==(h|0)){f=2206;break}else{if(91==(h|0)){f=2212;break}else{if(61==(h|0)){f=2211;break}else{if(58==(h|0)){f=2208;break}else{if(39==(h|0)||34==(h|0)){f=2215;break}else{if(47==(h|0)){var i=T();if(47==(i|0)){uE(10);continue}else{if(62==(i|0)){f=2225;break}else{if(42!=(i|0)){f=2221;break}}}for(;;){uE(42);var m=T();if(47==(m|0)){continue a}W(m);if(-1==(m|0)||0==(m|0)){continue a}}}else{if(123==(h|0)){f=2209;break}else{if(59==(h|0)){f=2205;break}else{if(60!=(h|0)){f=2260;break}}}}}}}}}}}}}}}}}}}}var n=T();if(115==(n|0)||109==(n|0)||102==(n|0)){f=2236;break}else{if(47==(n|0)){f=2246;break}else{if(33!=(n|0)){f=2227;break}}}var q=T();if(45!=(q|0)){f=2229;break}var p=T();if(45!=(p|0)){f=2231;break}for(;;){uE(45);m=T();if(45==(m|0)){break}W(m);if(-1==(m|0)||0==(m|0)){continue a}}m=T();62!=(m|0)&&(W(m),W(45))}if(2203==f){t[e]=7}else{if(2214==f){t[e]=24}else{if(2207==f){t[e]=11}else{if(2229==f){W(q),W(33),t[e]=22,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2210==f){t[e]=13}else{if(2258==f){t[e]=23,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2259==f){t[e]=15}else{if(2236==f){g=T();if(109==(n|0)||102==(n|0)){if(120!=(g|0)){W(g);W(n);t[e]=22;t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}if(109==(n|0)||102==(n|0)){g=T();58==(g|0)?t[e]=19:(W(g),W(120),W(n),t[e]=22);t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}}else{if(115==(n|0)&&58==(g|0)){t[e]=19;t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}}W(g);W(n);t[e]=22;t[d]=t[K+48>>2];t[b]=t[K+24>>2]}else{if(2204==f){t[e]=2}else{if(2202==f){dB(sz|0,1)}else{if(2213==f){t[e]=18}else{if(2227==f){W(n),t[e]=22,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2216==f){g=T(),!(92==(g|0)||34==(g|0))&&0==(L(g)|0)&&W(g),t[e]=1,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2206==f){t[e]=5}else{if(2212==f){t[e]=17}else{if(2211==f){t[e]=14}else{if(2231==f){W(p),W(45),W(33),t[e]=22,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2208==f){t[e]=4}else{if(2215==f){t[e]=10,vE(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2209==f){t[e]=12}else{if(2225==f){t[e]=21,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2221==f){W(i),t[e]=16,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2205==f){t[e]=3}else{if(2246==f){var g=T(),s=115==(g|0);if(115==(g|0)||109==(g|0)||102==(g|0)){c=T();if(109==(g|0)||102==(g|0)){if(120!=(c|0)){W(c);W(g);t[e]=22;t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}}else{if(120!=(c|0)){s&58==(c|0)?t[e]=20:(W(c),W(g),t[e]=22);t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}}s=T();58==(s|0)?t[e]=20:(W(s),W(c),W(g),t[e]=22)}else{W(g),W(47),t[e]=22}t[d]=t[K+48>>2];t[b]=t[K+24>>2]}else{if(2260==f){if(0==(wE(h)|0)){t[e]=0}else{f=t[c];i=(f|0)>>2;q=f+4|0;for(n=(f+8|0)>>2;!(s=t[i],(s+1|0)==(t[q>>2]|0)&&(R(f),s=t[i]),l[t[n]+s|0]=h&255,0!=(h|0)&&(s=t[i]+1|0,t[i]=s,l[t[n]+s|0]=0),s=T(),0==(wE(s)|0));){h=s}h=t[i];(h+1|0)==(t[q>>2]|0)&&(R(f),h=t[i]);l[t[n]+h|0]=0;0==(L(s)|0)&&W(s);t[d]=t[K+48>>2];t[b]=t[K+24>>2];d=UD(t[c],t[Ky>>2]);t[g>>2]=d;t[e]=-1==(d|0)?9:6}}}}}}}}}}}}}}}}}}}}}}}}}}}Y.X=1;function tE(b){var d,c,e,f,g=cE(),h=cE(),i=P();S(i);e=(b+12|0)>>2;V(i,t[t[e]+8>>2]);c=(b+4|0)>>2;d=t[c];if(17==(d|0)){Y(b);var m=1;d=t[c]}else{m=0}18==(d|0)&&(Y(b),d=t[c]);19==(d|0)&&Y(b);d=(b|0)>>2;if(6==(t[d]|0)){var n=t[c];if(20==(n|0)){return e=cE(),f=P(),c=(b+32|0)>>2,g=t[c],S(f),h=b+12|0,V(f,t[t[h>>2]+8>>2]),20==(t[b+4>>2]|0)&&Y(b),t[c]=1,iE(b,t[b+8>>2]),gE(e,b),Y(b),12==(t[b>>2]|0)&&(xE(e),nE(b)),V(t[h>>2],t[f+8>>2]),t[c]=g,dE(e),Q(f),1}if(13==(n|0)){rE(b);var q=1}else{if(0==(n|0)){return kE(b),1}if(5==(n|0)){c=m;e=cE();f=cE();g=P();S(g);h=b+12|0;V(g,t[t[h>>2]+8>>2]);5==(t[b+4>>2]|0)&&Y(b);gE(e,b);Y(b);var i=b|0,p=t[i>>2];if(4==(p|0)){Y(b),Y(b),q=2379}else{var s=p}for(;;){2379==q&&(s=t[i>>2]);if(3==(s|0)){break}Y(b);q=2379}0!=(c|0)&&jE(e,4);V(t[h>>2],t[g+8>>2]);dE(e);dE(f);Q(g);return 1}8==(n|0)||9==(n|0)||10==(n|0)?(sE(b),q=1):11==(n|0)||12==(n|0)||14==(n|0)||15==(n|0)||16==(n|0)?q=qE(b):(Y(b),q=1)}}else{q=1}gE(g,b);s=g+8|0;m=0;a:for(;;){p=m;for(m=t[d];;){if(14==(m|0)){f=2336;break a}else{if(3==(m|0)){var r=q;break a}else{if(13==(m|0)){f=2363;break a}}}Y(b);m=t[d];n=11==(m|0);b:do{if(n){for(var u=p;;){Y(b);var v=t[c];do{if(-1==(v|0)){if(0==(u|0)){var w=b,C=ba,C=(g+8|0)>>2,A=t[C];0!=(t[A>>2]|0)&&(U(A,Xi|0),A=t[C]);U(A,t[t[w+8>>2]+8>>2]);A=t[C];w=t[A>>2];(w+1|0)!=(t[A+4>>2]|0)?C=A:(R(A),C=w=t[C],w=t[w>>2]);C=C+8|0;C=t[C>>2];C=C+w|0;C=l[C]=0}else{V(i,t[t[e]+8>>2]),iE(b,t[s>>2]),C=u}}else{if(4==(v|0)){if(xE(g),Y(b),C=t[d],14==(C|0)){if(Y(b),12==(t[d]|0)){f=2328;break a}else{C=1}}else{if(11==(C|0)){if(Y(b),-1==(t[c]|0)){f=2326;break a}else{C=1}}else{C=1}}}else{C=u}}}while(0);Y(b);u=t[d];if(11==(u|0)){u=C}else{var I=C,M=u;break b}}}else{I=p,M=m}}while(0);7==(M|0)?(mE(b),m=t[d]):m=M;4==(m|0)&&(Y(b),Y(b),m=t[d]);if(17==(m|0)){break}else{p=I}}m=b;n=m|0;if(17==(t[n>>2]|0)){Y(m);for(v=1;!(u=t[n>>2],v=(17==(u|0)&1)+v|0,v=((18==(u|0)&0<(v|0))<<31>>31)+v|0,Y(m),!(0!=(v|0)|18!=(u|0)));){}}m=I}a:do{if(2336==f){Y(b);r=t[c];do{if(0==(r|0)){Y(b);-1==(t[c]|0)?7==(t[d]|0)?f=2341:(gE(h,b),Y(b),f=2340):f=2340;if(2340==f){if(I=t[d],7==(I|0)){f=2341}else{var B=I}}2341==f&&(mE(b),B=t[d]);if(12==(B|0)){if(0==(t[b+32>>2]|0)){nE(b);oE(g);if(0==(t[t[h+8>>2]>>2]|0)){r=q;break a}oE(h);r=q;break a}jE(g,2);0!=(t[t[h+8>>2]>>2]|0)&&oE(h);nE(b)}I=q}else{I=t[d],12==(I|0)?(yE(b,g),I=13==(t[d]|0)?1:q):(7==(I|0)?(mE(b),12==(t[d]|0)&&(jE(g,2),nE(b))):6==(r|0)&&(Y(b),I=t[c],4>I>>>0&&(Y(b),M=t[d],7==(M|0)&&(mE(b),M=t[d]),3==(M|0)&&0==(t[b+24>>2]|0)&&(0==(p|0)&1<(I-2|0)>>>0?oE(g):xE(g)))),I=q)}}while(0);pE(b);r=I}else{2326==f?(V(i,t[t[e]+8>>2]),iE(b,t[s>>2]),jE(b,2),r=b+28|0,t[r>>2]=1,pE(b),t[r>>2]=0,r=1):2328==f?(yE(b,g),pE(b),t[b+28>>2]=0,r=1):2363==f&&(r=0)}}while(0);V(t[e],t[i+8>>2]);dE(g);dE(h);Q(i);return r}tE.X=1;function gE(b,d){var c=d>>2,e=b>>2;t[e+6]=t[c+6];t[e+4]=t[c+4];t[e+5]=t[c+5];t[e]=t[c];t[e+1]=t[c+1];t[e+8]=t[c+8];V(t[e+2],t[t[c+2]+8>>2]);V(t[e+3],t[t[c+3]+8>>2])}function iE(b,d){var c;c=(b+12|0)>>2;var e=t[c];0!=(t[e>>2]|0)&&(U(e,Xi|0),e=t[c]);U(e,t[d+8>>2]);var f=t[c],e=t[f>>2];(e+1|0)!=(t[f+4>>2]|0)?(f=f+8|0,f=t[f>>2],c=f+e|0):(R(f),e=t[c],c=t[e>>2],f=e+8|0,f=t[f>>2],c=f+c|0);l[c]=0}function xE(b){if(0==(t[b+28>>2]|0)){var d=P(),c=t[b+12>>2];0==(t[c>>2]|0)?V(d,t[t[b+8>>2]+8>>2]):(V(d,t[c+8>>2]),U(d,Xi|0),U(d,t[t[b+8>>2]+8>>2]));var c=d|0,e=t[c>>2];(e+1|0)==(t[d+4>>2]|0)?(R(d),c=t[c>>2]):c=e;e=d+8|0;l[t[e>>2]+c|0]=0;0==(zE(t[Rz>>2],t[e>>2])|0)&&(AE(t[Rz>>2],BE(d)),jE(b,1));Q(d)}}xE.X=1;function jE(b,d){if(0!=(t[kz+(d<<4)>>2]|0)&&0==(t[b+28>>2]|0)){var c=0==(d|0)?0==(t[b+32>>2]|0)?0:2:d,e=b+12|0;if(0!=(t[t[e>>2]>>2]|0)){var f=P();V(f,t[t[e>>2]+8>>2]);U(f,Xi|0);e=b+8|0;U(f,t[t[e>>2]+8>>2]);var g=f|0,h=t[g>>2];(h+1|0)==(t[f+4>>2]|0)?(R(f),g=t[g>>2]):g=h;h=f+8|0;l[t[h>>2]+g|0]=0;V(t[e>>2],t[h>>2]);Q(f)}e=j;j+=80;f=e>>2;0!=(t[kz+(c<<4)>>2]|0)&&0==(t[b+28>>2]|0)&&(sC(e,t[t[b+8>>2]+8>>2]),t[f+1]=t[b+16>>2],t[f+2]=t[b+20>>2],t[f+9]=t[kz+(c<<4)+8>>2],l[e+40|0]=t[kz+(c<<4)+4>>2]&255,tC(e));j=e}}jE.X=1;function pE(b){for(var d=b|0;;){var c=t[d>>2];if(13==(c|0)||3==(c|0)){break}else{7==(c|0)?mE(b):12==(c|0)?nE(b):Y(b)}}}function yE(b,d){var c,e,f=cE();c=(b|0)>>2;for(var g=b+4|0,h=d+8|0;;){Y(b);e=10==(t[c]|0)?2434:-1==(t[g>>2]|0)?2434:2441;if(2434==e){e=0;gE(f,b);Y(b);var i=t[c];if(4!=(i|0)){var m=i}else{Y(b),0!=(t[g>>2]|0)?(iE(f,t[h>>2]),jE(f,3),Y(b)):(Y(b),e=t[c],7==(e|0)&&(mE(b),e=t[c]),12==(e|0)&&(iE(f,t[h>>2]),jE(f,2),nE(b),Y(b))),e=2441}}2441==e&&(m=t[c]);if(5!=(m|0)){break}}pE(b);dE(f)}yE.X=1;function mE(b){var d=b|0;if(7==(t[d>>2]|0)){Y(b);for(var c=1;;){var e=t[d>>2],c=(7==(e|0)&1)+c|0,c=((2==(e|0)&0<(c|0))<<31>>31)+c|0;Y(b);if(!(0!=(c|0)|2!=(e|0))){break}}}}function oE(b){if(0==(t[b+28>>2]|0)){var d=P(),c=t[b+12>>2];0==(t[c>>2]|0)?V(d,t[t[b+8>>2]+8>>2]):(V(d,t[c+8>>2]),U(d,Xi|0),U(d,t[t[b+8>>2]+8>>2]));var c=d|0,e=t[c>>2];(e+1|0)==(t[d+4>>2]|0)?(R(d),c=t[c>>2]):c=e;e=d+8|0;l[t[e>>2]+c|0]=0;0==(zE(t[fz>>2],t[e>>2])|0)&&(AE(t[fz>>2],BE(d)),jE(b,0));Q(d)}}oE.X=1;function nE(b){var d,c,e,f=P();S(f);V(f,t[t[b+12>>2]+8>>2]);c=(b+24|0)>>2;t[c]=t[c]+1|0;d=(b|0)>>2;e=t[d];if(12==(e|0)){if(-1!=(t[b+4>>2]|0)){var g=1,h=12;e=2472}else{Y(b);var i=t[d];e=2471}}else{i=e,e=2471}2471==e&&13!=(i|0)&&(g=1,h=i,e=2472);a:do{if(2472==e){for(;;){12==(h|0)?nE(b):g=lE(b);if(0==(g|0)){break a}Y(b);h=t[d];if(13==(h|0)){break a}else{e=2472}}}}while(0);Q(f);t[c]=t[c]-1|0}function hE(b){var d;d=(b|0)>>2;var c=t[d];22==(c|0)&&(Y(b),c=t[d]);if(9==(c|0)&&(Y(b),4==(t[d]|0)&&(Y(b),9==(t[d]|0)))){for(c=9;!(22==(c|0)&&(hE(b),Y(b),c=t[d]),19==(c|0)?eE(b):Y(b),c=t[d],1>=(c-20|0)>>>0);){}}}function vE(b,d){var c,e,f;f=(b|0)>>2;e=(b+4|0)>>2;c=(b+8|0)>>2;var g=1;a:for(;;){for(;;){if(!g){break a}var h=T();if(92==(h|0)){var h=T(),i=t[f]}else{if(-1==(h|0)){g=0;continue a}if((h|0)==(d|0)){g=0;continue a}i=t[f]}(i+1|0)==(t[e]|0)&&(R(b),i=t[f]);l[t[c]+i|0]=h&255;0!=(h|0)&&(h=t[f]+1|0,t[f]=h,l[t[c]+h|0]=0)}}g=t[f];(g+1|0)!=(t[e]|0)?(c=t[c],c=c+g|0):(R(b),e=t[f],c=t[c],c=c+e|0);l[c]=0}vE.X=1;function wE(b){return 0!=(pA(b)|0)|10>(b-48|0)>>>0?1:95==(b|0)||64==(b|0)||36==(b|0)||35==(b|0)?1:0}function CE(){var b,d=zC(28);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=-1;t[b+3]=P();t[b+4]=0;t[b+5]=t[K+48>>2];t[b+6]=t[K+24>>2];return d}function DE(b){if(0!=(b|0)){Q(t[b+12>>2]);var d=b+16|0;DE(t[d>>2]);t[d>>2]=0;vB(b)}}function EE(){var b;b=t[lA>>2]-1|0;t[lA>>2]=b;Q(t[(t[jA>>2]+12>>2)+(7*b|0)]);var d=t[lA>>2];b=t[jA>>2]>>2;t[b+(7*d|0)]=0;t[b+(7*d|0)+1]=-1;t[b+(7*d|0)+4]=0;t[b+(7*d|0)+2]=-1;t[b+(7*d|0)+3]=0;t[b+(7*d|0)+5]=0}function FE(b){return 17==(b|0)||47==(b|0)||50==(b|0)||55==(b|0)?1:0}function GE(b){return 4==(b|0)||28==(b|0)||48==(b|0)||16==(b|0)||9==(b|0)||7==(b|0)||32==(b|0)||49==(b|0)||60==(b|0)?1:0}function HE(b){for(var d=b|0;!(IE(b,11),JE(b),11!=(t[d>>2]|0));){}}function KE(b){for(var d=0;;){if(62==(t[b+4>>2]|0)){HE(b);var c=1}else{c=0}if(0==(c|0)){var e=d;break}else{d=1}}for(;;){if(d=b,c=t[d+4>>2],19==(c|0)?(LE(d),d=1):25==(c|0)||26==(c|0)||38==(c|0)||22==(c|0)?(HE(d),d=1):d=0,0==(d|0)){var f=e;break}else{e=1}}for(;!(e=b,d=e+4|0,c=t[d>>2],30==(c|0)?(ME(e),e=1):2==(c|0)?(JE(e),0==(GE(t[d>>2])|0)?HE(e):NE(e),e=1):55==(c|0)?(JE(e),e=1):19==(c|0)?(LE(e),e=1):0!=((5==(c|0)||6==(c|0)||13==(c|0)||14==(c|0)||21==(c|0)||22==(c|0)||26==(c|0)||27==(c|0)||38==(c|0)||39==(c|0)||40==(c|0)||41==(c|0)||54==(c|0)||63==(c|0)||64==(c|0)||65==(c|0)?1:0)|0)?(HE(e),e=1):0!=(GE(c)|0)?(NE(e),e=1):3==(t[e>>2]|0)?(JE(e),d=e|0,9!=(t[d>>2]|0)?d=0:(OE(e),d=(7==(t[d>>2]|0)?0==(qA(t[t[e+12>>2]+8>>2],mg|0)|0):0)&1),HE(e),e=d):(d=t[e+4>>2],8==(d|0)?(PE(e,1),e=1):56==(d|0)?(QE(e),e=1):35==(d|0)?(PE(e,9),e=1):0==(d|0)||11==(d|0)||12==(d|0)||20==(d|0)||21==(d|0)||29==(d|0)||31==(d|0)||37==(d|0)||42==(d|0)||44==(d|0)||46==(d|0)||51==(d|0)||58==(d|0)?(HE(e),e=1):e=0),0==(e|0));){f=1}return f}function RE(b){for(var d,c=b+4|0,e=b+16|0,f=0;;){var g=t[c>>2];if(19==(g|0)){LE(b),f=1}else{if(18==(g|0)){SE(b);g=t[e>>2];if(0==(g|0)){d=2647;break}g=t[g+4>>2];if(!(15==(g|0)||24==(g|0)||52==(g|0)||66==(g|0))){d=2649;break}HE(b);f=1}else{if(10==(g|0)||23==(g|0)||57==(g|0)){d=2648;break}else{0==(FE(g)|0)?HE(b):JE(b),f=1}}}}if(2647==d||2648==d||2649==d){return f}}function LE(b){JE(b);3==(t[b>>2]|0)&&TE(b,2);HE(b)}function SE(b){b=b+16|0;if(0==(t[b>>2]|0)){var d=CE();t[b>>2]=d;JE(d)}}function TE(b,d){var c,e=j;j+=80;c=e>>2;var f=b+8|0;t[f>>2]=d;if(0!=(UE(d)|0)){sC(e,t[t[b+12>>2]+8>>2]);f=t[f>>2];1==(f|0)&&(t[c]=2!=(t[oy+76>>2]|0)&1);t[c+1]=t[b+20>>2];t[c+2]=t[b+24>>2];t[c+4]=2>(f-6|0)>>>0&1;t[c+9]=t[iz+(f<<4)+8>>2];l[e+40|0]=t[iz+(f<<4)+4>>2]&255;t[c+6]=6!=(f|0)&1;if(0!=(t[lA>>2]|0)){var f=t[jA>>2],g=0,h=t[lA>>2];a:for(;;){for(var i=0==(g|0),m=h;;){if(!(0!=(m|0)&i)){break a}var m=m-1|0,n=f+28*m|0;if(3==(t[n>>2]|0)){var q=t[(f+8>>2)+(7*m|0)];if(!(-1==(q|0)||4==(q|0))){g=n;h=m;continue a}}}}f=g;0!=(f|0)&&(t[c+15]=t[iz+(t[f+8>>2]<<4)+8>>2],t[c+16]=t[t[f+12>>2]+8>>2])}c=t[lA>>2];if(0==(c|0)){var p=0}else{f=t[jA>>2];for(h=g=0;;){if(h=4==(t[(f+8>>2)+(7*g|0)]|0)?1:h,g=g+1|0,!(g>>>0<c>>>0&0==(h|0))){p=h;break}}}if(0!=(p|0)&&0==(UE(4)|0)){j=e;return}tC(e)}j=e}TE.X=1;function UE(b){var d=t[iz+(b<<4)>>2];return 0==(d|0)?0:0==(2>(b-6|0)>>>0&1|0)?d:t[oy+8>>2]}function ME(b){var d;JE(b);d=(b|0)>>2;if(3==(t[d]|0)){TE(b,4);var c=VE(b);d=2703}else{var e=t[b+4>>2];1==(e|0)||36==(e|0)?(JE(b),e=t[d],9==(e|0)?(JE(b),d=t[d]):d=e,7!=(d|0)?d=2704:(TE(b,4),c=VE(b),d=2703)):d=2704}if(2703==d){if(0==(c|0)){d=2704}else{var f=c}}2704==d&&(f=CE(),t[f>>2]=3,t[f+8>>2]=4);WE(f);for(c=b+4|0;;){if(d=t[c>>2],57==(d|0)){XE(b,11)}else{if(18==(d|0)){break}else{23==(d|0)?XE(b,3):0!=(FE(d)|0)?JE(b):0==(GE(d)|0)?HE(b):YE(b)}}}SE(b);HE(b);EE();DE(f)}ME.X=1;function NE(b){var d,c;YE(b);d=(b|0)>>2;var e=t[d];if(1==(e|0)){ZE(b);var f=t[d];c=2717}else{11!=(e|0)&&(f=e,c=2717)}if(2717==c&&(2==(f|0)&&JE(b),$E(b),11!=(t[d]|0))){return}HE(b)}function JE(b){var d,c,e;d=b+16|0;DE(t[d>>2]);c=(b|0)>>2;t[c]=0;t[b+8>>2]=-1;t[b+4>>2]=-1;t[d>>2]=0;d=(b+12|0)>>2;S(t[d]);for(var f=b+20|0,g=b+24|0;;){var h=aF();t[f>>2]=t[K+48>>2];t[g>>2]=t[K+24>>2];if(46==(h|0)){e=2744;break}else{if(42==(h|0)||47==(h|0)||43==(h|0)||45==(h|0)||61==(h|0)||60==(h|0)||62==(h|0)){var i=h;e=2731;break}else{if(44==(h|0)){e=2727;break}else{if(41==(h|0)){e=2729;break}else{if(10==(h|0)){break}else{if(40==(h|0)){e=2728;break}else{if(33==(h|0)){e=2739;break}else{if(-1==(h|0)){e=2726;break}else{if(37==(h|0)){e=2730;break}else{if(34==(h|0)||39==(h|0)){e=2751;break}else{if(59==(h|0)){e=2752;break}else{if(58==(h|0)){e=2753;break}else{if(!(32==(h|0)||9==(h|0))){e=2756;break}}}}}}}}}}}}}}a:do{if(2744==e){bF(t[d],46);i=aF();if(46!=(i|0)){cF(i);t[c]=0;return}i=t[d];h=t[i>>2];(h+1|0)==(t[i+4>>2]|0)&&(R(i),i=h=t[d],h=t[h>>2]);l[t[i+8>>2]+h|0]=46;i=t[d]|0;h=t[i>>2]+1|0;t[i>>2]=h;l[t[t[d]+8>>2]+h|0]=0;h=t[d];i=t[h>>2];(i+1|0)==(t[h+4>>2]|0)?(R(h),d=i=t[d],i=t[i>>2]):d=h;l[t[d+8>>2]+i|0]=0;t[c]=7;return}if(2731==e){for(;;){h=t[d];b=t[h>>2];(b+1|0)==(t[h+4>>2]|0)&&(R(h),h=b=t[d],b=t[b>>2]);l[t[h+8>>2]+b|0]=i&255;0!=(i|0)&&(i=t[d]|0,h=t[i>>2]+1|0,t[i>>2]=h,l[t[t[d]+8>>2]+h|0]=0);var m=aF();if(0==(bC(bg|0,m,7)|0)){break}else{i=m}}cF(m);h=t[d];i=t[h>>2];(i+1|0)==(t[h+4>>2]|0)?(R(h),d=i=t[d],i=t[i>>2]):d=h;l[t[d+8>>2]+i|0]=0;t[c]=7;return}if(2727==e){t[c]=1;return}if(2729==e){t[c]=8;return}if(2756==e){if(0!=(pA(h)|0)){c=b;i=ba;i=(c+12|0)>>2;bF(t[i],h);h=UD(t[i],t[Ny>>2]);d=c+4|0;t[d>>2]=h;b=c|0;-1!=(h|0)?t[b>>2]=4:(t[b>>2]=3,i=t[t[i]+8>>2],0==(N(i,Sf|0,3)|0)&&(h=PD(i+3|0),i=UD(h,t[Ny>>2]),Q(h),-1!=(i|0)&&(h=CE(),c=c+16|0,t[c>>2]=h,t[h>>2]=4,t[t[c>>2]+4>>2]=i,t[d>>2]=18)));return}10>(h-48|0)>>>0?(i=dF(h),U(t[d],t[i+8>>2]),Q(i),t[c]=6):t[c]=0;return}if(2728==e){t[c]=9;return}if(2739==e){if(0==(t[gz>>2]|0)){eF(),t[Nz>>2]=0}else{for(;;){if(f=aF(),-1==(f|0)||10==(f|0)){break a}}}}else{if(2726==e){dB(rz|0,1)}else{if(2730==e){t[c]=10;return}if(2751==e){fF(t[d],h);t[c]=12;return}if(2752==e){t[c]=11;return}if(2753==e){d=aF();58==(d|0)?t[c]=2:(cF(d),t[c]=0);return}}}}while(0);t[c]=11;0!=(t[gz>>2]|0)&&gF()}JE.X=1;function PE(b,d){var c,e;JE(b);c=(b|0)>>2;for(var f=b+12|0,g=t[c];;){if(7==(g|0)){if(0==(qA(t[t[f>>2]+8>>2],dh|0)|0)){JE(b);3==(t[c]|0)&&(TE(b,d),JE(b));hF(b);var h=t[c];e=2801}}else{h=g,e=2801}2801==e&&(e=0,3==(h|0)&&TE(b,7));JE(b);g=t[c];9==(g|0)&&(OE(b),g=t[c]);1==(g|0)&&(JE(b),g=t[c]);if(11==(g|0)){break}}HE(b)}function QE(b){var d,c,e;JE(b);c=(b|0)>>2;7==(t[c]|0)?0!=(qA(t[t[b+12>>2]+8>>2],dh|0)|0)?e=2814:(JE(b),3==(t[c]|0)&&TE(b,12),d=VE(b),hF(b)):e=2814;2814==e&&(e=CE(),d=e>>2,t[d]=3,t[d+2]=12,V(t[d+3],tg|0),d=e);a:for(;;){for(e=t[c];;){if(3!=(e|0)){break a}TE(b,5);JE(b);e=t[c];if(1==(e|0)){break}}JE(b)}HE(b);WE(d);c=b+4|0;if(18!=(t[c>>2]|0)){for(;!(iF(b),18==(t[c>>2]|0));){}}SE(b);HE(b);EE();DE(d)}QE.X=1;function VE(b){var d,c,e=CE();c=e>>2;d=b>>2;t[c]=t[d];t[c+1]=t[d+1];t[c+2]=t[d+2];t[c+3]=t[d+3];t[c+4]=t[d+4];t[c+5]=t[d+5];t[c+6]=t[d+6];t[e+12>>2]=BE(t[b+12>>2]);t[b+16>>2]=0;return e}function hF(b){IE(b,7);11!=(t[b>>2]|0)&&JE(b)}function WE(b){var d,c;d=t[jA>>2];0==(d|0)?(t[lA>>2]=0,t[kA>>2]=10,d=zC(280),t[jA>>2]=d):(c=t[lA>>2],(c|0)==(t[kA>>2]|0)&&(c=c+10|0,t[kA>>2]=c,d=jF(d,28*c|0),t[jA>>2]=d));c=(d+28*t[lA>>2]|0)>>2;d=b>>2;t[c]=t[d];t[c+1]=t[d+1];t[c+2]=t[d+2];t[c+3]=t[d+3];t[c+4]=t[d+4];t[c+5]=t[d+5];t[c+6]=t[d+6];b=BE(t[b+12>>2]);d=t[lA>>2];t[(t[jA>>2]+12>>2)+(7*d|0)]=b;t[lA>>2]=d+1|0}function iF(b){var d=t[b+4>>2];if(0!=(GE(d)|0)){NE(b)}else{if(61==(d|0)){HE(b);var d=b+4|0,c=33==(t[d>>2]|0);a:do{if(c){for(;;){var e=b;HE(e);var f=e+4|0,g=18==(t[f>>2]|0);b:do{if(!g){for(;;){if(iF(e),18==(t[f>>2]|0)){break b}}}}while(0);SE(e);HE(e);if(33!=(t[d>>2]|0)){break a}}}}while(0);SE(b);HE(b)}else{56==(d|0)?QE(b):HE(b)}}}function IE(b,d){for(var c=b|0,e=b+16|0;;){var f=t[c>>2];if((f|0)==(d|0)|11==(f|0)){break}f=t[e>>2];if(0!=(f|0)&&11==(t[f>>2]|0)){break}JE(b)}}function OE(b){for(var d=b|0,c=0;;){var e=t[d>>2];if(11==(e|0)){break}else{c=9==(e|0)?c+1|0:8==(e|0)?c-1|0:c}JE(b);if(0>=(c|0)){break}}}function YE(b){var d=b>>2,c=b+4|0,e=t[c>>2];if(16==(e|0)){JE(b);var f=t[c>>2];9==(f|0)||43==(f|0)?JE(b):IE(b,11)}else{if(4==(e|0)||9==(e|0)||28==(e|0)||32==(e|0)||48==(e|0)){JE(b);var f=b|0,g=t[f>>2];9==(g|0)?(OE(b),f=t[f>>2]):f=g;7==(f|0)&&0==(qA(t[t[d+3]+8>>2],wo|0)|0)&&(JE(b),JE(b))}else{if(7==(e|0)){JE(b);f=b|0;g=t[f>>2];if(7==(g|0)){if(0==(qA(t[t[d+3]+8>>2],wo|0)|0)){JE(b),f=t[f>>2]}else{return}}else{f=g}9==(f|0)?OE(b):6==(f|0)&&JE(b)}else{if(49==(e|0)){JE(b),7==(t[d]|0)&&0==(qA(t[t[d+3]+8>>2],dh|0)|0)&&(JE(b),JE(b),JE(b))}else{if(60==(e|0)){if(JE(b),9==(t[d]|0)){OE(b)}else{d=(b|0)>>2;c=t[d];1==(c|0)&&(ZE(b),c=t[d]);2==(c|0)?(JE(b),d=t[d]):d=c;3==(d|0)&&TE(b,12);WE(b);HE(b);d=b+4|0;c=t[d>>2];44==(c|0)||53==(c|0)?(HE(b),g=2964):f=c;for(;;){2964==g&&(f=t[d>>2]);if(18==(f|0)){break}0==(GE(f)|0)?HE(b):(g=b,YE(g),c=g|0,e=t[c>>2],1==(e|0)?(ZE(g),c=t[c>>2]):c=e,2==(c|0)&&JE(g),$E(g));g=2964}SE(b);IE(b,11);EE()}}else{IE(b,11)}}}}}}YE.X=1;function ZE(b){for(var d,c=b+4|0,e=b|0;;){JE(b);var f=t[c>>2];12==(f|0)||29==(f|0)?(JE(b),OE(b)):38==(f|0)||0==(f|0)||21==(f|0)||31==(f|0)||37==(f|0)||44==(f|0)||42==(f|0)||46==(f|0)||51==(f|0)||58==(f|0)?JE(b):IE(b,11);f=t[e>>2];if(2==(f|0)){d=2915;break}else{if(1!=(f|0)){break}}}2915!=d&&IE(b,11)}function $E(b){var d,c;d=(b|0)>>2;var e=t[d];if(10==(e|0)){HE(b)}else{for(var f=b+4|0;;){if(4==(e|0)){e=t[f>>2];if(23==(e|0)||57==(e|0)){c=2929;break}t[d]=3}else{if(3!=(e|0)){c=2927;break}}kF(b);e=t[d];if(11==(e|0)){c=2925;break}else{if(1!=(e|0)){continue}}JE(b);e=t[d]}2929!=c&&2927!=c&&2925==c&&HE(b)}}function kF(b){var d;0==(t[lA>>2]|0)?d=13:(d=t[(t[jA>>2]+28*(t[lA>>2]-1)|0)+8>>2],d=3==(d|0)?7:12==(d|0)?5:11==(d|0)?7:13);TE(b,d);JE(b);d=(b|0)>>2;var c=t[d];9==(c|0)&&(OE(b),c=t[d]);7==(c|0)&&0==(qA(t[t[b+12>>2]+8>>2],wo|0)|0)&&(JE(b),9==(t[d]|0)?OE(b):JE(b));if(7==(t[d]|0)){if(c=t[t[b+12>>2]+8>>2],0==(qA(c,dh|0)|0)){JE(b),hF(b)}else{if(0==(qA(c,mg|0)|0)){for(c=7;!(1==(c|0)||11==(c|0));){JE(b),c=t[d],9==(c|0)&&(OE(b),c=t[d])}}}}}kF.X=1;function XE(b,d){JE(b);3==(t[b>>2]|0)&&TE(b,d);WE(b);HE(b);KE(b);RE(b);10==(t[b+4>>2]|0)&&lF(b);SE(b);HE(b);EE()}function cF(b){t[Jx>>2]=b}function lF(b){var d,c=b+4|0,e=t[c>>2];if(10==(e|0)){HE(b),d=2987}else{var f=e}for(;;){if(2987==d&&(f=t[c>>2]),23==(f|0)){XE(b,3),d=2987}else{if(18==(f|0)){break}else{57==(f|0)?XE(b,11):0!=(FE(f)|0)?JE(b):0==(GE(f)|0)?JE(b):YE(b),d=2987}}}}function aF(){var b=t[Jx>>2];0==(b|0)?b=0==(t[gz>>2]|0)?mF():nF():t[Jx>>2]=0;return b}function eF(){for(;;){var b=T();if(-1==(b|0)||10==(b|0)){break}}return b}function gF(){for(var b;;){var d=aF();if(!(32==(d|0)||9==(d|0))){break}}if(10>(d-48|0)>>>0){for(var c=d,e=d=0;;){if(0==(e|0)){var f=CE();t[f>>2]=5}else{f=e}b=(f+12|0)>>2;var g=t[b],e=t[g>>2];(e+1|0)==(t[g+4>>2]|0)&&(R(g),g=e=t[b],e=t[e>>2]);l[t[g+8>>2]+e|0]=c&255;0!=(c|0)&&(c=t[b]|0,g=t[c>>2]+1|0,t[c>>2]=g,l[t[t[b]+8>>2]+g|0]=0);g=aF();e=d+1|0;if(10>(g-48|0)>>>0&5>(e|0)){c=g,d=e,e=f}else{break}}0>(d|0)|0==(f|0)||(c=t[b],d=t[c>>2],(d+1|0)==(t[c+4>>2]|0)?(R(c),b=d=t[b],d=t[d>>2]):b=c,l[t[b+8>>2]+d|0]=0,TE(f,6),DE(f));f=g}else{f=d}cF(f)}gF.X=1;function bF(b,d){var c,e;e=(b|0)>>2;var f=b+4|0;c=(b+8|0)>>2;for(var g=d;;){var h=t[e];(h+1|0)==(t[f>>2]|0)&&(R(b),h=t[e]);l[t[c]+h|0]=g&255;0!=(g|0)&&(h=t[e]+1|0,t[e]=h,l[t[c]+h|0]=0);h=aF();if(0!=(oA(h)|0)|95==(h|0)){g=h}else{break}}g=t[e];(g+1|0)!=(t[f>>2]|0)?(c=t[c],c=c+g|0):(R(b),e=t[e],c=t[c],c=c+e|0);l[c]=0;cF(h)}function dF(b){var d,c=P(),b=oF(b);V(c,t[b+8>>2]);Q(b);b=aF();if(46==(b|0)){d=oF(0);var b=(c|0)>>2,e=t[b];if((e+1|0)==(t[c+4>>2]|0)){R(c);var f=t[b]}else{f=e}e=c+8|0;l[t[e>>2]+f|0]=46;f=t[b]+1|0;t[b]=f;l[t[e>>2]+f|0]=0;U(c,t[d+8>>2]);Q(d);var g=aF()}else{g=b}if(101==(rA(g)|0)){e=oF(0);f=c|0;d=f>>2;var h=t[d],b=c+4|0;if((h+1|0)==(t[b>>2]|0)){R(c);var i=t[d]}else{i=h}h=c+8|0;l[t[h>>2]+i|0]=g&255;0!=(g|0)&&(g=t[d]+1|0,t[d]=g,l[t[h>>2]+g|0]=0);U(c,t[e+8>>2]);Q(e);d=f;e=b}else{cF(g),d=c|0,e=c+4|0}b=t[d>>2];if((b+1|0)!=(t[e>>2]|0)){return d=t[(c+8|0)>>2],b=d+b|0,l[b]=0,c}R(c);b=t[d>>2];d=t[(c+8|0)>>2];b=d+b|0;l[b]=0;return c}dF.X=1;function oF(b){var d,c,e=P();if(45==(b|0)){b=(e|0)>>2;d=t[b];if((d+1|0)==(t[e+4>>2]|0)){R(e);var f=t[b]}else{f=d}d=e+8|0;l[t[d>>2]+f|0]=45;f=t[b]+1|0;t[b]=f;l[t[d>>2]+f|0]=0;var g=aF()}else{g=10>(b-48|0)>>>0?b:aF()}d=(e|0)>>2;f=e+4|0;for(b=(e+8|0)>>2;;){if(-1==(g|0)){c=3069;break}var h=t[d],i=(h+1|0)==(t[f>>2]|0);if(10<=(g-48|0)>>>0){c=3077;break}if(i){R(e);var m=t[d]}else{m=h}l[t[b]+m|0]=g&255;0!=(g|0)&&(g=t[d]+1|0,t[d]=g,l[t[b]+g|0]=0);g=aF()}if(3077==c){if(i){var n=g;c=3078}else{var q=g,p=h}}else{if(3069==c){if(c=t[d],(c+1|0)==(t[f>>2]|0)){n=-1,c=3078}else{l[t[b]+c|0]=0;var s;cF(-1);return e}}}3078==c&&(R(e),q=n,p=t[d]);l[t[b]+p|0]=0;if(95!=(q|0)){return cF(q),e}for(;;){q=aF();if(-1==(q|0)){s=-1;c=3083;break}if(0==(pA(q)|0)){s=q;c=3086;break}}if(3086==c||3083==c){return cF(s),e}}oF.X=1;function nF(){var b=T();do{if(38==(b|0)){for(;;){var d=T();if(!(0!=(L(d)|0)&10!=(d|0))){break}}if(10==(d|0)){t[Vc>>2]=1;var c=0,e=10}else{33==(d|0)?(c=0,e=33):(W(d),c=1,e=38)}}else{c=0==(t[Vc>>2]|0)?1:35==(b|0)||33==(b|0)?0:1,e=b}}while(0);a:for(;;){var f=e;b:for(;;){if(c){break a}b=0==(L(f)|0);c:do{if(b){var g=f}else{for(;;){if(d=T(),0==(L(d)|0)){g=d;break c}}}}while(0);do{if(33!=(g|0)&&!(0!=(t[Vc>>2]|0)&35==(g|0))){if(38!=(g|0)){c=1;e=g;continue a}f=T();continue b}}while(0);f=-1==(eF()|0)?-1:T();t[Vc>>2]=1}}t[Vc>>2]=10==(f|0)&1;return f}nF.X=1;function fF(b,d){var c,e,f=j,g=t[K+20>>2];l[ly]=1;e=(b|0)>>2;var h=b+4|0;c=(b+8|0)>>2;for(var i=aF();(i|0)!=(d|0)&&!(-1==(i|0)||10==(i|0));){var m=t[e];(m+1|0)==(t[h>>2]|0)&&(R(b),m=t[e]);l[t[c]+m|0]=i&255;0!=(i|0)&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);i=aF()}m=-1==(i|0);if(-1==(i|0)||10==(i|0)){i=t[t[K+40>>2]+8>>2],KC(Qf|0,(k=j,j+=8,t[k>>2]=i,t[k+4>>2]=g,k)),m&&dB(rz|0,1),0==(t[gz>>2]|0)&&dB(rz|0,2)}g=t[e];(g+1|0)!=(t[h>>2]|0)?(c=t[c],c=c+g|0):(R(b),e=t[e],c=t[c],c=c+e|0);l[c]=0;l[ly]=0;j=f}fF.X=1;function mF(){var b;if(0==(t[Nz>>2]|0)){var d=0,c=0,e=1}else{var f=T();t[Nz>>2]=t[Nz>>2]+1|0;if(10==(f|0)){t[Nz>>2]=0,d=1,c=10,e=1}else{if(33!=(f|0)|l[ly]){if(38!=(f|0)){var g=0,h=f;b=3132}else{f=T(),10==(f|0)?dB(rz|0,2):(W(f),g=0,h=38,b=3132)}}else{c=eF(),t[Nz>>2]=0,e=d=1}}}a:for(;;){3132==b&&(b=0,d=g,c=h,e=0==(t[Nz>>2]|0));var h=(g=0==(d|0))?-1:10,i=c,f=e;b:for(;;){if(!f){b=3146;break a}f=pF();if(4==(f|0)){t[Nz>>2]=6,i=h,f=0}else{if(2==(f|0)){b=3137;break}else{if(0==(f|0)||1==(f|0)){b=3136;break a}else{if(5==(f|0)){b=3139}else{if(3!=(f|0)){g=d;h=i;b=3132;continue a}}}}do{if(3139==b&&(b=0,!g)){t[Nz>>2]=6;i=10;f=0;continue b}}while(0);for(t[Nz>>2]=5;;){var m=T(),n=t[Nz>>2]+1|0;t[Nz>>2]=n;if(10==(m|0)){break}else{if(!(32==(m|0)||9==(m|0))){break b}}}t[Nz>>2]=0;i=10;f=1}}3137==b?(eF(),g=d,h=i):6<n>>>0?(W(m),g=d,h=32):(g=d,h=m);b=3132}if(3146==b){return i}3136==b&&dB(rz|0,2)}mF.X=1;function pF(){var b,d,c,e=P();d=(e|0)>>2;var f=e+4|0;b=(e+8|0)>>2;var g=0;a:for(;;){var h=T();if(0==(g|0)&&0!=(bC(Kf|0,h,9)|0)){var i=2;c=3162;break}if(9==(h|0)){i=5;c=3162;break}if(5==(g|0)){c=3152;break}do{if(-1==(h|0)){i=4;c=3162;break a}else{if(10==(h|0)){c=3161;break a}else{if(32!=(h|0)){if(10<=(h-48|0)>>>0){i=1;c=3162;break a}var m=t[d];(m+1|0)==(t[f>>2]|0)&&(R(e),m=t[d]);l[t[b]+m|0]=h&255;0!=(h|0)&&(m=t[d]+1|0,t[d]=m,l[t[b]+m|0]=0)}}}}while(0);g=g+1|0;if(6<=(g|0)){i=0;c=3162;break}}if(3152==c){if(48==(h|0)||32==(h|0)){i=5,c=3162}else{var h=t[d],n=0==(h|0)?3:1,q=h}}else{3161==c&&(i=6,c=3162)}3162==c&&(n=i,q=t[d]);if(0==(q|0)){return Q(e),n}(q+1|0)==(t[f>>2]|0)?(R(e),d=t[d]):d=q;l[t[b]+d|0]=0;b=CE();t[b>>2]=5;V(t[b+12>>2],t[e+8>>2]);TE(b,6);DE(b);Q(e);return n}pF.X=1;function qF(){var b,d=zC(20);b=d>>2;t[b]=-1;t[b+1]=-1;t[b+2]=P();t[b+3]=t[K+48>>2];t[b+4]=t[K+24>>2];return d}function rF(b){0!=(b|0)&&(Q(t[b+8>>2]),vB(b))}function sF(b,d){var c,e=qF();tF(e);var f=e|0;if(5==(t[f>>2]|0)){tF(e);var g=0}else{g=1}for(var h=b|0;;){uF(e,d);tF(b);var i=t[h>>2];if(15==(i|0)||6==(i|0)){tF(e)}else{vF(b);var i=b,m=i|0;if(11!=(t[m>>2]|0)){for(;!(tF(i),wF(i),11==(t[m>>2]|0));){}}if(g){c=3210;break}tF(e);if(6==(t[f>>2]|0)){c=3211;break}}}3211==c?rF(e):3210==c&&rF(e)}function uF(b,d){var c,e=j;j+=80;c=e>>2;var f=b+8|0;sC(e,t[t[f>>2]+8>>2]);if(0!=(t[dz+(d<<4)>>2]|0)&&(t[c+1]=t[b+12>>2],t[c+2]=t[b+16>>2],t[c+9]=t[dz+(d<<4)+8>>2],l[e+40|0]=t[dz+(d<<4)+4>>2]&255,tC(e),0!=(t[Zb>>2]|0)&0!=(t[oy+4>>2]|0))){var g=P();V(g,t[t[Zb>>2]+8>>2]);U(g,Xi|0);U(g,t[t[f>>2]+8>>2]);t[c+8]=t[g+8>>2];tC(e);Q(g)}j=e}uF.X=1;function vF(b){var d,c=b|0,e=b+4|0;a:for(;;){var f=t[c>>2];if(3==(f|0)){d=3222;break}else{if(5==(f|0)){d=3221;break}}var g=t[e>>2];if(2>(g-6|0)>>>0){d=3225;break}if(9==(f|0)){wF(b)}else{12!=(f|0)&&(d=3228);do{if(3228==d&&(d=0,!(9==(g|0)|13==(f|0)))){if(5==(g|0)){tF(b);wF(b);continue a}else{if(8==(g|0)){tF(b);wF(b);continue a}else{d=3238;break a}}}}while(0);tF(b)}}3238!=d&&(3222==d?(tF(b),14==(t[c>>2]|0)&&(tF(b),tF(b))):3221==d?wF(b):3225==d&&(tF(b),wF(b)))}function wF(b){var d=b|0,c=t[d>>2];if(5==(c|0)){var e=6}else{if(7==(c|0)){e=8}else{if(9==(c|0)){e=10}else{return}}}tF(b);for(var f=1;;){var g=t[d>>2],f=((g|0)==(c|0)&1)+f|0,f=(((g|0)==(e|0)&0<(f|0))<<31>>31)+f|0;tF(b);if(!(0!=(f|0)|(g|0)!=(e|0))){break}}}function xF(b,d){var c,e,f;f=(b|0)>>2;e=(b+4|0)>>2;c=(b+8|0)>>2;var g=96==(d|0),h=1;a:for(;;){b:for(;;){if(!h){break a}var i=T();do{if(-1==(i|0)){h=0;continue a}else{if(92==(i|0)&&!g){var i=T(),m=t[f];(m+1|0)==(t[e]|0)&&(R(b),m=t[f]);l[t[c]+m|0]=i&255;if(0==(i|0)){continue b}i=t[f]+1|0;t[f]=i;l[t[c]+i|0]=0;continue b}}}while(0);if((i|0)==(d|0)){h=0;continue a}m=t[f];(m+1|0)==(t[e]|0)&&(R(b),m=t[f]);l[t[c]+m|0]=i&255;0!=(i|0)&&(i=t[f]+1|0,t[f]=i,l[t[c]+i|0]=0)}}g=t[f];(g+1|0)!=(t[e]|0)?(c=t[c],c=c+g|0):(R(b),e=t[f],c=t[c],c=c+e|0);l[c]=0}xF.X=1;function tF(b){var d,c,e,f;e=(b|0)>>2;t[e]=-1;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+12|0)>>2;for(b=(b+16|0)>>2;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(91==(h|0)){f=3307;break}else{if(!(32==(h|0)||13==(h|0)||9==(h|0))){if(46==(h|0)){f=3310;break}else{if(41==(h|0)){f=3304;break}else{if(125==(h|0)){f=3306;break}else{if(40==(h|0)){f=3303;break}else{if(42==(h|0)){f=3309;break}else{if(34==(h|0)||39==(h|0)||96==(h|0)){f=3300;break}else{if(10==(h|0)){var i=t[$b>>2];if(2>(i-3|0)>>>0|6==(i|0)|8==(i|0)|10==(i|0)){f=3291;break}}else{if(-1==(h|0)){f=3292;break}else{if(60==(h|0)){if(45==(T()|0)){f=3302;break}}else{if(44==(h|0)){f=3311;break}else{if(93==(h|0)){f=3308;break}else{if(47==(h|0)){var m=T();if(47==(m|0)){uE(10),W(10)}else{if(42==(m|0)){i=0}else{f=3299;break}for(;;){var n=T(),q=10==(n|0)?1:i;if(-1==(n|0)||42==(n|0)){i=T();if(47==(i|0)){break}W(i);if(-1==(i|0)||0==(i|0)){break}else{i=q}}else{i=q}}W(0!=(q|0)?10:32)}}else{f=123==(h|0)?3305:3312;break}}}}}}}}}}}}}}}if(3307==f){t[e]=9}else{if(3312==f){m=t[c];q=(m|0)>>2;i=m+4|0;for(f=(m+8|0)>>2;;){var p=t[q];(p+1|0)==(t[i>>2]|0)&&(R(m),p=t[q]);l[t[f]+p|0]=h&255;0!=(h|0)&&(p=t[q]+1|0,t[q]=p,l[t[f]+p|0]=0);p=T();if(0==((0!=(pA(p)|0)|10>(p-48|0)>>>0?1:95==(p|0)||64==(p|0)||36==(p|0)||35==(p|0)?1:128<(p|0))&1|0)){break}else{h=p}}h=t[q];(h+1|0)==(t[i>>2]|0)&&(R(m),h=t[q]);f=t[f];h=f+h|0;l[h]=0;W(p);t[d]=t[K+48>>2];t[b]=t[K+24>>2];d=mC(t[t[c]+8>>2],t[My>>2]);t[g>>2]=d;t[e]=-1==(d|0)?3:2}else{3291==f?t[e]=11:3310==f?t[e]=14:3304==f?t[e]=6:3306==f?t[e]=8:3302==f?t[e]=13:3303==f?t[e]=5:3299==f?(t[e]=1,W(m)):3309==f?t[e]=12:3300==f?(t[e]=4,xF(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2]):3292==f?dB(qz|0,1):3311==f?t[e]=15:3308==f?t[e]=10:3305==f&&(t[e]=7)}}t[$b>>2]=t[e]}tF.X=1;function yF(){var b,d=zC(32);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+6]=0;t[b+7]=0;t[b+4]=t[K+48>>2];t[b+5]=t[K+24>>2];return d}function zF(b){Q(t[b+8>>2]);Q(t[b+12>>2]);vB(b)}function AF(b){var d,c=yF();BF(c);CF(c,t[b+12>>2]);BF(b);d=(b|0)>>2;var e=t[d],f=11==(e|0);a:do{if(f){for(var g=b+4|0;;){BF(b);-1==(t[g>>2]|0)&&(DF(c,b),BF(b));var h=t[d];if(11!=(h|0)){var i=h;break a}}}else{i=e}}while(0);7==(i|0)?(EF(b),d=t[d]):d=i;12==(d|0)&&(0==(FF(b,c)|0)?GF(c):HF(c));IF(b);zF(c)}function JF(b,d){if(6==(t[b>>2]|0)){var c=t[b+4>>2];if(8==(c|0)||9==(c|0)||10==(c|0)){var e=b+4|0,f=t[e>>2];if(10==(f|0)){BF(b),f=b|0,12==(t[f>>2]|0)?FF(b,b):JF(b,0),BF(b),9==(t[e>>2]|0)&&(BF(b),7==(t[f>>2]|0)&&EF(b))}else{if(8==(f|0)||9==(f|0)){BF(b),e=b|0,f=t[e>>2],7==(f|0)?(EF(b),e=t[e>>2]):e=f,12==(e|0)?FF(b,b):JF(b,0)}}e=1}else{if(13==(c|0)){BF(b),e=b|0,f=t[e>>2],7==(f|0)?(EF(b),e=t[e>>2]):e=f,12==(e|0)&&FF(b,b),e=1}else{if(11==(c|0)||12==(c|0)||14==(c|0)||15==(c|0)||16==(c|0)){for(var g=b+4|0,c=(b|0)>>2;;){BF(b);11==(t[g>>2]|0)&&BF(b);var h=t[c];7==(h|0)&&(EF(b),h=t[c]);if(12==(h|0)){e=3377;break}IF(b);if(13==(t[c]|0)){f=0;break}BF(b);if(13==(t[c]|0)){f=0;break}if(12!=(t[g>>2]|0)){f=1;break}}3377==e&&(FF(b,b),f=1);e=f}else{KF(b,d),e=1}}}}else{e=KF(b,d)}return e}function BF(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+16|0)>>2;b=(b+20|0)>>2;a:for(;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(58==(h|0)){f=3397;break}else{if(44==(h|0)){f=3395;break}else{if(123==(h|0)){f=3398;break}else{if(46==(h|0)){f=3396;break}else{if(39==(h|0)||34==(h|0)){f=3403;break}else{if(92==(h|0)){f=3404;break}else{if(61==(h|0)){f=3400;break}else{if(59==(h|0)){f=3394;break}else{if(93==(h|0)){f=3402;break}else{if(40==(h|0)){f=3392;break}else{if(-1==(h|0)){f=3391;break}else{if(125==(h|0)){f=3399;break}else{if(41==(h|0)){f=3393;break}else{if(91==(h|0)){f=3401;break}else{if(32==(h|0)||10==(h|0)||9==(h|0)){continue}else{if(47!=(h|0)){f=3413;break}}}}}}}}}}}}}}}}var i=T();if(47==(i|0)){uE(10)}else{if(42!=(i|0)){f=3409;break}for(;;){uE(42);var m=T();if(47==(m|0)){continue a}W(m);if(-1==(m|0)||0==(m|0)){continue a}}}}if(3409==f){t[e]=15,W(i)}else{if(3397==f){t[e]=4}else{if(3395==f){t[e]=5}else{if(3398==f){t[e]=12}else{if(3396==f){t[e]=11}else{if(3403==f){t[e]=10,LF(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(3404==f){g=T(),!(92==(g|0)||34==(g|0))&&0==(L(g)|0)&&W(g),t[e]=1,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(3400==f){t[e]=14}else{if(3394==f){t[e]=3}else{if(3402==f){t[e]=17}else{if(3392==f){t[e]=7}else{if(3391==f){dB(pz|0,1)}else{if(3399==f){t[e]=13}else{if(3393==f){t[e]=2}else{if(3401==f){t[e]=16}else{if(3413==f){if(0==(MF(h)|0)){t[e]=0}else{var i=t[c],m=(i|0)>>2,n=i+4|0;for(f=(i+8|0)>>2;;){var q=t[m];(q+1|0)==(t[n>>2]|0)&&(R(i),q=t[m]);l[t[f]+q|0]=h&255;0!=(h|0)&&(q=t[m]+1|0,t[m]=q,l[t[f]+q|0]=0);q=T();if(0==(MF(q)|0)){break}else{h=q}}h=t[m];(h+1|0)==(t[n>>2]|0)?(R(i),i=t[m]):i=h;l[t[f]+i|0]=0;0==(L(q)|0)&&W(q);t[d]=t[K+48>>2];t[b]=t[K+24>>2];d=UD(t[c],t[Iy>>2]);t[g>>2]=d;t[e]=-1==(d|0)?9:6}}}}}}}}}}}}}}}}}}BF.X=1;function KF(b,d){var c,e,f,g,h=b>>2,i,m=yF(),n=yF(),q=P();S(q);var p=0!=(d|0),s=p&1;g=(b+4|0)>>2;e=t[g];if(5==(e|0)){e=0==(t[h+6]|0)&1;BF(b);var r=e;e=t[g]}else{r=0}7==(e|0)?(BF(b),e=b|0,11==(t[e>>2]|0)&&BF(b)):e=b|0;f=e>>2;NF(m,b);e=(b+12|0)>>2;var u=m+8|0;a:for(;;){var v=t[f];if(3==(v|0)){i=3459;break}else{if(14==(v|0)){i=3461;break}else{if(13==(v|0)){var w=0;break}}}BF(b);var v=t[f],C=11==(v|0);b:do{if(C){for(var A=s;;){BF(b);var I=t[g];do{if(-1==(I|0)){if(0==(A|0)){DF(m,b);var M=0}else{V(q,t[t[e]+8>>2]),CF(b,t[u>>2]),M=A}}else{if(4==(I|0)){if(HF(m),BF(b),M=t[f],11==(M|0)){if(BF(b),-1==(t[g]|0)){i=3451;break a}else{M=1}}else{if(14==(M|0)){if(BF(b),12==(t[f]|0)){i=3453;break a}else{M=1}}else{M=1}}}else{M=A}}}while(0);BF(b);A=t[f];if(11==(A|0)){A=M}else{var B=0;c=M;var G=A;break b}}}else{B=r,c=s,G=v}}while(0);7==(G|0)?(EF(b),r=t[f]):r=G;if(16==(r|0)&&(r=b,s=r|0,16==(t[s>>2]|0))){BF(r);for(C=1;!(v=t[s>>2],C=(16==(v|0)&1)+C|0,C=((17==(v|0)&0<(C|0))<<31>>31)+C|0,BF(r),!(0!=(C|0)|17!=(v|0)));){}}r=B;s=c}a:do{if(3451==i){V(q,t[t[e]+8>>2]),CF(b,t[u>>2]),OF(b,2),w=b+28|0,t[w>>2]=1,IF(b),t[w>>2]=0,w=1}else{if(3453==i){PF(b,m),IF(b),t[h+7]=0,w=1}else{if(3459==i){0!=(t[h+6]|0)|0==(r|0)||OF(m,4),w=1}else{if(3461==i){BF(b);w=t[g];do{if(0==(w|0)){BF(b);-1==(t[g]|0)?7==(t[f]|0)?i=3466:(NF(n,b),BF(b),i=3465):i=3465;if(3465==i){if(B=t[f],7==(B|0)){i=3466}else{var Z=B}}3466==i&&(EF(b),Z=t[f]);if(12==(Z|0)){if(p){OF(m,2),0!=(t[t[n+8>>2]>>2]|0)&&GF(n),FF(b,m)}else{0==(FF(b,m)|0)?GF(m):HF(m);if(0==(t[t[n+8>>2]>>2]|0)){w=1;break a}GF(n);w=1;break a}}}else{if(B=t[f],12==(B|0)){if(0==(PF(b,m)|0)&&!(0!=(t[h+6]|0)|0==(r|0))){B=P();c=t[e];0==(t[c>>2]|0)?V(B,t[t[h+2]+8>>2]):(V(B,t[c+8>>2]),U(B,Xi|0),U(B,t[t[h+2]+8>>2]));c=B|0;G=t[c>>2];(G+1|0)==(t[B+4>>2]|0)&&(R(B),G=t[c>>2]);c=(B+8|0)>>2;l[t[c]+G|0]=0;do{if(0==(zE(t[ez>>2],t[c])|0)&&0==(zE(t[Qz>>2],t[c])|0)){BF(b);if(3!=(t[f]|0)&&(IF(b),3!=(t[f]|0))){break}OF(m,4)}}while(0);Q(B)}}else{7==(B|0)?(EF(b),12==(t[f]|0)&&(OF(m,2),FF(b,m))):6==(w|0)?(BF(b),B=t[g],4>B>>>0&&(BF(b),c=t[f],7==(c|0)&&(EF(b),c=t[f]),3==(c|0)&&0==(t[h+6]|0)&&(0==(s|0)&1<(B-2|0)>>>0?GF(m):HF(m)))):-1==(w|0)&&!(0!=(t[h+6]|0)|0==(r|0))&&(B=P(),c=t[e],0==(t[c>>2]|0)?V(B,t[t[h+2]+8>>2]):(V(B,t[c+8>>2]),U(B,Xi|0),U(B,t[t[h+2]+8>>2])),c=B|0,G=t[c>>2],(G+1|0)==(t[B+4>>2]|0)&&(R(B),G=t[c>>2]),c=(B+8|0)>>2,l[t[c]+G|0]=0,0==(zE(t[ez>>2],t[c])|0)&&0==(zE(t[Qz>>2],t[c])|0)&&(IF(b),3==(t[f]|0)&&OF(m,4)),Q(B))}}}while(0);IF(b);w=1}}}}}while(0);V(t[e],t[q+8>>2]);zF(m);zF(n);Q(q);return w}KF.X=1;function NF(b,d){var c=d>>2,e=b>>2;t[e+6]=t[c+6];t[e+4]=t[c+4];t[e+5]=t[c+5];t[e]=t[c];t[e+1]=t[c+1];V(t[e+2],t[t[c+2]+8>>2]);V(t[e+3],t[t[c+3]+8>>2])}function CF(b,d){var c;c=(b+12|0)>>2;var e=t[c];0!=(t[e>>2]|0)&&(U(e,Xi|0),e=t[c]);U(e,t[d+8>>2]);var f=t[c],e=t[f>>2];(e+1|0)!=(t[f+4>>2]|0)?(f=f+8|0,f=t[f>>2],c=f+e|0):(R(f),e=t[c],c=t[e>>2],f=e+8|0,f=t[f>>2],c=f+c|0);l[c]=0}function DF(b,d){var c;c=(b+8|0)>>2;var e=t[c];0!=(t[e>>2]|0)&&(U(e,Xi|0),e=t[c]);U(e,t[t[d+8>>2]+8>>2]);var f=t[c],e=t[f>>2];(e+1|0)!=(t[f+4>>2]|0)?(f=f+8|0,f=t[f>>2],c=f+e|0):(R(f),e=t[c],c=t[e>>2],f=e+8|0,f=t[f>>2],c=f+c|0);l[c]=0}function HF(b){if(0==(t[b+28>>2]|0)){var d=P(),c=t[b+12>>2];0==(t[c>>2]|0)?V(d,t[t[b+8>>2]+8>>2]):(V(d,t[c+8>>2]),U(d,Xi|0),U(d,t[t[b+8>>2]+8>>2]));var c=d|0,e=t[c>>2];(e+1|0)==(t[d+4>>2]|0)?(R(d),c=t[c>>2]):c=e;e=d+8|0;l[t[e>>2]+c|0]=0;0==(zE(t[Qz>>2],t[e>>2])|0)&&(AE(t[Qz>>2],BE(d)),OF(b,1));Q(d)}}HF.X=1;function OF(b,d){if(0!=(t[Vy+(d<<4)>>2]|0)&&0==(t[b+28>>2]|0)){var c=b+12|0;if(0!=(t[t[c>>2]>>2]|0)){var e=P();V(e,t[t[c>>2]+8>>2]);U(e,Xi|0);c=b+8|0;U(e,t[t[c>>2]+8>>2]);var f=e|0,g=t[f>>2];(g+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=g;g=e+8|0;l[t[g>>2]+f|0]=0;V(t[c>>2],t[g>>2]);Q(e)}c=j;j+=80;e=c>>2;0!=(t[Vy+(d<<4)>>2]|0)&&0==(t[b+28>>2]|0)&&(sC(c,t[t[b+8>>2]+8>>2]),t[e+1]=t[b+16>>2],t[e+2]=t[b+20>>2],t[e+9]=t[Vy+(d<<4)+8>>2],l[c+40|0]=t[Vy+(d<<4)+4>>2]&255,tC(c));j=c}}function IF(b){for(var d=b|0;;){var c=t[d>>2];if(13==(c|0)||3==(c|0)){break}else{7==(c|0)?EF(b):12==(c|0)?FF(b,b):BF(b)}}}function PF(b,d){var c,e,f=yF();c=(b|0)>>2;var g=b+4|0,h=d+8|0,i=0;a:for(;;){BF(b);var m=t[c];do{if(13==(m|0)){var n=0;e=3574;break a}else{if(10==(m|0)){e=3562}else{if(-1==(t[g>>2]|0)){e=3562}else{var q=i;e=3569}}}}while(0);if(3562==e){if(e=0,NF(f,b),BF(b),m=t[c],4!=(m|0)){var p=i,s=m}else{BF(b),0!=(t[g>>2]|0)?(CF(f,t[h>>2]),OF(f,3),BF(b),q=1):(BF(b),e=t[c],7==(e|0)&&(EF(b),e=t[c]),12!=(e|0)?q=i:(CF(f,t[h>>2]),OF(f,2),FF(b,f),BF(b),q=1)),e=3569}}3569==e&&(e=0,p=q,s=t[c]);if(5==(s|0)){i=p}else{break}}if(3574==e){return zF(f),n}IF(b);n=p;zF(f);return n}PF.X=1;function EF(b){var d=b|0;if(7==(t[d>>2]|0)){BF(b);for(var c=1;;){var e=t[d>>2],c=(7==(e|0)&1)+c|0,c=((2==(e|0)&0<(c|0))<<31>>31)+c|0;BF(b);if(!(0!=(c|0)|2!=(e|0))){break}}}}function QF(b){var d=l[b+1|0];100==d<<24>>24||68==d<<24>>24?(d=l[b+2|0],101==d<<24>>24||69==d<<24>>24?(b=l[b+3|0],b=102==b<<24>>24|70==b<<24>>24):b=0):b=0;return b&1}function GF(b){if(0==(t[b+28>>2]|0)){var d=P(),c=t[b+12>>2];0==(t[c>>2]|0)?V(d,t[t[b+8>>2]+8>>2]):(V(d,t[c+8>>2]),U(d,Xi|0),U(d,t[t[b+8>>2]+8>>2]));var c=d|0,e=t[c>>2];(e+1|0)==(t[d+4>>2]|0)?(R(d),c=t[c>>2]):c=e;e=d+8|0;l[t[e>>2]+c|0]=0;0==(zE(t[ez>>2],t[e>>2])|0)&&(AE(t[ez>>2],BE(d)),OF(b,0));Q(d)}}GF.X=1;function FF(b,d){var c,e,f,g,h,i,m=P();h=(b+24|0)>>2;t[h]=t[h]+1|0;g=(b|0)>>2;e=t[g];if(12==(e|0)){if(e=b+4|0,-1!=(t[e>>2]|0)){var n=12,q=e}else{BF(b),c=t[g],i=3606}}else{c=e,i=3606}if(3606==i){if(13==(c|0)){var p=0;Q(m);g=t[h];t[h]=g-1|0;return p}n=c;q=b+4|0}f=(b+12|0)>>2;e=(d+8|0)>>2;c=(m+8|0)>>2;var s=0,r=n;a:for(;;){var u=t[q>>2];do{if(0==(u|0)){V(m,t[t[f]+8>>2]),CF(b,t[e]),AF(b),V(t[f],t[c]),n=s}else{if(7==(u|0)){V(m,t[t[f]+8>>2]),CF(b,t[e]),JF(b,1),V(t[f],t[c]),n=1}else{if(5==(u|0)){V(m,t[t[f]+8>>2]),CF(b,t[e]),JF(b,s),V(t[f],t[c]),n=s}else{if(12==(r|0)){FF(b,d),n=s}else{if(0==(JF(b,s)|0)){p=s;i=3620;break a}else{n=s}}}}}}while(0);BF(b);r=t[g];if(13==(r|0)){p=n;i=3618;break}else{s=n}}if(3620==i||3618==i){return Q(m),g=t[h],t[h]=g-1|0,p}}FF.X=1;function LF(b,d){var c,e,f;f=(b|0)>>2;e=(b+4|0)>>2;c=(b+8|0)>>2;var g=1;a:for(;;){for(;;){if(!g){break a}var h=T();if(92==(h|0)){var h=T(),i=t[f]}else{if(-1==(h|0)){g=0;continue a}if((h|0)==(d|0)){g=0;continue a}i=t[f]}(i+1|0)==(t[e]|0)&&(R(b),i=t[f]);l[t[c]+i|0]=h&255;0!=(h|0)&&(h=t[f]+1|0,t[f]=h,l[t[c]+h|0]=0)}}g=t[f];(g+1|0)!=(t[e]|0)?(c=t[c],c=c+g|0):(R(b),e=t[f],c=t[c],c=c+e|0);l[c]=0}LF.X=1;function MF(b){return 0!=(pA(b)|0)|10>(b-48|0)>>>0?1:95==(b|0)||64==(b|0)||36==(b|0)||35==(b|0)?1:0}function RF(){var b,d=P(),c=eC();if(0!=(c|0)){for(;;){var e=40==l[c]<<24>>24;a:do{if(e){if(0==(QF(c)|0)){for(var f=c;;){var g=f+1|0,f=l[g];if(0==f<<24>>24){break a}var h=l[g];if(0!=(L(f&255)|0)){b=3677;break}if(40==h<<24>>24||41==h<<24>>24){break a}else{if(58==h<<24>>24){var i=g;break}else{f=g}}}do{if(3677==b){if(b=0,58==h<<24>>24){i=g}else{break a}}}while(0);for(;;){var m=i+1|0,n=l[m];if(58==n<<24>>24){i=m}else{break}}if(0!=(QF(i)|0)){for(var f=m,q=n;;){if(0==q<<24>>24){var p=f;break}var s=f+1|0;if(0!=(L(q&255)|0)){p=f;break}f=s;q=l[s]}for(;0!=(L(l[p]&255)|0);){p=p+1|0}SF(d,p)}}else{f=c;for(q=40;;){if(0==q<<24>>24){var r=f;break}s=f+1|0;if(0!=(L(q&255)|0)){r=f;break}f=s;q=l[s]}for(;0!=(L(l[r]&255)|0);){r=r+1|0}SF(d,r)}}}while(0);c=eC();if(0==(c|0)){break}}}Q(d)}RF.X=1;function SF(b,d){var c,e,f;c=l[d];a:do{if(39==c<<24>>24){var g=d+1|0}else{if(40==c<<24>>24){if(e=l[d+1|0],113==e<<24>>24||81==e<<24>>24?(e=l[d+2|0],117==e<<24>>24||85==e<<24>>24?(e=l[d+3|0],111==e<<24>>24||79==e<<24>>24?(e=l[d+4|0],116==e<<24>>24||84==e<<24>>24?(e=l[d+5|0],e=101==e<<24>>24||69==e<<24>>24?0!=(L(l[d+6|0]&255)|0):0):e=0):e=0):e=0):e=0,0==(e&1|0)){g=d}else{for(e=d+7|0;;){if(0==(L(l[e]&255)|0)){g=e;break a}else{e=e+1|0}}}}else{g=d}}}while(0);e=(b|0)>>2;var h=b+4|0;for(c=(b+8|0)>>2;;){var i=l[g];if(0==i<<24>>24||40==i<<24>>24){f=3697;break}if(0!=(L(i&255)|0)){f=3697;break}var i=l[g],m=t[e],n=(m+1|0)==(t[h>>2]|0);if(41==i<<24>>24){f=3704;break}if(n){R(b);var i=l[g],q=t[e]}else{q=m}l[t[c]+q|0]=i;0!=l[g]<<24>>24&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);g=g+1|0}if(3697==f){if(m=t[e],(m+1|0)==(t[h>>2]|0)){f=3705}else{var p=m}}else{3704==f&&(n?f=3705:p=m)}3705==f&&(R(b),p=t[e]);l[t[c]+p|0]=0;0!=(t[e]|0)&&jC(b,By|0,0);S(b)}SF.X=1;function TF(b,d,c){if(0!=(d|0)&0!=(b|0)&b>>>0<d>>>0){for(;;){if(0==(L(l[b]<<24>>24)|0)){var e=d;break}else{b=b+1|0}}for(;0!=(L(l[e]<<24>>24)|0);){e=e-1|0}if(b>>>0<e>>>0){var f=(b|0)==(e|0),d=(c|0)>>2,g=t[d],h=c+4|0,i=(g+1|0)==(t[h>>2]|0);a:do{if(f){var m=i,n=g}else{for(var q=c+8|0,p=b,s=i,r=g;;){if(s&&(R(c),r=t[d]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[d]+1|0,t[d]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[d],s=(r+1|0)==(t[h>>2]|0),(p|0)==(e|0)){m=s;n=r;break a}}}}while(0);m?(R(c),e=t[d]):e=n;l[t[c+8>>2]+e|0]=0;jC(c,zy|0,0);S(c)}}}TF.X=1;function UF(){var b,d=P(),c=VF();if(-1!=(c|0)){for(var e=d+8|0,f=1,g=0,h=0,i=1;;){if(0==(i|0)){var m=g,n=f;b=3760}else{if(0!=(g|0)&9==(c|0)){WF();var q=i,p=h,s=g,r=f}else{m=0,n=1,b=3760}}a:do{if(3760==b){if(b=0,10==(c|0)){q=1,p=h,s=m,r=n}else{if(0!=(L(c)|0)){q=0,p=h,s=m,r=n}else{if(123==(c|0)){XF(123,125),q=0,p=h,s=m,r=n}else{if(35==(c|0)){WF(),q=0,p=h,s=m,r=n}else{if(40==(c|0)){XF(40,41),q=0,p=h,s=m,r=n}else{if(58==(c|0)){q=0,p=h,r=s=1}else{if(0==(n|0)){q=0,p=h,s=m,r=0}else{if(0==(YF(c)|0)){q=0,p=h,s=m,r=0}else{ZF(c,d);q=t[e>>2];if(0==(qA(q,Fg|0)|0)){p=q=0,s=m}else{if(0!=(h|0)){WF(),q=0,p=h,s=m}else{do{if(0==(qA(q,zr|0)|0)){if(0==(YF(c)|0)){p=t[e>>2]}else{ZF($F(),d);jC(d,xy|0,0);WF();q=0;p=1;s=m;r=n;break a}}else{p=q}}while(0);0==(qA(p,ce|0)|0)&&0!=(YF(c)|0)&&ZF($F(),d);q=$F();do{if(0==(bC(Uw|0,q,4)|0)){if(61!=(q|0)){p=q=0;s=m;r=n;break a}}else{f=58==(q|0)?1:m;p=VF();if(61!=(p|0)){W(p);p=q=0;s=f;r=n;break a}if(43==(q|0)){WF();p=q=0;s=f;r=n;break a}}}while(0);jC(d,xy|0,0);WF();s=p=q=0}}r=n}}}}}}}}}}while(0);c=VF();if(-1==(c|0)){break}else{f=r,g=s,h=p,i=q}}}Q(d)}UF.X=1;function VF(){var b=T();92==(b|0)&&(b=T(),b=10!=(b|0)?b:T());return b}function WF(){for(var b;;){var d=VF();if(-1==(d|0)){b=3796;break}else{if(10==(d|0)){break}}}3796!=b&&W(10)}function XF(b,d){var c=j,e,f=b<<24>>24,g=d<<24>>24,h=t[K+20>>2],i=0,m=1;a:for(;;){if(0>=(m|0)){var n=i;break}for(;;){var q=VF();if((q|0)==(f|0)){e=3803;break}if((q|0)==(g|0)){e=3804;break}if(-1==(q|0)||10==(q|0)){n=q;break a}}3803==e?(e=0,i=f,m=m+1|0):3804==e&&(e=0,i=g,m=m-1|0)}-1==(n|0)&&(e=t[t[K+40>>2]+8>>2],KC(Ev|0,(k=j,j+=12,t[k>>2]=e,t[k+4>>2]=f,t[k+8>>2]=h,k)));j=c}function YF(b){return(0==(b|0)?0:0!=(oA(b)|0)?1:0!=(bC(hw|0,b,4)|0))&1}function ZF(b,d){var c;S(d);var e=0==(YF(b)|0);c=(d|0)>>2;var f=d+4|0;a:do{if(e){var g=b}else{for(var h=d+8|0,i=b;;){var m=t[c];(m+1|0)==(t[f>>2]|0)&&(R(d),m=t[c]);l[t[h>>2]+m|0]=i&255;0!=(i|0)&&(i=t[c]+1|0,t[c]=i,l[t[h>>2]+i|0]=0);i=VF();if(0==(YF(i)|0)){g=i;break a}}}}while(0);W(g);e=t[c];(e+1|0)!=(t[f>>2]|0)?(c=t[(d+8|0)>>2],c=c+e|0):(R(d),f=t[c],c=t[(d+8|0)>>2],c=c+f|0);l[c]=0}ZF.X=1;function $F(){for(var b;;){var d=VF();if(10==(d|0)){b=3830;break}if(0==(L(d)|0)){b=3831;break}}if(3831==b||3830==b){return d}}function aG(b,d){V(t[rc>>2],b);t[qc>>2]=d}function bG(){S(t[rc>>2])}function cG(b){var d,c;d=(b+4|0)>>2;a:for(;;){for(var e=t[d];;){if(0==(e|0)){c=3867;break a}var f=l[e];if(0==f<<24>>24){c=3867;break a}if(0!=(dG(f)|0)){c=3869;break a}if(64==f<<24>>24){c=3871;break a}if(0!=((32==f<<24>>24|9==f<<24>>24)&1|0)){c=3873;break}f&=255;if(123==(f|0)){c=3883;break a}else{if(40==(f|0)){c=3875;break a}else{if(45==(f|0)){c=3892;break a}else{if(44==(f|0)){c=3887;break a}else{if(34==(f|0)){c=3890;break a}else{if(43==(f|0)){c=3891;break a}else{if(58==(f|0)){c=3889;break a}else{if(93==(f|0)){c=3886;break a}else{if(125==(f|0)){c=3884;break a}else{if(35==(f|0)){c=3877;break a}else{if(59==(f|0)){c=3888;break a}else{if(92==(f|0)){c=3876;break a}else{if(41==(f|0)){c=3882;break a}else{if(91==(f|0)){c=3885;break a}else{if(47!=(f|0)){c=3893;break a}}}}}}}}}}}}}}}var g=e+1|0,f=l[g];if(42==f<<24>>24){c=3879;break}else{if(47!=f<<24>>24){c=3881;break a}}e=t[d]=0}if(3873==c){c=0;for(var f=b+4|0,h=t[f>>2];0!=((32==l[h]<<24>>24|9==l[h]<<24>>24)&1|0);){h=h+1|0}t[f>>2]=h}else{if(3879==c){c=0;var h=f=ba,f=(b+4|0)>>2,i=t[f]+2|0,m=1,n=1;b:for(;;){c:for(;;){for(var q=0==(m|0),p=i;;){if(q){break b}if(0!=(p|0)){var s=l[p];if(47==s<<24>>24){break}else{if(0!=s<<24>>24){break c}}}i=eC();t[f]=i;if(0==(i|0)){h=3980;break b}else{p=i}}if(n){break}else{i=p,m=0}}i=p+1|0;n=42!=s<<24>>24}3980!=h&&(t[f]=p)}}}if(3871==c){eG(b);var r=mC(t[t[b>>2]+8>>2],t[Uy>>2]),u=-1==(r|0)?37:r}else{if(3883==c){t[d]=e+1|0,u=28}else{if(3875==c){t[d]=e+1|0,u=26}else{if(3892==c){t[d]=e+1|0,u=25}else{if(3887==c){t[d]=e+1|0,u=23}else{if(3890==c){d=(b+4|0)>>2;b=t[d];c=0;a:for(;;){e=b;for(g=0;;){var v=e+1|0;if(c|0==(v|0)){r=3947;break a}p=l[v];if(0==p<<24>>24){r=3948;break a}else{if(34==p<<24>>24&&0==(g|0)){b=v;c=1;continue a}}e=v;g=92==p<<24>>24&1}}3947==r?t[d]=v:3948==r&&(t[d]=v);u=37}else{3891==c?(t[d]=e+1|0,u=24):3893==c?(t[d]=e+1|0,u=37):3869==c?(fG(b),r=mC(t[t[b>>2]+8>>2],t[Uy>>2]),u=-1==(r|0)?22:r):3889==c?(t[d]=e+1|0,u=33):3886==c?(t[d]=e+1|0,u=31):3884==c?(t[d]=e+1|0,u=29):3867==c?(r=eC(),t[d]=r,u=0==(r|0)?38:36):3877==c?(t[d]=e+1|0,u=34):3888==c?(t[d]=e+1|0,u=32):3876==c?(t[d]=e+1|0,u=35):3881==c?(t[d]=g,u=37):3882==c?(t[d]=e+1|0,u=27):3885==c&&(t[d]=e+1|0,u=30)}}}}}}return u}cG.X=1;function dG(b){return(0==(26>(b-97&255)&1|0)?0!=(26>(b-65&255)&1|0):1)&1}function fG(b){var d;d=(b|0)>>2;S(t[d]);var b=(b+4|0)>>2,c=t[b],e=l[c];if(0!=(dG(e)|0)|95==e<<24>>24){var f=t[d],c=t[f>>2];(c+1|0)==(t[f+4>>2]|0)&&(R(f),c=t[d],e=l[t[b]],f=c,c=t[c>>2]);l[t[f+8>>2]+c|0]=e;e=t[b];0!=l[e]<<24>>24&&(e=t[d]|0,c=t[e>>2]+1|0,t[e>>2]=c,l[t[t[d]+8>>2]+c|0]=0,e=t[b])}else{e=c}e=e+1|0;c=l[e];f=0==(gG(c)|0);a:do{if(f){var g=e}else{for(var h=e,i=c;;){var m=t[d],n=t[m>>2];(n+1|0)==(t[m+4>>2]|0)&&(R(m),n=t[d],i=l[h],m=n,n=t[n>>2]);l[t[m+8>>2]+n|0]=i;0!=l[h]<<24>>24&&(i=t[d]|0,n=t[i>>2]+1|0,t[i>>2]=n,l[t[t[d]+8>>2]+n|0]=0);h=h+1|0;i=l[h];if(0==(gG(i)|0)){g=h;break a}}}}while(0);t[b]=g;b=t[d];g=t[b>>2];(g+1|0)!=(t[b+4>>2]|0)?(b=b+8|0,b=t[b>>2],d=b+g|0):(R(b),g=t[d],d=t[g>>2],b=g+8|0,b=t[b>>2],d=b+d|0);l[d]=0}fG.X=1;function hG(b,d){if(27==(d|0)||29==(d|0)||31==(d|0)){var c=t[Kc>>2]-1|0;t[Kc>>2]=c}else{26==(d|0)||28==(d|0)||30==(d|0)?(c=t[Kc>>2]+1|0,t[Kc>>2]=c):c=t[Kc>>2]}0==(c|0)&&(t[z>>2]=t[rd>>2])}function eG(b){var d;d=(b|0)>>2;S(t[d]);var b=(b+4|0)>>2,c=t[b];if(64==l[c]<<24>>24){var e=t[d],f=t[e>>2];(f+1|0)==(t[e+4>>2]|0)?(R(e),f=t[d],c=l[t[b]],e=f,f=t[f>>2]):c=64;l[t[e+8>>2]+f|0]=c;c=t[b];0!=l[c]<<24>>24&&(c=t[d]|0,e=t[c>>2]+1|0,t[c>>2]=e,l[t[t[d]+8>>2]+e|0]=0,c=t[b])}c=c+1|0;e=l[c];f=0==(gG(e)|0);a:do{if(f){var g=c}else{for(var h=c,i=e;;){var m=t[d],n=t[m>>2];(n+1|0)==(t[m+4>>2]|0)&&(R(m),n=t[d],i=l[h],m=n,n=t[n>>2]);l[t[m+8>>2]+n|0]=i;0!=l[h]<<24>>24&&(i=t[d]|0,n=t[i>>2]+1|0,t[i>>2]=n,l[t[t[d]+8>>2]+n|0]=0);h=h+1|0;i=l[h];if(0==(gG(i)|0)){g=h;break a}}}}while(0);t[b]=g;b=t[d];g=t[b>>2];(g+1|0)!=(t[b+4>>2]|0)?(b=b+8|0,b=t[b>>2],d=b+g|0):(R(b),g=t[d],d=t[g>>2],b=g+8|0,b=t[b>>2],d=b+d|0);l[d]=0}eG.X=1;function gG(b){return(0==(10>(b-48&255)&1|0)?95==b<<24>>24|0!=(dG(b)|0):1)&1}function iG(b,d){var c=j;j+=80;sC(c,b);t[c+36>>2]=t[uy+(d<<4)+8>>2];l[c+40|0]=t[uy+(d<<4)+4>>2]&255;var e=t[rc>>2];0!=(e|0)&&(t[c+60>>2]=t[uy+(t[qc>>2]<<4)+8>>2],t[c+64>>2]=t[e+8>>2]);tC(c);j=c}function jG(b,d){24==(d|0)?(t[z>>2]=238,t[Ac>>2]=4):10==(d|0)?(bG(),t[z>>2]=16):25==(d|0)?(t[z>>2]=238,t[Ac>>2]=3):28==(d|0)&&(t[z>>2]=250,hG(0,28),t[rd>>2]=26)}function kG(b){return 32==b<<24>>24||9==b<<24>>24||13==b<<24>>24||10==b<<24>>24?1:0}function lG(b){var d,b=(b+4|0)>>2,c=t[b],e=0;a:for(;;){for(var f=c,g=0;;){var h=f+1|0;if(e|0==(h|0)){d=24;break a}var i=l[h];if(34==i<<24>>24){if(0==(g|0)){c=h;e=1;continue a}}else{if(0==i<<24>>24){d=25;break a}}f=h;g=92==i<<24>>24&1}}24==d?t[b]=h:25==d&&(t[b]=h)}function mG(){for(var b,d=t[t[K+40>>2]+8>>2],c=tb(d),e=P();;){var f=c-1|0;if(0<(f|0)&46!=l[d+f|0]<<24>>24){c=f}else{var g=f;break}}for(;;){if(0>=(g|0)){var h=g;break}c=l[d+g|0];if(92==c<<24>>24||47==c<<24>>24){b=41;break}g=g-1|0}41==b&&(h=g+1|0);b=d+h|0;f=f-h|0;S(e);gD(e,b,f);f=e|0;h=t[f>>2];(h+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=h;h=e+8|0;l[t[h>>2]+f|0]=0;f=t[h>>2];h=l[f];0!=(26>(h-97&255)&1|0)&&(l[f]=h-32&255);nG(e,2);Q(e)}mG.X=1;function oG(b,d){27==(d|0)||14==(d|0)||13==(d|0)?(pG(),t[z>>2]=248,t[Tc>>2]=248):7==(d|0)?(pG(),t[z>>2]=128,t[Tc>>2]=122):0==(d|0)?(pG(),t[z>>2]=t[Tc>>2]):26==(d|0)?(pG(),t[z>>2]=86,t[Tc>>2]=86):17==(d|0)?(pG(),t[z>>2]=68,t[Tc>>2]=68):6==(d|0)?(l[yc]=0,qG()):16==(d|0)?(pG(),t[z>>2]=88):2==(d|0)&&(pG(),t[z>>2]=24,t[Tc>>2]=24)}function rG(b){var d,c;d=(b+4|0)>>2;a:for(;;){for(var e=t[d];;){if(0!=(e|0)){var f=l[e];if(0!=f<<24>>24){break}}var g=eC();t[d]=g;if(0==(g|0)){var h=48;break a}else{e=g}}if(0!=(sG(f)|0)){c=75;break}if(0!=(10>(f-48&255)&1|0)){c=77;break}if(0!=(kG(f)|0)){for(var g=b+4|0,i=t[g>>2];0!=(kG(l[i])|0);){i=i+1|0}t[g>>2]=i}else{g=f&255;if(0!=(t[Gc+(g<<2)>>2]|0)){c=81;break}if(123==(g|0)){c=89;break}else{if(125==(g|0)){c=90;break}else{if(39==(g|0)){c=91;break}else{if(41==(g|0)){c=86;break}else{if(91==(g|0)){c=87;break}else{if(93==(g|0)){c=88;break}else{if(44==(g|0)){c=92;break}else{if(61==(g|0)){c=93;break}else{if(59==(g|0)){c=94;break}else{if(34==(g|0)){c=95;break}else{if(95==(g|0)){c=96;break}else{if(35==(g|0)){c=97;break}else{if(92==(g|0)){c=98;break}else{if(40!=(g|0)){c=99;break}}}}}}}}}}}}}}var m=e+1|0;if(42!=l[m]<<24>>24){c=85;break}tG(b)}}if(89==c){t[d]=e+1|0,h=36}else{if(90==c){t[d]=e+1|0,h=37}else{if(91==c){t[d]=e+1|0,h=38}else{if(85==c){t[d]=m,h=32}else{if(86==c){t[d]=e+1|0,h=33}else{if(81==c){h=uG(b)}else{if(87==c){t[d]=e+1|0,h=34}else{if(88==c){t[d]=e+1|0,h=35}else{if(75==c){vG(b),b=mC(t[t[b>>2]+8>>2],t[Ty>>2]),h=-1==(b|0)?31:b}else{if(77==c){b=b+4|0;d=t[b>>2];if(0!=(10>(l[d]-48&255)&1|0)){for(;!(d=d+1|0,t[b>>2]=d,0==(10>(l[d]-48&255)&1|0));){}}h=41}else{92==c?(t[d]=e+1|0,h=44):93==c?(t[d]=e+1|0,h=40):94==c?(t[d]=e+1|0,h=43):95==c?(lG(b),h=41):96==c?(t[d]=e+1|0,h=41):97==c?(t[d]=e+1|0,h=46):98==c?(t[d]=e+1|0,h=47):99==c&&(t[d]=e+1|0,h=41)}}}}}}}}}}return h}rG.X=1;function sG(b){return(0==(26>(b-97&255)&1|0)?0!=(26>(b-65&255)&1|0):1)&1}function vG(b){var d;d=(b|0)>>2;S(t[d]);var b=(b+4|0)>>2,c=t[b],e=l[c];if(0!=(sG(e)|0)|95==e<<24>>24){var f=t[d],c=t[f>>2];(c+1|0)==(t[f+4>>2]|0)&&(R(f),c=t[d],e=l[t[b]],f=c,c=t[c>>2]);l[t[f+8>>2]+c|0]=e;e=t[b];0!=l[e]<<24>>24&&(e=t[d]|0,c=t[e>>2]+1|0,t[e>>2]=c,l[t[t[d]+8>>2]+c|0]=0,e=t[b])}else{e=c}e=e+1|0;c=l[e];f=0==(wG(c)|0);a:do{if(f){var g=e}else{for(var h=e,i=c;;){var m=t[d],n=t[m>>2];(n+1|0)==(t[m+4>>2]|0)&&(R(m),n=t[d],i=l[h],m=n,n=t[n>>2]);l[t[m+8>>2]+n|0]=i;0!=l[h]<<24>>24&&(i=t[d]|0,n=t[i>>2]+1|0,t[i>>2]=n,l[t[t[d]+8>>2]+n|0]=0);h=h+1|0;i=l[h];if(0==(wG(i)|0)){g=h;break a}}}}while(0);t[b]=g;b=t[d];g=t[b>>2];(g+1|0)!=(t[b+4>>2]|0)?(b=b+8|0,b=t[b>>2],d=b+g|0):(R(b),g=t[d],d=t[g>>2],b=g+8|0,b=t[b>>2],d=b+d|0);l[d]=0}vG.X=1;function uG(b){var d;d=(b+4|0)>>2;var c=t[d],b=(b|0)>>2;S(t[b]);var e=t[d],f=0==(t[Gc+((l[e]&255)<<2)>>2]|0),g=t[b],h=(t[g>>2]+1|0)==(t[g+4>>2]|0);a:do{if(f){var i=0,m=h,n=g}else{for(var q=0,p=g,s=h,r=e;;){if(s&&(R(p),r=t[d],p=t[b]),l[t[p+8>>2]+t[p>>2]|0]=l[r+q|0],p=t[d],0==l[p+q|0]<<24>>24?r=p:(p=t[b]|0,r=t[p>>2]+1|0,t[p>>2]=r,l[t[t[b]+8>>2]+r|0]=0,r=t[d]),q=q+1|0,p=t[b],s=(t[p>>2]+1|0)==(t[p+4>>2]|0),0==(t[Gc+((l[r+q|0]&255)<<2)>>2]|0)){i=q;m=s;n=p;break a}}}}while(0);m?(R(n),m=t[b]):m=n;l[t[m+8>>2]+t[m>>2]|0]=0;t[d]=t[d]+i|0;if(2>(i|0)){d=l[c]&255,d=61==(d|0)?40:124==(d|0)?39:42}else{if(2==(i|0)&&45==l[c]<<24>>24&&62==l[c+1|0]<<24>>24){return 45}d=42}return d}uG.X=1;function tG(b){var d,c;d=(b+4|0)>>2;var e=t[d]+2|0,f=1,g=0;a:for(;;){var g=0==(g|0),h=e;b:for(;;){var e=0==(f|0),i=h;c:for(;;){if(e){c=167;break a}do{if(0!=(i|0)&&(h=l[i],0!=h<<24>>24)){if(42==h<<24>>24){var m=1;c=166;break b}else{if(41==h<<24>>24){break c}else{if(40==h<<24>>24){c=161;break b}else{if(34!=h<<24>>24){c=165;break b}}}}t[d]=i;lG(b);i=t[d];continue c}}while(0);h=eC();t[d]=h;if(0==(h|0)){c=169;break a}else{i=h}}if(g){m=0;c=166;break}else{h=i,f=0}}do{if(161==c){if(c=0,42!=l[i+1|0]<<24>>24){m=0,c=166}else{t[d]=i;tG(b);var n=t[d];if(0==(n|0)){c=170;break a}else{var q=0}}}else{165==c&&(m=0,c=166)}}while(0);166==c&&(c=0,n=i,q=m&1);e=n+1|0;g=q}167==c&&(t[d]=i)}function xG(){for(var b,d=t[Xb>>2];;){var c=d-1|0;if(0>=(d|0)){var e=-1;b=205;break}if(0==(t[t[Yb+(c<<4)+12>>2]>>2]|0)){d=c}else{e=c;b=204;break}}if(205==b||204==b){return e}}function yG(b,d){if(42==(d|0)){var c=l[t[b+8>>2]]<<24>>24;58==(c|0)?(t[rd>>2]=20,t[z>>2]=154,t[Ib>>2]=40):126==(c|0)?(t[z>>2]=172,l[md]=0):63==(c|0)&&(t[z>>2]=144,l[md]=0)}else{40==(d|0)&&(t[z>>2]=20)}}function wG(b){if(0!=(10>(b-48&255)&1|0)){return 1}b=0!=(sG(b)|0)|95==b<<24>>24|39==b<<24>>24;return b&1}function pG(){l[yc]&&(l[yc]=0,zG())}function qG(){var b=zG();5==(b|0)?zG():4==(b|0)?zG():3==(b|0)?zG():0==(b|0)&&zG()}function nG(b,d){var c=j;j+=80;!(0==(t[ry+(d<<4)>>2]|0)|0==(b|0))&&0!=(t[b>>2]|0)&&(AG(c,t[b+8>>2],d),tC(c));j=c}function AG(b,d,c){var e=b>>2;sC(b,d);t[e+9]=t[ry+(c<<4)+8>>2];l[b+40|0]=t[ry+(c<<4)+4>>2]&255;2==(c|0)&&(t[e]=1,t[e+1]=1);b=xG();-1<(b|0)&&(t[e+15]=0==(t[Yb+(b<<4)+4>>2]|0)?wf|0:6==(t[Yb+(b<<4)+4>>2]|0)?al|0:2==(t[Yb+(b<<4)+4>>2]|0)?Fi|0:3==(t[Yb+(b<<4)+4>>2]|0)?Eq|0:1==(t[Yb+(b<<4)+4>>2]|0)?ll|0:4==(t[Yb+(b<<4)+4>>2]|0)?Cf|0:5==(t[Yb+(b<<4)+4>>2]|0)?Bw|0:0,t[e+16]=t[t[Yb+(b<<4)+12>>2]+8>>2])}function zG(){for(var b,d=t[Xb>>2];;){var c=d-1|0;if(0>=(d|0)){b=300;break}if(0==(t[Yb+(c<<4)>>2]|0)){b=299;break}else{d=c}}if(299==b){return t[Xb>>2]=c,t[z>>2]=t[Yb+(c<<4)+8>>2],S(t[Yb+(c<<4)+12>>2]),b=t[Yb+(c<<4)+4>>2]}if(300==b){return t[Xb>>2]=0,t[z>>2]=122,-1}}function BG(b,d,c,e){var f=j,g=t[Xb>>2];255<(g|0)?KC(Qk|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k)):(t[Yb+(g<<4)>>2]=b,t[Yb+(g<<4)+4>>2]=d,t[Yb+(g<<4)+8>>2]=c,b=xG(),0==(e|0)?(t[Xb>>2]=g+1|0,S(t[Yb+(g<<4)+12>>2])):(g=t[Yb+(g<<4)+12>>2],-1<(b|0)?(V(g,t[t[Yb+(b<<4)+12>>2]+8>>2]),g=t[Yb+(t[Xb>>2]<<4)+12>>2],d=t[g>>2],(d+1|0)==(t[g+4>>2]|0)&&(R(g),g=d=t[Yb+(t[Xb>>2]<<4)+12>>2],d=t[d>>2]),c=4==(t[Yb+(b<<4)+4>>2]|0)||5==(t[Yb+(b<<4)+4>>2]|0)||3==(t[Yb+(b<<4)+4>>2]|0)||1==(t[Yb+(b<<4)+4>>2]|0)?47:0==(t[Yb+(b<<4)+4>>2]|0)?46:6==(t[Yb+(b<<4)+4>>2]|0)?32:2==(t[Yb+(b<<4)+4>>2]|0)?35:36,b=g+8|0,l[t[b>>2]+d|0]=c,0!=c<<24>>24&&(d=g|0,c=t[d>>2]+1|0,t[d>>2]=c,l[t[b>>2]+c|0]=0),U(g,t[e+8>>2])):V(g,t[e+8>>2]),t[Xb>>2]=t[Xb>>2]+1|0));j=f}BG.X=1;function CG(b,d){30==(d|0)?(DG(),t[z>>2]=160,EG(160)):11==(d|0)?(EG(12),t[z>>2]=20):1==(d|0)?(BG(0,6,20,0),t[z>>2]=20):6==(d|0)?qG():10==(d|0)?(t[rd>>2]=20,t[z>>2]=114,t[Ib>>2]=45):36==(d|0)?(t[z>>2]=104,t[Ib>>2]=37,t[rd>>2]=12,FG(0,36)):39==(d|0)||33==(d|0)||35==(d|0)||37==(d|0)?DG():12==(d|0)?GG():5==(d|0)||24==(d|0)?(DG(),EG(12),t[z>>2]=20):0==(d|0)?(GG(),t[z>>2]=188):15==(d|0)?(EG(12),t[z>>2]=20):32==(d|0)||34==(d|0)?(EG(12),t[z>>2]=20):43==(d|0)?t[z>>2]=20:4==(d|0)||27==(d|0)||(l[yc]=1,oG(0,d))}function EG(b){BG(1,3,b,0)}function GG(){var b=xG();-1<(b|0)?(t[Xb>>2]=b,t[z>>2]=t[Yb+(b<<4)+8>>2],S(t[Yb+(b<<4)+12>>2])):(t[Xb>>2]=0,t[z>>2]=122)}function DG(){var b=t[Xb>>2];1>(b|0)?t[z>>2]=122:(b=b-1|0,t[Xb>>2]=b,t[z>>2]=t[Yb+(b<<4)+8>>2],S(t[Yb+(b<<4)+12>>2]))}function FG(b,d){35==(d|0)?t[qd>>2]=t[qd>>2]+1|0:33==(d|0)?t[od>>2]=t[od>>2]+1|0:34==(d|0)?t[qd>>2]=t[qd>>2]-1|0:37==(d|0)?t[pd>>2]=t[pd>>2]+1|0:36==(d|0)?t[pd>>2]=t[pd>>2]-1|0:32==(d|0)&&(t[od>>2]=t[od>>2]-1|0);(t[Ib>>2]|0)==(d|0)&0==(t[od>>2]|0)&0==(t[qd>>2]|0)&0==(t[pd>>2]|0)?t[z>>2]=t[rd>>2]:6==(d|0)&&(zG(),t[z>>2]=122)}function HG(){var b=j;j+=80;var d,c=P(),e=eC();t[nd>>2]=e;if(0!=(e|0)){for(var f=0,g=0,h=0,i=0,m=0,n=0,q=0,p=0;;){var s=e+1|0;t[nd>>2]=s;var r=l[e],e=r&255;if(0==r<<24>>24){if(r=eC(),t[nd>>2]=r,0==(r|0)){var u=p,v=q,w=n,C=m,A=i,I=h,M=g,B=f}else{if(s=l[r],0==s<<24>>24){u=p,v=q,w=n,C=m,A=i,I=h,M=g,B=f}else{if((0==(h|0)|0==(f|0))&0==(i|0)){d=r+1|0,t[nd>>2]=d,G=s&255,Z=d}else{var G=e,Z=r}d=522}}}else{G=e,Z=s,d=522}a:do{if(522==d){if(d=0,0!=(q|0)){123==(n|0)&125==(G|0)?(u=p,v=0,w=n):40==(n|0)&42==(G|0)?(41!=l[Z]<<24>>24?(u=p,v=q):(t[nd>>2]=Z+1|0,u=p,v=0),w=40):(u=p,v=q,w=n),C=m,A=i,I=h,M=g,B=f}else{if(0!=(m|0)){u=p,v=0,w=n,C=39==(G|0)?0:m,A=i,I=h,M=g,B=f}else{if(40==(G|0)){42==l[Z]<<24>>24?(t[nd>>2]=Z+1|0,u=p,v=1,w=40,C=0,A=i,I=h,M=g):(u=p,v=0,w=n,C=0,A=i,I=h,M=0==(h|0)?g:1),B=f}else{if(123==(G|0)){u=p,v=1,w=123,C=0,A=i,I=h,M=g,B=f}else{if(39==(G|0)){u=p,v=0,w=n,C=1,A=i,I=h,M=g,B=f}else{if(41==(G|0)){u=p,v=0,w=n,C=0,A=i,I=h,M=0,B=f}else{if(59==(G|0)){if(0!=(h|0)&0==(g|0)){e=1}else{u=p;v=0;w=n;C=0;A=i;I=h;M=g;B=f;break}}else{e=f}do{if(0==(h|0)|0==(e|0)){I=h,B=e}else{B=l[Z];if(0==B<<24>>24){u=p;v=0;w=n;C=0;A=i;I=h;M=g;B=e;break a}else{if(32==B<<24>>24){I=h;B=e;break}}0==(rA(101==B<<24>>24&1)|0)?102!=(rA(l[t[nd>>2]]&255)|0)?(B=h,u=e):(B=(u=0==(IG(cl|0)|0))?h:0,u=u?e:0):(B=(u=0==(IG(Vn|0)|0))?h:0,u=u?e:0);if(0==(B|0)|0==(u|0)){I=B,B=u}else{0!=(t[b+32>>2]|0)&&tC(b);u=p;v=0;w=n;C=0;A=i;I=0;M=g;B=0;break a}}}while(0);if(0==(i|0)){0!=(I|0)?(u=p,v=0,w=n,A=C=0):(u=rA(G),99==(u|0)?(u=(A=0==(IG(oj|0)|0))?p:1,v=0,w=n,C=0,A=A&1^1):100==(u|0)?(u=(A=0==(IG(Mh|0)|0))?p:1,v=0,w=n,C=0,A=A&1^1):112==(u|0)?(u=(A=0==(IG(sg|0)|0))?p:1,v=0,w=n,C=0,A=A&1^1):102==(u|0)?(u=(A=0==(IG(of|0)|0))?p:0,v=0,w=n,C=0,A=A&1^1):(u=p,v=0,w=n,A=C=0),I=0)}else{if(u=l[t[nd>>2]],0==u<<24>>24){u=p,v=0,w=n,C=0,A=i}else{u=0==(L(u&255)|0);v=t[nd>>2];b:do{if(u){var X=v}else{for(w=v;;){if(w=w+1|0,t[nd>>2]=w,C=t[nd>>2],0==(L(l[w]&255)|0)){X=C;break b}else{w=C}}}}while(0);b:for(;;){u=l[X];if(0==u<<24>>24){break}do{if(0==(oA(u&255)|0)&&(v=l[X],!(95==v<<24>>24||46==v<<24>>24)&&10<=((v&255)-48|0)>>>0)){break b}}while(0);X=X+1|0}w=t[nd>>2];u=c;v=w;w=X-w|0;S(u);gD(u,v,w);u=b;v=p;!(0==(t[ky+(v<<4)>>2]|0)|0==(c|0))&&0!=(t[c>>2]|0)?(sC(u,t[c+8>>2]),t[u+36>>2]=t[ky+(v<<4)+8>>2],l[u+40|0]=t[ky+(v<<4)+4>>2]&255):sC(u,0);t[nd>>2]=X;u=p;v=0;w=n;A=C=0;I=1}}M=g}}}}}}}}while(0);e=t[nd>>2];if(0==(e|0)){break}else{f=B,g=M,h=I,i=A,m=C,n=w,q=v,p=u}}}Q(c);j=b}HG.X=1;function IG(b){for(var d,c=0;;){var e=l[b];if(0==e<<24>>24){break}if((rA(e<<24>>24)|0)!=(rA(l[t[nd>>2]+c|0]&255)|0)){d=568;break}b=b+1|0;c=c+1|0}if(568==d&&0!=l[b]<<24>>24||0!=(oA(l[t[nd>>2]+c|0]&255)|0)){return 0}d=t[nd>>2]+c|0;b=l[d];if(95==b<<24>>24||46==b<<24>>24){return 0}t[nd>>2]=d;return 1}function JG(){var b,d,c,e,f=j;j+=80;var g,h=P();e=(h|0)>>2;var i=h+4|0;c=(h+8|0)>>2;var m=f+40|0,n=f+36|0,q=f+32|0,p=0,s=0;a:for(;;){var r=eC();if(0==(r|0)){var u=p;break}if(0!=(s|0)){s=0==(N(r,nj|0,4)|0)?0:s}else{if(s=l[r],61==s<<24>>24){r=r+1|0;if(0==(pA(l[r]<<24>>24)|0)){r=0}else{c:{for(var s=r,v=aq|0,w=ba,C={};;){w=l[v++];if(!w){break}C[w]=1}for(;;){w=l[s];if(!w){break}if(w in C){break c}s++}s=0}v=0==(s|0)?tb(r):s-r|0;s=zC(v+1|0);iB(s,r,v);for(v=r=l[s+v|0]=0;;){var A=0==(qA(s,t[Fc+(v<<2)>>2])|0)?1:r,v=v+1|0;if(11>v>>>0&0==(A|0)){r=A}else{break}}vB(s);r=A}s=r}else{if(0==(qA(r,Lh|0)|0)){u=p;break}if(0==(qA(r,rg|0)|0)){u=p;break}if(35!=s<<24>>24){for(;;){v=r+1|0;if(0==(L(s&255)|0)){break}r=v;s=l[v]}do{if(0==(N(r,nf|0,3)|0)){b=p;var I=4,M=r+3|0}else{if(0==(N(r,Ze|0,3)|0)){s=r+3|0;if(0==(L(l[s]&255)|0)){s=0;continue a}for(;;){v=l[s];if(0==v<<24>>24){break}if(0==(L(v&255)|0)){break}else{s=s+1|0}}if(0!=(N(s,Rr|0,8)|0)){s=0;continue a}b=p;I=0;M=s+8|0}else{if(0!=(N(r,Gi|0,7)|0)){if(0==(N(r,as|0,6)|0)){b=p;I=1;M=r+6|0;g=631;break}if(0==((95==(l[r]&255|0)|0!=(pA(l[r]&255)|0))&1|0)){s=0;continue a}else{s=r}for(;;){if(0==(KG(l[s]&255)|0)){var B=s;break}else{s=s+1|0}}for(;;){var G=B+1|0;if(0==(L(l[B]&255)|0)){break}else{B=G}}if(58!=l[B]<<24>>24){s=0;continue a}if(s=58==l[G]<<24>>24){s=0;continue a}else{var Z=r,X=p;d=X>>2;var ga=s?-1:2,ra=1;break}}g=r+7|0;0==(p|0)?I=P():(S(p),I=p);for(v=g;0!=(L(l[v]&255)|0);){v=v+1|0}b=(I|0)>>2;M=I+4|0;for(s=I+8|0;;){w=l[v];if(59==w<<24>>24){break}if(0!=(L(w&255)|0)){break}w=t[b];(w+1|0)==(t[M>>2]|0)&&(R(I),w=t[b]);l[t[s>>2]+w|0]=l[v];0!=l[v]<<24>>24&&(w=t[b]+1|0,t[b]=w,l[t[s>>2]+w|0]=0);v=v+1|0}U(I,Bv|0);b=I;I=3;M=g}}g=631}while(0);do{if(631==g){if(g=0,p=l[M],0==p<<24>>24){Z=M,X=b,d=X>>2,ga=I,ra=0}else{if(0==(L(p&255)|0)){p=b;s=0;continue a}else{Z=M,X=b,d=X>>2,ga=I,ra=0}}}}while(0);for(p=Z;;){if(0==(L(l[p]&255)|0)){var ka=p;break}p=p+1|0}b:for(;;){p=l[ka];if(!(0==p<<24>>24||35==p<<24>>24)){var ia=ka,ea=p;break}p=eC();if(0==(p|0)){u=X;break a}for(;;){if(0==(L(l[p]&255)|0)){ka=p;continue b}else{p=p+1|0}}}for(;;){if(0==(KG(ea&255)|0)){if(1==(ga|0)){g=647;break}else{if(3!=(ga|0)){break}}if(58!=l[ia]<<24>>24){break}}ea=t[e];(ea+1|0)==(t[i>>2]|0)&&(R(h),ea=t[e]);l[t[c]+ea|0]=l[ia];0!=l[ia]<<24>>24&&(ea=t[e]+1|0,t[e]=ea,l[t[c]+ea|0]=0);ia=ea=ia+1|0;ea=l[ea]}647==g&&(g=0,0==(t[e]|0)&&61==l[ia]<<24>>24&&U(h,Fu|0));p=t[e];(p+1|0)==(t[i>>2]|0)&&(R(h),p=t[e]);l[t[c]+p|0]=0;if(0!=(t[e]|0)){do{if(4==(ga|0)){sC(f,t[c]);do{p=ba;s=ia;r=v=0;b:for(;;){for(w=s;;){var wb=l[w];if(0!=wb<<24>>24){break}s=eC();if(0==(s|0)){var sb=0;break b}else{w=s}}s=0==(r|0);for(C=wb;;){C&=255;if(32==(C|0)||9==(C|0)){var Db=v,Za=r;break}else{if(58==(C|0)){p=688;break}else{if(40==(C|0)){p=690;break}else{if(41==(C|0)){p=691;break}else{if(59==(C|0)){if(s){sb=1;break b}}else{if(123==(C|0)&&s){sb=0;break b}}}}}}if(0==(v|0)){p=697;break}if(0==((95==(C|0)|0!=(pA(C)|0))&1|0)){sb=0;break b}else{v=w}for(;;){var kc=v+1|0;if(0==(KG(l[kc]&255)|0)){break}else{v=kc}}w=kc;v=0;C=l[kc]}do{if(688==p){if(p=0,s){if(1==(v|0)){sb=0;break b}else{Db=1,Za=0}}else{Db=v,Za=r}}else{if(690==p){p=0,Db=v,Za=r+1|0}else{if(691==p){p=0,Db=v,Za=r-1|0}else{if(697==p){if(p=0,s){sb=0;break b}else{Db=0,Za=r}}}}}}while(0);s=w+1|0;v=Db;r=Za}if(1==(sb|0)){if(1==(t[iy+80>>2]|0)){p=5}else{S(h);p=X;s=0;continue a}}else{p=4}}while(0);l[m]=t[iy+(p<<4)+4>>2]&255;t[n>>2]=t[iy+(p<<4)+8>>2];tC(f);!(0==(t[oy+4>>2]|0)|ra|0==(X|0))&&0!=(t[d]|0)&&(p=P(),V(p,t[d+2]),U(p,t[c]),t[q>>2]=t[p+8>>2],tC(f),Q(p))}else{jC(h,iy|0,ga),!(0==(t[oy+4>>2]|0)|ra|3==(ga|0)|0==(X|0))&&0!=(t[d]|0)&&(p=P(),V(p,t[d+2]),U(p,t[c]),jC(p,iy|0,ga),Q(p))}}while(0)}S(h);p=X}s=0}}}Q(h);0!=(u|0)&&Q(u);j=f}JG.X=1;function KG(b){return(95==(b|0)|0!=(oA(b)|0))&1}function LG(){var b,d,c,e=j;j+=12;var f,g=e+4;c=g>>2;var h=e+8,i=P(),m=P(),n=P(),q=MG(12);t[e>>2]=0;var p=i|0,s=i+8|0;d=(m|0)>>2;var r=m+4|0;b=(m+8|0)>>2;var u=n|0,v=0,w=1;a:for(;;){for(;;){var C=eC();if(0==(C|0)){break a}var A=l[NG(C)];if(0!=A<<24>>24){if(35!=A<<24>>24){break}if(!w){break}}}0==(v|0)&&S(i);U(i,C);DD(i);var I=t[s>>2],M=92==l[I+(t[p>>2]-1)|0]<<24>>24;b:do{if(M){zD(i);U(i,Eo|0);var B=1}else{var G=NG(I),Z=G-I|0;if(w){for(var X=ba,ga=t[q+4>>2],ra=q|0,ka=n+8|0,ia=0;;){if((ia|0)>=(ga|0)){X=770;break}var ea=t[ra>>2],wb=ea+12*ia|0;if(0!=(wb|0)){var sb=t[(ea+4>>2)+(3*ia|0)];if(0==(qA(t[ka>>2],t[sb+8>>2])|0)){break}}ia=ia+1|0}770!=X&&((t[wb>>2]|0)<(Z|0)||S(sb));var Db=OG(G,e);if(0!=(Db|0)){PG(Db+3|0,e)}else{for(var Za,kc=G;;){if(0==l[kc]<<24>>24){var $c=0;break}var Ia=QG(kc);if(0==(N(Ia,wk|0,3)|0)){$c=Ia;break}if(0==(N(Ia,Fi|0,5)|0)){$c=Ia;break}if(0==(N(Ia,kn|0,4)|0)){$c=Ia;break}if(0==(N(Ia,Ym|0,5)|0)){$c=Ia;break}kc=RG(Ia)}Za=$c;var Eb=0==(Za|0);c:do{if(!Eb){t[c]=0;do{if(0==(N(Za,ng|0,4)|0)){var Pb=NG(Za+3|0)}else{if(0==(N(Za,gf|0,6)|0)){var He=NG(Za+5|0);t[c]=1;Pb=He}else{if(0==(N(Za,Fd|0,5)|0)){var Hd=SG(NG(Za+4|0),g);if(0==(Hd|0)){break c}else{Pb=Hd;break}}if(0!=(N(Za,Mw|0,6)|0)){break c}var de=SG(NG(Za+5|0),g);if(0==(de|0)){break c}else{Pb=de}}}}while(0);var ee=TG(q,Z,n),Id=t[c];if(0==(Id|0)){var Jd=m,uc=n,Kd=ee,Qb;var Mc=UG(Pb,Jd),ad=ba;if(0==(Mc|0)){var bb=0}else{var Qa=mA(Mc,40);if(0==(Qa|0)){bb=0}else{var Rb=1,vc=Qa;e:for(;;){for(var Sb=0<(Rb|0),fe=vc;;){var vd=fe+1|0;if(!Sb){break e}var lc=l[vd];if(41==lc<<24>>24){ad=981;break}else{if(40==lc<<24>>24){ad=980;break}else{if(0==lc<<24>>24){break e}else{fe=vd}}}}981==ad?(ad=0,Rb=Rb-1|0,vc=vd):980==ad&&(ad=0,Rb=Rb+1|0,vc=vd)}l[vd]=0;bb=jB(Qa)}}Qb=bb;VG(Jd,uc,Kd);0!=(Qb|0)&&vB(Qb)}else{WG(Pb,m,n,ee)}for(var Nc=Z,ge=m,he=Id,Tb=q|0,Ub=q+4|0,bd=t[Ub>>2],cd=0,ac=0;;){if((ac|0)>=(bd|0)){var ie=cd;break}var Ld=t[Tb>>2]+12*ac|0;if((t[Ld>>2]|0)<(Nc|0)){cd=Ld,ac=ac+1|0}else{ie=Ld;break}}if((ac|0)==(bd|0)){var gb=q,dd=ge,Vb=ba,Sa=ba,Sa=(gb+4|0)>>2,Oc=t[Sa],Pc=gb+8|0,Md=t[Pc>>2];if((Oc|0)<(Md|0)){var ed=Oc,je=gb|0}else{var ke=Md+1|0;t[Pc>>2]=ke;var wd=gb|0,Vb=wd>>2;t[Vb]=jF(t[Vb],12*ke|0);var xd=P();t[(t[Vb]+4>>2)+(3*t[Sa]|0)]=xd;ed=t[Sa];je=wd}var ob=t[je>>2];t[Sa]=ed+1|0;V(t[(ob+4>>2)+(3*ed|0)],t[dd+8>>2]);t[(ob+8>>2)+(3*ed|0)]=0;var Fb=t[Tb>>2]+12*bd|0}else{t[Ub>>2]=ac+1|0,V(t[ie+4>>2],t[ge+8>>2]),Fb=ie}t[Fb>>2]=Nc;t[Fb+8>>2]=0==(he|0)&1}}while(0);var fd=XG(I);do{if(0!=(fd|0)){S(m);var le=0==(YG(l[fd]<<24>>24)|0),gd=t[d],yd=(gd+1|0)==(t[r>>2]|0);c:do{if(le){var Nd=yd,Od=gd}else{for(var wc=fd,xc=yd,hd=gd;;){if(xc){R(m);var Pd=t[d]}else{Pd=hd}l[t[b]+Pd|0]=l[wc];if(0!=l[wc]<<24>>24){var bc=t[d]+1|0;t[d]=bc;l[t[b]+bc|0]=0}var me=wc+1|0,Qd=t[d],ne=(Qd+1|0)==(t[r>>2]|0);if(0==(YG(l[me]<<24>>24)|0)){Nd=ne;Od=Qd;break c}else{wc=me,xc=ne,hd=Qd}}}}while(0);if(Nd){R(m);var cc=t[d]}else{cc=Od}l[t[b]+cc|0]=0;var id=TG(q,Z,n),yb=0!=(id|0);if(0==(ZG(fd,h)|0)){if(!yb&&0!=(t[u>>2]|0)){B=0;break b}var Rd=t[b],oe=n,jd=ba,Qc=j;j+=80;jd=Qc>>2;sC(Qc,Rd);t[jd+9]=qf|0;l[Qc+40|0]=118;0!=(t[oe>>2]|0)&&(t[jd+15]=Fi|0,t[jd+16]=t[oe+8>>2]);tC(Qc);j=Qc}else{yb?f=743:0==(t[u>>2]|0)&&(f=743),743==f&&(f=0,VG(m,n,id)),vB(t[h>>2])}}}while(0);var mc=tA(QG(I),Yv|0);if(0!=(mc|0)&&0!=(L(l[mc+6|0]<<24>>24)|0)){var pe=NG(mc+7|0),Rc=P(),kd=P(),nc=QG(pe),Sd=0==l[nc]<<24>>24;c:do{if(!Sd){for(var Sc=kd+8|0,Td=Rc+8|0,qe=nc;;){var hf=QG(UG(qe,Rc));UG(hf,kd);0!=(qA(t[Sc>>2],Ur|0)|0)&&0!=(qA(t[Td>>2],Ur|0)|0)&&jC(Rc,fy|0,4);if(0==l[hf]<<24>>24){break c}else{qe=hf}}}}while(0);Q(Rc);Q(kd)}}}else{PG(G,e)}B=0}}while(0);v=B;w=0==(t[e>>2]|0)}Q(n);Q(m);Q(i);var jf=q+8|0,Ag=0<(t[jf>>2]|0),JH=q|0,KH=t[JH>>2];a:do{if(Ag){for(var Xp=0,LH=KH;;){Q(t[(LH+4>>2)+(3*Xp|0)]);var MH=Xp+1|0,NH=t[JH>>2];if((MH|0)<(t[jf>>2]|0)){Xp=MH,LH=NH}else{var Yp=NH;break a}}}else{Yp=KH}}while(0);if(0==(Yp|0)){var OH=q}else{vB(Yp),OH=q}vB(OH);j=e}LG.X=1;function NG(b){for(;0!=(L(l[b]<<24>>24)|0);){b=b+1|0}return b}function PG(b,d){for(var c=b;;){c=tA(c,t[d>>2]);if(0==(c|0)){break}t[d>>2]=0;c=OG(c+3|0,d);if(0==(c|0)){break}else{c=c+3|0}}}function OG(b,d){for(var c,e=b;;){var f=l[e];if(34==f<<24>>24||39==f<<24>>24){if(0==(N(e,Cm|0,3)|0)){c=774;break}if(0==(N(e,Lm|0,3)|0)){c=776;break}f=$G(e);if(0==l[f]<<24>>24){var g=0;break}else{e=f}}else{if(0==f<<24>>24||35==f<<24>>24){g=0;break}}e=e+1|0}776==c?(t[d>>2]=Lm|0,g=e):774==c&&(t[d>>2]=Cm|0,g=e);return g}function SG(b,d){var c,e=NG(b);if(0==(N(Vn|0,e,6)|0)){e=NG(e+6|0);if(0==(N(Gn|0,e,4)|0)){var f;return 0}var g=e}else{g=e}if(0==(N(Fi|0,g,5)|0)){return t[d>>2]=1,f=NG(g+5|0)}var e=0,h=b;a:for(;;){var i=l[g];if(0==i<<24>>24){f=0;c=804;break}var m=e+1|0;if(2>(e|0)){var n=g}else{f=0;c=806;break}for(;;){if(0==i<<24>>24||61==i<<24>>24||40==i<<24>>24){var q=i;break}var p=n+1|0;if(0!=(L(i<<24>>24)|0)){c=797;break}n=p;i=l[p]}797==c&&(c=0,q=l[n]);if(40==q<<24>>24){c=801;break}else{if(0==q<<24>>24||61==q<<24>>24){f=0;c=807;break}}for(i=n=NG(n);;){if(42==l[i]<<24>>24){i=i+1|0}else{e=m;g=n;h=i;continue a}}}if(801==c){return h}if(804==c||806==c||807==c){return f}}SG.X=1;function TG(b,d,c){var e;S(c);for(var f=b|0,b=b+4|0,g=0,h=0,i=0;;){if((i|0)>=(t[b>>2]|0)){e=817;break}var m=t[f>>2],n=m+12*i|0;if((t[n>>2]|0)>=(d|0)){e=816;break}0!=(h|0)&&U(c,Xi|0);U(c,t[t[(m+4>>2)+(3*i|0)]+8>>2]);g=0==(t[(m+8>>2)+(3*i|0)]|0)&1;h=n;i=i+1|0}if(817==e||816==e){return g}}function WG(b,d,c,e){var f,g,h=P();S(h);var i=NG(UG(b,d));if(40==l[i]<<24>>24){g=(h|0)>>2;f=(h+4|0)>>2;b=(h+8|0)>>2;for(i=i+1|0;;){var m=l[i];if(0==m<<24>>24){i=eC();if(0==(i|0)){break}var n=t[g];(n+1|0)==(t[f]|0)&&(R(h),n=t[g]);l[t[b]+n|0]=32;n=t[g]+1|0;t[g]=n;l[t[b]+n|0]=0}else{if(41==m<<24>>24){break}n=t[g];(n+1|0)==(t[f]|0)&&(R(h),m=l[i],n=t[g]);l[t[b]+n|0]=m;0!=l[i]<<24>>24&&(n=t[g]+1|0,t[g]=n,l[t[b]+n|0]=0);i=i+1|0}}i=t[g];(i+1|0)==(t[f]|0)?(R(h),f=t[g]):f=i;l[t[b]+f|0]=0}d=t[(d+8|0)>>2];f=j;j+=80;b=f>>2;sC(f,d);t[b+9]=Fi|0;l[f+40|0]=99;0!=(t[c>>2]|0)&&(t[(f+60|0)>>2]=0==(e|0)?Cf|0:Fi|0,t[b+16]=t[c+8>>2]);t[b+14]=t[h+8>>2];tC(f);j=f;Q(h)}WG.X=1;function XG(b){var d,c=mA(b,61);if(0==(c|0)){var e;return 0}for(var f=c;;){var f=f+1|0,g=l[f];if(0==g<<24>>24||40==g<<24>>24||35==g<<24>>24){var h=c;break}else{if(61==g<<24>>24){e=0;d=860;break}}}if(860==d){return e}for(;;){d=h-1|0;if(d>>>0<b>>>0){var i=d;break}if(0==(L(l[d]<<24>>24)|0)){i=d;break}else{h=d}}for(;i>>>0>=b>>>0&&0!=(YG(l[i]<<24>>24)|0);){i=i-1|0}d=i+1|0;if(0==((95==(l[d]<<24>>24|0)|0!=(pA(l[d]<<24>>24)|0))&1|0)){return 0}for(;i>>>0>=b>>>0&&0!=(L(l[i]<<24>>24)|0);){i=i-1|0}return(i+1|0)==(b|0)?d:0}function YG(b){return(95==(b|0)|0!=(oA(b)|0))&1}function ZG(b,d){var c,e,f,g=NG(RG(NG(b)));if(61!=l[g]<<24>>24){return 0}g=NG(g+1|0);if(0!=(N(g,xo|0,6)|0)){return 0}var g=g+6|0,h=NG(g);if((h|0)==(g|0)){return 0}g=P();f=(g|0)>>2;c=t[f];e=(g+4|0)>>2;if((c+1|0)==(t[e]|0)){R(g);var i=t[f]}else{i=c}c=(g+8|0)>>2;l[t[c]+i|0]=40;i=t[f]+1|0;t[f]=i;for(l[t[c]+i|0]=0;;){var i=l[h],m=t[f],n=(m+1|0)==(t[e]|0);if(58==i<<24>>24||0==i<<24>>24){break}if(n){R(g);var i=l[h],q=t[f]}else{q=m}l[t[c]+q|0]=i;0!=l[h]<<24>>24&&(i=t[f]+1|0,t[f]=i,l[t[c]+i|0]=0);h=h+1|0}n&&(R(g),m=t[f]);l[t[c]+m|0]=41;m=t[f]+1|0;t[f]=m;l[t[c]+m|0]=0;m=t[f];(m+1|0)==(t[e]|0)?(R(g),e=t[f]):e=m;l[t[c]+e|0]=0;0!=(d|0)&&(t[d>>2]=jB(t[c]));Q(g);return 1}ZG.X=1;function VG(b,d,c){var e,f=j;j+=80;e=f>>2;b=b+8|0;sC(f,t[b>>2]);var g=f+36|0;t[g>>2]=Cf|0;var h=f+40|0;l[h]=102;0!=(t[d>>2]|0)&&(0==(c|0)?t[e+15]=Cf|0:(t[g>>2]=$p|0,l[h]=109,t[e+15]=Fi|0),t[e+16]=t[d+8>>2]);d=t[b>>2];0==(N(d,Jp|0,2)|0)&&0!=(qA(d,sp|0)|0)?(t[e+11]=nx|0,t[e+4]=1):t[e+11]=Yf|0;tC(f);j=f}function $G(b){var d,c=b,e=0;a:for(;;){for(var f=0==(e|0),g=c;;){var h=g+1|0,c=l[h];if(0==c<<24>>24){var i=h;d=934;break a}if(!f){break}if(92==c<<24>>24){c=h;e=1;continue a}if(c<<24>>24==l[b]<<24>>24){break a}else{g=h}}c=h;e=e-1|0}return 934==d?i:g+2|0}function QG(b){var d;a:for(;;){var c=l[b];b:do{if(34==c<<24>>24||39==c<<24>>24||35==c<<24>>24){var e=b;d=949}else{if(0==c<<24>>24){var f=b;d=953;break a}else{do{if(0!=(sA(b,bv|0,2)|0)&&0!=(sA(b,Du|0,2)|0)&&0!=(sA(b,bu|0,2)|0)&&0!=(sA(b,Dt|0,2)|0)&&0!=(sA(b,ct|0,2)|0)&&0!=(sA(b,Es|0,2)|0)){do{if(0!=(sA(b,ms|0,3)|0)&&0!=(sA(b,Xr|0,3)|0)&&0!=(sA(b,xr|0,3)|0)&&0!=(sA(b,gr|0,3)|0)){var g=b,h=c;break b}}while(0);e=b+2|0;d=949;break b}}while(0);e=b+1|0;d=949}}}while(0);if(949==d&&(d=0,g=$G(e),h=l[g],0==h<<24>>24)){f=g;d=954;break}if(0==((95==(h<<24>>24|0)|0!=(pA(h<<24>>24)|0))&1|0)){b=g+1|0}else{f=g;d=952;break}}if(952==d||953==d||954==d){return f}}QG.X=1;function UG(b,d){var c;S(d);var e=0==(YG(l[b]<<24>>24)|0);c=(d|0)>>2;var f=t[c],g=d+4|0,h=(f+1|0)==(t[g>>2]|0);a:do{if(e){var i=b,m=h,n=f}else{for(var q=d+8|0,p=b,s=h,r=f;;){if(s&&(R(d),r=t[c]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[g>>2]|0),0==(YG(l[p]<<24>>24)|0)){i=p;m=s;n=r;break a}}}}while(0);if(!m){return c=t[(d+8|0)>>2],n=c+n|0,l[n]=0,i}R(d);n=t[c];c=t[(d+8|0)>>2];n=c+n|0;l[n]=0;return i}UG.X=1;function RG(b){for(;0!=(YG(l[b]<<24>>24)|0);){b=b+1|0}return b}function aH(){var b,d=j;j+=4;var c;b=d>>2;var e=bH();t[tc>>2]=e;e=1;a:for(;;){b:for(;;){var f=eC();if(0==(f|0)){break a}t[b]=f;if(0!=(cH(d,Zm|0)|0)){e=0;continue a}if(0!=(cH(d,Ok|0)|0)){e=1;continue a}dH(d);0==(cH(d,Vs|0)|0)?0!=(cH(d,bp|0)|0)?c=1005:0!=(cH(d,im|0)|0)?c=1005:0!=(cH(d,ff|0)|0)?c=1005:0!=(cH(d,ye|0)|0)&&(c=1005):c=1005;1005==c&&(c=0,AE(t[tc>>2],PD(hm|0)));0==(cH(d,Uf|0)|0)?0!=(cH(d,Fi|0)|0)?eH(d,0):0!=(cH(d,wk|0)|0)?eH(d,1):0!=(cH(d,av|0)|0)?eH(d,4):0!=(cH(d,Bu|0)|0)&&eH(d,5):eH(d,2);c:for(;;){var f=t[b],g=l[f];if(0==g<<24>>24){continue b}do{if(e){var h=t[b];if(0==(L(g&255)|0)){if(35==l[h]<<24>>24){continue b}do{if(0==(cH(d,ov|0)|0)&&0==(cH(d,Zs|0)|0)){do{if(0!=(cH(d,Sf|0)|0)&&(f=t[tc>>2],g=t[f+4>>2],0!=(g|0))){Q(t[t[f+8>>2]+(g-1<<2)>>2]);f=t[tc>>2];g=f+4|0;h=t[g>>2]-1|0;t[g>>2]=h;t[t[f+8>>2]+(h<<2)>>2]=0;continue c}}while(0);f=t[b];g=l[f];if(34==g<<24>>24){for(;;){if(f=f+1|0,t[b]=f,g=l[f],0==g<<24>>24||34==g<<24>>24){continue c}}}else{if(0==g<<24>>24){continue c}else{var i=f}}for(;;){if(f=i+1|0,t[b]=f,g=t[b],0!=(oA(l[f]&255)|0)){i=g}else{if(95==l[g]<<24>>24){i=g}else{continue c}}}}}while(0);AE(t[tc>>2],PD(hm|0));continue c}}else{h=f}}while(0);t[b]=h+1|0}}}fH(t[tc>>2]);j=d}aH.X=1;function cH(b,d){var c=tb(d),e=t[b>>2],f=l[e+c|0];if(0!=(N(e,d,c)|0)){return 0}if(0!=f<<24>>24){if(0!=(L(f&255)|0)|40==f<<24>>24){e=t[b>>2]}else{return 0}}t[b>>2]=e+c|0;return 1}function dH(b){if(0!=(L(l[t[b>>2]]&255)|0)){for(;;){var d=t[b>>2]+1|0;t[b>>2]=d;if(0==(L(l[d]&255)|0)){break}}}}function eH(b,d){if(0!=(L(l[t[b>>2]]&255)|0)){var c=P(),e=gH(b,c,d);if(-1!=(e|0)&&0!=(t[c>>2]|0)){var f,g=j;j+=80;f=g>>2;var h=c|0,i=t[h>>2];(i+1|0)==(t[c+4>>2]|0)&&(R(c),i=t[h>>2]);h=c+8|0;l[t[h>>2]+i|0]=0;var m=t[tc>>2],i=P(),n=t[m+4>>2];if(0!=(n|0)){for(var m=m+8|0,q=0,p=0;;){var s=t[t[m>>2]+(q<<2)>>2];0!=(t[s>>2]|0)&&(U(i,0!=(p|0)?Xi|0:hm|0),U(i,t[s+8>>2]),p=p+1|0);q=q+1|0;if((q|0)==(n|0)){break}}}sC(g,t[h>>2]);0!=(t[i>>2]|0)&&(t[f+15]=Fi|0,t[f+16]=t[i+8>>2]);t[f+9]=t[cy+(e<<4)+8>>2];l[g+40|0]=t[cy+(e<<4)+4>>2]&255;tC(g);AE(t[tc>>2],BE(c));S(c);Q(i);j=g}Q(c)}}function gH(b,d,c){var e,f,g=b>>2,h;f=(d|0)>>2;var i=d+4|0;e=(d+8|0)>>2;a:for(;;){var m=1==(c|0);do{if(m){dH(b);var n=Wr|0;h=1061}else{var q=2>(c-4|0)>>>0?vr|0:fr|0;dH(b);if(3==(c|0)){n=q,h=1061}else{if(0!=(c|0)){var p=q}else{if(p=t[g],60!=l[p]<<24>>24){p=q}else{if(60==l[p+1|0]<<24>>24){var s=-1;h=1081;break a}else{p=q}}}}}}while(0);if(1061==h){h=0;for(var p=d,q=b,r=ba,u=0;;){if(28==(u|0)){var v=0,r=1101;break}var w=t[hc+(u<<2)>>2];if(0==(cH(q,w)|0)){u=u+1|0}else{break}}1101!=r&&(U(p,w),v=1);p=v;if(0==(p|0)){p=n}else{s=c;h=1078;break}}for(q=t[g];;){r=l[q];if(0==r<<24>>24){s=c;h=1077;break a}q=l[t[g]];if(0==(oA(r&255)|0)&&0==(0!=(mA(p,q<<24>>24)|0)&1|0)){s=c;h=1079;break a}r=t[f];(r+1|0)==(t[i>>2]|0)&&(R(d),r=t[f]);l[t[e]+r|0]=q;0!=q<<24>>24&&(r=t[f]+1|0,t[f]=r,l[t[e]+r|0]=0);r=t[g]+1|0;t[g]=r;if(m){if(46==q<<24>>24){break}if(0==(0!=(mA(Pq|0,q<<24>>24)|0)&1|0)){q=r}else{s=1;h=1080;break a}}else{q=r}}c=t[f];(c+1|0)==(t[i>>2]|0)&&(R(d),c=t[f]);l[t[e]+c|0]=0;S(d);c=3}if(1081==h||1077==h||1078==h||1080==h||1079==h){return s}}gH.X=1;function hH(){var b=P(),d=eC();if(0!=(d|0)){for(;;){var c=40==l[d]<<24>>24;a:do{if(c){var e=l[d+1|0];do{if(68==e<<24>>24||100==e<<24>>24){var f=l[d+2|0];if(69==f<<24>>24||101==f<<24>>24){if(f=l[d+3|0],70==f<<24>>24||102==f<<24>>24){for(var f=d,g=40;;){var h=f+1|0;if(0!=(L(g)|0)){var i=f;break}f=h;g=l[h]&255}for(;;){f=l[i];if(0==f<<24>>24){break}if(0==(L(f&255)|0)&&40!=l[i]<<24>>24){break}i=i+1|0}iH(b,i);jC(b,ay|0,0);if(40!=l[i]<<24>>24){break a}f=i;g=l[i+1|0]}else{f=d,g=e}}else{f=d,g=e}}else{f=d,g=e}}while(0);if(83==g<<24>>24||115==g<<24>>24){if(e=l[f+2|0],69==e<<24>>24||101==e<<24>>24){if(e=l[f+3|0],(84==e<<24>>24||116==e<<24>>24)&&33==l[f+4|0]<<24>>24&&0!=(L(l[f+5|0]&255)|0)){for(e=f;;){f=l[e];if(0==f<<24>>24){var m=e;break}if(0==(L(f&255)|0)){e=e+1|0}else{m=e;break}}for(;0!=(L(l[m]&255)|0);){m=m+1|0}iH(b,m);jC(b,ay|0,1)}}}}}while(0);d=eC();if(0==(d|0)){break}}}Q(b)}hH.X=1;function iH(b,d){var c,e,f;S(b);e=(b|0)>>2;var g=b+4|0;c=(b+8|0)>>2;for(var h=d;;){var i=l[h];if(0==i<<24>>24||40==i<<24>>24||41==i<<24>>24){f=1133;break}var m=t[e],n=(m+1|0)==(t[g>>2]|0);if(0!=(L(i&255)|0)){f=1140;break}n?(R(b),i=t[e]):i=m;l[t[c]+i|0]=l[h];0!=l[h]<<24>>24&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);h=h+1|0}if(1133==f){if(h=t[e],(h+1|0)==(t[g>>2]|0)){f=1141}else{var q=h}}else{1140==f&&(n?f=1141:q=m)}1141==f&&(R(b),q=t[e]);l[t[c]+q|0]=0}iH.X=1;function jH(){var b,d,c,e=P(),f=eC();if(0!=(f|0)){d=(e|0)>>2;var g=e+4|0;for(b=(e+8|0)>>2;;){var h=l[f],i=35==h<<24>>24;a:do{if(!i){for(var m=f,n=h;;){var q=m+1|0;if(0==(L(n&255)|0)){break}m=q;n=l[q]}n=0==(N(m,Cf|0,8)|0);b:do{if(n){if(q=m+8|0,0==(L(l[q]&255)|0)){var p=0,s=m}else{if(0==(L(l[q]&255)|0)){break a}for(;;){if(0==(L(l[q]&255)|0)){p=1;s=q;break b}else{q=q+1|0}}}}else{p=0,s=m}}while(0);do{if(0==(oA(l[s]&255)|0)){if(95==l[s]<<24>>24){m=s}else{break a}}else{m=s}}while(0);b:for(;;){do{if(0==(oA(l[m]&255)|0)){var r=t[d],u=(r+1|0)==(t[g>>2]|0);if(95!=l[m]<<24>>24){break b}if(u){c=1159}else{var v=r}}else{n=t[d],(n+1|0)==(t[g>>2]|0)?c=1159:v=n}}while(0);1159==c&&(c=0,R(e),v=t[d]);l[t[b]+v|0]=l[m];0!=l[m]<<24>>24&&(n=t[d]+1|0,t[d]=n,l[t[b]+n|0]=0);m=m+1|0}u?(R(e),n=t[d]):n=r;for(l[t[b]+n|0]=0;;){var w=m+1|0;if(0==(L(l[m]&255)|0)){break}else{m=w}}if(40==l[m]<<24>>24){for(n=w;0!=(L(l[n]&255)|0);){n=n+1|0}41!=l[n]<<24>>24?n=p:(n=0!=(qA(kH(t[t[K>>2]+8>>2]),bf|0)|0)?0:0==(qA(t[e+8>>2],zd|0)|0),n&=1,n=0==(n|0)?1:p)}else{n=p}0!=(n|0)&&jC(e,Xx|0,0);S(e)}}while(0);f=eC();if(0==(f|0)){break}}}Q(e)}jH.X=1;function lH(){var b,d=j;j+=4;var c;b=d>>2;var e=P(),f=eC();if(0!=(f|0)){for(var g=e+8|0,h=-1;;){for(var f=mH(f),i=t[b]=f;;){f=t[Mz>>2];if(0!=(f|0)){i=tA(i,Mm|0);t[b]=i;if(0==(i|0)){var m=h;break}t[Mz>>2]=f-1|0;t[b]=i+2|0}var n,f=d;n=P();t[f>>2]=nH(t[f>>2],n);for(var f=t[n+8>>2],i=-1,q=0;;){var p=0==(qA(f,t[Tx+(q<<3)>>2])|0)?t[Tx+(q<<3)+4>>2]:i,q=q+1|0;if(10>q>>>0&-1==(p|0)){i=p}else{break}}Q(n);n=p;f=t[b];-1==(n|0)?n=h:(f=nH(mH(f),e),t[b]=f,i=t[g>>2],-2==(n|0)?(oH(h,i),n=h):oH(n,i));h=f;if(0==(tA(h,Dk|0)|0)){if(0==(h|0)){m=n;break}else{f=h}}else{if(h=tA(h+2|0,Mm|0),t[b]=h,0==(h|0)){c=1199;break}else{f=h}}if(0==l[f]<<24>>24){m=n;break}else{h=n,i=f}}1199==c&&(c=0,t[Mz>>2]=t[Mz>>2]+1|0,m=n);f=eC();if(0==(f|0)){break}else{h=m}}}Q(e);j=d}lH.X=1;function mH(b){for(;0!=(L(l[b]&255)|0);){b=b+1|0}return b}function nH(b,d){var c;S(d);var e=b,f=0,g=l[b];a:for(;;){for(var h=0!=(f|0),i=0==(f|0),m=e,n=g;;){if(0==n<<24>>24){var q=m;c=1233;break a}var p=l[m];if(!(0==(pH(n&255)|0)|h)){c=1221;break a}var n=m+1|0,s=l[n];if(40==p<<24>>24&&42==s<<24>>24&i){c=1219;break a}if(34!=s<<24>>24|92==p<<24>>24){m=n,n=s}else{e=n;f=1;g=34;continue a}}}if(1221==c){if(0==p<<24>>24|0==(m|0)){return m}e=0==(pH(p&255)|0);c=(d|0)>>2;f=t[c];g=d+4|0;h=(f+1|0)==(t[g>>2]|0);a:do{if(e){var r=m,u=h,v=f}else{i=d+8|0;q=m;n=h;for(p=f;;){if(n&&(R(d),p=t[c]),l[t[i>>2]+p|0]=l[q],0!=l[q]<<24>>24&&(p=t[c]+1|0,t[c]=p,l[t[i>>2]+p|0]=0),q=q+1|0,p=t[c],n=(p+1|0)==(t[g>>2]|0),0==(pH(l[q]&255)|0)){r=q;u=n;v=p;break a}}}}while(0);u?(R(d),m=t[c]):m=v;l[t[d+8>>2]+m|0]=0;return r}if(1233==c){return q}if(1219==c){return t[Mz>>2]=t[Mz>>2]+1|0,m+2|0}}nH.X=1;function oH(b,d){var c=j;j+=80;sC(c,d);t[c+36>>2]=t[Sx+(b<<4)+8>>2];l[c+40|0]=t[Sx+(b<<4)+4>>2]&255;tC(c);j=c}function pH(b){return 0!=(oA(b)|0)?1:0==(b|0)?0:0!=(bC(wh|0,b,21)|0)&1}function qH(){var b,d=zC(28);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+4]=0;t[b+5]=t[K+48>>2];t[b+6]=t[K+24>>2];return d}function rH(b){Q(t[b+8>>2]);Q(t[b+12>>2]);vB(b)}function sH(b){$(b);8==(t[b>>2]|0)&&(tH(b,5),$(b))}function uH(b){var d=t[b+4>>2];if(27==(d|0)){vH(b)}else{if(1==(d|0)){wH(b,0)}else{if(55==(d|0)){xH(b)}else{if(28==(d|0)){yH(b)}else{if(31==(d|0)){var c,d=qH();$(d);$(b);var e=b|0;14==(t[e>>2]|0)&&$(d);for(c=(b+4|0)>>2;68!=(t[c]|0)&&6!=(t[e>>2]|0);){$(b)}tH(d,14);68==(t[c]|0)&&($(b),1==(t[c]|0)&&wH(b,1),zH(b,1));rH(d)}else{if(53==(d|0)){xH(b)}else{if(54==(d|0)){xH(b)}else{if(17==(d|0)){d=qH();c=d>>2;$(d);2==(t[c+1]|0)&&$(d);var e=b+4|0,f=0==(t[e>>2]|0);a:do{if(!f){for(var g=b|0;;){if($(b),14==(t[g>>2]|0)&&$(d),0==(t[e>>2]|0)){break a}}}}while(0);e=t[c];(8==(e|0)||13==(e|0))&&tH(d,6);AH(b,t[c+2]);wH(b,0);S(t[b+12>>2]);zH(b,0);rH(d)}else{if(69==(d|0)){for(c=b+4|0;!(d=0==(t[c>>2]|0),$(b),d);){}15==(t[b>>2]|0)&&BH(b,16);zH(b,1)}else{if(3==(d|0)){CH(b,0)}else{if(65==(d|0)){zH(b,0)}else{if(30==(d|0)){c=qH();d=qH();$(c);$(b);e=b|0;14==(t[e>>2]|0)&&($(c),$(b));if(45==(t[b+4>>2]|0)&&(f=t[c>>2],8==(f|0)||13==(f|0))){$(d),$(b),14==(t[e>>2]|0)&&($(d),$(b)),AH(c,t[d+8>>2]),tH(c,13)}zH(b,0);rH(c);rH(d)}else{if(52==(d|0)){xH(b)}else{if(34==(d|0)){DH(b)}else{if(26==(d|0)){CH(b,9)}else{if(66==(d|0)){d=qH();$(d);$(b);e=(b|0)>>2;f=t[e];14==(f|0)&&($(d),$(b),f=t[e]);10==(f|0)&&EH(b);for(f=b+4|0;!(c=0==(t[f>>2]|0))&&6!=(t[e]|0);){$(b)}e=t[d>>2];(8==(e|0)||13==(e|0))&&c&&tH(d,18);zH(b,1);rH(d)}else{32==(d|0)?(c=qH(),$(c),$(b),d=b|0,e=t[d>>2],14==(e|0)?($(c),$(b),d=t[d>>2]):d=e,10==(d|0)&&(d=t[c>>2],(8==(d|0)||13==(d|0))&&tH(c,15)),zH(b,0),rH(c)):35==(d|0)?DH(b):33==(d|0)?(c=qH(),$(c),$(b),29==(t[b+4>>2]|0)&&(d=t[c>>2],(8==(d|0)||13==(d|0))&&tH(c,16)),zH(b,0),rH(c)):67==(d|0)?(c=qH(),$(c),$(b),d=t[c>>2],(8==(d|0)||13==(d|0))&&14==(t[b+4>>2]|0)&&tH(c,19),zH(b,1),rH(c)):59==(d|0)?FH(b):62==(d|0)?GH(b):61==(d|0)?FH(b):42==(d|0)?(c=qH(),$(c),$(b),d=t[c>>2],(8==(d|0)||13==(d|0))&&6!=(t[b>>2]|0)&&tH(c,12),zH(b,1),rH(c)):58==(d|0)?FH(b):19==(d|0)?HH(b):7==(d|0)?IH(b,0):4==(d|0)?wH(b,0):56==(d|0)?xH(b):29==(d|0)?PH(b):57==(d|0)?FH(b):6==(d|0)?HH(b):60==(d|0)&&FH(b)}}}}}}}}}}}}}}}}}uH.X=1;function wH(b,d){var c,e;1==(t[b>>2]|0)&&(sH(b),$(b));e=(b+4|0)>>2;if(1!=(t[e]|0)&&($(b),QH(b,d),1!=(t[e]|0))){return}$(b);var f=qH();c=(b+4|0)>>2;if(4==(t[c]|0)){for(var g=f+4|0,h=b|0,i=0==(d|0);;){$(b);$(f);var m=t[g>>2];if(3==(m|0)){tH(b,0)}else{if(63==(t[c]|0)&64==(m|0)){$(b),27==(t[c]|0)&&($(b),m=t[h>>2],(8==(m|0)||13==(m|0))&&tH(b,10))}else{if(m=t[h>>2],8==(m|0)||13==(m|0)){i?tH(b,12):tH(b,4)}}}BH(b,6);$(b);if(4!=(t[c]|0)){break}}}rH(f);c=(b+16|0)>>2;f=t[c]+1|0;t[c]=f;if(5==(t[e]|0)){e=f}else{for(;!(IH(b,0),0!=(RH(b)|0)&&$(b),5==(t[e]|0));){}e=t[c]}t[c]=e-1|0;$(b)}function CH(b,d){$(b);var c=t[b>>2];(8==(c|0)||13==(c|0))&&tH(b,d)}function DH(b){var d=qH();$(d);0==(t[d+4>>2]|0)&&$(d);$(b);var c=t[d>>2];(8==(c|0)||13==(c|0))&&tH(d,17);zH(b,0);rH(d)}function HH(b){var d,c,e,f,g,h=qH();f=h>>2;var i=P();e=(b+4|0)>>2;var m=6==(t[e]|0),n=m?2:7;d=(b+12|0)>>2;V(i,t[t[d]+8>>2]);$(b);SH(h,b);$(b);c=(b|0)>>2;var q=t[c];14==(q|0)&&(0!=(t[i>>2]|0)&&AH(b,t[f+2]),$(b),SH(h,b),$(b),q=t[c]);10==(q|0)&&EH(b);m&&2>(t[e]-24|0)>>>0&&($(b),$(b),10==(t[c]|0)&&EH(b));if(0!=(RH(b)|0)){tH(h,1)}else{for(;;){var p=t[e];if(0==(p|0)||1==(p|0)){break}else{if(44==(p|0)||37==(p|0)||38==(p|0)||39==(p|0)){g=1362;break}}if(21==(t[c]|0)){g=1361;break}if(0!=(RH(b)|0)){g=1361;break}$(b);36==(p|0)&&10==(t[c]|0)&&EH(b)}if(1361==g&&(44==(p|0)||37==(p|0)||38==(p|0)||39==(p|0))){g=1362}1362==g&&(AH(b,t[f+2]),m=t[f],8==(m|0)||13==(m|0)?g=1364:-1!=(t[e]|0)&&(g=1364),1364==g&&tH(h,n),S(t[d]));21==(t[c]|0)&&$(b);c=t[e];4==(c|0)&&(QH(b,0),c=t[e]);2>c>>>0&&(AH(b,t[f+2]),f=t[f],8==(f|0)||13==(f|0)?g=1373:-1!=(t[e]|0)&&(g=1373),1373==g&&tH(h,n),wH(b,1),S(t[d]))}b=t[d];d=(i+8|0)>>2;d=t[d];V(b,d);rH(h);Q(i)}HH.X=1;function $(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+20|0)>>2;b=(b+24|0)>>2;a:for(;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(46==(h|0)){f=1386;break}else{if(125==(h|0)){f=1389;break}else{if(40==(h|0)){f=1382;break}else{if(126==(h|0)){f=1390;break}else{if(58==(h|0)){f=1384;break}else{if(41==(h|0)){f=1383;break}else{if(91==(h|0)){f=1391;break}else{if(123==(h|0)){f=1388;break}else{if(93==(h|0)){f=1392;break}else{if(61==(h|0)){f=1393;break}else{if(39==(h|0)||34==(h|0)){f=1394;break}else{if(45==(h|0)){var i=T();if(45!=(i|0)){f=1397;break}uE(10)}else{if(60==(h|0)||62==(h|0)){f=1400;break}else{if(92==(h|0)){f=1405;break}else{if(47==(h|0)){var m=T();if(47==(m|0)){uE(10)}else{if(42!=(m|0)){f=1410;break}for(;;){uE(42);var n=T();if(47==(n|0)){continue a}W(n);if(-1==(n|0)||0==(n|0)){continue a}}}}else{if(!(32==(h|0)||10==(h|0)||9==(h|0))){if(-1==(h|0)){f=1381;break}else{if(59==(h|0)){f=1385;break}else{if(44==(h|0)){f=1387;break}else{if(0==((0!=(pA(h)|0)|64==(h|0)|95==(h|0))&1|0)){f=1415;break}for(var q=t[c],p=n=ba,p=(q|0)>>2,s=q+4|0,n=(q+8|0)>>2,r=h;;){var u=t[p];(u+1|0)==(t[s>>2]|0)&&(R(q),u=t[p]);l[t[n]+u|0]=r&255;0!=(r|0)&&(u=t[p]+1|0,t[p]=u,l[t[n]+u|0]=0);u=T();if(0==((0!=(pA(u)|0)|10>(u-48|0)>>>0?1:95==(u|0)||64==(u|0)||36==(u|0)||35==(u|0)?1:0)|0)){break}else{r=u}}r=t[p];(r+1|0)==(t[s>>2]|0)?(R(q),q=t[p]):q=r;l[t[n]+q|0]=0;0==(L(u)|0)&&W(u);t[d]=t[K+48>>2];t[b]=t[K+24>>2];n=UD(t[c],t[Hy>>2]);t[g>>2]=n;if(-1==(n|0)){f=1418;break}else{if(23!=(n|0)){f=1419;break}}S(t[c]);uE(10)}}}}}}}}}}}}}}}}}}}}if(1386==f){t[e]=14}else{if(1389==f){t[e]=16}else{if(1382==f){t[e]=10}else{if(1390==f){t[e]=19}else{if(1415==f){t[e]=0}else{if(1384==f){t[e]=5}else{if(1383==f){t[e]=4}else{if(1391==f){t[e]=17}else{if(1388==f){t[e]=15}else{if(1392==f){t[e]=18}else{if(1393==f){t[e]=21}else{if(1394==f){t[e]=13;e=t[c];g=h;c=(e|0)>>2;f=e+4|0;h=(e+8|0)>>2;i=1;a:for(;;){for(;;){if(!i){break a}m=T();if(-1==(m|0)|(m|0)==(g|0)){i=0;continue a}n=t[c];(n+1|0)==(t[f>>2]|0)&&(R(e),n=t[c]);l[t[h]+n|0]=m&255;0!=(m|0)&&(m=t[c]+1|0,t[c]=m,l[t[h]+m|0]=0)}}g=t[c];(g+1|0)!=(t[f>>2]|0)?(h=t[h],e=h+g|0):(R(e),e=t[c],h=t[h],e=h+e|0);l[e]=0;t[d]=t[K+48>>2];t[b]=t[K+24>>2]}else{1397==f?(0==(L(i)|0)&&W(i),t[e]=11):1400==f?(d=T(),(d|0)!=(h|0)?(W(d),t[e]=0):t[e]=60==(h|0)?1:2):1405==f?(h=T(),!(92==(h|0)||39==(h|0)||34==(h|0))&&0==(L(h)|0)&&W(h),t[e]=3,t[d]=t[K+48>>2],t[b]=t[K+24>>2]):1410==f?(t[e]=20,W(m)):1419==f?t[e]=9:1418==f?t[e]=8:1381==f?dB(xz|0,1):1385==f?t[e]=6:1387==f&&(t[e]=7)}}}}}}}}}}}}}$.X=1;function IH(b,d){var c,e,f;e=(b|0)>>2;c=(b+4|0)>>2;var g=0==(d|0);a:for(;;){var h=1==(t[e]|0);b:do{if(h){sH(b);var i=0;f=1488}else{var m=t[c];c:do{if(40==(m|0)){for($(b);;){var n=41==(t[c]|0);$(b);if(n){var q=0;break b}}}else{if(43==(m|0)){$(b);q=0;break b}else{if(70==(m|0)){$(b);uH(b);var p=0}else{if(1==(m|0)||4==(m|0)){wH(b,1),p=0}else{if(11==(m|0)||13==(m|0)){f=1465}else{if(7==(m|0)){for(p=7;41!=(p|0);){if(1==(p|0)){f=1452;break}$(b);p=t[c]}if(1452==f){f=0,wH(b,0),p=0!=(RH(b)|0)&1}else{$(b);var p=t[c],n=5==(p|0),s=10!=(p|0)&(n^1);d:do{if(s){for(var r=p;;){2>(r-8|0)>>>0&&$(b);IH(b,1);0!=(RH(b)|0)&&$(b);var r=t[c],u=5==(r|0);if(!(10!=(r|0)&(u^1))){var v=u,w=r;break d}}}else{v=n,w=p}}while(0);v?($(b),p=t[c]):p=w;7==(p|0)||10==(p|0)?($(b),p=0!=(RH(b)|0)&1):p=0}}else{if(14==(m|0)){$(b);$(b);if(0!=(t[c]|0)){break a}for(;;){if($(b),15==(t[c]|0)){f=1465;break c}}}else{5!=(m|0)&&$(b),p=0}}}}}}}}while(0);if(1465==f){f=0;$(b);m=5==(t[c]|0);c:do{if(!m){for(;;){if(IH(b,0),0!=(RH(b)|0)&&$(b),5==(t[c]|0)){break c}}}}while(0);$(b);m=t[c];(11==(m|0)||13==(m|0)||14==(m|0))&&$(b);p=0!=(RH(b)|0)&1}m=0==(p|0);c:for(;;){if(!m){i=p;f=1488;break b}n=t[c];if(5==(n|0)){i=0;f=1488;break b}if(0!=(RH(b)|0)){i=0;f=1488;break b}if(!(10!=(n|0)|g)){break a}if(5==(t[e]|0)&&($(b),n=t[c],11==(n|0)||12==(n|0)||14==(n|0))){break a}$(b);n=t[e];if(10==(n|0)||15==(n|0)||17==(n|0)){TH(b),n=t[e]}do{if(1!=(n|0)&&(s=t[c],!(43==(s|0)||11==(s|0)||13==(s|0)||14==(s|0)||1==(s|0)))){if(7!=(s|0)){continue c}IH(b,1);continue c}}while(0);IH(b,0)}}}while(0);1488==f&&(f=0,q=0!=(RH(b)|0)&0==(i|0)?1:i);h=t[c];if(5==(h|0)){break}if(!((10!=(h|0)|g)&0==(q|0))){break}}}IH.X=1;function xH(b){var d,c=qH(),e=qH(),f=qH();$(b);d=(b|0)>>2;do{if(10==(t[d]|0)){$(c);$(b);var g=t[d],h=7==(g|0),g=4!=(g|0)&(h^1);a:do{if(g){for(;;){$(b);var i=t[d],m=7==(i|0);if(!(4!=(i|0)&(m^1))){var n=m;break a}}}else{n=h}}while(0);if(n){$(e);$(b);g=t[d];h=7==(g|0);g=4!=(g|0)&(h^1);a:do{if(g){for(;;){if($(b),i=t[d],m=7==(i|0),!(4!=(i|0)&(m^1))){var q=m;break a}}}else{q=h}}while(0);q&&($(f),13==(t[c>>2]|0)&&13==(t[e>>2]|0)&&13==(t[f>>2]|0)&&(AH(c,t[e+8>>2]),AH(c,t[f+8>>2]),tH(c,20)));4!=(t[d]|0)&&BH(b,4)}}}while(0);zH(b,1);rH(c);rH(e);rH(f)}xH.X=1;function FH(b){var d,c=qH(),e=qH();$(b);d=(b|0)>>2;if(10==(t[d]|0)){$(c);$(b);var f=t[d],g=7==(f|0),f=4!=(f|0)&(g^1);a:do{if(f){for(;;){$(b);var h=t[d],i=7==(h|0);if(!(4!=(h|0)&(i^1))){var m=i;break a}}}else{m=g}}while(0);m&&($(e),13==(t[c>>2]|0)&&13==(t[e>>2]|0)&&(AH(c,t[e+8>>2]),tH(c,21)));4!=(t[d]|0)&&BH(b,4)}zH(b,1);rH(c);rH(e)}function GH(b){var d,c=qH(),e=qH(),f=qH();$(b);d=(b|0)>>2;do{if(10==(t[d]|0)){$(c);$(b);var g=t[d],h=7==(g|0),g=4!=(g|0)&(h^1);a:do{if(g){for(;;){$(b);var i=t[d],m=7==(i|0);if(!(4!=(i|0)&(m^1))){var n=m;break a}}}else{n=h}}while(0);if(n){$(e);$(b);g=t[d];h=7==(g|0);g=4!=(g|0)&(h^1);a:do{if(g){for(;;){if($(b),i=t[d],m=7==(i|0),!(4!=(i|0)&(m^1))){var q=m;break a}}}else{q=h}}while(0);q&&($(f),13==(t[c>>2]|0)&&13==(t[e>>2]|0)&&13==(t[f>>2]|0)&&(AH(c,t[e+8>>2]),AH(c,t[f+8>>2]),tH(c,22)));4!=(t[d]|0)&&BH(b,4)}}}while(0);zH(b,1);rH(c);rH(e);rH(f)}GH.X=1;function vH(b){var d,c,e=qH();$(e);c=(e|0)>>2;17==(t[c]|0)&&($(e),$(b));$(b);d=(b|0)>>2;var f=t[d];14==(f|0)?($(e),f=t[c],17==(f|0)&&($(e),$(b),f=t[c]),14==(f|0)&&($(e),17==(t[c]|0)&&($(e),$(b))),$(b),f=t[d],14!=(f|0)?d=f:($(e),17==(t[c]|0)&&($(e),$(b)),$(b),d=t[d])):d=f;if(10==(d|0)){if(c=t[c],8==(c|0)||13==(c|0)){tH(e,10),c=b+12|0,V(t[c>>2],t[t[e+8>>2]+8>>2]),UH(b),S(t[c>>2])}}else{44==(t[b+4>>2]|0)&&8==(t[c]|0)&&tH(e,10)}zH(b,0);rH(e)}vH.X=1;function RH(b){var d=t[b>>2];return(6==(d|0)||19==(d|0)||20==(d|0)?1:71==(t[b+4>>2]|0))&1}function yH(b){var d,c,e=qH(),f=qH();$(e);$(b);var g=b|0;14==(t[g>>2]|0)&&($(e),$(b));for(d=(b+4|0)>>2;45!=(t[d]|0)&&0==(RH(b)|0);){$(b)}if(0==(RH(b)|0)){$(f);$(b);14==(t[g>>2]|0)&&($(f),$(b));for(var h=e+8|0,g=b+12|0;;){var i=t[d];if(1==(i|0)||16==(i|0)){break}if(0!=(RH(b)|0)){c=1618;break}4==(i|0)?(AH(b,t[h>>2]),QH(b,1),S(t[g>>2])):$(b)}if(1618==c&&!(1==(i|0)||16==(i|0))){zH(b,1);rH(e);rH(f);return}c=f+8|0;AH(e,t[c>>2]);tH(e,11);AH(b,t[c>>2]);1==(t[d]|0)&&wH(b,1);S(t[g>>2])}zH(b,1);rH(e);rH(f)}yH.X=1;function PH(b){var d,c,e=qH(),f=P();c=(b+12|0)>>2;V(f,t[t[c]+8>>2]);AH(e,t[c]);$(e);if(8==(t[e>>2]|0)&&($(b),d=(b+4|0)>>2,0==(t[d]|0))){$(b);AH(b,t[e+8>>2]);var g=t[d];20==(g|0)||21==(g|0)?(tH(e,8),UH(b)):27==(g|0)?tH(e,10):22==(g|0)&&($(b),3==(t[d]|0)&&tH(e,0));S(t[c])}V(t[c],t[f+8>>2]);rH(e);Q(f)}function EH(b){10==(t[b>>2]|0)&&TH(b)}function tH(b,d){if(0!=(t[Qx+(d<<4)>>2]|0)){var c=b+12|0;if(0!=(t[t[c>>2]>>2]|0)){var e=P();V(e,t[t[c>>2]+8>>2]);U(e,Xi|0);c=b+8|0;U(e,t[t[c>>2]+8>>2]);var f=e|0,g=t[f>>2];(g+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=g;g=e+8|0;l[t[g>>2]+f|0]=0;V(t[c>>2],t[g>>2]);Q(e)}c=j;j+=80;e=c>>2;0!=(t[Qx+(d<<4)>>2]|0)&&(sC(c,t[t[b+8>>2]+8>>2]),t[e+1]=t[b+20>>2],t[e+2]=t[b+24>>2],t[e+9]=t[Qx+(d<<4)+8>>2],l[c+40|0]=t[Qx+(d<<4)+4>>2]&255,tC(c));j=c}}function zH(b,d){var c=t[b+16>>2];if(!(0!=(d|0)&&0!=(RH(b)|0))){for(;;){$(b);if(0!=(RH(b)|0)){break}if(0!=((0>=(c|0)?0:5==(t[b+4>>2]|0)?(t[b+16>>2]|0)==(c|0)&1:0)|0)){break}}}}function TH(b){var d=b|0,c=t[d>>2];if(10==(c|0)){var e=4}else{if(15==(c|0)){e=16}else{if(17==(c|0)){e=18}else{return}}}$(b);for(var f=1;;){var g=t[d>>2],f=((g|0)==(c|0)&1)+f|0,f=(((g|0)==(e|0)&0<(f|0))<<31>>31)+f|0;$(b);if(!(0!=(f|0)|(g|0)!=(e|0))){break}}}function AH(b,d){var c;c=(b+12|0)>>2;var e=t[c];0!=(t[e>>2]|0)&&(U(e,Xi|0),e=t[c]);U(e,t[d+8>>2]);var f=t[c],e=t[f>>2];(e+1|0)!=(t[f+4>>2]|0)?(f=f+8|0,f=t[f>>2],c=f+e|0):(R(f),e=t[c],c=t[e>>2],f=e+8|0,f=t[f>>2],c=f+c|0);l[c]=0}function UH(b){var d,c;d=(b|0)>>2;if(10==(t[d]|0)){var e=10}else{$(b),e=t[d]}var f=b+4|0;a:for(;;){(7==(e|0)||10==(e|0))&&$(b);if(6>(t[f>>2]-46|0)>>>0){c=1701}else{var g=t[d];if(8==(g|0)||13==(g|0)){tH(b,3),c=1701}else{var h=g}}for(;;){1701==c&&(c=0,h=t[d]);if(7==(h|0)||10==(h|0)){e=h;continue a}else{if(4==(h|0)){break a}}$(b);g=t[d];10!=(g|0)?h=g:(EH(b),c=1701)}}}function QH(b,d){var c,e=b+4|0,f=t[e>>2];if(4==(f|0)){$(b),c=1708}else{var g=f}a:for(;;){1708==c&&(g=t[e>>2]);do{if(19==(g|0)){HH(b)}else{if(3==(g|0)){CH(b,0)}else{if(6==(g|0)){HH(b)}else{if(29==(g|0)){PH(b)}else{if(28==(g|0)){CH(b,11)}else{if(26==(g|0)){CH(b,9)}else{if(1==(g|0)||5==(g|0)){break a}else{8==(t[b>>2]|0)&&(0==(d|0)?tH(b,12):tH(b,4))}}}}}}}}while(0);BH(b,6);$(b);c=1708}}function BH(b,d){var c=b|0;if((t[c>>2]|0)!=(d|0)){for(;!($(b),(t[c>>2]|0)==(d|0));){}}}function SH(b,d){var c=d>>2,e=b>>2;t[e+5]=t[c+5];t[e+6]=t[c+6];t[e]=t[c];t[e+1]=t[c+1];V(t[e+2],t[t[c+2]+8>>2]);V(t[e+3],t[t[c+3]+8>>2])}function VH(){var b,d=P(),c=eC();if(0!=(c|0)){for(;;){if(0!=(L(l[c]&255)|0)){c=c+1|0}else{var e=l[c];a:do{if(!(0==e<<24>>24||35==e<<24>>24)){for(var f=c,g=e;;){if(0==g<<24>>24){var h=0;break}var i=f+1|0;if(0!=(L(g&255)|0)){b=1782;break}f=i;g=l[i]}1782==b&&(b=0,h=l[f]&255);if(0!=(L(h)|0)){for(;0!=(L(l[f]&255)|0);){f=f+1|0}if(0!=(WH(c,ok|0)|0)){XH(f,d,2)}else{do{if(0==(WH(c,Fi|0)|0)&&0==(WH(c,kh|0)|0)){do{if(0==(WH(c,Yf|0)|0)&&0==(WH(c,Ve|0)|0)&&0==(WH(c,nx|0)|0)){break a}}while(0);if(0==(WH(f,Bw|0)|0)){break a}for(c=f+6|0;0!=(L(l[c]&255)|0);){c=c+1|0}XH(c,d,1);break a}}while(0);XH(f,d,0)}}}}while(0);c=eC();if(0==(c|0)){break}}}}Q(d)}VH.X=1;function WH(b,d){return 0==(N(b,d,tb(d))|0)&1}function XH(b,d,c){var e,f,g;S(d);f=(d|0)>>2;var h=d+4|0;for(e=(d+8|0)>>2;;){var i=l[b];if(0==i<<24>>24){g=1804;break}var m=t[f],n=(m+1|0)==(t[h>>2]|0);if(0!=(L(i&255)|0)){g=1811;break}n?(R(d),i=t[f]):i=m;l[t[e]+i|0]=l[b];0!=l[b]<<24>>24&&(i=t[f]+1|0,t[f]=i,l[t[e]+i|0]=0);b=b+1|0}if(1811==g){if(n){g=1812}else{var q=m}}else{1804==g&&(m=t[f],(m+1|0)==(t[h>>2]|0)?g=1812:q=m)}1812==g&&(R(d),q=t[f]);l[t[e]+q|0]=0;jC(d,Nx|0,c)}XH.X=1;function YH(){var b,d=zC(24);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+4]=t[K+48>>2];t[b+5]=t[K+24>>2];return d}function ZH(b){Q(t[b+8>>2]);Q(t[b+12>>2]);vB(b)}function $H(b,d){var c,e,f=YH(),g=P();S(g);e=(b|0)>>2;c=t[e];if(4==(c|0)){c=b>>2;var h=f>>2;t[h+4]=t[c+4];t[h+5]=t[c+5];t[h]=t[c];t[h+1]=t[c+1];V(t[h+2],t[t[c+2]+8>>2]);V(t[h+3],t[t[c+3]+8>>2]);aI(b);h=t[e]}else{h=c}if(10==(h|0)){aI(b);c=(g|0)>>2;for(h=b+8|0;;){var i=t[e];if(6==(i|0)){0!=(t[c]|0)&&U(g,Eo|0),U(g,t[t[h>>2]+8>>2])}else{if(11==(i|0)){break}}aI(b)}h=t[c];(h+1|0)==(t[g+4>>2]|0)?(R(g),c=t[c]):c=h;h=g+8|0;l[t[h>>2]+c|0]=0;V(t[f+8>>2],t[h>>2]);bI(f,d);c=0;h=t[e]}else{c=1}13==(h|0)&&(aI(b),h=t[e]);if(8==(h|0)){aI(b);h=9==(t[e]|0);c=0!=(c|0);a:do{if(!h){for(var i=g|0,m=b+8|0;;){if(c&&(0!=(t[i>>2]|0)&&U(g,Eo|0),U(g,t[t[m>>2]+8>>2])),aI(b),9==(t[e]|0)){break a}}}}while(0);c&&(e=g|0,c=t[e>>2],(c+1|0)==(t[g+4>>2]|0)?(R(g),e=t[e>>2]):e=c,c=g+8|0,l[t[c>>2]+e|0]=0,V(t[f+8>>2],t[c>>2]),bI(f,d))}ZH(f);Q(g)}$H.X=1;function bI(b,d){if(0!=(t[Lx+(d<<4)>>2]|0)){var c=b+12|0;if(0!=(t[t[c>>2]>>2]|0)){var e=P();V(e,t[t[c>>2]+8>>2]);U(e,Xi|0);c=b+8|0;U(e,t[t[c>>2]+8>>2]);var f=e|0,g=t[f>>2];(g+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=g;g=e+8|0;l[t[g>>2]+f|0]=0;V(t[c>>2],t[g>>2]);Q(e)}c=j;j+=80;e=c>>2;0!=(t[Lx+(d<<4)>>2]|0)&&(sC(c,t[t[b+8>>2]+8>>2]),t[e+1]=t[b+16>>2],t[e+2]=t[b+20>>2],t[e+9]=t[Lx+(d<<4)+8>>2],l[c+40|0]=t[Lx+(d<<4)+4>>2]&255,tC(c));j=c}}function cI(b,d){var c,e,f;f=(b|0)>>2;e=(b+4|0)>>2;c=(b+8|0)>>2;var g=1;a:for(;;){for(;;){if(!g){break a}var h=T();if(-1==(h|0)){g=0;continue a}else{if(92==(h|0)){var h=T(),i=t[f];(i+1|0)==(t[e]|0)&&(R(b),i=t[f]);l[t[c]+i|0]=h&255;if(0==(h|0)){continue}h=t[f]+1|0;t[f]=h;l[t[c]+h|0]=0;continue}}if((h|0)==(d|0)){g=0;continue a}i=t[f];(i+1|0)==(t[e]|0)&&(R(b),i=t[f]);l[t[c]+i|0]=h&255;0!=(h|0)&&(h=t[f]+1|0,t[f]=h,l[t[c]+h|0]=0)}}g=t[f];(g+1|0)!=(t[e]|0)?(c=t[c],c=c+g|0):(R(b),e=t[f],c=t[c],c=c+e|0);l[c]=0}cI.X=1;function dI(b,d){var c,e;e=(b|0)>>2;var f=b+4|0;c=(b+8|0)>>2;for(var g=d;;){var h=t[e];(h+1|0)==(t[f>>2]|0)&&(R(b),h=t[e]);l[t[c]+h|0]=g&255;0!=(g|0)&&(g=t[e]+1|0,t[e]=g,l[t[c]+g|0]=0);h=T();if(0==(eI(h)|0)){break}else{g=h}}g=t[e];(g+1|0)==(t[f>>2]|0)?(R(b),e=t[e]):e=g;l[t[c]+e|0]=0;0==(L(h)|0)&&W(h)}function aI(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+16|0)>>2;for(b=(b+20|0)>>2;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(42==(h|0)){f=1916;break}else{if(-1==(h|0)){f=1908;break}else{if(40==(h|0)){f=1909;break}else{if(44==(h|0)){f=1911;break}else{if(125==(h|0)){f=1913;break}else{if(39==(h|0)||34==(h|0)){f=1917;break}else{if(123==(h|0)){f=1912;break}else{if(32==(h|0)||10==(h|0)||9==(h|0)){continue}else{if(93==(h|0)){f=1915;break}else{if(92==(h|0)){f=1918;break}else{if(91==(h|0)){f=1914;break}else{if(41==(h|0)){f=1910;break}else{if(37!=(h|0)){f=1924;break}}}}}}}}}}}}}uE(10)}1916==f?t[e]=13:1908==f?dB(wz|0,1):1909==f?t[e]=5:1911==f?t[e]=3:1924==f?0==(eI(h)|0)?t[e]=0:(dI(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2],t[e]=6):1913==f?t[e]=9:1917==f?(t[e]=7,cI(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2]):1912==f?t[e]=8:1915==f?t[e]=11:1918==f?(f=T(),0==(pA(f)|0)?W(f):(dI(t[c],f),t[d]=t[K+48>>2],t[b]=t[K+24>>2],d=UD(t[c],t[Jy>>2]),t[g>>2]=d,t[e]=-1==(d|0)?6:4)):1914==f?t[e]=10:1910==f&&(t[e]=2)}aI.X=1;function fI(b){t[Ix>>2]=b}function eI(b){return 0!=(pA(b)|0)|10>(b-48|0)>>>0?1:95==(b|0)||45==(b|0)||36==(b|0)||35==(b|0)||46==(b|0)?1:0}function gI(b,d){var c;S(b);if(0==(hI(d)|0)){var e=t[(b|0)>>2];return e=0!=(e|0)&1}var f=0==(hI(d)|0),e=b|0;c=e>>2;var g=b+4|0;a:do{if(f){var h=d}else{for(var i=b+8|0,m=d;;){var n=t[c];(n+1|0)==(t[g>>2]|0)&&(R(b),n=t[c]);l[t[i>>2]+n|0]=m&255;0!=(m|0)&&(m=t[c]+1|0,t[c]=m,l[t[i>>2]+m|0]=0);m=iI();if(0==(hI(m)|0)){h=m;break a}}}}while(0);fI(h);f=t[c];(f+1|0)==(t[g>>2]|0)?(R(b),c=t[c]):c=f;l[t[b+8>>2]+c|0]=0;e=t[e>>2];return e=0!=(e|0)&1}gI.X=1;function jI(b){var d=0==(L(b)|0);a:do{if(d){var c=b}else{for(;;){var e=iI();if(0==(L(e)|0)){c=e;break a}}}}while(0);return c}function kI(b,d){for(var c=b<<24>>24,e=d<<24>>24,f=1;;){var g=iI(),f=(g|0)==(c|0)?f+1|0:(((g|0)==(e|0))<<31>>31)+f|0;if(0>=(f|0)){break}}return iI()}function hI(b){return(0!=(oA(b)|0)|95==(b|0)|96==(b|0))&1}function lI(){var b,d=zC(24);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+4]=t[K+48>>2];t[b+5]=t[K+24>>2];return d}function mI(b){0!=(b|0)&&(Q(t[b+8>>2]),Q(t[b+12>>2]),vB(b))}function nI(b,d){var c=t[b+4>>2];83==(c|0)?oI(b):23==(c|0)?uE(59):28==(c|0)?pI(b):79==(c|0)?oI(b):58==(c|0)?(c=lI(),qI(b),12==(t[b+4>>2]|0)?(qI(c),rI(c,9)):4==(t[b>>2]|0)&&rI(b,9),mI(c)):18==(c|0)?(c=lI(),qI(c),0==(d|0)?rI(c,0):rI(c,10),uE(59),mI(c)):16==(c|0)?sI(b):24==(c|0)?sI(b):61==(c|0)&&pI(b)}function oI(b){var d,c=lI();d=(b+4|0)>>2;var e=t[d];qI(c);qI(b);if(38==(t[d]|0)&&(qI(b),d=65==(t[d]|0),rI(c,83==(e|0)?1:2),d)){e=lI();qI(e);for(d=e+4|0;!(qI(b),uE(59),rI(e,3),qI(e),23==(t[d>>2]|0));){}uE(59);mI(e)}mI(c)}function sI(b){var d=lI(),c=b+4|0,e=t[c>>2];qI(d);24!=(e|0)?(rI(d,5),tI(),uE(59)):(qI(b),38==(t[c>>2]|0)&&(rI(d,4),tI(),uE(59)));mI(d)}function pI(b){var d,c,e,f=lI();c=(b+4|0)>>2;var g=28==(t[c]|0);qI(f);qI(b);d=(b|0)>>2;if(1==(t[d]|0)){var h=b|0;if(1==(t[h>>2]|0)){qI(b);for(var i=1;;){var m=t[h>>2],i=(1==(m|0)&1)+i|0,i=((2==(m|0)&0<(i|0))<<31>>31)+i|0;qI(b);if(!(0!=(i|0)|2!=(m|0))){break}}}}a:do{if(g){if(68!=(t[c]|0)){e=2060}else{for(qI(b);;){if(38==(t[c]|0)){e=2060;break a}if(8==(t[d]|0)){break a}qI(b)}}}else{e=2060}}while(0);do{if(2060==e&&8!=(t[d]|0)){if(38!=(t[c]|0)){mI(f);return}if(g){rI(f,7);for(d=f+8|0;;){if(qI(b),23==(t[c]|0)){if(qI(b),e=(28==(t[b+4>>2]|0)?1:0!=(uI(b,t[d>>2])|0))&1,uE(59),0!=(e|0)){break}}else{nI(b,1)}}}else{rI(f,8);for(d=f+8|0;;){if(qI(b),23==(t[c]|0)){if(qI(b),e=(61==(t[b+4>>2]|0)?1:0!=(uI(b,t[d>>2])|0))&1,uE(59),0!=(e|0)){break}}else{nI(b,1)}}}mI(f);return}}while(0);rI(f,6);mI(f)}pI.X=1;function iI(){var b,d=t[Ix>>2];0==(d|0)?d=T():t[Ix>>2]=0;if(34==(d|0)){for(;;){if(b=T(),-1==(b|0)||34==(b|0)){var c=64;break}}return c}if(47==(d|0)){b=2086}else{var e=d}a:do{if(2086==b){if(c=T(),-1==(c|0)){dB(vz|0,1)}else{if(42==(c|0)){e=vI()}else{if(47==(c|0)){for(;;){if(c=T(),-1==(c|0)||10==(c|0)){e=c;break a}}}else{return W(c),c=47}}}}}while(0);if(-1==(e|0)){dB(vz|0,1)}else{return e}}function qI(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+16|0)>>2;for(b=(b+20|0)>>2;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(34==(h|0)){f=2106;break}else{if(59==(h|0)){f=2103;break}else{if(41==(h|0)){f=2102;break}else{if(-1==(h|0)){f=2100;break}else{if(46==(h|0)){f=2104;break}else{if(44==(h|0)){f=2105;break}else{if(40==(h|0)){f=2101;break}else{if(32==(h|0)||10==(h|0)||9==(h|0)){continue}else{if(39==(h|0)){f=2128;break}else{if(45!=(h|0)){f=2112;break}}}}}}}}}}var i=T();if(45!=(i|0)){f=2109;break}uE(10)}if(2106==f){t[e]=9,wI(t[c]),t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2103==f){t[e]=8}else{if(2102==f){t[e]=2}else{if(2100==f){dB(uz|0,1)}else{if(2112==f){if(0==((95==(h|0)|0!=(pA(h)|0))&1|0)){t[e]=0}else{var i=t[c],m;m=(i|0)>>2;var n=i+4|0;for(f=(i+8|0)>>2;;){var q=t[m];(q+1|0)==(t[n>>2]|0)&&(R(i),q=t[m]);l[t[f]+q|0]=h&255;0!=(h|0)&&(q=t[m]+1|0,t[m]=q,l[t[f]+q|0]=0);q=T();if(0==((0==(pA(q)|0)?95==(q|0)|10>(q-48|0)>>>0:1)&1|0)){break}else{h=q}}h=t[m];(h+1|0)==(t[n>>2]|0)?(R(i),i=t[m]):i=h;l[t[f]+i|0]=0;0==(L(q)|0)&&W(q);t[d]=t[K+48>>2];t[b]=t[K+24>>2];d=UD(t[c],t[Ey>>2]);t[g>>2]=d;t[e]=-1==(d|0)?4:5}}else{2104==f?t[e]=6:2105==f?t[e]=3:2101==f?t[e]=1:2109==f&&(0==(L(i)|0)&&W(i),t[e]=7)}}}}}}qI.X=1;function rI(b,d){if(0!=(t[Cx+(d<<4)>>2]|0)){var c=b+12|0;if(0!=(t[t[c>>2]>>2]|0)){var e=P();V(e,t[t[c>>2]+8>>2]);U(e,Xi|0);c=b+8|0;U(e,t[t[c>>2]+8>>2]);var f=e|0,g=t[f>>2];(g+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=g;g=e+8|0;l[t[g>>2]+f|0]=0;V(t[c>>2],t[g>>2]);Q(e)}c=j;j+=80;e=c>>2;0!=(t[Cx+(d<<4)>>2]|0)&&(sC(c,t[t[b+8>>2]+8>>2]),t[e+1]=t[b+16>>2],t[e+2]=t[b+20>>2],t[e+9]=t[Cx+(d<<4)+8>>2],l[c+40|0]=t[Cx+(d<<4)+4>>2]&255,tC(c));j=c}}function uI(b,d){if(4!=(t[b>>2]|0)){var c;return 0}c=0==(sA(t[t[b+8>>2]+8>>2],t[d+8>>2],Aa)|0);return c&1}function tI(){for(var b=lI(),d=b+4|0;!(qI(b),23==(t[d>>2]|0));){}mI(b)}function wI(b){var d,c,e;e=(b|0)>>2;c=(b+4|0)>>2;d=(b+8|0)>>2;var f=1;a:for(;;){for(;;){if(!f){break a}var g=T();if(-1==(g|0)||34==(g|0)){f=0;continue a}else{if(92==(g|0)){var g=T(),h=t[e]}else{h=t[e]}(h+1|0)==(t[c]|0)&&(R(b),h=t[e]);l[t[d]+h|0]=g&255;0!=(g|0)&&(g=t[e]+1|0,t[e]=g,l[t[d]+g|0]=0)}}}f=t[e];(f+1|0)!=(t[c]|0)?(d=t[d],d=d+f|0):(R(b),b=t[e],d=t[d],d=d+b|0);l[d]=0}wI.X=1;function xI(){for(var b;;){var d=eC();if(0==(d|0)){var c=0;b=2211;break}for(;0!=(L(l[d]&255)|0);){d=d+1|0}if(34!=l[d]<<24>>24){c=d;b=2210;break}}if(2210==b||2211==b){return c}}function yI(b){var d,c,e=P(),f=92==l[b]<<24>>24;a:do{if(f){for(var g=b;;){var g=g+1|0,h=l[g];if(0==h<<24>>24){c=g;break a}if(0==(L(h&255)|0)){c=g;break a}}}else{if(0==(N(b,Hr|0,4)|0)){var i=0;Q(e);return i}if(0==(N(b,Go|0,4)|0)||0!=(N(b,om|0,3)|0)){return i=0,Q(e),i}g=b+3|0;h=l[g];109==h<<24>>24&&(g=b+4|0,h=l[g],97==h<<24>>24&&(g=b+5|0,h=l[g],110==h<<24>>24&&(g=b+6|0,g=h=100==l[g]<<24>>24?b+7|0:g,h=l[h])));g=33==h<<24>>24?g+1|0:g;if(32==l[g]<<24>>24){h=32}else{return i=1,Q(e),i}for(;;){if(0==h<<24>>24){c=g;break a}var m=g+1|0;if(0==(L(h&255)|0)){c=g;break a}g=m;h=l[m]}}}while(0);for(;;){b=0==(L(l[c]&255)|0);a:do{if(b){if(45==l[c]<<24>>24){f=c;for(g=45;;){if(0==g<<24>>24){i=f;break a}h=f+1|0;if(0!=(L(g&255)|0)){i=f;break a}f=h;g=l[h]}}else{i=c}}else{i=c+1|0}}while(0);c=l[i];if(0==c<<24>>24){break}if(0==(oA(c&255)|0)){c=i}else{d=2249;break}}if(2249==d&&0!=l[i]<<24>>24){c=(e|0)>>2;b=e+4|0;for(d=(e+8|0)>>2;!(f=t[c],(f+1|0)==(t[b>>2]|0)&&(R(e),f=t[c]),l[t[d]+f|0]=l[i],0!=l[i]<<24>>24&&(f=t[c]+1|0,t[c]=f,l[t[d]+f|0]=0),i=i+1|0,0==(oA(l[i]&255)|0)&&95!=l[i]<<24>>24);){}i=t[c];(i+1|0)==(t[b>>2]|0)&&(R(e),i=t[c]);l[t[d]+i|0]=0;jC(e,Ax|0,1);S(e);i=1;Q(e);return i}yI(xI());i=1;Q(e);return i}yI.X=1;function zI(b){return 0==(N(b,ys|0,3)|0)||0==(N(b,hs|0,2)|0)||0==(N(b,Or|0,3)|0)||0==(N(b,nr|0,4)|0)||0==(N(b,Yq|0,2)|0)||0==(N(b,Lq|0,3)|0)||0==(N(b,yq|0,4)|0)||0==(N(b,kq|0,2)|0)||0==(N(b,Sp|0,3)|0)||0==(N(b,Cp|0,4)|0)||0==(N(b,np|0,2)|0)||0==(N(b,ap|0,3)|0)||0==(N(b,No|0,4)|0)||0==(N(b,so|0,2)|0)||0==(N(b,jo|0,3)|0)||0==(N(b,$n|0,4)|0)||0==(N(b,Pn|0,2)|0)||0==(N(b,An|0,3)|0)||0==(N(b,pn|0,4)|0)||0==(N(b,br|0,2)|0)||0==(N(b,Tm|0,3)|0)||0==(N(b,Gm|0,4)|0)||0==(N(b,tm|0,5)|0)||0==(N(b,bm|0,6)|0)||0==(N(b,Tl|0,7)|0)||0==(N(b,Jl|0,3)|0)||0==(N(b,Bl|0,4)|0)||0==(N(b,rl|0,5)|0)||0==(N(b,gl|0,6)|0)||0==(N(b,Wk|0,7)|0)||0==(N(b,Kk|0,8)|0)||0==(N(b,xk|0,3)|0)||0==(N(b,nk|0,4)|0)||0==(N(b,Zj|0,5)|0)||0==(N(b,Rj|0,6)|0)||0==(N(b,Kj|0,7)|0)||0==(N(b,Fj|0,8)|0)||0==(N(b,yj|0,3)|0)||0==(N(b,rj|0,4)|0)||0==(N(b,fj|0,5)|0)||0==(N(b,Yi|0,6)|0)||0==(N(b,Mi|0,7)|0)||0==(N(b,Di|0,8)|0)||0==(N(b,mi|0,3)|0)||0==(N(b,gi|0,4)|0)||0==(N(b,bi|0,5)|0)||0==(N(b,Zh|0,6)|0)||0==(N(b,Vh|0,7)|0)||0==(N(b,Oh|0,8)|0)||0==(N(b,Gh|0,3)|0)||0==(N(b,Ah|0,4)|0)||0==(N(b,qh|0,5)|0)||0==(N(b,jh|0,6)|0)||0==(N(b,Yg|0,7)|0)||0==(N(b,Tg|0,8)|0)||0==(N(b,Og|0,3)|0)||0==(N(b,Jg|0,4)|0)||0==(N(b,Cg|0,5)|0)||0==(N(b,ug|0,6)|0)?1:0==(N(b,og|0,7)|0)?1:0==(N(b,kg|0,8)|0)&1}zI.X=1;function AI(b){for(var d,c,e=P();;){var f=l[b];if(0==f<<24>>24){c=b;break}var g=b+1|0;if(0==(oA(f&255)|0)){d=2393;break}else{b=g}}2393==d&&(c=33==l[b]<<24>>24?g:b);a:for(;;){g=l[c];do{if(0!=g<<24>>24&&0!=(L(g&255)|0)){c=c+1|0;continue a}}while(0);if(0==(N(c,Nv|0,8)|0)){var h=c;break}do{if(0==(N(c,nv|0,8)|0)){d=2402}else{if(0==(N(c,Ru|0,8)|0)){d=2402}else{if(0==(N(c,su|0,8)|0)){d=2402}else{if(0==(N(c,Ut|0,8)|0)){d=2402}else{if(0==(N(c,tt|0,6)|0)){var i=c+6|0}else{if(0!=(N(c,Ts|0,9)|0)){h=c;break a}i=c+9|0}}}}}}while(0);2402==d&&(d=0,i=c+8|0);if(0==l[i]<<24>>24){h=i;break}else{c=i}}c=(e|0)>>2;i=e+4|0;for(d=(e+8|0)>>2;!(g=t[c],(g+1|0)==(t[i>>2]|0)&&(R(e),g=t[c]),l[t[d]+g|0]=l[h],0!=l[h]<<24>>24&&(g=t[c]+1|0,t[c]=g,l[t[d]+g|0]=0),h=h+1|0,g=l[h],0==g<<24>>24||32==g<<24>>24);){}h=t[c];(h+1|0)==(t[i>>2]|0)&&(R(e),h=t[c]);d=t[d];d=d+h|0;l[d]=0;jC(e,Ax|0,3);S(e);Q(e)}AI.X=1;function BI(b){var d,c,e=j;j+=4;var f,g=P();d=b+2|0;var h=l[d];110==h<<24>>24?(d=b+3|0,h=l[d],99!=h<<24>>24?b=d:(d=b+4|0,h=l[d],116!=h<<24>>24?b=d:(d=b+5|0,h=l[d],105!=h<<24>>24?b=d:(d=b+6|0,h=l[d],111!=h<<24>>24?b=d:(h=b+7|0,b=h=110==l[h]<<24>>24?b+8|0:h,h=l[h]))))):b=d;b=33==h<<24>>24?b+1|0:b;h=0==(L(l[b]&255)|0);a:do{if(!h){for(d=b;;){c=l[d];if(0==c<<24>>24){break a}if(0==(L(c&255)|0)){break}else{d=d+1|0}}if(0!=l[d]<<24>>24){var i=CI(d,e);if(0==((65<=(l[i]&255)&&90>=(l[i]&255))|0)&&(d=t[e>>2],!(115==(d|0)||100==(d|0)||97==(d|0)||60==(d|0)))){break}c=(g|0)>>2;var m=g+4|0;for(d=(g+8|0)>>2;;){var n=t[c];(n+1|0)==(t[m>>2]|0)&&(R(g),n=t[c]);l[t[d]+n|0]=l[i];0!=l[i]<<24>>24&&(n=t[c]+1|0,t[c]=n,l[t[d]+n|0]=0);i=i+1|0;if(0==(oA(l[i]&255)|0)&&(n=l[i],!(95==n<<24>>24||46==n<<24>>24||35==n<<24>>24))){break}}i=t[c];(i+1|0)==(t[m>>2]|0)?(R(g),c=t[c]):c=i;l[t[d]+c|0]=0;jC(g,Ax|0,2);S(g)}}}while(0);for(;;){b=xI();if(0==(b|0)){f=2445;break}if(0!=(N(b,Re|0,5)|0)&&0==(N(b,jx|0,4)|0)){f=2446;break}}2446==f?(Q(g),j=e):2445==f&&(Q(g),j=e)}BI.X=1;function DI(b){var d,c=P(),e=b+3|0,f=l[e];114==f<<24>>24?(e=b+4|0,f=l[e],111!=f<<24>>24?b=e:(e=b+5|0,f=l[e],117!=f<<24>>24?b=e:(f=b+6|0,b=f=112==l[f]<<24>>24?b+7|0:f,f=l[f]))):b=e;if(0!=(L(f&255)|0)){for(e=b;;){b=l[e];if(0==b<<24>>24){d=2469;break}if(0==(L(b&255)|0)){break}else{e=e+1|0}}if(2469!=d&&0!=l[e]<<24>>24&&0!=(sA(e,Sf|0,3)|0)){b=(c|0)>>2;f=c+4|0;for(d=(c+8|0)>>2;;){var g=t[b];(g+1|0)==(t[f>>2]|0)&&(R(c),g=t[b]);l[t[d]+g|0]=l[e];0!=l[e]<<24>>24&&(g=t[b]+1|0,t[b]=g,l[t[d]+g|0]=0);e=e+1|0;if(0==(oA(l[e]&255)|0)&&95!=l[e]<<24>>24){break}}e=t[b];(e+1|0)==(t[f>>2]|0)?(R(c),b=t[b]):b=e;l[t[d]+b|0]=0;jC(c,Ax|0,0);S(c)}}Q(c)}DI.X=1;function EI(b){var d,c,e=P(),b=b+3|0;if(0!=(L(l[b]&255)|0)){for(;;){var f=l[b];if(0==f<<24>>24){d=2495;break}var g=b+1|0;if(0==(L(f&255)|0)){break}else{b=g}}if(2495!=d){f=l[b];if(118==f<<24>>24){d=2476}else{if(0==f<<24>>24||38==f<<24>>24||64==f<<24>>24||91==f<<24>>24){Q(e);return}var h=b;c=f}if(2476==d){if(58!=l[g]<<24>>24){h=b,c=118}else{Q(e);return}}for(;;){if(0==c<<24>>24||36==c<<24>>24){var i=c;break}g=h+1|0;if(0!=(oA(c&255)|0)){d=2480;break}h=g;c=l[g]}2480==d&&(i=l[h]);if(0!=i<<24>>24){c=(e|0)>>2;g=e+4|0;d=(e+8|0)>>2;for(b=i;0!=b<<24>>24;){if(i=t[c],(i+1|0)==(t[g>>2]|0)&&(R(e),b=l[h],i=t[c]),l[t[d]+i|0]=b,0!=l[h]<<24>>24&&(i=t[c]+1|0,t[c]=i,l[t[d]+i|0]=0),h=h+1|0,i=l[h],0!=(oA(l[h]&255)|0)){b=i}else{if(95==i<<24>>24||35==i<<24>>24||58==i<<24>>24||36==i<<24>>24){b=i}else{break}}}i=t[c];(i+1|0)==(t[g>>2]|0)&&(R(e),i=t[c]);l[t[d]+i|0]=0;jC(e,Ax|0,4);S(e)}}}Q(e)}EI.X=1;function FI(b){return-2==(b|0)?b=Lu|0:b=t[t[t[Cy>>2]+(b<<2)>>2]>>2]}function CI(b,d){var c=d>>2,e=tb(b),f=0!=(d|0);f&&(t[c]=0);if(3<e>>>0){if(58==l[b+1|0]<<24>>24){f&&(t[c]=l[b]&255);var g;return b+2|0}if(5<e>>>0){if(0!=(sA(b,xw|0,5)|0)){e=0}else{return f&&(t[c]=l[b]&255),b+5|0}}else{e=0}}else{e=0}for(;;){if(f=l[b+e|0]&255,35==(f|0)?t[c]=97:46==(f|0)&&(t[c]=100),e=e+1|0,f=b+e|0,0==(oA(l[f]&255)|0)&&(f=l[f],!(95==f<<24>>24||46==f<<24>>24||35==f<<24>>24))){g=b;break}}return g}CI.X=1;function jC(b,d,c){var e=j;j+=80;!(0==(t[d+(c<<4)>>2]|0)|0==(b|0))&&0!=(t[b>>2]|0)&&(sC(e,t[b+8>>2]),t[e+36>>2]=t[d+(c<<4)+8>>2],l[e+40|0]=t[d+(c<<4)+4>>2]&255,tC(e));j=e}function GI(b){var d=MG(52);t[d>>2]=HI(b);return d}function II(b){var d=t[oy+128>>2];if(-1==(d|0)){if(d=JI(KI(b)),-2!=(d|0)){var c=d}else{var e;var d=kH(b),f=t[Dy>>2];if(0==(f|0)){e=-2}else{for(var g=t[Cy>>2],h=-2,i=0;;){var m=t[t[g+(i<<2)>>2]+44>>2];if(0!=(m|0)){var n;n=ba;for(var q=m+4|0,m=m+8|0,p=0,s=0;;){if(0!=(s|0)){var r=s;n=2999;break}if(p>>>0>=t[q>>2]>>>0){r=0;n=3e3;break}s=0==(sA(t[t[t[m>>2]+(p<<2)>>2]+8>>2],d,Aa)|0)&1;p=p+1|0}n=2999==n||3e3==n?r:ba;h=0==(n|0)?h:i}i=i+1|0;if(!(i>>>0<f>>>0&-2==(h|0))){e=h;break}}}if(-2!=(e|0)){c=e}else{if(LI(b),0==(t[ld+20>>2]|0)){c=-2}else{if(b=tB(b,Wv|0),0==(b|0)){c=-2}else{e=P();r=MI(e,b);if(0==(r|0)){c=-2}else{if(35!=l[r]<<24>>24){c=-2}else{if(33!=l[r+1|0]<<24>>24){c=-2}else{d=gB(r,47);r=NI(0==(d|0)?r+2|0:d+1|0);d=r+8|0;f=JI(t[d>>2]);if(-2==(f|0)){if(f=t[Dy>>2],0==(f|0)){c=-2}else{g=t[Cy>>2];i=-2;for(h=0;;){if(n=t[t[g+(h<<2)>>2]>>2],i=0==(n|0)?i:0==(sA(t[d>>2],n,Aa)|0)?h:i,h=h+1|0,!(h>>>0<f>>>0&-2==(i|0))){c=i;break}}}}else{c=f}Q(r)}}}Q(e);uB(b)}}}}}else{c=d}return c}function JI(b){var d=t[Dy>>2];if(0==(d|0)){var c;return-2}for(var e=0,f=d;;){if(d=t[t[t[Cy>>2]+(e<<2)>>2]+48>>2],0==(d|0)?d=-2:(d=0==(-1!=(OI(d,b,186)|0)&1|0)?-2:e,f=t[Dy>>2]),e=e+1|0,!(e>>>0<f>>>0&-2==(d|0))){c=d;break}}return c}function PI(b){for(var d=j,c,e=t[t[t[Cy>>2]+(b<<2)>>2]+44>>2],f=0==(e|0),g=e+4|0,h=e+8|0,e=1,i=0;!f&&i>>>0<t[g>>2]>>>0;){var e=0!=(e|0)?hm|0:Eo|0,m=t[t[t[h>>2]+(i<<2)>>2]+8>>2];mB(lw|0,(k=j,j+=8,t[k>>2]=e,t[k+4>>2]=m,k));e=0;i=i+1|0}g=t[t[t[Cy>>2]+(b<<2)>>2]+48>>2];b=0==(g|0);f=g+4|0;g=g+8|0;h=e;for(e=0;;){if(b){c=2587;break}if(e>>>0>=t[f>>2]>>>0){c=2586;break}h=0!=(h|0)?hm|0:Eo|0;i=t[t[t[g>>2]+(e<<2)>>2]+8>>2];mB(lm|0,(k=j,j+=8,t[k>>2]=h,t[k+4>>2]=i,k));h=0;e=e+1|0}2587==c?j=d:2586==c&&(j=d)}PI.X=1;function QI(){var b,d=j;b=zC(176);t[Cy>>2]=b;KC(Rf|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));for(var c=0;;){var e=ab[t[Uz+(c<<2)>>2]]();b=e>>2;var f=0==(e|0);a:do{if(!f){var g=t[b];do{if(0!=(g|0)&&0!=l[g]<<24>>24){f=e+24|0;do{if(0==(t[b+8]|0)){if(!(0==(t[f>>2]|0)^0==(t[b+7]|0))){RI(1,ix|0,(k=j,j+=4,t[k>>2]=g,k));break a}}else{t[f>>2]=132}}while(0);f=0!=(c|0)?Cr|0:hm|0;KC(cw|0,(k=j,j+=8,t[k>>2]=f,t[k+4>>2]=g,k));g=t[Dy>>2];t[Dy>>2]=g+1|0;t[b+9]=g;t[t[Cy>>2]+(g<<2)>>2]=e;break a}}while(0);RI(1,Qe|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k))}}while(0);b=c+1|0;if(44==(b|0)){break}else{c=b}}KC(Jq|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));b=t[Dy>>2];if(0!=(b|0)){for(c=0;!(t[t[t[Cy>>2]+(c<<2)>>2]+40>>2]=1,c=c+1|0,c>>>0>=b>>>0);){}}c=t[Dy>>2];if(0!=(c|0)){for(b=0;!(e=t[t[t[Cy>>2]+(b<<2)>>2]+20>>2],0!=(e|0)&&(ab[e](b),c=t[Dy>>2]),b=b+1|0,b>>>0>=c>>>0);){}}j=d}QI.X=1;function NI(b){var d,c,e,f=P();c=(f|0)>>2;var g=f+4|0;for(d=(f+8|0)>>2;;){for(S(f);;){if(0==(L(l[b]<<24>>24)|0)){var h=b;break}else{b=b+1|0}}for(;;){b=l[h];if(0==b<<24>>24){e=2676;break}var i=t[c],m=(i+1|0)==(t[g>>2]|0);if(0!=(L(b<<24>>24)|0)){e=2683;break}m?(R(f),b=t[c]):b=i;l[t[d]+b|0]=l[h];0!=l[h]<<24>>24&&(b=t[c]+1|0,t[c]=b,l[t[d]+b|0]=0);h=h+1|0}if(2676==e){if(e=0,b=t[c],(b+1|0)==(t[g>>2]|0)){e=2684}else{var n=b}}else{2683==e&&(e=0,m?e=2684:n=i)}2684==e&&(e=0,R(f),n=t[c]);l[t[d]+n|0]=0;if(0==(qA(t[d],Lo|0)|0)){b=h}else{break}}return f}NI.X=1;function KC(b){var d=j;j+=4;0!=(t[oy+88>>2]|0)&&(t[d>>2]=arguments[KC.length],wB(b,t[d>>2]));j=d}function rD(b,d,c){var e,f=t[oy+60>>2];if(0==(f|0)){var g;return 0}var h=tb(b),i=0!=(d|0);i&&(t[d>>2]=0);for(var m=t[f+4>>2],n=h+1|0,f=f+8|0,q=0;;){if(q>>>0>=m>>>0){g=0;e=2724;break}var p=t[t[f>>2]+(q<<2)>>2],s=t[p+8>>2];if(0==(N(s,b,h)|0)){p=t[p>>2];if((h|0)==(p|0)){g=1;e=2720;break}var r=l[s+h|0];if((p|0)==(n|0)&43==r<<24>>24){e=2711;break}if(61==r<<24>>24){e=2714;break}}q=q+1|0}if(2714==e){if(0==(c|0)){return 0}t[c>>2]=s+n|0;return 0}if(2711==e){return!i?1:t[d>>2]=1}if(2720==e||2724==e){return g}}function SI(b){var d=j,c=b+1|0,e=l[b];if(0==e<<24>>24){c=oz,b=t[c>>2],0!=(b|0)&&(fH(b),t[c>>2]=0)}else{if(64==e<<24>>24){b=tB(c,Wv|0);if(0==(b|0)){var f=0}else{if(e=bH(),0!=(cB(b)|0)){f=e}else{for(;;){var g=P();MI(g,b);DD(g);0==(t[g>>2]|0)?Q(g):AE(e,g);if(0!=(cB(b)|0)){f=e;break}}}}b=f;0==(b|0)&&RI(5,Xv|0,(k=j,j+=4,t[k>>2]=c,k));f=t[oz>>2];if(0==(f|0)){t[oz>>2]=b}else{e=b+4|0;if(0!=(t[e>>2]|0)){for(var g=b+8|0,h=0;!(AE(f,t[t[g>>2]+(h<<2)>>2]),t[t[g>>2]+(h<<2)>>2]=0,h=h+1|0,h>>>0>=t[e>>2]>>>0);){}}fH(b)}KC(Fm|0,(k=j,j+=4,t[k>>2]=c,k))}else{c=PD(b),f=t[oz>>2],0==(f|0)&&(f=bH(),t[oz>>2]=f),AE(f,c),KC(rm|0,(k=j,j+=4,t[k>>2]=b,k))}}j=d}function kH(b){var d=gB(b,47);return 0==(d|0)?b:d+1|0}function zC(b){var d=j,b=Xa(b);if(0!=(b|0)){return j=d,b}RI(1,gk|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));j=d;return b}function MG(b){var d=j;var c=Xa(b);0==(c|0)||0==(t[c-4>>2]&3|0)||Ya(c,b);if(0!=(c|0)){return j=d,c}RI(1,gk|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));j=d;return c}function jF(b,d){var c=j;if(0==(b|0)){var e=zC(d)}else{e=0==(b|0)?Xa(d):TI(b,d),0==(e|0)&&(RI(1,gk|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k)),e=0)}j=c;return e}function HI(b){var d=zC(tb(b)+1|0);AB(d,b);return d}function LI(b){var d=j;j+=72;var c=t[ld>>2];if(!(0!=(c|0)&&0==(qA(b,c)|0))){if(c=t[ld>>2],0!=(c|0)&&(vB(c),t[ld>>2]=0),b=HI(b),t[ld>>2]=b,0!=(PB(b,d,ca)|0)){t[ld+4>>2]=0}else{var b=d+8|0,c=t[b>>2],e=40960==(c&61440|0);t[ld+8>>2]=e&1;if(e){if(0==(PB(t[ld>>2],d)|0)){b=t[b>>2]}else{t[ld+4>>2]=0;j=d;return}}else{b=c}t[ld+4>>2]=1;c=b&61440;t[ld+12>>2]=16384==(c|0)&1;t[ld+16>>2]=32768==(c|0)&1;t[ld+20>>2]=0!=(b&73|0)&1;t[ld+24>>2]=b>>>11&1;t[ld+28>>2]=t[d+28>>2]}}j=d}LI.X=1;function KI(b){b=gB(kH(b),46);return 0==(b|0)?hm|0:b+1|0}function UI(b,d,c,e,f){var g=j;j+=12;var h=g+4,i=g+8;var m=j;j+=256;var n=0==(f|0);b:do{if(n){var q=9}else{for(var p=0,s=9;;){var r=l[f+p|0];if(0==r<<24>>24){q=s;break b}r=r<<24>>24;101==(r|0)?s|=1:98==(r|0)?s&=-2:105==(r|0)?s|=2:RI(2,Qu|0,(k=j,j+=4,t[k>>2]=l[f]<<24>>24,k));p=p+1|0}}}while(0);f=zC(16);n="";q&2&&(n+="i");SB[f]=RegExp(TB(d),n);j=m;0!=(f|0)&&(VI(e,g,h,i),WI(b,f,HI(c),l[g],t[h>>2],t[i>>2]));j=g}function VI(b,d,c,e){c>>=2;l[d]=0;t[c]=0;t[e>>2]=0;var f=0==(b|0);a:do{if(!f){f=l[b];do{if(0==f<<24>>24){break a}else{if(44==f<<24>>24){var g=b,h=114}else{g=b+1|0,h=l[g],44==h<<24>>24||0==h<<24>>24?h=f:(g=b,h=114)}}}while(0);l[d]=h;b=44==l[g]<<24>>24?g+1|0:g;if(0==l[b]<<24>>24){t[c]=HI(yt|0);return}d=mA(b,44);if(0==(d|0)){t[c]=HI(b);return}f=d-b|0;g=zC(f+1|0);t[c]=g;iB(g,b,f);l[t[c]+f|0]=0;c=d+1|0;if(0==l[c]<<24>>24){return}t[e>>2]=HI(c);return}}while(0);l[d]=114;t[c]=HI(yt|0)}VI.X=1;function WI(b,d,c,e,f,g){var h,i=t[Yx>>2];if((t[Zx>>2]|0)<(b|0)){i=jF(i,(b<<3)+8|0);t[Yx>>2]=i;h=t[Zx>>2]+1|0;var m=(h|0)>(b|0);a:do{if(!m){for(var n=h;;){if(t[i+(n<<3)>>2]=0,t[i+(n<<3)+4>>2]=0,n=n+1|0,(n|0)>(b|0)){break a}}}}while(0);t[Zx>>2]=b}h=i;i=(b<<3)+h|0;h=((b<<3)+h+4|0)>>2;m=jF(t[i>>2],28*t[h]+28|0);b=m>>2;t[i>>2]=m;i=t[h];t[h]=i+1|0;t[b+(7*i|0)]=d;t[b+(7*i|0)+1]=0;t[b+(7*i|0)+2]=c;t[b+(7*i|0)+3]=1;l[m+28*i+16|0]=e;t[b+(7*i|0)+5]=f;t[b+(7*i|0)+6]=g}WI.X=1;function RI(b,d){var c=j;j+=4;t[c>>2]=arguments[RI.length];var e=0!=(b&2|0)?fw|0:hm|0;lB(t[Wb>>2],Ht|0,(k=j,j+=8,t[k>>2]=0,t[k+4>>2]=e,k));xB(t[Wb>>2],d,t[c>>2]);if(0!=(b&4|0)){var e=t[Wb>>2],f,g=t[GA>>2];zB||(zB=Xa(256));f=zB;if(g in yB){if(255<yB[g].length){FA(DA)}else{for(var g=yB[g],h=0;h<g.length;h++){l[f+h]=g.charCodeAt(h)}l[f+h]=0}}else{FA(xA)}f=zB;lB(e,Co|0,(k=j,j+=4,t[k>>2]=f,k))}pB(10,t[Wb>>2]);0==(b&1|0)?j=c:(nb(rb),aa("exit(1) called, at "+Error().stack))}function S(b){t[b>>2]=0;l[t[b+8>>2]]=0}function zD(b){var d=b|0,c=t[d>>2];0!=(c|0)&&(c=c-1|0,t[d>>2]=c,l[t[b+8>>2]+c|0]=0)}function XI(b){var d=l[b];if(0==d<<24>>24){return 0}for(var c=0;;){var c=c<<1,e=d&255^(0==(c&256|0)?c:c&254|1),b=b+1|0,d=l[b];if(0==d<<24>>24){break}else{c=e}}return(40503*e|0)>>>9&127}function YI(b,d,c){var e,f,g,h=P();f=(h|0)>>2;var i=h+4|0;e=(h+8|0)>>2;a:for(;;){var m=l[d];do{if(92==m<<24>>24){var n=d+1|0,q=l[n],p=q<<24>>24,s=p-48|0;if(10>s>>>0){if(9>(p-49|0)>>>0){var r=t[c+(s<<3)>>2];-1!=(r|0)&&gD(h,b+r|0,t[c+(s<<3)+4>>2]-r|0)}r=n}else{var u=n,v=q;g=2926}}else{if(0==m<<24>>24){break a}else{u=d,v=m,g=2926}}}while(0);2926==g&&(g=0,10==v<<24>>24||13==v<<24>>24||(m=t[f],(m+1|0)==(t[i>>2]|0)?(R(h),d=l[u],m=t[f]):d=v,l[t[e]+m|0]=d,0!=l[u]<<24>>24&&(d=t[f]+1|0,t[f]=d,l[t[e]+d|0]=0)),r=u);d=r+1|0}b=t[f];if((b+1|0)!=(t[i>>2]|0)){return e=t[e],e=e+b|0,l[e]=0,h}R(h);f=t[f];e=t[e];e=e+f|0;l[e]=0;return h}YI.X=1;function bH(){var b,d=zC(12);b=d>>2;t[b]=0;t[b+1]=0;t[b+2]=0;return d}function AE(b,d){var c,e;e=(b+8|0)>>2;var f=t[e];c=(b+4|0)>>2;if(0==(f|0)){t[c]=0,t[b>>2]=10,f=zC(40),t[e]=f}else{var g=t[c],h=b|0;(g|0)==(t[h>>2]|0)&&(g=g+10|0,t[h>>2]=g,f=jF(f,g<<2),t[e]=f)}e=f;f=t[c];t[c]=f+1|0;t[e+(f<<2)>>2]=d}function fH(b){var d;if(0!=(b|0)){d=(b+8|0)>>2;if(0!=(t[d]|0)){var c;c=(b+4|0)>>2;if(0!=(t[c]|0)){for(var e=b+8|0,f=0;!(Q(t[t[e>>2]+(f<<2)>>2]),t[t[e>>2]+(f<<2)>>2]=0,f=f+1|0,f>>>0>=t[c]>>>0);){}}t[c]=0;vB(t[d]);t[d]=0}t[b>>2]=0;t[b+4>>2]=0;vB(b)}}function ZI(b){var d=bH(),c=t[b>>2];if(0==(c|0)){return d}for(;!(AE(d,PD(c)),b=b+4|0,c=t[b>>2],0==(c|0));){}return d}function zE(b,d){return-1!=(OI(b,d,66)|0)&1}function OI(b,d,c){for(var e,f=b+4|0,b=b+8|0,g=0,h=-1;;){if(-1!=(h|0)){var i=h;e=2989;break}if(g>>>0>=t[f>>2]>>>0){i=-1;e=2988;break}h=0==(ab[c](d,t[t[b>>2]+(g<<2)>>2])|0)?-1:g;g=g+1|0}if(2988==e||2989==e){return i}}function R(b){var d=t[b+4>>2];1073741824>d>>>0&&$I(b,d<<1)}function $I(b,d){var c=b+8|0,e=jF(t[c>>2],d);t[b+4>>2]=d;t[c>>2]=e}function Q(b){if(0!=(b|0)){var d=t[b+8>>2];0!=(d|0)&&vB(d);vB(b)}}function P(){var b,d=zC(12);b=d>>2;t[b]=0;t[b+1]=32;t[b+2]=zC(32);S(d);return d}function U(b,d){var c,e=tb(d);c=(b|0)>>2;var f=t[c],g=e+1|0,h=b+4|0,i=(g+f|0)>>>0<t[h>>2]>>>0;a:do{if(i){var m=f}else{for(;;){R(b);var n=t[c];if((g+n|0)>>>0<t[h>>2]>>>0){m=n;break a}}}}while(0);AB(t[b+8>>2]+m|0,d);t[c]=t[c]+e|0}function BE(b){var d=P();U(d,t[b+8>>2]);return d}function PD(b){var d=P();U(d,b);return d}function gD(b,d,c){var e,f=l[d],g=0!=(c|0)&0!=f<<24>>24;e=(b|0)>>2;var h=t[e],i=b+4|0,m=(h+1|0)==(t[i>>2]|0);a:do{if(g){for(var n=b+8|0,q=d,p=c,s=m,r=f,u=h;;){if(s&&(R(b),r=l[q],u=t[e]),l[t[n>>2]+u|0]=r,0!=l[q]<<24>>24&&(u=t[e]+1|0,t[e]=u,l[t[n>>2]+u|0]=0),p=p-1|0,q=q+1|0,r=l[q],u=t[e],s=(u+1|0)==(t[i>>2]|0),!(0!=(p|0)&0!=r<<24>>24)){var v=s,w=u;break a}}}else{v=m,w=h}}while(0);v&&(R(b),w=t[e]);b=t[(b+8|0)>>2];b=b+w|0;l[b]=0}gD.X=1;function DD(b){var d;d=(b|0)>>2;for(b=b+8|0;0!=(L(l[t[b>>2]+(t[d]-1)|0]<<24>>24)|0);){var c=t[d];if(0==(c|0)){break}c=c-1|0;t[d]=c;l[t[b>>2]+c|0]=0}}function V(b,d){S(b);U(b,d)}function lC(b,d,c,e){t[b+4>>2]>>>0<c>>>0&&$I(b,c);b=t[b+8>>2];if(0==(d|0)){var f,d=b+0|0}else{for(c=0;;){if(l[b+c|0]=rA(l[e+c|0]<<24>>24)&255,c=c+1|0,(c|0)==(d|0)){f=d;break}}d=b+f|0}l[d]=0}function vC(b,d,c){var e=XI(b),f=t[aJ()+(e<<2)>>2];if(0==(f|0)){t[aJ()+(e<<2)>>2]=bJ(b,d,c)}else{for(e=f;;){var g=e|0,e=t[g>>2];if(0==(e|0)){break}}t[g>>2]=bJ(b,d,c)}}function JC(b){t[Lz+4>>2]=t[Lz>>2];t[Lz>>2]=b}function cJ(){return t[Lz+(t[Lz+28>>2]<<4)+44>>2]}function dJ(){return(t[Lz+28>>2]<<4)+Lz+32|0}function aJ(){if(l[Uc]){var b=t[bz>>2];return b}b=zC(512);t[bz>>2]=b;for(var d=0;!(t[b+(d<<2)>>2]=0,d=d+1|0,128==(d|0));){}l[Uc]=1;return b}function bJ(b,d,c){var e,f=zC(16);e=f>>2;t[e]=0;t[e+1]=b;t[e+2]=d;t[e+3]=c;return f}function mC(b,d){var c,e,f=t[aJ()+(XI(b)<<2)>>2];for(c=f>>2;;){if(0==(f|0)){var g=-1;e=3099;break}if((t[c+2]|0)==(d|0)&&0==(qA(b,t[c+1])|0)){break}f=t[c];c=f>>2}return 3099==e?g:g=t[c+3]}function UD(b,d){var c=P();lC(c,t[b>>2],t[b+4>>2],t[b+8>>2]);var e=mC(t[c+8>>2],d);Q(c);return e}function vI(){for(var b,d=T();;){if(-1==(d|0)){var c=-1;b=3117;break}var e=T();if(42==(d|0)&47==(e|0)){c=32;b=3116;break}else{d=e}}if(3117==b||3116==b){return c}}function IC(){var b,d=t[Lz>>2];if(0==(d|0)){var c=d=0}else{t[Lz>>2]=t[Lz+4>>2];t[Lz+4>>2]=0;var e;return d}a:for(;;){b:for(;;){for(var f=T();;){if(9==(f|0)||32==(f|0)){var g=f;b=3150;break b}else{if(-1==(f|0)){var h=0,i=0,m=-1;b=3151;break b}else{if(10==(f|0)){b=3122;break b}else{if(34==(f|0)){b=3123;break b}else{if(39==(f|0)){b=3126;break b}else{if(35==(f|0)){break}else{if(47==(f|0)){b=3127;break b}else{if(92==(f|0)){b=3132;break b}else{if(63!=(f|0)){b=3144;break b}}}}}}}}}var n=T();if(63!=(n|0)){b=3136;break b}var q=T();if(40==(q|0)){g=91;b=3150;break b}else{if(41==(q|0)){h=d;i=c;m=93;b=3151;break b}else{if(60==(q|0)){var p=d,s=c,r=123;break b}else{if(47==(q|0)){f=92;continue}else{if(62==(q|0)){b=3138;break b}else{if(33==(q|0)){b=3139;break b}else{if(39==(q|0)){b=3140;break b}else{if(45==(q|0)){b=3141;break b}else{if(61!=(q|0)){b=3143;break b}}}}}}}}}f=35}if(0==(t[Lz+20>>2]|0)){p=d;s=c;r=35;break}t[Lz+16>>2]=2;t[Lz+20>>2]=0;d=1}b:do{if(3150==b){b=0,p=d,s=c,r=g}else{if(3151==b){b=0,p=h,s=i,r=m}else{if(3136==b){b=0,W(n),p=d,s=c,r=63}else{if(3144==b){b=0;do{if(64==(f|0)&0!=(t[Lz+12>>2]|0)&&34==(T()|0)){t[Lz+20>>2]=0;eJ(1);p=d;s=c;r=211;break b}}while(0);t[Lz+20>>2]=0;if(0==(d|0)){p=0,s=c,r=f}else{var c=f,u=cJ(),v=t[Lz+16>>2];if(2==(v|0)){c=fJ(c)}else{if(3==(v|0)){u=ba;c=48!=(c|0)&1;u=ba;v=cJ();u=t[Lz+28>>2];if(19>u>>>0){t[Lz+28>>2]=u+1|0;u=dJ()>>2;t[u]=v;var w=t[Lz+8>>2];t[u+1]=w;t[u+2]=c;c=(0==(v|0)?0!=(t[Vz>>2]|c|0)?0:0!=(w|0)?1:0==(t[oy+120>>2]|0):1)&1;t[u+3]=c}else{c=0}u=c;t[Lz+16>>2]=0}else{if(4==(v|0)){c:{if(0!=(pA(c)|0)||126==(c|0)||95==(c|0)||36==(c|0)){if(gJ(c),0==(qA(t[t[Lz+24>>2]+8>>2],Ys|0)|0)){for(;;){var C=T();if(32!=(C|0)){break}}if(0==(pA(C)|0)&&!(126==(C|0)||95==(C|0)||36==(C|0))){t[Lz+16>>2]=0;break c}gJ(C);hJ()}}t[Lz+16>>2]=0}}else{1==(v|0)?iJ(c):5==(v|0)&&iJ(c)}}c=u}continue a}}else{if(3122==b){b=0,t[Lz+20>>2]=1,p=0!=(d|0)&0==(c|0)?0:d,s=c,r=10}else{if(3123==b){b=0,t[Lz+20>>2]=0,eJ(0),p=d,s=c,r=211}else{if(3143==b){b=0,W(q),JC(63),p=d,s=c,r=63}else{if(3126==b){b=0;t[Lz+20>>2]=0;p=ba;r=s=0;c:for(;;){if(0==(s|0)){for(s=r;;){var A=T();if(-1==(A|0)){p=3180;break c}var I=s+1|0;if(10==(A|0)){p=3174;break c}else{if(39==(A|0)){p=3183;break c}else{if(92!=(A|0)){break}}}T();s=I}s=0==(s|0)&&0!=(bC(Pe|0,nA(A),5)|0)?A:0;r=I}else{for(u=r;;){var M=T();if(-1==(M|0)){p=3185;break c}v=u+1|0;if(10==(M|0)){p=3174;break c}else{if(39==(M|0)){p=3184;break c}else{if(92==(M|0)){T();u=v;continue}}}if(0==(u|0)&&0!=(bC(Pe|0,nA(M),5)|0)){s=M;r=v;continue c}if(0==(oA(M)|0)){p=3178;break c}else{u=v}}}}3178==p?W(M):3174==p&&W(10);p=d;s=c;r=195}else{if(3127==b){if(b=0,p=T(),42==(p|0)?p=1:47==(p|0)?p=2:(W(p),p=0),2==(p|0)){for(;;){var B=T();if(-1==(B|0)||10==(B|0)){break}else{if(92!=(B|0)){continue}}T()}r=B;10!=(r|0)?(p=d,s=c):(W(10),p=d,s=c,r=10)}else{1==(p|0)?(p=d,s=c,r=vI()):(t[Lz+20>>2]=0,p=d,s=c,r=47)}}else{3138==b?(b=0,p=d,s=c,r=125):3139==b?(b=0,p=d,s=c,r=124):3140==b?(b=0,p=d,s=c,r=94):3141==b?(b=0,p=d,s=c,r=126):3132==b&&(b=0,p=T(),10!=(p|0)&&(63==(p|0)?JC(63):W(p)),p=d,s=c,r=92)}}}}}}}}}}while(0);if(0==(p|s|0)){e=r;break}else{d=p,c=s}}return e}IC.X=1;function eJ(b){if(0!=(b|0)){for(;!(b=T(),-1==(b|0)||34==(b|0));){}}else{for(;;){b=T();if(-1==(b|0)||34==(b|0)){break}else{if(92!=(b|0)){continue}}T()}}}function iJ(b){var d;if(0==(pA(b)|0)){if(126==(b|0)||95==(b|0)||36==(b|0)){d=3203}}else{d=3203}3203==d&&(gJ(b),0==(cJ()|0)&&hJ());t[Lz+16>>2]=0}function fJ(b){var d=j;j+=12;for(var c=d|0,e,f=b,b=0;;){if(9<=b>>>0){e=3274;break}if(0!=(b|0)){var g=T();if(-1==(g|0)){break}if(0==(pA(g)|0)){break}else{f=g}}l[c+b|0]=f&255;b=b+1|0}3274!=e&&W(g);e=c+b|0;l[e]=0;e=0==(qA(c,zr|0)|0);a:do{if(e){t[Lz+16>>2]=1,g=0}else{if(0==(qA(c,zo|0)|0)){t[Lz+16>>2]=5,g=0}else{if(0==(N(c,im|0,2)|0)){t[Lz+16>>2]=3,g=0}else{do{if(0!=(qA(c,dk|0)|0)&&0!=(qA(c,ti|0)|0)){if(0==(qA(c,ch|0)|0)){c=t[Lz+28>>2];0!=(c|0)&&(t[Lz+28>>2]=c-1|0);c=cJ();t[Lz+16>>2]=0;g=c;break a}t[Lz+16>>2]=0==(qA(c,Of|0)|0)?4:0;g=0;break a}}while(0);g=jJ();t[Lz+(t[Lz+28>>2]<<4)+44>>2]=g;0==(g|0)&&0==(qA(c,ti|0)|0)&&0==(t[Vz>>2]|0)&&(b=dJ(),t[b+8>>2]=(0==(t[b+4>>2]|0)?0!=(t[Lz+8>>2]|0):1)&1);t[Lz+16>>2]=0}}}}while(0);j=d;return g}fJ.X=1;function gJ(b){var d=t[Lz+24>>2],c,e;S(d);e=(d|0)>>2;var f=d+4|0;for(c=(d+8|0)>>2;;){var g=t[e];(g+1|0)==(t[f>>2]|0)&&(R(d),g=t[e]);l[t[c]+g|0]=b&255;0!=(b|0)&&(b=t[e]+1|0,t[e]=b,l[t[c]+b|0]=0);g=T();if(-1==(g|0)){break}if(0!=(oA(g)|0)){b=g}else{if(95==(g|0)||36==(g|0)){b=g}else{break}}}W(g);b=t[e];(b+1|0)!=(t[f>>2]|0)?(c=t[c],c=c+b|0):(R(d),d=t[e],c=t[c],c=c+d|0);l[c]=0}function hJ(){var b=t[t[Lz+24>>2]+8>>2],d,c=j;j+=80;d=c>>2;var e=0==(t[K+52>>2]|0);0!=(t[Tz+16>>2]|0)&&0!=(t[oy+8>>2]|0)|e^1&&(sC(c,b),t[d]=2!=(t[oy+76>>2]|0)&1,t[d+4]=e&1,t[d+6]=1,t[d+9]=Zv|0,l[c+40|0]=100,tC(c));j=c}function W(b){t[K+28>>2]=b}function jJ(){var b;b=dJ()>>2;0==(t[Lz+8>>2]|0)|0!=(t[Vz>>2]|0)||(t[b+1]=1);if(0!=(t[b]|0)){return 1}if(0==(t[b+2]|0)){return 0}b=0!=(t[b+1]|0);return b&1}function kJ(b){var d,c;d=t[K+40>>2];0!=(d|0)&&Q(d);t[K+40>>2]=b;d=t[K+44>>2];0!=(d|0)&&vB(d);d=(b+8|0)>>2;var e=t[d];if(0==(t[oy+144>>2]|0)){c=3323}else{if(0!=(47==(l[e]<<24>>24|0)&1|0)){c=3323}else{var f;f=t[NaN>>2];var g,h;var i;if(0==(47==(l[e]<<24>>24|0)&1|0)){i=tb(0);var m=tb(e)+i|0,n=zC(m+1|0);AB(n,0);AB(n+i|0,e);l[n+m|0]=0;i=n}else{i=HI(e)}m=mA(i,47);c:for(;;){var q=m+1|0,p=m+2|0,n=m+3|0;if(0==(m|0)){break}for(;;){if(0==l[m]<<24>>24){break c}if(46!=l[q]<<24>>24){break}var s=l[p];if(46==s<<24>>24){h=2791;break}else{if(!(47==s<<24>>24||0==s<<24>>24)){break}}AB(m,p)}do{if(2791==h&&(h=0,p=l[n],47==p<<24>>24||0==p<<24>>24)){for(q=m;;){q=q-1|0;if(q>>>0<i>>>0){var r=m;break}if(0!=(47==(l[q]<<24>>24|0)&1|0)){r=q;break}}AB(r,n);m=r;continue c}}while(0);m=mA(q,47)}h=0!=l[i]<<24>>24?i:HI(dh|0);r=f;for(f=h;;){if(l[f]<<24>>24==l[r]<<24>>24){r=r+1|0,f=f+1|0}else{var u=r,v=f;break}}for(;;){if((v|0)==(h|0)){var w=h;g=2824;break}r=v-1|0;u=u-1|0;if(47==l[r]<<24>>24){var C=0,A=u;break}else{v=r}}if(2824!=g){for(;!(g=mA(A+1|0,47),0==(g|0));){C=C+1|0,A=g}g=zC(3*C+tb(v)+1|0);l[g]=0;w=0<(C|0);b:do{if(w){for(A=C;;){if(A=A-1|0,u=g+tb(g)|0,Fa=3092014,l[u]=Fa&255,Fa>>=8,l[u+1]=Fa&255,Fa>>=8,l[u+2]=Fa&255,Fa>>=8,l[u+3]=Fa&255,0>=(A|0)){break b}}}}while(0);C=tb(g);w=0;do{l[g+C+w]=l[v+w],w++}while(0!=l[v+(w-1)]);vB(h);w=g}f=w}}3323==c&&(f=HI(e));t[K+44>>2]=f;b=t[b>>2];b>>>0>t[NaN>>2]>>>0&&(t[NaN>>2]=b);b=t[oy+104>>2];b=0==(b|0)?0:-1!=(OI(b,KI(t[d]),186)|0)&1;t[K+52>>2]=b;d=II(t[d]);t[K+56>>2]=d}function T(){var b=t[K+28>>2];if(0!=(b|0)){t[K+28>>2]=0;var d;return b}for(var c=t[K+12>>2];;){if(0==(c|0)){b=lJ(),0==(b|0)?b=t[K+12>>2]:(b=t[b+8>>2],t[K+12>>2]=b),c=(0==(b|0))<<31>>31}else{b=c+1|0;t[K+12>>2]=b;var c=l[c],e=c&255;0!=c<<24>>24?c=e:(t[K+12>>2]=0,c=e,b=0)}if(0==(c|0)){c=b}else{d=c;break}}return d}function lJ(){var b,d=t[K+8>>2];0==(d|0)&&(d=P(),t[K+8>>2]=d);S(d);a:for(;;){for(var c,d=ba;;){c=XB(t[K+16>>2]);if(0==(t[K+36>>2]|0)|-1==(c|0)){var e=c;break}t[K+24>>2]=t[Ox>>2];t[K+36>>2]=0;t[K+20>>2]=t[K+20>>2]+1|0;t[K+48>>2]=t[K+48>>2]+1|0;if(!(35==(c|0)&0!=(t[oy+152>>2]|0))){e=c;break}if(0==(mJ()|0)){d=3399;break}}3399==d&&(oB(t[K+16>>2],Ox),e=XB(t[K+16>>2]));-1==(e|0)?(t[K+32>>2]=1,d=-1):10==(e|0)?(t[K+36>>2]=1,nB(t[K+16>>2],Ox),d=10):13==(e|0)?(d=XB(t[K+16>>2]),10==(d|0)?(t[K+36>>2]=1,nB(t[K+16>>2],Ox),d=10):(YB(d),d=13)):d=e;c=d;d=-1!=(c|0);do{if(d){var f=t[K+8>>2],g=t[f>>2];(g+1|0)==(t[f+4>>2]|0)&&(R(f),f=g=t[K+8>>2],g=t[g>>2]);l[t[f+8>>2]+g|0]=c&255;if(0!=(c|0)){if(f=t[K+8>>2]|0,g=t[f>>2]+1|0,t[f>>2]=g,l[t[t[K+8>>2]+8>>2]+g|0]=0,10==(c|0)){b=3357;break a}else{-1==(c|0)&&(b=3358)}}}else{b=3358}}while(0);if(3358==b&&(b=0,c=t[K+8>>2],f=t[c>>2],0!=(f|0))){var h=c,i=f;break}if(!d){var m=0;b=3367;break}}if(3357==b){h=i=t[K+8>>2],i=t[i>>2]}else{if(3367==b){return m}}(i+1|0)==(t[h+4>>2]|0)&&(R(h),h=i=t[K+8>>2],i=t[i>>2]);l[t[h+8>>2]+i|0]=0;h=t[K+8>>2];if(0==(t[h>>2]|0)){return h}b=t[K+56>>2];if(!(-2==(b|0)|(t[Zx>>2]|0)<(b|0))&&(e=t[Yx>>2],i=(b<<3)+e+4|0,0!=(t[i>>2]|0))){b=(b<<3)+e|0;for(e=0;;){c=h;d=t[b>>2]+28*e|0;m=j;j+=80;for(var n=c+8|0,f=m|0,g=TB(t[n>>2]),q=SB[t[d>>2]].exec(g),p=0;10>p;p++){var s=-1,r=-1;q&&p<q.length&&(s=g.indexOf(q[p]),r=s+q[p].length);t[f+8*p>>2]=s;t[f+(8*p+4)>>2]=r}if(0==((q?0:1)|0)){if(g=t[d+4>>2],1==(g|0)){g=j;j+=80;for(n=0;10>(n|0);){q=t[f+(n<<3)>>2];if(-1==(q|0)){break}t[g+(n<<3)>>2]=q;t[g+(n<<3)+4>>2]=t[f+(n<<3)+4>>2]-q|0;n=n+1|0}ab[t[d+8>>2]](t[c+8>>2],g|0,n);j=g}else{if(0==(g|0)){c=j;g=d+8|0;f=YI(t[n>>2],t[g>>2],f);q=n=ba;q=(f|0)>>2;for(n=(f+8|0)>>2;0!=(L(l[t[n]]<<24>>24)|0);){p=t[q];if(0==(p|0)){break}if(1<p>>>0){for(p=1;;){var u=t[n];l[u+(p-1)|0]=l[u+p|0];p=p+1|0;u=t[q];if(p>>>0>=u>>>0){break}}p=u-1|0}else{p=0}t[q]=p;l[t[n]+p|0]=0}DD(f);0==(t[f>>2]|0)?(d=t[t[K+40>>2]+8>>2],n=t[K+20>>2],g=t[g>>2],RI(2,St|0,(k=j,j+=12,t[k>>2]=d,t[k+4>>2]=n,t[k+8>>2]=g,k))):(g=f,d=d+12|0,n=j,j+=80,0!=(t[d>>2]|0)&&(sC(n,t[g+8>>2]),l[n+40|0]=l[d+4|0],t[n+36>>2]=t[d+8>>2],tC(n)),j=n);Q(f);j=c}}}j=m;e=e+1|0;if(e>>>0>=t[i>>2]>>>0){break}}}return m=t[K+8>>2]}lJ.X=1;function uE(b){for(;;){var d=T();if(-1==(d|0)|(d|0)==(b|0)){break}}}function eC(){var b=lJ();if(0==(b|0)){return 0}var d=t[b+8>>2],c;c=(b|0)>>2;b=t[b+8>>2]+(t[c]-1)|0;10==l[b]<<24>>24&&(l[b]=0,t[c]=t[c]-1|0);return d}function MI(b,d){var c,e=j;j+=4;var f;S(b);if(0==(d|0)){return RI(1,ck|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k)),j=e,0}c=(b+8|0)>>2;for(var g=b+4|0;;){var h=t[c]+(t[g>>2]-2)|0;nB(d,e);l[h]=0;var i;a:{i=t[c];var m=t[g>>2],n=d;if(JA[n]){var q=JA[n];if(q.error||q.c){i=0}else{for(var p=ba,s=0;s<m-1&&10!=p;s++){p=WB(n);if(-1==p){if(q.error){i=0;break a}if(q.c){break}}l[i+s]=p}l[i+s]=0}}else{i=0}}if(0==(i|0)){f=3380;break}h=l[h];if(0==h<<24>>24||10==h<<24>>24||13==h<<24>>24){break}R(b);oB(d,e)}if(3380==f){if(0!=(cB(d)|0)){return j=e,0}RI(5,si|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));j=e;return 0}t[b>>2]=tb(t[b+8>>2]);h=t[c];c=(b|0)>>2;m=t[c];f=h+(m-1)|0;g=l[f];if(13==g<<24>>24){return l[f]=10,j=e,i}h=h+(m-2)|0;if(!(13==l[h]<<24>>24&10==g<<24>>24)){return j=e,i}l[h]=10;l[f]=0;t[c]=t[c]-1|0;j=e;return i}MI.X=1;function mJ(){var b,d=j;j+=80;var c;b=d>>2;var e=nJ();if(10>(e-48|0)>>>0){YB(e),c=3419}else{if(108!=(e|0)){var f=0}else{105!=(XB(t[K+16>>2])|0)?f=0:110!=(XB(t[K+16>>2])|0)?f=0:101!=(XB(t[K+16>>2])|0)?f=0:(e=XB(t[K+16>>2]),32==(e|0)||9==(e|0)?c=3419:f=0)}}if(3419==c){var g;a:{c=0;for(f=nJ();;){if(-1==(f|0)){g=3434;break}e=f-48|0;if(10<=e>>>0){g=3437;break}c=e+10*c|0;f=XB(t[K+16>>2])}if(3437==g){if(YB(f),32==(f|0)||9==(f|0)){g=c;break a}}else{3434==g&&YB(-1)}g=0}if(0==(g|0)){f=0}else{c=oJ();f=c|0;if(0==(t[f>>2]|0)){t[K+48>>2]=g-1|0}else{e=c+8|0;if(-2==(II(t[e>>2])|0)){e=0}else{var e=t[e>>2],h=t[K+4>>2];if(0!=(47==(l[e]<<24>>24|0)&1|0)|0==(h|0)){e=BE(c)}else{var i=t[h+8>>2],m,h=P();m=47==(l[i+(tb(i)-1)|0]<<24>>24|0)&1;V(h,i);if(0==(m|0)){m=(h|0)>>2;var i=t[m],n=h+4|0;if((i+1|0)==(t[n>>2]|0)){R(h);var q=t[m]}else{q=i}i=(h+8|0)>>2;l[t[i]+q|0]=47;q=t[m]+1|0;t[m]=q;l[t[i]+q|0]=0;q=t[m];(q+1|0)==(t[n>>2]|0)?(R(h),m=t[m]):m=q;l[t[i]+m|0]=0}U(h,e);e=h}kJ(e);e=1}0!=(e|0)&&(t[K+48>>2]=g-1|0)}0!=(t[oy>>2]|0)&&0!=(t[f>>2]|0)&1==(g|0)&&(sC(d,kH(t[c+8>>2])),t[b+5]=1,t[b]=1,t[b+1]=1,t[b+9]=Ne|0,l[d+40|0]=70,tC(d));Q(c);f=1}}j=d;return f}mJ.X=1;function nJ(){for(;;){var b=XB(t[K+16>>2]);if(!(32==(b|0)||9==(b|0))){break}}return b}function oJ(){var b,d,c=P(),e=nJ(),f=34==(e|0);a:do{if(f){var g=c|0;b=g>>2;for(var h=c+4|0,i=c+8|0,m=XB(t[K+16>>2]);;){if(-1==(m|0)||34==(m|0)){var n=g,q=h,p=i;break a}else{if(10==(m|0)){var s=g,r=h,u=i;d=3457;break a}}var v=t[b];(v+1|0)==(t[h>>2]|0)&&(R(c),v=t[b]);l[t[i>>2]+v|0]=m&255;0!=(m|0)&&(m=t[b]+1|0,t[b]=m,l[t[i>>2]+m|0]=0);m=XB(t[K+16>>2])}}else{g=c|0;b=g>>2;h=c+4|0;i=c+8|0;for(m=e;;){if(-1==(m|0)||9==(m|0)||32==(m|0)){n=g;q=h;p=i;break a}else{if(10==(m|0)){s=g;r=h;u=i;d=3457;break a}}v=t[b];(v+1|0)==(t[h>>2]|0)&&(R(c),v=t[b]);l[t[i>>2]+v|0]=m&255;0!=(m|0)&&(m=t[b]+1|0,t[b]=m,l[t[i>>2]+m|0]=0);m=XB(t[K+16>>2])}}}while(0);3457==d&&(YB(10),n=s,q=r,p=u);d=t[n>>2];if((d+1|0)!=(t[q>>2]|0)){return p=t[p>>2],p=p+d|0,l[p]=0,c}R(c);n=t[n>>2];p=t[p>>2];p=p+n|0;l[p]=0;return c}oJ.X=1;function pJ(){if(!l[Hc]){l[Hc]=1;QI();var b=j,d=bH();t[ny>>2]=d;KC(st|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));var d=j,c=ZI(az|0);t[oy+104>>2]=c;if(0!=(t[oy+88>>2]|0)){mB(am|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));var e=t[oy+104>>2],c=j,f=e+4|0;if(0!=(t[f>>2]|0)){for(var e=e+8|0,g=0;;){var h=0!=(g|0)?Cr|0:hm|0,i=t[t[t[e>>2]+(g<<2)>>2]+8>>2];mB(cw|0,(k=j,j+=8,t[k>>2]=h,t[k+4>>2]=i,k));g=g+1|0;if(g>>>0>=t[f>>2]>>>0){break}}}j=c;qB(10,t[Ob>>2])}j=d;KC(Ss|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));d=j;if(0!=(t[Dy>>2]|0)){for(c=0;;){f=FI(c);KC(vi|0,(k=j,j+=4,t[k>>2]=f,k));f=c;e=j;h=t[t[Cy>>2]+(f<<2)>>2];i=h+44|0;g=t[i>>2];0!=(g|0)&&fH(g);var g=h+48|0,m=t[g>>2];0!=(m|0)&&fH(m);m=t[h+16>>2];m=0==(m|0)?bH():ZI(m);t[i>>2]=m;h=t[h+12>>2];h=0==(h|0)?bH():ZI(h);t[g>>2]=h;0!=(t[oy+88>>2]|0)&&PI(f);KC(Jq|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));j=e;c=c+1|0;if(c>>>0>=t[Dy>>2]>>>0){break}}}j=d;KC(xs|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));SI(fs|0);SI(Lr|0);SI(mr|0);SI(Xq|0);SI(Kq|0);SI(wq|0);SI(jq|0);SI(Rp|0);SI(Bp|0);SI(mp|0);SI($o|0);SI(Ko|0);SI(ro|0);SI(ho|0);SI(Zn|0);SI(On|0);SI(zn|0);SI(on|0);SI(dn|0);j=b}}function qJ(b){pJ();return FI(II(b))}a._getLanguage=qJ;function rJ(b){var d=j,c=t[oy+128>>2],c=-1==(c|0)?II(b):c;if(-2==(c|0)){KC(gs|0,(k=j,j+=4,t[k>>2]=b,k))}else{if(0==(t[t[t[Cy>>2]+(c<<2)>>2]+40>>2]|0)){KC(Mr|0,(k=j,j+=4,t[k>>2]=b,k))}else{0!=(t[oy+136>>2]|0)&&ba();var e=j;j+=4;var f=t[NaN>>2];nB(t[NaN>>2],e);var g=0,h=0;a:for(;;){var i=g,g=h;b:for(;;){for(;;){var m=g+1|0;var h=b,n=c,g=m,q;var p=h,s=n;q=j;var r=t[K+16>>2];0!=(r|0)&&(uB(r),t[K+16>>2]=0);r=tB(p,Ns|0);t[K+16>>2]=r;if(0==(r|0)){RI(6,Xv|0,(k=j,j+=4,t[k>>2]=p,k)),p=0}else{var r=kH(p),u=t[K>>2];0!=(u|0)&&Q(u);u=PD(p);t[K>>2]=u;u=t[K+4>>2];0!=(u|0)&&Q(u);(r|0)==(p|0)?t[K+4>>2]=0:(u=P(),t[K+4>>2]=u,r=r+(p^-1)|0,S(u),gD(u,p,r));nB(t[K+16>>2],Ox);nB(t[K+16>>2],K+24|0);t[K+12>>2]=0;t[K+20>>2]=0;t[K+32>>2]=0;t[K+36>>2]=1;r=t[K+8>>2];0!=(r|0)&&S(r);kJ(PD(p));t[K+48>>2]=0;s=FI(s);r=0!=(t[K+52>>2]|0)?yo|0:hm|0;KC(wr|0,(k=j,j+=12,t[k>>2]=p,t[k+4>>2]=s,t[k+8>>2]=r,k));p=1}j=q;q=p;0==(q|0)?g=0:(n=t[t[Cy>>2]+(n<<2)>>2],0!=(t[oy+72>>2]|0)&&ba(),q=ba,p=j,j+=80,q=p>>2,0!=(t[oy>>2]|0)&&(sC(p,kH(h)),t[q+5]=1,t[q]=1,t[q+1]=1,t[q+9]=Ne|0,l[p+40|0]=70,tC(p)),j=p,h=t[n+24>>2],0==(h|0)?(h=t[n+28>>2],g=0==(h|0)?0:ab[h](g)):(ab[h](),g=0),0!=(t[oy+72>>2]|0)&&ba(t[K+44>>2]),h=t[K+16>>2],0!=(h|0)&&(0!=(t[oy+148>>2]|0)&&(LI(t[t[K>>2]+8>>2]),h=t[K+16>>2]),uB(h),t[K+16>>2]=0));if(0==(g|0)){break a}else{if(2==(g|0)){break b}else{if(1==(g|0)){break}else{g=m}}}}oB(t[NaN>>2],e);t[NaN>>2]=f;i=1;g=m}nB(t[NaN>>2],e);g=i;h=m;f=t[NaN>>2]}j=e;0!=(t[oy+136>>2]|0)&&ba(i)}}j=d;RB&&RB(Na(b))}function sJ(b){var d=j;pJ();if(4294967293<II(b)>>>0){mB(Ks|0,(k=j,j+=4,t[k>>2]=b,k))}else{var c=tB(b,Wv|0);if(0==(c|0)){var c=Na(b),e=Na(b),f=e.lastIndexOf("/");VA(e.substr(0,f),e.substr(f+1),c,ca,ca,(function(){ab[38](b)}),(function(){ab[82](b)}))}else{uB(c),rJ(b)}}j=d}a._parseURL=sJ;function tC(b){var b=b>>2,d=t[b+9],c=t[b+1],e=t[b+7],f=t[b+3];QB&&QB(Na(t[b+8]),Na(d),c,Na(e),Na(f))}function sC(b,d){for(var c=b>>2,e=b>>2,f=e+20;e<f;e++){t[e]=0}t[c]=1==(t[oy+76>>2]|0)&1;t[c+1]=t[K+48>>2];t[c+3]=FI(t[K+56>>2]);t[c+2]=t[K+24>>2];t[c+7]=t[K+44>>2];t[c+8]=d}function Xa(b){do{if(245>b>>>0){var d=11>b>>>0?16:b+11&-8,c=d>>>3,e=t[D>>2],f=e>>>(c>>>0);if(0!=(f&3|0)){var g=(f&1^1)+c|0,h=g<<1,d=(h<<2)+D+40|0,c=(h+2<<2)+D+40|0,b=t[c>>2],h=b+8|0,f=t[h>>2];(d|0)==(f|0)?t[D>>2]=e&(1<<g^-1):f>>>0<t[D+16>>2]>>>0?O():(t[c>>2]=f,t[f+12>>2]=d);g<<=3;t[b+4>>2]=g|3;g=b+(g|4)|0;t[g>>2]|=1;return h}if(d>>>0>t[D+8>>2]>>>0){if(0==(f|0)){if(0==(t[D+4>>2]|0)){e=d;break}h=tJ(d);if(0==(h|0)){e=d;break}return h}var b=2<<c,b=f<<c&(b|-b),c=(b&-b)-1|0,b=c>>>12&16,f=c>>>(b>>>0),c=f>>>5&8,i=f>>>(c>>>0),f=i>>>2&4,m=i>>>(f>>>0),i=m>>>1&2,m=m>>>(i>>>0),n=m>>>1&1,f=(c|b|f|i|n)+(m>>>(n>>>0))|0,b=f<<1,i=(b<<2)+D+40|0,m=(b+2<<2)+D+40|0,c=t[m>>2],b=c+8|0,n=t[b>>2];(i|0)==(n|0)?t[D>>2]=e&(1<<f^-1):n>>>0<t[D+16>>2]>>>0?O():(t[m>>2]=n,t[n+12>>2]=i);f<<=3;e=f-d|0;t[c+4>>2]=d|3;i=c;c=i+d|0;t[i+(d|4)>>2]=e|1;t[i+f>>2]=e;n=t[D+8>>2];0!=(n|0)&&(d=t[D+20>>2],i=n>>>2&1073741822,f=(i<<2)+D+40|0,m=t[D>>2],n=1<<(n>>>3),0==(m&n|0)?(t[D>>2]=m|n,h=f,g=(i+2<<2)+D+40|0):(i=(i+2<<2)+D+40|0,m=t[i>>2],m>>>0<t[D+16>>2]>>>0?O():(h=m,g=i)),t[g>>2]=d,t[h+12>>2]=d,t[d+8>>2]=h,t[d+12>>2]=f);t[D+8>>2]=e;t[D+20>>2]=c;return h=b}e=d}else{if(4294967231<b>>>0){e=-1}else{if(e=b+11&-8,0!=(t[D+4>>2]|0)&&(d=uJ(e),0!=(d|0))){return h=d}}}}while(0);g=t[D+8>>2];e>>>0>g>>>0?(h=t[D+12>>2],e>>>0<h>>>0?(h=h-e|0,t[D+12>>2]=h,g=t[D+24>>2],t[D+24>>2]=g+e|0,t[e+(g+4)>>2]=h|1,t[g+4>>2]=e|3,h=g+8|0):h=vJ(e)):(d=g-e|0,h=t[D+20>>2],15<d>>>0?(t[D+20>>2]=h+e|0,t[D+8>>2]=d,t[e+(h+4)>>2]=d|1,t[h+g>>2]=d,t[h+4>>2]=e|3):(t[D+8>>2]=0,t[D+20>>2]=0,t[h+4>>2]=g|3,g=g+(h+4)|0,t[g>>2]|=1),h=h+8|0);return h}Xa.X=1;function tJ(b){var d,c,e=t[D+4>>2],f=(e&-e)-1|0,e=f>>>12&16,g=f>>>(e>>>0),f=g>>>5&8;c=g>>>(f>>>0);var g=c>>>2&4,h=c>>>(g>>>0);c=h>>>1&2;var h=h>>>(c>>>0),i=h>>>1&1,e=g=f=t[D+((f|e|g|c|i)+(h>>>(i>>>0))<<2)+304>>2];c=e>>2;for(f=(t[f+4>>2]&-8)-b|0;;){h=t[g+16>>2];if(0==(h|0)){if(g=t[g+20>>2],0==(g|0)){break}else{c=g}}else{c=h}h=(t[c+4>>2]&-8)-b|0;i=h>>>0<f>>>0;g=c;e=i?c:e;c=e>>2;f=i?h:f}var h=e,m=t[D+16>>2];h>>>0<m>>>0&&O();g=h+b|0;h>>>0<g>>>0||O();var i=t[c+6],n=t[c+3],q=(n|0)==(e|0);a:do{if(q){var p=e+20|0,s=t[p>>2];do{if(0==(s|0)){var r=e+16|0,u=t[r>>2];if(0==(u|0)){var v=0;d=v>>2;break a}}else{r=p,u=s}}while(0);for(;;){if(p=u+20|0,s=t[p>>2],0!=(s|0)){r=p,u=s}else{if(p=u+16|0,s=t[p>>2],0==(s|0)){break}else{r=p,u=s}}}r>>>0<m>>>0?O():(t[r>>2]=0,v=u,d=v>>2)}else{r=t[c+2],r>>>0<m>>>0?O():(t[r+12>>2]=n,t[n+8>>2]=r,v=n,d=v>>2)}}while(0);m=0==(i|0);a:do{if(!m){n=e+28|0;q=(t[n>>2]<<2)+D+304|0;do{if((e|0)==(t[q>>2]|0)){if(t[q>>2]=v,0==(v|0)){t[D+4>>2]&=1<<t[n>>2]^-1;break a}}else{if(i>>>0<t[D+16>>2]>>>0&&O(),r=i+16|0,(t[r>>2]|0)==(e|0)?t[r>>2]=v:t[i+20>>2]=v,0==(v|0)){break a}}}while(0);v>>>0<t[D+16>>2]>>>0&&O();t[d+6]=i;n=t[c+4];0!=(n|0)&&(n>>>0<t[D+16>>2]>>>0?O():(t[d+4]=n,t[n+24>>2]=v));n=t[c+5];0!=(n|0)&&(n>>>0<t[D+16>>2]>>>0?O():(t[d+5]=n,t[n+24>>2]=v))}}while(0);if(16>f>>>0){var w=f+b|0;t[c+1]=w|3;w=w+(h+4)|0;t[w>>2]|=1;return w=e+8|0}t[c+1]=b|3;t[b+(h+4)>>2]=f|1;t[h+f+b>>2]=f;h=t[D+8>>2];if(0!=(h|0)){b=t[D+20>>2];v=h>>>2&1073741822;d=(v<<2)+D+40|0;c=t[D>>2];h=1<<(h>>>3);if(0==(c&h|0)){t[D>>2]=c|h;var w=d,C=(v+2<<2)+D+40|0}else{v=(v+2<<2)+D+40|0,c=t[v>>2],c>>>0<t[D+16>>2]>>>0?O():(w=c,C=v)}t[C>>2]=b;t[w+12>>2]=b;t[b+8>>2]=w;t[b+12>>2]=d}t[D+8>>2]=f;t[D+20>>2]=g;return w=e+8|0}tJ.X=1;function vJ(b){var d,c;0==(t[zc>>2]|0)&&wJ();var e=0==(t[D+440>>2]&4|0);a:do{if(e){var f=t[D+24>>2];if(0==(f|0)){c=3592}else{if(f=xJ(f),0==(f|0)){c=3592}else{var g=t[zc+8>>2],g=b+47-t[D+12>>2]+g&-g;if(2147483647>g>>>0){c=$B(g);var h=(c|0)==(t[f>>2]+t[f+4>>2]|0);d=h?c:-1;var h=h?g:0,i=g,m=c;c=3599}else{var n=0}}}if(3592==c){if(f=$B(0),-1==(f|0)){n=0}else{var g=t[zc+8>>2],g=g+(b+47)&-g,q=f,p=t[zc+4>>2],s=p-1|0,g=0==(s&q|0)?g:g-q+(s+q&-p)|0;2147483647>g>>>0?(c=$B(g),d=(h=(c|0)==(f|0))?f:-1,h=h?g:0,i=g,m=c,c=3599):n=0}}b:do{if(3599==c){c=-i|0;if(-1!=(d|0)){var r=h,u=d;c=3612;break a}do{if(-1!=(m|0)&2147483647>i>>>0){if(i>>>0<(b+48|0)>>>0){if(n=t[zc+8>>2],n=b+47-i+n&-n,2147483647>n>>>0){if(-1==($B(n)|0)){$B(c);n=h;break b}else{n=n+i|0}}else{n=i}}else{n=i}}else{n=i}}while(0);if(-1!=(m|0)){r=n;u=m;c=3612;break a}t[D+440>>2]|=4;var v=h;c=3609;break a}}while(0);t[D+440>>2]|=4;v=n}else{v=0}c=3609}while(0);3609==c&&(e=t[zc+8>>2],e=e+(b+47)&-e,2147483647>e>>>0&&(e=$B(e),d=$B(0),-1!=(d|0)&-1!=(e|0)&e>>>0<d>>>0&&(d=d-e|0,e=(h=d>>>0>(b+40|0)>>>0)?e:-1,-1!=(e|0)&&(r=h?d:v,u=e,c=3612))));do{if(3612==c){v=t[D+432>>2]+r|0;t[D+432>>2]=v;v>>>0>t[D+436>>2]>>>0&&(t[D+436>>2]=v);v=t[D+24>>2];e=0==(v|0);a:do{if(e){d=t[D+16>>2];0==(d|0)|u>>>0<d>>>0&&(t[D+16>>2]=u);t[D+444>>2]=u;t[D+448>>2]=r;t[D+456>>2]=0;t[D+36>>2]=t[zc>>2];t[D+32>>2]=-1;for(d=0;!(h=d<<1,i=(h<<2)+D+40|0,t[D+(h+3<<2)+40>>2]=i,t[D+(h+2<<2)+40>>2]=i,d=d+1|0,32==(d|0));){}yJ(u,r-40|0)}else{h=D+444|0;for(d=h>>2;0!=(h|0);){var w=t[d],C=h+4|0,A=t[C>>2];if((u|0)==(w+A|0)){c=3621;break}h=t[d+2];d=h>>2}do{if(3621==c&&0==(t[d+3]&8|0)&&(h=v,h>>>0>=w>>>0&h>>>0<u>>>0)){t[C>>2]=A+r|0;yJ(t[D+24>>2],t[D+12>>2]+r|0);break a}}while(0);u>>>0<t[D+16>>2]>>>0&&(t[D+16>>2]=u);d=u+r|0;for(h=D+444|0;0!=(h|0);){var I=h|0;if((t[I>>2]|0)==(d|0)){c=3630;break}h=t[h+8>>2]}if(3630==c&&0==(t[h+12>>2]&8|0)){return t[I>>2]=u,w=h+4|0,t[w>>2]=t[w>>2]+r|0,b=zJ(u,d,b)}AJ(u,r)}}while(0);v=t[D+12>>2];if(v>>>0>b>>>0){return r=v-b|0,t[D+12>>2]=r,w=u=t[D+24>>2],t[D+24>>2]=w+b|0,t[b+(w+4)>>2]=r|1,t[u+4>>2]=b|3,b=u+8|0}}}while(0);t[GA>>2]=12;return 0}vJ.X=1;function uJ(b){var d,c,e,f,g,h=b>>2,i,m=-b|0,n=b>>>8;if(0==(n|0)){var q=0}else{if(16777215<b>>>0){q=31}else{var p=(n+1048320|0)>>>16&8,s=n<<p,r=(s+520192|0)>>>16&4,u=s<<r,v=(u+245760|0)>>>16&2,w=14-(r|p|v)+(u<<v>>>15)|0,q=b>>>((w+7|0)>>>0)&1|w<<1}}var C=t[D+(q<<2)+304>>2],A=0==(C|0);a:do{if(A){var I=0,M=m,B=0}else{var G=31==(q|0)?0:25-(q>>>1)|0,Z=0,X=m,ga=C;g=ga>>2;for(var ra=b<<G,ka=0;;){var ia=t[g+1]&-8,ea=ia-b|0;if(ea>>>0<X>>>0){if((ia|0)==(b|0)){I=ga;M=ea;B=ga;break a}else{var wb=ga,sb=ea}}else{wb=Z,sb=X}var Db=t[g+5],Za=t[((ra>>>31<<2)+16>>2)+g],kc=0==(Db|0)|(Db|0)==(Za|0)?ka:Db;if(0==(Za|0)){I=wb;M=sb;B=kc;break a}else{Z=wb,X=sb,ga=Za,g=ga>>2,ra<<=1,ka=kc}}}}while(0);if(0==(B|0)&0==(I|0)){var $c=2<<q,Ia=t[D+4>>2]&($c|-$c);if(0==(Ia|0)){var Eb=0;return Eb}var Pb=(Ia&-Ia)-1|0,He=Pb>>>12&16,Hd=Pb>>>(He>>>0),de=Hd>>>5&8,ee=Hd>>>(de>>>0),Id=ee>>>2&4,Jd=ee>>>(Id>>>0),uc=Jd>>>1&2,Kd=Jd>>>(uc>>>0),Qb=Kd>>>1&1,Mc=t[D+((de|He|Id|uc|Qb)+(Kd>>>(Qb>>>0))<<2)+304>>2]}else{Mc=B}var ad=0==(Mc|0);a:do{if(ad){var bb=M,Qa=I;f=Qa>>2}else{var Rb=Mc;e=Rb>>2;for(var vc=M,Sb=I;;){var fe=(t[e+1]&-8)-b|0,vd=fe>>>0<vc>>>0,lc=vd?fe:vc,Nc=vd?Rb:Sb,ge=t[e+4];if(0!=(ge|0)){Rb=ge,e=Rb>>2,vc=lc,Sb=Nc}else{var he=t[e+5];if(0==(he|0)){bb=lc;Qa=Nc;f=Qa>>2;break a}else{Rb=he,e=Rb>>2,vc=lc,Sb=Nc}}}}}while(0);if(0==(Qa|0)||bb>>>0>=(t[D+8>>2]-b|0)>>>0){return Eb=0}var Tb=Qa;c=Tb>>2;var Ub=t[D+16>>2];Tb>>>0<Ub>>>0&&O();var bd=Tb+b|0;Tb>>>0<bd>>>0||O();var cd=t[f+6],ac=t[f+3],ie=(ac|0)==(Qa|0);a:do{if(ie){var Ld=Qa+20|0,gb=t[Ld>>2];do{if(0==(gb|0)){var dd=Qa+16|0,Vb=t[dd>>2];if(0==(Vb|0)){var Sa=0;d=Sa>>2;break a}else{var Oc=dd,Pc=Vb}}else{Oc=Ld,Pc=gb}}while(0);for(;;){var Md=Pc+20|0,ed=t[Md>>2];if(0!=(ed|0)){Oc=Md,Pc=ed}else{var je=Pc+16|0,ke=t[je>>2];if(0==(ke|0)){break}else{Oc=je,Pc=ke}}}Oc>>>0<Ub>>>0?O():(t[Oc>>2]=0,Sa=Pc,d=Sa>>2)}else{var wd=t[f+2];wd>>>0<Ub>>>0?O():(t[wd+12>>2]=ac,t[ac+8>>2]=wd,Sa=ac,d=Sa>>2)}}while(0);var xd=0==(cd|0);a:do{if(xd){var ob=Qa}else{var Fb=Qa+28|0,fd=(t[Fb>>2]<<2)+D+304|0;do{if((Qa|0)==(t[fd>>2]|0)){if(t[fd>>2]=Sa,0==(Sa|0)){t[D+4>>2]&=1<<t[Fb>>2]^-1;ob=Qa;break a}}else{cd>>>0<t[D+16>>2]>>>0&&O();var le=cd+16|0;(t[le>>2]|0)==(Qa|0)?t[le>>2]=Sa:t[cd+20>>2]=Sa;if(0==(Sa|0)){ob=Qa;break a}}}while(0);Sa>>>0<t[D+16>>2]>>>0&&O();t[d+6]=cd;var gd=t[f+4];0!=(gd|0)&&(gd>>>0<t[D+16>>2]>>>0?O():(t[d+4]=gd,t[gd+24>>2]=Sa));var yd=t[f+5];0==(yd|0)?ob=Qa:yd>>>0<t[D+16>>2]>>>0?O():(t[d+5]=yd,t[yd+24>>2]=Sa,ob=Qa)}}while(0);do{if(16>bb>>>0){var Nd=bb+b|0;t[ob+4>>2]=Nd|3;var Od=Nd+(Tb+4)|0;t[Od>>2]|=1}else{if(t[ob+4>>2]=b|3,t[h+(c+1)]=bb|1,t[(bb>>2)+c+h]=bb,256>bb>>>0){var wc=bb>>>2&1073741822,xc=(wc<<2)+D+40|0,hd=t[D>>2],Pd=1<<(bb>>>3);if(0==(hd&Pd|0)){t[D>>2]=hd|Pd;var bc=xc,me=(wc+2<<2)+D+40|0}else{var Qd=(wc+2<<2)+D+40|0,ne=t[Qd>>2];ne>>>0<t[D+16>>2]>>>0?O():(bc=ne,me=Qd)}t[me>>2]=bd;t[bc+12>>2]=bd;t[h+(c+2)]=bc;t[h+(c+3)]=xc}else{var cc=bd,id=bb>>>8;if(0==(id|0)){var yb=0}else{if(16777215<bb>>>0){yb=31}else{var Rd=(id+1048320|0)>>>16&8,oe=id<<Rd,jd=(oe+520192|0)>>>16&4,Qc=oe<<jd,mc=(Qc+245760|0)>>>16&2,pe=14-(jd|Rd|mc)+(Qc<<mc>>>15)|0,yb=bb>>>((pe+7|0)>>>0)&1|pe<<1}}var Rc=(yb<<2)+D+304|0;t[h+(c+7)]=yb;t[h+(c+5)]=0;t[h+(c+4)]=0;var kd=t[D+4>>2],nc=1<<yb;if(0==(kd&nc|0)){t[D+4>>2]=kd|nc,t[Rc>>2]=cc,t[h+(c+6)]=Rc,t[h+(c+3)]=cc,t[h+(c+2)]=cc}else{for(var Sd=bb<<(31==(yb|0)?0:25-(yb>>>1)|0),Sc=t[Rc>>2];(t[Sc+4>>2]&-8|0)!=(bb|0);){var Td=(Sd>>>31<<2)+Sc+16|0,qe=t[Td>>2];if(0==(qe|0)){i=3709;break}else{Sd<<=1,Sc=qe}}if(3709==i){if(Td>>>0<t[D+16>>2]>>>0){O()}else{t[Td>>2]=cc;t[h+(c+6)]=Sc;t[h+(c+3)]=cc;t[h+(c+2)]=cc;break}}var hf=Sc+8|0,jf=t[hf>>2],Ag=t[D+16>>2];Sc>>>0<Ag>>>0&&O();jf>>>0<Ag>>>0?O():(t[jf+12>>2]=cc,t[hf>>2]=cc,t[h+(c+2)]=jf,t[h+(c+3)]=Sc,t[h+(c+6)]=0)}}}}while(0);return Eb=ob+8|0}uJ.X=1;function BJ(){var b;0==(t[zc>>2]|0)&&wJ();b=t[D+24>>2];if(0!=(b|0)){var d=t[D+12>>2];if(40<d>>>0){var c=t[zc+8>>2],e=(Math.floor(((d-41+c|0)>>>0)/(c>>>0))-1)*c|0,f=xJ(b);if(0==(t[f+12>>2]&8|0)&&(d=$B(0),b=(f+4|0)>>2,(d|0)==(t[f>>2]+t[b]|0)&&(e=$B(-(2147483646<e>>>0?-2147483648-c|0:e)|0),c=$B(0),-1!=(e|0)&c>>>0<d>>>0&&(e=d-c|0,(d|0)!=(c|0))))){t[b]=t[b]-e|0;t[D+432>>2]=t[D+432>>2]-e|0;yJ(t[D+24>>2],t[D+12>>2]-e|0);return}}t[D+12>>2]>>>0>t[D+28>>2]>>>0&&(t[D+28>>2]=-1)}}BJ.X=1;function vB(b){var d,c,e,f,g,h,i,m=b>>2,n;if(0!=(b|0)){var q=b-8|0,p=t[D+16>>2];q>>>0<p>>>0&&O();var s=t[b-4>>2],r=s&3;1==(r|0)&&O();var u=s&-8;i=u>>2;var v=b+(u-8)|0,w=0==(s&1|0);a:do{if(w){var C=t[q>>2];if(0==(r|0)){return}var A=-8-C|0;h=A>>2;var I=b+A|0,M=I,B=C+u|0;I>>>0<p>>>0&&O();if((M|0)==(t[D+20>>2]|0)){g=(b+(u-4)|0)>>2;if(3!=(t[g]&3|0)){var G=M;f=G>>2;var Z=B;break}t[D+8>>2]=B;t[g]&=-2;t[h+(m+1)]=B|1;t[v>>2]=B;return}var X=C>>>3;if(256>C>>>0){var ga=t[h+(m+2)],ra=t[h+(m+3)];if((ga|0)==(ra|0)){t[D>>2]&=1<<X^-1;G=M;f=G>>2;Z=B;break}var ka=((C>>>2&1073741822)<<2)+D+40|0;(ga|0)!=(ka|0)&ga>>>0<p>>>0&&O();if((ra|0)==(ka|0)|ra>>>0>=p>>>0){t[ga+12>>2]=ra;t[ra+8>>2]=ga;G=M;f=G>>2;Z=B;break}else{O()}}var ia=I,ea=t[h+(m+6)],wb=t[h+(m+3)],sb=(wb|0)==(ia|0);b:do{if(sb){var Db=A+(b+20)|0,Za=t[Db>>2];do{if(0==(Za|0)){var kc=A+(b+16)|0,$c=t[kc>>2];if(0==($c|0)){var Ia=0;e=Ia>>2;break b}else{var Eb=kc,Pb=$c}}else{Eb=Db,Pb=Za}}while(0);for(;;){var He=Pb+20|0,Hd=t[He>>2];if(0!=(Hd|0)){Eb=He,Pb=Hd}else{var de=Pb+16|0,ee=t[de>>2];if(0==(ee|0)){break}else{Eb=de,Pb=ee}}}Eb>>>0<p>>>0?O():(t[Eb>>2]=0,Ia=Pb,e=Ia>>2)}else{var Id=t[h+(m+2)];Id>>>0<p>>>0?O():(t[Id+12>>2]=wb,t[wb+8>>2]=Id,Ia=wb,e=Ia>>2)}}while(0);if(0==(ea|0)){G=M,f=G>>2,Z=B}else{var Jd=A+(b+28)|0,uc=(t[Jd>>2]<<2)+D+304|0;do{if((ia|0)==(t[uc>>2]|0)){if(t[uc>>2]=Ia,0==(Ia|0)){t[D+4>>2]&=1<<t[Jd>>2]^-1;G=M;f=G>>2;Z=B;break a}}else{ea>>>0<t[D+16>>2]>>>0&&O();var Kd=ea+16|0;(t[Kd>>2]|0)==(ia|0)?t[Kd>>2]=Ia:t[ea+20>>2]=Ia;if(0==(Ia|0)){G=M;f=G>>2;Z=B;break a}}}while(0);Ia>>>0<t[D+16>>2]>>>0&&O();t[e+6]=ea;var Qb=t[h+(m+4)];0!=(Qb|0)&&(Qb>>>0<t[D+16>>2]>>>0?O():(t[e+4]=Qb,t[Qb+24>>2]=Ia));var Mc=t[h+(m+5)];0==(Mc|0)?(G=M,f=G>>2,Z=B):Mc>>>0<t[D+16>>2]>>>0?O():(t[e+5]=Mc,t[Mc+24>>2]=Ia,G=M,f=G>>2,Z=B)}}else{G=q,f=G>>2,Z=u}}while(0);var ad=G;c=ad>>2;ad>>>0<v>>>0||O();var bb=b+(u-4)|0,Qa=t[bb>>2];0==(Qa&1|0)&&O();do{if(0==(Qa&2|0)){if((v|0)==(t[D+24>>2]|0)){var Rb=t[D+12>>2]+Z|0;t[D+12>>2]=Rb;t[D+24>>2]=G;t[f+1]=Rb|1;(G|0)==(t[D+20>>2]|0)&&(t[D+20>>2]=0,t[D+8>>2]=0);if(Rb>>>0<=t[D+28>>2]>>>0){return}BJ();return}if((v|0)==(t[D+20>>2]|0)){var vc=t[D+8>>2]+Z|0;t[D+8>>2]=vc;t[D+20>>2]=G;t[f+1]=vc|1;t[(vc>>2)+c]=vc;return}var Sb=(Qa&-8)+Z|0,fe=Qa>>>3,vd=256>Qa>>>0;a:do{if(vd){var lc=t[m+i],Nc=t[((u|4)>>2)+m];if((lc|0)==(Nc|0)){t[D>>2]&=1<<fe^-1}else{var ge=((Qa>>>2&1073741822)<<2)+D+40|0;(lc|0)!=(ge|0)&&lc>>>0<t[D+16>>2]>>>0&&O();(Nc|0)!=(ge|0)&&Nc>>>0<t[D+16>>2]>>>0&&O();t[lc+12>>2]=Nc;t[Nc+8>>2]=lc}}else{var he=v,Tb=t[i+(m+4)],Ub=t[((u|4)>>2)+m],bd=(Ub|0)==(he|0);b:do{if(bd){var cd=u+(b+12)|0,ac=t[cd>>2];do{if(0==(ac|0)){var ie=u+(b+8)|0,Ld=t[ie>>2];if(0==(Ld|0)){var gb=0;d=gb>>2;break b}else{var dd=ie,Vb=Ld}}else{dd=cd,Vb=ac}}while(0);for(;;){var Sa=Vb+20|0,Oc=t[Sa>>2];if(0!=(Oc|0)){dd=Sa,Vb=Oc}else{var Pc=Vb+16|0,Md=t[Pc>>2];if(0==(Md|0)){break}else{dd=Pc,Vb=Md}}}dd>>>0<t[D+16>>2]>>>0?O():(t[dd>>2]=0,gb=Vb,d=gb>>2)}else{var ed=t[m+i];ed>>>0<t[D+16>>2]>>>0?O():(t[ed+12>>2]=Ub,t[Ub+8>>2]=ed,gb=Ub,d=gb>>2)}}while(0);if(0!=(Tb|0)){var je=u+(b+20)|0,ke=(t[je>>2]<<2)+D+304|0;do{if((he|0)==(t[ke>>2]|0)){if(t[ke>>2]=gb,0==(gb|0)){t[D+4>>2]&=1<<t[je>>2]^-1;break a}}else{Tb>>>0<t[D+16>>2]>>>0&&O();var wd=Tb+16|0;(t[wd>>2]|0)==(he|0)?t[wd>>2]=gb:t[Tb+20>>2]=gb;if(0==(gb|0)){break a}}}while(0);gb>>>0<t[D+16>>2]>>>0&&O();t[d+6]=Tb;var xd=t[i+(m+2)];0!=(xd|0)&&(xd>>>0<t[D+16>>2]>>>0?O():(t[d+4]=xd,t[xd+24>>2]=gb));var ob=t[i+(m+3)];0!=(ob|0)&&(ob>>>0<t[D+16>>2]>>>0?O():(t[d+5]=ob,t[ob+24>>2]=gb))}}}while(0);t[f+1]=Sb|1;t[(Sb>>2)+c]=Sb;if((G|0)!=(t[D+20>>2]|0)){var Fb=Sb}else{t[D+8>>2]=Sb;return}}else{t[bb>>2]=Qa&-2,t[f+1]=Z|1,Fb=t[(Z>>2)+c]=Z}}while(0);if(256>Fb>>>0){var fd=Fb>>>2&1073741822,le=(fd<<2)+D+40|0,gd=t[D>>2],yd=1<<(Fb>>>3);if(0==(gd&yd|0)){t[D>>2]=gd|yd;var Nd=le,Od=(fd+2<<2)+D+40|0}else{var wc=(fd+2<<2)+D+40|0,xc=t[wc>>2];xc>>>0<t[D+16>>2]>>>0?O():(Nd=xc,Od=wc)}t[Od>>2]=G;t[Nd+12>>2]=G;t[f+2]=Nd;t[f+3]=le}else{var hd=G,Pd=Fb>>>8;if(0==(Pd|0)){var bc=0}else{if(16777215<Fb>>>0){bc=31}else{var me=(Pd+1048320|0)>>>16&8,Qd=Pd<<me,ne=(Qd+520192|0)>>>16&4,cc=Qd<<ne,id=(cc+245760|0)>>>16&2,yb=14-(ne|me|id)+(cc<<id>>>15)|0,bc=Fb>>>((yb+7|0)>>>0)&1|yb<<1}}var Rd=(bc<<2)+D+304|0;t[f+7]=bc;t[f+5]=0;t[f+4]=0;var oe=t[D+4>>2],jd=1<<bc;do{if(0==(oe&jd|0)){t[D+4>>2]=oe|jd,t[Rd>>2]=hd,t[f+6]=Rd,t[f+3]=G,t[f+2]=G}else{for(var Qc=Fb<<(31==(bc|0)?0:25-(bc>>>1)|0),mc=t[Rd>>2];(t[mc+4>>2]&-8|0)!=(Fb|0);){var pe=(Qc>>>31<<2)+mc+16|0,Rc=t[pe>>2];if(0==(Rc|0)){n=3862;break}else{Qc<<=1,mc=Rc}}if(3862==n){if(pe>>>0<t[D+16>>2]>>>0){O()}else{t[pe>>2]=hd;t[f+6]=mc;t[f+3]=G;t[f+2]=G;break}}var kd=mc+8|0,nc=t[kd>>2],Sd=t[D+16>>2];mc>>>0<Sd>>>0&&O();nc>>>0<Sd>>>0?O():(t[nc+12>>2]=hd,t[kd>>2]=hd,t[f+2]=nc,t[f+3]=mc,t[f+6]=0)}}while(0);var Sc=t[D+32>>2]-1|0;t[D+32>>2]=Sc;if(0==(Sc|0)){for(var Td=D+452|0;;){var qe=t[Td>>2];if(0==(qe|0)){break}else{Td=qe+8|0}}t[D+32>>2]=-1}}}}vB.X=1;function xJ(b){var d,c,e=D+444|0;for(d=e>>2;;){var f=t[d];if(f>>>0<=b>>>0&&(f+t[d+1]|0)>>>0>b>>>0){var g=e;c=3904;break}d=t[d+2];if(0==(d|0)){g=0;c=3905;break}else{e=d,d=e>>2}}if(3904==c||3905==c){return g}}function yJ(b,d){var c=b+8|0,c=0==(c&7|0)?0:-c&7,e=d-c|0;t[D+24>>2]=b+c|0;t[D+12>>2]=e;t[c+(b+4)>>2]=e|1;t[d+(b+4)>>2]=40;t[D+28>>2]=t[zc+16>>2]}function TI(b,d){var c,e,f;if(4294967231<d>>>0){return t[GA>>2]=12,0}var g=b-8|0;e=(b-4|0)>>2;var h=t[e],i=h&-8,m=i-8|0,n=b+m|0;g>>>0<t[D+16>>2]>>>0&&O();var q=h&3;1!=(q|0)&-8<(m|0)||O();c=(b+(i-4)|0)>>2;0==(t[c]&1|0)&&O();m=11>d>>>0?16:d+11&-8;if(0==(q|0)){var p=0,s,h=t[g+4>>2]&-8;s=256>m>>>0?0:h>>>0>=(m+4|0)>>>0&&(h-m|0)>>>0<=t[zc+8>>2]<<1>>>0?g:0;f=3939}else{i>>>0<m>>>0?(n|0)==(t[D+24>>2]|0)&&(c=t[D+12>>2]+i|0,c>>>0>m>>>0&&(p=c-m|0,t[e]=m|h&1|2,t[b+(m-4)>>2]=p|1,t[D+24>>2]=b+(m-8)|0,t[D+12>>2]=p,p=0,s=g,f=3939)):(p=i-m|0,15<p>>>0?(t[e]=m|h&1|2,t[b+(m-4)>>2]=p|3,t[c]|=1,p=b+m|0):p=0,s=g,f=3939)}if(3939==f&&0!=(s|0)){return 0!=(p|0)&&vB(p),s+8|0}g=Xa(d);if(0==(g|0)){return 0}e=i-(0==(t[e]&3|0)?8:4)|0;hB(g,b,e>>>0<d>>>0?e:d);vB(b);return g}TI.X=1;function wJ(){if(0==(t[zc>>2]|0)){var b=ZB();0!=(b-1&b|0)&&O();t[zc+8>>2]=b;t[zc+4>>2]=b;t[zc+12>>2]=-1;t[zc+16>>2]=2097152;t[zc+20>>2]=0;t[D+440>>2]=0;b=Math.floor(Date.now()/1e3);t[zc>>2]=b&-16^1431655768}}function zJ(b,d,c){var e,f,g,h=d>>2,i=b>>2,m,n=b+8|0,n=0==(n&7|0)?0:-n&7;f=d+8|0;var q=0==(f&7|0)?0:-f&7;g=q>>2;var p=d+q|0,s=n+c|0;f=s>>2;var s=b+s|0,r=p-(b+n)-c|0;t[(n+4>>2)+i]=c|3;if((p|0)==(t[D+24>>2]|0)){return m=t[D+12>>2]+r|0,t[D+12>>2]=m,t[D+24>>2]=s,t[f+(i+1)]=m|1,b=b+(n|8)|0}if((p|0)==(t[D+20>>2]|0)){return m=t[D+8>>2]+r|0,t[D+8>>2]=m,t[D+20>>2]=s,t[f+(i+1)]=m|1,t[(m>>2)+i+f]=m,b=b+(n|8)|0}var u=t[g+(h+1)];if(1==(u&3|0)){var c=u&-8,v=u>>>3,w=256>u>>>0;a:do{if(w){var C=t[((q|8)>>2)+h],A=t[g+(h+3)];if((C|0)==(A|0)){t[D>>2]&=1<<v^-1}else{var I=((u>>>2&1073741822)<<2)+D+40|0;(C|0)!=(I|0)&&C>>>0<t[D+16>>2]>>>0&&O();(A|0)!=(I|0)&&A>>>0<t[D+16>>2]>>>0&&O();t[C+12>>2]=A;t[A+8>>2]=C}}else{var C=p,A=t[((q|24)>>2)+h],I=t[g+(h+3)],M=(I|0)==(C|0);b:do{if(M){var B=q|16,G=B+(d+4)|0,Z=t[G>>2];do{if(0==(Z|0)){var X=d+B|0,ga=t[X>>2];if(0==(ga|0)){var ra=0;e=ra>>2;break b}}else{X=G,ga=Z}}while(0);for(;;){if(B=ga+20|0,G=t[B>>2],0!=(G|0)){X=B,ga=G}else{if(B=ga+16|0,G=t[B>>2],0==(G|0)){break}else{X=B,ga=G}}}X>>>0<t[D+16>>2]>>>0?O():(t[X>>2]=0,ra=ga,e=ra>>2)}else{X=t[((q|8)>>2)+h],X>>>0<t[D+16>>2]>>>0?O():(t[X+12>>2]=I,t[I+8>>2]=X,ra=I,e=ra>>2)}}while(0);if(0!=(A|0)){I=q+(d+28)|0;M=(t[I>>2]<<2)+D+304|0;do{if((C|0)==(t[M>>2]|0)){if(t[M>>2]=ra,0==(ra|0)){t[D+4>>2]&=1<<t[I>>2]^-1;break a}}else{if(A>>>0<t[D+16>>2]>>>0&&O(),X=A+16|0,(t[X>>2]|0)==(C|0)?t[X>>2]=ra:t[A+20>>2]=ra,0==(ra|0)){break a}}}while(0);ra>>>0<t[D+16>>2]>>>0&&O();t[e+6]=A;C=q|16;A=t[(C>>2)+h];0!=(A|0)&&(A>>>0<t[D+16>>2]>>>0?O():(t[e+4]=A,t[A+24>>2]=ra));C=t[(C+4>>2)+h];0!=(C|0)&&(C>>>0<t[D+16>>2]>>>0?O():(t[e+5]=C,t[C+24>>2]=ra))}}}while(0);e=d+(c|q)|0;d=c+r|0}else{e=p,d=r}e=e+4|0;t[e>>2]&=-2;t[f+(i+1)]=d|1;t[(d>>2)+i+f]=d;if(256>d>>>0){var ka=d>>>2&1073741822;m=(ka<<2)+D+40|0;e=t[D>>2];d=1<<(d>>>3);if(0==(e&d|0)){t[D>>2]=e|d;var ia=m,ea=(ka+2<<2)+D+40|0}else{ka=(ka+2<<2)+D+40|0,d=t[ka>>2],d>>>0<t[D+16>>2]>>>0?O():(ia=d,ea=ka)}t[ea>>2]=s;t[ia+12>>2]=s;t[f+(i+2)]=ia;t[f+(i+3)]=m;return b=b+(n|8)|0}ea=d>>>8;0==(ea|0)?ea=0:16777215<d>>>0?ea=31:(ia=(ea+1048320|0)>>>16&8,e=ea<<ia,ea=(e+520192|0)>>>16&4,e<<=ea,h=(e+245760|0)>>>16&2,ia=14-(ea|ia|h)+(e<<h>>>15)|0,ea=d>>>((ia+7|0)>>>0)&1|ia<<1);ia=(ea<<2)+D+304|0;t[f+(i+7)]=ea;t[f+(i+5)]=0;t[f+(i+4)]=0;e=t[D+4>>2];h=1<<ea;if(0==(e&h|0)){return t[D+4>>2]=e|h,t[ia>>2]=s,t[f+(i+6)]=ia,t[f+(i+3)]=s,t[f+(i+2)]=s,b=b+(n|8)|0}ea=d<<(31==(ea|0)?0:25-(ea>>>1)|0);for(ia=t[ia>>2];(t[ia+4>>2]&-8|0)!=(d|0);){if(ka=(ea>>>31<<2)+ia+16|0,e=t[ka>>2],0==(e|0)){m=4026;break}else{ea<<=1,ia=e}}if(4026==m){return ka>>>0<t[D+16>>2]>>>0&&O(),t[ka>>2]=s,t[f+(i+6)]=ia,t[f+(i+3)]=s,t[f+(i+2)]=s,b=b+(n|8)|0}m=ia+8|0;ka=t[m>>2];ea=t[D+16>>2];ia>>>0<ea>>>0&&O();ka>>>0<ea>>>0&&O();t[ka+12>>2]=s;t[m>>2]=s;t[f+(i+2)]=ka;t[f+(i+3)]=ia;t[f+(i+6)]=0;return b=b+(n|8)|0}zJ.X=1;function AJ(b,d){var c,e,f,g=t[D+24>>2];e=g>>2;var h=xJ(g),i=t[h>>2];c=t[h+4>>2];var h=i+c|0,m=i+(c-39)|0,i=i+(c-47)+(0==(m&7|0)?0:-m&7)|0,i=i>>>0<(g+16|0)>>>0?g:i,m=i+8|0;c=m>>2;yJ(b,d-40|0);t[i+4>>2]=27;t[c]=t[D+444>>2];t[c+1]=t[D+448>>2];t[c+2]=t[D+452>>2];t[c+3]=t[D+456>>2];t[D+444>>2]=b;t[D+448>>2]=d;t[D+456>>2]=0;t[D+452>>2]=m;c=i+28|0;t[c>>2]=7;m=(i+32|0)>>>0<h>>>0;a:do{if(m){for(var n=c;;){var q=n+4|0;t[q>>2]=7;if((n+8|0)>>>0<h>>>0){n=q}else{break a}}}}while(0);if((i|0)!=(g|0)){if(h=i-g|0,i=h+(g+4)|0,t[i>>2]&=-2,t[e+1]=h|1,t[g+h>>2]=h,256>h>>>0){var p=h>>>2&1073741822;f=(p<<2)+D+40|0;i=t[D>>2];h=1<<(h>>>3);if(0==(i&h|0)){t[D>>2]=i|h;var s=f,r=(p+2<<2)+D+40|0}else{p=(p+2<<2)+D+40|0,h=t[p>>2],h>>>0<t[D+16>>2]>>>0?O():(s=h,r=p)}t[r>>2]=g;t[s+12>>2]=g;t[e+2]=s;t[e+3]=f}else{if(r=h>>>8,0==(r|0)?r=0:16777215<h>>>0?r=31:(s=(r+1048320|0)>>>16&8,i=r<<s,r=(i+520192|0)>>>16&4,i<<=r,c=(i+245760|0)>>>16&2,s=14-(r|s|c)+(i<<c>>>15)|0,r=h>>>((s+7|0)>>>0)&1|s<<1),s=(r<<2)+D+304|0,t[e+7]=r,t[e+5]=0,t[e+4]=0,i=t[D+4>>2],c=1<<r,0==(i&c|0)){t[D+4>>2]=i|c,t[s>>2]=g,t[e+6]=s,t[e+3]=g,t[e+2]=g}else{r=h<<(31==(r|0)?0:25-(r>>>1)|0);for(s=t[s>>2];(t[s+4>>2]&-8|0)!=(h|0);){if(p=(r>>>31<<2)+s+16|0,i=t[p>>2],0==(i|0)){f=4065;break}else{r<<=1,s=i}}4065==f?(p>>>0<t[D+16>>2]>>>0&&O(),t[p>>2]=g,t[e+6]=s,t[e+3]=g,t[e+2]=g):(f=s+8|0,p=t[f>>2],r=t[D+16>>2],s>>>0<r>>>0&&O(),p>>>0<r>>>0&&O(),t[p+12>>2]=g,t[f>>2]=g,t[e+2]=p,t[e+3]=s,t[e+6]=0)}}}}AJ.X=1;var fB=da;a.H=(function(b){function d(){for(var b=0;3>b;b++){e.push(0)}}var c=b.length+1,e=[y(lb("/bin/this.program"),"i8",x)];d();for(var f=0;f<c-1;f+=1){e.push(y(lb(b[f]),"i8",x)),d()}e.push(0);e=y(e,"i32",x);return _main(c,e,0)});ab=[0,0,(function(b){UI(b,Fr|0,Fo|0,mm|0,0)}),0,(function(b){t[Fy>>2]=b;for(var d=0;!(vC(t[Fx+(d<<3)>>2],b,t[Fx+(d<<3)+4>>2]),d=d+1|0,26==(d|0));){}}),0,(function(){var b,d=GI(hn|0);b=d>>2;t[b+3]=gy|0;t[b+5]=272;t[b+8]=1;return d}),0,JG,0,(function(b){t[Hy>>2]=b;for(b=0;!(vC(t[F+(b<<3)>>2],t[Hy>>2],t[F+(b<<3)+4>>2]),b=b+1|0,73==(b|0));){}}),0,CG,0,(function(b){t[Ty>>2]=b;t[Gc+132>>2]=1;t[Gc+144>>2]=1;t[Gc+148>>2]=1;t[Gc+152>>2]=1;t[Gc+168>>2]=1;t[Gc+172>>2]=1;t[Gc+180>>2]=1;t[Gc+184>>2]=1;t[Gc+188>>2]=1;t[Gc+232>>2]=1;t[Gc+240>>2]=1;t[Gc+244>>2]=1;t[Gc+248>>2]=1;t[Gc+252>>2]=1;t[Gc+256>>2]=1;t[Gc+376>>2]=1;t[Gc+504>>2]=1;t[Gc+496>>2]=1;for(b=0;!(vC(t[sy+(b<<3)>>2],t[Ty>>2],t[sy+(b<<3)+4>>2]),b=b+1|0,42==(b|0));){}}),0,(function(b,d){0==(d|0)?(t[z>>2]=260,t[rd>>2]=16):26==(d|0)?(iG(t[t[Mb>>2]+8>>2],7),S(t[Mb>>2]),t[rd>>2]=16,t[z>>2]=250,hG(0,26)):22==(d|0)?V(t[Mb>>2],t[b+8>>2]):34==(d|0)?t[z>>2]=150:5==(d|0)?t[z>>2]=62:3==(d|0)?t[z>>2]=174:4==(d|0)?t[z>>2]=124:28==(d|0)?(t[rd>>2]=16,t[z>>2]=250,hG(0,28)):1==(d|0)&&(t[z>>2]=198,t[rd>>2]=16)}),0,(function(b,d){31==(d|0)?(nG(b,7),l[Kb]=1,t[Ib>>2]=43,t[rd>>2]=18,t[z>>2]=208):37==(d|0)&&(zG(),t[z>>2]=122)}),0,(function(b,d){8==(d|0)||29==(d|0)?(t[z>>2]=114,t[Ib>>2]=3,t[rd>>2]=20):14==(d|0)?oG(0,14):13==(d|0)||27==(d|0)?t[z>>2]=188:19==(d|0)?(S(t[Ec>>2]),BG(0,2,12,0),l[yc]=0,t[z>>2]=122):25==(d|0)?(t[z>>2]=20,BG(1,4,160,b)):10==(d|0)?t[z>>2]=160:(t[z>>2]=12,CG(0,d))}),0,(function(){var b=j;j+=8;var d=P(),c=P();t[rc>>2]=c;c=P();t[Mb>>2]=c;c=P();t[Wc>>2]=c;c=P();t[ec>>2]=c;c=b|0;t[c>>2]=P();t[b+4>>2]=eC();t[z>>2]=16;var e=cG(b),f=38==(e|0);a:do{if(!f){for(var g=e;;){if(ab[t[z>>2]](t[c>>2],g),g=cG(b),38==(g|0)){break a}}}}while(0);Q(d);Q(t[rc>>2]);Q(t[Mb>>2]);Q(t[Wc>>2]);Q(t[ec>>2]);t[rc>>2]=0;t[Mb>>2]=0;t[ec>>2]=0;t[Wc>>2]=0;j=b}),0,(function(b,d){34==(d|0)?(t[z>>2]=114,t[Ib>>2]=35,t[rd>>2]=24):31==(d|0)&&(nG(b,0),V(t[Ec>>2],t[b+8>>2]),t[z>>2]=104,t[Ib>>2]=40,t[rd>>2]=268)}),0,jG,0,(function(){var b,d=GI(Vl|0);b=d>>2;t[b+1]=Az|0;t[b+2]=4;t[b+3]=zz|0;t[b+6]=286;return d}),0,(function(){var b,d=GI(yh|0);b=d>>2;t[b+1]=Xx|0;t[b+2]=1;t[b+3]=Wx|0;t[b+6]=190;return d}),0,(function(){var b,d=GI(xq|0);b=d>>2;t[b+3]=$y|0;t[b+5]=164;t[b+8]=1;return d}),0,(function(){var b,d=GI(nu|0);b=d>>2;t[b+3]=Xy|0;t[b+1]=Vy|0;t[b+2]=5;t[b+6]=202;t[b+5]=288;return d}),0,(function(b){t[Qy>>2]=b;uC(b,1)}),0,rJ,0,(function(){var b,d=GI(ei|0);b=d>>2;t[b+1]=iz|0;t[b+2]=14;t[b+3]=hz|0;t[b+7]=162;t[b+5]=216;return d}),0,(function(){var b,d=GI(uu|0);b=d>>2;t[b+1]=Jz|0;t[b+2]=13;t[b+3]=Iz|0;t[b+7]=142;t[b+5]=254;return d}),0,(function(b){t[Gy>>2]=b;uC(b,4)}),0,(function(b,d){26==(d|0)?(t[z>>2]=48,t[rd>>2]=46,t[Ib>>2]=27):32==(d|0)?(iG(t[t[Mb>>2]+8>>2],8),S(t[Mb>>2])):22==(d|0)&&V(t[Mb>>2],t[b+8>>2])}),0,(function(b,d){(t[Ib>>2]|0)==(d|0)&&(t[z>>2]=t[rd>>2])}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=qH(),f=(k=Da++,d[k]=1,Ea[k]=b,t[xz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:for(var g=e,h=g|0,i=g+4|0;!($(g),1==(t[h>>2]|0)?sH(g):uH(g),5==(t[i>>2]|0));){}b=3;break;case 4:rH(e);return;default:ua(0,"bad label: "+b)}}catch(m){(!m.f||!(m.id in d))&&aa(m),c[Ea[m.id]](m.value)}}}),0,(function(){var b,d=GI(zh|0);b=d>>2;t[b+1]=ay|0;t[b+2]=2;t[b+3]=$x|0;t[b+6]=224;return d}),0,(function(){var b,d=GI(um|0);b=d>>2;t[b+1]=Nx|0;t[b+2]=3;t[b+3]=Mx|0;t[b+6]=94;return d}),0,(function(){var b,d=GI(bl|0);b=d>>2;t[b+1]=iy|0;t[b+2]=6;t[b+3]=hy|0;t[b+6]=8;return d}),0,(function(){var b,d=GI(Op|0);b=d>>2;t[b+3]=jy|0;t[b+1]=ky|0;t[b+2]=2;t[b+6]=232;return d}),0,(function(b){UI(b,ls|0,Fo|0,Jm|0,0);UI(b,Bk|0,Fo|0,Pi|0,0)}),0,(function(b,d){if(22==(d|0)){var c=b+8|0;aG(t[c>>2],2);iG(t[c>>2],2)}t[z>>2]=74}),0,(function(b){t[Ry>>2]=b;uC(b,0)}),0,(function(b,d){return 0==(qA(b,t[d+8>>2])|0)&1}),0,(function(b,d){31==(d|0)&&(nG(b,2),V(t[Dc>>2],t[b+8>>2]),t[Ib>>2]=40,t[rd>>2]=280,t[z>>2]=104)}),0,nC,0,(function(){var b,d=GI(cr|0);b=d>>2;t[b+1]=nz|0;t[b+2]=5;t[b+3]=mz|0;t[b+6]=276;return d}),0,(function(b,d){24==(d|0)?(t[z>>2]=284,t[Ac>>2]=4):9==(d|0)?t[z>>2]=46:25==(d|0)?(t[z>>2]=284,t[Ac>>2]=3):10==(d|0)?(bG(),t[z>>2]=16):28==(d|0)&&(t[z>>2]=256)}),0,(function(){var b,d=GI(jm|0);b=d>>2;t[b+3]=Pz|0;t[b+5]=78;t[b+8]=1;return d}),0,(function(b){UI(b,ek|0,Fo|0,bh|0,Ti|0);UI(b,Oe|0,Fo|0,hx|0,Ti|0);UI(b,uw|0,Fo|0,Kv|0,Ti|0);UI(b,mv|0,Fo|0,Pu|0,Ti|0);UI(b,pu|0,Fo|0,Rt|0,Ti|0);UI(b,rt|0,Fo|0,Ps|0,Ti|0)}),0,(function(){var b,d=GI(ut|0);b=d>>2;t[b+1]=Zy|0;t[b+2]=8;t[b+3]=Yy|0;t[b+7]=142;t[b+5]=266;return d}),0,(function(){}),0,(function(){var b=j;j+=8;for(var d=P(),c=0;;){var e=P();t[Yb+(c<<4)+12>>2]=e;c=c+1|0;if(256==(c|0)){break}}t[Xb>>2]=0;mG();c=P();t[Nb>>2]=c;c=P();t[Dc>>2]=c;c=P();t[Ec>>2]=c;c=P();t[Jb>>2]=c;V(c,fr|0);c=b|0;t[c>>2]=P();t[b+4>>2]=eC();t[z>>2]=122;var e=rG(b),f=48==(e|0);a:do{if(!f){for(var g=e;;){if(ab[t[z>>2]](t[c>>2],g),g=rG(b),48==(g|0)){break a}}}}while(0);Q(d);Q(t[Jb>>2]);Q(t[Nb>>2]);Q(t[Dc>>2]);Q(t[Ec>>2]);for(d=0;!(Q(t[Yb+(d<<4)+12>>2]),d=d+1|0,256==(d|0));){}j=b}),0,(function(b,d){38==(d|0)?(t[rd>>2]=86,t[z>>2]=228):32==(d|0)?(t[rd>>2]=86,t[Ib>>2]=33,t[z>>2]=114):31==(d|0)?(nG(b,4),BG(0,0,122,b),l[yc]=1,t[Ib>>2]=40,t[rd>>2]=168,t[z>>2]=154):oG(0,d)}),0,(function(b,d){32==(d|0)||18==(d|0)||28==(d|0)||21==(d|0)||(31==(d|0)?(nG(b,1),BG(0,5,122,b),t[z>>2]=110):6==(d|0)?zG():t[z>>2]=122)}),0,(function(){var b,d=GI($t|0);b=d>>2;t[b+1]=zy|0;t[b+2]=1;t[b+3]=yy|0;t[b+6]=140;return d}),0,(function(b){t[Ey>>2]=b;for(var d=0;!(vC(t[E+(d<<3)>>2],b,t[E+(d<<3)+4>>2]),d=d+1|0,95==(d|0));){}}),0,VH,0,(function(){var b,d=GI(ep|0);b=d>>2;t[b+1]=Sx|0;t[b+2]=7;t[b+3]=Rx|0;t[b+6]=158;return d}),0,(function(){var b,d=GI(vs|0);b=d>>2;t[b+1]=Xz|0;t[b+2]=4;t[b+3]=Wz|0;t[b+6]=148;return d}),0,(function(b){t[Uy>>2]=b;for(b=0;!(vC(t[sc+(b<<3)>>2],t[Uy>>2],t[sc+(b<<3)+4>>2]),b=b+1|0,21==(b|0));){}}),0,dC,0,FG,0,(function(){var b,d=GI(Xh|0);b=d>>2;t[b+1]=By|0;t[b+2]=1;t[b+3]=Ay|0;t[b+6]=180;return d}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=12;h=c}),g:0};;){try{switch(b){case 2:var e,f,g=P();e=1;f=0;var h=(k=Da++,d[k]=1,Ea[k]=b,t[vz>>2]=k,0);b=12;break;case 12:b=0==(h|0)?3:11;break;case 3:b=-1==(f|0)?11:4;break;case 4:var i=f=iI();b=32==(i|0)||9==(i|0)?5:59==(i|0)||10==(i|0)?6:7;break;case 5:b=-1==(f|0)?11:4;break;case 6:e=1;b=5;break;case 7:b=0==(e|0)?10:8;break;case 8:b=0==(gI(g,f)|0)?10:9;break;case 9:a:{var i=g,m=ba,n=i+8|0,q=mC(t[n>>2],t[Fy>>2]);if(0==(q|0)){m=1967}else{if(-1==(q|0)){break a}}do{if(1967==m&&96==l[t[n>>2]]<<24>>24){gI(i,jI(iI()));for(jC(i,Ex|0,0);10!=(iI()|0);){}fI(10);break a}}while(0);var p=jI(iI()),s=40==(p|0)?kI(40,41):p,r=jI(s),u=91==(r|0)?kI(91,93):r,v=jI(u);if(35==(v|0)){var w=iI(),C=40!=(w|0)?w:kI(40,41)}else{C=v}var A=jI(C);if(0!=(hI(A)|0)){var i=q,n=A,m=ba,I=P();b:for(;;){if(0==(hI(n)|0)){var M=n,m=2007;break}gI(I,n);jC(I,Ex|0,i);var B=jI(iI()),G=91==(B|0)?kI(91,93):B,Z=jI(G),X=61==(Z|0);c:do{if(X){if(123==(jI(iI())|0)){m=2001;break b}for(;;){var ga=iI();if(59==(ga|0)||44==(ga|0)){var ra=ga;break c}}}else{ra=Z}}while(0);if(44!=(ra|0)){M=ra;m=2008;break}n=jI(iI())}2001==m?(kI(123,125),M=123,Q(I),fI(M)):2007==m?(Q(I),fI(M)):2008==m&&(Q(I),fI(M))}}b=10;break;case 10:e=0;b=5;break;case 11:Q(g);return;default:ua(0,"bad label: "+b)}}catch(ka){(!ka.f||!(ka.id in d))&&aa(ka),c[Ea[ka.id]](ka.value)}}}),0,yG,0,(function(){var b,d=GI(Mv|0);b=d>>2;t[b+1]=Cz|0;t[b+2]=3;t[b+3]=Bz|0;t[b+6]=130;t[b+5]=176;return d}),0,(function(b,d){(t[Ib>>2]|0)==(d|0)?t[z>>2]=t[rd>>2]:6==(d|0)&&(zG(),t[z>>2]=122)}),0,(function(b){t[My>>2]=b;vC(Gi|0,b,0);vC(Yv|0,b,1);vC(El|0,b,2);vC(wf|0,b,3);vC(Wj|0,b,4);vC(Mg|0,b,5);vC(uq|0,b,6);vC(cq|0,b,7);vC(ys|0,b,8);vC(kw|0,b,9)}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;h=c}),g:0};;){try{switch(b){case 2:var e=cE(),f=bH();t[Rz>>2]=f;var g=bH();t[fz>>2]=g;var h=(k=Da++,d[k]=1,Ea[k]=b,t[sz>>2]=k,0);b=5;break;case 5:b=0==(h|0)?3:4;break;case 3:var i=e,m=ba,m=(i|0)>>2,n=i+4|0;a:for(;;){Y(i);var q=t[m];if(22==(q|0)){Y(i);if(24==(t[m]|0)){for(Y(i);;){var p=24==(t[m]|0);Y(i);if(p){continue a}}}if(-1==(t[n>>2]|0)&&(Y(i),23!=(t[m]|0))){for(;;){if(Y(i),23==(t[m]|0)){continue a}}}}else{19==(q|0)?eE(i):fE(i)}};case 4:fH(t[Rz>>2]);fH(t[fz>>2]);t[Rz>>2]=0;t[fz>>2]=0;dE(e);return;default:ua(0,"bad label: "+b)}}catch(s){(!s.f||!(s.id in d))&&aa(s),c[Ea[s.id]](s.value)}}}),0,oC,0,oG,0,(function(b,d){if(22==(d|0)){var c=b+8|0;iG(t[c>>2],0);aG(t[c>>2],0)}t[z>>2]=74}),0,LG,0,(function(b,d){31==(d|0)?nG(b,8):oG(0,d);t[z>>2]=122}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=ED(),f=(k=Da++,d[k]=1,Ea[k]=b,t[tz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:FD(e,7);var g=e,h=ba;GD(g);var i=g|0,m=t[i>>2];if(11==(m|0)){var n=g,q=j;j+=80;var p=n+12|0;0!=(t[Cz>>2]|0)&&(sC(q,t[t[p>>2]+8>>2]),t[q+36>>2]=t[Cz+8>>2],l[q+40|0]=t[Cz+4>>2]&255,tC(q));V(t[n+16>>2],t[t[p>>2]+8>>2]);j=q;GD(g);h=1608}else{var s=m}for(;;){1608==h&&(s=t[i>>2]);if(15==(s|0)){ID(g)}else{if(12==(s|0)){var r=t[g+4>>2];if(31==(r|0)){if(n=g,p=q=ba,GD(n),q=(n|0)>>2,11==(t[q]|0)){for(var u=n+4|0;;){JD(n);var v=t[q];if(12==(v|0)){var w=t[u>>2];if(45==(w|0)){for(var C=n,A=C|0,I=C+4|0;!(GD(C),0!=(LD(C)|0)&&(GD(C),3==(t[I>>2]|0)&&(GD(C),0!=(LD(C)|0)&&(MD(C),GD(C)))),7!=(t[A>>2]|0));){}p=1635}else{if(18==(w|0)){GD(n)}else{if(21==(w|0)||55==(w|0)||44==(w|0)||50==(w|0)){p=1635}}}1635==p&&(p=0,FD(n,18),GD(n));var M=t[q]}else{M=v}if(20==(M|0)){GD(n);var B=t[q]}else{B=M}if(11!=(B|0)){break}}}}else{if(24==(r|0)){for(var n=g,q=ba,q=(n+4|0)>>2,G=t[q];;){if(24==(G|0)){p=n;u=ba;u=(p+8|0)>>2;t[u]=1;GD(p);C=p|0;if(14==(t[C>>2]|0)){t[u]=0;for(A=14;;){if(11==(A|0)){var Z;if(11!=(t[p>>2]|0)){var X=0,ga=X&1}else{X=0==(sA(t[t[p+12>>2]+8>>2],qu|0,Aa)|0),ga=X&1}Z=ga;t[u]|=0==(Z|0)&1}else{if(3==(A|0)){break}}GD(p);A=t[C>>2]}GD(p)}var ra=t[q]}else{ra=G}!(24==(ra|0)||33==(ra|0)||29==(ra|0))&&0==(KD(n)|0)&&GD(n);var ka=t[q];if(18==(ka|0)||33==(ka|0)||29==(ka|0)){break}else{G=ka}}}else{GD(g)}}}else{GD(g)}}if(18==(t[g+4>>2]|0)){break}else{h=1608}}b=3;break;case 4:HD(e);return;default:ua(0,"bad label: "+b)}}catch(ia){(!ia.f||!(ia.id in d))&&aa(ia),c[Ea[ia.id]](ia.value)}}}),0,(function(){for(;0!=(eC()|0);){}}),0,qJ,0,(function(){var b,d=GI(Cu|0);b=d>>2;t[b+1]=dz|0;t[b+2]=5;t[b+3]=cz|0;t[b+6]=230;t[b+5]=116;return d}),0,(function(){var b,d=GI(iq|0);b=d>>2;t[b+1]=uy|0;t[b+2]=13;t[b+3]=ty|0;t[b+6]=22;t[b+5]=100;return d}),0,(function(){var b=P(),d=eC();if(0!=(d|0)){for(;;){for(var c=ba,e=d;;){var f=e+1|0;if(0==(L(l[e]&255)|0)){break}else{e=f}}e=l[e];if(45==e<<24>>24){if(45==l[f]<<24>>24){var g=0}else{c=3733}}else{0==e<<24>>24?g=0:c=3733}3733==c&&(g=1);0!=(g|0)&&(c=tA(d,Cf|0),0!=(c|0)&&(e=mA(d,61),0==(e|0)?(d=c+9|0,TF(d,mA(d,40),b)):TF(d,e,b)));d=eC();if(0==(d|0)){break}}}Q(b)}),0,(function(b){var d=j,c;c=2;for(var e={},f={2:(function(b){c=7;n=b}),g:0};;){try{switch(c){case 2:var g=(t[Py>>2]|0)==(t[K+56>>2]|0)&1;t[Vz>>2]=1<b>>>0&1;t[Lz>>2]=0;t[Lz+4>>2]=0;t[Lz+8>>2]=0;t[Lz+12>>2]=g;t[Lz+16>>2]=0;t[Lz+20>>2]=1;t[Lz+28>>2]=0;t[Lz+32>>2]=0;t[Lz+36>>2]=0;t[Lz+40>>2]=0;t[Lz+44>>2]=0;var h=t[Lz+24>>2];if(0==(h|0)){var i=P();t[Lz+24>>2]=i}else{S(h)}var m=P();t[Vx>>2]=m;var n=(k=Da++,e[k]=1,Ea[k]=c,t[yz>>2]=k,0);c=7;break;case 7:c=0==(n|0)?3:4;break;case 3:yC(0,0);var q=0;c=6;break;case 4:if(0!=(t[Fz>>2]|0)){for(;!(wC(),0==(t[Fz>>2]|0));){}}3==(n|0)&1==(b|0)?c=5:(q=0,c=6);break;case 5:var p=t[(t[K+40>>2]+8|0)>>2];KC(ku|0,(k=j,j+=4,t[k>>2]=p,k));q=1;c=6;break;case 6:Q(t[Vx>>2]);var s=t[Lz+24>>2];0!=(s|0)&&(Q(s),t[Lz+24>>2]=0);j=d;return q;default:ua(0,"bad label: "+c)}}catch(r){(!r.f||!(r.id in e))&&aa(r),f[Ea[r.id]](r.value)}}}),0,(function(b,d){if(31==(d|0)){l[md]||(l[md]=1,0==(t[ic>>2]|0)&&(t[z>>2]=110))}else{if(33==(d|0)){var c=t[ic>>2]-1|0;t[ic>>2]=c;0==(c|0)&&(t[z>>2]=110)}else{32==(d|0)&&(t[ic>>2]=t[ic>>2]+1|0)}}}),0,(function(){var b,d=GI(ej|0);b=d>>2;t[b+1]=fy|0;t[b+2]=5;t[b+3]=ey|0;t[b+6]=126;return d}),0,qC,0,(function(b,d){t[z>>2]=22!=(d|0)?304:0==(qA(t[b+8>>2],zr|0)|0)?298:304}),0,(function(){var b,d=GI(Pr|0);b=d>>2;t[b+1]=Hx|0;t[b+2]=13;t[b+3]=Gx|0;t[b+7]=142;t[b+5]=44;return d}),0,(function(b,d){(t[Ib>>2]|0)==(d|0)?t[z>>2]=t[rd>>2]:oG(0,d)}),0,(function(){var b=KI(t[t[K>>2]+8>>2]),d=0==(qA(b,eq|0)|0)?sd|0:0==(qA(b,wn|0)|0)?dc|0:Xc|0,c=eC();if(0!=(c|0)){for(;;){if(0!=(L(l[c]<<24>>24)|0)){c=c+1|0}else{do{if(0!=l[c]<<24>>24){for(var e=d;0!=(t[e>>2]|0);){var f;f=c;for(var g=e,h=ba,i=g|0,m=0,n=t[i>>2];m>>>0<tb(n)>>>0;){if(n=t[i>>2],(rA(l[f+m|0]<<24>>24)|0)==(l[n+m|0]<<24>>24|0)){m=m+1|0}else{var q=0,h=341;break}}if(341!=h){q=P();h=g+8|0;i=0<(t[h>>2]+1|0);b:do{if(i){for(var n=0,p=f+m|0;;){if(p=pC(p,q),n=n+1|0,(n|0)>=(t[h>>2]+1|0)){break b}}}}while(0);jC(q,Zz|0,t[g+4>>2]);Q(q);q=1}f=q;if(0==(f|0)){e=e+12|0}else{break}}if(0==(qA(b,eq|0)|0)){e=c,46==l[e]<<24>>24&&(f=P(),pC(e+1|0,f),jC(f,Zz|0,2),Q(f))}else{e=c;for(f=e+(tb(e)-1)|0;0!=(L(l[f]<<24>>24)|0);){f=f-1|0}58==l[f]<<24>>24&&(g=P(),gD(g,e,f-e|0),jC(g,Zz|0,2),Q(g))}}}while(0);c=eC();if(0==(c|0)){break}}}}}),0,lH,0,(function(b,d){34==(d|0)?t[Bc>>2]=t[Bc>>2]+1|0:12==(d|0)?GG():14==(d|0)?(GG(),oG(0,14)):45==(d|0)&&(EG(160),t[z>>2]=20)}),0,(function(b){var d=j,c;c=2;for(var e={},f={2:(function(b){c=7;i=b}),g:0};;){try{switch(c){case 2:var g=CE();t[my>>2]=g;var h=CE();t[gz>>2]=1<b>>>0&1;t[Nz>>2]=0;var i=(k=Da++,e[k]=1,Ea[k]=c,t[rz>>2]=k,0);c=7;break;case 7:c=1==(i|0)?6:3;break;case 3:c=2!=(i|0)|0!=(t[gz>>2]|0)?5:4;break;case 4:var m=t[(t[K+40>>2]+8|0)>>2];KC(Hg|0,(k=j,j+=4,t[k>>2]=m,k));var n=1;c=6;break;case 5:var q=h;JE(q);for(var p=q|0,s=q+4|0;;){if(11==(t[p>>2]|0)){JE(q)}else{var r=t[s>>2];if(23==(r|0)){XE(q,3)}else{if(57==(r|0)){XE(q,11)}else{if(3==(r|0)){var u=q,v=ba;JE(u);v=(u+4|0)>>2;11==(t[v]|0)&&(JE(u),3==(t[u>>2]|0)&&TE(u,0));WE(u);HE(u);KE(u);if(18!=(t[v]|0)){for(;!(HE(u),18==(t[v]|0));){}}SE(u);HE(u);EE()}else{if(45==(r|0)){XE(q,10)}else{if(18==(r|0)){HE(q)}else{if(34==(r|0)){u=q;v=ba;JE(u);3==(t[u>>2]|0)&&TE(u,8);WE(u);HE(u);KE(u);var w=u+4|0,C=t[w>>2];if(10==(C|0)){lF(u),v=2626}else{var A=C}for(;;){2626==v&&(A=t[w>>2]);if(18==(A|0)){break}HE(u);v=2626}SE(u);HE(u);EE()}else{0!=(FE(r)|0)?JE(q):0==(KE(q)|RE(q)|0)&&JE(q)}}}}}}}};case 6:var I=0==(t[lA>>2]|0);a:do{if(!I){for(;;){if(EE(),0==(t[lA>>2]|0)){break a}}}}while(0);var M=t[jA>>2];0!=(M|0)&&vB(M);t[jA>>2]=0;t[lA>>2]=0;t[kA>>2]=0;DE(h);DE(t[my>>2]);j=d;return n;default:ua(0,"bad label: "+c)}}catch(B){(!B.f||!(B.id in e))&&aa(B),f[Ea[B.id]](B.value)}}}),0,(function(b){UI(b,Nn|0,du|0,Ej|0,Ti|0);UI(b,Ig|0,Fo|0,ue|0,0)}),0,(function(b,d){var c=t[gc>>2];0!=(c|0)&&(t[rd>>2]=c,t[gc>>2]=0);32==(d|0)?(iG(t[t[Mb>>2]+8>>2],6),S(t[Mb>>2])):22==(d|0)?V(t[Mb>>2],t[b+8>>2]):28==(d|0)||26==(d|0)||30==(d|0)?(t[z>>2]=250,t[gc>>2]=t[rd>>2],t[rd>>2]=166,hG(0,d)):29==(d|0)&&(t[z>>2]=t[rd>>2])}),0,(function(b,d){if(31==(d|0)){var c=t[b+8>>2];0==(26>(l[c]-65&255)&1|0)?(t[z>>2]=154,t[rd>>2]=168,t[Ib>>2]=39):(V(t[Nb>>2],c),AG(Lb,t[t[Nb>>2]+8>>2],6),t[z>>2]=234)}else{36==(d|0)?t[z>>2]=18:0==(d|0)&&(t[z>>2]=86)}}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=lI(),f=(k=Da++,d[k]=1,Ea[k]=b,t[uz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:for(var g=e,h=g+4|0;!(qI(g),nI(g,0),23==(t[h>>2]|0));){}b=3;break;case 4:mI(e);return;default:ua(0,"bad label: "+b)}}catch(i){(!i.f||!(i.id in d))&&aa(i),c[Ea[i.id]](i.value)}}}),0,(function(b,d){if(31==(d|0)){l[md]||(l[md]=1)}else{if(32==(d|0)){t[jc>>2]=t[jc>>2]+1|0}else{if(42==(d|0)){58==l[t[b+8>>2]]<<24>>24?(t[z>>2]=228,t[rd>>2]=110):0==(t[jc>>2]|0)&l[md]&&(t[z>>2]=110,yG(b,42))}else{if(33==(d|0)){var c=t[jc>>2]-1|0;t[jc>>2]=c;0==(c|0)&&(t[z>>2]=110)}else{0==(t[jc>>2]|0)&l[md]&&(t[z>>2]=110,yG(b,d))}}}}}),0,(function(b,d){if(22==(d|0)){var c=b+8|0;iG(t[c>>2],1);aG(t[c>>2],1)}t[z>>2]=26}),0,(function(b){t[Oy>>2]=b;for(b=0;!(vC(t[Dz+(b<<3)>>2],t[Oy>>2],t[Dz+(b<<3)+4>>2]),b=b+1|0,61==(b|0));){}}),0,(function(){var b,d=GI(Fn|0);b=d>>2;t[b+1]=aA|0;t[b+2]=1;t[b+3]=$z|0;t[b+6]=120;return d}),0,RF,0,(function(){var b,d=GI(ww|0);b=d>>2;t[b+3]=Kx|0;t[b+1]=Lx|0;t[b+2]=8;t[b+6]=246;t[b+5]=236;return d}),0,(function(){var b,d=GI(pv|0);b=d>>2;t[b+1]=Tz|0;t[b+2]=14;t[b+3]=Kz|0;t[b+7]=142;t[b+5]=36;return d}),0,(function(b,d){return 0==(sA(b,t[d+8>>2],Aa)|0)&1}),0,(function(b,d){32==(d|0)||21==(d|0)||(42==(d|0)?(BG(1,4,20,b),t[z>>2]=110):6==(d|0)?zG():41==(d|0)?(BG(1,3,20,b),t[z>>2]=110):31==(d|0)?(BG(1,3,20,b),t[z>>2]=110):t[z>>2]=12)}),0,jH,0,(function(b,d){if((t[Ib>>2]|0)==(d|0)){t[z>>2]=t[rd>>2]}else{if(((l[Zc]?29:0)|0)==(d|0)){t[z>>2]=t[Yc>>2]}}}),0,(function(b){UI(b,gp|0,Fo|0,Ek|0,Ti|0);UI(b,xh|0,Fo|0,ig|0,0)}),0,(function(){var b,d=GI(Fw|0);b=d>>2;t[b+1]=Tz|0;t[b+2]=14;t[b+3]=Sz|0;t[b+7]=142;t[b+5]=64;return d}),0,(function(b,d){if(22==(d|0)){if(l[fc]){l[fc]=0;bG();var c=t[rd>>2];t[z>>2]=c;ab[c](b,22)}else{c=b+8|0,iG(t[c>>2],10),aG(t[c>>2],10),l[fc]=1}}else{28==(d|0)?t[z>>2]=166:32==(d|0)&&(l[fc]&&bG(),c=t[rd>>2],t[z>>2]=c,ab[c](b,32))}}),0,(function(){var b,d=GI(ul|0);b=d>>2;t[b+1]=xy|0;t[b+2]=1;t[b+4]=vy|0;t[b+3]=wy|0;t[b+6]=270;return d}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;h=c}),g:0};;){try{switch(b){case 2:var e=yF(),f=bH();t[Qz>>2]=f;var g=bH();t[ez>>2]=g;var h=(k=Da++,d[k]=1,Ea[k]=b,t[pz>>2]=k,0);b=5;break;case 5:b=0==(h|0)?3:4;break;case 3:for(var i=e,m=i|0,n=i+4|0;;){BF(i),6!=(t[m>>2]|0)?JF(i,0):0==(t[n>>2]|0)?AF(i):JF(i,0)};case 4:fH(t[Qz>>2]);fH(t[ez>>2]);t[Qz>>2]=0;t[ez>>2]=0;zF(e);return;default:ua(0,"bad label: "+b)}}catch(q){(!q.f||!(q.id in d))&&aa(q),c[Ea[q.id]](q.value)}}}),0,sJ,0,(function(){var b,d=GI(qw|0);b=d>>2;t[b+1]=Ax|0;t[b+2]=5;t[b+3]=zx|0;t[b+6]=210;return d}),0,(function(b,d){(t[Ib>>2]|0)==(d|0)?t[z>>2]=t[rd>>2]:((l[Kb]?37:0)|0)==(d|0)?t[z>>2]=122:oG(0,d)}),0,(function(){var b=xI();a:for(;;){for(var d=0==(b|0);;){if(d){break a}var c;c=b;var e=0==(N(c,Hr|0,4)|0)?1:0==(N(c,Go|0,4)|0)?1:0!=(N(c,om|0,3)|0)?1:yI(c);0!=(zI(c)|0)&&AI(c);0==(N(c,hk|0,2)|0)&&BI(c);0==(N(c,yi|0,3)|0)&&DI(c);0==(N(c,fh|0,3)|0)&&EI(c);c=e;if(0!=(c|0)){break}}b=xI()}}),0,(function(b){t[Sy>>2]=b;for(b=0;!(vC(t[gA+(b<<3)>>2],t[Sy>>2],t[gA+(b<<3)+4>>2]),b=b+1|0,16==(b|0));){}}),0,(function(){var b,d=GI(rr|0);b=d>>2;t[b+3]=Ez|0;t[b+5]=306;t[b+8]=1;return d}),0,(function(b){t[Ny>>2]=b;for(b=0;!(vC(t[J+(b<<3)>>2],t[Ny>>2],t[J+(b<<3)+4>>2]),b=b+1|0,68==(b|0));){}}),0,(function(){var b,d=GI($m|0);b=d>>2;t[b+3]=dy|0;t[b+5]=296;t[b+8]=1;return d}),0,(function(){var b,d=GI(vw|0);b=d>>2;t[b+1]=Ex|0;t[b+2]=8;t[b+3]=Dx|0;t[b+6]=108;t[b+5]=4;return d}),0,(function(){var b,d=GI(rs|0);b=d>>2;t[b+3]=Ux|0;t[b+5]=194;t[b+8]=1;return d}),0,hH,0,(function(){var b,d=GI(Jr|0);b=d>>2;t[b+1]=Cx|0;t[b+2]=11;t[b+3]=Bx|0;t[b+6]=170;t[b+5]=92;return d}),0,(function(){t[z>>2]=t[rd>>2]}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=qF(),f=(k=Da++,d[k]=1,Ea[k]=b,t[qz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:for(var g=e,h=g|0,i=g+4|0;;){if(tF(g),2==(t[h>>2]|0)){var m=t[i>>2];if(4==(m|0)){sF(g,4)}else{if(5==(m|0)){var n=g,q=qF();tF(q);5==(t[q>>2]|0)&&wF(q);tF(n);wF(n);vF(n);7==(t[n>>2]|0)&&wF(n);uF(q,1);rF(q)}else{if(2==(m|0)){sF(g,2)}else{if(0==(m|0)){var p=qF();tF(p);uF(p,0);if(0==(t[Zb>>2]|0)&0!=(t[oy+4>>2]|0)){var s=P();t[Zb>>2]=s;V(s,t[t[p+8>>2]+8>>2])}rF(p)}else{3==(m|0)&&sF(g,3)}}}}}};case 4:rF(e);Q(t[Zb>>2]);t[Zb>>2]=0;return;default:ua(0,"bad label: "+b)}}catch(r){(!r.f||!(r.id in d))&&aa(r),c[Ea[r.id]](r.value)}}}),0,HG,0,(function(b,d){20==(d|0)?(tC(Lb),S(t[Nb>>2]),t[z>>2]=154,t[rd>>2]=168,t[Ib>>2]=39):42==(d|0)?(t[z>>2]=122,zG(),l[yc]=0):39==(d|0)?(tC(Lb),S(t[Nb>>2]),t[z>>2]=168):(tC(Lb),S(t[Nb>>2]),t[z>>2]=154,t[rd>>2]=168,t[Ib>>2]=39,zG(),oG(0,d))}),0,(function(b){t[Jy>>2]=b;vC(Nr|0,t[Jy>>2],0);vC(Mo|0,t[Jy>>2],1);vC(sm|0,t[Jy>>2],2);vC(mk|0,t[Jy>>2],3);vC(Ci|0,t[Jy>>2],4);vC(ih|0,t[Jy>>2],5);vC(Wf|0,t[Jy>>2],6);vC(Ue|0,t[Jy>>2],7)}),0,(function(b,d){if(28==(d|0)||32==(d|0)){var c=t[Wc>>2];0==(t[c>>2]|0)?iG(t[t[ec>>2]+8>>2],t[Ac>>2]):(iG(t[c+8>>2],t[Ac>>2]),S(t[Wc>>2]));t[z>>2]=26;jG(0,d);S(t[ec>>2])}else{33==(d|0)?(U(t[Wc>>2],t[t[ec>>2]+8>>2]),U(t[Wc>>2],Gq|0),S(t[ec>>2])):22==(d|0)?V(t[ec>>2],t[b+8>>2]):26==(d|0)&&(t[z>>2]=48,t[rd>>2]=238,t[Ib>>2]=27)}}),0,(function(){var b,d=GI(wx|0);b=d>>2;t[b+3]=hA|0;t[b+5]=60;t[b+8]=1;return d}),0,(function(){var b,d=GI(gg|0);b=d>>2;t[b+1]=fA|0;t[b+2]=4;t[b+3]=eA|0;t[b+4]=dA|0;t[b+6]=102;t[b+5]=212;return d}),0,(function(){var b,d=GI(mw|0);b=d>>2;t[b+3]=yx|0;t[b+5]=2;t[b+8]=1;return d}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=YH(),f=(k=Da++,d[k]=1,Ea[k]=b,t[wz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:for(var g=e,h=g|0,i=g+4|0;;){if(aI(g),4==(t[h>>2]|0)){var m=t[i>>2];3==(m|0)?$H(g,3):4==(m|0)?$H(g,4):5==(m|0)?$H(g,5):1==(m|0)?$H(g,1):7==(m|0)?$H(g,7):0==(m|0)?$H(g,0):2==(m|0)?$H(g,2):6==(m|0)&&$H(g,6)}};case 4:ZH(e);return;default:ua(0,"bad label: "+b)}}catch(n){(!n.f||!(n.id in d))&&aa(n),c[Ea[n.id]](n.value)}}}),0,(function(b,d){6==(d|0)?zG():31==(d|0)?(nG(b,3),BG(0,3,122,b),l[yc]=1,t[z>>2]=110):42==(d|0)?(nG(b,5),BG(0,4,122,b),t[z>>2]=110):32==(d|0)||18==(d|0)||28==(d|0)||21==(d|0)||(t[z>>2]=122)}),0,hG,0,(function(){var b,d=GI(tp|0);b=d>>2;t[b+1]=cy|0;t[b+2]=6;t[b+3]=by|0;t[b+6]=278;return d}),0,(function(b){t[Py>>2]=b;uC(b,2)}),0,(function(b,d){22==(d|0)?V(t[Mb>>2],t[b+8>>2]):32==(d|0)?(iG(t[t[Mb>>2]+8>>2],6),S(t[Mb>>2])):30==(d|0)||26==(d|0)?(t[z>>2]=250,t[rd>>2]=256):29==(d|0)&&(t[z>>2]=74)}),0,(function(){var b,d=GI(Qq|0);b=d>>2;t[b+1]=cA|0;t[b+2]=5;t[b+3]=bA|0;t[b+6]=70;return d}),0,(function(b,d){2==(d|0)?(t[z>>2]=294,t[rd>>2]=260):32==(d|0)?(iG(t[t[Mb>>2]+8>>2],9),S(t[Mb>>2]),t[z>>2]=16):1==(d|0)?(t[z>>2]=198,t[rd>>2]=260):22==(d|0)&&V(t[Mb>>2],t[b+8>>2])}),0,(function(){var b,d=GI(Hw|0);b=d>>2;t[b+1]=Qx|0;t[b+2]=23;t[b+3]=Px|0;t[b+6]=50;t[b+5]=10;return d}),0,(function(){var b,d=GI(Wq|0);b=d>>2;t[b+3]=jz|0;t[b+1]=kz|0;t[b+2]=6;t[b+6]=118;t[b+5]=300;return d}),0,(function(b){t[Ly>>2]=b;uC(b,3)}),0,(function(b,d){var c=t[Ec>>2];19==(d|0)?BG(0,2,122,c):S(c);t[z>>2]=122}),0,UF,0,(function(b){UI(b,Zk|0,kj|0,Jh|0,0);UI(b,qg|0,Fo|0,Ud|0,0);UI(b,Ow|0,Fo|0,$v|0,0);UI(b,zv|0,kj|0,Ek|0,0);UI(b,Eu|0,du|0,Et|0,0);UI(b,dt|0,kj|0,Et|0,0);UI(b,Fs|0,du|0,ns|0,0);UI(b,Yr|0,yr|0,ns|0,0);UI(b,Yr|0,kj|0,ns|0,0)}),0,(function(b,d){var c=t[pc>>2];0!=(c|0)&&(t[rd>>2]=c,t[pc>>2]=0);29==(d|0)?(t[z>>2]=t[rd>>2],bG()):22==(d|0)&&(iG(t[b+8>>2],11),c=t[rd>>2],t[pc>>2]=c,t[Ib>>2]=23,l[Zc]=1,t[Yc>>2]=c,t[rd>>2]=274,t[z>>2]=192)}),0,$D,0,aH,0,(function(b,d){23==(d|0)||22==(d|0)?(BG(0,1,122,t[Dc>>2]),t[z>>2]=122):9==(d|0)?(t[z>>2]=104,t[Ib>>2]=45,t[rd>>2]=280):32==(d|0)?(t[z>>2]=104,t[rd>>2]=122,t[Ib>>2]=33,FG(0,32)):(S(t[Dc>>2]),t[z>>2]=122)}),0,(function(){for(var b=0;;){var d=eC();if(0==(d|0)){break}b=AD(d,b);if(10==(b|0)){break}}}),0,(function(b,d){if(22==(d|0)){V(t[ec>>2],t[b+8>>2])}else{if(28==(d|0)||32==(d|0)){var c=t[Wc>>2];0==(t[c>>2]|0)?iG(t[t[ec>>2]+8>>2],t[Ac>>2]):(iG(t[c+8>>2],t[Ac>>2]),S(t[Wc>>2]));t[z>>2]=74;jG(0,d);S(t[ec>>2])}else{33==(d|0)?(U(t[Wc>>2],t[t[ec>>2]+8>>2]),U(t[Wc>>2],Gq|0),S(t[ec>>2])):26==(d|0)&&(t[z>>2]=48,t[rd>>2]=284,t[Ib>>2]=27)}}}),0,(function(){var b=P(),d=eC();if(0!=(d|0)){for(;;){var c=l[d];if(45==c<<24>>24){for(var e=d+1|0,c=b,d=P(),f=t[d+8>>2],e=YD(e,d);0!=(L(l[e]&255)|0);){e=e+1|0}e=40==l[e]<<24>>24?e+1|0:e;0==(qA(f,Hh|0)|0)?ZD(e,3):0==(qA(f,zr|0)|0)?ZD(e,0):0==(qA(f,Uf|0)|0)&&(f=e,e=P(),YD(f,e),jC(e,Az|0,2),V(c,t[e+8>>2]),Q(e));Q(d)}else{if(!(37==c<<24>>24||34==c<<24>>24)&&0!=(pA(c&255)|0)){c=d;f=b;d=P();YD(c,d);var c=d,e=ba,g=j;j+=80;e=g>>2;0!=(t[Az+16>>2]|0)&&0!=(t[c>>2]|0)&&(sC(g,t[c+8>>2]),t[e+9]=t[Az+24>>2],l[g+40|0]=t[Az+20>>2]&255,0!=(f|0)&&0!=(t[f>>2]|0)&&(t[e+15]=Uf|0,t[e+16]=t[f+8>>2]),tC(g));j=g;Q(d)}}d=eC();if(0==(d|0)){break}}}Q(b)}),0,(function(b){t[Iy>>2]=b;for(b=0;!(vC(t[Wy+(b<<3)>>2],t[Iy>>2],t[Wy+(b<<3)+4>>2]),b=b+1|0,17==(b|0));){}}),0,(function(){var b,d=GI(Vv|0);b=d>>2;t[b+1]=Hz|0;t[b+2]=3;t[b+3]=Gz|0;t[b+6]=282;return d}),0,(function(){var b,d=GI(bq|0);b=d>>2;t[b+1]=ry|0;t[b+2]=9;t[b+3]=qy|0;t[b+6]=84;t[b+5]=14;return d}),0,(function(b,d){if(22==(d|0)){if(l[oc]){l[oc]=0;bG();var c=t[rd>>2];t[z>>2]=c;ab[c](b,22)}else{c=b+8|0,iG(t[c>>2],11),aG(t[c>>2],11),l[oc]=1}}else{28==(d|0)?(t[z>>2]=274,l[oc]=0):32==(d|0)&&(l[oc]&&bG(),c=t[rd>>2],t[z>>2]=c,ab[c](b,32))}}),0,(function(b){UI(b,Pk|0,Fo|0,Eh|0,0)}),0,(function(b,d){22==(d|0)&&iG(t[b+8>>2],12);t[z>>2]=304}),0,(function(b){t[Ky>>2]=b;for(b=0;!(vC(t[lz+(b<<3)>>2],t[Ky>>2],t[lz+(b<<3)+4>>2]),b=b+1|0,28==(b|0));){}}),0,(function(){var b,d=GI(nl|0);b=d>>2;t[b+1]=Zz|0;t[b+2]=6;t[b+3]=Yz|0;t[b+6]=156;return d}),0,(function(b,d){35==(d|0)?l[Jc]=1:36==(d|0)?l[Jc]?l[Jc]=0:t[z>>2]=16:l[Jc]=0}),0,(function(b){UI(b,vo|0,Fo|0,mm|0,0);UI(b,ni|0,Fo|0,Et|0,0)}),0];a.FUNCTION_TABLE=ab;function Hb(b){function d(){var c=0;Ab=ca;a._main&&(nb(qb),c=a.H(b),a.noExitRuntime||nb(rb));if(a.postRun){for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);0<a.postRun.length;){a.postRun.pop()()}}return c}b=b||a.arguments;if(0<xb){return a.h("run() called, but dependencies remain, so not running"),0}if(a.preRun){"function"==typeof a.preRun&&(a.preRun=[a.preRun]);var c=a.preRun;a.preRun=[];for(var e=c.length-1;0<=e;e--){c[e]()}if(0<xb){return 0}}return a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1);d()}),1),0):d()}a.run=a.T=Hb;if(a.preInit){for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;){a.preInit.pop()()}}nb(pb);var CJ=ca;a.noInitialRun&&(CJ=fa);CJ&&Hb()

Module = this.Module;

})();

define("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags.min",[], function(require, exports, module) {

	module.exports = Module;
	module.exports.CTags_parseTempFile = function(filename, contents) {
		filename = "file." + filename.match(/[^.]*$/)[0];
		this.FS_createDataFile("/", filename, contents, true, true);
		logged = "";
		this.CTags_parseFile("/" + filename);
	};
	var logged = "";
	module.exports.getLog = function() {
		return logged.replace(/\n$/, "");
	};
	Module.print = function() {
		arguments = Array.prototype.slice.call(arguments);
		logged += arguments.map(function(a) {
			return typeof a === "object" ? JSON.stringify(a) : a;
		}).join(" ") + "\n";
		console.log.apply(sysConsole, arguments)
	};
	Module.printErr = function() {
		arguments = Array.prototype.slice.call(arguments);
		logged += arguments.map(function(a) {
			return typeof a === "object" ? JSON.stringify(a) : a;
		}).join(" ") + "\n";
		console.err.apply(sysConsole, arguments)
	};

	
});
})();

define("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_ex",[], function(require, exports, module) {
var ctags = require("./ctags.min");

var util = require("./ctags_util");

var MAX_DOCHEAD_LENGTH = 80;

var CTAGS_OPTIONS = [
    '--langdef=js',
    '--langmap=js:.js',
    '--regex-js=/([A-Za-z0-9._$]+)[ \\t]*[:=][ \\t]*\\{/\\1/,object/',
    '--regex-js=/([A-Za-z0-9._$()]+)[ \\t]*[:=][ \\t]*function[ \\t]*\\(/\\1/,function/',
    '--regex-js=/function[ \\t]+([A-Za-z0-9._$]+)[ \\t]*\\(([^)])\\)/\\1/,function/',
    '--regex-js=/([A-Za-z0-9._$]+)[ \\t]*[:=][ \\t]*\\[/\\1/,array/',
    '--regex-js=/([^= ]+)[ \\t]*=[ \\t]*[^"]\'[^\']*/\\1/,string/',
    '--regex-js=/([^= ]+)[ \\t]*=[ \\t]*[^\']"[^"]*/\\1/,string/',
    
    '--langdef=rust',
    '--langmap=rust:.rs',
    '--regex-rust=/[ \\t]*fn[ \\t]+([a-zA-Z0-9_]+)/\\1/f,function/',
    '--regex-rust=/[ \\t]*type[ \\t]+([a-zA-Z0-9_]+)/\\1/T,types/',
    '--regex-rust=/[ \\t]*enum[ \\t]+([a-zA-Z0-9_]+)/\\1/T,types/',
    '--regex-rust=/[ \\t]*struct[ \\t]+([a-zA-Z0-9_]+)/\\1/m,types/',
    '--regex-rust=/[ \\t]*class[ \\t]+([a-zA-Z0-9_]+)/\\1/m,types/',
    '--regex-rust=/[ \\t]*mod[ \\t]+([a-zA-Z0-9_]+)/\\1/m,modules/',
    '--regex-rust=/[ \\t]*const[ \\t]+([a-zA-Z0-9_]+)/\\1/m,consts/',
    '--regex-rust=/[ \\t]*trait[ \\t]+([a-zA-Z0-9_]+)/\\1/m,traits/',
    '--regex-rust=/[ \\t]*impl[ \\t]+([a-zA-Z0-9_]+)/\\1/m,impls/',
    '--regex-rust=/[ \\t]*impl[ \\t]+of[ \\t]([a-zA-Z0-9_]+)/\\1/m,impls/',
    
    '--langmap=PHP:+.inc',
    '--PHP-kinds=+cf',
    '--regex-PHP=/abstract class ([^ ]*)/\\1/c/',
    '--regex-PHP=/interface ([^ ]*)/\\1/c/',
    '--regex-PHP=/(public |static |abstract |protected |private )+function ([^ (]*)/\\2/f/',

    '--regex-make=/-D([^ =]+).+$/\\1/d,definition/',
    
    '--langdef=markdown',
    '--langmap=markdown:.markdown',
    '--regex-markdown=/^#[ \\t]+(.*)/\\1/h,heading1/',
    '--regex-markdown=/^##[ \\t]+(.*)/\\1/h,heading2/',
    '--regex-markdown=/^###[ \\t]+(.*)/\\1/h,heading3/',
    
    '--langdef=ActionScript',
    '--langmap=ActionScript:.as',
    '--regex-ActionScript=/^[ \\t]*[(private|public|static)( \\t)]*function[ \\t]+([A-Za-z0-9_]+)[ \\t]*\\(/\\1/f,function/',
    '--regex-ActionScript=/^[ \\t]*[(public)( \\t)]*function[ \\t]+(set|get)[ \\t]+([A-Za-z0-9_]+)[ \\t]*\\(/\\2/p,property/',
    '--regex-ActionScript=/.*\\.prototype\\.([A-Za-z0-9 ]+)=([ \\t]?)function([ \\t]?)*\\(/\\1/f,function/',
];
var LANGUAGES = module.exports.LANGUAGES = [
    { guessFargs: true, extensions: ["as"], name: "actionscript" },
    { guessFargs: false, extensions: ["asm", "a"], name: "assembly_x86" },
    { guessFargs: true, extensions: ["sh"], name: "sh" },
    { guessFargs: true, extensions: ["js"], name: "javascript" },
    { guessFargs: true, extensions: ["html"], name: "html" },
    { guessFargs: true, extensions: ["coffee"], name: "coffee" },
    { guessFargs: true, extensions: ["bas"]},
    { guessFargs: true, extensions: ["asp"]},
    { guessFargs: true, extensions: ["cpp", "c", "cc", "cxx", "h", "hh", "hpp"], name: "c_cpp" },
    { guessFargs: true, extensions: ["cs"], name: "csharp" },
    { guessFargs: false, extensions: ["e", "ge"], extractDocs: false, name: "eiffel" },
    { guessFargs: true, extensions: ["erl", "hrl"], name: "erlang" },
    { guessFargs: false, extensions: ["f", "for", "ftn", "f77", "f90", "f95"]}, // Fortran
    { guessFargs: true, extensions: ["lisp", "cl", "lsp"]},
    { guessFargs: true, extensions: ["lua"], name: "lua" },
    { guessFargs: false, extensions: ["cob"], name: "cobol" },
    { guessFargs: true, extensions: ["pas", "p"], name: "pascal" },
    { guessFargs: true, extensions: ["scm", "sm", "scheme", "oak"], name: "scheme" },
    { guessFargs: true, extensions: ["pl", "pm"], name: "perl" },
    { guessFargs: false, extensions: ["prolog"], name: "prolog" },
    { guessFargs: false, extensions: ["ltx", "tex", "bib", "sty", "cls", "clo"], name: "latex" },
    { guessFargs: true, extensions: ["php", "php3", "phtml", "inc"], name: "php" },
    { guessFargs: true, extensions: ["py"], name: "python" },
    { guessFargs: false, extensions: ["y", "ym"]},
    { guessFargs: true, extensions: ["java"], name: "java" },
    { guessFargs: true, extensions: ["rb", "ru"], name: "ruby" },
    { guessFargs: true, extensions: ["ss"]}
];

module.exports.languages = LANGUAGES.map(function(l) { return l.name; }).filter(Boolean);
module.exports.extensions = [].concat.apply([], LANGUAGES.map(function(l) { return l.extensions; }));
util.init(module.exports);

module.exports.pathForLanguage = function(language, path) {
    var ext = path.match(/[^./]*$/)[0];
    LANGUAGES.some(function(r) {
        if (r.name == language) {
            if (r.extensions.indexOf(ext) == -1)
                path = "tmp." + r.extensions[0];
            return true;
        }
    });
    return path;
};

module.exports.analyze = function(path, doc, options, callback) {
    if (!doc)
        return callback("No contents");
    
    var lines;
    if (doc.getAllLines) {
        lines = doc.getAllLines();
        doc = doc.getValue();
    }
    else {
        if (doc.getValue)
            doc = doc.getValue();
        lines = doc.split(/\n/);
    }
    
    var result = {
        doc: doc ? util.extractDocumentationAtRow(lines, 0) : undefined,
        properties: {}
    };
    
    var isDone = false;
    var language = getLanguage(path);
    var guessFargs = language && language.guessFargs;
    ctags.CTags_setOnTagEntry(function(name, kind, row, sourceFile, language) {
        analyzeTag(lines, name, kind, row, sourceFile, guessFargs, result.properties);
    });
    
    ctags.CTags_setOnParsingCompleted(function() {
        isDone = true;
        callback(null, result);
    });
    
    var filename = path.match(/[^\/]*$/)[0];
    ctags.FS_createPath("/", "data", true, true);
    try {
        ctags.CTags_parseTempFile(filename, doc);
    } catch (err) {
        if (isDone)
            throw err;
        return callback("Internal error in CTags: " + err);
    }
    if (!isDone) {
        callback(ctags.getLog() || "ctags analysis failed");
        callback = function() {
            throw new Error("Callback called too late");
        };
    }
};

function getLanguage(path) {
    var ext = path.substr(path.lastIndexOf(".") + 1);
    return ext && LANGUAGES.filter(function(l) {
        return l.extensions.indexOf(ext) > -1;
    })[0];
}
    
function analyzeTag(lines, name, kind, row, sourceFile, guessFargs, results) {
    var line = lines[row - 1] || "";
    var doc = util.extractDocumentationAtRow(lines, row - 1);

    var docHead = line.length > MAX_DOCHEAD_LENGTH
        ? line.substr(MAX_DOCHEAD_LENGTH) + "..."
        : line;
    if (docHead.indexOf(name) === -1) // sanity check
        docHead = null;
    var icon = getIconForKind(kind);
    
    var result = {
        row: row - 1,
        doc: doc,
        docHead: docHead,
        kind: kind,
        icon: icon
    };
    if (icon === "method" || icon === "method2") {
        result.guessFargs = guessFargs;
        result.properties = {
            _return: []
        };
    }
    
    results["_" + name] = results["_" + name] || [];
    results["_" + name].push(result);
}

function getIconForKind(kind) {
    switch (kind) {
        case "member": 
            return "property";
        case "function":
            return "method";
        case "prototype":
            return "method2";
        case "class": case "module": case "typedef":
            return "package";
        default:
            return "property2";
    }
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/handler_registry",[], function(require, exports, module) {

var assert = require("c9/assert");

module.exports.HandlerRegistry = function() {
    var handlers = [];
    var supportedLanguages = "";
    var supportedExtensions = "";
    
    return {
        registerHandler: function(handler, options) {
            options = options || {};
            var existing = handlers.filter(function(h) { return h.$source && handler.$source === h.$source; });
            if (existing.length || handlers.indexOf(handler) > -1)
                return;
            
            handler.sender = options.sender;
            if (handler.init)
                handler.init(options, function(err) {
                    if (err)
                        console.error("Error initializing " + handler.$source, err.stack || err);
                });
        
            var languages = handler.languages;
            var extensions = handler.extensions;
            handler.guidName = languages.join("");
            assert(languages && extensions, "Handlers must have a languages and extensions property");
            
            handler.supportedLanguages = "$.";
            handler.supportedExtensions = "$.";
            handlers.push(handler);
            languages.forEach(function(e) {
                supportedLanguages += (supportedLanguages ? "|^" : "^") + e;
                handler.supportedLanguages += "|^" + e + "$";
            });
            extensions.forEach(function(e) {
                supportedExtensions += (supportedExtensions ? "|^" : "^") + e + "$";
                handler.supportedExtensions += "|^" + e + "$";
            });
        },
        
        unregisterHandler: function(source) {
            handlers = handlers.filter(function(h) { return !(h.$source && source === h.$source); });
        },
        
        getHandlerFor: function(path, language) {
            var match = path && path.match(/\.([^/.]*)$/);
            var extension = match && match[1] || "";
            if (!extension.match(supportedExtensions) && !(language || "").match(supportedLanguages))
                return null;
            
            var results = handlers.filter(function(p) {
                if (p.disabled) return false;
                if (language && language.match(p.supportedLanguages)) return true;
                if (p.supportedExtensions && extension.match(p.supportedExtensions)) return true;
                if (p.supportedPaths && path && path.match(p.supportedPaths)) return true;
                return false;
            });
            if (results.length > 1)
                results = results.filter(function(r) { return !r.isGeneric; });
            
            return results[0];
        },
        
        getAllHandlers: function() {
            return handlers;
        }
    
    };
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler",[], function(require, exports, module) {

var asyncForEach = require("plugins/c9.ide.language.core/worker").asyncForEach;
var workerUtil = require("plugins/c9.ide.language/worker_util");
var child_process = typeof process === "undefined" || !process.version
    ? null
    : arguments[0]("child_process");
module.exports = {
    languages: [],
    extensions: [],
    maxCallInterval: 2000,
    CALL_INTERVAL_MIN: 500,
    
    CALL_INTERVAL_BASIC: 1200,
    init: function(options, callback) {
        callback();
    },
    findImports: function(path, value, ast, options, callback) {
        callback();
    },
    analyzeCurrent: function(path, value, ast, options, callback) {
        callback();
    },
    analyzeOthers: function(paths, options, callback) {
        callback();
    },
    analyzeWorkspaceRoot: function(callback) {
        callback();
    },
    analyzeCurrentAll: function(paths, options, callback) {
        var errs = [];
        var results = [];
        var _self = this;
        asyncForEach(
            paths,
            function(path, next) {
                workerUtil.readFile(path, { unsaved: true }, function(err, doc) {
                    if (err) {
                        errs.push(err);
                        results.push(null);
                        return next();
                    }
                    
                    _self.analyzeCurrent(path, doc, null, options, function(err, result) {
                        errs.push(err);
                        results.push(result);
                        next();
                    });
                });
            },
            function() {
                callback(errs, results);
            }
        );
    },
    $lint: function(linter, args, stdin, options, callback) {
        var a = arguments;
        callback = a[4] || a[3] || a[2];
        options = typeof a[3] == "object" && a[3]
            || typeof a[2] == "object" && !(a[2] instanceof Buffer) && a[2];
        stdin = (typeof a[2] == "string" || a[2] instanceof Buffer) && a[2];

        if (!child_process)
            return callback(new Error("Only implemented for server-side plugins"));
        
        options = options || {};
        options.maxBuffer = options.maxBuffer || 200 * 1024;
        options.env = options.env || {};
        var PATH = options.env.PATH || this.defaultEnv && this.defaultEnv.PATH || process.env.PATH;
        options.env.PATH = process.platform === "linux"
            ? PATH + ":/mnt/shared/bin"
            : PATH;
        for (var key in process.env) {
            options.env[key] = options.env[key] != null ? options.env[key] : process.env[key];
        }
        
        try {
            var child = child_process.execFile(
                linter, args, options,
                function(err, stdout, stderr) {
                    if (err && ["ENOENT", "EACCES"].indexOf(err.code) > -1) {
                        err = new Error(err.code + ": No " + (linter === "bash" ? "linter" : linter) + " installation found");
                        err.code = "EFATAL";
                        return callback(err, stdout, stderr);
                    }
                    
                    callback(null, stdout, stderr, err);
                }
            );

            child.stdin.on("error", function(e) {
            });
    
            if (stdin)
                child.stdin.end(stdin);
        }
        catch (err) {
            err.code = "EFATAL";
            callback(err);
        }
    }
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/server_handler_wrapper",[], function(require, exports, module) {
    
    var lastId = 0;
    module.exports.ServerHandlerWrapper = function(descriptor, worker) {
        var PluginBase = require("./jsonalyzer_base_handler");
        var handler = Object.create(PluginBase);
        handler.$source = descriptor.path;
        handler.languages = descriptor.properties.languages;
        handler.extensions = descriptor.properties.extensions;
        handler.maxCallInterval = descriptor.properties.maxCallInterval;
        
        if (descriptor.functions.analyzeCurrent)
            handler.analyzeCurrent = function(path, value, ast, options, callback) {
                callServer({
                    handlerPath: descriptor.path,
                    maxCallInterval: descriptor.properties.maxCallInterval,
                    semaphore: handler.$source,
                    filePath: path,
                    method: "analyzeCurrent",
                    args: [path, null, null, options]
                }, callback);
            };
        if (descriptor.functions.findImports)
            handler.findImports = function(path, value, ast, options, callback) {
                callServer({
                    handlerPath: descriptor.path,
                    maxCallInterval: descriptor.properties.maxCallInterval,
                    filePath: path,
                    method: "findImports",
                    args: [path, null, null, options]
                }, callback);
            };
        if (descriptor.functions.analyzeOthers)
            handler.analyzeOthers = function(paths, options, callback) {
                callServer({
                    handlerPath: descriptor.path,
                    maxCallInterval: descriptor.properties.maxCallInterval,
                    filePath: null, // we're not using collab for these so we don't care
                    method: "analyzeOthers",
                    args: [paths, options]
                }, callback);
            };
        return handler;
    
        function callServer(options, callback) {
            options.id = ++lastId;
            worker.sender.on("jsonalyzerCallServerResult", function onResult(e) {
                if (e.data.id !== options.id)
                    return;
                
                worker.sender.off("jsonalyzerCallServerResult", onResult);

                var err = e.data.result[0];
                if (err && err.code === "EFATAL") {
                    console.error("Fatal error in " + descriptor.path, err);
                    handler.disabled = err;
                }

                callback.apply(null, e.data.result);
            });
            worker.sender.emit("jsonalyzerCallServer", options);
        }
    };
    
});

define("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker",[], function(require, exports, module) {

var baseLanguageHandler = require("plugins/c9.ide.language/base_handler");
var languageWorker = require("plugins/c9.ide.language.core/worker");
var index = require("./semantic_index");
var jumptodef = require("./jumptodef");
var complete = require("./complete");
var outline = require("./outline");
var refactor = require("./refactor");
var highlight = require("./highlight_occurrences");
var scopeAnalyzer = require('plugins/c9.ide.language.javascript/scope_analyzer');
var directoryIndexer = require("./directory_indexer");
var fileIndexer = require("./file_indexer");
var ctagsUtil = require("./ctags/ctags_util");
var ctagsEx = require("./ctags/ctags_ex");
var HandlerRegistry = require("./handler_registry").HandlerRegistry;
var ServerHandlerWrapper = require("./server_handler_wrapper").ServerHandlerWrapper;
require("treehugger/traverse"); // add traversal methods

var worker = module.exports = Object.create(baseLanguageHandler);
var isOnline = false;
var isInWebWorker = typeof window == "undefined" || !window.location || !window.document;
var handlers = new HandlerRegistry();
var handlersServer = new HandlerRegistry();

worker.$isInited = false;
worker.DEBUG = true;
worker.KIND_DEFAULT = scopeAnalyzer.KIND_DEFAULT;
worker.KIND_PACKAGE = scopeAnalyzer.KIND_PACKAGE;

worker.init = function(callback) {
    worker.sender.on("onlinechange", function(event) {
        worker.onOnlineChange(event);
    });
    worker.sender.on("filechange", function(event) {
        worker.onFileChange(event);
    });
    worker.sender.on("dirchange", function(event) {
        worker.onDirChange(event);
    });
    worker.sender.on("jsonalyzerRegister", function(event) {
        worker.loadPlugin(event.data.modulePath, event.data.contents, function(err, plugin) {
            if (err) return console.error(err);
            plugin.$source = event.data.modulePath;
            
            var oldHandler = worker.getHandlerFor(worker.path, worker.language);
            var options = event.data.options || {};
            
            options.sender = worker.sender;
            handlers.registerHandler(plugin, worker, options);
            if (oldHandler !== worker.getHandlerFor(worker.path, worker.language)) {
                index.markStale(oldHandler);
                languageWorker.$lastWorker.onUpdate();
            }
                
            worker.sender.emit("jsonalyzerRegistered",
                { modulePath: event.data.modulePath, err: err });
        });
    });
    worker.sender.on("jsonalyzerRegisterServer", function(event) {
        var oldHandler = worker.getServerHandlerFor(worker.path, worker.language);
        handlersServer.registerHandler(
            new ServerHandlerWrapper(event.data, worker), worker);
        if (oldHandler !== worker.getServerHandlerFor(worker.path, worker.language)) {
            index.markStale(oldHandler);
            var clientHandler = worker.getHandlerFor(worker.path, worker.language);
            if (oldHandler !== clientHandler)
                index.markStale(clientHandler);
            languageWorker.$lastWorker.onUpdate();
        }
    });
    worker.sender.on("jsonalyzerUnregister", function(event) {
        if (window.require)
            window.require.modules[event.data.modulePath] = null;
        handlers.unregisterHandler(event.data.modulePath);
        worker.sender.emit("jsonalyzerUnregistered", { modulePath: event.data.modulePath });
    });
    worker.sender.on("jsonalyzerUnregisterServer", function(event) {
        handlersServer.unregisterHandler(event.data.modulePath);
        worker.sender.emit("jsonalyzerUnregisteredServer", { modulePath: event.data.modulePath });
    });
    
    directoryIndexer.init(this);
    fileIndexer.init(this);
    index.init(this);
    jumptodef.init(this);
    complete.init(this);
    outline.init(this);
    refactor.init(this);
    highlight.init(this);
    ctagsUtil.init(ctagsEx, this);
    callback();
};

worker.loadPlugin = function(modulePath, contents, callback) {
    if (contents) {
        contents = contents.replace(/^(define\()(function|["'])/m, function(_, def, arg1) {
            if (arg1 == "function")
                return def + "'" + modulePath + "',[]," + arg1;
            return _;
        });
        try {
            eval.call(null, contents + "\n//@ sourceURL=" + modulePath);
        } catch (e) {
            return callback("Could not load language handler " + modulePath + ": " + e);
        }
    }
    var handler;
    try {
        handler = require(modulePath);
        if (!handler)
            throw new Error("Unable to load required module: " + modulePath);
    } catch (e) {
        if (isInWebWorker)
            return callback("Could not load language handler " + modulePath + ": " + e);
        return require([modulePath], function(handler) {
            if (!handler)
                return callback("Could not load language handler " + modulePath);
            callback(null, handler);
        });
    }
    callback(null, handler);
};

worker.handlesLanguage = function(language, part) {
    return (!part || !part.index) && this.getHandlerFor(this.path, language);
};

worker.onDocumentOpen = function(path, doc, oldPath, callback) {
    if (this.$isInited && !this.getHandlerFor(path, null))
        return callback();
    fileIndexer.analyzeOthers([path]);
    callback();
};

worker.analyze = function(doc, ast, options, callback) {
    if (options.minimalAnalysis && index.get(worker.path) || !worker.path)
        return callback();
    var fullDoc = this.doc.getValue();
    this.language = this.doc.$language;
        
    fileIndexer.analyzeCurrent(worker.path, fullDoc, ast, options, function(err, result, imports, markers) {
        if (err)
            console.error("[jsonalyzer] Warning: could not analyze " + worker.path + ": " + (err.stack || err));
        if (imports && imports.length)
            fileIndexer.analyzeOthers(imports, true);
        
        callback(markers);
    });
};

worker.complete = complete.complete.bind(complete);

worker.outline = outline.outline.bind(outline);

worker.jumpToDefinition = jumptodef.jumpToDefinition.bind(jumptodef);

worker.getRefactorings = refactor.getRefactorings.bind(refactor);

worker.getRenamePositions = refactor.getRenamePositions.bind(refactor);

worker.commitRename = refactor.commitRename.bind(refactor);

worker.highlightOccurrences = highlight.highlightOccurrences.bind(highlight);

worker.onOnlineChange = function(event) {
    isOnline = event.data.isOnline;
},

worker.onFileChange = function(event) {
    if (worker.disabled)
        return;
    var path = event.data.path.replace(/^\/((?!workspace)[^\/]+\/[^\/]+\/)?workspace\//, "");
    
    if (!this.getHandlerFor(path, null))
        return;
    
    if (event.data.isSave && path === this.path)
        return fileIndexer.analyzeCurrent(path, event.data.value, null, { isSave: true }, function() {});

    index.removeByPath(path);
    fileIndexer.analyzeOthers([path]);
};

worker.onDirChange = function(event) {
    directoryIndexer.enqueue(event.data.path);
};

worker.getHandlerFor = function(path, language) {
    language = language || (worker.path === path && worker.language);
    
    return handlers.getHandlerFor(path, language)
        || this.getServerHandlerFor(path, language);
};

worker.getServerHandlerFor = function(path, language) {
    language = language || (worker.path === path && worker.language);
    
    return handlersServer.getHandlerFor(path, language);
};

worker.getAllHandlers = function() {
    return handlers.getAllHandlers();
};

worker.getHandlerRegistry = function() {
    return handlers;
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_html",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var BaseHandler = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var handler = module.exports = Object.create(BaseHandler);

handler.extensions = ["htm", "html"];
handler.languages = ["html"];
handler.maxCallInterval = handler.CALL_INTERVAL_BASIC;

var TAGS = [
    { regex: /(?:^|\n)\s*<(xml|html)\b/g, kind: "package" },
    { regex: /(?:^|\n)\s*<(form|h1|body|head)\b/g, kind: "method", indent: 1 },
    { regex: /\sng-app=["']([A-Za-z0-9$_\.]+)/g, kind: "property", indent: 1 },
    { regex: /\sng-controller=["']([A-Za-z0-9$_\.]+)/g, kind: "property", indent: 1 },
    { regex: /\sng-repeat="[^\"]+ in ([^\"]+)/g, kind: "property2", indent: 1 },
    { regex: /\sng-repeat='[^\']+ in ([^\']+)/g, kind: "property2", indent: 1 },
    { regex: /\sng-click=["']([A-Za-z0-9$_\.]+)/g, kind: "property2", indent: 1 },
    { regex: /\sng-model=["']([A-Za-z0-9$_\.]+)/g, kind: "property2", indent: 1 },
    { regex: /\sdata-bind="[^"]*\b(?:foreach|click|value|checked):\s*(?:\$root\.)?([A-Za-z0-9$_\.]+)/g, kind: "property2", indent: 1 },
    { regex: /\sdata-bind='[^']*\b(?:foreach|click|value|checked):\s*(?:\$root\.)?([A-Za-z0-9$_\.]+)/g, kind: "property2", indent: 1 },
];
var GUESS_FARGS = false;
var EXTRACT_DOCS = false;

handler.init = function(options, callback) {
    callback();
};

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "" || doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });
    for (var id in results) {
        results[id].forEach(function(r) {
            r.noComplete = true;
        });
    }
    
    callback(null, { properties: results });
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_make",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)([A-Za-z0-9 \.].*?)\s*:(?!=)/g, kind: "property" },
    { regex: /(?:^|\n)([A-Za-z0-9].*?)\s*:=/g, kind: "property2" }
];
var GUESS_FARGS = false;
var EXTRACT_DOCS = false;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["makefile"];

handler.extensions = [];

handler.supportedPaths = "(^|\/)Makefile.*";

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(
            path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });
    callback(null, { properties: results });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_go",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*package\s+([^\s\(]+)/g, kind: "package" },
    { regex: /(?:^|\n)\s*type\s+([^\s\(]+)/g, kind: "method2", indent: 1 },
    { regex: /(?:^|\n)\s*func\s+([^\s\r\(]+)/g, kind: "method", indent: 1 },
    {
        regex: new RegExp(
            "(?:^|\\n)\\s*import\\s+([^ \\(]+)"
        ),
        kind: "import"
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["golang"];

handler.extensions = ["go"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    var serverHandler = jsonalyzer.getServerHandlerFor(path, "go");
    if (options.service || !serverHandler)
        return callback(null, { properties: results });
    
    serverHandler.analyzeCurrent(path, doc, ast, options, function(err, summary, markers) {
        if (err && err.code === "ESUPERSEDED")
            return callback(err);
        if (err)
            console.error(err.stack || err);
        return callback(null, { properties: results }, markers);
    });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_ctags",[], function(require, exports, module) {

var index = require("plugins/c9.ide.language.jsonalyzer/worker/semantic_index");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var ctags = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_ex");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");
var asyncForEach = require("plugins/c9.ide.language.core/worker").asyncForEach;
var workerUtil = require("plugins/c9.ide.language/worker_util");

var handler = module.exports = Object.create(PluginBase);

var IDLE_TIME = 50;

handler.languages = ctags.languages;

handler.extensions = ctags.extensions;

handler.isGeneric = true;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback();
    if ((options.service === "complete" || options.isSave) && index.get(path))
        return callback(null, index.get(path));
    if (options.language)
        path = ctags.pathForLanguage(options.language, path);
    ctags.analyze(path, doc, options, callback);
};

handler.analyzeOthers = function(paths, options, callback) {
    var errs = [];
    var results = [];
    var _self = this;
    asyncForEach(
        paths,
        function(path, next) {
            workerUtil.readFile(path, { unsaved: true }, function(err, doc) {
                if (err) {
                    errs.push(err);
                    results.push(null);
                    return next();
                }
                
                _self.analyzeCurrent(path, doc, null, {}, function(err, result) {
                    errs.push(err);
                    results.push(result);
                    next();
                });
            });
        },
        function() {
            callback(errs, results);
        }
    );
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_rb",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*module\s+([^ \(]+)/g, kind: "package" },
    { regex: /(?:^|\n)\s*class\s+([^ \(]+)/g, kind: "package" },
    { regex: /(?:^|\n)\s*def\s+([^ \(]+)/g, kind: "method" },
    {
        regex: new RegExp(
            "(?:^|\\n)\\s*include\\s+([^ \\(]+)"
        ),
        kind: "import"
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["ruby"];

handler.extensions = ["rb"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    var serverHandler = jsonalyzer.getServerHandlerFor(path, "ruby");
    if (options.service || !serverHandler)
        return callback(null, { properties: results });
    
    serverHandler.analyzeCurrent(path, doc, ast, options, function(err, summary, markers) {
        if (err && err.code === "ESUPERSEDED")
            return callback(err);
        if (err)
            console.error(err.stack || err);
        return callback(null, { properties: results }, markers);
    });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_sh",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*([A-Za-z0-9_]+)\(\)/g, kind: "method" },
    { regex: /(?:^|\n)\s*(\.|source)\s+([A-Za-z0-9_]+)/g, kind: "import" }
];
var GUESS_FARGS = false;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["sh"];

handler.extensions = ["sh"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(
            path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    var serverHandler = jsonalyzer.getServerHandlerFor(path, "sh");
    if (options.service || !serverHandler)
        return callback(null, { properties: results });
    
    serverHandler.analyzeCurrent(path, doc, ast, options, function(err, summary, markers) {
        if (err && err.code === "ESUPERSEDED")
            return callback(err);
        if (err)
            console.error(err.stack || err);
        return callback(null, { properties: results }, markers);
    });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_php",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*(?:abstract\s+)?class ([^ ]*)/g, kind: "package" },
    { regex: /(?:^|\n)\s*interface ([^ ]*)/g, kind: "package" },
    {
        regex: /(?:^|\n)\s*(?:public\s+|static\s+|abstract\s+|protected\s+|private\s+|final\s+)*function ([^ (]*)/g,
        kind: "method"
    },
    {
        regex: new RegExp(
            "(?:^|\n)\s*include\\("
            + "(?:\\$\\w+(?:\\[[\\w']+\\])?)?"
            + "(?:\\s*\\.\\s*)?",
            "g"
        ),
        kind: "import"
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["php"];

handler.extensions = ["php"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    var serverHandler = jsonalyzer.getServerHandlerFor(path, "php");
    if (options.service || !serverHandler)
        return callback(null, { properties: results });
    
    serverHandler.analyzeCurrent(path, doc, ast, options, function(err, summary, markers) {
        if (err && err.code === "ESUPERSEDED")
            return callback(err);
        if (err)
            console.error(err.stack || err);
        return callback(null, { properties: results }, markers);
    });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_md",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /^# (.*?)[#\s]*$/gm, kind: "property" },
    { regex: /^([A-Za-z0-9].*?)[ \t]*\n={2,}$/gm, kind: "property" },
    { regex: /^#{3,} (.*?)[# \t]*$/gm, kind: "property2", indent: 2 },
    { regex: /^([A-Za-z0-9].*?)[ \t]*\n-{3,}$/gm, kind: "property2", indent: 2 },
    { regex: /^#{2} (.*?)[# \t]*$/gm, kind: "property2", indent: 1 },
    { regex: /^([A-Za-z0-9].*?)[ \t]*\n-{2}$/gm, kind: "property2", indent: 1 },
];
var GUESS_FARGS = false;
var EXTRACT_DOCS = false;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["markdown"];

handler.extensions = ["md", "markdown"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(
            path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });
    callback(null, { properties: results });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.javascript.infer/path",[], function(require, exports, module) {

function getBasePath(file, workspaceDir) {
    if (file.substr(0, workspaceDir.length) === workspaceDir)
        file = file.substr(workspaceDir.length + 1);
    return file.replace(/\/?[^\/]*$/, "");
}

function canonicalizePath(path, basePath) {
    if (basePath && isRelativePath(path))
        path = basePath + "/" + path;
    return normalizePath(path).replace(/^\.\//, "");
}

function isRelativePath(path) {
    return !!path.match(/^\.\.\/|^\.\//);
}

function isAbsolutePath(path) {
    return !!path.match(/^\//);
}

function uncanonicalizePath(path, basePath) {
    if (basePath === "")
        return "./" + path;
    var pathParts = path.split("/");
    var basePathParts = basePath.split("/");
    for (var common = 0; common < basePathParts.length; common++)
        if (basePathParts[common] !== pathParts[common])
            break;
    var dirsUp = pathParts.length - 1 - common;
    var resultParts = [];
    for (var i = 0; i < dirsUp; i++)
        resultParts.push("..");
    if (!dirsUp)
        resultParts.push(".");
    for (var j = common; j < pathParts.length; j++)
        resultParts.push(pathParts[j]);
    return resultParts.join("/");
}

function normalizePath(path) {
    var isAbsolute = path.charAt(0) === '/',
        trailingSlash = path.substr(-1) === '/';

    path = normalizePathArray(path.split('/').filter(function(p) {
        return !!p;
    }), !isAbsolute).join('/');

    if (!path && !isAbsolute) {
        path = '.';
    }
    if (path && trailingSlash) {
        path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
}

function normalizePathArray(parts, allowAboveRoot) {
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
            parts.splice(i, 1);
        }
        else if (last === '..') {
            parts.splice(i, 1);
            up++;
        }
        else if (up) {
            parts.splice(i, 1);
            up--;
        }
    }
    if (allowAboveRoot) {
        for (; up--; up) {
            parts.unshift('..');
        }
    }

    return parts;
}

exports.canonicalizePath = canonicalizePath;
exports.uncanonicalizePath = uncanonicalizePath;
exports.getBasePath = getBasePath;
exports.isRelativePath = isRelativePath;
exports.isAbsolutePath = isAbsolutePath;
exports.normalizePath = normalizePath;

});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_js",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");
var pathUtil = require("plugins/c9.ide.language.javascript.infer/path");

var TAGS = [
    {
        regex: /function\s*([A-Za-z0-9$_]+)\s*\(/g,
        kind: "unknown2"
    },
    {
        regex: /exports\.([A-Za-z0-9$_]+)\s*=\s*function\b/g,
        kind: "unknown2"
    },
    {
        regex: /\s(\w+)\s*:\s*\w+(?:\s|,)/g,
        kind: "unknown2",
        docOnly: true
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.extensions = ["js", "jsx"];

handler.languages = ["javascript", "jsx"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, EXTRACT_DOCS, GUESS_FARGS, results);
    });
    for (var p in results) {
        if (results[p][0])
            results[p][0].kind = null;
    }
    callback(null, { properties: results });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    var openFiles = ctagsUtil.findMatchingOpenFiles(path);
    var astImports = findImportsInAST(path, ast);

    callback(null, openFiles.concat(astImports));
};

function findImportsInAST(path, ast) {
    if (!ast)
        return [];
    
    return []; // Don't import anything now that tern does this for us
    
    var basePath = path.match(/^(.*?)(\/[^\/]+)?$/)[1];
    return ast.collectTopDown(
        'Call(Var("require"), [String(required)])', function(b) {
            var name = b.required.value;
            if (name.match(/^text!/))
                return;
            var isFilePath = pathUtil.isAbsolutePath(name) || pathUtil.isRelativePath(name);
            if (!isFilePath)
                name = guessFilePath(basePath, name);
            if (!name)
                return;
            
            var result = isFilePath ? pathUtil.canonicalizePath(name, basePath) : "js_p:" + name;
            if (isFilePath && !result.match(/\.js$/))
                result += ".js";
            return result;
        }
    ).toArray();
}

function guessFilePath(basePath, importPath) {
    var baseDir = importPath.match(/[^\/]+/);
    if (!baseDir)
        return;
    var i = basePath.indexOf(baseDir[0]);
    if (i === -1)
        return;
    return basePath.substr(0, i) + importPath;
}

});

define("lodash",[], function(require, exports, module) {
  'use strict';
  var undefined;
  var arrayPool = [],
      objectPool = [];
  var idCounter = 0;
  var keyPrefix = +new Date + '';
  var largeArraySize = 75;
  var maxPoolSize = 40;
  var whitespace = (
    ' \t\x0B\f\xA0\ufeff' +
    '\n\r\u2028\u2029' +
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
  var reFlags = /\w*$/;
  var reFuncName = /^\s*function[ \n\r\t]+\w/;
  var reInterpolate = /<%=([\s\S]+?)%>/g;
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
  var reNoMatch = /($^)/;
  var reThis = /\bthis\b/;
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];
  var templateCounter = 0;
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };
  var root = (objectTypes[typeof window] && window) || this;
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    //
    return a.index - b.index;
  }
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }
  function getArray() {
    return arrayPool.pop() || [];
  }
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }
  function runInContext(context) {
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;
    var arrayRef = [];
    var objectProto = Object.prototype;
    var oldDash = context._;
    var toString = objectProto.toString;
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;
    var defineProperty = (function() {
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch (e) { }
      return result;
    }());
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;
    function lodash(value) {
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    lodashWrapper.prototype = lodash.prototype;
    var support = lodash.support = {};
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
    support.funcNames = typeof Function.name == 'string';
    lodash.templateSettings = {
      'escape': /<%-([\s\S]+?)%>/g,
      'evaluate': /<%([\s\S]+?)%>/g,
      'interpolate': reInterpolate,
      'variable': '',
      'imports': {
        '_': lodash
      }
    };
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (this instanceof bound) {
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      if (!isDeep) {
        return result;
      }
      stackA.push(value);
      stackB.push(result);
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      if (a === b) {
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      if (a == null || b == null) {
        return a === b;
      }
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          return +a == +b;

        case numberClass:
          return (a != +a)
            ? b != +b
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        if (className != objectClass) {
          return false;
        }
        var ctorA = a.constructor,
            ctorB = b.constructor;
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;
      stackA.push(a);
      stackB.push(b);
      if (isArr) {
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            size++;
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            stackA.push(source);
            stackB.push(value);
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };
    function shimIsPlainObject(value) {
      var ctor,
          result;
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };
    var shimKeys = function(object) {
      'use strict';
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result;
    };
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    var htmlUnescapes = invert(htmlEscapes);
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
    var assign = function(object, source, guard) {
      'use strict';
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result;
    };
    function clone(value, isDeep, callback, thisArg) {
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }
    var defaults = function(object, source, guard) {
      'use strict';
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result;
    };
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    var forIn = function(collection, callback, thisArg) {
      'use strict';
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result;
    };
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }
    var forOwn = function(collection, callback, thisArg) {
      'use strict';
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result;
    };
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }
    function isFunction(value) {
      return typeof value == 'function';
    }
    function isObject(value) {
      return !!(value && objectTypes[typeof value]);
    }
    function isNaN(value) {
      return isNumber(value) && value != +value;
    }
    function isNull(value) {
      return value === null;
    }
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }
    function isUndefined(value) {
      return typeof value == 'undefined';
    }
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }
    var pluck = map;
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection);
        });
      }
      return accumulator;
    }
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }
    var where = filter;
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }
    function flatten(array, isShallow, callback, thisArg) {
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }
    function uniq(array, isSorted, callback, thisArg) {
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      };
      memoized.cache = {};
      return memoized;
    }
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);
        func = null;
        return result;
      };
    }
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];
      if (props.length == 1 && a === a && !isObject(a)) {
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }
    function identity(value) {
      return value;
    }
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }
    function noConflict() {
      context._ = oldDash;
      return this;
    }
    function noop() {
    }
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };
    function property(key) {
      return function(object) {
        return object[key];
      };
    }
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }
    function template(text, data, options) {
      var settings = lodash.templateSettings;
      text = String(text || '');
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;
        return match;
      });

      source += "';\n";
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch (e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      result.source = source;
      return result;
    }
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }
    function wrapperToString() {
      return String(this.__wrapped__);
    }
    function wrapperValueOf() {
      return this.__wrapped__;
    }
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;
    mixin(lodash);
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {};
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName] = function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });
    lodash.VERSION = '2.4.1';
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }
  var _ = runInContext();
  return _; });

define("events",[], function(require, exports, module) {

var EventEmitter = exports.EventEmitter = function() {};

var toString = Object.prototype.toString;

var isArray = Array.isArray || function(obj) {
    return toString.call(obj) === '[object Array]';
};
//
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
    if (!this._events) this._events = {};
    this._events.maxListeners = n;
};
EventEmitter.prototype.emit = function(type) {
    if (!this._events) 
        return;

    var handler = this._events[type];
    if (!handler) 
        return;
    
    var returnValue;

    if (typeof handler == 'function') {
        switch (arguments.length) {
        case 1:
            return handler.call(this);
        case 2:
            return handler.call(this, arguments[1]);
        case 3:
            return handler.call(this, arguments[1], arguments[2]);
        default:
            var args = Array.prototype.slice.call(arguments, 1);
            returnValue = handler.apply(this, args);
        }
    }
    else if (isArray(handler)) {
        var args = Array.prototype.slice.call(arguments, 1);

        var listeners = handler.slice(), temp;
        for (var i = 0, l = listeners.length; i < l; i++) {
            temp = listeners[i].apply(this, args);
            if (temp !== undefined) 
                returnValue = temp;
        }
    }
    
    return returnValue;
};
EventEmitter.prototype.addListener = function(type, listener, plugin) {
    if ('function' !== typeof listener) {
        throw new Error('addListener only takes instances of Function');
    }

    if (!this._events) this._events = {};

    var eventList = this._events[type];

    if (!eventList) {
        this._events[type] = listener;
    }
    else if (isArray(eventList)) {
        if (!eventList.warned) {
            var m;
            if (this._events.maxListeners !== undefined) {
                m = this._events.maxListeners;
            }
            else {
                m = defaultMaxListeners;
            }

            if (m && m > 0 && eventList.length > m) {
                eventList.warned = true;
                console.error('warning: possible EventEmitter memory '
                    + 'leak detected. " + eventList.length + " listeners of type "' + type + '" added. '
                    + 'Use emitter.setMaxListeners() to increase limit.'
                );
                console.trace();
            }
        }
        eventList.push(listener);
    }
    else {
        this._events[type] = [eventList, listener];
    }
    
    if (type != "newListener") 
        this.emit('newListener', type, listener);
    
    plugin && plugin.addEvent(this, type, listener);

    return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener, plugin) {
    var self = this;
    
    var wrapped = function() {
        self.removeListener(type, listener);
        return listener.apply(self, arguments);
    };
    wrapped.listener = listener;
    
    self.on(type, wrapped, plugin);

    return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
    if ('function' !== typeof listener) {
        throw new Error('removeListener only takes instances of Function');
    }
    if (!this._events || !this._events[type]) return this;

    var list = this._events[type];

    if (isArray(list)) {
        if (!list.some(function(l, i) {
            if ((l.listener || l) == listener) {
                list.splice(i, 1);
                return true;
            }
        })) return this;
        
        if (list.length === 0) 
            delete this._events[type];
    }
    else if ((this._events[type].listener || this._events[type]) === listener) {
        delete this._events[type];
    }
    
    if (type != "removeListener")
        this.emit('removeListener', type, listener);

    return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function(type) {
    if (type && this._events && this._events[type]) this._events[type] = null;
    return this;
};

EventEmitter.prototype.listeners = function(type) {
    if (!this._events) this._events = {};
    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
        this._events[type] = [this._events[type]];
    }
    return this._events[type];
};
 
});

define("plugins/c9.ide.language.javascript.eslint/worker/eslint_browserified",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function() {
var require=(function outer (modules, cache, entry) {
    var previousRequire = typeof require == "function" && require;

    function newRequire(name, jumped){
        if(!cache[name]) {
            if(!modules[name]) {
                var currentRequire = typeof require == "function" && require;
                if (!jumped && currentRequire) return currentRequire(name, true);

                if (previousRequire) return previousRequire(name, true);
                var err = new Error('Cannot find module \'' + name + '\'');
                err.code = 'MODULE_NOT_FOUND';
                throw err;
            }
            var m = cache[name] = {exports:{}};
            modules[name][0].call(m.exports, function(x){
                var id = modules[name][1][x];
                return newRequire(id ? id : x);
            },m,m.exports,outer,modules,cache,entry);
        }
        return cache[name].exports;
    }
    for(var i=0;i<entry.length;i++) newRequire(entry[i]);

    return newRequire;
})({
"/../acorn/dist/acorn.js": [function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/src\\expression.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var pp = _state.Parser.prototype;

pp.checkPropClash = function (prop, propHash) {
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
  var key = prop.key;var name = undefined;
  switch (key.type) {
    case "Identifier":
      name = key.name;break;
    case "Literal":
      name = String(key.value);break;
    default:
      return;
  }
  var kind = prop.kind;

  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var isGetSet = kind !== "init";
    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raiseRecoverable(key.start, "Redefinition of property");
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

pp.parseExpression = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === _tokentype.types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

pp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) return this.parseYield();

  var validateDestructuring = false;
  if (!refDestructuringErrors) {
    refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
    validateDestructuring = true;
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.type.isAssign) {
    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true);
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
    refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return left;
};

pp.parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  if (this.eat(_tokentype.types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(_tokentype.types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

pp.parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
};

pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
    if (prec > minPrec) {
      var logical = this.type === _tokentype.types.logicalOR || this.type === _tokentype.types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start,
          startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }
  return left;
};

pp.buildBinary = function (startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};

pp.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
  var startPos = this.start,
      startLoc = this.startLoc,
      expr = undefined;
  if (this.type.prefix) {
    var node = this.startNode(),
        update = this.type === _tokentype.types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raiseRecoverable(node.start, "Deleting local variable in strict mode");else sawUnary = true;
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.prefix = false;
      node.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(_tokentype.types.starstar)) return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);else return expr;
};

pp.parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
  return this.parseSubscripts(expr, startPos, startLoc);
};

pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  for (;;) {
    if (this.eat(_tokentype.types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseIdent(true);
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.eat(_tokentype.types.bracketL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.expect(_tokentype.types.bracketR);
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      node.arguments = this.parseExprList(_tokentype.types.parenR, false);
      base = this.finishNode(node, "CallExpression");
    } else if (this.type === _tokentype.types.backQuote) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate();
      base = this.finishNode(node, "TaggedTemplateExpression");
    } else if (this.type == _tokentype.types.colon && this.input[this.end] == ":") {
      this.next();
      this.next();
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [base];
      var e2 = this.parseExpression();
      node.expressions.push(e2);
      base = this.finishNode(node, "SequenceExpression");
    } else {
      return base;
    }
  }
};

pp.parseExprAtom = function (refDestructuringErrors) {
  var node = undefined,
      canBeArrow = this.potentialArrowAt == this.start;
  switch (this.type) {
    case _tokentype.types._super:
      if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");

    case _tokentype.types._this:
      var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case _tokentype.types.name:
      if (this.value == "async" && /^[ \t]*(function\b|\(|\w+[ \t]*=>)/.test(this.input.slice(this.end))) {
        node = this.startNode();
        this.next();
        this.potentialArrowAt = this.start;
        return this.parseExprAtom(refDestructuringErrors);
      }
      if (this.value == "await" && /^[ \t]+[\w\x1f-\uffff]/.test(this.input.slice(this.end))) {
        node = this.startNode();
        this.next();
        return this.parseExprAtom(refDestructuringErrors);
      }

      var startPos = this.start,
          startLoc = this.startLoc;
      var id = this.parseIdent(this.type !== _tokentype.types.name);
      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
      return id;

    case _tokentype.types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;

    case _tokentype.types.num:case _tokentype.types.string:
      return this.parseLiteral(this.value);

    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
      node = this.startNode();
      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case _tokentype.types.parenL:
      return this.parseParenAndDistinguishExpression(canBeArrow);

    case _tokentype.types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");

    case _tokentype.types.braceL:
      return this.parseObj(false, refDestructuringErrors);

    case _tokentype.types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case _tokentype.types._class:
      return this.parseClass(this.startNode(), false);

    case _tokentype.types._new:
      return this.parseNew();

    case _tokentype.types.backQuote:
      return this.parseTemplate();

    case _tokentype.types._do:
      this.next();
      return this.parseStatement();
    case _tokentype.types.at:
      this.next();
      return this.parseExprAtom();
    case _tokentype.types.colon:
      if (this.input[this.end] == ":") {
         this.next();
         this.next();
         return this.parseExprSubscripts(refDestructuringErrors);
      }

    default:
      this.unexpected();
  }
};

pp.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal");
};

pp.parseParenExpression = function () {
  this.expect(_tokentype.types.parenL);
  var val = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  return val;
};

pp.parseParenAndDistinguishExpression = function (canBeArrow) {
  var startPos = this.start,
      startLoc = this.startLoc,
      val = undefined;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start,
        innerStartLoc = this.startLoc;
    var exprList = [],
        first = true;
    var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 },
        spreadStart = undefined,
        innerParenStart = undefined;
    while (this.type !== _tokentype.types.parenR) {
      first ? first = false : this.expect(_tokentype.types.comma);
      if (this.type === _tokentype.types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRest()));
        break;
      } else {
        if (this.type === _tokentype.types.parenL && !innerParenStart) {
          innerParenStart = this.start;
        }
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start,
        innerEndLoc = this.startLoc;
    this.expect(_tokentype.types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, true);
      if (innerParenStart) this.unexpected(innerParenStart);
      return this.parseParenArrowList(startPos, startLoc, exprList);
    }

    if (!exprList.length) this.unexpected(this.lastTokStart);
    if (spreadStart) this.unexpected(spreadStart);
    this.checkExpressionErrors(refDestructuringErrors, true);

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};

pp.parseParenItem = function (item) {
  return item;
};

pp.parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
};

var empty = [];

pp.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
    if (!this.inFunction) this.raiseRecoverable(node.start, "new.target can only be used in functions");
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;
  return this.finishNode(node, "NewExpression");
};

pp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
    cooked: this.value
  };
  this.next();
  elem.tail = this.type === _tokentype.types.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(_tokentype.types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(_tokentype.types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement());
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

pp.parseObj = function (isPattern, refDestructuringErrors) {
  var node = this.startNode(),
      first = true,
      propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;
    if (this.value == "async" && /^[ \t]*\w+/.test(this.input.slice(this.end))) this.next();

    var prop = this.startNode(),
        isGenerator = undefined,
        startPos = undefined,
        startLoc = undefined;
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
    }

    this.parsePropertyName(prop);
    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
    this.checkPropClash(prop, propHash);
    node.properties.push(this.finishNode(prop, "Property"));
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
  if (this.eat(_tokentype.types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
    if (isPattern) this.unexpected();
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator);
  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {
    if (isGenerator || isPattern) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
    }
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    prop.kind = "init";
    if (isPattern) {
      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) || this.inGenerator && prop.key.name == "yield") this.raiseRecoverable(prop.key.start, "Binding " + prop.key.name);
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === _tokentype.types.eq && refDestructuringErrors) {
      if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else this.unexpected();
};

pp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(_tokentype.types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(_tokentype.types.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
};

pp.initFunction = function (node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
};

pp.parseMethod = function (isGenerator) {
  var node = this.startNode(),
      oldInGen = this.inGenerator;
  this.inGenerator = isGenerator;
  this.initFunction(node);
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
  if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
  this.parseFunctionBody(node, false);
  this.inGenerator = oldInGen;
  return this.finishNode(node, "FunctionExpression");
};

pp.parseArrowExpression = function (node, params) {
  var oldInGen = this.inGenerator;
  this.inGenerator = false;
  this.initFunction(node);
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);
  this.inGenerator = oldInGen;
  return this.finishNode(node, "ArrowFunctionExpression");
};

pp.parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    var oldInFunc = this.inFunction,
        oldLabels = this.labels;
    this.inFunction = true;this.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.inFunction = oldInFunc;this.labels = oldLabels;
  }

  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
    var oldStrict = this.strict;
    this.strict = true;
    if (node.id) this.checkLVal(node.id, true);
    this.checkParams(node);
    this.strict = oldStrict;
  } else if (isArrowFunction) {
    this.checkParams(node);
  }
};

pp.checkParams = function (node) {
  var nameHash = {};
  for (var i = 0; i < node.params.length; i++) {
    this.checkLVal(node.params[i], true, nameHash);
  }
};

pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
        refDestructuringErrors.trailingComma = this.lastTokStart;
      }
      if (allowTrailingComma && this.afterTrailingComma(close)) break;
    } else first = false;

    var elt = undefined;
    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refDestructuringErrors);else elt = this.parseMaybeAssign(false, refDestructuringErrors);
    elts.push(elt);
  }
  return elts;
};

pp.parseIdent = function (liberal) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved == "never") liberal = false;
  if (this.type === _tokentype.types.name) {
    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved");
    if (!liberal && this.inGenerator && this.value === "yield") this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator");
    node.name = this.value;
  } else if (liberal && this.type.keyword) {
    node.name = this.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "Identifier");
};

pp.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(_tokentype.types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js"}],"/src\\identifier.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierChar = isIdentifierChar;
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  7: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

exports.reservedWords = reservedWords;
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};

exports.keywords = keywords;
function isIdentifierStart(code, astral) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  return code >= 0xaa;
}

function isIdentifierChar(code, astral) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  return code >= 0xaa;
}

},{}],"/src\\index.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;

var _state = _dereq_("./state");

_dereq_("./parseutil");

_dereq_("./statement");

_dereq_("./lval");

_dereq_("./expression");

_dereq_("./location");

exports.Parser = _state.Parser;
exports.plugins = _state.plugins;

var _options = _dereq_("./options");

exports.defaultOptions = _options.defaultOptions;

var _locutil = _dereq_("./locutil");

exports.Position = _locutil.Position;
exports.SourceLocation = _locutil.SourceLocation;
exports.getLineInfo = _locutil.getLineInfo;

var _node = _dereq_("./node");

exports.Node = _node.Node;

var _tokentype = _dereq_("./tokentype");

exports.TokenType = _tokentype.TokenType;
exports.tokTypes = _tokentype.types;

var _tokencontext = _dereq_("./tokencontext");

exports.TokContext = _tokencontext.TokContext;
exports.tokContexts = _tokencontext.types;

var _identifier = _dereq_("./identifier");

exports.isIdentifierChar = _identifier.isIdentifierChar;
exports.isIdentifierStart = _identifier.isIdentifierStart;

var _tokenize = _dereq_("./tokenize");

exports.Token = _tokenize.Token;

var _whitespace = _dereq_("./whitespace");

exports.isNewLine = _whitespace.isNewLine;
exports.lineBreak = _whitespace.lineBreak;
exports.lineBreakG = _whitespace.lineBreakG;
var version = "3.0.2";

exports.version = version;
function parse(input, options) {
  return new _state.Parser(options, input).parse();
}

function parseExpressionAt(input, pos, options) {
  var p = new _state.Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression();
}

function tokenizer(input, options) {
  return new _state.Parser(options, input);
}

},{"./expression":"/src\\expression.js","./identifier":"/src\\identifier.js","./location":"/src\\location.js","./locutil":"/src\\locutil.js","./lval":"/src\\lval.js","./node":"/src\\node.js","./options":"/src\\options.js","./parseutil":"/src\\parseutil.js","./state":"/src\\state.js","./statement":"/src\\statement.js","./tokencontext":"/src\\tokencontext.js","./tokenize":"/src\\tokenize.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\location.js":[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var pp = _state.Parser.prototype;

pp.raise = function (pos, message) {
  var loc = _locutil.getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
  throw err;
};

pp.raiseRecoverable = pp.raise;

pp.curPosition = function () {
  if (this.options.locations) {
    return new _locutil.Position(this.curLine, this.pos - this.lineStart);
  }
};

},{"./locutil":"/src\\locutil.js","./state":"/src\\state.js"}],"/src\\locutil.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getLineInfo = getLineInfo;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _whitespace = _dereq_("./whitespace");

var Position = (function () {
  function Position(line, col) {


    this.line = line;
    this.column = col;
  }

  Position.prototype.offset = function offset(n) {
    return new Position(this.line, this.column + n);
  };

  return Position;
})();

exports.Position = Position;

var SourceLocation = function SourceLocation(p, start, end) {


  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) this.source = p.sourceFile;
};

exports.SourceLocation = SourceLocation;

function getLineInfo(input, offset) {
  for (var line = 0, cur = 0;;) {
    _whitespace.lineBreakG.lastIndex = cur;
    var match = _whitespace.lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
}

},{"./whitespace":"/src\\whitespace.js"}],"/src\\lval.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _util = _dereq_("./util");

var pp = _state.Parser.prototype;

pp.toAssignable = function (node, isBinding) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var i = 0; i < node.properties.length; i++) {
          var prop = node.properties[i];
          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
          this.toAssignable(prop.value, isBinding);
        }
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator
          ;
        } else {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
          break;
        }

      case "AssignmentPattern":
        if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value");
        break;

      case "ParenthesizedExpression":
        node.expression = this.toAssignable(node.expression, isBinding);
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  }
  return node;
};

pp.toAssignableList = function (exprList, isBinding) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type == "RestElement") {
      --end;
    } else if (last && last.type == "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
      --end;
    }

    if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this.toAssignable(elt, isBinding);
  }
  return exprList;
};

pp.parseSpread = function (refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};

pp.parseRest = function (allowNonIdent) {
  var node = this.startNode();
  this.next();

  if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();

  return this.finishNode(node, "RestElement");
};

pp.parseBindingAtom = function () {
  if (this.options.ecmaVersion < 6) return this.parseIdent();
  switch (this.type) {
    case _tokentype.types.name:
      return this.parseIdent();

    case _tokentype.types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern");

    case _tokentype.types.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

pp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (first) first = false;else this.expect(_tokentype.types.comma);
    if (allowEmpty && this.type === _tokentype.types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === _tokentype.types.ellipsis) {
      var rest = this.parseRest(allowNonIdent);
      this.parseBindingListItem(rest);
      elts.push(rest);
      this.expect(close);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};

pp.parseBindingListItem = function (param) {
  return param;
};

pp.parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};

pp.checkLVal = function (expr, isBinding, checkClashes) {
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      if (checkClashes) {
        if (_util.has(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
        checkClashes[expr.name] = true;
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var i = 0; i < expr.properties.length; i++) {
        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
      }break;

    case "ArrayPattern":
      for (var i = 0; i < expr.elements.length; i++) {
        var elem = expr.elements[i];
        if (elem) this.checkLVal(elem, isBinding, checkClashes);
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes);
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes);
      break;

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, isBinding, checkClashes);
      break;

    default:
      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
  }
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./util":"/src\\util.js"}],"/src\\node.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var Node = function Node(parser, pos, loc) {


  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
  if (parser.options.ranges) this.range = [pos, 0];
};

exports.Node = Node;

var pp = _state.Parser.prototype;

pp.startNode = function () {
  return new Node(this, this.start, this.startLoc);
};

pp.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
};

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) node.loc.end = loc;
  if (this.options.ranges) node.range[1] = pos;
  return node;
}

pp.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};

pp.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};

},{"./locutil":"/src\\locutil.js","./state":"/src\\state.js"}],"/src\\options.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getOptions = getOptions;

var _util = _dereq_("./util");

var _locutil = _dereq_("./locutil");

var defaultOptions = {
  ecmaVersion: 6,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowHashBang: false,
  locations: true,
  onToken: null,
  onComment: null,
  ranges: false,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: false,
  plugins: {}
};

exports.defaultOptions = defaultOptions;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;

  if (_util.isArray(options.onToken)) {
    (function () {
      var tokens = options.onToken;
      options.onToken = function (token) {
        return tokens.push(token);
      };
    })();
  }
  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
    if (options.ranges) comment.range = [start, end];
    array.push(comment);
  };
}

},{"./locutil":"/src\\locutil.js","./util":"/src\\util.js"}],"/src\\parseutil.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var pp = _state.Parser.prototype;

pp.isUseStrict = function (stmt) {
  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
};

pp.eat = function (type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};

pp.isContextual = function (name) {
  return this.type === _tokentype.types.name && this.value === name;
};

pp.eatContextual = function (name) {
  return this.value === name && this.eat(_tokentype.types.name);
};

pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) this.unexpected();
};

pp.canInsertSemicolon = function () {
  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    return true;
  }
};

pp.semicolon = function () {
  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
};

pp.afterTrailingComma = function (tokType) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    this.next();
    return true;
  }
};

pp.expect = function (type) {
  this.eat(type) || this.unexpected();
};

pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

pp.checkPatternErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.trailingComma;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Trailing comma is not permitted in destructuring patterns");
};

pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\state.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var _options = _dereq_("./options");

var plugins = {};

exports.plugins = plugins;
function keywordRegexp(words) {
  return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
}

var Parser = (function () {
  function Parser(options, input, startPos) {


    this.options = options = _options.getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
    var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
    this.reservedWords = keywordRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
    this.reservedWordsStrict = keywordRegexp(reservedStrict);
    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
    this.input = String(input);

    this.containsEsc = false;

    this.loadPlugins(options.plugins);

    if (startPos) {
      this.pos = startPos;
      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 0;
    }

    this.type = _tokentype.types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    this.context = this.initialContext();
    this.exprAllowed = true;

    this.strict = this.inModule = options.sourceType === "module";

    this.potentialArrowAt = -1;

    this.inFunction = this.inGenerator = false;
    this.labels = [];

    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
  }

  Parser.prototype.isKeyword = function isKeyword(word) {
    return this.keywords.test(word);
  };

  Parser.prototype.isReservedWord = function isReservedWord(word) {
    return this.reservedWords.test(word);
  };

  Parser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
    for (var _name in pluginConfigs) {
      var plugin = plugins[_name];
      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
      plugin(this, pluginConfigs[_name]);
    }
  };

  Parser.prototype.parse = function parse() {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node);
  };

  return Parser;
})();

exports.Parser = Parser;

},{"./identifier":"/src\\identifier.js","./options":"/src\\options.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\statement.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var _identifier = _dereq_("./identifier");

var pp = _state.Parser.prototype;

pp.parseTopLevel = function (node) {
  var first = true;
  if (!node.body) node.body = [];
  while (this.type !== _tokentype.types.eof) {
    var stmt = this.parseStatement(true, true);
    node.body.push(stmt);
    if (first) {
      if (this.isUseStrict(stmt)) this.setStrict(true);
      first = false;
    }
  }
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

var loopLabel = { kind: "loop" },
    switchLabel = { kind: "switch" };

pp.isLet = function () {
  if (this.type !== _tokentype.types.name || this.options.ecmaVersion < 6 || this.value != "let") return false;
  _whitespace.skipWhiteSpace.lastIndex = this.pos;
  var skip = _whitespace.skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length,
      nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh == 123) return true; // '{' and '['
  if (_identifier.isIdentifierStart(nextCh, true)) {
    for (var pos = next + 1; _identifier.isIdentifierChar(this.input.charCodeAt(pos, true)); ++pos) {}
    var ident = this.input.slice(next, pos);
    if (!this.isKeyword(ident)) return true;
  }
  return false;
};

pp.parseStatement = function (declaration, topLevel) {
  var starttype = this.type,
      node = this.startNode(),
      kind = undefined;

  if (this.isLet()) {
    starttype = _tokentype.types._var;
    kind = "let";
  }

  switch (starttype) {
    case _tokentype.types._break:case _tokentype.types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case _tokentype.types._debugger:
      return this.parseDebuggerStatement(node);
    case _tokentype.types._do:
      return this.parseDoStatement(node);
    case _tokentype.types._for:
      return this.parseForStatement(node);
    case _tokentype.types._function:
      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
      return this.parseFunctionStatement(node);
    case _tokentype.types._class:
      if (!declaration) this.unexpected();
      return this.parseClass(node, true);
    case _tokentype.types._if:
      return this.parseIfStatement(node);
    case _tokentype.types._return:
      return this.parseReturnStatement(node);
    case _tokentype.types._switch:
      return this.parseSwitchStatement(node);
    case _tokentype.types._throw:
      return this.parseThrowStatement(node);
    case _tokentype.types._try:
      return this.parseTryStatement(node);
    case _tokentype.types._const:case _tokentype.types._var:
      kind = kind || this.value;
      if (!declaration && kind != "var") this.unexpected();
      return this.parseVarStatement(node, kind);
    case _tokentype.types._while:
      return this.parseWhileStatement(node);
    case _tokentype.types._with:
      return this.parseWithStatement(node);
    case _tokentype.types.braceL:
      return this.parseBlock();
    case _tokentype.types.semi:
      return this.parseEmptyStatement(node);
    case _tokentype.types._export:
    case _tokentype.types._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
      }
      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);

    case _tokentype.types.at:
      this.next();
      return this.parseExpression();
    default:
      var maybeName = this.value,
          expr = this.parseExpression();
      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr);
      }
      else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};

pp.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword == "break";
  this.next();
  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  for (var i = 0; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(_tokentype.types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
  return this.finishNode(node, "DoWhileStatement");
};

pp.parseForStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  this.expect(_tokentype.types.parenL);
  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
  var isLet = this.isLet();
  if (this.type === _tokentype.types._var || this.type === _tokentype.types._const || isLet) {
    var _init = this.startNode(),
        kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(_init, true, kind);
    this.finishNode(_init, "VariableDeclaration");
    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(kind !== "var" && _init.declarations[0].init)) return this.parseForIn(node, _init);
    return this.parseFor(node, _init);
  }
  var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
    this.checkPatternErrors(refDestructuringErrors, true);
    this.toAssignable(init);
    this.checkLVal(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return this.parseFor(node, init);
};

pp.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

pp.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
  this.next();

  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
    node.argument = this.parseExpression();this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};

pp.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(_tokentype.types.braceL);
  this.labels.push(switchLabel);

  for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {
    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
      var isCase = this.type === _tokentype.types._case;
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(_tokentype.types.colon);
    } else {
      if (!cur) this.unexpected();
      cur.consequent.push(this.parseStatement(true));
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp.parseThrowStatement = function (node) {
  this.next();
  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};

var empty = [];

pp.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === _tokentype.types._catch) {
    var clause = this.startNode();
    this.next();
    this.expect(_tokentype.types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true);
    this.expect(_tokentype.types.parenR);
    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
  return this.finishNode(node, "TryStatement");
};

pp.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp.parseWithStatement = function (node) {
  if (this.strict) this.raise(this.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp.parseLabeledStatement = function (node, maybeName, expr) {
  for (var i = 0; i < this.labels.length; ++i) {
    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label = this.labels[i];
    if (label.statementStart == node.start) {
      label.statementStart = this.start;
      label.kind = kind;
    } else break;
  }
  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
  node.body = this.parseStatement(true);
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};

pp.parseBlock = function (allowStrict) {
  var node = this.startNode(),
      first = true,
      oldStrict = undefined;
  node.body = [];
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    var stmt = this.parseStatement(true);
    node.body.push(stmt);
    if (first && allowStrict && this.isUseStrict(stmt)) {
      oldStrict = this.strict;
      this.setStrict(this.strict = true);
    }
    first = false;
  }
  if (oldStrict === false) this.setStrict(false);
  return this.finishNode(node, "BlockStatement");
};

pp.parseFor = function (node, init) {
  node.init = init;
  this.expect(_tokentype.types.semi);
  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
  this.expect(_tokentype.types.semi);
  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};

pp.parseForIn = function (node, init) {
  var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type);
};

pp.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl);
    if (this.eat(_tokentype.types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(_tokentype.types.comma)) break;
  }
  return node;
};

pp.parseVarId = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true);
};

pp.parseFunction = function (node, isStatement, allowExpressionBody) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
  var oldInGen = this.inGenerator;
  this.inGenerator = node.generator;
  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);
  this.inGenerator = oldInGen;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp.parseFunctionParams = function (node) {
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true);
};

pp.parseClass = function (node, isStatement) {
  this.next();
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(_tokentype.types.braceL);
  var decorators = [];
  while (!this.eat(_tokentype.types.braceR)) {
    if (this.eat(_tokentype.types.semi)) continue;
    if (this.type == _tokentype.types.at) {
      this.next();
      var expr = this.parseMaybeAssign(true);
      decorators.push(expr);
      continue;
    }
    if (this.value == "async" && /^[ \t]*\w+/.test(this.input.slice(this.end))) this.next();
    var method = this.startNode();
    var isGenerator = this.eat(_tokentype.types.star);
    var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
    this.parsePropertyName(method);
    method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
    if (method["static"]) {
      if (isGenerator) this.unexpected();
      isGenerator = this.eat(_tokentype.types.star);
      this.parsePropertyName(method);
    }
    method.kind = "method";
    var isGetSet = false;
    if (!method.computed) {
      var key = method.key;

      if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) {
        isGetSet = true;
        method.kind = key.name;
        key = this.parsePropertyName(method);
      }
      if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
        method.kind = "constructor";
        hadConstructor = true;
      }
    }

    if (this.type == _tokentype.types.eq) {
      this.next();
      method.value = this.parseExpression();
    } else if (this.type == _tokentype.types.semi || this.canInsertSemicolon()) {
      if (this.type == _tokentype.types.semi) this.next();
      var _node = this.startNode();
      _node.body = [];
      method.value = this.finishNode(_node, "BlockStatement");
    }
    if (method.value) {
      method.kind = 'class'
      classBody.body.push(this.finishNode(method, "Property"));
      continue;
    }

    this.parseClassMethod(classBody, method, isGenerator);

    if (decorators.length) {
      var body = method.value.body.body;
      if (body) body.unshift.apply(body, decorators);
      decorators = [];
    }
    if (isGetSet) {
      var paramCount = method.kind === "get" ? 0 : 1;
      if (method.value.params.length !== paramCount) {
        var start = method.value.start;
        if (method.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
      }
      if (method.kind === "set" && method.value.params[0].type === "RestElement") this.raise(method.value.params[0].start, "Setter cannot use rest params");
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp.parseClassMethod = function (classBody, method, isGenerator) {
  method.value = this.parseMethod(isGenerator);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp.parseClassId = function (node, isStatement) {
  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
};

pp.parseClassSuper = function (node) {
  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
};

pp.parseExport = function (node) {
  this.next();
  if (this.eat(_tokentype.types.star)) {
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(_tokentype.types._default)) {
    var parens = this.type == _tokentype.types.parenL;
    var expr = this.parseMaybeAssign();
    var needsSemi = true;
    if (!parens && (expr.type == "FunctionExpression" || expr.type == "ClassExpression")) {
      needsSemi = false;
      if (expr.id) {
        expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
      }
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    if (this.eatContextual("from")) {
      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    } else {
      for (var i = 0; i < node.specifiers.length; i++) {
        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
          this.unexpected(node.specifiers[i].local.start);
        }
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp.shouldParseExportStatement = function () {
  return this.type.keyword || this.isLet();
};

pp.parseExportSpecifiers = function () {
  var nodes = [],
      first = true;
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.local = this.parseIdent(this.type === _tokentype.types._default);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes;
};

pp.parseImport = function (node) {
  this.next();
  if (this.type === _tokentype.types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

pp.parseImportSpecifiers = function () {
  var nodes = [],
      first = true;
  if (this.type === _tokentype.types.name) {
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(_tokentype.types.comma)) return nodes;
  }
  if (this.type === _tokentype.types.star) {
    var node = this.startNode();
    this.next();
    this.expectContextual("as");
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.imported = this.parseIdent(true);
    if (this.eatContextual("as")) {
      node.local = this.parseIdent();
    } else {
      node.local = node.imported;
      if (this.isKeyword(node.local.name)) this.unexpected(node.local.start);
      if (this.reservedWordsStrict.test(node.local.name)) this.raise(node.local.start, "The keyword '" + node.local.name + "' is reserved");
    }
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportSpecifier"));
  }
  return nodes;
};

},{"./identifier":"/src\\identifier.js","./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokencontext.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {


  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

exports.TokContext = TokContext;
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", true),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  f_expr: new TokContext("function", true)
};

exports.types = types;
var pp = _state.Parser.prototype;

pp.initialContext = function () {
  return [types.b_stat];
};

pp.braceIsBlock = function (prevType) {
  if (prevType === _tokentype.types.colon) {
    var _parent = this.curContext();
    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
  }
  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
  return !this.exprAllowed;
};

pp.updateContext = function (prevType) {
  var update = undefined,
      type = this.type;
  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
};

_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
  if (this.context.length == 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext() === types.f_expr) {
    this.context.pop();
    this.exprAllowed = false;
  } else if (out === types.b_tmpl) {
    this.exprAllowed = true;
  } else {
    this.exprAllowed = !out.isExpr;
  }
};

_tokentype.types.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

_tokentype.types.dollarBraceL.updateContext = function () {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

_tokentype.types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

_tokentype.types.incDec.updateContext = function () {};

_tokentype.types._function.updateContext = function () {
  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
  this.exprAllowed = false;
};

_tokentype.types.backQuote.updateContext = function () {
  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
  this.exprAllowed = false;
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokenize.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var _whitespace = _dereq_("./whitespace");

var Token = function Token(p) {


  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
  if (p.options.ranges) this.range = [p.start, p.end];
};

exports.Token = Token;

var pp = _state.Parser.prototype;

var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";

pp.next = function () {
  if (this.options.onToken) this.options.onToken(new Token(this));

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp.getToken = function () {
  this.next();
  return new Token(this);
};

if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
  var self = this;
  return { next: function next() {
      var token = self.getToken();
      return {
        done: token.type === _tokentype.types.eof,
        value: token
      };
    } };
};

pp.setStrict = function (strict) {
  this.strict = strict;
  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
  this.pos = this.start;
  if (this.options.locations) {
    while (this.pos < this.lineStart) {
      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
      --this.curLine;
    }
  }
  this.nextToken();
};

pp.curContext = function () {
  return this.context[this.context.length - 1];
};

pp.nextToken = function () {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) this.skipSpace();

  this.start = this.pos;
  if (this.options.locations) this.startLoc = this.curPosition();
  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);

  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
};

pp.readToken = function (code) {
  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

  return this.getTokenFromCode(code);
};

pp.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) return code;
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00;
};

pp.skipBlockComment = function () {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos,
      end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
  this.pos = end + 2;
  if (this.options.locations) {
    _whitespace.lineBreakG.lastIndex = start;
    var match = undefined;
    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};

pp.skipLineComment = function (startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
    ++this.pos;
    ch = this.input.charCodeAt(this.pos);
  }
  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};

pp.skipSpace = function () {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:case 8232:case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};

pp.finishToken = function (type, val) {
  this.end = this.pos;
  if (this.options.locations) this.endLoc = this.curPosition();
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

pp.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) return this.readNumber(true);
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(_tokentype.types.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(_tokentype.types.dot);
  }
};

pp.readToken_slash = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;return this.readRegexp();
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.slash, 1);
};

pp.readToken_mult_modulo_exp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? _tokentype.types.star : _tokentype.types.modulo;

  if (this.options.ecmaVersion >= 7 && next === 42) {
    ++size;
    tokentype = _tokentype.types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) return this.finishOp(_tokentype.types.assign, size + 1);
  return this.finishOp(tokentype, size);
};

pp.readToken_pipe_amp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
};

pp.readToken_caret = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.bitwiseXOR, 1);
};

pp.readToken_plus_min = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(_tokentype.types.incDec, 2);
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.plusMin, 1);
};

pp.readToken_lt_gt = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
    return this.finishOp(_tokentype.types.bitShift, size);
  }
  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
    if (this.inModule) this.unexpected();
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) size = 2;
  return this.finishOp(_tokentype.types.relational, size);
};

pp.readToken_eq_excl = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(_tokentype.types.arrow);
  }
  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
};

pp.getTokenFromCode = function (code) {
  switch (code) {
    case 46:
      return this.readToken_dot();

    case 40:
      ++this.pos;return this.finishToken(_tokentype.types.parenL);
    case 41:
      ++this.pos;return this.finishToken(_tokentype.types.parenR);
    case 59:
      ++this.pos;return this.finishToken(_tokentype.types.semi);
    case 44:
      ++this.pos;return this.finishToken(_tokentype.types.comma);
    case 91:
      ++this.pos;return this.finishToken(_tokentype.types.bracketL);
    case 93:
      ++this.pos;return this.finishToken(_tokentype.types.bracketR);
    case 123:
      ++this.pos;return this.finishToken(_tokentype.types.braceL);
    case 125:
      ++this.pos;return this.finishToken(_tokentype.types.braceR);
    case 58:
      ++this.pos;return this.finishToken(_tokentype.types.colon);
    case 63:
      ++this.pos;return this.finishToken(_tokentype.types.question);

    case 96:
      if (this.options.ecmaVersion < 6) break;
      ++this.pos;
      return this.finishToken(_tokentype.types.backQuote);

    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number
        ;
      }
    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
      return this.readNumber(false);

    case 34:case 39:
      return this.readString(code);

    case 47:
      return this.readToken_slash();

    case 37:case 42:
      return this.readToken_mult_modulo_exp(code);

    case 124:case 38:
      return this.readToken_pipe_amp(code);

    case 94:
      return this.readToken_caret();

    case 43:case 45:
      return this.readToken_plus_min(code);

    case 60:case 62:
      return this.readToken_lt_gt(code);

    case 61:case 33:
      return this.readToken_eq_excl(code);

    case 126:
      return this.finishOp(_tokentype.types.prefix, 1);
    case 64:
      ++this.pos;return this.finishToken(_tokentype.types.at);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};

function tryCreateRegexp(src, flags, throwErrorAt, parser) {
  try {
    return new RegExp(src, flags);
  } catch (e) {
    if (throwErrorAt !== undefined) {
      if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
      throw e;
    }
  }
}

var regexpUnicodeSupport = false; // !!tryCreateRegexp("\uffff", "u");

pp.readRegexp = function () {
  var _this = this;

  var escaped = undefined,
      inClass = undefined,
      start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
    var ch = this.input.charAt(this.pos);
    if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
    if (!escaped) {
      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
      escaped = ch === "\\";
    } else escaped = false;
    ++this.pos;
  }
  var content = this.input.slice(start, this.pos);
  ++this.pos;
  var mods = this.readWord1();
  var tmp = content;
  if (mods) {
    var validFlags = /^[gim]*$/;
    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;
    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    if (mods.indexOf("u") >= 0 && !regexpUnicodeSupport) {
      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
        code = Number("0x" + code);
        if (code > 0x10FFFF) _this.raise(start + offset + 3, "Code point out of bounds");
        return "x";
      });
      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
    }
  }
  var value = null;
  if (!isRhino) {
    tryCreateRegexp(tmp, undefined, start, this);
    value = tryCreateRegexp(content, mods);
  }
  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });
};

pp.readInt = function (radix, len) {
  var start = this.pos,
      total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos),
        val = undefined;
    if (code >= 97) val = code - 97 + 10 // a
    ;else if (code >= 65) val = code - 65 + 10 // A
    ;else if (code >= 48 && code <= 57) val = code - 48 // 0-9
    ;else val = Infinity;
    if (val >= radix) break;
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) return null;

  return total;
};

pp.readRadixNumber = function (radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
  return this.finishToken(_tokentype.types.num, val);
};

pp.readNumber = function (startsWithDot) {
  var start = this.pos,
      isFloat = false,
      octal = this.input.charCodeAt(this.pos) === 48;
  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
  var next = this.input.charCodeAt(this.pos);
  if (next === 46) {
    ++this.pos;
    this.readInt(10);
    isFloat = true;
    next = this.input.charCodeAt(this.pos);
  }
  if (next === 69 || next === 101) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) ++this.pos; // '+-'
    if (this.readInt(10) === null) this.raise(start, "Invalid number");
    isFloat = true;
  }
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

  var str = this.input.slice(start, this.pos),
      val = undefined;
  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
  return this.finishToken(_tokentype.types.num, val);
};

pp.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
      code = undefined;

  if (ch === 123) {
    if (this.options.ecmaVersion < 6) this.unexpected();
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
  } else {
    code = this.readHexChar(4);
  }
  return code;
};

function codePointToString(code) {
  if (code <= 0xFFFF) return String.fromCharCode(code);
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}

pp.readString = function (quote) {
  var out = "",
      chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) break;
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(_tokentype.types.string, out);
};

pp.readTmplToken = function () {
  var out = "",
      chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && this.type === _tokentype.types.template) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(_tokentype.types.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(_tokentype.types.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(_tokentype.types.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (_whitespace.isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

pp.readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n"; // 'n' -> '\n'
    case 114:
      return "\r"; // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2)); // 'x'
    case 117:
      return codePointToString(this.readCodePoint()); // 'u'
    case 116:
      return "\t"; // 't' -> '\t'
    case 98:
      return "\b"; // 'b' -> '\b'
    case 118:
      return "\u000b"; // 'v' -> '\u000b'
    case 102:
      return "\f"; // 'f' -> '\f'
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;++this.curLine;
      }
      return "";
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        if (octalStr !== "0" && (this.strict || inTemplate)) {
          this.raise(this.pos - 2, "Octal literal in strict mode");
        }
        this.pos += octalStr.length - 1;
        return String.fromCharCode(octal);
      }
      return String.fromCharCode(ch);
  }
};

pp.readHexChar = function (len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) this.raise(codePos, "Bad character escape sequence");
  return n;
};

pp.readWord1 = function () {
  this.containsEsc = false;
  var word = "",
      first = true,
      chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (_identifier.isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) != 117) // "u"
        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};

pp.readWord = function () {
  var word = this.readWord1();
  var type = _tokentype.types.name;
  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];
  return this.finishToken(type, word);
};

},{"./identifier":"/src\\identifier.js","./locutil":"/src\\locutil.js","./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokentype.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TokenType = function TokenType(label) {
  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

exports.TokenType = TokenType;

function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true },
    startsExpr = { startsExpr: true };

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

  at: new TokenType("@", { beforeExpr: true, startsExpr: true }),

  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=", 6),
  relational: binop("</>", 7),
  bitShift: binop("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true })
};

exports.types = types;
var keywords = {};

exports.keywords = keywords;
function kw(name) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  options.keyword = name;
  keywords[name] = types["_" + name] = new TokenType(name, options);
}

kw("break");
kw("case", beforeExpr);
kw("catch");
kw("continue");
kw("debugger");
kw("default", beforeExpr);
kw("do", { isLoop: true, beforeExpr: true });
kw("else", beforeExpr);
kw("finally");
kw("for", { isLoop: true });
kw("function", startsExpr);
kw("if");
kw("return", beforeExpr);
kw("switch");
kw("throw", beforeExpr);
kw("try");
kw("var");
kw("const");
kw("while", { isLoop: true });
kw("with");
kw("new", { beforeExpr: true, startsExpr: true });
kw("this", startsExpr);
kw("super", startsExpr);
kw("class");
kw("extends", beforeExpr);
kw("export");
kw("import");
kw("null", startsExpr);
kw("true", startsExpr);
kw("false", startsExpr);
kw("in", { beforeExpr: true, binop: 7 });
kw("instanceof", { beforeExpr: true, binop: 7 });
kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

},{}],"/src\\util.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isArray = isArray;
exports.has = has;

function isArray(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
}

function has(obj, propName) {
  return Object.prototype.hasOwnProperty.call(obj, propName);
}

},{}],"/src\\whitespace.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isNewLine = isNewLine;
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
exports.lineBreak = lineBreak;
var lineBreakG = new RegExp(lineBreak.source, "g");

exports.lineBreakG = lineBreakG;

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

exports.nonASCIIwhitespace = nonASCIIwhitespace;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
exports.skipWhiteSpace = skipWhiteSpace;

},{}]},{},["/src\\index.js"])("/src\\index.js")
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},
   {}],

"/node_modules/espree/lib/ast-node-types.js": [function(require,module,exports){
"use strict";

module.exports = {
    AssignmentExpression: "AssignmentExpression",
    AssignmentPattern: "AssignmentPattern",
    ArrayExpression: "ArrayExpression",
    ArrayPattern: "ArrayPattern",
    ArrowFunctionExpression: "ArrowFunctionExpression",
    BlockStatement: "BlockStatement",
    BinaryExpression: "BinaryExpression",
    BreakStatement: "BreakStatement",
    CallExpression: "CallExpression",
    CatchClause: "CatchClause",
    ClassBody: "ClassBody",
    ClassDeclaration: "ClassDeclaration",
    ClassExpression: "ClassExpression",
    ConditionalExpression: "ConditionalExpression",
    ContinueStatement: "ContinueStatement",
    DoWhileStatement: "DoWhileStatement",
    DebuggerStatement: "DebuggerStatement",
    EmptyStatement: "EmptyStatement",
    ExperimentalRestProperty: "ExperimentalRestProperty",
    ExperimentalSpreadProperty: "ExperimentalSpreadProperty",
    ExpressionStatement: "ExpressionStatement",
    ForStatement: "ForStatement",
    ForInStatement: "ForInStatement",
    ForOfStatement: "ForOfStatement",
    FunctionDeclaration: "FunctionDeclaration",
    FunctionExpression: "FunctionExpression",
    Identifier: "Identifier",
    IfStatement: "IfStatement",
    Literal: "Literal",
    LabeledStatement: "LabeledStatement",
    LogicalExpression: "LogicalExpression",
    MemberExpression: "MemberExpression",
    MetaProperty: "MetaProperty",
    MethodDefinition: "MethodDefinition",
    NewExpression: "NewExpression",
    ObjectExpression: "ObjectExpression",
    ObjectPattern: "ObjectPattern",
    Program: "Program",
    Property: "Property",
    RestElement: "RestElement",
    ReturnStatement: "ReturnStatement",
    SequenceExpression: "SequenceExpression",
    SpreadElement: "SpreadElement",
    Super: "Super",
    SwitchCase: "SwitchCase",
    SwitchStatement: "SwitchStatement",
    TaggedTemplateExpression: "TaggedTemplateExpression",
    TemplateElement: "TemplateElement",
    TemplateLiteral: "TemplateLiteral",
    ThisExpression: "ThisExpression",
    ThrowStatement: "ThrowStatement",
    TryStatement: "TryStatement",
    UnaryExpression: "UnaryExpression",
    UpdateExpression: "UpdateExpression",
    VariableDeclaration: "VariableDeclaration",
    VariableDeclarator: "VariableDeclarator",
    WhileStatement: "WhileStatement",
    WithStatement: "WithStatement",
    YieldExpression: "YieldExpression",
    JSXIdentifier: "JSXIdentifier",
    JSXNamespacedName: "JSXNamespacedName",
    JSXMemberExpression: "JSXMemberExpression",
    JSXEmptyExpression: "JSXEmptyExpression",
    JSXExpressionContainer: "JSXExpressionContainer",
    JSXElement: "JSXElement",
    JSXClosingElement: "JSXClosingElement",
    JSXOpeningElement: "JSXOpeningElement",
    JSXAttribute: "JSXAttribute",
    JSXSpreadAttribute: "JSXSpreadAttribute",
    JSXText: "JSXText",
    ExportDefaultDeclaration: "ExportDefaultDeclaration",
    ExportNamedDeclaration: "ExportNamedDeclaration",
    ExportAllDeclaration: "ExportAllDeclaration",
    ExportSpecifier: "ExportSpecifier",
    ImportDeclaration: "ImportDeclaration",
    ImportSpecifier: "ImportSpecifier",
    ImportDefaultSpecifier: "ImportDefaultSpecifier",
    ImportNamespaceSpecifier: "ImportNamespaceSpecifier"
};

},
   {}],

"/node_modules/espree/lib/comment-attachment.js": [function(require,module,exports){
"use strict";

var astNodeTypes = require("./ast-node-types");

var extra = {
    trailingComments: [],
    leadingComments: [],
    bottomRightStack: []
};

module.exports = {

    reset: function() {
        extra.trailingComments = [];
        extra.leadingComments = [];
        extra.bottomRightStack = [];
    },

    addComment: function(comment) {
        extra.trailingComments.push(comment);
        extra.leadingComments.push(comment);
    },

    processComment: function(node) {
        var lastChild,
            trailingComments,
            i;

        if (node.type === astNodeTypes.Program) {
            if (node.body.length > 0) {
                return;
            }
        }

        if (extra.trailingComments.length > 0) {

            if (extra.trailingComments[0].range[0] >= node.range[1]) {
                trailingComments = extra.trailingComments;
                extra.trailingComments = [];
            } else {

                extra.trailingComments.length = 0;
            }
        } else {
            if (extra.bottomRightStack.length > 0 &&
                    extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments &&
                    extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
                trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
                delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
            }
        }

        while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
            lastChild = extra.bottomRightStack.pop();
        }

        if (lastChild) {
            if (lastChild.leadingComments) {
                if (lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
                    node.leadingComments = lastChild.leadingComments;
                    delete lastChild.leadingComments;
                } else {
                    for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
                        if (lastChild.leadingComments[i].range[1] <= node.range[0]) {
                            node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                            break;
                        }
                    }
                }
            }
        } else if (extra.leadingComments.length > 0) {

            if (extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
                node.leadingComments = extra.leadingComments;
                extra.leadingComments = [];
            } else {

                for (i = 0; i < extra.leadingComments.length; i++) {
                    if (extra.leadingComments[i].range[1] > node.range[0]) {
                        break;
                    }
                }

                node.leadingComments = extra.leadingComments.slice(0, i);
                if (node.leadingComments.length === 0) {
                    delete node.leadingComments;
                }

                trailingComments = extra.leadingComments.slice(i);
                if (trailingComments.length === 0) {
                    trailingComments = null;
                }
            }
        }

        if (trailingComments) {
            node.trailingComments = trailingComments;
        }

        extra.bottomRightStack.push(node);
    }

};

},
   {"./ast-node-types":"/node_modules/espree/lib/ast-node-types.js"}],

"/node_modules/espree/lib/token-translator.js": [function(require,module,exports){
"use strict";


var Token = {
    Boolean: "Boolean",
    EOF: "<end>",
    Identifier: "Identifier",
    Keyword: "Keyword",
    Null: "Null",
    Numeric: "Numeric",
    Punctuator: "Punctuator",
    String: "String",
    RegularExpression: "RegularExpression",
    Template: "Template",
    JSXIdentifier: "JSXIdentifier",
    JSXText: "JSXText"
};

function convertTemplatePart(tokens, code) {
    var firstToken = tokens[0],
        lastTemplateToken = tokens[tokens.length - 1];

    var token = {
        type: Token.Template,
        value: code.slice(firstToken.start, lastTemplateToken.end)
    };

    if (firstToken.loc) {
        token.loc = {
            start: firstToken.loc.start,
            end: lastTemplateToken.loc.end
        };
    }

    if (firstToken.range) {
        token.range = [firstToken.range[0], lastTemplateToken.range[1]];
    }

    return token;
}

function TokenTranslator(acornTokTypes, code) {

    this._acornTokTypes = acornTokTypes;

    this._tokens = [];

    this._curlyBrace = null;

    this._code = code;

}

TokenTranslator.prototype = {
    constructor: TokenTranslator,

    translate: function(token, extra) {

        var type = token.type,
            tt = this._acornTokTypes;

        if (type === tt.name) {
            token.type = Token.Identifier;

            if (token.value === "static") {
                token.type = Token.Keyword;
            }

            if (extra.ecmaVersion > 5 && (token.value === "yield" || token.value === "let")) {
                token.type = Token.Keyword;
            }

        } else if (type === tt.semi || type === tt.comma ||
                 type === tt.parenL || type === tt.parenR ||
                 type === tt.braceL || type === tt.braceR ||
                 type === tt.dot || type === tt.bracketL ||
                 type === tt.colon || type === tt.question ||
                 type === tt.bracketR || type === tt.ellipsis ||
                 type === tt.arrow || type === tt.jsxTagStart ||
                 type === tt.incDec || type === tt.starstar ||
                 type === tt.jsxTagEnd || (type.binop && !type.keyword) ||
                 type.isAssign) {

            token.type = Token.Punctuator;
            token.value = this._code.slice(token.start, token.end);
        } else if (type === tt.jsxName) {
            token.type = Token.JSXIdentifier;
        } else if (type.label === "jsxText" || type === tt.jsxAttrValueToken) {
            token.type = Token.JSXText;
        } else if (type.keyword) {
            if (type.keyword === "true" || type.keyword === "false") {
                token.type = Token.Boolean;
            } else if (type.keyword === "null") {
                token.type = Token.Null;
            } else {
                token.type = Token.Keyword;
            }
        } else if (type === tt.num) {
            token.type = Token.Numeric;
            token.value = this._code.slice(token.start, token.end);
        } else if (type === tt.string) {

            if (extra.jsxAttrValueToken) {
                extra.jsxAttrValueToken = false;
                token.type = Token.JSXText;
            } else {
                token.type = Token.String;
            }

            token.value = this._code.slice(token.start, token.end);
        } else if (type === tt.regexp) {
            token.type = Token.RegularExpression;
            var value = token.value;
            token.regex = {
                flags: value.flags,
                pattern: value.pattern
            };
            token.value = "/" + value.pattern + "/" + value.flags;
        }

        return token;
    },

    onToken: function(token, extra) {

        var that = this,
            tt = this._acornTokTypes,
            tokens = extra.tokens,
            templateTokens = this._tokens;

        function translateTemplateTokens() {
            tokens.push(convertTemplatePart(that._tokens, that._code));
            that._tokens = [];
        }

        if (token.type === tt.eof) {

            if (this._curlyBrace) {
                tokens.push(this.translate(this._curlyBrace, extra));
            }

            return;
        }

        if (token.type === tt.backQuote) {
            templateTokens.push(token);

            if (templateTokens.length > 1) {
                translateTemplateTokens();
            }

            return;
        } else if (token.type === tt.dollarBraceL) {
            templateTokens.push(token);
            translateTemplateTokens();
            return;
        } else if (token.type === tt.braceR) {

            if (this._curlyBrace) {

                tokens.push(this.translate(this._curlyBrace, extra));
            }

            this._curlyBrace = token;
            return;
        } else if (token.type === tt.template) {
            if (this._curlyBrace) {
                templateTokens.push(this._curlyBrace);
                this._curlyBrace = null;
            }

            templateTokens.push(token);
            return;
        }

        if (this._curlyBrace) {
            tokens.push(this.translate(this._curlyBrace, extra));
            this._curlyBrace = null;
        }

        tokens.push(this.translate(token, extra));
    }
};

module.exports = TokenTranslator;

},
   {}],

"/node_modules/espree/lib/visitor-keys.js": [function(require,module,exports){
"use strict";

module.exports = {

    AssignmentExpression: ["left", "right"],
    AssignmentPattern: ["left", "right"],
    ArrayExpression: ["elements"],
    ArrayPattern: ["elements"],
    ArrowFunctionExpression: ["params", "body"],
    BlockStatement: ["body"],
    BinaryExpression: ["left", "right"],
    BreakStatement: ["label"],
    CallExpression: ["callee", "arguments"],
    CatchClause: ["param", "body"],
    ClassBody: ["body"],
    ClassDeclaration: ["id", "superClass", "body"],
    ClassExpression: ["id", "superClass", "body"],
    ConditionalExpression: ["test", "consequent", "alternate"],
    ContinueStatement: ["label"],
    DebuggerStatement: [],
    DirectiveStatement: [],
    DoWhileStatement: ["body", "test"],
    EmptyStatement: [],
    ExportAllDeclaration: ["source"],
    ExportDefaultDeclaration: ["declaration"],
    ExportNamedDeclaration: ["declaration", "specifiers", "source"],
    ExportSpecifier: ["exported", "local"],
    ExpressionStatement: ["expression"],
    ForStatement: ["init", "test", "update", "body"],
    ForInStatement: ["left", "right", "body"],
    ForOfStatement: ["left", "right", "body"],
    FunctionDeclaration: ["id", "params", "body"],
    FunctionExpression: ["id", "params", "body"],
    Identifier: [],
    IfStatement: ["test", "consequent", "alternate"],
    ImportDeclaration: ["specifiers", "source"],
    ImportDefaultSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportSpecifier: ["imported", "local"],
    Literal: [],
    LabeledStatement: ["label", "body"],
    LogicalExpression: ["left", "right"],
    MemberExpression: ["object", "property"],
    MetaProperty: ["meta", "property"],
    MethodDefinition: ["key", "value"],
    ModuleSpecifier: [],
    NewExpression: ["callee", "arguments"],
    ObjectExpression: ["properties"],
    ObjectPattern: ["properties"],
    Program: ["body"],
    Property: ["key", "value"],
    RestElement: [ "argument" ],
    ReturnStatement: ["argument"],
    SequenceExpression: ["expressions"],
    SpreadElement: ["argument"],
    Super: [],
    SwitchStatement: ["discriminant", "cases"],
    SwitchCase: ["test", "consequent"],
    TaggedTemplateExpression: ["tag", "quasi"],
    TemplateElement: [],
    TemplateLiteral: ["quasis", "expressions"],
    ThisExpression: [],
    ThrowStatement: ["argument"],
    TryStatement: ["block", "handler", "finalizer"],
    UnaryExpression: ["argument"],
    UpdateExpression: ["argument"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id", "init"],
    WhileStatement: ["test", "body"],
    WithStatement: ["object", "body"],
    YieldExpression: ["argument"],

    JSXIdentifier: [],
    JSXNamespacedName: ["namespace", "name"],
    JSXMemberExpression: ["object", "property"],
    JSXEmptyExpression: [],
    JSXExpressionContainer: ["expression"],
    JSXElement: ["openingElement", "closingElement", "children"],
    JSXClosingElement: ["name"],
    JSXOpeningElement: ["name", "attributes"],
    JSXAttribute: ["name", "value"],
    JSXText: null,
    JSXSpreadAttribute: ["argument"],

    ExperimentalRestProperty: ["argument"],
    ExperimentalSpreadProperty: ["argument"]
};

},
   {}],

"/node_modules/espree/node_modules/acorn-jsx/inject.js": [function(require,module,exports){
'use strict';

var XHTMLEntities = require('./xhtml');

var hexNumber = /^[\da-fA-F]+$/;
var decimalNumber = /^\d+$/;

module.exports = function(acorn) {
  var tt = acorn.tokTypes;
  var tc = acorn.tokContexts;

  tc.j_oTag = new acorn.TokContext('<tag', false);
  tc.j_cTag = new acorn.TokContext('</tag', false);
  tc.j_expr = new acorn.TokContext('<tag>...</tag>', true, true);

  tt.jsxName = new acorn.TokenType('jsxName');
  tt.jsxText = new acorn.TokenType('jsxText', {beforeExpr: true});
  tt.jsxTagStart = new acorn.TokenType('jsxTagStart');
  tt.jsxTagEnd = new acorn.TokenType('jsxTagEnd');

  tt.jsxTagStart.updateContext = function() {
    this.context.push(tc.j_expr); // treat as beginning of JSX expression
    this.context.push(tc.j_oTag); // start opening tag context
    this.exprAllowed = false;
  };
  tt.jsxTagEnd.updateContext = function(prevType) {
    var out = this.context.pop();
    if (out === tc.j_oTag && prevType === tt.slash || out === tc.j_cTag) {
      this.context.pop();
      this.exprAllowed = this.curContext() === tc.j_expr;
    } else {
      this.exprAllowed = true;
    }
  };

  var pp = acorn.Parser.prototype;

  pp.jsx_readToken = function() {
    var out = '', chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length)
        this.raise(this.start, 'Unterminated JSX contents');
      var ch = this.input.charCodeAt(this.pos);

      switch (ch) {
      case 60: // '<'
      case 123: // '{'
        if (this.pos === this.start) {
          if (ch === 60 && this.exprAllowed) {
            ++this.pos;
            return this.finishToken(tt.jsxTagStart);
          }
          return this.getTokenFromCode(ch);
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(tt.jsxText, out);

      case 38: // '&'
        out += this.input.slice(chunkStart, this.pos);
        out += this.jsx_readEntity();
        chunkStart = this.pos;
        break;

      default:
        if (acorn.isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readNewLine(true);
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    }
  };

  pp.jsx_readNewLine = function(normalizeCRLF) {
    var ch = this.input.charCodeAt(this.pos);
    var out;
    ++this.pos;
    if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
      ++this.pos;
      out = normalizeCRLF ? '\n' : '\r\n';
    } else {
      out = String.fromCharCode(ch);
    }
    if (this.options.locations) {
      ++this.curLine;
      this.lineStart = this.pos;
    }

    return out;
  };

  pp.jsx_readString = function(quote) {
    var out = '', chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length)
        this.raise(this.start, 'Unterminated string constant');
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) break;
      if (ch === 38) { // '&'
        out += this.input.slice(chunkStart, this.pos);
        out += this.jsx_readEntity();
        chunkStart = this.pos;
      } else if (acorn.isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        out += this.jsx_readNewLine(false);
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(tt.string, out);
  };

  pp.jsx_readEntity = function() {
    var str = '', count = 0, entity;
    var ch = this.input[this.pos];
    if (ch !== '&')
      this.raise(this.pos, 'Entity must start with an ampersand');
    var startPos = ++this.pos;
    while (this.pos < this.input.length && count++ < 10) {
      ch = this.input[this.pos++];
      if (ch === ';') {
        if (str[0] === '#') {
          if (str[1] === 'x') {
            str = str.substr(2);
            if (hexNumber.test(str))
              entity = String.fromCharCode(parseInt(str, 16));
          } else {
            str = str.substr(1);
            if (decimalNumber.test(str))
              entity = String.fromCharCode(parseInt(str, 10));
          }
        } else {
          entity = XHTMLEntities[str];
        }
        break;
      }
      str += ch;
    }
    if (!entity) {
      this.pos = startPos;
      return '&';
    }
    return entity;
  };


  pp.jsx_readWord = function() {
    var ch, start = this.pos;
    do {
      ch = this.input.charCodeAt(++this.pos);
    } while (acorn.isIdentifierChar(ch) || ch === 45); // '-'
    return this.finishToken(tt.jsxName, this.input.slice(start, this.pos));
  };

  function getQualifiedJSXName(object) {
    if (object.type === 'JSXIdentifier')
      return object.name;

    if (object.type === 'JSXNamespacedName')
      return object.namespace.name + ':' + object.name.name;

    if (object.type === 'JSXMemberExpression')
      return getQualifiedJSXName(object.object) + '.' +
      getQualifiedJSXName(object.property);
  }

  pp.jsx_parseIdentifier = function() {
    var node = this.startNode();
    if (this.type === tt.jsxName)
      node.name = this.value;
    else if (this.type.keyword)
      node.name = this.type.keyword;
    else
      this.unexpected();
    this.next();
    return this.finishNode(node, 'JSXIdentifier');
  };

  pp.jsx_parseNamespacedName = function() {
    var startPos = this.start, startLoc = this.startLoc;
    var name = this.jsx_parseIdentifier();
    if (!this.eat(tt.colon)) return name;
    var node = this.startNodeAt(startPos, startLoc);
    node.namespace = name;
    node.name = this.jsx_parseIdentifier();
    return this.finishNode(node, 'JSXNamespacedName');
  };

  pp.jsx_parseElementName = function() {
    var startPos = this.start, startLoc = this.startLoc;
    var node = this.jsx_parseNamespacedName();
    while (this.eat(tt.dot)) {
      var newNode = this.startNodeAt(startPos, startLoc);
      newNode.object = node;
      newNode.property = this.jsx_parseIdentifier();
      node = this.finishNode(newNode, 'JSXMemberExpression');
    }
    return node;
  };

  pp.jsx_parseAttributeValue = function() {
    switch (this.type) {
    case tt.braceL:
      var node = this.jsx_parseExpressionContainer();
      if (node.expression.type === 'JSXEmptyExpression')
        this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');
      return node;

    case tt.jsxTagStart:
    case tt.string:
      return this.parseExprAtom();

    default:
      this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');
    }
  };

  pp.jsx_parseEmptyExpression = function() {
    var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
    return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);
  };


  pp.jsx_parseExpressionContainer = function() {
    var node = this.startNode();
    this.next();
    node.expression = this.type === tt.braceR
      ? this.jsx_parseEmptyExpression()
      : this.parseExpression();
    this.expect(tt.braceR);
    return this.finishNode(node, 'JSXExpressionContainer');
  };

  pp.jsx_parseAttribute = function() {
    var node = this.startNode();
    if (this.eat(tt.braceL)) {
      this.expect(tt.ellipsis);
      node.argument = this.parseMaybeAssign();
      this.expect(tt.braceR);
      return this.finishNode(node, 'JSXSpreadAttribute');
    }
    node.name = this.jsx_parseNamespacedName();
    node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
    return this.finishNode(node, 'JSXAttribute');
  };

  pp.jsx_parseOpeningElementAt = function(startPos, startLoc) {
    var node = this.startNodeAt(startPos, startLoc);
    node.attributes = [];
    node.name = this.jsx_parseElementName();
    while (this.type !== tt.slash && this.type !== tt.jsxTagEnd)
      node.attributes.push(this.jsx_parseAttribute());
    node.selfClosing = this.eat(tt.slash);
    this.expect(tt.jsxTagEnd);
    return this.finishNode(node, 'JSXOpeningElement');
  };

  pp.jsx_parseClosingElementAt = function(startPos, startLoc) {
    var node = this.startNodeAt(startPos, startLoc);
    node.name = this.jsx_parseElementName();
    this.expect(tt.jsxTagEnd);
    return this.finishNode(node, 'JSXClosingElement');
  };

  pp.jsx_parseElementAt = function(startPos, startLoc) {
    var node = this.startNodeAt(startPos, startLoc);
    var children = [];
    var openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
    var closingElement = null;

    if (!openingElement.selfClosing) {
      contents: for (;;) {
        switch (this.type) {
        case tt.jsxTagStart:
          startPos = this.start; startLoc = this.startLoc;
          this.next();
          if (this.eat(tt.slash)) {
            closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
            break contents;
          }
          children.push(this.jsx_parseElementAt(startPos, startLoc));
          break;

        case tt.jsxText:
          children.push(this.parseExprAtom());
          break;

        case tt.braceL:
          children.push(this.jsx_parseExpressionContainer());
          break;

        default:
          this.unexpected();
        }
      }
      if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
        this.raise(
          closingElement.start,
          'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');
      }
    }

    node.openingElement = openingElement;
    node.closingElement = closingElement;
    node.children = children;
    if (this.type === tt.relational && this.value === "<") {
      this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
    }
    return this.finishNode(node, 'JSXElement');
  };

  pp.jsx_parseElement = function() {
    var startPos = this.start, startLoc = this.startLoc;
    this.next();
    return this.jsx_parseElementAt(startPos, startLoc);
  };

  acorn.plugins.jsx = function(instance) {
    instance.extend('parseExprAtom', function(inner) {
      return function(refShortHandDefaultPos) {
        if (this.type === tt.jsxText)
          return this.parseLiteral(this.value);
        else if (this.type === tt.jsxTagStart)
          return this.jsx_parseElement();
        else
          return inner.call(this, refShortHandDefaultPos);
      };
    });

    instance.extend('readToken', function(inner) {
      return function(code) {
        var context = this.curContext();

        if (context === tc.j_expr) return this.jsx_readToken();

        if (context === tc.j_oTag || context === tc.j_cTag) {
          if (acorn.isIdentifierStart(code)) return this.jsx_readWord();

          if (code == 62) {
            ++this.pos;
            return this.finishToken(tt.jsxTagEnd);
          }

          if ((code === 34 || code === 39) && context == tc.j_oTag)
            return this.jsx_readString(code);
        }

        if (code === 60 && this.exprAllowed) {
          ++this.pos;
          return this.finishToken(tt.jsxTagStart);
        }
        return inner.call(this, code);
      };
    });

    instance.extend('updateContext', function(inner) {
      return function(prevType) {
        if (this.type == tt.braceL) {
          var curContext = this.curContext();
          if (curContext == tc.j_oTag) this.context.push(tc.b_expr);
          else if (curContext == tc.j_expr) this.context.push(tc.b_tmpl);
          else inner.call(this, prevType);
          this.exprAllowed = true;
        } else if (this.type === tt.slash && prevType === tt.jsxTagStart) {
          this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
          this.context.push(tc.j_cTag); // reconsider as closing tag context
          this.exprAllowed = false;
        } else {
          return inner.call(this, prevType);
        }
      };
    });
  };

  return acorn;
};

},
   {"./xhtml":"/node_modules/espree/node_modules/acorn-jsx/xhtml.js"}],

"/node_modules/espree/node_modules/acorn-jsx/xhtml.js": [function(require,module,exports){
module.exports = {
  quot: '\u0022',
  amp: '&',
  apos: '\u0027',
  lt: '<',
  gt: '>',
  nbsp: '\u00A0',
  iexcl: '\u00A1',
  cent: '\u00A2',
  pound: '\u00A3',
  curren: '\u00A4',
  yen: '\u00A5',
  brvbar: '\u00A6',
  sect: '\u00A7',
  uml: '\u00A8',
  copy: '\u00A9',
  ordf: '\u00AA',
  laquo: '\u00AB',
  not: '\u00AC',
  shy: '\u00AD',
  reg: '\u00AE',
  macr: '\u00AF',
  deg: '\u00B0',
  plusmn: '\u00B1',
  sup2: '\u00B2',
  sup3: '\u00B3',
  acute: '\u00B4',
  micro: '\u00B5',
  para: '\u00B6',
  middot: '\u00B7',
  cedil: '\u00B8',
  sup1: '\u00B9',
  ordm: '\u00BA',
  raquo: '\u00BB',
  frac14: '\u00BC',
  frac12: '\u00BD',
  frac34: '\u00BE',
  iquest: '\u00BF',
  Agrave: '\u00C0',
  Aacute: '\u00C1',
  Acirc: '\u00C2',
  Atilde: '\u00C3',
  Auml: '\u00C4',
  Aring: '\u00C5',
  AElig: '\u00C6',
  Ccedil: '\u00C7',
  Egrave: '\u00C8',
  Eacute: '\u00C9',
  Ecirc: '\u00CA',
  Euml: '\u00CB',
  Igrave: '\u00CC',
  Iacute: '\u00CD',
  Icirc: '\u00CE',
  Iuml: '\u00CF',
  ETH: '\u00D0',
  Ntilde: '\u00D1',
  Ograve: '\u00D2',
  Oacute: '\u00D3',
  Ocirc: '\u00D4',
  Otilde: '\u00D5',
  Ouml: '\u00D6',
  times: '\u00D7',
  Oslash: '\u00D8',
  Ugrave: '\u00D9',
  Uacute: '\u00DA',
  Ucirc: '\u00DB',
  Uuml: '\u00DC',
  Yacute: '\u00DD',
  THORN: '\u00DE',
  szlig: '\u00DF',
  agrave: '\u00E0',
  aacute: '\u00E1',
  acirc: '\u00E2',
  atilde: '\u00E3',
  auml: '\u00E4',
  aring: '\u00E5',
  aelig: '\u00E6',
  ccedil: '\u00E7',
  egrave: '\u00E8',
  eacute: '\u00E9',
  ecirc: '\u00EA',
  euml: '\u00EB',
  igrave: '\u00EC',
  iacute: '\u00ED',
  icirc: '\u00EE',
  iuml: '\u00EF',
  eth: '\u00F0',
  ntilde: '\u00F1',
  ograve: '\u00F2',
  oacute: '\u00F3',
  ocirc: '\u00F4',
  otilde: '\u00F5',
  ouml: '\u00F6',
  divide: '\u00F7',
  oslash: '\u00F8',
  ugrave: '\u00F9',
  uacute: '\u00FA',
  ucirc: '\u00FB',
  uuml: '\u00FC',
  yacute: '\u00FD',
  thorn: '\u00FE',
  yuml: '\u00FF',
  OElig: '\u0152',
  oelig: '\u0153',
  Scaron: '\u0160',
  scaron: '\u0161',
  Yuml: '\u0178',
  fnof: '\u0192',
  circ: '\u02C6',
  tilde: '\u02DC',
  Alpha: '\u0391',
  Beta: '\u0392',
  Gamma: '\u0393',
  Delta: '\u0394',
  Epsilon: '\u0395',
  Zeta: '\u0396',
  Eta: '\u0397',
  Theta: '\u0398',
  Iota: '\u0399',
  Kappa: '\u039A',
  Lambda: '\u039B',
  Mu: '\u039C',
  Nu: '\u039D',
  Xi: '\u039E',
  Omicron: '\u039F',
  Pi: '\u03A0',
  Rho: '\u03A1',
  Sigma: '\u03A3',
  Tau: '\u03A4',
  Upsilon: '\u03A5',
  Phi: '\u03A6',
  Chi: '\u03A7',
  Psi: '\u03A8',
  Omega: '\u03A9',
  alpha: '\u03B1',
  beta: '\u03B2',
  gamma: '\u03B3',
  delta: '\u03B4',
  epsilon: '\u03B5',
  zeta: '\u03B6',
  eta: '\u03B7',
  theta: '\u03B8',
  iota: '\u03B9',
  kappa: '\u03BA',
  lambda: '\u03BB',
  mu: '\u03BC',
  nu: '\u03BD',
  xi: '\u03BE',
  omicron: '\u03BF',
  pi: '\u03C0',
  rho: '\u03C1',
  sigmaf: '\u03C2',
  sigma: '\u03C3',
  tau: '\u03C4',
  upsilon: '\u03C5',
  phi: '\u03C6',
  chi: '\u03C7',
  psi: '\u03C8',
  omega: '\u03C9',
  thetasym: '\u03D1',
  upsih: '\u03D2',
  piv: '\u03D6',
  ensp: '\u2002',
  emsp: '\u2003',
  thinsp: '\u2009',
  zwnj: '\u200C',
  zwj: '\u200D',
  lrm: '\u200E',
  rlm: '\u200F',
  ndash: '\u2013',
  mdash: '\u2014',
  lsquo: '\u2018',
  rsquo: '\u2019',
  sbquo: '\u201A',
  ldquo: '\u201C',
  rdquo: '\u201D',
  bdquo: '\u201E',
  dagger: '\u2020',
  Dagger: '\u2021',
  bull: '\u2022',
  hellip: '\u2026',
  permil: '\u2030',
  prime: '\u2032',
  Prime: '\u2033',
  lsaquo: '\u2039',
  rsaquo: '\u203A',
  oline: '\u203E',
  frasl: '\u2044',
  euro: '\u20AC',
  image: '\u2111',
  weierp: '\u2118',
  real: '\u211C',
  trade: '\u2122',
  alefsym: '\u2135',
  larr: '\u2190',
  uarr: '\u2191',
  rarr: '\u2192',
  darr: '\u2193',
  harr: '\u2194',
  crarr: '\u21B5',
  lArr: '\u21D0',
  uArr: '\u21D1',
  rArr: '\u21D2',
  dArr: '\u21D3',
  hArr: '\u21D4',
  forall: '\u2200',
  part: '\u2202',
  exist: '\u2203',
  empty: '\u2205',
  nabla: '\u2207',
  isin: '\u2208',
  notin: '\u2209',
  ni: '\u220B',
  prod: '\u220F',
  sum: '\u2211',
  minus: '\u2212',
  lowast: '\u2217',
  radic: '\u221A',
  prop: '\u221D',
  infin: '\u221E',
  ang: '\u2220',
  and: '\u2227',
  or: '\u2228',
  cap: '\u2229',
  cup: '\u222A',
  'int': '\u222B',
  there4: '\u2234',
  sim: '\u223C',
  cong: '\u2245',
  asymp: '\u2248',
  ne: '\u2260',
  equiv: '\u2261',
  le: '\u2264',
  ge: '\u2265',
  sub: '\u2282',
  sup: '\u2283',
  nsub: '\u2284',
  sube: '\u2286',
  supe: '\u2287',
  oplus: '\u2295',
  otimes: '\u2297',
  perp: '\u22A5',
  sdot: '\u22C5',
  lceil: '\u2308',
  rceil: '\u2309',
  lfloor: '\u230A',
  rfloor: '\u230B',
  lang: '\u2329',
  rang: '\u232A',
  loz: '\u25CA',
  spades: '\u2660',
  clubs: '\u2663',
  hearts: '\u2665',
  diams: '\u2666'
};

},
   {}],

"/node_modules/espree/package.json": [function(require,module,exports){
module.exports={
  "name": "espree",
  "description": "An Esprima-compatible JavaScript parser built on Acorn",
  "author": {
    "name": "Nicholas C. Zakas",
    "email": "nicholas+npm@nczconsulting.com"
  },
  "homepage": "https://github.com/eslint/espree",
  "main": "espree.js",
  "version": "3.1.1",
  "files": [
    "lib",
    "espree.js"
  ],
  "engines": {
    "node": ">=0.10.0"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/eslint/espree.git"
  },
  "bugs": {
    "url": "http://github.com/eslint/espree.git"
  },
  "license": "BSD-2-Clause",
  "dependencies": {
    "acorn": "^3.0.4",
    "acorn-jsx": "^2.0.1"
  },
  "devDependencies": {
    "browserify": "^7.0.0",
    "chai": "^1.10.0",
    "eslint": "^2.0.0-beta.1",
    "eslint-config-eslint": "^3.0.0",
    "eslint-release": "^0.3.0",
    "esprima": "latest",
    "esprima-fb": "^8001.2001.0-dev-harmony-fb",
    "istanbul": "~0.2.6",
    "json-diff": "~0.3.1",
    "leche": "^1.0.1",
    "mocha": "^2.0.1",
    "optimist": "~0.6.0",
    "regenerate": "~0.5.4",
    "shelljs": "^0.3.0",
    "shelljs-nodecli": "^0.1.1",
    "unicode-6.3.0": "~0.1.0"
  },
  "keywords": [
    "ast",
    "ecmascript",
    "javascript",
    "parser",
    "syntax",
    "acorn"
  ],
  "scripts": {
    "generate-regex": "node tools/generate-identifier-regex.js",
    "test": "npm run-script lint && node Makefile.js test",
    "lint": "node Makefile.js lint",
    "release": "eslint-release",
    "alpharelease": "eslint-prelease alpha",
    "betarelease": "eslint-prelease beta",
    "browserify": "node Makefile.js browserify"
  },
  "_id": "espree@3.1.1",
  "_shasum": "54d560a12bcf414a970d6527adaedd9f6d7ba95b",
  "_from": "espree@>=3.1.1 <4.0.0",
  "_npmVersion": "1.4.10",
  "_npmUser": {
    "name": "nzakas",
    "email": "nicholas@nczconsulting.com"
  },
  "maintainers": [
    {
      "name": "nzakas",
      "email": "nicholas@nczconsulting.com"
    }
  ],
  "dist": {
    "shasum": "54d560a12bcf414a970d6527adaedd9f6d7ba95b",
    "tarball": "http://registry.npmjs.org/espree/-/espree-3.1.1.tgz"
  },
  "_npmOperationalInternal": {
    "host": "packages-6-west.internal.npmjs.com",
    "tmp": "tmp/espree-3.1.1.tgz_1456510901064_0.6160593316890299"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/espree/-/espree-3.1.1.tgz",
  "readme": "ERROR: No README data found!"
}

},
   {}],

"espree": [function(require,module,exports){
"use strict";

var astNodeTypes = require("./lib/ast-node-types"),
    commentAttachment = require("./lib/comment-attachment"),
    TokenTranslator = require("./lib/token-translator"),
    acornJSX = require("acorn-jsx/inject"),
    rawAcorn = require("acorn");


var acorn = acornJSX(rawAcorn);

var lookahead,
    extra,
    lastToken;

function resetExtra() {
    extra = {
        tokens: null,
        range: false,
        loc: false,
        comment: false,
        comments: [],
        tolerant: true,
        errors: [],
        strict: false,
        ecmaFeatures: {},
        ecmaVersion: 5,
        isModule: false
    };
}



var tt = acorn.tokTypes,
    getLineInfo = acorn.getLineInfo;

tt.jsxAttrValueToken = {};

function isValidNode(node) {
    return true;
}

function esprimaFinishNode(result) {
    if (!isValidNode(result)) {
        this.unexpected(result.start);
    }

    if (result.type === "TryStatement") {
        delete result.guardedHandlers;
    } else if (result.type === "CatchClause") {
        delete result.guard;
    }

    if (result.type === "TemplateElement") {

        var terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === "${";

        if (result.range) {
            result.range[0]--;
            result.range[1] += (terminalDollarBraceL ? 2 : 1);
        }

        if (result.loc) {
            result.loc.start.column--;
            result.loc.end.column += (terminalDollarBraceL ? 2 : 1);
        }
    }

    if (result.type === "ExportDefaultDeclaration") {
        if (/^(Class|Function)Expression$/.test(result.declaration.type)) {
            result.declaration.type = result.declaration.type.replace("Expression", "Declaration");
        }
    }

    if (result.type === "Literal" && result.value === undefined) {
        result.value = null;
    }

    if (extra.attachComment) {
        commentAttachment.processComment(result);
    }

    if (result.type.indexOf("Function") > -1 && !result.generator) {
        result.generator = false;
    }

    return result;
}

function isValidToken(parser) {
    return true;
}

function wrapFinishNode(finishNode) {
    return /** @this acorn.Parser */ function(node, type, pos, loc) {
        var result = finishNode.call(this, node, type, pos, loc);
        return esprimaFinishNode.call(this, result);
    };
}

acorn.plugins.espree = function(instance) {

    instance.extend("finishNode", wrapFinishNode);

    instance.extend("finishNodeAt", wrapFinishNode);

    instance.extend("next", function(next) {
        return /** @this acorn.Parser */ function() {
            if (!isValidToken(this)) {
                this.unexpected();
            }
            return next.call(this);
        };
    });

    instance.extend("checkLVal", function(checkLVal) {

        return /** @this acorn.Parser */ function(expr, isBinding, checkClashes) {

            if (extra.ecmaFeatures.experimentalObjectRestSpread && expr.type === "ObjectPattern") {
                for (var i = 0; i < expr.properties.length; i++) {
                    if (expr.properties[i].type.indexOf("Experimental") === -1) {
                        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
                    }
                }
                return undefined;
            }

            return checkLVal.call(this, expr, isBinding, checkClashes);
        };
    });

    instance.extend("parseTopLevel", function(parseTopLevel) {
        return /** @this acorn.Parser */ function(node) {
            if (extra.ecmaFeatures.impliedStrict && this.options.ecmaVersion >= 5) {
                this.strict = true;
            }
            return parseTopLevel.call(this, node);
        };
    });

    instance.extend("toAssignable", function(toAssignable) {

        return /** @this acorn.Parser */ function(node, isBinding) {

            if (extra.ecmaFeatures.experimentalObjectRestSpread &&
                    node.type === "ObjectExpression"
            ) {
                node.type = "ObjectPattern";

                for (var i = 0; i < node.properties.length; i++) {
                    var prop = node.properties[i];

                    if (prop.type === "ExperimentalSpreadProperty") {
                        prop.type = "ExperimentalRestProperty";
                    } else if (prop.kind !== "init") {
                        this.raise(prop.key.start, "Object pattern can't contain getter or setter");
                    } else {
                        this.toAssignable(prop.value, isBinding);
                    }
                }

                return node;
            } else {
                return toAssignable.call(this, node, isBinding);
            }
        };

    });

    instance.parseObjectRest = function() {
        var node = this.startNode();
        this.next();
        node.argument = this.parseIdent();
        return this.finishNode(node, "ExperimentalRestProperty");
    };

    instance.parseObj = function(isPattern, refShorthandDefaultPos) {
        var node = this.startNode(),
            first = true,
            propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(tt.braceR)) {

            if (!first) {
                this.expect(tt.comma);

                if (this.afterTrailingComma(tt.braceR)) {
                    break;
                }

            } else {
                first = false;
            }

            if (this.value == "async" && /^[ \t]*\w+/.test(this.input.slice(this.end)))
                this.next();
            
            var prop = this.startNode(),
                isGenerator,
                startPos,
                startLoc;

            if (extra.ecmaFeatures.experimentalObjectRestSpread && this.type === tt.ellipsis) {
                if (isPattern) {
                    prop = this.parseObjectRest();
                } else {
                    prop = this.parseSpread();
                    prop.type = "ExperimentalSpreadProperty";
                }

                node.properties.push(prop);
                continue;
            }

            if (this.options.ecmaVersion >= 6) {
                prop.method = false;
                prop.shorthand = false;

                if (isPattern || refShorthandDefaultPos) {
                    startPos = this.start;
                    startLoc = this.startLoc;
                }

                if (!isPattern) {
                    isGenerator = this.eat(tt.star);
                }
            }

            this.parsePropertyName(prop);
            this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos);
            this.checkPropClash(prop, propHash);
            node.properties.push(this.finishNode(prop, "Property"));
        }

        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    };

    instance.raise = instance.raiseRecoverable = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        var err = new SyntaxError(message);
        err.index = pos;
        err.lineNumber = loc.line;
        err.column = loc.column; // acorn uses 0-based columns
        throw err;
    };

    instance.unexpected = function(pos) {
        var message = "Unexpected token";

        if (pos !== null && pos !== undefined) {
            this.pos = pos;

            if (this.options.locations) {
                while (this.pos < this.lineStart) {
                    this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
                    --this.curLine;
                }
            }

            this.nextToken();
        }

        if (this.end > this.start) {
            message += " " + this.input.slice(this.start, this.end);
        }

        this.raise(this.start, message);
    };

    instance.extend("jsx_readString", function(jsxReadString) {
        return /** @this acorn.Parser */ function(quote) {
            var result = jsxReadString.call(this, quote);
            if (this.type === tt.string) {
                extra.jsxAttrValueToken = true;
            }

            return result;
        };
    });
};

function tokenize(code, options) {
    var toString,
        tokens,
        impliedStrict,
        translator = new TokenTranslator(tt, code);

    toString = String;
    if (typeof code !== "string" && !(code instanceof String)) {
        code = toString(code);
    }

    lookahead = null;

    options = options || {};

    var acornOptions = {
        ecmaVersion: 5,
        plugins: {
            espree: true
        }
    };

    resetExtra();

    options.tokens = true;
    extra.tokens = [];

    extra.range = (typeof options.range === "boolean") && options.range;
    acornOptions.ranges = extra.range;

    extra.loc = (typeof options.loc === "boolean") && options.loc;
    acornOptions.locations = extra.loc;

    extra.comment = typeof options.comment === "boolean" && options.comment;

    if (extra.comment) {
        acornOptions.onComment = function() {
            var comment = convertAcornCommentToEsprimaComment.apply(this, arguments);
            extra.comments.push(comment);
        };
    }

    extra.tolerant = typeof options.tolerant === "boolean" && options.tolerant;

    if (typeof options.ecmaVersion === "number") {
        switch (options.ecmaVersion) {
            case 3:
            case 5:
            case 6:
            case 7:
                acornOptions.ecmaVersion = options.ecmaVersion;
                extra.ecmaVersion = options.ecmaVersion;
                break;

            default:
                throw new Error("ecmaVersion must be 3, 5, 6, or 7.");
        }
    }

    if (options.ecmaFeatures && typeof options.ecmaFeatures === "object") {
        extra.ecmaFeatures = options.ecmaFeatures;
        impliedStrict = extra.ecmaFeatures.impliedStrict;
        extra.ecmaFeatures.impliedStrict = typeof impliedStrict === "boolean" && impliedStrict;
    }

    try {
        var tokenizer = acorn.tokenizer(code, acornOptions);
        while ((lookahead = tokenizer.getToken()).type !== tt.eof) {
            translator.onToken(lookahead, extra);
        }

        tokens = extra.tokens;

        if (extra.comment) {
            tokens.comments = extra.comments;
        }
        if (extra.tolerant) {
            tokens.errors = extra.errors;
        }
    } catch (e) {
        throw e;
    }
    return tokens;
}



function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {
    var comment = {
        type: block ? "Block" : "Line",
        value: text
    };

    if (typeof start === "number") {
        comment.start = start;
        comment.end = end;
        comment.range = [start, end];
    }

    if (typeof startLoc === "object") {
        comment.loc = {
            start: startLoc,
            end: endLoc
        };
    }

    return comment;
}

function parse(code, options) {
    var program,
        toString = String,
        translator,
        impliedStrict,
        acornOptions = {
            ecmaVersion: 5,
            plugins: {
                espree: true
            }
        };

    lastToken = null;

    if (typeof code !== "string" && !(code instanceof String)) {
        code = toString(code);
    }

    resetExtra();
    commentAttachment.reset();

    if (typeof options !== "undefined") {
        extra.range = (typeof options.range === "boolean") && options.range;
        extra.loc = (typeof options.loc === "boolean") && options.loc;
        extra.attachComment = (typeof options.attachComment === "boolean") && options.attachComment;

        if (extra.loc && options.source !== null && options.source !== undefined) {
            extra.source = toString(options.source);
        }

        if (typeof options.tokens === "boolean" && options.tokens) {
            extra.tokens = [];
            translator = new TokenTranslator(tt, code);
        }
        if (typeof options.comment === "boolean" && options.comment) {
            extra.comment = true;
            extra.comments = [];
        }
        if (typeof options.tolerant === "boolean" && options.tolerant) {
            extra.errors = [];
        }
        if (extra.attachComment) {
            extra.range = true;
            extra.comments = [];
            commentAttachment.reset();
        }

        if (typeof options.ecmaVersion === "number") {
            switch (options.ecmaVersion) {
                case 3:
                case 5:
                case 6:
                case 7:
                    acornOptions.ecmaVersion = options.ecmaVersion;
                    extra.ecmaVersion = options.ecmaVersion;
                    break;

                default:
                    throw new Error("ecmaVersion must be 3, 5, 6, or 7.");
            }
        }

        if (options.sourceType === "module") {
            extra.isModule = true;

            if (acornOptions.ecmaVersion < 6) {
                acornOptions.ecmaVersion = 6;
                extra.ecmaVersion = 6;
            }

            acornOptions.sourceType = "module";
        }

        if (options.ecmaFeatures && typeof options.ecmaFeatures === "object") {
            extra.ecmaFeatures = options.ecmaFeatures;
            impliedStrict = extra.ecmaFeatures.impliedStrict;
            extra.ecmaFeatures.impliedStrict = typeof impliedStrict === "boolean" && impliedStrict;
            if (options.ecmaFeatures.globalReturn) {
                acornOptions.allowReturnOutsideFunction = true;
            }
        }


        acornOptions.onToken = function(token) {
            if (extra.tokens) {
                translator.onToken(token, extra);
            }
            if (token.type !== tt.eof) {
                lastToken = token;
            }
        };

        if (extra.attachComment || extra.comment) {
            acornOptions.onComment = function() {
                var comment = convertAcornCommentToEsprimaComment.apply(this, arguments);
                extra.comments.push(comment);

                if (extra.attachComment) {
                    commentAttachment.addComment(comment);
                }
            };
        }

        if (extra.range) {
            acornOptions.ranges = true;
        }

        if (extra.loc) {
            acornOptions.locations = true;
        }

        if (extra.ecmaFeatures.jsx) {
            acornOptions.plugins = {
                jsx: true,
                espree: true
            };
        }
    }

    program = acorn.parse(code, acornOptions);
    program.sourceType = extra.isModule ? "module" : "script";

    if (extra.comment || extra.attachComment) {
        program.comments = extra.comments;
    }

    if (extra.tokens) {
        program.tokens = extra.tokens;
    }

    if (program.range) {
        program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];
        program.range[1] = lastToken ? lastToken.range[1] : program.range[1];
    }

    if (program.loc) {
        program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;
        program.loc.end = lastToken ? lastToken.loc.end : program.loc.end;
    }

    return program;
}

exports.version = require("./package.json").version;

exports.tokenize = tokenize;

exports.parse = parse;

exports.Syntax = (function() {
    var name, types = {};

    if (typeof Object.create === "function") {
        types = Object.create(null);
    }

    for (name in astNodeTypes) {
        if (astNodeTypes.hasOwnProperty(name)) {
            types[name] = astNodeTypes[name];
        }
    }

    if (typeof Object.freeze === "function") {
        Object.freeze(types);
    }

    return types;
}());

exports.VisitorKeys = (function() {
    var visitorKeys = require("./lib/visitor-keys");
    var name,
        keys = {};

    if (typeof Object.create === "function") {
        keys = Object.create(null);
    }

    for (name in visitorKeys) {
        if (visitorKeys.hasOwnProperty(name)) {
            keys[name] = visitorKeys[name];
        }
    }

    if (typeof Object.freeze === "function") {
        Object.freeze(keys);
    }

    return keys;
}());

},
   {"./lib/ast-node-types":"/node_modules/espree/lib/ast-node-types.js","./lib/comment-attachment":"/node_modules/espree/lib/comment-attachment.js","./lib/token-translator":"/node_modules/espree/lib/token-translator.js","./lib/visitor-keys":"/node_modules/espree/lib/visitor-keys.js","./package.json":"/node_modules/espree/package.json","acorn":"/../acorn/dist/acorn.js","acorn-jsx/inject":"/node_modules/espree/node_modules/acorn-jsx/inject.js"}]},{},[]);

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.eslint = f()}})(function(){var define,module,exports;return (function outer (modules, cache, entry) {
    var previousRequire = typeof require == "function" && require;

    function newRequire(name, jumped){
        if(!cache[name]) {
            if(!modules[name]) {
                var currentRequire = typeof require == "function" && require;
                if (!jumped && currentRequire) return currentRequire(name, true);

                if (previousRequire) return previousRequire(name, true);
                var err = new Error('Cannot find module \'' + name + '\'');
                err.code = 'MODULE_NOT_FOUND';
                throw err;
            }
            var m = cache[name] = {exports:{}};
            modules[name][0].call(m.exports, function(x){
                var id = modules[name][1][x];
                return newRequire(id ? id : x);
            },m,m.exports,outer,modules,cache,entry);
        }
        return cache[name].exports;
    }
    for(var i=0;i<entry.length;i++) newRequire(entry[i]);

    return newRequire;
})({
"/conf/blank-script.json": [function(require,module,exports){
module.exports={
  "type": "Program",
  "body": [],
  "sourceType": "script",
  "range": [
    0,
    0
  ],
  "loc": {
    "start": {
      "line": 0,
      "column": 0
    },
    "end": {
      "line": 0,
      "column": 0
    }
  },
  "comments": [],
  "tokens": []
}

},
   {}],

"/conf/environments.js": [function(require,module,exports){
"use strict";

var globals = require("globals");

module.exports = {
    builtin: globals.es6,
    browser: {
        globals: globals.browser
    },
    node: {
        globals: globals.node,
        parserOptions: {
            ecmaFeatures: {
                globalReturn: true
            }
        }
    },
    commonjs: {
        globals: globals.commonjs,
        parserOptions: {
            ecmaFeatures: {
                globalReturn: true
            }
        }
    },
    "shared-node-browser": {
        globals: globals["shared-node-browser"]
    },
    worker: {
        globals: globals.worker
    },
    amd: {
        globals: globals.amd
    },
    mocha: {
        globals: globals.mocha
    },
    jasmine: {
        globals: globals.jasmine
    },
    jest: {
        globals: globals.jest
    },
    phantomjs: {
        globals: globals.phantomjs
    },
    jquery: {
        globals: globals.jquery
    },
    qunit: {
        globals: globals.qunit
    },
    prototypejs: {
        globals: globals.prototypejs
    },
    shelljs: {
        globals: globals.shelljs
    },
    meteor: {
        globals: globals.meteor
    },
    mongo: {
        globals: globals.mongo
    },
    protractor: {
        globals: globals.protractor
    },
    applescript: {
        globals: globals.applescript
    },
    nashorn: {
        globals: globals.nashorn
    },
    serviceworker: {
        globals: globals.serviceworker
    },
    atomtest: {
        globals: globals.atomtest
    },
    embertest: {
        globals: globals.embertest
    },
    webextensions: {
        globals: globals.webextensions
    },
    es6: {
        globals: globals.es6,
        parserOptions: {
            ecmaVersion: 6
        }
    },
    greasemonkey: {
        globals: globals.greasemonkey
    }
};

},
   {"globals":"/node_modules/globals/index.js"}],

"/conf/eslint.json": [function(require,module,exports){
module.exports={
    "parser": "espree",
    "ecmaFeatures": {},
    "rules": {
        "no-alert": "off",
        "no-array-constructor": "off",
        "no-bitwise": "off",
        "no-caller": "off",
        "no-case-declarations": "error",
        "no-catch-shadow": "off",
        "no-class-assign": "error",
        "no-cond-assign": "error",
        "no-confusing-arrow": "off",
        "no-console": "error",
        "no-const-assign": "error",
        "no-constant-condition": "error",
        "no-continue": "off",
        "no-control-regex": "error",
        "no-debugger": "error",
        "no-delete-var": "error",
        "no-div-regex": "off",
        "no-dupe-class-members": "error",
        "no-dupe-keys": "error",
        "no-dupe-args": "error",
        "no-duplicate-case": "error",
        "no-else-return": "off",
        "no-empty": "error",
        "no-empty-character-class": "error",
        "no-empty-function": "off",
        "no-empty-pattern": "error",
        "no-eq-null": "off",
        "no-eval": "off",
        "no-ex-assign": "error",
        "no-extend-native": "off",
        "no-extra-bind": "off",
        "no-extra-boolean-cast": "error",
        "no-extra-label": "off",
        "no-extra-parens": "off",
        "no-extra-semi": "error",
        "no-fallthrough": "error",
        "no-floating-decimal": "off",
        "no-func-assign": "error",
        "no-implicit-coercion": "off",
        "no-implicit-globals": "off",
        "no-implied-eval": "off",
        "no-inline-comments": "off",
        "no-inner-declarations": "error",
        "no-invalid-regexp": "error",
        "no-invalid-this": "off",
        "no-irregular-whitespace": "error",
        "no-iterator": "off",
        "no-label-var": "off",
        "no-labels": "off",
        "no-lone-blocks": "off",
        "no-lonely-if": "off",
        "no-loop-func": "off",
        "no-mixed-requires": "off",
        "no-mixed-spaces-and-tabs": "error",
        "linebreak-style": "off",
        "no-multi-spaces": "off",
        "no-multi-str": "off",
        "no-multiple-empty-lines": "off",
        "no-native-reassign": "off",
        "no-negated-condition": "off",
        "no-negated-in-lhs": "error",
        "no-nested-ternary": "off",
        "no-new": "off",
        "no-new-func": "off",
        "no-new-object": "off",
        "no-new-require": "off",
        "no-new-symbol": "error",
        "no-new-wrappers": "off",
        "no-obj-calls": "error",
        "no-octal": "error",
        "no-octal-escape": "off",
        "no-param-reassign": "off",
        "no-path-concat": "off",
        "no-plusplus": "off",
        "no-process-env": "off",
        "no-process-exit": "off",
        "no-proto": "off",
        "no-redeclare": "error",
        "no-regex-spaces": "error",
        "no-restricted-globals": "off",
        "no-restricted-imports": "off",
        "no-restricted-modules": "off",
        "no-restricted-syntax": "off",
        "no-return-assign": "off",
        "no-script-url": "off",
        "no-self-assign": "error",
        "no-self-compare": "off",
        "no-sequences": "off",
        "no-shadow": "off",
        "no-shadow-restricted-names": "off",
        "no-whitespace-before-property": "off",
        "no-spaced-func": "off",
        "no-sparse-arrays": "error",
        "no-sync": "off",
        "no-ternary": "off",
        "no-trailing-spaces": "off",
        "no-this-before-super": "error",
        "no-throw-literal": "off",
        "no-undef": "error",
        "no-undef-init": "off",
        "no-undefined": "off",
        "no-unexpected-multiline": "error",
        "no-underscore-dangle": "off",
        "no-unmodified-loop-condition": "off",
        "no-unneeded-ternary": "off",
        "no-unreachable": "error",
        "no-unused-expressions": "off",
        "no-unused-labels": "error",
        "no-unused-vars": "error",
        "no-use-before-define": "off",
        "no-useless-call": "off",
        "no-useless-concat": "off",
        "no-useless-constructor": "off",
        "no-void": "off",
        "no-var": "off",
        "no-warning-comments": "off",
        "no-with": "off",
        "no-magic-numbers": "off",
        "array-bracket-spacing": "off",
        "array-callback-return": "off",
        "arrow-body-style": "off",
        "arrow-parens": "off",
        "arrow-spacing": "off",
        "accessor-pairs": "off",
        "block-scoped-var": "off",
        "block-spacing": "off",
        "brace-style": "off",
        "callback-return": "off",
        "camelcase": "off",
        "comma-dangle": "error",
        "comma-spacing": "off",
        "comma-style": "off",
        "complexity": ["off", 11],
        "computed-property-spacing": "off",
        "consistent-return": "off",
        "consistent-this": "off",
        "constructor-super": "error",
        "curly": "off",
        "default-case": "off",
        "dot-location": "off",
        "dot-notation": "off",
        "eol-last": "off",
        "eqeqeq": "off",
        "func-names": "off",
        "func-style": "off",
        "generator-star-spacing": "off",
        "global-require": "off",
        "guard-for-in": "off",
        "handle-callback-err": "off",
        "id-length": "off",
        "indent": "off",
        "init-declarations": "off",
        "jsx-quotes": "off",
        "key-spacing": "off",
        "keyword-spacing": "off",
        "lines-around-comment": "off",
        "max-depth": "off",
        "max-len": "off",
        "max-nested-callbacks": "off",
        "max-params": "off",
        "max-statements": "off",
        "new-cap": "off",
        "new-parens": "off",
        "newline-after-var": "off",
        "newline-before-return": "off",
        "newline-per-chained-call": "off",
        "object-curly-spacing": ["off", "never"],
        "object-shorthand": "off",
        "one-var": "off",
        "one-var-declaration-per-line": "off",
        "operator-assignment": "off",
        "operator-linebreak": "off",
        "padded-blocks": "off",
        "prefer-arrow-callback": "off",
        "prefer-const": "off",
        "prefer-reflect": "off",
        "prefer-rest-params": "off",
        "prefer-spread": "off",
        "prefer-template": "off",
        "quote-props": "off",
        "quotes": "off",
        "radix": "off",
        "id-match": "off",
        "id-blacklist": "off",
        "require-jsdoc": "off",
        "require-yield": "off",
        "semi": "off",
        "semi-spacing": "off",
        "sort-vars": "off",
        "sort-imports": "off",
        "space-before-blocks": "off",
        "space-before-function-paren": "off",
        "space-in-parens": "off",
        "space-infix-ops": "off",
        "space-unary-ops": "off",
        "spaced-comment": "off",
        "strict": "off",
        "template-curly-spacing": "off",
        "use-isnan": "error",
        "valid-jsdoc": "off",
        "valid-typeof": "error",
        "vars-on-top": "off",
        "wrap-iife": "off",
        "wrap-regex": "off",
        "yield-star-spacing": "off",
        "yoda": "off"
    }
}

},
   {}],

"/conf/replacements.json": [function(require,module,exports){
module.exports={
    "rules": {
        "generator-star": ["generator-star-spacing"],
        "global-strict": ["strict"],
        "no-arrow-condition": ["no-confusing-arrow", "no-constant-condition"],
        "no-comma-dangle": ["comma-dangle"],
        "no-empty-class": ["no-empty-character-class"],
        "no-empty-label": ["no-labels"],
        "no-extra-strict": ["strict"],
        "no-reserved-keys": ["quote-props"],
        "no-space-before-semi": ["semi-spacing"],
        "no-wrap-func": ["no-extra-parens"],
        "space-after-function-name": ["space-before-function-paren"],
        "space-after-keywords": ["keyword-spacing"],
        "space-before-function-parentheses": ["space-before-function-paren"],
        "space-before-keywords": ["keyword-spacing"],
        "space-in-brackets": ["object-curly-spacing", "array-bracket-spacing", "computed-property-spacing"],
        "space-return-throw-case": ["keyword-spacing"],
        "space-unary-word-ops": ["space-unary-ops"],
        "spaced-line-comment": ["spaced-comment"]
    }
}

},
   {}],

"/node_modules/browserify/node_modules/assert/assert.js": [function(require,module,exports){
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

var assert = module.exports = ok;

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

assert.fail = fail;

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  if (a.prototype !== b.prototype) return false;
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  if (ka.length != kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},
   {"util/":"/node_modules/browserify/node_modules/util/util.js"}],

"/node_modules/browserify/node_modules/events/events.js": [function(require,module,exports){
function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

EventEmitter.defaultMaxListeners = 10;

EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    this._events[type].push(listener);
  else
    this._events[type] = [this._events[type], listener];

  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},
   {}],

"/node_modules/browserify/node_modules/inherits/inherits_browser.js": [function(require,module,exports){
if (typeof Object.create === 'function') {
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},
   {}],

"/node_modules/browserify/node_modules/path-browserify/index.js": [function(require,module,exports){
(function (process){
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    return '.';
  }

  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},
   {"_process":"/node_modules/browserify/node_modules/process/browser.js"}],

"/node_modules/browserify/node_modules/process/browser.js": [function(require,module,exports){
var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},
   {}],

"/node_modules/browserify/node_modules/util/support/isBufferBrowser.js": [function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},
   {}],

"/node_modules/browserify/node_modules/util/util.js": [function(require,module,exports){
(function (process,global){
var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


exports.deprecate = function(fn, msg) {
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    exports._extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      value.inspect !== exports.inspect &&
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},
   {"./support/isBuffer":"/node_modules/browserify/node_modules/util/support/isBufferBrowser.js","_process":"/node_modules/browserify/node_modules/process/browser.js","inherits":"/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],

"/node_modules/debug/browser.js": [function(require,module,exports){

exports = module.exports = require('./debug');

},
   {"./debug":"/node_modules/debug/debug.js"}],

"/node_modules/debug/debug.js": [function(require,module,exports){

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

exports.names = [];
exports.skips = [];

exports.formatters = {};

var prevColor = 0;

var prevTime;

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

function debug(namespace) {

  function disabled() {
  }
  disabled.enabled = false;

  function enabled() {

    var self = enabled;

    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      args = ['%o'].concat(args);
    }

    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

function disable() {
  exports.enable('');
}

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},
   {"ms":"/node_modules/debug/node_modules/ms/index.js"}],

"/node_modules/debug/node_modules/ms/index.js": [function(require,module,exports){
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},
   {}],

"/node_modules/doctrine/lib/doctrine.js": [function(require,module,exports){
(function () {
    'use strict';

    var typed,
        utility,
        isArray,
        jsdoc,
        esutils,
        hasOwnProperty;

    esutils = require('esutils');
    isArray = require('isarray');
    typed = require('./typed');
    utility = require('./utility');

    function sliceSource(source, index, last) {
        return source.slice(index, last);
    }

    hasOwnProperty = (function () {
        var func = Object.prototype.hasOwnProperty;
        return function hasOwnProperty(obj, name) {
            return func.call(obj, name);
        };
    }());

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }

    function isASCIIAlphanumeric(ch) {
        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||
            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||
            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);
    }

    function isParamTitle(title) {
        return title === 'param' || title === 'argument' || title === 'arg';
    }

    function isReturnTitle(title) {
        return title === 'return' || title === 'returns';
    }

    function isProperty(title) {
        return title === 'property' || title === 'prop';
    }

    function isNameParameterRequired(title) {
        return isParamTitle(title) || isProperty(title) ||
            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';
    }

    function isAllowedName(title) {
        return isNameParameterRequired(title) || title === 'const' || title === 'constant';
    }

    function isAllowedNested(title) {
        return isProperty(title) || isParamTitle(title);
    }

    function isTypeParameterRequired(title) {
        return isParamTitle(title) || isReturnTitle(title) ||
            title === 'define' || title === 'enum' ||
            title === 'implements' || title === 'this' ||
            title === 'type' || title === 'typedef' || isProperty(title);
    }

    function isAllowedType(title) {
        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||
            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||
            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||
            title === 'public' || title === 'private' || title === 'protected';
    }

    function trim(str) {
        return str.replace(/^\s+/, '').replace(/\s+$/, '');
    }

    function unwrapComment(doc) {
        var BEFORE_STAR = 0,
            STAR = 1,
            AFTER_STAR = 2,
            index,
            len,
            mode,
            result,
            ch;

        doc = doc.replace(/^\/\*\*?/, '').replace(/\*\/$/, '');
        index = 0;
        len = doc.length;
        mode = BEFORE_STAR;
        result = '';

        while (index < len) {
            ch = doc.charCodeAt(index);
            switch (mode) {
            case BEFORE_STAR:
                if (esutils.code.isLineTerminator(ch)) {
                    result += String.fromCharCode(ch);
                } else if (ch === 0x2A  /* '*' */) {
                    mode = STAR;
                } else if (!esutils.code.isWhiteSpace(ch)) {
                    result += String.fromCharCode(ch);
                    mode = AFTER_STAR;
                }
                break;

            case STAR:
                if (!esutils.code.isWhiteSpace(ch)) {
                    result += String.fromCharCode(ch);
                }
                mode = esutils.code.isLineTerminator(ch) ? BEFORE_STAR : AFTER_STAR;
                break;

            case AFTER_STAR:
                result += String.fromCharCode(ch);
                if (esutils.code.isLineTerminator(ch)) {
                    mode = BEFORE_STAR;
                }
                break;
            }
            index += 1;
        }

        return result.replace(/\s+$/, '');
    }

    (function (exports) {
        var Rules,
            index,
            lineNumber,
            length,
            source,
            recoverable,
            sloppy,
            strict;

        function advance() {
            var ch = source.charCodeAt(index);
            index += 1;
            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\r' */ && source.charCodeAt(index) === 0x0A  /* '\n' */)) {
                lineNumber += 1;
            }
            return String.fromCharCode(ch);
        }

        function scanTitle() {
            var title = '';
            advance();

            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {
                title += advance();
            }

            return title;
        }

        function seekContent() {
            var ch, waiting, last = index;

            waiting = false;
            while (last < length) {
                ch = source.charCodeAt(last);
                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\n' */)) {
                    waiting = true;
                } else if (waiting) {
                    if (ch === 0x40  /* '@' */) {
                        break;
                    }
                    if (!esutils.code.isWhiteSpace(ch)) {
                        waiting = false;
                    }
                }
                last += 1;
            }
            return last;
        }

        function parseType(title, last) {
            var ch, brace, type, direct = false;


            while (index < last) {
                ch = source.charCodeAt(index);
                if (esutils.code.isWhiteSpace(ch)) {
                    advance();
                } else if (ch === 0x7B  /* '{' */) {
                    advance();
                    break;
                } else {
                    direct = true;
                    break;
                }
            }


            if (direct) {
                return null;
            }

            brace = 1;
            type = '';
            while (index < last) {
                ch = source.charCodeAt(index);
                if (esutils.code.isLineTerminator(ch)) {
                    advance();
                } else {
                    if (ch === 0x7D  /* '}' */) {
                        brace -= 1;
                        if (brace === 0) {
                            advance();
                            break;
                        }
                    } else if (ch === 0x7B  /* '{' */) {
                        brace += 1;
                    }
                    type += advance();
                }
            }

            if (brace !== 0) {
                return utility.throwError('Braces are not balanced');
            }

            if (isParamTitle(title)) {
                return typed.parseParamType(type);
            }
            return typed.parseType(type);
        }

        function scanIdentifier(last) {
            var identifier;
            if (!esutils.code.isIdentifierStart(source.charCodeAt(index))) {
                return null;
            }
            identifier = advance();
            while (index < last && esutils.code.isIdentifierPart(source.charCodeAt(index))) {
                identifier += advance();
            }
            return identifier;
        }

        function skipWhiteSpace(last) {
            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
                advance();
            }
        }

        function parseName(last, allowBrackets, allowNestedParams) {
            var name = '', useBrackets;

            skipWhiteSpace(last);

            if (index >= last) {
                return null;
            }

            if (allowBrackets && source.charCodeAt(index) === 0x5B  /* '[' */) {
                useBrackets = true;
                name = advance();
            }

            if (!esutils.code.isIdentifierStart(source.charCodeAt(index))) {
                return null;
            }

            name += scanIdentifier(last);

            if (allowNestedParams) {
                if (source.charCodeAt(index) === 0x3A /* ':' */ && (
                        name === 'module' ||
                        name === 'external' ||
                        name === 'event')) {
                    name += advance();
                    name += scanIdentifier(last);

                }
                if(source.charCodeAt(index) === 0x5B  /* '[' */ && source.charCodeAt(index + 1) === 0x5D  /* ']' */){
                    name += advance();
                    name += advance();
                }
                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||
                        source.charCodeAt(index) === 0x2F  /* '/' */ ||
                        source.charCodeAt(index) === 0x23  /* '#' */ ||
                        source.charCodeAt(index) === 0x7E  /* '~' */) {
                    name += advance();
                    name += scanIdentifier(last);
                }
            }

            if (useBrackets) {
                skipWhiteSpace(last);
                if (source.charCodeAt(index) === 0x3D  /* '=' */) {
                    name += advance();
                    skipWhiteSpace(last);

                    var ch;
                    var bracketDepth = 1;
                    while (index < last) {
                        ch = source.charCodeAt(index);

                        if (esutils.code.isWhiteSpace(ch)) {
                            skipWhiteSpace(last);
                            ch = source.charCodeAt(index);
                        }

                        if (ch === 0x5B /* '[' */) {
                            bracketDepth++;
                        } else if (ch === 0x5D  /* ']' */ &&
                            --bracketDepth === 0) {
                            break;
                        }

                        name += advance();
                    }
                }

                skipWhiteSpace(last);

                if (index >= last  || source.charCodeAt(index) !== 0x5D  /* ']' */) {
                    return null;
                }

                name += advance();
            }

            return name;
        }

        function skipToTag() {
            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) {
                advance();
            }
            if (index >= length) {
                return false;
            }
            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);
            return true;
        }

        function TagParser(options, title) {
            this._options = options;
            this._title = title;
            this._tag = {
                title: title,
                description: null
            };
            if (this._options.lineNumbers) {
                this._tag.lineNumber = lineNumber;
            }
            this._last = 0;
            this._extra = { };
        }

        TagParser.prototype.addError = function addError(errorText) {
            var args = Array.prototype.slice.call(arguments, 1),
                msg = errorText.replace(
                    /%(\d)/g,
                    function (whole, index) {
                        utility.assert(index < args.length, 'Message reference must be in range');
                        return args[index];
                    }
                );

            if (!this._tag.errors) {
                this._tag.errors = [];
            }
            if (strict) {
                utility.throwError(msg);
            }
            this._tag.errors.push(msg);
            return recoverable;
        };

        TagParser.prototype.parseType = function () {
            if (isTypeParameterRequired(this._title)) {
                try {
                    this._tag.type = parseType(this._title, this._last);
                    if (!this._tag.type) {
                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {
                            if (!this.addError('Missing or invalid tag type')) {
                                return false;
                            }
                        }
                    }
                } catch (error) {
                    this._tag.type = null;
                    if (!this.addError(error.message)) {
                        return false;
                    }
                }
            } else if (isAllowedType(this._title)) {
                try {
                    this._tag.type = parseType(this._title, this._last);
                } catch (e) {
                }
            }
            return true;
        };

        TagParser.prototype._parseNamePath = function (optional) {
            var name;
            name = parseName(this._last, sloppy && isParamTitle(this._title), true);
            if (!name) {
                if (!optional) {
                    if (!this.addError('Missing or invalid tag name')) {
                        return false;
                    }
                }
            }
            this._tag.name = name;
            return true;
        };

        TagParser.prototype.parseNamePath = function () {
            return this._parseNamePath(false);
        };

        TagParser.prototype.parseNamePathOptional = function () {
            return this._parseNamePath(true);
        };


        TagParser.prototype.parseName = function () {
            var assign, name;

            if (isAllowedName(this._title)) {
                this._tag.name = parseName(this._last, sloppy && isParamTitle(this._title), isAllowedNested(this._title));
                if (!this._tag.name) {
                    if (!isNameParameterRequired(this._title)) {
                        return true;
                    }

                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {
                        this._extra.name = this._tag.type;
                        this._tag.name = this._tag.type.name;
                        this._tag.type = null;
                    } else {
                        if (!this.addError('Missing or invalid tag name')) {
                            return false;
                        }
                    }
                } else {
                    name = this._tag.name;
                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {
                        assign = name.substring(1, name.length - 1).split('=');
                        if (assign[1]) {
                            this._tag['default'] = assign[1];
                        }
                        this._tag.name = assign[0];

                        if (this._tag.type && this._tag.type.type !== 'OptionalType') {
                            this._tag.type = {
                                type: 'OptionalType',
                                expression: this._tag.type
                            };
                        }
                    }
                }
            }

            return true;
        };

        TagParser.prototype.parseDescription = function parseDescription() {
            var description = trim(sliceSource(source, index, this._last));
            if (description) {
                if ((/^-\s+/).test(description)) {
                    description = description.substring(2);
                }
                this._tag.description = description;
            }
            return true;
        };

        TagParser.prototype.parseCaption = function parseDescription() {
            var description = trim(sliceSource(source, index, this._last));
            var captionStartTag = '<caption>';
            var captionEndTag = '</caption>';
            var captionStart = description.indexOf(captionStartTag);
            var captionEnd = description.indexOf(captionEndTag);
            if (captionStart >= 0 && captionEnd >= 0) {
                this._tag.caption = trim(description.substring(
                    captionStart + captionStartTag.length, captionEnd));
                this._tag.description = trim(description.substring(captionEnd + captionEndTag.length));
            } else {
                this._tag.description = description;
            }
            return true;
        };

        TagParser.prototype.parseKind = function parseKind() {
            var kind, kinds;
            kinds = {
                'class': true,
                'constant': true,
                'event': true,
                'external': true,
                'file': true,
                'function': true,
                'member': true,
                'mixin': true,
                'module': true,
                'namespace': true,
                'typedef': true
            };
            kind = trim(sliceSource(source, index, this._last));
            this._tag.kind = kind;
            if (!hasOwnProperty(kinds, kind)) {
                if (!this.addError('Invalid kind name \'%0\'', kind)) {
                    return false;
                }
            }
            return true;
        };

        TagParser.prototype.parseAccess = function parseAccess() {
            var access;
            access = trim(sliceSource(source, index, this._last));
            this._tag.access = access;
            if (access !== 'private' && access !== 'protected' && access !== 'public') {
                if (!this.addError('Invalid access name \'%0\'', access)) {
                    return false;
                }
            }
            return true;
        };

        TagParser.prototype.parseThis = function parseAccess() {
            var value = trim(sliceSource(source, index, this._last));
            if (value && value.charAt(0) === '{') {
                var gotType = this.parseType();
                if (gotType && this._tag.type.type === 'NameExpression') {
                    this._tag.name = this._tag.type.name;
                    return true;
                } else {
                    return this.addError('Invalid name for this');
                }
            } else {
                return this.parseNamePath();
            }
        };

        TagParser.prototype.parseVariation = function parseVariation() {
            var variation, text;
            text = trim(sliceSource(source, index, this._last));
            variation = parseFloat(text, 10);
            this._tag.variation = variation;
            if (isNaN(variation)) {
                if (!this.addError('Invalid variation \'%0\'', text)) {
                    return false;
                }
            }
            return true;
        };

        TagParser.prototype.ensureEnd = function () {
            var shouldBeEmpty = trim(sliceSource(source, index, this._last));
            if (shouldBeEmpty) {
                if (!this.addError('Unknown content \'%0\'', shouldBeEmpty)) {
                    return false;
                }
            }
            return true;
        };

        TagParser.prototype.epilogue = function epilogue() {
            var description;

            description = this._tag.description;
            if (isParamTitle(this._title) && !this._tag.type && description && description.charAt(0) === '[') {
                this._tag.type = this._extra.name;
                if (!this._tag.name) {
                    this._tag.name = undefined;
                }

                if (!sloppy) {
                    if (!this.addError('Missing or invalid tag name')) {
                        return false;
                    }
                }
            }

            return true;
        };

        Rules = {
            'access': ['parseAccess'],
            'alias': ['parseNamePath', 'ensureEnd'],
            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'example': ['parseCaption'],
            'deprecated': ['parseDescription'],
            'global': ['ensureEnd'],
            'inner': ['ensureEnd'],
            'instance': ['ensureEnd'],
            'kind': ['parseKind'],
            'mixes': ['parseNamePath', 'ensureEnd'],
            'mixin': ['parseNamePathOptional', 'ensureEnd'],
            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'method': ['parseNamePathOptional', 'ensureEnd'],
            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'func': ['parseNamePathOptional', 'ensureEnd'],
            'function': ['parseNamePathOptional', 'ensureEnd'],
            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'name': ['parseNamePath', 'ensureEnd'],
            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'private': ['parseType', 'parseDescription'],
            'protected': ['parseType', 'parseDescription'],
            'public': ['parseType', 'parseDescription'],
            'readonly': ['ensureEnd'],
            'requires': ['parseNamePath', 'ensureEnd'],
            'since': ['parseDescription'],
            'static': ['ensureEnd'],
            'summary': ['parseDescription'],
            'this': ['parseThis', 'ensureEnd'],
            'todo': ['parseDescription'],
            'typedef': ['parseType', 'parseNamePathOptional'],
            'variation': ['parseVariation'],
            'version': ['parseDescription']
        };

        TagParser.prototype.parse = function parse() {
            var i, iz, sequences, method;

            if (!this._title) {
                if (!this.addError('Missing or invalid title')) {
                    return null;
                }
            }

            this._last = seekContent(this._title);

            if (hasOwnProperty(Rules, this._title)) {
                sequences = Rules[this._title];
            } else {
                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];
            }

            for (i = 0, iz = sequences.length; i < iz; ++i) {
                method = sequences[i];
                if (!this[method]()) {
                    return null;
                }
            }

            return this._tag;
        };

        function parseTag(options) {
            var title, parser, tag;

            if (!skipToTag()) {
                return null;
            }

            title = scanTitle();

            parser = new TagParser(options, title);
            tag = parser.parse();

            while (index < parser._last) {
                advance();
            }
            return tag;
        }

        function scanJSDocDescription(preserveWhitespace) {
            var description = '', ch, atAllowed;

            atAllowed = true;
            while (index < length) {
                ch = source.charCodeAt(index);

                if (atAllowed && ch === 0x40  /* '@' */) {
                    break;
                }

                if (esutils.code.isLineTerminator(ch)) {
                    atAllowed = true;
                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {
                    atAllowed = false;
                }

                description += advance();
            }

            return preserveWhitespace ? description : trim(description);
        }

        function parse(comment, options) {
            var tags = [], tag, description, interestingTags, i, iz;

            if (options === undefined) {
                options = {};
            }

            if (typeof options.unwrap === 'boolean' && options.unwrap) {
                source = unwrapComment(comment);
            } else {
                source = comment;
            }

            if (options.tags) {
                if (isArray(options.tags)) {
                    interestingTags = { };
                    for (i = 0, iz = options.tags.length; i < iz; i++) {
                        if (typeof options.tags[i] === 'string') {
                            interestingTags[options.tags[i]] = true;
                        } else {
                            utility.throwError('Invalid "tags" parameter: ' + options.tags);
                        }
                    }
                } else {
                    utility.throwError('Invalid "tags" parameter: ' + options.tags);
                }
            }

            length = source.length;
            index = 0;
            lineNumber = 0;
            recoverable = options.recoverable;
            sloppy = options.sloppy;
            strict = options.strict;

            description = scanJSDocDescription(options.preserveWhitespace);

            while (true) {
                tag = parseTag(options);
                if (!tag) {
                    break;
                }
                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
                    tags.push(tag);
                }
            }

            return {
                description: description,
                tags: tags
            };
        }
        exports.parse = parse;
    }(jsdoc = {}));

    exports.version = utility.VERSION;
    exports.parse = jsdoc.parse;
    exports.parseType = typed.parseType;
    exports.parseParamType = typed.parseParamType;
    exports.unwrapComment = unwrapComment;
    exports.Syntax = shallowCopy(typed.Syntax);
    exports.Error = utility.DoctrineError;
    exports.type = {
        Syntax: exports.Syntax,
        parseType: typed.parseType,
        parseParamType: typed.parseParamType,
        stringify: typed.stringify
    };
}());

},
   {"./typed":"/node_modules/doctrine/lib/typed.js","./utility":"/node_modules/doctrine/lib/utility.js","esutils":"/node_modules/doctrine/node_modules/esutils/lib/utils.js","isarray":"/node_modules/doctrine/node_modules/isarray/index.js"}],

"/node_modules/doctrine/lib/typed.js": [function(require,module,exports){
(function () {
    'use strict';

    var Syntax,
        Token,
        source,
        length,
        index,
        previous,
        token,
        value,
        esutils,
        utility;

    esutils = require('esutils');
    utility = require('./utility');

    Syntax = {
        NullableLiteral: 'NullableLiteral',
        AllLiteral: 'AllLiteral',
        NullLiteral: 'NullLiteral',
        UndefinedLiteral: 'UndefinedLiteral',
        VoidLiteral: 'VoidLiteral',
        UnionType: 'UnionType',
        ArrayType: 'ArrayType',
        RecordType: 'RecordType',
        FieldType: 'FieldType',
        FunctionType: 'FunctionType',
        ParameterType: 'ParameterType',
        RestType: 'RestType',
        NonNullableType: 'NonNullableType',
        OptionalType: 'OptionalType',
        NullableType: 'NullableType',
        NameExpression: 'NameExpression',
        TypeApplication: 'TypeApplication'
    };

    Token = {
        ILLEGAL: 0,    // ILLEGAL
        DOT_LT: 1,     // .<
        REST: 2,       // ...
        LT: 3,         // <
        GT: 4,         // >
        LPAREN: 5,     // (
        RPAREN: 6,     // )
        LBRACE: 7,     // {
        RBRACE: 8,     // }
        LBRACK: 9,    // [
        RBRACK: 10,    // ]
        COMMA: 11,     // ,
        COLON: 12,     // :
        STAR: 13,      // *
        PIPE: 14,      // |
        QUESTION: 15,  // ?
        BANG: 16,      // !
        EQUAL: 17,     // =
        NAME: 18,      // name token
        STRING: 19,    // string
        NUMBER: 20,    // number
        EOF: 21
    };

    function isTypeName(ch) {
        return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);
    }

    function Context(previous, index, token, value) {
        this._previous = previous;
        this._index = index;
        this._token = token;
        this._value = value;
    }

    Context.prototype.restore = function () {
        previous = this._previous;
        index = this._index;
        token = this._token;
        value = this._value;
    };

    Context.save = function () {
        return new Context(previous, index, token, value);
    };

    function advance() {
        var ch = source.charAt(index);
        index += 1;
        return ch;
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {
                ch = advance();
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanString() {
        var str = '', quote, ch, code, unescaped, restore; //TODO review removal octal = false
        quote = source.charAt(index);
        ++index;

        while (index < length) {
            ch = advance();

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = advance();
                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'u':
                    case 'x':
                        restore = index;
                        unescaped = scanHexEscape(ch);
                        if (unescaped) {
                            str += unescaped;
                        } else {
                            index = restore;
                            str += ch;
                        }
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\v';
                        break;

                    default:
                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
                            code = '01234567'.indexOf(ch);

                            if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
                                code = code * 8 + '01234567'.indexOf(advance());

                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {
                                    code = code * 8 + '01234567'.indexOf(advance());
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    if (ch ===  '\r' && source.charCodeAt(index) === 0x0A  /* '\n' */) {
                        ++index;
                    }
                }
            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            utility.throwError('unexpected quote');
        }

        value = str;
        return Token.STRING;
    }

    function scanNumber() {
        var number, ch;

        number = '';
        ch = source.charCodeAt(index);

        if (ch !== 0x2E  /* '.' */) {
            number = advance();
            ch = source.charCodeAt(index);

            if (number === '0') {
                if (ch === 0x78  /* 'x' */ || ch === 0x58  /* 'X' */) {
                    number += advance();
                    while (index < length) {
                        ch = source.charCodeAt(index);
                        if (!esutils.code.isHexDigit(ch)) {
                            break;
                        }
                        number += advance();
                    }

                    if (number.length <= 2) {
                        utility.throwError('unexpected token');
                    }

                    if (index < length) {
                        ch = source.charCodeAt(index);
                        if (esutils.code.isIdentifierStart(ch)) {
                            utility.throwError('unexpected token');
                        }
                    }
                    value = parseInt(number, 16);
                    return Token.NUMBER;
                }

                if (esutils.code.isOctalDigit(ch)) {
                    number += advance();
                    while (index < length) {
                        ch = source.charCodeAt(index);
                        if (!esutils.code.isOctalDigit(ch)) {
                            break;
                        }
                        number += advance();
                    }

                    if (index < length) {
                        ch = source.charCodeAt(index);
                        if (esutils.code.isIdentifierStart(ch) || esutils.code.isDecimalDigit(ch)) {
                            utility.throwError('unexpected token');
                        }
                    }
                    value = parseInt(number, 8);
                    return Token.NUMBER;
                }

                if (esutils.code.isDecimalDigit(ch)) {
                    utility.throwError('unexpected token');
                }
            }

            while (index < length) {
                ch = source.charCodeAt(index);
                if (!esutils.code.isDecimalDigit(ch)) {
                    break;
                }
                number += advance();
            }
        }

        if (ch === 0x2E  /* '.' */) {
            number += advance();
            while (index < length) {
                ch = source.charCodeAt(index);
                if (!esutils.code.isDecimalDigit(ch)) {
                    break;
                }
                number += advance();
            }
        }

        if (ch === 0x65  /* 'e' */ || ch === 0x45  /* 'E' */) {
            number += advance();

            ch = source.charCodeAt(index);
            if (ch === 0x2B  /* '+' */ || ch === 0x2D  /* '-' */) {
                number += advance();
            }

            ch = source.charCodeAt(index);
            if (esutils.code.isDecimalDigit(ch)) {
                number += advance();
                while (index < length) {
                    ch = source.charCodeAt(index);
                    if (!esutils.code.isDecimalDigit(ch)) {
                        break;
                    }
                    number += advance();
                }
            } else {
                utility.throwError('unexpected token');
            }
        }

        if (index < length) {
            ch = source.charCodeAt(index);
            if (esutils.code.isIdentifierStart(ch)) {
                utility.throwError('unexpected token');
            }
        }

        value = parseFloat(number);
        return Token.NUMBER;
    }


    function scanTypeName() {
        var ch, ch2;

        value = advance();
        while (index < length && isTypeName(source.charCodeAt(index))) {
            ch = source.charCodeAt(index);
            if (ch === 0x2E  /* '.' */) {
                if ((index + 1) >= length) {
                    return Token.ILLEGAL;
                }
                ch2 = source.charCodeAt(index + 1);
                if (ch2 === 0x3C  /* '<' */) {
                    break;
                }
            }
            value += advance();
        }
        return Token.NAME;
    }

    function next() {
        var ch;

        previous = index;

        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {
            advance();
        }
        if (index >= length) {
            token = Token.EOF;
            return token;
        }

        ch = source.charCodeAt(index);
        switch (ch) {
        case 0x27:  /* ''' */
        case 0x22:  /* '"' */
            token = scanString();
            return token;

        case 0x3A:  /* ':' */
            advance();
            token = Token.COLON;
            return token;

        case 0x2C:  /* ',' */
            advance();
            token = Token.COMMA;
            return token;

        case 0x28:  /* '(' */
            advance();
            token = Token.LPAREN;
            return token;

        case 0x29:  /* ')' */
            advance();
            token = Token.RPAREN;
            return token;

        case 0x5B:  /* '[' */
            advance();
            token = Token.LBRACK;
            return token;

        case 0x5D:  /* ']' */
            advance();
            token = Token.RBRACK;
            return token;

        case 0x7B:  /* '{' */
            advance();
            token = Token.LBRACE;
            return token;

        case 0x7D:  /* '}' */
            advance();
            token = Token.RBRACE;
            return token;

        case 0x2E:  /* '.' */
            if (index + 1 < length) {
                ch = source.charCodeAt(index + 1);
                if (ch === 0x3C  /* '<' */) {
                    advance();  // '.'
                    advance();  // '<'
                    token = Token.DOT_LT;
                    return token;
                }

                if (ch === 0x2E  /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E  /* '.' */) {
                    advance();  // '.'
                    advance();  // '.'
                    advance();  // '.'
                    token = Token.REST;
                    return token;
                }

                if (esutils.code.isDecimalDigit(ch)) {
                    token = scanNumber();
                    return token;
                }
            }
            token = Token.ILLEGAL;
            return token;

        case 0x3C:  /* '<' */
            advance();
            token = Token.LT;
            return token;

        case 0x3E:  /* '>' */
            advance();
            token = Token.GT;
            return token;

        case 0x2A:  /* '*' */
            advance();
            token = Token.STAR;
            return token;

        case 0x7C:  /* '|' */
            advance();
            token = Token.PIPE;
            return token;

        case 0x3F:  /* '?' */
            advance();
            token = Token.QUESTION;
            return token;

        case 0x21:  /* '!' */
            advance();
            token = Token.BANG;
            return token;

        case 0x3D:  /* '=' */
            advance();
            token = Token.EQUAL;
            return token;

        default:
            if (esutils.code.isDecimalDigit(ch)) {
                token = scanNumber();
                return token;
            }

            utility.assert(isTypeName(ch));
            token = scanTypeName();
            return token;
        }
    }

    function consume(target, text) {
        utility.assert(token === target, text || 'consumed token not matched');
        next();
    }

    function expect(target, message) {
        if (token !== target) {
            utility.throwError(message || 'unexpected token');
        }
        next();
    }

    function parseUnionType() {
        var elements;
        consume(Token.LPAREN, 'UnionType should start with (');
        elements = [];
        if (token !== Token.RPAREN) {
            while (true) {
                elements.push(parseTypeExpression());
                if (token === Token.RPAREN) {
                    break;
                }
                expect(Token.PIPE);
            }
        }
        consume(Token.RPAREN, 'UnionType should end with )');
        return {
            type: Syntax.UnionType,
            elements: elements
        };
    }

    function parseArrayType() {
        var elements;
        consume(Token.LBRACK, 'ArrayType should start with [');
        elements = [];
        while (token !== Token.RBRACK) {
            if (token === Token.REST) {
                consume(Token.REST);
                elements.push({
                    type: Syntax.RestType,
                    expression: parseTypeExpression()
                });
                break;
            } else {
                elements.push(parseTypeExpression());
            }
            if (token !== Token.RBRACK) {
                expect(Token.COMMA);
            }
        }
        expect(Token.RBRACK);
        return {
            type: Syntax.ArrayType,
            elements: elements
        };
    }

    function parseFieldName() {
        var v = value;
        if (token === Token.NAME || token === Token.STRING) {
            next();
            return v;
        }

        if (token === Token.NUMBER) {
            consume(Token.NUMBER);
            return String(v);
        }

        utility.throwError('unexpected token');
    }

    function parseFieldType() {
        var key;

        key = parseFieldName();
        if (token === Token.COLON) {
            consume(Token.COLON);
            return {
                type: Syntax.FieldType,
                key: key,
                value: parseTypeExpression()
            };
        }
        return {
            type: Syntax.FieldType,
            key: key,
            value: null
        };
    }

    function parseRecordType() {
        var fields;

        consume(Token.LBRACE, 'RecordType should start with {');
        fields = [];
        if (token === Token.COMMA) {
            consume(Token.COMMA);
        } else {
            while (token !== Token.RBRACE) {
                fields.push(parseFieldType());
                if (token !== Token.RBRACE) {
                    expect(Token.COMMA);
                }
            }
        }
        expect(Token.RBRACE);
        return {
            type: Syntax.RecordType,
            fields: fields
        };
    }

    function parseNameExpression() {
        var name = value;
        expect(Token.NAME);

        if (token === Token.COLON && (
                name === 'module' ||
                name === 'external' ||
                name === 'event')) {
            consume(Token.COLON);
            name += ':' + value;
            expect(Token.NAME);
        }

        return {
            type: Syntax.NameExpression,
            name: name
        };
    }

    function parseTypeExpressionList() {
        var elements = [];

        elements.push(parseTop());
        while (token === Token.COMMA) {
            consume(Token.COMMA);
            elements.push(parseTop());
        }
        return elements;
    }

    function parseTypeName() {
        var expr, applications;

        expr = parseNameExpression();
        if (token === Token.DOT_LT || token === Token.LT) {
            next();
            applications = parseTypeExpressionList();
            expect(Token.GT);
            return {
                type: Syntax.TypeApplication,
                expression: expr,
                applications: applications
            };
        }
        return expr;
    }

    function parseResultType() {
        consume(Token.COLON, 'ResultType should start with :');
        if (token === Token.NAME && value === 'void') {
            consume(Token.NAME);
            return {
                type: Syntax.VoidLiteral
            };
        }
        return parseTypeExpression();
    }

    function parseParametersType() {
        var params = [], optionalSequence = false, expr, rest = false;

        while (token !== Token.RPAREN) {
            if (token === Token.REST) {
                consume(Token.REST);
                rest = true;
            }

            expr = parseTypeExpression();
            if (expr.type === Syntax.NameExpression && token === Token.COLON) {
                consume(Token.COLON);
                expr = {
                    type: Syntax.ParameterType,
                    name: expr.name,
                    expression: parseTypeExpression()
                };
            }
            if (token === Token.EQUAL) {
                consume(Token.EQUAL);
                expr = {
                    type: Syntax.OptionalType,
                    expression: expr
                };
                optionalSequence = true;
            } else {
                if (optionalSequence) {
                    utility.throwError('unexpected token');
                }
            }
            if (rest) {
                expr = {
                    type: Syntax.RestType,
                    expression: expr
                };
            }
            params.push(expr);
            if (token !== Token.RPAREN) {
                expect(Token.COMMA);
            }
        }
        return params;
    }

    function parseFunctionType() {
        var isNew, thisBinding, params, result, fnType;
        utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \'function\'');
        consume(Token.NAME);

        expect(Token.LPAREN);

        isNew = false;
        params = [];
        thisBinding = null;
        if (token !== Token.RPAREN) {
            if (token === Token.NAME &&
                    (value === 'this' || value === 'new')) {
                isNew = value === 'new';
                consume(Token.NAME);
                expect(Token.COLON);
                thisBinding = parseTypeName();
                if (token === Token.COMMA) {
                    consume(Token.COMMA);
                    params = parseParametersType();
                }
            } else {
                params = parseParametersType();
            }
        }

        expect(Token.RPAREN);

        result = null;
        if (token === Token.COLON) {
            result = parseResultType();
        }

        fnType = {
            type: Syntax.FunctionType,
            params: params,
            result: result
        };
        if (thisBinding) {
            fnType['this'] = thisBinding;
            if (isNew) {
                fnType['new'] = true;
            }
        }
        return fnType;
    }

    function parseBasicTypeExpression() {
        var context;
        switch (token) {
        case Token.STAR:
            consume(Token.STAR);
            return {
                type: Syntax.AllLiteral
            };

        case Token.LPAREN:
            return parseUnionType();

        case Token.LBRACK:
            return parseArrayType();

        case Token.LBRACE:
            return parseRecordType();

        case Token.NAME:
            if (value === 'null') {
                consume(Token.NAME);
                return {
                    type: Syntax.NullLiteral
                };
            }

            if (value === 'undefined') {
                consume(Token.NAME);
                return {
                    type: Syntax.UndefinedLiteral
                };
            }

            context = Context.save();
            if (value === 'function') {
                try {
                    return parseFunctionType();
                } catch (e) {
                    context.restore();
                }
            }

            return parseTypeName();

        default:
            utility.throwError('unexpected token');
        }
    }

    function parseTypeExpression() {
        var expr;

        if (token === Token.QUESTION) {
            consume(Token.QUESTION);
            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||
                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||
                    token === Token.RBRACK || token === Token.GT) {
                return {
                    type: Syntax.NullableLiteral
                };
            }
            return {
                type: Syntax.NullableType,
                expression: parseBasicTypeExpression(),
                prefix: true
            };
        }

        if (token === Token.BANG) {
            consume(Token.BANG);
            return {
                type: Syntax.NonNullableType,
                expression: parseBasicTypeExpression(),
                prefix: true
            };
        }

        expr = parseBasicTypeExpression();
        if (token === Token.BANG) {
            consume(Token.BANG);
            return {
                type: Syntax.NonNullableType,
                expression: expr,
                prefix: false
            };
        }

        if (token === Token.QUESTION) {
            consume(Token.QUESTION);
            return {
                type: Syntax.NullableType,
                expression: expr,
                prefix: false
            };
        }

        if (token === Token.LBRACK) {
            consume(Token.LBRACK);
            expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');
            return {
                type: Syntax.TypeApplication,
                expression: {
                    type: Syntax.NameExpression,
                    name: 'Array'
                },
                applications: [expr]
            };
        }

        return expr;
    }

    function parseTop() {
        var expr, elements;

        expr = parseTypeExpression();
        if (token !== Token.PIPE) {
            return expr;
        }

        elements = [expr];
        consume(Token.PIPE);
        while (true) {
            elements.push(parseTypeExpression());
            if (token !== Token.PIPE) {
                break;
            }
            consume(Token.PIPE);
        }

        return {
            type: Syntax.UnionType,
            elements: elements
        };
    }

    function parseTopParamType() {
        var expr;

        if (token === Token.REST) {
            consume(Token.REST);
            return {
                type: Syntax.RestType,
                expression: parseTop()
            };
        }

        expr = parseTop();
        if (token === Token.EQUAL) {
            consume(Token.EQUAL);
            return {
                type: Syntax.OptionalType,
                expression: expr
            };
        }

        return expr;
    }

    function parseType(src, opt) {
        var expr;

        source = src;
        length = source.length;
        index = 0;
        previous = 0;

        next();
        expr = parseTop();

        if (opt && opt.midstream) {
            return {
                expression: expr,
                index: previous
            };
        }

        if (token !== Token.EOF) {
            utility.throwError('not reach to EOF');
        }

        return expr;
    }

    function parseParamType(src, opt) {
        var expr;

        source = src;
        length = source.length;
        index = 0;
        previous = 0;

        next();
        expr = parseTopParamType();

        if (opt && opt.midstream) {
            return {
                expression: expr,
                index: previous
            };
        }

        if (token !== Token.EOF) {
            utility.throwError('not reach to EOF');
        }

        return expr;
    }

    function stringifyImpl(node, compact, topLevel) {
        var result, i, iz;

        switch (node.type) {
        case Syntax.NullableLiteral:
            result = '?';
            break;

        case Syntax.AllLiteral:
            result = '*';
            break;

        case Syntax.NullLiteral:
            result = 'null';
            break;

        case Syntax.UndefinedLiteral:
            result = 'undefined';
            break;

        case Syntax.VoidLiteral:
            result = 'void';
            break;

        case Syntax.UnionType:
            if (!topLevel) {
                result = '(';
            } else {
                result = '';
            }

            for (i = 0, iz = node.elements.length; i < iz; ++i) {
                result += stringifyImpl(node.elements[i], compact);
                if ((i + 1) !== iz) {
                    result += '|';
                }
            }

            if (!topLevel) {
                result += ')';
            }
            break;

        case Syntax.ArrayType:
            result = '[';
            for (i = 0, iz = node.elements.length; i < iz; ++i) {
                result += stringifyImpl(node.elements[i], compact);
                if ((i + 1) !== iz) {
                    result += compact ? ',' : ', ';
                }
            }
            result += ']';
            break;

        case Syntax.RecordType:
            result = '{';
            for (i = 0, iz = node.fields.length; i < iz; ++i) {
                result += stringifyImpl(node.fields[i], compact);
                if ((i + 1) !== iz) {
                    result += compact ? ',' : ', ';
                }
            }
            result += '}';
            break;

        case Syntax.FieldType:
            if (node.value) {
                result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);
            } else {
                result = node.key;
            }
            break;

        case Syntax.FunctionType:
            result = compact ? 'function(' : 'function (';

            if (node['this']) {
                if (node['new']) {
                    result += (compact ? 'new:' : 'new: ');
                } else {
                    result += (compact ? 'this:' : 'this: ');
                }

                result += stringifyImpl(node['this'], compact);

                if (node.params.length !== 0) {
                    result += compact ? ',' : ', ';
                }
            }

            for (i = 0, iz = node.params.length; i < iz; ++i) {
                result += stringifyImpl(node.params[i], compact);
                if ((i + 1) !== iz) {
                    result += compact ? ',' : ', ';
                }
            }

            result += ')';

            if (node.result) {
                result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);
            }
            break;

        case Syntax.ParameterType:
            result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);
            break;

        case Syntax.RestType:
            result = '...';
            if (node.expression) {
                result += stringifyImpl(node.expression, compact);
            }
            break;

        case Syntax.NonNullableType:
            if (node.prefix) {
                result = '!' + stringifyImpl(node.expression, compact);
            } else {
                result = stringifyImpl(node.expression, compact) + '!';
            }
            break;

        case Syntax.OptionalType:
            result = stringifyImpl(node.expression, compact) + '=';
            break;

        case Syntax.NullableType:
            if (node.prefix) {
                result = '?' + stringifyImpl(node.expression, compact);
            } else {
                result = stringifyImpl(node.expression, compact) + '?';
            }
            break;

        case Syntax.NameExpression:
            result = node.name;
            break;

        case Syntax.TypeApplication:
            result = stringifyImpl(node.expression, compact) + '.<';
            for (i = 0, iz = node.applications.length; i < iz; ++i) {
                result += stringifyImpl(node.applications[i], compact);
                if ((i + 1) !== iz) {
                    result += compact ? ',' : ', ';
                }
            }
            result += '>';
            break;

        default:
            utility.throwError('Unknown type ' + node.type);
        }

        return result;
    }

    function stringify(node, options) {
        if (options == null) {
            options = {};
        }
        return stringifyImpl(node, options.compact, options.topLevel);
    }

    exports.parseType = parseType;
    exports.parseParamType = parseParamType;
    exports.stringify = stringify;
    exports.Syntax = Syntax;
}());

},
   {"./utility":"/node_modules/doctrine/lib/utility.js","esutils":"/node_modules/doctrine/node_modules/esutils/lib/utils.js"}],

"/node_modules/doctrine/lib/utility.js": [function(require,module,exports){

(function () {
    'use strict';

    var VERSION;

    VERSION = require('../package.json').version;
    exports.VERSION = VERSION;

    function DoctrineError(message) {
        this.name = 'DoctrineError';
        this.message = message;
    }
    DoctrineError.prototype = (function () {
        var Middle = function () { };
        Middle.prototype = Error.prototype;
        return new Middle();
    }());
    DoctrineError.prototype.constructor = DoctrineError;
    exports.DoctrineError = DoctrineError;

    function throwError(message) {
        throw new DoctrineError(message);
    }
    exports.throwError = throwError;

    exports.assert = require('assert');
}());


},
   {"../package.json":"/node_modules/doctrine/package.json","assert":"/node_modules/browserify/node_modules/assert/assert.js"}],

"/node_modules/doctrine/node_modules/esutils/lib/ast.js": [function(require,module,exports){
(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());

},
   {}],

"/node_modules/doctrine/node_modules/esutils/lib/code.js": [function(require,module,exports){
(function () {
    'use strict';

    var Regex, NON_ASCII_WHITESPACES;

    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return isDecimalDigit(ch) ||    // 0..9
            (97 <= ch && ch <= 102) ||  // a..f
            (65 <= ch && ch <= 70);     // A..F
    }

    function isOctalDigit(ch) {
        return (ch >= 48 && ch <= 55);   // 0..7
    }

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0);
    }

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    function isIdentifierStart(ch) {
        return (ch >= 97 && ch <= 122) ||     // a..z
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch >= 97 && ch <= 122) ||     // a..z
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
    };
}());

},
   {}],

"/node_modules/doctrine/node_modules/esutils/lib/keyword.js": [function(require,module,exports){
(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierName(id) {
        var i, iz, ch;

        if (id.length === 0) {
            return false;
        }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {  // \ (backslash)
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPart(ch) || ch === 92) {  // \ (backslash)
                return false;
            }
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierName(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierName(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());

},
   {"./code":"/node_modules/doctrine/node_modules/esutils/lib/code.js"}],

"/node_modules/doctrine/node_modules/esutils/lib/utils.js": [function(require,module,exports){

(function () {
    'use strict';

    exports.ast = require('./ast');
    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());

},
   {"./ast":"/node_modules/doctrine/node_modules/esutils/lib/ast.js","./code":"/node_modules/doctrine/node_modules/esutils/lib/code.js","./keyword":"/node_modules/doctrine/node_modules/esutils/lib/keyword.js"}],

"/node_modules/doctrine/node_modules/isarray/index.js": [function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},
   {}],

"/node_modules/doctrine/package.json": [function(require,module,exports){
module.exports={
  "name": "doctrine",
  "description": "JSDoc parser",
  "homepage": "https://github.com/eslint/doctrine",
  "main": "lib/doctrine.js",
  "version": "1.2.0",
  "engines": {
    "node": ">=0.10.0"
  },
  "directories": {
    "lib": "./lib"
  },
  "files": [
    "lib",
    "LICENSE.BSD",
    "LICENSE.closure-compiler",
    "LICENSE.esprima",
    "README.md"
  ],
  "maintainers": [
    {
      "name": "constellation",
      "email": "utatane.tea@gmail.com"
    },
    {
      "name": "nzakas",
      "email": "nicholas@nczconsulting.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/eslint/doctrine.git"
  },
  "devDependencies": {
    "coveralls": "^2.11.2",
    "dateformat": "^1.0.11",
    "eslint": "^1.10.3",
    "eslint-release": "^0.3.0",
    "istanbul": "^0.4.1",
    "linefix": "^0.1.1",
    "mocha": "^2.3.3",
    "npm-license": "^0.3.1",
    "semver": "^5.0.3",
    "shelljs": "^0.5.3",
    "shelljs-nodecli": "^0.1.1",
    "should": "^5.0.1"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/eslint/doctrine/raw/master/LICENSE.BSD"
    }
  ],
  "scripts": {
    "test": "npm run lint && node Makefile.js test",
    "lint": "eslint lib/",
    "release": "eslint-release",
    "alpharelease": "eslint-prerelease alpha",
    "betarelease": "eslint-prerelease beta"
  },
  "dependencies": {
    "esutils": "^1.1.6",
    "isarray": "^1.0.0"
  },
  "bugs": {
    "url": "https://github.com/eslint/doctrine/issues"
  },
  "_id": "doctrine@1.2.0",
  "_shasum": "ff0adabd686b4faeb1e2b5c775c34a74539e784f",
  "_from": "doctrine@>=1.2.0 <2.0.0",
  "_npmVersion": "1.4.10",
  "_npmUser": {
    "name": "nzakas",
    "email": "nicholas@nczconsulting.com"
  },
  "dist": {
    "shasum": "ff0adabd686b4faeb1e2b5c775c34a74539e784f",
    "tarball": "http://registry.npmjs.org/doctrine/-/doctrine-1.2.0.tgz"
  },
  "_npmOperationalInternal": {
    "host": "packages-5-east.internal.npmjs.com",
    "tmp": "tmp/doctrine-1.2.0.tgz_1455906515924_0.953179617645219"
  },
  "_resolved": "https://registry.npmjs.org/doctrine/-/doctrine-1.2.0.tgz"
}

},
   {}],

"/node_modules/es6-map/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')() ? Map : require('./polyfill');

},
   {"./is-implemented":"/node_modules/es6-map/is-implemented.js","./polyfill":"/node_modules/es6-map/polyfill.js"}],

"/node_modules/es6-map/is-implemented.js": [function(require,module,exports){
'use strict';

module.exports = function () {
	var map, iterator, result;
	if (typeof Map !== 'function') return false;
	try {
		map = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);
	} catch (e) {
		return false;
	}
	if (String(map) !== '[object Map]') return false;
	if (map.size !== 3) return false;
	if (typeof map.clear !== 'function') return false;
	if (typeof map.delete !== 'function') return false;
	if (typeof map.entries !== 'function') return false;
	if (typeof map.forEach !== 'function') return false;
	if (typeof map.get !== 'function') return false;
	if (typeof map.has !== 'function') return false;
	if (typeof map.keys !== 'function') return false;
	if (typeof map.set !== 'function') return false;
	if (typeof map.values !== 'function') return false;

	iterator = map.entries();
	result = iterator.next();
	if (result.done !== false) return false;
	if (!result.value) return false;
	if (result.value[0] !== 'raz') return false;
	if (result.value[1] !== 'one') return false;

	return true;
};

},
   {}],

"/node_modules/es6-map/is-native-implemented.js": [function(require,module,exports){
'use strict';

module.exports = (function () {
	if (typeof Map === 'undefined') return false;
	return (Object.prototype.toString.call(new Map()) === '[object Map]');
}());

},
   {}],

"/node_modules/es6-map/lib/iterator-kinds.js": [function(require,module,exports){
'use strict';

module.exports = require('es5-ext/object/primitive-set')('key',
	'value', 'key+value');

},
   {"es5-ext/object/primitive-set":"/node_modules/es6-map/node_modules/es5-ext/object/primitive-set.js"}],

"/node_modules/es6-map/lib/iterator.js": [function(require,module,exports){
'use strict';

var setPrototypeOf    = require('es5-ext/object/set-prototype-of')
  , d                 = require('d')
  , Iterator          = require('es6-iterator')
  , toStringTagSymbol = require('es6-symbol').toStringTag
  , kinds             = require('./iterator-kinds')

  , defineProperties = Object.defineProperties
  , unBind = Iterator.prototype._unBind
  , MapIterator;

MapIterator = module.exports = function (map, kind) {
	if (!(this instanceof MapIterator)) return new MapIterator(map, kind);
	Iterator.call(this, map.__mapKeysData__, map);
	if (!kind || !kinds[kind]) kind = 'key+value';
	defineProperties(this, {
		__kind__: d('', kind),
		__values__: d('w', map.__mapValuesData__)
	});
};
if (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);

MapIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(MapIterator),
	_resolve: d(function (i) {
		if (this.__kind__ === 'value') return this.__values__[i];
		if (this.__kind__ === 'key') return this.__list__[i];
		return [this.__list__[i], this.__values__[i]];
	}),
	_unBind: d(function () {
		this.__values__ = null;
		unBind.call(this);
	}),
	toString: d(function () { return '[object Map Iterator]'; })
});
Object.defineProperty(MapIterator.prototype, toStringTagSymbol,
	d('c', 'Map Iterator'));

},
   {"./iterator-kinds":"/node_modules/es6-map/lib/iterator-kinds.js","d":"/node_modules/es6-map/node_modules/d/index.js","es5-ext/object/set-prototype-of":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/index.js","es6-iterator":"/node_modules/es6-map/node_modules/es6-iterator/index.js","es6-symbol":"/node_modules/es6-map/node_modules/es6-symbol/index.js"}],

"/node_modules/es6-map/node_modules/d/auto-bind.js": [function(require,module,exports){
'use strict';

var copy       = require('es5-ext/object/copy')
  , map        = require('es5-ext/object/map')
  , callable   = require('es5-ext/object/valid-callable')
  , validValue = require('es5-ext/object/valid-value')

  , bind = Function.prototype.bind, defineProperty = Object.defineProperty
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , define;

define = function (name, desc, bindTo) {
	var value = validValue(desc) && callable(desc.value), dgs;
	dgs = copy(desc);
	delete dgs.writable;
	delete dgs.value;
	dgs.get = function () {
		if (hasOwnProperty.call(this, name)) return value;
		desc.value = bind.call(value, (bindTo == null) ? this : this[bindTo]);
		defineProperty(this, name, desc);
		return this[name];
	};
	return dgs;
};

module.exports = function (props/*, bindTo*/) {
	var bindTo = arguments[1];
	return map(props, function (desc, name) {
		return define(name, desc, bindTo);
	});
};

},
   {"es5-ext/object/copy":"/node_modules/es6-map/node_modules/es5-ext/object/copy.js","es5-ext/object/map":"/node_modules/es6-map/node_modules/es5-ext/object/map.js","es5-ext/object/valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/object/valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/d/index.js": [function(require,module,exports){
'use strict';

var assign        = require('es5-ext/object/assign')
  , normalizeOpts = require('es5-ext/object/normalize-options')
  , isCallable    = require('es5-ext/object/is-callable')
  , contains      = require('es5-ext/string/#/contains')

  , d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

},
   {"es5-ext/object/assign":"/node_modules/es6-map/node_modules/es5-ext/object/assign/index.js","es5-ext/object/is-callable":"/node_modules/es6-map/node_modules/es5-ext/object/is-callable.js","es5-ext/object/normalize-options":"/node_modules/es6-map/node_modules/es5-ext/object/normalize-options.js","es5-ext/string/#/contains":"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/index.js"}],

"/node_modules/es6-map/node_modules/es5-ext/array/#/clear.js": [function(require,module,exports){
'use strict';

var value = require('../../object/valid-value');

module.exports = function () {
	value(this).length = 0;
	return this;
};

},
   {"../../object/valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/es5-ext/array/#/e-index-of.js": [function(require,module,exports){
'use strict';

var toPosInt = require('../../number/to-pos-integer')
  , value    = require('../../object/valid-value')

  , indexOf = Array.prototype.indexOf
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , abs = Math.abs, floor = Math.floor;

module.exports = function (searchElement/*, fromIndex*/) {
	var i, l, fromIndex, val;
	if (searchElement === searchElement) { //jslint: ignore
		return indexOf.apply(this, arguments);
	}

	l = toPosInt(value(this).length);
	fromIndex = arguments[1];
	if (isNaN(fromIndex)) fromIndex = 0;
	else if (fromIndex >= 0) fromIndex = floor(fromIndex);
	else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));

	for (i = fromIndex; i < l; ++i) {
		if (hasOwnProperty.call(this, i)) {
			val = this[i];
			if (val !== val) return i; //jslint: ignore
		}
	}
	return -1;
};

},
   {"../../number/to-pos-integer":"/node_modules/es6-map/node_modules/es5-ext/number/to-pos-integer.js","../../object/valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/es5-ext/function/is-arguments.js": [function(require,module,exports){
'use strict';

var toString = Object.prototype.toString

  , id = toString.call((function () { return arguments; }()));

module.exports = function (x) { return (toString.call(x) === id); };

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/math/sign/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Math.sign
	: require('./shim');

},
   {"./is-implemented":"/node_modules/es6-map/node_modules/es5-ext/math/sign/is-implemented.js","./shim":"/node_modules/es6-map/node_modules/es5-ext/math/sign/shim.js"}],

"/node_modules/es6-map/node_modules/es5-ext/math/sign/is-implemented.js": [function(require,module,exports){
'use strict';

module.exports = function () {
	var sign = Math.sign;
	if (typeof sign !== 'function') return false;
	return ((sign(10) === 1) && (sign(-20) === -1));
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/math/sign/shim.js": [function(require,module,exports){
'use strict';

module.exports = function (value) {
	value = Number(value);
	if (isNaN(value) || (value === 0)) return value;
	return (value > 0) ? 1 : -1;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/number/to-integer.js": [function(require,module,exports){
'use strict';

var sign = require('../math/sign')

  , abs = Math.abs, floor = Math.floor;

module.exports = function (value) {
	if (isNaN(value)) return 0;
	value = Number(value);
	if ((value === 0) || !isFinite(value)) return value;
	return sign(value) * floor(abs(value));
};

},
   {"../math/sign":"/node_modules/es6-map/node_modules/es5-ext/math/sign/index.js"}],

"/node_modules/es6-map/node_modules/es5-ext/number/to-pos-integer.js": [function(require,module,exports){
'use strict';

var toInteger = require('./to-integer')

  , max = Math.max;

module.exports = function (value) { return max(0, toInteger(value)); };

},
   {"./to-integer":"/node_modules/es6-map/node_modules/es5-ext/number/to-integer.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/_iterate.js": [function(require,module,exports){
'use strict';

var callable = require('./valid-callable')
  , value    = require('./valid-value')

  , bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys
  , propertyIsEnumerable = Object.prototype.propertyIsEnumerable;

module.exports = function (method, defVal) {
	return function (obj, cb/*, thisArg, compareFn*/) {
		var list, thisArg = arguments[2], compareFn = arguments[3];
		obj = Object(value(obj));
		callable(cb);

		list = keys(obj);
		if (compareFn) {
			list.sort((typeof compareFn === 'function') ? bind.call(compareFn, obj) : undefined);
		}
		if (typeof method !== 'function') method = list[method];
		return call.call(method, list, function (key, index) {
			if (!propertyIsEnumerable.call(obj, key)) return defVal;
			return call.call(cb, thisArg, obj[key], key, obj, index);
		});
	};
};

},
   {"./valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js","./valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/assign/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Object.assign
	: require('./shim');

},
   {"./is-implemented":"/node_modules/es6-map/node_modules/es5-ext/object/assign/is-implemented.js","./shim":"/node_modules/es6-map/node_modules/es5-ext/object/assign/shim.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/assign/is-implemented.js": [function(require,module,exports){
'use strict';

module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== 'function') return false;
	obj = { foo: 'raz' };
	assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
	return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/assign/shim.js": [function(require,module,exports){
'use strict';

var keys  = require('../keys')
  , value = require('../valid-value')

  , max = Math.max;

module.exports = function (dest, src/*, …srcn*/) {
	var error, i, l = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try { dest[key] = src[key]; } catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < l; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};

},
   {"../keys":"/node_modules/es6-map/node_modules/es5-ext/object/keys/index.js","../valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/copy.js": [function(require,module,exports){
'use strict';

var assign = require('./assign')
  , value  = require('./valid-value');

module.exports = function (obj) {
	var copy = Object(value(obj));
	if (copy !== obj) return copy;
	return assign({}, obj);
};

},
   {"./assign":"/node_modules/es6-map/node_modules/es5-ext/object/assign/index.js","./valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/create.js": [function(require,module,exports){
'use strict';

var create = Object.create, shim;

if (!require('./set-prototype-of/is-implemented')()) {
	shim = require('./set-prototype-of/shim');
}

module.exports = (function () {
	var nullObject, props, desc;
	if (!shim) return create;
	if (shim.level !== 1) return create;

	nullObject = {};
	props = {};
	desc = { configurable: false, enumerable: false, writable: true,
		value: undefined };
	Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
		if (name === '__proto__') {
			props[name] = { configurable: true, enumerable: false, writable: true,
				value: undefined };
			return;
		}
		props[name] = desc;
	});
	Object.defineProperties(nullObject, props);

	Object.defineProperty(shim, 'nullPolyfill', { configurable: false,
		enumerable: false, writable: false, value: nullObject });

	return function (prototype, props) {
		return create((prototype === null) ? nullObject : prototype, props);
	};
}());

},
   {"./set-prototype-of/is-implemented":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js","./set-prototype-of/shim":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/shim.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/for-each.js": [function(require,module,exports){
'use strict';

module.exports = require('./_iterate')('forEach');

},
   {"./_iterate":"/node_modules/es6-map/node_modules/es5-ext/object/_iterate.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/is-callable.js": [function(require,module,exports){
'use strict';

module.exports = function (obj) { return typeof obj === 'function'; };

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/is-object.js": [function(require,module,exports){
'use strict';

var map = { function: true, object: true };

module.exports = function (x) {
	return ((x != null) && map[typeof x]) || false;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/keys/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Object.keys
	: require('./shim');

},
   {"./is-implemented":"/node_modules/es6-map/node_modules/es5-ext/object/keys/is-implemented.js","./shim":"/node_modules/es6-map/node_modules/es5-ext/object/keys/shim.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/keys/is-implemented.js": [function(require,module,exports){
'use strict';

module.exports = function () {
	try {
		Object.keys('primitive');
		return true;
	} catch (e) { return false; }
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/keys/shim.js": [function(require,module,exports){
'use strict';

var keys = Object.keys;

module.exports = function (object) {
	return keys(object == null ? object : Object(object));
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/map.js": [function(require,module,exports){
'use strict';

var callable = require('./valid-callable')
  , forEach  = require('./for-each')

  , call = Function.prototype.call;

module.exports = function (obj, cb/*, thisArg*/) {
	var o = {}, thisArg = arguments[2];
	callable(cb);
	forEach(obj, function (value, key, obj, index) {
		o[key] = call.call(cb, thisArg, value, key, obj, index);
	});
	return o;
};

},
   {"./for-each":"/node_modules/es6-map/node_modules/es5-ext/object/for-each.js","./valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/normalize-options.js": [function(require,module,exports){
'use strict';

var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

module.exports = function (options/*, …options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (options == null) return;
		process(Object(options), result);
	});
	return result;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/primitive-set.js": [function(require,module,exports){
'use strict';

var forEach = Array.prototype.forEach, create = Object.create;

module.exports = function (arg/*, …args*/) {
	var set = create(null);
	forEach.call(arguments, function (name) { set[name] = true; });
	return set;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Object.setPrototypeOf
	: require('./shim');

},
   {"./is-implemented":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js","./shim":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/shim.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js": [function(require,module,exports){
'use strict';

var create = Object.create, getPrototypeOf = Object.getPrototypeOf
  , x = {};

module.exports = function (/*customCreate*/) {
	var setPrototypeOf = Object.setPrototypeOf
	  , customCreate = arguments[0] || create;
	if (typeof setPrototypeOf !== 'function') return false;
	return getPrototypeOf(setPrototypeOf(customCreate(null), x)) === x;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/shim.js": [function(require,module,exports){
'use strict';

var isObject      = require('../is-object')
  , value         = require('../valid-value')

  , isPrototypeOf = Object.prototype.isPrototypeOf
  , defineProperty = Object.defineProperty
  , nullDesc = { configurable: true, enumerable: false, writable: true,
		value: undefined }
  , validate;

validate = function (obj, prototype) {
	value(obj);
	if ((prototype === null) || isObject(prototype)) return obj;
	throw new TypeError('Prototype must be null or an object');
};

module.exports = (function (status) {
	var fn, set;
	if (!status) return null;
	if (status.level === 2) {
		if (status.set) {
			set = status.set;
			fn = function (obj, prototype) {
				set.call(validate(obj, prototype), prototype);
				return obj;
			};
		} else {
			fn = function (obj, prototype) {
				validate(obj, prototype).__proto__ = prototype;
				return obj;
			};
		}
	} else {
		fn = function self(obj, prototype) {
			var isNullBase;
			validate(obj, prototype);
			isNullBase = isPrototypeOf.call(self.nullPolyfill, obj);
			if (isNullBase) delete self.nullPolyfill.__proto__;
			if (prototype === null) prototype = self.nullPolyfill;
			obj.__proto__ = prototype;
			if (isNullBase) defineProperty(self.nullPolyfill, '__proto__', nullDesc);
			return obj;
		};
	}
	return Object.defineProperty(fn, 'level', { configurable: false,
		enumerable: false, writable: false, value: status.level });
}((function () {
	var x = Object.create(null), y = {}, set
	  , desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');

	if (desc) {
		try {
			set = desc.set; // Opera crashes at this point
			set.call(x, y);
		} catch (ignore) { }
		if (Object.getPrototypeOf(x) === y) return { set: set, level: 2 };
	}

	x.__proto__ = y;
	if (Object.getPrototypeOf(x) === y) return { level: 2 };

	x = {};
	x.__proto__ = y;
	if (Object.getPrototypeOf(x) === y) return { level: 1 };

	return false;
}())));

require('../create');

},
   {"../create":"/node_modules/es6-map/node_modules/es5-ext/object/create.js","../is-object":"/node_modules/es6-map/node_modules/es5-ext/object/is-object.js","../valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js": [function(require,module,exports){
'use strict';

module.exports = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js": [function(require,module,exports){
'use strict';

module.exports = function (value) {
	if (value == null) throw new TypeError("Cannot use null or undefined");
	return value;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? String.prototype.contains
	: require('./shim');

},
   {"./is-implemented":"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/is-implemented.js","./shim":"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/shim.js"}],

"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/is-implemented.js": [function(require,module,exports){
'use strict';

var str = 'razdwatrzy';

module.exports = function () {
	if (typeof str.contains !== 'function') return false;
	return ((str.contains('dwa') === true) && (str.contains('foo') === false));
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/shim.js": [function(require,module,exports){
'use strict';

var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/string/is-string.js": [function(require,module,exports){
'use strict';

var toString = Object.prototype.toString

  , id = toString.call('');

module.exports = function (x) {
	return (typeof x === 'string') || (x && (typeof x === 'object') &&
		((x instanceof String) || (toString.call(x) === id))) || false;
};

},
   {}],

"/node_modules/es6-map/node_modules/es6-iterator/array.js": [function(require,module,exports){
'use strict';

var setPrototypeOf = require('es5-ext/object/set-prototype-of')
  , contains       = require('es5-ext/string/#/contains')
  , d              = require('d')
  , Iterator       = require('./')

  , defineProperty = Object.defineProperty
  , ArrayIterator;

ArrayIterator = module.exports = function (arr, kind) {
	if (!(this instanceof ArrayIterator)) return new ArrayIterator(arr, kind);
	Iterator.call(this, arr);
	if (!kind) kind = 'value';
	else if (contains.call(kind, 'key+value')) kind = 'key+value';
	else if (contains.call(kind, 'key')) kind = 'key';
	else kind = 'value';
	defineProperty(this, '__kind__', d('', kind));
};
if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);

ArrayIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(ArrayIterator),
	_resolve: d(function (i) {
		if (this.__kind__ === 'value') return this.__list__[i];
		if (this.__kind__ === 'key+value') return [i, this.__list__[i]];
		return i;
	}),
	toString: d(function () { return '[object Array Iterator]'; })
});

},
   {"./":"/node_modules/es6-map/node_modules/es6-iterator/index.js","d":"/node_modules/es6-map/node_modules/d/index.js","es5-ext/object/set-prototype-of":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/index.js","es5-ext/string/#/contains":"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/index.js"}],

"/node_modules/es6-map/node_modules/es6-iterator/for-of.js": [function(require,module,exports){
'use strict';

var isArguments = require('es5-ext/function/is-arguments')
  , callable    = require('es5-ext/object/valid-callable')
  , isString    = require('es5-ext/string/is-string')
  , get         = require('./get')

  , isArray = Array.isArray, call = Function.prototype.call
  , some = Array.prototype.some;

module.exports = function (iterable, cb/*, thisArg*/) {
	var mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;
	if (isArray(iterable) || isArguments(iterable)) mode = 'array';
	else if (isString(iterable)) mode = 'string';
	else iterable = get(iterable);

	callable(cb);
	doBreak = function () { broken = true; };
	if (mode === 'array') {
		some.call(iterable, function (value) {
			call.call(cb, thisArg, value, doBreak);
			if (broken) return true;
		});
		return;
	}
	if (mode === 'string') {
		l = iterable.length;
		for (i = 0; i < l; ++i) {
			char = iterable[i];
			if ((i + 1) < l) {
				code = char.charCodeAt(0);
				if ((code >= 0xD800) && (code <= 0xDBFF)) char += iterable[++i];
			}
			call.call(cb, thisArg, char, doBreak);
			if (broken) break;
		}
		return;
	}
	result = iterable.next();

	while (!result.done) {
		call.call(cb, thisArg, result.value, doBreak);
		if (broken) return;
		result = iterable.next();
	}
};

},
   {"./get":"/node_modules/es6-map/node_modules/es6-iterator/get.js","es5-ext/function/is-arguments":"/node_modules/es6-map/node_modules/es5-ext/function/is-arguments.js","es5-ext/object/valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/string/is-string":"/node_modules/es6-map/node_modules/es5-ext/string/is-string.js"}],

"/node_modules/es6-map/node_modules/es6-iterator/get.js": [function(require,module,exports){
'use strict';

var isArguments    = require('es5-ext/function/is-arguments')
  , isString       = require('es5-ext/string/is-string')
  , ArrayIterator  = require('./array')
  , StringIterator = require('./string')
  , iterable       = require('./valid-iterable')
  , iteratorSymbol = require('es6-symbol').iterator;

module.exports = function (obj) {
	if (typeof iterable(obj)[iteratorSymbol] === 'function') return obj[iteratorSymbol]();
	if (isArguments(obj)) return new ArrayIterator(obj);
	if (isString(obj)) return new StringIterator(obj);
	return new ArrayIterator(obj);
};

},
   {"./array":"/node_modules/es6-map/node_modules/es6-iterator/array.js","./string":"/node_modules/es6-map/node_modules/es6-iterator/string.js","./valid-iterable":"/node_modules/es6-map/node_modules/es6-iterator/valid-iterable.js","es5-ext/function/is-arguments":"/node_modules/es6-map/node_modules/es5-ext/function/is-arguments.js","es5-ext/string/is-string":"/node_modules/es6-map/node_modules/es5-ext/string/is-string.js","es6-symbol":"/node_modules/es6-map/node_modules/es6-symbol/index.js"}],

"/node_modules/es6-map/node_modules/es6-iterator/index.js": [function(require,module,exports){
'use strict';

var clear    = require('es5-ext/array/#/clear')
  , assign   = require('es5-ext/object/assign')
  , callable = require('es5-ext/object/valid-callable')
  , value    = require('es5-ext/object/valid-value')
  , d        = require('d')
  , autoBind = require('d/auto-bind')
  , Symbol   = require('es6-symbol')

  , defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , Iterator;

module.exports = Iterator = function (list, context) {
	if (!(this instanceof Iterator)) return new Iterator(list, context);
	defineProperties(this, {
		__list__: d('w', value(list)),
		__context__: d('w', context),
		__nextIndex__: d('w', 0)
	});
	if (!context) return;
	callable(context.on);
	context.on('_add', this._onAdd);
	context.on('_delete', this._onDelete);
	context.on('_clear', this._onClear);
};

defineProperties(Iterator.prototype, assign({
	constructor: d(Iterator),
	_next: d(function () {
		var i;
		if (!this.__list__) return;
		if (this.__redo__) {
			i = this.__redo__.shift();
			if (i !== undefined) return i;
		}
		if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
		this._unBind();
	}),
	next: d(function () { return this._createResult(this._next()); }),
	_createResult: d(function (i) {
		if (i === undefined) return { done: true, value: undefined };
		return { done: false, value: this._resolve(i) };
	}),
	_resolve: d(function (i) { return this.__list__[i]; }),
	_unBind: d(function () {
		this.__list__ = null;
		delete this.__redo__;
		if (!this.__context__) return;
		this.__context__.off('_add', this._onAdd);
		this.__context__.off('_delete', this._onDelete);
		this.__context__.off('_clear', this._onClear);
		this.__context__ = null;
	}),
	toString: d(function () { return '[object Iterator]'; })
}, autoBind({
	_onAdd: d(function (index) {
		if (index >= this.__nextIndex__) return;
		++this.__nextIndex__;
		if (!this.__redo__) {
			defineProperty(this, '__redo__', d('c', [index]));
			return;
		}
		this.__redo__.forEach(function (redo, i) {
			if (redo >= index) this.__redo__[i] = ++redo;
		}, this);
		this.__redo__.push(index);
	}),
	_onDelete: d(function (index) {
		var i;
		if (index >= this.__nextIndex__) return;
		--this.__nextIndex__;
		if (!this.__redo__) return;
		i = this.__redo__.indexOf(index);
		if (i !== -1) this.__redo__.splice(i, 1);
		this.__redo__.forEach(function (redo, i) {
			if (redo > index) this.__redo__[i] = --redo;
		}, this);
	}),
	_onClear: d(function () {
		if (this.__redo__) clear.call(this.__redo__);
		this.__nextIndex__ = 0;
	})
})));

defineProperty(Iterator.prototype, Symbol.iterator, d(function () {
	return this;
}));
defineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));

},
   {"d":"/node_modules/es6-map/node_modules/d/index.js","d/auto-bind":"/node_modules/es6-map/node_modules/d/auto-bind.js","es5-ext/array/#/clear":"/node_modules/es6-map/node_modules/es5-ext/array/#/clear.js","es5-ext/object/assign":"/node_modules/es6-map/node_modules/es5-ext/object/assign/index.js","es5-ext/object/valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/object/valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js","es6-symbol":"/node_modules/es6-map/node_modules/es6-symbol/index.js"}],

"/node_modules/es6-map/node_modules/es6-iterator/is-iterable.js": [function(require,module,exports){
'use strict';

var isArguments    = require('es5-ext/function/is-arguments')
  , isString       = require('es5-ext/string/is-string')
  , iteratorSymbol = require('es6-symbol').iterator

  , isArray = Array.isArray;

module.exports = function (value) {
	if (value == null) return false;
	if (isArray(value)) return true;
	if (isString(value)) return true;
	if (isArguments(value)) return true;
	return (typeof value[iteratorSymbol] === 'function');
};

},
   {"es5-ext/function/is-arguments":"/node_modules/es6-map/node_modules/es5-ext/function/is-arguments.js","es5-ext/string/is-string":"/node_modules/es6-map/node_modules/es5-ext/string/is-string.js","es6-symbol":"/node_modules/es6-map/node_modules/es6-symbol/index.js"}],

"/node_modules/es6-map/node_modules/es6-iterator/string.js": [function(require,module,exports){
'use strict';

var setPrototypeOf = require('es5-ext/object/set-prototype-of')
  , d              = require('d')
  , Iterator       = require('./')

  , defineProperty = Object.defineProperty
  , StringIterator;

StringIterator = module.exports = function (str) {
	if (!(this instanceof StringIterator)) return new StringIterator(str);
	str = String(str);
	Iterator.call(this, str);
	defineProperty(this, '__length__', d('', str.length));

};
if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);

StringIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(StringIterator),
	_next: d(function () {
		if (!this.__list__) return;
		if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
		this._unBind();
	}),
	_resolve: d(function (i) {
		var char = this.__list__[i], code;
		if (this.__nextIndex__ === this.__length__) return char;
		code = char.charCodeAt(0);
		if ((code >= 0xD800) && (code <= 0xDBFF)) return char + this.__list__[this.__nextIndex__++];
		return char;
	}),
	toString: d(function () { return '[object String Iterator]'; })
});

},
   {"./":"/node_modules/es6-map/node_modules/es6-iterator/index.js","d":"/node_modules/es6-map/node_modules/d/index.js","es5-ext/object/set-prototype-of":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/index.js"}],

"/node_modules/es6-map/node_modules/es6-iterator/valid-iterable.js": [function(require,module,exports){
'use strict';

var isIterable = require('./is-iterable');

module.exports = function (value) {
	if (!isIterable(value)) throw new TypeError(value + " is not iterable");
	return value;
};

},
   {"./is-iterable":"/node_modules/es6-map/node_modules/es6-iterator/is-iterable.js"}],

"/node_modules/es6-map/node_modules/es6-symbol/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')() ? Symbol : require('./polyfill');

},
   {"./is-implemented":"/node_modules/es6-map/node_modules/es6-symbol/is-implemented.js","./polyfill":"/node_modules/es6-map/node_modules/es6-symbol/polyfill.js"}],

"/node_modules/es6-map/node_modules/es6-symbol/is-implemented.js": [function(require,module,exports){
'use strict';

module.exports = function () {
	var symbol;
	if (typeof Symbol !== 'function') return false;
	symbol = Symbol('test symbol');
	try { String(symbol); } catch (e) { return false; }
	if (typeof Symbol.iterator === 'symbol') return true;

	if (typeof Symbol.isConcatSpreadable !== 'object') return false;
	if (typeof Symbol.iterator !== 'object') return false;
	if (typeof Symbol.toPrimitive !== 'object') return false;
	if (typeof Symbol.toStringTag !== 'object') return false;
	if (typeof Symbol.unscopables !== 'object') return false;

	return true;
};

},
   {}],

"/node_modules/es6-map/node_modules/es6-symbol/is-symbol.js": [function(require,module,exports){
'use strict';

module.exports = function (x) {
	return (x && ((typeof x === 'symbol') || (x['@@toStringTag'] === 'Symbol'))) || false;
};

},
   {}],

"/node_modules/es6-map/node_modules/es6-symbol/polyfill.js": [function(require,module,exports){
'use strict';

var d              = require('d')
  , validateSymbol = require('./validate-symbol')

  , create = Object.create, defineProperties = Object.defineProperties
  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null);

if (typeof Symbol === 'function') NativeSymbol = Symbol;

var generateName = (function () {
	var created = create(null);
	return function (desc) {
		var postfix = 0, name, ie11BugWorkaround;
		while (created[desc + (postfix || '')]) ++postfix;
		desc += (postfix || '');
		created[desc] = true;
		name = '@@' + desc;
		defineProperty(objPrototype, name, d.gs(null, function (value) {
			if (ie11BugWorkaround) return;
			ie11BugWorkaround = true;
			defineProperty(this, name, d(value));
			ie11BugWorkaround = false;
		}));
		return name;
	};
}());

HiddenSymbol = function Symbol(description) {
	if (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');
	return SymbolPolyfill(description);
};

module.exports = SymbolPolyfill = function Symbol(description) {
	var symbol;
	if (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');
	symbol = create(HiddenSymbol.prototype);
	description = (description === undefined ? '' : String(description));
	return defineProperties(symbol, {
		__description__: d('', description),
		__name__: d('', generateName(description))
	});
};
defineProperties(SymbolPolyfill, {
	for: d(function (key) {
		if (globalSymbols[key]) return globalSymbols[key];
		return (globalSymbols[key] = SymbolPolyfill(String(key)));
	}),
	keyFor: d(function (s) {
		var key;
		validateSymbol(s);
		for (key in globalSymbols) if (globalSymbols[key] === s) return key;
	}),

	hasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
	isConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
		SymbolPolyfill('isConcatSpreadable')),
	iterator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
	match: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
	replace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
	search: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
	species: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
	split: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
	toPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
	toStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
	unscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
});

defineProperties(HiddenSymbol.prototype, {
	constructor: d(SymbolPolyfill),
	toString: d('', function () { return this.__name__; })
});

defineProperties(SymbolPolyfill.prototype, {
	toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
	valueOf: d(function () { return validateSymbol(this); })
});
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('',
	function () { return validateSymbol(this); }));
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));

defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

},
   {"./validate-symbol":"/node_modules/es6-map/node_modules/es6-symbol/validate-symbol.js","d":"/node_modules/es6-map/node_modules/d/index.js"}],

"/node_modules/es6-map/node_modules/es6-symbol/validate-symbol.js": [function(require,module,exports){
'use strict';

var isSymbol = require('./is-symbol');

module.exports = function (value) {
	if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
	return value;
};

},
   {"./is-symbol":"/node_modules/es6-map/node_modules/es6-symbol/is-symbol.js"}],

"/node_modules/es6-map/node_modules/event-emitter/index.js": [function(require,module,exports){
'use strict';

var d        = require('d')
  , callable = require('es5-ext/object/valid-callable')

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit, methods, descriptors, base;

on = function (type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;
	else if (typeof data[type] === 'object') data[type].push(listener);
	else data[type] = [data[type], listener];

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once.__eeOnceListener__ = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if (typeof listeners === 'object') {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) ||
					(candidate.__eeOnceListener__ === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) ||
				(listeners.__eeOnceListener__ === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if (typeof listeners === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;

},
   {"d":"/node_modules/es6-map/node_modules/d/index.js","es5-ext/object/valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js"}],

"/node_modules/es6-map/polyfill.js": [function(require,module,exports){
'use strict';

var clear          = require('es5-ext/array/#/clear')
  , eIndexOf       = require('es5-ext/array/#/e-index-of')
  , setPrototypeOf = require('es5-ext/object/set-prototype-of')
  , callable       = require('es5-ext/object/valid-callable')
  , validValue     = require('es5-ext/object/valid-value')
  , d              = require('d')
  , ee             = require('event-emitter')
  , Symbol         = require('es6-symbol')
  , iterator       = require('es6-iterator/valid-iterable')
  , forOf          = require('es6-iterator/for-of')
  , Iterator       = require('./lib/iterator')
  , isNative       = require('./is-native-implemented')

  , call = Function.prototype.call
  , defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf
  , MapPoly;

module.exports = MapPoly = function (/*iterable*/) {
	var iterable = arguments[0], keys, values, self;
	if (!(this instanceof MapPoly)) throw new TypeError('Constructor requires \'new\'');
	if (isNative && setPrototypeOf && (Map !== MapPoly)) {
		self = setPrototypeOf(new Map(), getPrototypeOf(this));
	} else {
		self = this;
	}
	if (iterable != null) iterator(iterable);
	defineProperties(self, {
		__mapKeysData__: d('c', keys = []),
		__mapValuesData__: d('c', values = [])
	});
	if (!iterable) return self;
	forOf(iterable, function (value) {
		var key = validValue(value)[0];
		value = value[1];
		if (eIndexOf.call(keys, key) !== -1) return;
		keys.push(key);
		values.push(value);
	}, self);
	return self;
};

if (isNative) {
	if (setPrototypeOf) setPrototypeOf(MapPoly, Map);
	MapPoly.prototype = Object.create(Map.prototype, {
		constructor: d(MapPoly)
	});
}

ee(defineProperties(MapPoly.prototype, {
	clear: d(function () {
		if (!this.__mapKeysData__.length) return;
		clear.call(this.__mapKeysData__);
		clear.call(this.__mapValuesData__);
		this.emit('_clear');
	}),
	delete: d(function (key) {
		var index = eIndexOf.call(this.__mapKeysData__, key);
		if (index === -1) return false;
		this.__mapKeysData__.splice(index, 1);
		this.__mapValuesData__.splice(index, 1);
		this.emit('_delete', index, key);
		return true;
	}),
	entries: d(function () { return new Iterator(this, 'key+value'); }),
	forEach: d(function (cb/*, thisArg*/) {
		var thisArg = arguments[1], iterator, result;
		callable(cb);
		iterator = this.entries();
		result = iterator._next();
		while (result !== undefined) {
			call.call(cb, thisArg, this.__mapValuesData__[result],
				this.__mapKeysData__[result], this);
			result = iterator._next();
		}
	}),
	get: d(function (key) {
		var index = eIndexOf.call(this.__mapKeysData__, key);
		if (index === -1) return;
		return this.__mapValuesData__[index];
	}),
	has: d(function (key) {
		return (eIndexOf.call(this.__mapKeysData__, key) !== -1);
	}),
	keys: d(function () { return new Iterator(this, 'key'); }),
	set: d(function (key, value) {
		var index = eIndexOf.call(this.__mapKeysData__, key), emit;
		if (index === -1) {
			index = this.__mapKeysData__.push(key) - 1;
			emit = true;
		}
		this.__mapValuesData__[index] = value;
		if (emit) this.emit('_add', index, key);
		return this;
	}),
	size: d.gs(function () { return this.__mapKeysData__.length; }),
	values: d(function () { return new Iterator(this, 'value'); }),
	toString: d(function () { return '[object Map]'; })
}));
Object.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {
	return this.entries();
}));
Object.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));

},
   {"./is-native-implemented":"/node_modules/es6-map/is-native-implemented.js","./lib/iterator":"/node_modules/es6-map/lib/iterator.js","d":"/node_modules/es6-map/node_modules/d/index.js","es5-ext/array/#/clear":"/node_modules/es6-map/node_modules/es5-ext/array/#/clear.js","es5-ext/array/#/e-index-of":"/node_modules/es6-map/node_modules/es5-ext/array/#/e-index-of.js","es5-ext/object/set-prototype-of":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/index.js","es5-ext/object/valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/object/valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js","es6-iterator/for-of":"/node_modules/es6-map/node_modules/es6-iterator/for-of.js","es6-iterator/valid-iterable":"/node_modules/es6-map/node_modules/es6-iterator/valid-iterable.js","es6-symbol":"/node_modules/es6-map/node_modules/es6-symbol/index.js","event-emitter":"/node_modules/es6-map/node_modules/event-emitter/index.js"}],

"/node_modules/escope/lib/definition.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Definition = exports.ParameterDefinition = undefined;

var _variable = require('./variable');

var _variable2 = _interopRequireDefault(_variable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
                                                                                                                                                            Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
                                                                                                                                                          
                                                                                                                                                            Redistribution and use in source and binary forms, with or without
                                                                                                                                                            modification, are permitted provided that the following conditions are met:
                                                                                                                                                          
                                                                                                                                                              * Redistributions of source code must retain the above copyright
                                                                                                                                                                notice, this list of conditions and the following disclaimer.
                                                                                                                                                              * Redistributions in binary form must reproduce the above copyright
                                                                                                                                                                notice, this list of conditions and the following disclaimer in the
                                                                                                                                                                documentation and/or other materials provided with the distribution.
                                                                                                                                                          
                                                                                                                                                            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                                                                                                                            AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                                                                                                                            IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                                                                                                                            ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                                                                                                                                                            DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                                                                                                                                                            (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                                                                                                                                                            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                                                                                                                                                            ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                                                                                                                                                            (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                                                                                                                                                            THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                          */

var Definition = function Definition(type, name, node, parent, index, kind) {
  _classCallCheck(this, Definition);

  this.type = type;
  this.name = name;
  this.node = node;
  this.parent = parent;
  this.index = index;
  this.kind = kind;
};


exports.default = Definition;

var ParameterDefinition = function (_Definition) {
  _inherits(ParameterDefinition, _Definition);

  function ParameterDefinition(name, node, index, rest) {
    _classCallCheck(this, ParameterDefinition);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ParameterDefinition).call(this, _variable2.default.Parameter, name, node, null, index, null));

    _this.rest = rest;
    return _this;
  }

  return ParameterDefinition;
}(Definition);

exports.ParameterDefinition = ParameterDefinition;
exports.Definition = Definition;


},
   {"./variable":"/node_modules/escope/lib/variable.js"}],

"/node_modules/escope/lib/index.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ScopeManager = exports.Scope = exports.Variable = exports.Reference = exports.version = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /*
                                                                                                                                                                                                                                                    Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
                                                                                                                                                                                                                                                    Copyright (C) 2013 Alex Seville <hi@alexanderseville.com>
                                                                                                                                                                                                                                                    Copyright (C) 2014 Thiago de Arruda <tpadilha84@gmail.com>
                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                    Redistribution and use in source and binary forms, with or without
                                                                                                                                                                                                                                                    modification, are permitted provided that the following conditions are met:
                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                      * Redistributions of source code must retain the above copyright
                                                                                                                                                                                                                                                        notice, this list of conditions and the following disclaimer.
                                                                                                                                                                                                                                                      * Redistributions in binary form must reproduce the above copyright
                                                                                                                                                                                                                                                        notice, this list of conditions and the following disclaimer in the
                                                                                                                                                                                                                                                        documentation and/or other materials provided with the distribution.
                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                                                                                                                                                                                                                    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                                                                                                                                                                                                                    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                                                                                                                                                                                                                    ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                                                                                                                                                                                                                                                    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                                                                                                                                                                                                                                                    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                                                                                                                                                                                                                                                    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                                                                                                                                                                                                                                                    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                                                                                                                                                                                                                                                    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                                                                                                                                                                                                                                                    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                  */

exports.analyze = analyze;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _scopeManager = require('./scope-manager');

var _scopeManager2 = _interopRequireDefault(_scopeManager);

var _referencer = require('./referencer');

var _referencer2 = _interopRequireDefault(_referencer);

var _reference = require('./reference');

var _reference2 = _interopRequireDefault(_reference);

var _variable = require('./variable');

var _variable2 = _interopRequireDefault(_variable);

var _scope = require('./scope');

var _scope2 = _interopRequireDefault(_scope);

var _package = require('../package.json');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function defaultOptions() {
    return {
        optimistic: false,
        directive: false,
        nodejsScope: false,
        impliedStrict: false,
        sourceType: 'script', // one of ['script', 'module']
        ecmaVersion: 5,
        childVisitorKeys: null,
        fallback: 'iteration'
    };
}

function updateDeeply(target, override) {
    var key, val;

    function isHashObject(target) {
        return (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && target instanceof Object && !(target instanceof Array) && !(target instanceof RegExp);
    }

    for (key in override) {
        if (override.hasOwnProperty(key)) {
            val = override[key];
            if (isHashObject(val)) {
                if (isHashObject(target[key])) {
                    updateDeeply(target[key], val);
                } else {
                    target[key] = updateDeeply({}, val);
                }
            } else {
                target[key] = val;
            }
        }
    }
    return target;
}

function analyze(tree, providedOptions) {
    var scopeManager, referencer, options;

    options = updateDeeply(defaultOptions(), providedOptions);

    scopeManager = new _scopeManager2.default(options);

    referencer = new _referencer2.default(options, scopeManager);
    referencer.visit(tree);

    (0, _assert2.default)(scopeManager.__currentScope === null, 'currentScope should be null.');

    return scopeManager;
}

exports.
version = _package.version;
exports.
Reference = _reference2.default;
exports.
Variable = _variable2.default;
exports.
Scope = _scope2.default;
exports.
ScopeManager = _scopeManager2.default;


},
   {"../package.json":"/node_modules/escope/package.json","./reference":"/node_modules/escope/lib/reference.js","./referencer":"/node_modules/escope/lib/referencer.js","./scope":"/node_modules/escope/lib/scope.js","./scope-manager":"/node_modules/escope/lib/scope-manager.js","./variable":"/node_modules/escope/lib/variable.js","assert":"/node_modules/browserify/node_modules/assert/assert.js"}],

"/node_modules/escope/lib/pattern-visitor.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _estraverse = require('estraverse');

var _esrecurse = require('esrecurse');

var _esrecurse2 = _interopRequireDefault(_esrecurse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Redistribution and use in source and binary forms, with or without
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 modification, are permitted provided that the following conditions are met:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Redistributions of source code must retain the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     notice, this list of conditions and the following disclaimer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Redistributions in binary form must reproduce the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     notice, this list of conditions and the following disclaimer in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     documentation and/or other materials provided with the distribution.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function getLast(xs) {
    return xs[xs.length - 1] || null;
}

var PatternVisitor = function (_esrecurse$Visitor) {
    _inherits(PatternVisitor, _esrecurse$Visitor);

    _createClass(PatternVisitor, null, [{
        key: 'isPattern',
        value: function isPattern(node) {
            var nodeType = node.type;
            return nodeType === _estraverse.Syntax.Identifier || nodeType === _estraverse.Syntax.ObjectPattern || nodeType === _estraverse.Syntax.ArrayPattern || nodeType === _estraverse.Syntax.SpreadElement || nodeType === _estraverse.Syntax.RestElement || nodeType === _estraverse.Syntax.AssignmentPattern;
        }
    }]);

    function PatternVisitor(options, rootPattern, callback) {
        _classCallCheck(this, PatternVisitor);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PatternVisitor).call(this, null, options));

        _this.rootPattern = rootPattern;
        _this.callback = callback;
        _this.assignments = [];
        _this.rightHandNodes = [];
        _this.restElements = [];
        return _this;
    }

    _createClass(PatternVisitor, [{
        key: 'Identifier',
        value: function Identifier(pattern) {
            var lastRestElement = getLast(this.restElements);
            this.callback(pattern, {
                topLevel: pattern === this.rootPattern,
                rest: lastRestElement != null && lastRestElement.argument === pattern,
                assignments: this.assignments
            });
        }
    }, {
        key: 'Property',
        value: function Property(property) {
            if (property.computed) {
                this.rightHandNodes.push(property.key);
            }

            this.visit(property.value);
        }
    }, {
        key: 'ArrayPattern',
        value: function ArrayPattern(pattern) {
            var i, iz, element;
            for (i = 0, iz = pattern.elements.length; i < iz; ++i) {
                element = pattern.elements[i];
                this.visit(element);
            }
        }
    }, {
        key: 'AssignmentPattern',
        value: function AssignmentPattern(pattern) {
            this.assignments.push(pattern);
            this.visit(pattern.left);
            this.rightHandNodes.push(pattern.right);
            this.assignments.pop();
        }
    }, {
        key: 'RestElement',
        value: function RestElement(pattern) {
            this.restElements.push(pattern);
            this.visit(pattern.argument);
            this.restElements.pop();
        }
    }, {
        key: 'MemberExpression',
        value: function MemberExpression(node) {
            if (node.computed) {
                this.rightHandNodes.push(node.property);
            }
            this.rightHandNodes.push(node.object);
        }

    }, {
        key: 'SpreadElement',
        value: function SpreadElement(node) {
            this.visit(node.argument);
        }
    }, {
        key: 'ArrayExpression',
        value: function ArrayExpression(node) {
            node.elements.forEach(this.visit, this);
        }
    }, {
        key: 'AssignmentExpression',
        value: function AssignmentExpression(node) {
            this.assignments.push(node);
            this.visit(node.left);
            this.rightHandNodes.push(node.right);
            this.assignments.pop();
        }
    }, {
        key: 'CallExpression',
        value: function CallExpression(node) {
            var _this2 = this;

            node.arguments.forEach(function (a) {
                _this2.rightHandNodes.push(a);
            });
            this.visit(node.callee);
        }
    }]);

    return PatternVisitor;
}(_esrecurse2.default.Visitor);


exports.default = PatternVisitor;

},
   {"esrecurse":"/node_modules/escope/node_modules/esrecurse/esrecurse.js","estraverse":"/node_modules/estraverse/estraverse.js"}],

"/node_modules/escope/lib/reference.js": [function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var READ = 0x1;
var WRITE = 0x2;
var RW = READ | WRITE;

var Reference = function () {
  function Reference(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
    _classCallCheck(this, Reference);

    this.identifier = ident;
    this.from = scope;
    this.tainted = false;
    this.resolved = null;
    this.flag = flag;
    if (this.isWrite()) {
      this.writeExpr = writeExpr;
      this.partial = partial;
      this.init = init;
    }
    this.__maybeImplicitGlobal = maybeImplicitGlobal;
  }


  _createClass(Reference, [{
    key: "isStatic",
    value: function isStatic() {
      return !this.tainted && this.resolved && this.resolved.scope.isStatic();
    }

  }, {
    key: "isWrite",
    value: function isWrite() {
      return !!(this.flag & Reference.WRITE);
    }

  }, {
    key: "isRead",
    value: function isRead() {
      return !!(this.flag & Reference.READ);
    }

  }, {
    key: "isReadOnly",
    value: function isReadOnly() {
      return this.flag === Reference.READ;
    }

  }, {
    key: "isWriteOnly",
    value: function isWriteOnly() {
      return this.flag === Reference.WRITE;
    }

  }, {
    key: "isReadWrite",
    value: function isReadWrite() {
      return this.flag === Reference.RW;
    }
  }]);

  return Reference;
}();


exports.default = Reference;
Reference.READ = READ;
Reference.WRITE = WRITE;
Reference.RW = RW;


},
   {}],

"/node_modules/escope/lib/referencer.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _estraverse = require('estraverse');

var _esrecurse = require('esrecurse');

var _esrecurse2 = _interopRequireDefault(_esrecurse);

var _reference = require('./reference');

var _reference2 = _interopRequireDefault(_reference);

var _variable = require('./variable');

var _variable2 = _interopRequireDefault(_variable);

var _patternVisitor = require('./pattern-visitor');

var _patternVisitor2 = _interopRequireDefault(_patternVisitor);

var _definition = require('./definition');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Redistribution and use in source and binary forms, with or without
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 modification, are permitted provided that the following conditions are met:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Redistributions of source code must retain the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     notice, this list of conditions and the following disclaimer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Redistributions in binary form must reproduce the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     notice, this list of conditions and the following disclaimer in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     documentation and/or other materials provided with the distribution.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */


function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
    var visitor = new _patternVisitor2.default(options, rootPattern, callback);
    visitor.visit(rootPattern);

    if (referencer != null) {
        visitor.rightHandNodes.forEach(referencer.visit, referencer);
    }
}

var Importer = function (_esrecurse$Visitor) {
    _inherits(Importer, _esrecurse$Visitor);

    function Importer(declaration, referencer) {
        _classCallCheck(this, Importer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Importer).call(this, null, referencer.options));

        _this.declaration = declaration;
        _this.referencer = referencer;
        return _this;
    }

    _createClass(Importer, [{
        key: 'visitImport',
        value: function visitImport(id, specifier) {
            var _this2 = this;

            this.referencer.visitPattern(id, function (pattern) {
                _this2.referencer.currentScope().__define(pattern, new _definition.Definition(_variable2.default.ImportBinding, pattern, specifier, _this2.declaration, null, null));
            });
        }
    }, {
        key: 'ImportNamespaceSpecifier',
        value: function ImportNamespaceSpecifier(node) {
            var local = node.local || node.id;
            if (local) {
                this.visitImport(local, node);
            }
        }
    }, {
        key: 'ImportDefaultSpecifier',
        value: function ImportDefaultSpecifier(node) {
            var local = node.local || node.id;
            this.visitImport(local, node);
        }
    }, {
        key: 'ImportSpecifier',
        value: function ImportSpecifier(node) {
            var local = node.local || node.id;
            if (node.name) {
                this.visitImport(node.name, node);
            } else {
                this.visitImport(local, node);
            }
        }
    }]);

    return Importer;
}(_esrecurse2.default.Visitor);


var Referencer = function (_esrecurse$Visitor2) {
    _inherits(Referencer, _esrecurse$Visitor2);

    function Referencer(options, scopeManager) {
        _classCallCheck(this, Referencer);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(Referencer).call(this, null, options));

        _this3.options = options;
        _this3.scopeManager = scopeManager;
        _this3.parent = null;
        _this3.isInnerMethodDefinition = false;
        return _this3;
    }

    _createClass(Referencer, [{
        key: 'currentScope',
        value: function currentScope() {
            return this.scopeManager.__currentScope;
        }
    }, {
        key: 'close',
        value: function close(node) {
            while (this.currentScope() && node === this.currentScope().block) {
                this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
            }
        }
    }, {
        key: 'pushInnerMethodDefinition',
        value: function pushInnerMethodDefinition(isInnerMethodDefinition) {
            var previous = this.isInnerMethodDefinition;
            this.isInnerMethodDefinition = isInnerMethodDefinition;
            return previous;
        }
    }, {
        key: 'popInnerMethodDefinition',
        value: function popInnerMethodDefinition(isInnerMethodDefinition) {
            this.isInnerMethodDefinition = isInnerMethodDefinition;
        }
    }, {
        key: 'materializeTDZScope',
        value: function materializeTDZScope(node, iterationNode) {
            this.scopeManager.__nestTDZScope(node, iterationNode);
            this.visitVariableDeclaration(this.currentScope(), _variable2.default.TDZ, iterationNode.left, 0, true);
        }
    }, {
        key: 'materializeIterationScope',
        value: function materializeIterationScope(node) {
            var _this4 = this;

            var letOrConstDecl;
            this.scopeManager.__nestForScope(node);
            letOrConstDecl = node.left;
            this.visitVariableDeclaration(this.currentScope(), _variable2.default.Variable, letOrConstDecl, 0);
            this.visitPattern(letOrConstDecl.declarations[0].id, function (pattern) {
                _this4.currentScope().__referencing(pattern, _reference2.default.WRITE, node.right, null, true, true);
            });
        }
    }, {
        key: 'referencingDefaultValue',
        value: function referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
            var scope = this.currentScope();
            assignments.forEach(function (assignment) {
                scope.__referencing(pattern, _reference2.default.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);
            });
        }
    }, {
        key: 'visitPattern',
        value: function visitPattern(node, options, callback) {
            if (typeof options === 'function') {
                callback = options;
                options = { processRightHandNodes: false };
            }
            traverseIdentifierInPattern(this.options, node, options.processRightHandNodes ? this : null, callback);
        }
    }, {
        key: 'visitFunction',
        value: function visitFunction(node) {
            var _this5 = this;

            var i, iz;
            if (node.type === _estraverse.Syntax.FunctionDeclaration) {
                this.currentScope().__define(node.id, new _definition.Definition(_variable2.default.FunctionName, node.id, node, null, null, null));
            }

            if (node.type === _estraverse.Syntax.FunctionExpression && node.id) {
                this.scopeManager.__nestFunctionExpressionNameScope(node);
            }

            this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);

            for (i = 0, iz = node.params.length; i < iz; ++i) {
                this.visitPattern(node.params[i], { processRightHandNodes: true }, function (pattern, info) {
                    _this5.currentScope().__define(pattern, new _definition.ParameterDefinition(pattern, node, i, info.rest));

                    _this5.referencingDefaultValue(pattern, info.assignments, null, true);
                });
            }

            if (node.rest) {
                this.visitPattern({
                    type: 'RestElement',
                    argument: node.rest
                }, function (pattern) {
                    _this5.currentScope().__define(pattern, new _definition.ParameterDefinition(pattern, node, node.params.length, true));
                });
            }

            if (node.body.type === _estraverse.Syntax.BlockStatement) {
                this.visitChildren(node.body);
            } else {
                this.visit(node.body);
            }

            this.close(node);
        }
    }, {
        key: 'visitClass',
        value: function visitClass(node) {
            if (node.type === _estraverse.Syntax.ClassDeclaration) {
                this.currentScope().__define(node.id, new _definition.Definition(_variable2.default.ClassName, node.id, node, null, null, null));
            }

            this.visit(node.superClass);

            this.scopeManager.__nestClassScope(node);

            if (node.id) {
                this.currentScope().__define(node.id, new _definition.Definition(_variable2.default.ClassName, node.id, node));
            }
            this.visit(node.body);

            this.close(node);
        }
    }, {
        key: 'visitProperty',
        value: function visitProperty(node) {
            var previous, isMethodDefinition;
            if (node.computed) {
                this.visit(node.key);
            }

            isMethodDefinition = node.type === _estraverse.Syntax.MethodDefinition;
            if (isMethodDefinition) {
                previous = this.pushInnerMethodDefinition(true);
            }
            this.visit(node.value);
            if (isMethodDefinition) {
                this.popInnerMethodDefinition(previous);
            }
        }
    }, {
        key: 'visitForIn',
        value: function visitForIn(node) {
            var _this6 = this;

            if (node.left.type === _estraverse.Syntax.VariableDeclaration && node.left.kind !== 'var') {
                this.materializeTDZScope(node.right, node);
                this.visit(node.right);
                this.close(node.right);

                this.materializeIterationScope(node);
                this.visit(node.body);
                this.close(node);
            } else {
                if (node.left.type === _estraverse.Syntax.VariableDeclaration) {
                    this.visit(node.left);
                    this.visitPattern(node.left.declarations[0].id, function (pattern) {
                        _this6.currentScope().__referencing(pattern, _reference2.default.WRITE, node.right, null, true, true);
                    });
                } else {
                    this.visitPattern(node.left, { processRightHandNodes: true }, function (pattern, info) {
                        var maybeImplicitGlobal = null;
                        if (!_this6.currentScope().isStrict) {
                            maybeImplicitGlobal = {
                                pattern: pattern,
                                node: node
                            };
                        }
                        _this6.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
                        _this6.currentScope().__referencing(pattern, _reference2.default.WRITE, node.right, maybeImplicitGlobal, true, false);
                    });
                }
                this.visit(node.right);
                this.visit(node.body);
            }
        }
    }, {
        key: 'visitVariableDeclaration',
        value: function visitVariableDeclaration(variableTargetScope, type, node, index, fromTDZ) {
            var _this7 = this;

            var decl, init;

            decl = node.declarations[index];
            init = decl.init;
            this.visitPattern(decl.id, { processRightHandNodes: !fromTDZ }, function (pattern, info) {
                variableTargetScope.__define(pattern, new _definition.Definition(type, pattern, decl, node, index, node.kind));

                if (!fromTDZ) {
                    _this7.referencingDefaultValue(pattern, info.assignments, null, true);
                }
                if (init) {
                    _this7.currentScope().__referencing(pattern, _reference2.default.WRITE, init, null, !info.topLevel, true);
                }
            });
        }
    }, {
        key: 'AssignmentExpression',
        value: function AssignmentExpression(node) {
            var _this8 = this;

            if (_patternVisitor2.default.isPattern(node.left)) {
                if (node.operator === '=') {
                    this.visitPattern(node.left, { processRightHandNodes: true }, function (pattern, info) {
                        var maybeImplicitGlobal = null;
                        if (!_this8.currentScope().isStrict) {
                            maybeImplicitGlobal = {
                                pattern: pattern,
                                node: node
                            };
                        }
                        _this8.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
                        _this8.currentScope().__referencing(pattern, _reference2.default.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);
                    });
                } else {
                    this.currentScope().__referencing(node.left, _reference2.default.RW, node.right);
                }
            } else {
                this.visit(node.left);
            }
            this.visit(node.right);
        }
    }, {
        key: 'CatchClause',
        value: function CatchClause(node) {
            var _this9 = this;

            this.scopeManager.__nestCatchScope(node);

            this.visitPattern(node.param, { processRightHandNodes: true }, function (pattern, info) {
                _this9.currentScope().__define(pattern, new _definition.Definition(_variable2.default.CatchClause, node.param, node, null, null, null));
                _this9.referencingDefaultValue(pattern, info.assignments, null, true);
            });
            this.visit(node.body);

            this.close(node);
        }
    }, {
        key: 'Program',
        value: function Program(node) {
            this.scopeManager.__nestGlobalScope(node);

            if (this.scopeManager.__isNodejsScope()) {
                this.currentScope().isStrict = false;
                this.scopeManager.__nestFunctionScope(node, false);
            }

            if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {
                this.scopeManager.__nestModuleScope(node);
            }

            if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
                this.currentScope().isStrict = true;
            }

            this.visitChildren(node);
            this.close(node);
        }
    }, {
        key: 'Identifier',
        value: function Identifier(node) {
            this.currentScope().__referencing(node);
        }
    }, {
        key: 'UpdateExpression',
        value: function UpdateExpression(node) {
            if (_patternVisitor2.default.isPattern(node.argument)) {
                this.currentScope().__referencing(node.argument, _reference2.default.RW, null);
            } else {
                this.visitChildren(node);
            }
        }
    }, {
        key: 'MemberExpression',
        value: function MemberExpression(node) {
            this.visit(node.object);
            if (node.computed) {
                this.visit(node.property);
            }
        }
    }, {
        key: 'Property',
        value: function Property(node) {
            this.visitProperty(node);
        }
    }, {
        key: 'MethodDefinition',
        value: function MethodDefinition(node) {
            this.visitProperty(node);
        }
    }, {
        key: 'BreakStatement',
        value: function BreakStatement() {}
    }, {
        key: 'ContinueStatement',
        value: function ContinueStatement() {}
    }, {
        key: 'LabeledStatement',
        value: function LabeledStatement(node) {
            this.visit(node.body);
        }
    }, {
        key: 'ForStatement',
        value: function ForStatement(node) {
            if (node.init && node.init.type === _estraverse.Syntax.VariableDeclaration && node.init.kind !== 'var') {
                this.scopeManager.__nestForScope(node);
            }

            this.visitChildren(node);

            this.close(node);
        }
    }, {
        key: 'ClassExpression',
        value: function ClassExpression(node) {
            this.visitClass(node);
        }
    }, {
        key: 'ClassDeclaration',
        value: function ClassDeclaration(node) {
            this.visitClass(node);
        }
    }, {
        key: 'CallExpression',
        value: function CallExpression(node) {
            if (!this.scopeManager.__ignoreEval() && node.callee.type === _estraverse.Syntax.Identifier && node.callee.name === 'eval') {
                this.currentScope().variableScope.__detectEval();
            }
            this.visitChildren(node);
        }
    }, {
        key: 'BlockStatement',
        value: function BlockStatement(node) {
            if (this.scopeManager.__isES6()) {
                this.scopeManager.__nestBlockScope(node);
            }

            this.visitChildren(node);

            this.close(node);
        }
    }, {
        key: 'ThisExpression',
        value: function ThisExpression() {
            this.currentScope().variableScope.__detectThis();
        }
    }, {
        key: 'WithStatement',
        value: function WithStatement(node) {
            this.visit(node.object);
            this.scopeManager.__nestWithScope(node);

            this.visit(node.body);

            this.close(node);
        }
    }, {
        key: 'VariableDeclaration',
        value: function VariableDeclaration(node) {
            var variableTargetScope, i, iz, decl;
            variableTargetScope = node.kind === 'var' ? this.currentScope().variableScope : this.currentScope();
            for (i = 0, iz = node.declarations.length; i < iz; ++i) {
                decl = node.declarations[i];
                this.visitVariableDeclaration(variableTargetScope, _variable2.default.Variable, node, i);
                if (decl.init) {
                    this.visit(decl.init);
                }
            }
        }

    }, {
        key: 'SwitchStatement',
        value: function SwitchStatement(node) {
            var i, iz;

            this.visit(node.discriminant);

            if (this.scopeManager.__isES6()) {
                this.scopeManager.__nestSwitchScope(node);
            }

            for (i = 0, iz = node.cases.length; i < iz; ++i) {
                this.visit(node.cases[i]);
            }

            this.close(node);
        }
    }, {
        key: 'FunctionDeclaration',
        value: function FunctionDeclaration(node) {
            this.visitFunction(node);
        }
    }, {
        key: 'FunctionExpression',
        value: function FunctionExpression(node) {
            this.visitFunction(node);
        }
    }, {
        key: 'ForOfStatement',
        value: function ForOfStatement(node) {
            this.visitForIn(node);
        }
    }, {
        key: 'ForInStatement',
        value: function ForInStatement(node) {
            this.visitForIn(node);
        }
    }, {
        key: 'ArrowFunctionExpression',
        value: function ArrowFunctionExpression(node) {
            this.visitFunction(node);
        }
    }, {
        key: 'ImportDeclaration',
        value: function ImportDeclaration(node) {
            var importer;
            importer = new Importer(node, this);
            importer.visit(node);
        }
    }, {
        key: 'visitExportDeclaration',
        value: function visitExportDeclaration(node) {
            if (node.source) {
                return;
            }
            if (node.declaration) {
                this.visit(node.declaration);
                return;
            }

            this.visitChildren(node);
        }
    }, {
        key: 'ExportDeclaration',
        value: function ExportDeclaration(node) {
            this.visitExportDeclaration(node);
        }
    }, {
        key: 'ExportNamedDeclaration',
        value: function ExportNamedDeclaration(node) {
            this.visitExportDeclaration(node);
        }
    }, {
        key: 'ExportSpecifier',
        value: function ExportSpecifier(node) {
            var local = node.id || node.local;
            this.visit(local);
        }
    }, {
        key: 'MetaProperty',
        value: function MetaProperty() {
        }
    }]);

    return Referencer;
}(_esrecurse2.default.Visitor);


exports.default = Referencer;

},
   {"./definition":"/node_modules/escope/lib/definition.js","./pattern-visitor":"/node_modules/escope/lib/pattern-visitor.js","./reference":"/node_modules/escope/lib/reference.js","./variable":"/node_modules/escope/lib/variable.js","assert":"/node_modules/browserify/node_modules/assert/assert.js","esrecurse":"/node_modules/escope/node_modules/esrecurse/esrecurse.js","estraverse":"/node_modules/estraverse/estraverse.js"}],

"/node_modules/escope/lib/scope-manager.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Redistribution and use in source and binary forms, with or without
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       modification, are permitted provided that the following conditions are met:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Redistributions of source code must retain the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           notice, this list of conditions and the following disclaimer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Redistributions in binary form must reproduce the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           notice, this list of conditions and the following disclaimer in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           documentation and/or other materials provided with the distribution.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _es6WeakMap = require('es6-weak-map');

var _es6WeakMap2 = _interopRequireDefault(_es6WeakMap);

var _scope = require('./scope');

var _scope2 = _interopRequireDefault(_scope);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ScopeManager = function () {
    function ScopeManager(options) {
        _classCallCheck(this, ScopeManager);

        this.scopes = [];
        this.globalScope = null;
        this.__nodeToScope = new _es6WeakMap2.default();
        this.__currentScope = null;
        this.__options = options;
        this.__declaredVariables = new _es6WeakMap2.default();
    }

    _createClass(ScopeManager, [{
        key: '__useDirective',
        value: function __useDirective() {
            return this.__options.directive;
        }
    }, {
        key: '__isOptimistic',
        value: function __isOptimistic() {
            return this.__options.optimistic;
        }
    }, {
        key: '__ignoreEval',
        value: function __ignoreEval() {
            return this.__options.ignoreEval;
        }
    }, {
        key: '__isNodejsScope',
        value: function __isNodejsScope() {
            return this.__options.nodejsScope;
        }
    }, {
        key: 'isModule',
        value: function isModule() {
            return this.__options.sourceType === 'module';
        }
    }, {
        key: 'isImpliedStrict',
        value: function isImpliedStrict() {
            return this.__options.impliedStrict;
        }
    }, {
        key: 'isStrictModeSupported',
        value: function isStrictModeSupported() {
            return this.__options.ecmaVersion >= 5;
        }

    }, {
        key: '__get',
        value: function __get(node) {
            return this.__nodeToScope.get(node);
        }

    }, {
        key: 'getDeclaredVariables',
        value: function getDeclaredVariables(node) {
            return this.__declaredVariables.get(node) || [];
        }

    }, {
        key: 'acquire',
        value: function acquire(node, inner) {
            var scopes, scope, i, iz;

            function predicate(scope) {
                if (scope.type === 'function' && scope.functionExpressionScope) {
                    return false;
                }
                if (scope.type === 'TDZ') {
                    return false;
                }
                return true;
            }

            scopes = this.__get(node);
            if (!scopes || scopes.length === 0) {
                return null;
            }

            if (scopes.length === 1) {
                return scopes[0];
            }

            if (inner) {
                for (i = scopes.length - 1; i >= 0; --i) {
                    scope = scopes[i];
                    if (predicate(scope)) {
                        return scope;
                    }
                }
            } else {
                for (i = 0, iz = scopes.length; i < iz; ++i) {
                    scope = scopes[i];
                    if (predicate(scope)) {
                        return scope;
                    }
                }
            }

            return null;
        }

    }, {
        key: 'acquireAll',
        value: function acquireAll(node) {
            return this.__get(node);
        }

    }, {
        key: 'release',
        value: function release(node, inner) {
            var scopes, scope;
            scopes = this.__get(node);
            if (scopes && scopes.length) {
                scope = scopes[0].upper;
                if (!scope) {
                    return null;
                }
                return this.acquire(scope.block, inner);
            }
            return null;
        }
    }, {
        key: 'attach',
        value: function attach() {}
    }, {
        key: 'detach',
        value: function detach() {}
    }, {
        key: '__nestScope',
        value: function __nestScope(scope) {
            if (scope instanceof _scope.GlobalScope) {
                (0, _assert2.default)(this.__currentScope === null);
                this.globalScope = scope;
            }
            this.__currentScope = scope;
            return scope;
        }
    }, {
        key: '__nestGlobalScope',
        value: function __nestGlobalScope(node) {
            return this.__nestScope(new _scope.GlobalScope(this, node));
        }
    }, {
        key: '__nestBlockScope',
        value: function __nestBlockScope(node, isMethodDefinition) {
            return this.__nestScope(new _scope.BlockScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestFunctionScope',
        value: function __nestFunctionScope(node, isMethodDefinition) {
            return this.__nestScope(new _scope.FunctionScope(this, this.__currentScope, node, isMethodDefinition));
        }
    }, {
        key: '__nestForScope',
        value: function __nestForScope(node) {
            return this.__nestScope(new _scope.ForScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestCatchScope',
        value: function __nestCatchScope(node) {
            return this.__nestScope(new _scope.CatchScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestWithScope',
        value: function __nestWithScope(node) {
            return this.__nestScope(new _scope.WithScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestClassScope',
        value: function __nestClassScope(node) {
            return this.__nestScope(new _scope.ClassScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestSwitchScope',
        value: function __nestSwitchScope(node) {
            return this.__nestScope(new _scope.SwitchScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestModuleScope',
        value: function __nestModuleScope(node) {
            return this.__nestScope(new _scope.ModuleScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestTDZScope',
        value: function __nestTDZScope(node) {
            return this.__nestScope(new _scope.TDZScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestFunctionExpressionNameScope',
        value: function __nestFunctionExpressionNameScope(node) {
            return this.__nestScope(new _scope.FunctionExpressionNameScope(this, this.__currentScope, node));
        }
    }, {
        key: '__isES6',
        value: function __isES6() {
            return this.__options.ecmaVersion >= 6;
        }
    }]);

    return ScopeManager;
}();


exports.default = ScopeManager;

},
   {"./scope":"/node_modules/escope/lib/scope.js","assert":"/node_modules/browserify/node_modules/assert/assert.js","es6-weak-map":"/node_modules/escope/node_modules/es6-weak-map/index.js"}],

"/node_modules/escope/lib/scope.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ClassScope = exports.ForScope = exports.FunctionScope = exports.SwitchScope = exports.BlockScope = exports.TDZScope = exports.WithScope = exports.CatchScope = exports.FunctionExpressionNameScope = exports.ModuleScope = exports.GlobalScope = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Redistribution and use in source and binary forms, with or without
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       modification, are permitted provided that the following conditions are met:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Redistributions of source code must retain the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           notice, this list of conditions and the following disclaimer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Redistributions in binary form must reproduce the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           notice, this list of conditions and the following disclaimer in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           documentation and/or other materials provided with the distribution.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _estraverse = require('estraverse');

var _es6Map = require('es6-map');

var _es6Map2 = _interopRequireDefault(_es6Map);

var _reference = require('./reference');

var _reference2 = _interopRequireDefault(_reference);

var _variable = require('./variable');

var _variable2 = _interopRequireDefault(_variable);

var _definition = require('./definition');

var _definition2 = _interopRequireDefault(_definition);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function isStrictScope(scope, block, isMethodDefinition, useDirective) {
    var body, i, iz, stmt, expr;

    if (scope.upper && scope.upper.isStrict) {
        return true;
    }

    if (block.type === _estraverse.Syntax.ArrowFunctionExpression) {
        return true;
    }

    if (isMethodDefinition) {
        return true;
    }

    if (scope.type === 'class' || scope.type === 'module') {
        return true;
    }

    if (scope.type === 'block' || scope.type === 'switch') {
        return false;
    }

    if (scope.type === 'function') {
        if (block.type === _estraverse.Syntax.Program) {
            body = block;
        } else {
            body = block.body;
        }
    } else if (scope.type === 'global') {
        body = block;
    } else {
        return false;
    }

    if (useDirective) {
        for (i = 0, iz = body.body.length; i < iz; ++i) {
            stmt = body.body[i];
            if (stmt.type !== _estraverse.Syntax.DirectiveStatement) {
                break;
            }
            if (stmt.raw === '"use strict"' || stmt.raw === '\'use strict\'') {
                return true;
            }
        }
    } else {
        for (i = 0, iz = body.body.length; i < iz; ++i) {
            stmt = body.body[i];
            if (stmt.type !== _estraverse.Syntax.ExpressionStatement) {
                break;
            }
            expr = stmt.expression;
            if (expr.type !== _estraverse.Syntax.Literal || typeof expr.value !== 'string') {
                break;
            }
            if (expr.raw != null) {
                if (expr.raw === '"use strict"' || expr.raw === '\'use strict\'') {
                    return true;
                }
            } else {
                if (expr.value === 'use strict') {
                    return true;
                }
            }
        }
    }
    return false;
}

function registerScope(scopeManager, scope) {
    var scopes;

    scopeManager.scopes.push(scope);

    scopes = scopeManager.__nodeToScope.get(scope.block);
    if (scopes) {
        scopes.push(scope);
    } else {
        scopeManager.__nodeToScope.set(scope.block, [scope]);
    }
}

function shouldBeStatically(def) {
    return def.type === _variable2.default.ClassName || def.type === _variable2.default.Variable && def.parent.kind !== 'var';
}

var Scope = function () {
    function Scope(scopeManager, type, upperScope, block, isMethodDefinition) {
        _classCallCheck(this, Scope);

        this.type = type;
        this.set = new _es6Map2.default();
        this.taints = new _es6Map2.default();
        this.dynamic = this.type === 'global' || this.type === 'with';
        this.block = block;
        this.through = [];
        this.variables = [];
        this.references = [];

        this.variableScope = this.type === 'global' || this.type === 'function' || this.type === 'module' ? this : upperScope.variableScope;
        this.functionExpressionScope = false;
        this.directCallToEvalScope = false;
        this.thisFound = false;

        this.__left = [];

        this.upper = upperScope;
        this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());

        this.childScopes = [];
        if (this.upper) {
            this.upper.childScopes.push(this);
        }

        this.__declaredVariables = scopeManager.__declaredVariables;

        registerScope(scopeManager, this);
    }

    _createClass(Scope, [{
        key: '__shouldStaticallyClose',
        value: function __shouldStaticallyClose(scopeManager) {
            return !this.dynamic || scopeManager.__isOptimistic();
        }
    }, {
        key: '__shouldStaticallyCloseForGlobal',
        value: function __shouldStaticallyCloseForGlobal(ref) {
            var name = ref.identifier.name;
            if (!this.set.has(name)) {
                return false;
            }

            var variable = this.set.get(name);
            var defs = variable.defs;
            return defs.length > 0 && defs.every(shouldBeStatically);
        }
    }, {
        key: '__staticCloseRef',
        value: function __staticCloseRef(ref) {
            if (!this.__resolve(ref)) {
                this.__delegateToUpperScope(ref);
            }
        }
    }, {
        key: '__dynamicCloseRef',
        value: function __dynamicCloseRef(ref) {
            var current = this;
            do {
                current.through.push(ref);
                current = current.upper;
            } while (current);
        }
    }, {
        key: '__globalCloseRef',
        value: function __globalCloseRef(ref) {
            if (this.__shouldStaticallyCloseForGlobal(ref)) {
                this.__staticCloseRef(ref);
            } else {
                this.__dynamicCloseRef(ref);
            }
        }
    }, {
        key: '__close',
        value: function __close(scopeManager) {
            var closeRef;
            if (this.__shouldStaticallyClose(scopeManager)) {
                closeRef = this.__staticCloseRef;
            } else if (this.type !== 'global') {
                closeRef = this.__dynamicCloseRef;
            } else {
                closeRef = this.__globalCloseRef;
            }

            for (var i = 0, iz = this.__left.length; i < iz; ++i) {
                var ref = this.__left[i];
                closeRef.call(this, ref);
            }
            this.__left = null;

            return this.upper;
        }
    }, {
        key: '__resolve',
        value: function __resolve(ref) {
            var variable, name;
            name = ref.identifier.name;
            if (this.set.has(name)) {
                variable = this.set.get(name);
                variable.references.push(ref);
                variable.stack = variable.stack && ref.from.variableScope === this.variableScope;
                if (ref.tainted) {
                    variable.tainted = true;
                    this.taints.set(variable.name, true);
                }
                ref.resolved = variable;
                return true;
            }
            return false;
        }
    }, {
        key: '__delegateToUpperScope',
        value: function __delegateToUpperScope(ref) {
            if (this.upper) {
                this.upper.__left.push(ref);
            }
            this.through.push(ref);
        }
    }, {
        key: '__addDeclaredVariablesOfNode',
        value: function __addDeclaredVariablesOfNode(variable, node) {
            if (node == null) {
                return;
            }

            var variables = this.__declaredVariables.get(node);
            if (variables == null) {
                variables = [];
                this.__declaredVariables.set(node, variables);
            }
            if (variables.indexOf(variable) === -1) {
                variables.push(variable);
            }
        }
    }, {
        key: '__defineGeneric',
        value: function __defineGeneric(name, set, variables, node, def) {
            var variable;

            variable = set.get(name);
            if (!variable) {
                variable = new _variable2.default(name, this);
                set.set(name, variable);
                variables.push(variable);
            }

            if (def) {
                variable.defs.push(def);
                if (def.type !== _variable2.default.TDZ) {
                    this.__addDeclaredVariablesOfNode(variable, def.node);
                    this.__addDeclaredVariablesOfNode(variable, def.parent);
                }
            }
            if (node) {
                variable.identifiers.push(node);
            }
        }
    }, {
        key: '__define',
        value: function __define(node, def) {
            if (node && node.type === _estraverse.Syntax.Identifier) {
                this.__defineGeneric(node.name, this.set, this.variables, node, def);
            }
        }
    }, {
        key: '__referencing',
        value: function __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
            if (!node || node.type !== _estraverse.Syntax.Identifier) {
                return;
            }

            if (node.name === 'super') {
                return;
            }

            var ref = new _reference2.default(node, this, assign || _reference2.default.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);
            this.references.push(ref);
            this.__left.push(ref);
        }
    }, {
        key: '__detectEval',
        value: function __detectEval() {
            var current;
            current = this;
            this.directCallToEvalScope = true;
            do {
                current.dynamic = true;
                current = current.upper;
            } while (current);
        }
    }, {
        key: '__detectThis',
        value: function __detectThis() {
            this.thisFound = true;
        }
    }, {
        key: '__isClosed',
        value: function __isClosed() {
            return this.__left === null;
        }

    }, {
        key: 'resolve',
        value: function resolve(ident) {
            var ref, i, iz;
            (0, _assert2.default)(this.__isClosed(), 'Scope should be closed.');
            (0, _assert2.default)(ident.type === _estraverse.Syntax.Identifier, 'Target should be identifier.');
            for (i = 0, iz = this.references.length; i < iz; ++i) {
                ref = this.references[i];
                if (ref.identifier === ident) {
                    return ref;
                }
            }
            return null;
        }

    }, {
        key: 'isStatic',
        value: function isStatic() {
            return !this.dynamic;
        }

    }, {
        key: 'isArgumentsMaterialized',
        value: function isArgumentsMaterialized() {
            return true;
        }

    }, {
        key: 'isThisMaterialized',
        value: function isThisMaterialized() {
            return true;
        }
    }, {
        key: 'isUsedName',
        value: function isUsedName(name) {
            if (this.set.has(name)) {
                return true;
            }
            for (var i = 0, iz = this.through.length; i < iz; ++i) {
                if (this.through[i].identifier.name === name) {
                    return true;
                }
            }
            return false;
        }
    }]);

    return Scope;
}();

exports.default = Scope;

var GlobalScope = exports.GlobalScope = function (_Scope) {
    _inherits(GlobalScope, _Scope);

    function GlobalScope(scopeManager, block) {
        _classCallCheck(this, GlobalScope);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GlobalScope).call(this, scopeManager, 'global', null, block, false));

        _this.implicit = {
            set: new _es6Map2.default(),
            variables: [],
            left: []
        };
        return _this;
    }

    _createClass(GlobalScope, [{
        key: '__close',
        value: function __close(scopeManager) {
            var implicit = [];
            for (var i = 0, iz = this.__left.length; i < iz; ++i) {
                var ref = this.__left[i];
                if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
                    implicit.push(ref.__maybeImplicitGlobal);
                }
            }

            for (var i = 0, iz = implicit.length; i < iz; ++i) {
                var info = implicit[i];
                this.__defineImplicit(info.pattern, new _definition2.default(_variable2.default.ImplicitGlobalVariable, info.pattern, info.node, null, null, null));
            }

            this.implicit.left = this.__left;

            return _get(Object.getPrototypeOf(GlobalScope.prototype), '__close', this).call(this, scopeManager);
        }
    }, {
        key: '__defineImplicit',
        value: function __defineImplicit(node, def) {
            if (node && node.type === _estraverse.Syntax.Identifier) {
                this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);
            }
        }
    }]);

    return GlobalScope;
}(Scope);

var ModuleScope = exports.ModuleScope = function (_Scope2) {
    _inherits(ModuleScope, _Scope2);

    function ModuleScope(scopeManager, upperScope, block) {
        _classCallCheck(this, ModuleScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ModuleScope).call(this, scopeManager, 'module', upperScope, block, false));
    }

    return ModuleScope;
}(Scope);

var FunctionExpressionNameScope = exports.FunctionExpressionNameScope = function (_Scope3) {
    _inherits(FunctionExpressionNameScope, _Scope3);

    function FunctionExpressionNameScope(scopeManager, upperScope, block) {
        _classCallCheck(this, FunctionExpressionNameScope);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(FunctionExpressionNameScope).call(this, scopeManager, 'function-expression-name', upperScope, block, false));

        _this3.__define(block.id, new _definition2.default(_variable2.default.FunctionName, block.id, block, null, null, null));
        _this3.functionExpressionScope = true;
        return _this3;
    }

    return FunctionExpressionNameScope;
}(Scope);

var CatchScope = exports.CatchScope = function (_Scope4) {
    _inherits(CatchScope, _Scope4);

    function CatchScope(scopeManager, upperScope, block) {
        _classCallCheck(this, CatchScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(CatchScope).call(this, scopeManager, 'catch', upperScope, block, false));
    }

    return CatchScope;
}(Scope);

var WithScope = exports.WithScope = function (_Scope5) {
    _inherits(WithScope, _Scope5);

    function WithScope(scopeManager, upperScope, block) {
        _classCallCheck(this, WithScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(WithScope).call(this, scopeManager, 'with', upperScope, block, false));
    }

    _createClass(WithScope, [{
        key: '__close',
        value: function __close(scopeManager) {
            if (this.__shouldStaticallyClose(scopeManager)) {
                return _get(Object.getPrototypeOf(WithScope.prototype), '__close', this).call(this, scopeManager);
            }

            for (var i = 0, iz = this.__left.length; i < iz; ++i) {
                var ref = this.__left[i];
                ref.tainted = true;
                this.__delegateToUpperScope(ref);
            }
            this.__left = null;

            return this.upper;
        }
    }]);

    return WithScope;
}(Scope);

var TDZScope = exports.TDZScope = function (_Scope6) {
    _inherits(TDZScope, _Scope6);

    function TDZScope(scopeManager, upperScope, block) {
        _classCallCheck(this, TDZScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(TDZScope).call(this, scopeManager, 'TDZ', upperScope, block, false));
    }

    return TDZScope;
}(Scope);

var BlockScope = exports.BlockScope = function (_Scope7) {
    _inherits(BlockScope, _Scope7);

    function BlockScope(scopeManager, upperScope, block) {
        _classCallCheck(this, BlockScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(BlockScope).call(this, scopeManager, 'block', upperScope, block, false));
    }

    return BlockScope;
}(Scope);

var SwitchScope = exports.SwitchScope = function (_Scope8) {
    _inherits(SwitchScope, _Scope8);

    function SwitchScope(scopeManager, upperScope, block) {
        _classCallCheck(this, SwitchScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(SwitchScope).call(this, scopeManager, 'switch', upperScope, block, false));
    }

    return SwitchScope;
}(Scope);

var FunctionScope = exports.FunctionScope = function (_Scope9) {
    _inherits(FunctionScope, _Scope9);

    function FunctionScope(scopeManager, upperScope, block, isMethodDefinition) {
        _classCallCheck(this, FunctionScope);

        var _this9 = _possibleConstructorReturn(this, Object.getPrototypeOf(FunctionScope).call(this, scopeManager, 'function', upperScope, block, isMethodDefinition));

        if (_this9.block.type !== _estraverse.Syntax.ArrowFunctionExpression) {
            _this9.__defineArguments();
        }
        return _this9;
    }

    _createClass(FunctionScope, [{
        key: 'isArgumentsMaterialized',
        value: function isArgumentsMaterialized() {
            if (this.block.type === _estraverse.Syntax.ArrowFunctionExpression) {
                return false;
            }

            if (!this.isStatic()) {
                return true;
            }

            var variable = this.set.get('arguments');
            (0, _assert2.default)(variable, 'Always have arguments variable.');
            return variable.tainted || variable.references.length !== 0;
        }
    }, {
        key: 'isThisMaterialized',
        value: function isThisMaterialized() {
            if (!this.isStatic()) {
                return true;
            }
            return this.thisFound;
        }
    }, {
        key: '__defineArguments',
        value: function __defineArguments() {
            this.__defineGeneric('arguments', this.set, this.variables, null, null);
            this.taints.set('arguments', true);
        }
    }]);

    return FunctionScope;
}(Scope);

var ForScope = exports.ForScope = function (_Scope10) {
    _inherits(ForScope, _Scope10);

    function ForScope(scopeManager, upperScope, block) {
        _classCallCheck(this, ForScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ForScope).call(this, scopeManager, 'for', upperScope, block, false));
    }

    return ForScope;
}(Scope);

var ClassScope = exports.ClassScope = function (_Scope11) {
    _inherits(ClassScope, _Scope11);

    function ClassScope(scopeManager, upperScope, block) {
        _classCallCheck(this, ClassScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ClassScope).call(this, scopeManager, 'class', upperScope, block, false));
    }

    return ClassScope;
}(Scope);


},
   {"./definition":"/node_modules/escope/lib/definition.js","./reference":"/node_modules/escope/lib/reference.js","./variable":"/node_modules/escope/lib/variable.js","assert":"/node_modules/browserify/node_modules/assert/assert.js","es6-map":"/node_modules/es6-map/index.js","estraverse":"/node_modules/estraverse/estraverse.js"}],

"/node_modules/escope/lib/variable.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Variable = function Variable(name, scope) {
  _classCallCheck(this, Variable);

  this.name = name;
  this.identifiers = [];
  this.references = [];

  this.defs = [];

  this.tainted = false;
  this.stack = true;
  this.scope = scope;
};

exports.default = Variable;


Variable.CatchClause = 'CatchClause';
Variable.Parameter = 'Parameter';
Variable.FunctionName = 'FunctionName';
Variable.ClassName = 'ClassName';
Variable.Variable = 'Variable';
Variable.ImportBinding = 'ImportBinding';
Variable.TDZ = 'TDZ';
Variable.ImplicitGlobalVariable = 'ImplicitGlobalVariable';


},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')() ? WeakMap : require('./polyfill');

},
   {"./is-implemented":"/node_modules/escope/node_modules/es6-weak-map/is-implemented.js","./polyfill":"/node_modules/escope/node_modules/es6-weak-map/polyfill.js"}],

"/node_modules/escope/node_modules/es6-weak-map/is-implemented.js": [function(require,module,exports){
'use strict';

module.exports = function () {
	var weakMap, x;
	if (typeof WeakMap !== 'function') return false;
	try {
		weakMap = new WeakMap([[x = {}, 'one'], [{}, 'two'], [{}, 'three']]);
	} catch (e) {
		return false;
	}
	if (String(weakMap) !== '[object WeakMap]') return false;
	if (typeof weakMap.set !== 'function') return false;
	if (weakMap.set({}, 1) !== weakMap) return false;
	if (typeof weakMap.delete !== 'function') return false;
	if (typeof weakMap.has !== 'function') return false;
	if (weakMap.get(x) !== 'one') return false;

	return true;
};

},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/is-native-implemented.js": [function(require,module,exports){
'use strict';

module.exports = (function () {
	if (typeof WeakMap !== 'function') return false;
	return (Object.prototype.toString.call(new WeakMap()) === '[object WeakMap]');
}());

},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/auto-bind.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/d/auto-bind.js"][0].apply(exports,arguments)
},
   {"es5-ext/object/copy":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/copy.js","es5-ext/object/map":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/map.js","es5-ext/object/valid-callable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/object/valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/d/index.js"][0].apply(exports,arguments)
},
   {"es5-ext/object/assign":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/index.js","es5-ext/object/is-callable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/is-callable.js","es5-ext/object/normalize-options":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/normalize-options.js","es5-ext/string/#/contains":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/array/#/clear.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/array/#/clear.js"][0].apply(exports,arguments)
},
   {"../../object/valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/function/is-arguments.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/function/is-arguments.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/_iterate.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/_iterate.js"][0].apply(exports,arguments)
},
   {"./valid-callable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-callable.js","./valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/assign/index.js"][0].apply(exports,arguments)
},
   {"./is-implemented":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/is-implemented.js","./shim":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/shim.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/is-implemented.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/assign/is-implemented.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/shim.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/assign/shim.js"][0].apply(exports,arguments)
},
   {"../keys":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/keys/index.js","../valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/copy.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/copy.js"][0].apply(exports,arguments)
},
   {"./assign":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/index.js","./valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/create.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/create.js"][0].apply(exports,arguments)
},
   {"./set-prototype-of/is-implemented":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js","./set-prototype-of/shim":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/shim.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/for-each.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/for-each.js"][0].apply(exports,arguments)
},
   {"./_iterate":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/_iterate.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/is-callable.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/is-callable.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/is-object.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/is-object.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/keys/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/keys/index.js"][0].apply(exports,arguments)
},
   {"./is-implemented":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/keys/is-implemented.js","./shim":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/keys/shim.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/keys/is-implemented.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/keys/is-implemented.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/keys/shim.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/keys/shim.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/map.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/map.js"][0].apply(exports,arguments)
},
   {"./for-each":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/for-each.js","./valid-callable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-callable.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/normalize-options.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/normalize-options.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/index.js"][0].apply(exports,arguments)
},
   {"./is-implemented":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js","./shim":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/shim.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/shim.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/shim.js"][0].apply(exports,arguments)
},
   {"../create":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/create.js","../is-object":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/is-object.js","../valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-callable.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-object.js": [function(require,module,exports){
'use strict';

var isObject = require('./is-object');

module.exports = function (value) {
	if (!isObject(value)) throw new TypeError(value + " is not an Object");
	return value;
};

},
   {"./is-object":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/is-object.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/string/#/contains/index.js"][0].apply(exports,arguments)
},
   {"./is-implemented":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/is-implemented.js","./shim":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/shim.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/is-implemented.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/string/#/contains/is-implemented.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/shim.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/string/#/contains/shim.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/is-string.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/string/is-string.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/random-uniq.js": [function(require,module,exports){
'use strict';

var generated = Object.create(null)

  , random = Math.random;

module.exports = function () {
	var str;
	do { str = random().toString(36).slice(2); } while (generated[str]);
	return str;
};

},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/array.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/array.js"][0].apply(exports,arguments)
},
   {"./":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/index.js","d":"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/index.js","es5-ext/object/set-prototype-of":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/index.js","es5-ext/string/#/contains":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/for-of.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/for-of.js"][0].apply(exports,arguments)
},
   {"./get":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/get.js","es5-ext/function/is-arguments":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/function/is-arguments.js","es5-ext/object/valid-callable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/string/is-string":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/is-string.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/get.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/get.js"][0].apply(exports,arguments)
},
   {"./array":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/array.js","./string":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/string.js","./valid-iterable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/valid-iterable.js","es5-ext/function/is-arguments":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/function/is-arguments.js","es5-ext/string/is-string":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/is-string.js","es6-symbol":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/index.js"][0].apply(exports,arguments)
},
   {"d":"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/index.js","d/auto-bind":"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/auto-bind.js","es5-ext/array/#/clear":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/array/#/clear.js","es5-ext/object/assign":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/index.js","es5-ext/object/valid-callable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/object/valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js","es6-symbol":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/is-iterable.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/is-iterable.js"][0].apply(exports,arguments)
},
   {"es5-ext/function/is-arguments":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/function/is-arguments.js","es5-ext/string/is-string":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/is-string.js","es6-symbol":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/string.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/string.js"][0].apply(exports,arguments)
},
   {"./":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/index.js","d":"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/index.js","es5-ext/object/set-prototype-of":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/valid-iterable.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/valid-iterable.js"][0].apply(exports,arguments)
},
   {"./is-iterable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/is-iterable.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-symbol/index.js"][0].apply(exports,arguments)
},
   {"./is-implemented":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/is-implemented.js","./polyfill":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/polyfill.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/is-implemented.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-symbol/is-implemented.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/is-symbol.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-symbol/is-symbol.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/polyfill.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-symbol/polyfill.js"][0].apply(exports,arguments)
},
   {"./validate-symbol":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/validate-symbol.js","d":"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/validate-symbol.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-symbol/validate-symbol.js"][0].apply(exports,arguments)
},
   {"./is-symbol":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/is-symbol.js"}],

"/node_modules/escope/node_modules/es6-weak-map/polyfill.js": [function(require,module,exports){
'use strict';

var setPrototypeOf    = require('es5-ext/object/set-prototype-of')
  , object            = require('es5-ext/object/valid-object')
  , value             = require('es5-ext/object/valid-value')
  , randomUniq        = require('es5-ext/string/random-uniq')
  , d                 = require('d')
  , getIterator       = require('es6-iterator/get')
  , forOf             = require('es6-iterator/for-of')
  , toStringTagSymbol = require('es6-symbol').toStringTag
  , isNative          = require('./is-native-implemented')

  , isArray = Array.isArray, defineProperty = Object.defineProperty
  , hasOwnProperty = Object.prototype.hasOwnProperty, getPrototypeOf = Object.getPrototypeOf
  , WeakMapPoly;

module.exports = WeakMapPoly = function (/*iterable*/) {
	var iterable = arguments[0], self;
	if (!(this instanceof WeakMapPoly)) throw new TypeError('Constructor requires \'new\'');
	if (isNative && setPrototypeOf && (WeakMap !== WeakMapPoly)) {
		self = setPrototypeOf(new WeakMap(), getPrototypeOf(this));
	} else {
		self = this;
	}
	if (iterable != null) {
		if (!isArray(iterable)) iterable = getIterator(iterable);
	}
	defineProperty(self, '__weakMapData__', d('c', '$weakMap$' + randomUniq()));
	if (!iterable) return self;
	forOf(iterable, function (val) {
		value(val);
		self.set(val[0], val[1]);
	});
	return self;
};

if (isNative) {
	if (setPrototypeOf) setPrototypeOf(WeakMapPoly, WeakMap);
	WeakMapPoly.prototype = Object.create(WeakMap.prototype, {
		constructor: d(WeakMapPoly)
	});
}

Object.defineProperties(WeakMapPoly.prototype, {
	delete: d(function (key) {
		if (hasOwnProperty.call(object(key), this.__weakMapData__)) {
			delete key[this.__weakMapData__];
			return true;
		}
		return false;
	}),
	get: d(function (key) {
		if (hasOwnProperty.call(object(key), this.__weakMapData__)) {
			return key[this.__weakMapData__];
		}
	}),
	has: d(function (key) {
		return hasOwnProperty.call(object(key), this.__weakMapData__);
	}),
	set: d(function (key, value) {
		defineProperty(object(key), this.__weakMapData__, d('c', value));
		return this;
	}),
	toString: d(function () { return '[object WeakMap]'; })
});
defineProperty(WeakMapPoly.prototype, toStringTagSymbol, d('c', 'WeakMap'));

},
   {"./is-native-implemented":"/node_modules/escope/node_modules/es6-weak-map/is-native-implemented.js","d":"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/index.js","es5-ext/object/set-prototype-of":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/index.js","es5-ext/object/valid-object":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-object.js","es5-ext/object/valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js","es5-ext/string/random-uniq":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/random-uniq.js","es6-iterator/for-of":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/for-of.js","es6-iterator/get":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/get.js","es6-symbol":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/index.js"}],

"/node_modules/escope/node_modules/esrecurse/esrecurse.js": [function(require,module,exports){
(function () {
    'use strict';

    var assign,
        estraverse,
        isArray,
        objectKeys;

    assign = require('object-assign');
    estraverse = require('estraverse');

    isArray = Array.isArray || function isArray(array) {
        return Object.prototype.toString.call(array) === '[object Array]';
    };

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === estraverse.Syntax.ObjectExpression || nodeType === estraverse.Syntax.ObjectPattern) && key === 'properties';
    }

    function Visitor(visitor, options) {
        options = options || {};

        this.__visitor = visitor ||  this;
        this.__childVisitorKeys = options.childVisitorKeys
            ? assign({}, estraverse.VisitorKeys, options.childVisitorKeys)
            : estraverse.VisitorKeys;
        this.__fallback = options.fallback === 'iteration';
    }

    Visitor.prototype.visitChildren = function (node) {
        var type, children, i, iz, j, jz, child;

        if (node == null) {
            return;
        }

        type = node.type || estraverse.Syntax.Property;

        children = this.__childVisitorKeys[type];
        if (!children) {
            if (this.__fallback) {
                children = objectKeys(node);
            } else {
                throw new Error('Unknown node type ' + type + '.');
            }
        }

        for (i = 0, iz = children.length; i < iz; ++i) {
            child = node[children[i]];
            if (child) {
                if (isArray(child)) {
                    for (j = 0, jz = child.length; j < jz; ++j) {
                        if (child[j]) {
                            if (isNode(child[j]) || isProperty(type, children[i])) {
                                this.visit(child[j]);
                            }
                        }
                    }
                } else if (isNode(child)) {
                    this.visit(child);
                }
            }
        }
    };

    Visitor.prototype.visit = function (node) {
        var type;

        if (node == null) {
            return;
        }

        type = node.type || estraverse.Syntax.Property;
        if (this.__visitor[type]) {
            this.__visitor[type].call(this, node);
            return;
        }
        this.visitChildren(node);
    };

    exports.version = require('./package.json').version;
    exports.Visitor = Visitor;
    exports.visit = function (node, visitor, options) {
        var v = new Visitor(visitor, options);
        v.visit(node);
    };
}());

},
   {"./package.json":"/node_modules/escope/node_modules/esrecurse/package.json","estraverse":"/node_modules/estraverse/estraverse.js","object-assign":"/node_modules/object-assign/index.js"}],

"/node_modules/escope/node_modules/esrecurse/package.json": [function(require,module,exports){
module.exports={
  "name": "esrecurse",
  "description": "ECMAScript AST recursive visitor",
  "homepage": "https://github.com/estools/esrecurse",
  "main": "esrecurse.js",
  "version": "4.0.0",
  "engines": {
    "node": ">=0.10.0"
  },
  "maintainers": [
    {
      "name": "constellation",
      "email": "utatane.tea@gmail.com"
    },
    {
      "name": "michaelficarra",
      "email": "npm@michael.ficarra.me"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/estools/esrecurse.git"
  },
  "dependencies": {
    "estraverse": "~4.1.0",
    "object-assign": "^4.0.1"
  },
  "devDependencies": {
    "chai": "^3.3.0",
    "coffee-script": "^1.9.1",
    "esprima": "^2.1.0",
    "gulp": "^3.9.0",
    "gulp-bump": "^1.0.0",
    "gulp-eslint": "^1.0.0",
    "gulp-filter": "^3.0.1",
    "gulp-git": "^1.1.0",
    "gulp-mocha": "^2.1.3",
    "gulp-tag-version": "^1.2.1",
    "jsdoc": "^3.3.0-alpha10",
    "minimist": "^1.1.0"
  },
  "license": "BSD-2-Clause",
  "scripts": {
    "test": "gulp travis",
    "unit-test": "gulp test",
    "lint": "gulp lint"
  },
  "gitHead": "fc4b0d9b1e9ce493761e97af9a1afb5afd489f87",
  "bugs": {
    "url": "https://github.com/estools/esrecurse/issues"
  },
  "_id": "esrecurse@4.0.0",
  "_shasum": "c7b50295f9af5ff9a0073d139eb011476128e9e6",
  "_from": "esrecurse@>=4.0.0 <5.0.0",
  "_npmVersion": "2.14.4",
  "_nodeVersion": "4.1.1",
  "_npmUser": {
    "name": "constellation",
    "email": "utatane.tea@gmail.com"
  },
  "dist": {
    "shasum": "c7b50295f9af5ff9a0073d139eb011476128e9e6",
    "tarball": "http://registry.npmjs.org/esrecurse/-/esrecurse-4.0.0.tgz"
  },
  "_npmOperationalInternal": {
    "host": "packages-5-east.internal.npmjs.com",
    "tmp": "tmp/esrecurse-4.0.0.tgz_1454512903651_0.6128629888407886"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.0.0.tgz"
}

},
   {}],

"/node_modules/escope/package.json": [function(require,module,exports){
module.exports={
  "name": "escope",
  "description": "ECMAScript scope analyzer",
  "homepage": "http://github.com/estools/escope",
  "main": "lib/index.js",
  "version": "3.5.0",
  "engines": {
    "node": ">=0.4.0"
  },
  "maintainers": [
    {
      "name": "constellation",
      "email": "utatane.tea@gmail.com"
    },
    {
      "name": "michaelficarra",
      "email": "npm@michael.ficarra.me"
    },
    {
      "name": "nzakas",
      "email": "nicholas@nczconsulting.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/estools/escope.git"
  },
  "dependencies": {
    "es6-map": "^0.1.3",
    "es6-weak-map": "^2.0.1",
    "esrecurse": "^4.0.0",
    "estraverse": "^4.1.1"
  },
  "devDependencies": {
    "babel": "^6.3.26",
    "babel-preset-es2015": "^6.3.13",
    "babel-register": "^6.3.13",
    "browserify": "^13.0.0",
    "chai": "^3.4.1",
    "espree": "^3.1.1",
    "esprima": "^2.7.1",
    "gulp": "^3.9.0",
    "gulp-babel": "^6.1.1",
    "gulp-bump": "^1.0.0",
    "gulp-eslint": "^1.1.1",
    "gulp-espower": "^1.0.2",
    "gulp-filter": "^3.0.1",
    "gulp-git": "^1.6.1",
    "gulp-mocha": "^2.2.0",
    "gulp-plumber": "^1.0.1",
    "gulp-sourcemaps": "^1.6.0",
    "gulp-tag-version": "^1.3.0",
    "jsdoc": "^3.4.0",
    "lazypipe": "^1.0.1",
    "vinyl-source-stream": "^1.1.0"
  },
  "license": "BSD-2-Clause",
  "scripts": {
    "test": "gulp travis",
    "unit-test": "gulp test",
    "lint": "gulp lint",
    "jsdoc": "jsdoc src/*.js README.md"
  },
  "gitHead": "5b6a2ba88db85ec847c5d88ac9d771e36fb4b55a",
  "bugs": {
    "url": "https://github.com/estools/escope/issues"
  },
  "_id": "escope@3.5.0",
  "_shasum": "23724471bcb53b40ac810cf3face549fd32ab5f6",
  "_from": "escope@>=3.5.0 <4.0.0",
  "_npmVersion": "2.14.4",
  "_nodeVersion": "4.1.1",
  "_npmUser": {
    "name": "constellation",
    "email": "utatane.tea@gmail.com"
  },
  "dist": {
    "shasum": "23724471bcb53b40ac810cf3face549fd32ab5f6",
    "tarball": "http://registry.npmjs.org/escope/-/escope-3.5.0.tgz"
  },
  "_npmOperationalInternal": {
    "host": "packages-9-west.internal.npmjs.com",
    "tmp": "tmp/escope-3.5.0.tgz_1456758694258_0.07843037159182131"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/escope/-/escope-3.5.0.tgz"
}

},
   {}],

"/node_modules/eslint-plugin-react/index.js": [function(require,module,exports){
'use strict';

module.exports = {
  rules: {
    'jsx-uses-react': require('./lib/rules/jsx-uses-react'),
    'no-multi-comp': require('./lib/rules/no-multi-comp'),
    'prop-types': require('./lib/rules/prop-types'),
    'display-name': require('./lib/rules/display-name'),
    'wrap-multilines': require('./lib/rules/wrap-multilines'),
    'self-closing-comp': require('./lib/rules/self-closing-comp'),
    'no-danger': require('./lib/rules/no-danger'),
    'no-set-state': require('./lib/rules/no-set-state'),
    'no-is-mounted': require('./lib/rules/no-is-mounted'),
    'no-deprecated': require('./lib/rules/no-deprecated'),
    'no-did-mount-set-state': require('./lib/rules/no-did-mount-set-state'),
    'no-did-update-set-state': require('./lib/rules/no-did-update-set-state'),
    'react-in-jsx-scope': require('./lib/rules/react-in-jsx-scope'),
    'jsx-uses-vars': require('./lib/rules/jsx-uses-vars'),
    'jsx-handler-names': require('./lib/rules/jsx-handler-names'),
    'jsx-pascal-case': require('./lib/rules/jsx-pascal-case'),
    'jsx-no-bind': require('./lib/rules/jsx-no-bind'),
    'jsx-no-undef': require('./lib/rules/jsx-no-undef'),
    'jsx-quotes': require('./lib/rules/jsx-quotes'),
    'no-unknown-property': require('./lib/rules/no-unknown-property'),
    'jsx-curly-spacing': require('./lib/rules/jsx-curly-spacing'),
    'jsx-equals-spacing': require('./lib/rules/jsx-equals-spacing'),
    'jsx-sort-props': require('./lib/rules/jsx-sort-props'),
    'jsx-sort-prop-types': require('./lib/rules/jsx-sort-prop-types'),
    'sort-prop-types': require('./lib/rules/jsx-sort-prop-types'),
    'jsx-boolean-value': require('./lib/rules/jsx-boolean-value'),
    'sort-comp': require('./lib/rules/sort-comp'),
    'require-extension': require('./lib/rules/require-extension'),
    'jsx-no-duplicate-props': require('./lib/rules/jsx-no-duplicate-props'),
    'jsx-max-props-per-line': require('./lib/rules/jsx-max-props-per-line'),
    'jsx-no-literals': require('./lib/rules/jsx-no-literals'),
    'jsx-indent-props': require('./lib/rules/jsx-indent-props'),
    'jsx-indent': require('./lib/rules/jsx-indent'),
    'jsx-closing-bracket-location': require('./lib/rules/jsx-closing-bracket-location'),
    'no-direct-mutation-state': require('./lib/rules/no-direct-mutation-state'),
    'forbid-prop-types': require('./lib/rules/forbid-prop-types'),
    'prefer-es6-class': require('./lib/rules/prefer-es6-class'),
    'jsx-key': require('./lib/rules/jsx-key'),
    'no-string-refs': require('./lib/rules/no-string-refs')
  },
  rulesConfig: {
    'jsx-uses-react': 0,
    'no-multi-comp': 0,
    'prop-types': 0,
    'display-name': 0,
    'wrap-multilines': 0,
    'self-closing-comp': 0,
    'no-deprecated': 0,
    'no-danger': 0,
    'no-set-state': 0,
    'no-is-mounted': 0,
    'no-did-mount-set-state': 0,
    'no-did-update-set-state': 0,
    'react-in-jsx-scope': 0,
    'jsx-uses-vars': 1,
    'jsx-handler-names': 0,
    'jsx-pascal-case': 0,
    'jsx-no-bind': 0,
    'jsx-no-undef': 0,
    'jsx-quotes': 0,
    'no-unknown-property': 0,
    'jsx-curly-spacing': 0,
    'jsx-equals-spacing': 0,
    'jsx-sort-props': 0,
    'jsx-sort-prop-types': 0,
    'jsx-boolean-value': 0,
    'sort-comp': 0,
    'require-extension': 0,
    'jsx-no-duplicate-props': 0,
    'jsx-max-props-per-line': 0,
    'jsx-no-literals': 0,
    'jsx-indent-props': 0,
    'jsx-indent': 0,
    'jsx-closing-bracket-location': 0,
    'no-direct-mutation-state': 0,
    'forbid-prop-types': 0,
    'prefer-es6-class': 0,
    'jsx-key': 0,
    'no-string-refs': 0
  }
};

},
   {"./lib/rules/display-name":"/node_modules/eslint-plugin-react/lib/rules/display-name.js","./lib/rules/forbid-prop-types":"/node_modules/eslint-plugin-react/lib/rules/forbid-prop-types.js","./lib/rules/jsx-boolean-value":"/node_modules/eslint-plugin-react/lib/rules/jsx-boolean-value.js","./lib/rules/jsx-closing-bracket-location":"/node_modules/eslint-plugin-react/lib/rules/jsx-closing-bracket-location.js","./lib/rules/jsx-curly-spacing":"/node_modules/eslint-plugin-react/lib/rules/jsx-curly-spacing.js","./lib/rules/jsx-equals-spacing":"/node_modules/eslint-plugin-react/lib/rules/jsx-equals-spacing.js","./lib/rules/jsx-handler-names":"/node_modules/eslint-plugin-react/lib/rules/jsx-handler-names.js","./lib/rules/jsx-indent":"/node_modules/eslint-plugin-react/lib/rules/jsx-indent.js","./lib/rules/jsx-indent-props":"/node_modules/eslint-plugin-react/lib/rules/jsx-indent-props.js","./lib/rules/jsx-key":"/node_modules/eslint-plugin-react/lib/rules/jsx-key.js","./lib/rules/jsx-max-props-per-line":"/node_modules/eslint-plugin-react/lib/rules/jsx-max-props-per-line.js","./lib/rules/jsx-no-bind":"/node_modules/eslint-plugin-react/lib/rules/jsx-no-bind.js","./lib/rules/jsx-no-duplicate-props":"/node_modules/eslint-plugin-react/lib/rules/jsx-no-duplicate-props.js","./lib/rules/jsx-no-literals":"/node_modules/eslint-plugin-react/lib/rules/jsx-no-literals.js","./lib/rules/jsx-no-undef":"/node_modules/eslint-plugin-react/lib/rules/jsx-no-undef.js","./lib/rules/jsx-pascal-case":"/node_modules/eslint-plugin-react/lib/rules/jsx-pascal-case.js","./lib/rules/jsx-quotes":"/node_modules/eslint-plugin-react/lib/rules/jsx-quotes.js","./lib/rules/jsx-sort-prop-types":"/node_modules/eslint-plugin-react/lib/rules/jsx-sort-prop-types.js","./lib/rules/jsx-sort-props":"/node_modules/eslint-plugin-react/lib/rules/jsx-sort-props.js","./lib/rules/jsx-uses-react":"/node_modules/eslint-plugin-react/lib/rules/jsx-uses-react.js","./lib/rules/jsx-uses-vars":"/node_modules/eslint-plugin-react/lib/rules/jsx-uses-vars.js","./lib/rules/no-danger":"/node_modules/eslint-plugin-react/lib/rules/no-danger.js","./lib/rules/no-deprecated":"/node_modules/eslint-plugin-react/lib/rules/no-deprecated.js","./lib/rules/no-did-mount-set-state":"/node_modules/eslint-plugin-react/lib/rules/no-did-mount-set-state.js","./lib/rules/no-did-update-set-state":"/node_modules/eslint-plugin-react/lib/rules/no-did-update-set-state.js","./lib/rules/no-direct-mutation-state":"/node_modules/eslint-plugin-react/lib/rules/no-direct-mutation-state.js","./lib/rules/no-is-mounted":"/node_modules/eslint-plugin-react/lib/rules/no-is-mounted.js","./lib/rules/no-multi-comp":"/node_modules/eslint-plugin-react/lib/rules/no-multi-comp.js","./lib/rules/no-set-state":"/node_modules/eslint-plugin-react/lib/rules/no-set-state.js","./lib/rules/no-string-refs":"/node_modules/eslint-plugin-react/lib/rules/no-string-refs.js","./lib/rules/no-unknown-property":"/node_modules/eslint-plugin-react/lib/rules/no-unknown-property.js","./lib/rules/prefer-es6-class":"/node_modules/eslint-plugin-react/lib/rules/prefer-es6-class.js","./lib/rules/prop-types":"/node_modules/eslint-plugin-react/lib/rules/prop-types.js","./lib/rules/react-in-jsx-scope":"/node_modules/eslint-plugin-react/lib/rules/react-in-jsx-scope.js","./lib/rules/require-extension":"/node_modules/eslint-plugin-react/lib/rules/require-extension.js","./lib/rules/self-closing-comp":"/node_modules/eslint-plugin-react/lib/rules/self-closing-comp.js","./lib/rules/sort-comp":"/node_modules/eslint-plugin-react/lib/rules/sort-comp.js","./lib/rules/wrap-multilines":"/node_modules/eslint-plugin-react/lib/rules/wrap-multilines.js"}],

"/node_modules/eslint-plugin-react/lib/rules/display-name.js": [function(require,module,exports){
'use strict';

var Components = require('../util/Components');

module.exports = Components.detect(function(context, components, utils) {

  var config = context.options[0] || {};
  var acceptTranspilerName = config.acceptTranspilerName || false;

  var MISSING_MESSAGE = 'Component definition is missing display name';

  function isDisplayNameDeclaration(node) {
    if (node.type === /*ClassProperty*/'Property' && node.kind == 'class') {
      var tokens = context.getFirstTokens(node, 2);
      if (
        tokens[0].value === 'displayName' ||
        (tokens[1] && tokens[1].value === 'displayName')
      ) {
        return true;
      }
      return false;
    }

    return Boolean(
      node &&
      node.name === 'displayName'
    );
  }

  function markDisplayNameAsDeclared(node) {
    components.set(node, {
      hasDisplayName: true
    });
  }

  function reportMissingDisplayName(component) {
    context.report(
      component.node,
      MISSING_MESSAGE, {
        component: component.name
      }
    );
  }

  function hasTranspilerName(node) {
    var namedObjectAssignment = (
      node.type === 'ObjectExpression' &&
      node.parent &&
      node.parent.parent &&
      node.parent.parent.type === 'AssignmentExpression' && (
        !node.parent.parent.left.object ||
        node.parent.parent.left.object.name !== 'module' ||
        node.parent.parent.left.property.name !== 'exports'
      )
    );
    var namedObjectDeclaration = (
        node.type === 'ObjectExpression' &&
        node.parent &&
        node.parent.parent &&
        node.parent.parent.type === 'VariableDeclarator'
    );
    var namedClass = (
      node.type === 'ClassDeclaration' &&
      node.id && node.id.name
    );

    var namedFunctionDeclaration = (
      (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') &&
      node.id &&
      node.id.name
    );

    var namedFunctionExpression = (
      (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') &&
      node.parent &&
      (node.parent.type === 'VariableDeclarator' || node.parent.method === true)
    );

    if (
      namedObjectAssignment || namedObjectDeclaration ||
      namedClass ||
      namedFunctionDeclaration || namedFunctionExpression
    ) {
      return true;
    }
    return false;
  }

  return {
Property: function(node) {
      if (node.kind == 'class' && !isDisplayNameDeclaration(node)) {
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    MemberExpression: function(node) {
      if (!isDisplayNameDeclaration(node.property)) {
        return;
      }
      var component = utils.getRelatedComponent(node);
      if (!component) {
        return;
      }
      markDisplayNameAsDeclared(component.node);
    },

    FunctionExpression: function(node) {
      if (!acceptTranspilerName || !hasTranspilerName(node)) {
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    FunctionDeclaration: function(node) {
      if (!acceptTranspilerName || !hasTranspilerName(node)) {
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    ArrowFunctionExpression: function(node) {
      if (!acceptTranspilerName || !hasTranspilerName(node)) {
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    MethodDefinition: function(node) {
      if (!isDisplayNameDeclaration(node.key)) {
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    ClassDeclaration: function(node) {
      if (!acceptTranspilerName || !hasTranspilerName(node)) {
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    ObjectExpression: function(node) {
      if (!acceptTranspilerName || !hasTranspilerName(node)) {
        node.properties.forEach(function(property) {
          if (!property.key || !isDisplayNameDeclaration(property.key)) {
            return;
          }
          markDisplayNameAsDeclared(node);
        });
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    'Program:exit': function() {
      var list = components.list();
      for (var component in list) {
        if (!list.hasOwnProperty(component) || list[component].hasDisplayName) {
          continue;
        }
        reportMissingDisplayName(list[component]);
      }
    }
  };
});

module.exports.schema = [{
  type: 'object',
  properties: {
    acceptTranspilerName: {
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js"}],

"/node_modules/eslint-plugin-react/lib/rules/forbid-prop-types.js": [function(require,module,exports){
'use strict';

var DEFAULTS = ['any', 'array', 'object'];

module.exports = function(context) {

  function isForbidden(type) {
    var configuration = context.options[0] || {};

    var forbid = configuration.forbid || DEFAULTS;
    return forbid.indexOf(type) >= 0;
  }

  function isPropTypesDeclaration(node) {

    if (node.type === /*ClassProperty*/'Property' && node.kind == 'class') {
      var tokens = context.getFirstTokens(node, 2);
      if (tokens[0].value === 'propTypes' || (tokens[1] && tokens[1].value === 'propTypes')) {
        return true;
      }
      return false;
    }

    return Boolean(
      node &&
      node.name === 'propTypes'
    );
  }


  function checkForbidden(declarations) {
    declarations.forEach(function(declaration) {
      var target;
      var value = declaration.value;
      if (
        value.type === 'MemberExpression' &&
        value.property &&
        value.property.name &&
        value.property.name === 'isRequired'
      ) {
        value = value.object;
      }
      if (
        value.type === 'CallExpression' &&
        value.callee.type === 'MemberExpression'
      ) {
        value = value.callee;
      }
      if (value.property) {
        target = value.property.name;
      } else if (value.type === 'Identifier') {
        target = value.name;
      }
      if (isForbidden(target)) {
        context.report(declaration, 'Prop type `' + target + '` is forbidden');
      }
    });
  }

  return {
Property: function(node) {
      if (node.kind == 'class' && isPropTypesDeclaration(node) && node.value && node.value.type === 'ObjectExpression') {
        checkForbidden(node.value.properties);
      }
    },

    MemberExpression: function(node) {
      if (isPropTypesDeclaration(node.property)) {
        var right = node.parent.right;
        if (right && right.type === 'ObjectExpression') {
          checkForbidden(right.properties);
        }
      }
    },

    ObjectExpression: function(node) {
      node.properties.forEach(function(property) {
        if (!property.key) {
          return;
        }

        if (!isPropTypesDeclaration(property.key)) {
          return;
        }
        if (property.value.type === 'ObjectExpression') {
          checkForbidden(property.value.properties);
        }
      });
    }

  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    forbid: {
      type: 'array',
      items: {
        type: 'string'
      }
    }
  },
  additionalProperties: true
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-boolean-value.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var configuration = context.options[0] || 'never';

  var NEVER_MESSAGE = 'Value must be omitted for boolean attributes';
  var ALWAYS_MESSAGE = 'Value must be set for boolean attributes';

  return {
    JSXAttribute: function(node) {
      switch (configuration) {
        case 'always':
          if (node.value === null) {
            context.report({
              node: node,
              message: ALWAYS_MESSAGE,
              fix: function(fixer) {
                return fixer.insertTextAfter(node, '={true}');
              }
            });
          }
          break;
        case 'never':
          if (node.value && node.value.type === 'JSXExpressionContainer' && node.value.expression.value === true) {
            context.report({
              node: node,
              message: NEVER_MESSAGE,
              fix: function(fixer) {
                return fixer.removeRange([node.name.range[1], node.value.range[1]]);
              }
            });
          }
          break;
        default:
          break;
      }
    }
  };
};

module.exports.schema = [{
  enum: ['always', 'never']
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-closing-bracket-location.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var MESSAGE = 'The closing bracket must be {{location}}{{details}}';
  var MESSAGE_LOCATION = {
    'after-props': 'placed after the last prop',
    'after-tag': 'placed after the opening tag',
    'props-aligned': 'aligned with the last prop',
    'tag-aligned': 'aligned with the opening tag',
    'line-aligned': 'aligned with the line containing the opening tag'
  };
  var DEFAULT_LOCATION = 'tag-aligned';

  var config = context.options[0];
  var options = {
    nonEmpty: DEFAULT_LOCATION,
    selfClosing: DEFAULT_LOCATION
  };

  if (typeof config === 'string') {
    options.nonEmpty = config;
    options.selfClosing = config;
  } else if (typeof config === 'object') {
    if (config.hasOwnProperty('location')) {
      options.nonEmpty = config.location;
      options.selfClosing = config.location;
    }
    if (config.hasOwnProperty('nonEmpty')) {
      options.nonEmpty = config.nonEmpty;
    }
    if (config.hasOwnProperty('selfClosing')) {
      options.selfClosing = config.selfClosing;
    }
  }

  function getExpectedLocation(tokens) {
    var location;
    if (typeof tokens.lastProp === 'undefined') {
      location = 'after-tag';
    } else if (tokens.opening.line === tokens.lastProp.line) {
      location = 'after-props';
    } else {
      location = tokens.selfClosing ? options.selfClosing : options.nonEmpty;
    }
    return location;
  }

  function getCorrectColumn(tokens, expectedLocation) {
    switch (expectedLocation) {
      case 'props-aligned':
        return tokens.lastProp.column;
      case 'tag-aligned':
        return tokens.opening.column;
      case 'line-aligned':
        return tokens.openingStartOfLine.column;
      default:
        return null;
    }
  }

  function hasCorrectLocation(tokens, expectedLocation) {
    switch (expectedLocation) {
      case 'after-tag':
        return tokens.tag.line === tokens.closing.line;
      case 'after-props':
        return tokens.lastProp.line === tokens.closing.line;
      case 'props-aligned':
      case 'tag-aligned':
      case 'line-aligned':
        var correctColumn = getCorrectColumn(tokens, expectedLocation);
        return correctColumn === tokens.closing.column;
      default:
        return true;
    }
  }

  function getTokensLocations(node) {
    var opening = context.getFirstToken(node).loc.start;
    var closing = context.getLastTokens(node, node.selfClosing ? 2 : 1)[0].loc.start;
    var tag = context.getFirstToken(node.name).loc.start;
    var lastProp;
    if (node.attributes.length) {
      lastProp = node.attributes[node.attributes.length - 1];
      lastProp = {
        column: context.getFirstToken(lastProp).loc.start.column,
        line: context.getLastToken(lastProp).loc.end.line
      };
    }
    var openingLine = context.getSourceCode().lines[opening.line - 1];
    var openingStartOfLine = {
      column: /^\s*/.exec(openingLine)[0].length,
      line: opening.line
    };
    return {
      tag: tag,
      opening: opening,
      closing: closing,
      lastProp: lastProp,
      selfClosing: node.selfClosing,
      openingStartOfLine: openingStartOfLine
    };
  }

  return {
    JSXOpeningElement: function(node) {
      var tokens = getTokensLocations(node);
      var expectedLocation = getExpectedLocation(tokens);
      if (hasCorrectLocation(tokens, expectedLocation)) {
        return;
      }

      var data = {location: MESSAGE_LOCATION[expectedLocation], details: ''};
      var correctColumn = getCorrectColumn(tokens, expectedLocation);

      if (correctColumn !== null) {
        var expectedNextLine = tokens.lastProp &&
          (tokens.lastProp.line === tokens.closing.line);
        data.details = ' (expected column ' + (correctColumn + 1) +
          (expectedNextLine ? ' on the next line)' : ')');
      }

      context.report({
        node: node,
        loc: tokens.closing,
        message: MESSAGE,
        data: data
      });
    }
  };

};

module.exports.schema = [{
  oneOf: [
    {
      enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']
    },
    {
      type: 'object',
      properties: {
        location: {
          enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']
        }
      },
      additionalProperties: false
    }, {
      type: 'object',
      properties: {
        nonEmpty: {
          enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]
        },
        selfClosing: {
          enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]
        }
      },
      additionalProperties: false
    }
  ]
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-curly-spacing.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {
  var spaced = context.options[0] === 'always';
  var multiline = context.options[1] ? context.options[1].allowMultiline : true;

  function isMultiline(left, right) {
    return left.loc.start.line !== right.loc.start.line;
  }

  function isSpaced(left, right) {
    return left.range[1] < right.range[0];
  }

  function reportNoBeginningNewline(node, token) {
    context.report({
      node: node,
      loc: token.loc.start,
      message: 'There should be no newline after \'' + token.value + '\'',
      fix: function(fixer) {
        var nextToken = context.getSourceCode().getTokenAfter(token);
        return fixer.replaceTextRange([token.range[1], nextToken.range[0]], spaced ? ' ' : '');
      }
    });
  }

  function reportNoEndingNewline(node, token) {
    context.report({
      node: node,
      loc: token.loc.start,
      message: 'There should be no newline before \'' + token.value + '\'',
      fix: function(fixer) {
        var previousToken = context.getSourceCode().getTokenBefore(token);
        return fixer.replaceTextRange([previousToken.range[1], token.range[0]], spaced ? ' ' : '');
      }
    });
  }

  function reportNoBeginningSpace(node, token) {
    context.report({
      node: node,
      loc: token.loc.start,
      message: 'There should be no space after \'' + token.value + '\'',
      fix: function(fixer) {
        var nextToken = context.getSourceCode().getTokenAfter(token);
        return fixer.removeRange([token.range[1], nextToken.range[0]]);
      }
    });
  }

  function reportNoEndingSpace(node, token) {
    context.report({
      node: node,
      loc: token.loc.start,
      message: 'There should be no space before \'' + token.value + '\'',
      fix: function(fixer) {
        var previousToken = context.getSourceCode().getTokenBefore(token);
        return fixer.removeRange([previousToken.range[1], token.range[0]]);
      }
    });
  }

  function reportRequiredBeginningSpace(node, token) {
    context.report({
      node: node,
      loc: token.loc.start,
      message: 'A space is required after \'' + token.value + '\'',
      fix: function(fixer) {
        return fixer.insertTextAfter(token, ' ');
      }
    });
  }

  function reportRequiredEndingSpace(node, token) {
    context.report({
      node: node,
      loc: token.loc.start,
      message: 'A space is required before \'' + token.value + '\'',
      fix: function(fixer) {
        return fixer.insertTextBefore(token, ' ');
      }
    });
  }

  function validateBraceSpacing(node, first, second, penultimate, last) {
    if (spaced) {
      if (!isSpaced(first, second)) {
        reportRequiredBeginningSpace(node, first);
      } else if (!multiline && isMultiline(first, second)) {
        reportNoBeginningNewline(node, first);
      }

      if (!isSpaced(penultimate, last)) {
        reportRequiredEndingSpace(node, last);
      } else if (!multiline && isMultiline(penultimate, last)) {
        reportNoEndingNewline(node, last);
      }

      return;
    }

    if (isSpaced(first, second) && !(multiline && isMultiline(first, second))) {
      reportNoBeginningSpace(node, first);
    }

    if (isSpaced(penultimate, last) && !(multiline && isMultiline(penultimate, last))) {
      reportNoEndingSpace(node, last);
    }
  }

  return {
    JSXExpressionContainer: function(node) {
      var first = context.getFirstToken(node);
      var second = context.getFirstToken(node, 1);
      var penultimate = context.getLastToken(node, 1);
      var last = context.getLastToken(node);

      if (first === penultimate && second === last) {
        return;
      }

      validateBraceSpacing(node, first, second, penultimate, last);
    }
  };
};

module.exports.schema = [{
  enum: ['always', 'never']
}, {
  type: 'object',
  properties: {
    allowMultiline: {
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-equals-spacing.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {
  var config = context.options[0];
  var sourceCode = context.getSourceCode();

  function hasEqual(attrNode) {
    return attrNode.type !== 'JSXSpreadAttribute' && attrNode.value !== null;
  }

  return {
    JSXOpeningElement: function(node) {
      node.attributes.forEach(function(attrNode) {
        if (!hasEqual(attrNode)) {
          return;
        }

        var equalToken = sourceCode.getTokenAfter(attrNode.name);
        var spacedBefore = sourceCode.isSpaceBetweenTokens(attrNode.name, equalToken);
        var spacedAfter = sourceCode.isSpaceBetweenTokens(equalToken, attrNode.value);

        switch (config) {
          default:
          case 'never':
            if (spacedBefore) {
              context.report(attrNode, equalToken.loc.start,
                'There should be no space before \'=\'');
            }
            if (spacedAfter) {
              context.report(attrNode, equalToken.loc.start,
                'There should be no space after \'=\'');
            }
            break;
          case 'always':
            if (!spacedBefore) {
              context.report(attrNode, equalToken.loc.start,
                'A space is required before \'=\'');
            }
            if (!spacedAfter) {
              context.report(attrNode, equalToken.loc.start,
                'A space is required after \'=\'');
            }
            break;
        }
      });
    }
  };
};

module.exports.schema = [{
  enum: ['always', 'never']
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-handler-names.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var configuration = context.options[0] || {};
  var eventHandlerPrefix = configuration.eventHandlerPrefix || 'handle';
  var eventHandlerPropPrefix = configuration.eventHandlerPropPrefix || 'on';

  var EVENT_HANDLER_REGEX = new RegExp('^((props\.' + eventHandlerPropPrefix + ')'
                                       + '|((.*\.)?' + eventHandlerPrefix + ')).+$');
  var PROP_EVENT_HANDLER_REGEX = new RegExp('^(' + eventHandlerPropPrefix + '.+|ref)$');

  return {
    JSXAttribute: function(node) {
      if (!node.value || !node.value.expression || !node.value.expression.object) {
        return;
      }

      var propKey = typeof node.name === 'object' ? node.name.name : node.name;
      var propValue = context.getSource(node.value.expression).replace(/^this\./, '');

      if (propKey === 'ref') {
        return;
      }

      var propIsEventHandler = PROP_EVENT_HANDLER_REGEX.test(propKey);
      var propFnIsNamedCorrectly = EVENT_HANDLER_REGEX.test(propValue);

      if (propIsEventHandler && !propFnIsNamedCorrectly) {
        context.report(
          node,
          'Handler function for ' + propKey + ' prop key must begin with \'' + eventHandlerPrefix + '\''
        );
      } else if (propFnIsNamedCorrectly && !propIsEventHandler) {
        context.report(
          node,
          'Prop key for ' + propValue + ' must begin with \'' + eventHandlerPropPrefix + '\''
        );
      }
    }
  };

};

module.exports.schema = [{
  type: 'object',
  properties: {
    eventHandlerPrefix: {
      type: 'string'
    },
    eventHandlerPropPrefix: {
      type: 'string'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-indent-props.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var MESSAGE = 'Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.';

  var extraColumnStart = 0;
  var indentType = 'space';
  var indentSize = 4;

  if (context.options.length) {
    if (context.options[0] === 'tab') {
      indentSize = 1;
      indentType = 'tab';
    } else if (typeof context.options[0] === 'number') {
      indentSize = context.options[0];
      indentType = 'space';
    }
  }

  function report(node, needed, gotten, loc) {
    var msgContext = {
      needed: needed,
      type: indentType,
      characters: needed === 1 ? 'character' : 'characters',
      gotten: gotten
    };

    if (loc) {
      context.report(node, loc, MESSAGE, msgContext);
    } else {
      context.report(node, MESSAGE, msgContext);
    }
  }

  function getNodeIndent(node, byLastLine, excludeCommas) {
    byLastLine = byLastLine || false;
    excludeCommas = excludeCommas || false;

    var src = context.getSource(node, node.loc.start.column + extraColumnStart);
    var lines = src.split('\n');
    if (byLastLine) {
      src = lines[lines.length - 1];
    } else {
      src = lines[0];
    }

    var skip = excludeCommas ? ',' : '';

    var regExp;
    if (indentType === 'space') {
      regExp = new RegExp('^[ ' + skip + ']+');
    } else {
      regExp = new RegExp('^[\t' + skip + ']+');
    }

    var indent = regExp.exec(src);
    return indent ? indent[0].length : 0;
  }

  function isNodeFirstInLine(node, byEndLocation) {
    var firstToken = byEndLocation === true ? context.getLastToken(node, 1) : context.getTokenBefore(node);
    var startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line;
    var endLine = firstToken ? firstToken.loc.end.line : -1;

    return startLine !== endLine;
  }

  function checkNodesIndent(nodes, indent, excludeCommas) {
    nodes.forEach(function(node) {
      var nodeIndent = getNodeIndent(node, false, excludeCommas);
      if (
        node.type !== 'ArrayExpression' && node.type !== 'ObjectExpression' &&
        nodeIndent !== indent && isNodeFirstInLine(node)
      ) {
        report(node, indent, nodeIndent);
      }
    });
  }

  return {
    JSXOpeningElement: function(node) {
      var elementIndent = getNodeIndent(node);
      checkNodesIndent(node.attributes, elementIndent + indentSize);
    }
  };

};

module.exports.schema = [{
  oneOf: [{
    enum: ['tab']
  }, {
    type: 'integer'
  }]
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-indent.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var MESSAGE = 'Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.';

  var extraColumnStart = 0;
  var indentType = 'space';
  var indentSize = 4;

  if (context.options.length) {
    if (context.options[0] === 'tab') {
      indentSize = 1;
      indentType = 'tab';
    } else if (typeof context.options[0] === 'number') {
      indentSize = context.options[0];
      indentType = 'space';
    }
  }

  function report(node, needed, gotten, loc) {
    var msgContext = {
      needed: needed,
      type: indentType,
      characters: needed === 1 ? 'character' : 'characters',
      gotten: gotten
    };

    if (loc) {
      context.report(node, loc, MESSAGE, msgContext);
    } else {
      context.report(node, MESSAGE, msgContext);
    }
  }

  function getNodeIndent(node, byLastLine, excludeCommas) {
    byLastLine = byLastLine || false;
    excludeCommas = excludeCommas || false;

    var src = context.getSource(node, node.loc.start.column + extraColumnStart);
    var lines = src.split('\n');
    if (byLastLine) {
      src = lines[lines.length - 1];
    } else {
      src = lines[0];
    }

    var skip = excludeCommas ? ',' : '';

    var regExp;
    if (indentType === 'space') {
      regExp = new RegExp('^[ ' + skip + ']+');
    } else {
      regExp = new RegExp('^[\t' + skip + ']+');
    }

    var indent = regExp.exec(src);
    return indent ? indent[0].length : 0;
  }

  function isNodeFirstInLine(node) {
    var token = node;
    do {
      token = context.getTokenBefore(token);
    } while (token.type === 'JSXText');
    var startLine = node.loc.start.line;
    var endLine = token ? token.loc.end.line : -1;

    return startLine !== endLine;
  }

  function checkNodesIndent(node, indent, excludeCommas) {
    var nodeIndent = getNodeIndent(node, false, excludeCommas);
    if (nodeIndent !== indent && isNodeFirstInLine(node)) {
      report(node, indent, nodeIndent);
    }
  }

  return {
    JSXOpeningElement: function(node) {
      if (!node.parent || !node.parent.parent) {
        return;
      }
      var parentElementIndent = getNodeIndent(node.parent.parent);
      var indent = node.parent.parent.loc.start.line === node.loc.start.line ? 0 : indentSize;
      checkNodesIndent(node, parentElementIndent + indent);
    },
    JSXClosingElement: function(node) {
      if (!node.parent) {
        return;
      }
      var peerElementIndent = getNodeIndent(node.parent.openingElement);
      checkNodesIndent(node, peerElementIndent);
    }
  };

};

module.exports.schema = [{
  oneOf: [{
    enum: ['tab']
  }, {
    type: 'integer'
  }]
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-key.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  function hasKeyProp(node) {
    return node.openingElement.attributes.some(function(decl) {
      if (decl.type === 'JSXSpreadAttribute') {
        return false;
      }
      return (decl.name.name === 'key');
    });
  }

  function checkIteratorElement(node) {
    if (node.type === 'JSXElement' && !hasKeyProp(node)) {
      context.report(node, 'Missing "key" prop for element in iterator');
    }
  }

  function getReturnStatement(body) {
    return body.filter(function(item) {
      return item.type === 'ReturnStatement';
    })[0];
  }

  return {
    JSXElement: function(node) {
      if (hasKeyProp(node)) {
        return;
      }

      if (node.parent.type === 'ArrayExpression') {
        context.report(node, 'Missing "key" prop for element in array');
      }
    },

    CallExpression: function (node) {
      if (node.callee && node.callee.property && node.callee.property.name !== 'map') {
        return;
      }

      var fn = node.arguments[0];
      var isFn = fn && fn.type === 'FunctionExpression';
      var isArrFn = fn && fn.type === 'ArrowFunctionExpression';

      if (isArrFn && fn.body.type === 'JSXElement') {
        checkIteratorElement(fn.body);
      }

      if (isFn || isArrFn) {
        if (fn.body.type === 'BlockStatement') {
          var returnStatement = getReturnStatement(fn.body.body);
          if (returnStatement && returnStatement.argument) {
            checkIteratorElement(returnStatement.argument);
          }
        }
      }
    }
  };
};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-max-props-per-line.js": [function(require,module,exports){
'use strict';

module.exports = function (context) {

  var configuration = context.options[0] || {};
  var maximum = configuration.maximum || 1;

  function getPropName(propNode) {
    if (propNode.type === 'JSXSpreadAttribute') {
      return context.getSource(propNode.argument);
    }
    return propNode.name.name;
  }

  return {
    JSXOpeningElement: function (node) {
      var props = {};

      node.attributes.forEach(function(decl) {
        var line = decl.loc.start.line;
        if (props[line]) {
          props[line].push(decl);
        } else {
          props[line] = [decl];
        }
      });

      for (var line in props) {
        if (!props.hasOwnProperty(line)) {
          continue;
        }
        if (props[line].length > maximum) {
          var name = getPropName(props[line][maximum]);
          context.report(props[line][maximum], 'Prop `' + name + '` must be placed on a new line');
          break;
        }
      }
    }
  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    maximum: {
      type: 'integer',
      minimum: 1
    }
  }
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-no-bind.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {
  var configuration = context.options[0] || {};

  return {
    JSXAttribute: function(node) {
      var isRef = configuration.ignoreRefs && node.name.name === 'ref';
      if (isRef || !node.value || !node.value.expression) {
        return;
      }
      var valueNode = node.value.expression;
      if (
        !configuration.allowBind &&
        valueNode.type === 'CallExpression' &&
        valueNode.callee.type === 'MemberExpression' &&
        valueNode.callee.property.name === 'bind'
      ) {
        context.report(node, 'JSX props should not use .bind()');
      } else if (
        !configuration.allowArrowFunctions &&
        valueNode.type === 'ArrowFunctionExpression'
      ) {
        context.report(node, 'JSX props should not use arrow functions');
      }
    }
  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    allowArrowFunctions: {
      default: false,
      type: 'boolean'
    },
    allowBind: {
      default: false,
      type: 'boolean'
    },
    ignoreRefs: {
      default: false,
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-no-duplicate-props.js": [function(require,module,exports){
'use strict';

module.exports = function (context) {

  var configuration = context.options[0] || {};
  var ignoreCase = configuration.ignoreCase || false;

  return {
    JSXOpeningElement: function (node) {
      var props = {};

      node.attributes.forEach(function(decl) {
        if (decl.type === 'JSXSpreadAttribute') {
          return;
        }

        var name = decl.name.name;

        if (ignoreCase) {
          name = name.toLowerCase();
        }

        if (props.hasOwnProperty(name)) {
          context.report(decl, 'No duplicate props allowed');
        } else {
          props[name] = 1;
        }
      });
    }
  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    ignoreCase: {
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-no-literals.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  function reportLiteralNode(node) {
    context.report(node, 'Missing JSX expression container around literal string');
  }

  return {

    Literal: function(node) {
      if (
       !/^[\s]+$/.test(node.value) &&
        node.parent &&
        node.parent.type !== 'JSXExpressionContainer' &&
        node.parent.type !== 'JSXAttribute' &&
        node.parent.type.indexOf('JSX') !== -1
      ) {
        reportLiteralNode(node);
      }
    }

  };

};

module.exports.schema = [{
  type: 'object',
  properties: {},
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-no-undef.js": [function(require,module,exports){
'use strict';

var tagConvention = /^[a-z]|\-/;
function isTagName(name) {
  return tagConvention.test(name);
}

module.exports = function(context) {

  function checkIdentifierInJSX(node) {
    var scope = context.getScope();
    var variables = scope.variables;
    var i;
    var len;

    while (scope.type !== 'global') {
      scope = scope.upper;
      variables = scope.variables.concat(variables);
    }
    if (scope.childScopes.length) {
      variables = scope.childScopes[0].variables.concat(variables);
      if (scope.childScopes[0].childScopes.length) {
        variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
      }
    }

    for (i = 0, len = variables.length; i < len; i++) {
      if (variables[i].name === node.name) {
        return;
      }
    }

    context.report(node, '\'' + node.name + '\' is not defined.');
  }

  return {
    JSXOpeningElement: function(node) {
      switch (node.name.type) {
        case 'JSXIdentifier':
          node = node.name;
          break;
        case 'JSXMemberExpression':
          node = node.name.object;
          break;
        case 'JSXNamespacedName':
          node = node.name.namespace;
          break;
        default:
          break;
      }
      if (isTagName(node.name)) {
        return;
      }
      checkIdentifierInJSX(node);
    }
  };

};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-pascal-case.js": [function(require,module,exports){
'use strict';

var PASCAL_CASE_REGEX = /^[A-Z0-9]+[a-z0-9]+(?:[A-Z0-9]+[a-z0-9]*)*$/;
var COMPAT_TAG_REGEX = /^[a-z]|\-/;

module.exports = function(context) {

  return {
    JSXOpeningElement: function(node) {
      switch (node.name.type) {
        case 'JSXIdentifier':
          node = node.name;
          break;
        case 'JSXMemberExpression':
          node = node.name.object;
          break;
        case 'JSXNamespacedName':
          node = node.name.namespace;
          break;
        default:
          break;
      }

      var isPascalCase = PASCAL_CASE_REGEX.test(node.name);
      var isCompatTag = COMPAT_TAG_REGEX.test(node.name);

      if (!isPascalCase && !isCompatTag) {
        context.report(node, 'Imported JSX component ' + node.name + ' must be in PascalCase');
      }
    }
  };

};

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-quotes.js": [function(require,module,exports){
(function (process){
'use strict';

var QUOTE_SETTINGS = {
  double: {
    quote: '"',
    alternateQuote: '\'',
    description: 'doublequote'
  },
  single: {
    quote: '\'',
    alternateQuote: '"',
    description: 'singlequote'
  }
};

var AVOID_ESCAPE = 'avoid-escape';

var isWarnedForDeprecation = false;

module.exports = function(context) {

  function isSurroundedBy(val, character) {
    return val[0] === character && val[val.length - 1] === character;
  }

  return {

    Program: function() {
      if (isWarnedForDeprecation || /\=-(f|-format)=/.test(process.argv.join('='))) {
        return;
      }
      console.log('The react/jsx-quotes rule is deprecated. Please use the jsx-quotes rule instead.');
      isWarnedForDeprecation = true;
    },

    Literal: function(node) {

      if (node.parent.type !== 'JSXAttribute') {
        return;
      }
      var val = node.value;
      var rawVal = node.raw;
      var quoteOption = context.options[0];
      var settings = QUOTE_SETTINGS[quoteOption];
      var avoidEscape = context.options[1] === AVOID_ESCAPE;
      var isValid;

      if (settings && typeof val === 'string') {
        isValid = isSurroundedBy(rawVal, settings.quote);

        if (!isValid && avoidEscape) {
          isValid = isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
        }

        if (!isValid) {
          context.report(node, 'JSX attributes must use ' + settings.description + '.');
        }
      }
    }
  };

};

module.exports.schema = [{
  enum: ['single', 'double']
}, {
  enum: ['avoid-escape']
}];

}).call(this,require('_process'))
},
   {"_process":"/node_modules/browserify/node_modules/process/browser.js"}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-sort-prop-types.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var configuration = context.options[0] || {};
  var requiredFirst = configuration.requiredFirst || false;
  var callbacksLast = configuration.callbacksLast || false;
  var ignoreCase = configuration.ignoreCase || false;

  function isPropTypesDeclaration(node) {

    if (node.type === /*ClassProperty*/'Property' && node.kind == 'class') {
      var tokens = context.getFirstTokens(node, 2);
      return (tokens[0] && tokens[0].value === 'propTypes') ||
             (tokens[1] && tokens[1].value === 'propTypes');
    }

    return Boolean(
      node &&
      node.name === 'propTypes'
    );
  }

  function getKey(node) {
    return node.key.type === 'Identifier' ? node.key.name : node.key.value;
  }

  function getValueName(node) {
    return node.value.property && node.value.property.name;
  }

  function isCallbackPropName(propName) {
    return /^on[A-Z]/.test(propName);
  }

  function isRequiredProp(node) {
    return getValueName(node) === 'isRequired';
  }

  function checkSorted(declarations) {
    declarations.reduce(function(prev, curr) {
      var prevPropName = getKey(prev);
      var currentPropName = getKey(curr);
      var previousIsRequired = isRequiredProp(prev);
      var currentIsRequired = isRequiredProp(curr);
      var previousIsCallback = isCallbackPropName(prevPropName);
      var currentIsCallback = isCallbackPropName(currentPropName);

      if (ignoreCase) {
        prevPropName = prevPropName.toLowerCase();
        currentPropName = currentPropName.toLowerCase();
      }

      if (requiredFirst) {
        if (previousIsRequired && !currentIsRequired) {
          return curr;
        }
        if (!previousIsRequired && currentIsRequired) {
          context.report(curr, 'Required prop types must be listed before all other prop types');
          return curr;
        }
      }

      if (callbacksLast) {
        if (!previousIsCallback && currentIsCallback) {
          return curr;
        }
        if (previousIsCallback && !currentIsCallback) {
          context.report(prev, 'Callback prop types must be listed after all other prop types');
          return prev;
        }
      }

      if (currentPropName < prevPropName) {
        context.report(curr, 'Prop types declarations should be sorted alphabetically');
        return prev;
      }

      return curr;
    }, declarations[0]);
  }

  return {
Property: function(node) {
      if (node.kind == 'class' && isPropTypesDeclaration(node) && node.value && node.value.type === 'ObjectExpression') {
        checkSorted(node.value.properties);
      }
    },

    MemberExpression: function(node) {
      if (isPropTypesDeclaration(node.property)) {
        var right = node.parent.right;
        if (right && right.type === 'ObjectExpression') {
          checkSorted(right.properties);
        }
      }
    },

    ObjectExpression: function(node) {
      node.properties.forEach(function(property) {
        if (!property.key) {
          return;
        }

        if (!isPropTypesDeclaration(property.key)) {
          return;
        }
        if (property.value.type === 'ObjectExpression') {
          checkSorted(property.value.properties);
        }
      });
    }

  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    requiredFirst: {
      type: 'boolean'
    },
    callbacksLast: {
      type: 'boolean'
    },
    ignoreCase: {
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-sort-props.js": [function(require,module,exports){
'use strict';

function isCallbackPropName(propName) {
  return /^on[A-Z]/.test(propName);
}

module.exports = function(context) {

  var configuration = context.options[0] || {};
  var ignoreCase = configuration.ignoreCase || false;
  var callbacksLast = configuration.callbacksLast || false;
  var shorthandFirst = configuration.shorthandFirst || false;

  return {
    JSXOpeningElement: function(node) {
      node.attributes.reduce(function(memo, decl, idx, attrs) {
        if (decl.type === 'JSXSpreadAttribute') {
          return attrs[idx + 1];
        }

        var previousPropName = memo.name.name;
        var currentPropName = decl.name.name;
        var previousValue = memo.value;
        var currentValue = decl.value;
        var previousIsCallback = isCallbackPropName(previousPropName);
        var currentIsCallback = isCallbackPropName(currentPropName);

        if (ignoreCase) {
          previousPropName = previousPropName.toLowerCase();
          currentPropName = currentPropName.toLowerCase();
        }

        if (callbacksLast) {
          if (!previousIsCallback && currentIsCallback) {
            return decl;
          }
          if (previousIsCallback && !currentIsCallback) {
            context.report(memo, 'Callbacks must be listed after all other props');
            return memo;
          }
        }

        if (shorthandFirst) {
          if (currentValue && !previousValue) {
            return decl;
          }
          if (!currentValue && previousValue) {
            context.report(memo, 'Shorthand props must be listed before all other props');
            return memo;
          }
        }

        if (currentPropName < previousPropName) {
          context.report(decl, 'Props should be sorted alphabetically');
          return memo;
        }

        return decl;
      }, node.attributes[0]);
    }
  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    callbacksLast: {
      type: 'boolean'
    },
    shorthandFirst: {
      type: 'boolean'
    },
    ignoreCase: {
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-uses-react.js": [function(require,module,exports){
'use strict';

var variableUtil = require('../util/variable');
var pragmaUtil = require('../util/pragma');

module.exports = function(context) {

  var pragma = pragmaUtil.getFromContext(context);

  return {

    JSXOpeningElement: function() {
      variableUtil.markVariableAsUsed(context, pragma);
    },

    BlockComment: function(node) {
      pragma = pragmaUtil.getFromNode(node) || pragma;
    }

  };

};

module.exports.schema = [{
  type: 'object',
  properties: {
    pragma: {
      type: 'string'
    }
  },
  additionalProperties: false
}];

},
   {"../util/pragma":"/node_modules/eslint-plugin-react/lib/util/pragma.js","../util/variable":"/node_modules/eslint-plugin-react/lib/util/variable.js"}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-uses-vars.js": [function(require,module,exports){
'use strict';

var variableUtil = require('../util/variable');

module.exports = function(context) {

  return {
    JSXExpressionContainer: function(node) {
      if (node.expression.type !== 'Identifier') {
        return;
      }
      variableUtil.markVariableAsUsed(context, node.expression.name);
    },

    JSXIdentifier: function(node) {
      if (node.parent.type === 'JSXAttribute') {
        return;
      }
      variableUtil.markVariableAsUsed(context, node.name);
    }

  };

};

module.exports.schema = [];

},
   {"../util/variable":"/node_modules/eslint-plugin-react/lib/util/variable.js"}],

"/node_modules/eslint-plugin-react/lib/rules/no-danger.js": [function(require,module,exports){
'use strict';

var DANGEROUS_MESSAGE = 'Dangerous property \'{{name}}\' found';

var DANGEROUS_PROPERTY_NAMES = [
  'dangerouslySetInnerHTML'
];

var DANGEROUS_PROPERTIES = DANGEROUS_PROPERTY_NAMES.reduce(function (props, prop) {
  props[prop] = prop;
  return props;
}, Object.create(null));

var tagConvention = /^[a-z]|\-/;
function isTagName(name) {
  return tagConvention.test(name);
}

function isDangerous(name) {
  return name in DANGEROUS_PROPERTIES;
}

module.exports = function(context) {

  return {

    JSXAttribute: function(node) {
      if (isTagName(node.parent.name.name) && isDangerous(node.name.name)) {
        context.report(node, DANGEROUS_MESSAGE, {
          name: node.name.name
        });
      }
    }

  };

};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/no-deprecated.js": [function(require,module,exports){
'use strict';

var pragmaUtil = require('../util/pragma');

var DEPRECATED_MESSAGE = '{{oldMethod}} is deprecated since React {{version}}{{newMethod}}';

module.exports = function(context) {

  var optVer = context.options[0] ? context.options[0].react : '999.999.999';
  optVer = /^[0-9]+\.[0-9]+$/.test(optVer) ? optVer + '.0' : optVer;
  optVer = optVer.split('.').map(function(part) {
    return Number(part);
  });

  var pragma = pragmaUtil.getFromContext(context);

  function getDeprecated() {
    var deprecated = {
      MemberExpression: {}
    };
    deprecated.MemberExpression[pragma + '.renderComponent'] = ['0.12.0', pragma + '.render'];
    deprecated.MemberExpression[pragma + '.renderComponentToString'] = ['0.12.0', pragma + '.renderToString'];
    deprecated.MemberExpression[pragma + '.renderComponentToStaticMarkup'] = [
      '0.12.0',
      pragma + '.renderToStaticMarkup'
    ];
    deprecated.MemberExpression[pragma + '.isValidComponent'] = ['0.12.0', pragma + '.isValidElement'];
    deprecated.MemberExpression[pragma + '.PropTypes.component'] = ['0.12.0', pragma + '.PropTypes.element'];
    deprecated.MemberExpression[pragma + '.PropTypes.renderable'] = ['0.12.0', pragma + '.PropTypes.node'];
    deprecated.MemberExpression[pragma + '.isValidClass'] = ['0.12.0'];
    deprecated.MemberExpression['this.transferPropsTo'] = ['0.12.0', 'spread operator ({...})'];
    deprecated.MemberExpression[pragma + '.addons.classSet'] = ['0.13.0', 'the npm module classnames'];
    deprecated.MemberExpression[pragma + '.addons.cloneWithProps'] = ['0.13.0', pragma + '.cloneElement'];
    deprecated.MemberExpression[pragma + '.render'] = ['0.14.0', 'ReactDOM.render'];
    deprecated.MemberExpression[pragma + '.unmountComponentAtNode'] = ['0.14.0', 'ReactDOM.unmountComponentAtNode'];
    deprecated.MemberExpression[pragma + '.findDOMNode'] = ['0.14.0', 'ReactDOM.findDOMNode'];
    deprecated.MemberExpression[pragma + '.renderToString'] = ['0.14.0', 'ReactDOMServer.renderToString'];
    deprecated.MemberExpression[pragma + '.renderToStaticMarkup'] = ['0.14.0', 'ReactDOMServer.renderToStaticMarkup'];

    return deprecated;
  }

  function checkVersion(methodVer) {
    methodVer = methodVer.split('.').map(function(part) {
      return Number(part);
    });
    var higherMajor = methodVer[0] < optVer[0];
    var higherMinor = methodVer[0] === optVer[0] && methodVer[1] < optVer[1];
    var higherOrEqualPatch = methodVer[0] === optVer[0] && methodVer[1] === optVer[1] && methodVer[2] <= optVer[2];

    return higherMajor || higherMinor || higherOrEqualPatch;
  }

  function isDeprecated(type, method) {
    var deprecated = getDeprecated();

    return (
      deprecated[type] &&
      deprecated[type][method] &&
      checkVersion(deprecated[type][method][0])
    );
  }

  return {

    MemberExpression: function(node) {
      var method = context.getSource(node);
      if (!isDeprecated(node.type, method)) {
        return;
      }
      var deprecated = getDeprecated();
      context.report(node, DEPRECATED_MESSAGE, {
        oldMethod: method,
        version: deprecated[node.type][method][0],
        newMethod: deprecated[node.type][method][1] ? ', use ' + deprecated[node.type][method][1] + ' instead' : ''
      });
    },

    BlockComment: function(node) {
      pragma = pragmaUtil.getFromNode(node) || pragma;
    }

  };

};

module.exports.schema = [{
  type: 'object',
  properties: {
    react: {
      type: 'string',
      pattern: '^[0-9]+\.[0-9]+(\.[0-9]+)?$'
    }
  },
  additionalProperties: false
}];

},
   {"../util/pragma":"/node_modules/eslint-plugin-react/lib/util/pragma.js"}],

"/node_modules/eslint-plugin-react/lib/rules/no-did-mount-set-state.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var mode = context.options[0] || 'never';

  return {

    CallExpression: function(node) {
      var callee = node.callee;
      if (
        callee.type !== 'MemberExpression' ||
        callee.object.type !== 'ThisExpression' ||
        callee.property.name !== 'setState'
      ) {
        return;
      }
      var ancestors = context.getAncestors(callee).reverse();
      var depth = 0;
      for (var i = 0, j = ancestors.length; i < j; i++) {
        if (/Function(Expression|Declaration)$/.test(ancestors[i].type)) {
          depth++;
        }
        if (
          (ancestors[i].type !== 'Property' && ancestors[i].type !== 'MethodDefinition') ||
          ancestors[i].key.name !== 'componentDidMount' ||
          (mode === 'allow-in-func' && depth > 1)
        ) {
          continue;
        }
        context.report(callee, 'Do not use setState in componentDidMount');
        break;
      }
    }
  };

};

module.exports.schema = [{
  enum: ['allow-in-func']
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/no-did-update-set-state.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var mode = context.options[0] || 'never';

  return {

    CallExpression: function(node) {
      var callee = node.callee;
      if (
        callee.type !== 'MemberExpression' ||
        callee.object.type !== 'ThisExpression' ||
        callee.property.name !== 'setState'
      ) {
        return;
      }
      var ancestors = context.getAncestors(callee).reverse();
      var depth = 0;
      for (var i = 0, j = ancestors.length; i < j; i++) {
        if (/Function(Expression|Declaration)$/.test(ancestors[i].type)) {
          depth++;
        }
        if (
          (ancestors[i].type !== 'Property' && ancestors[i].type !== 'MethodDefinition') ||
          ancestors[i].key.name !== 'componentDidUpdate' ||
          (mode === 'allow-in-func' && depth > 1)
        ) {
          continue;
        }
        context.report(callee, 'Do not use setState in componentDidUpdate');
        break;
      }
    }
  };

};

module.exports.schema = [{
  enum: ['allow-in-func']
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/no-direct-mutation-state.js": [function(require,module,exports){
'use strict';

var Components = require('../util/Components');

module.exports = Components.detect(function(context, components, utils) {

  function isValid(component) {
    return Boolean(component && !component.mutateSetState);
  }

  function reportMutations(component) {
    var mutation;
    for (var i = 0, j = component.mutations.length; i < j; i++) {
      mutation = component.mutations[i];
      context.report(mutation, 'Do not mutate state directly. Use setState().');
    }
  }

  return {
    AssignmentExpression: function(node) {
      var item;
      if (!node.left || !node.left.object || !node.left.object.object) {
        return;
      }
      item = node.left.object;
      while (item.object.property) {
        item = item.object;
      }
      if (
        item.object.type === 'ThisExpression' &&
        item.property.name === 'state'
      ) {
        var component = components.get(utils.getParentComponent());
        var mutations = component && component.mutations || [];
        mutations.push(node.left.object);
        components.set(node, {
          mutateSetState: true,
          mutations: mutations
        });
      }
    },

    'Program:exit': function() {
      var list = components.list();
      for (var component in list) {
        if (!list.hasOwnProperty(component) || isValid(list[component])) {
          continue;
        }
        reportMutations(list[component]);
      }
    }
  };

});

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js"}],

"/node_modules/eslint-plugin-react/lib/rules/no-is-mounted.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  return {

    CallExpression: function(node) {
      var callee = node.callee;
      if (callee.type !== 'MemberExpression') {
        return;
      }
      if (callee.object.type !== 'ThisExpression' || callee.property.name !== 'isMounted') {
        return;
      }
      var ancestors = context.getAncestors(callee);
      for (var i = 0, j = ancestors.length; i < j; i++) {
        if (ancestors[i].type === 'Property' || ancestors[i].type === 'MethodDefinition') {
          context.report(callee, 'Do not use isMounted');
          break;
        }
      }
    }
  };

};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/no-multi-comp.js": [function(require,module,exports){
'use strict';

var Components = require('../util/Components');

module.exports = Components.detect(function(context, components) {

  var configuration = context.options[0] || {};
  var ignoreStateless = configuration.ignoreStateless || false;

  var MULTI_COMP_MESSAGE = 'Declare only one React component per file';

  function isIgnored(component) {
    return ignoreStateless === true && /Function/.test(component.node.type);
  }

  return {
    'Program:exit': function() {
      if (components.length() <= 1) {
        return;
      }

      var list = components.list();
      var i = 0;

      for (var component in list) {
        if (!list.hasOwnProperty(component) || isIgnored(list[component]) || ++i === 1) {
          continue;
        }
        context.report(list[component].node, MULTI_COMP_MESSAGE);
      }
    }
  };
});

module.exports.schema = [{
  type: 'object',
  properties: {
    ignoreStateless: {
      default: false,
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js"}],

"/node_modules/eslint-plugin-react/lib/rules/no-set-state.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  return {

    CallExpression: function(node) {
      var callee = node.callee;
      if (callee.type !== 'MemberExpression') {
        return;
      }
      if (callee.object.type !== 'ThisExpression' || callee.property.name !== 'setState') {
        return;
      }
      var ancestors = context.getAncestors(callee);
      for (var i = 0, j = ancestors.length; i < j; i++) {
        if (ancestors[i].type === 'Property' || ancestors[i].type === 'MethodDefinition') {
          context.report(callee, 'Do not use setState');
          break;
        }
      }
    }
  };

};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/no-string-refs.js": [function(require,module,exports){
'use strict';

var Components = require('../util/Components');

module.exports = Components.detect(function(context, components, utils) {
  function isRefsUsage(node) {
    return Boolean(
      (
        utils.getParentES6Component() ||
        utils.getParentES5Component()
      ) &&
      node.object.type === 'ThisExpression' &&
      node.property.name === 'refs'
    );
  }

  function isRefAttribute(node) {
    return Boolean(
      node.type === 'JSXAttribute' &&
      node.name &&
      node.name.name === 'ref'
    );
  }

  function containsStringLiteral(node) {
    return Boolean(
      node.value &&
      node.value.type === 'Literal' &&
      typeof node.value.value === 'string'
    );
  }

  function containsStringExpressionContainer(node) {
    return Boolean(
      node.value &&
      node.value.type === 'JSXExpressionContainer' &&
      node.value.expression &&
      node.value.expression.type === 'Literal' &&
      typeof node.value.expression.value === 'string'
    );
  }

  return {
    MemberExpression: function(node) {
      if (isRefsUsage(node)) {
        context.report(node, 'Using this.refs is deprecated.');
      }
    },
    JSXAttribute: function(node) {
      if (
        isRefAttribute(node) &&
        (containsStringLiteral(node) || containsStringExpressionContainer(node))
      ) {
        context.report(node, 'Using string literals in ref attributes is deprecated.');
      }
    }
  };
});

module.exports.schema = [];

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js"}],

"/node_modules/eslint-plugin-react/lib/rules/no-unknown-property.js": [function(require,module,exports){
'use strict';

var UNKNOWN_MESSAGE = 'Unknown property \'{{name}}\' found, use \'{{standardName}}\' instead';

var DOM_ATTRIBUTE_NAMES = {
  'accept-charset': 'acceptCharset',
  class: 'className',
  for: 'htmlFor',
  'http-equiv': 'httpEquiv',
  'clip-path': 'clipPath',
  'fill-opacity': 'fillOpacity',
  'font-family': 'fontFamily',
  'font-size': 'fontSize',
  'marker-end': 'markerEnd',
  'marker-mid': 'markerMid',
  'marker-start': 'markerStart',
  'stop-color': 'stopColor',
  'stop-opacity': 'stopOpacity',
  'stroke-dasharray': 'strokeDasharray',
  'stroke-linecap': 'strokeLinecap',
  'stroke-opacity': 'strokeOpacity',
  'stroke-width': 'strokeWidth',
  'text-anchor': 'textAnchor',
  'xlink:actuate': 'xlinkActuate',
  'xlink:arcrole': 'xlinkArcrole',
  'xlink:href': 'xlinkHref',
  'xlink:role': 'xlinkRole',
  'xlink:show': 'xlinkShow',
  'xlink:title': 'xlinkTitle',
  'xlink:type': 'xlinkType',
  'xml:base': 'xmlBase',
  'xml:lang': 'xmlLang',
  'xml:space': 'xmlSpace'
};

var DOM_PROPERTY_NAMES = [
  'acceptCharset', 'accessKey', 'allowFullScreen', 'allowTransparency', 'autoComplete', 'autoFocus', 'autoPlay',
  'cellPadding', 'cellSpacing', 'charSet', 'classID', 'className', 'colSpan', 'contentEditable', 'contextMenu',
  'crossOrigin', 'dateTime', 'encType', 'formAction', 'formEncType', 'formMethod', 'formNoValidate', 'formTarget',
  'frameBorder', 'hrefLang', 'htmlFor', 'httpEquiv', 'marginHeight', 'marginWidth', 'maxLength', 'mediaGroup',
  'noValidate', 'onBlur', 'onChange', 'onClick', 'onContextMenu', 'onCopy', 'onCut', 'onDoubleClick',
  'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop',
  'onFocus', 'onInput', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onMouseDown', 'onMouseEnter', 'onMouseLeave',
  'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp', 'onPaste', 'onScroll', 'onSubmit', 'onTouchCancel',
  'onTouchEnd', 'onTouchMove', 'onTouchStart', 'onWheel',
  'radioGroup', 'readOnly', 'rowSpan', 'spellCheck', 'srcDoc', 'srcSet', 'tabIndex', 'useMap',
  'autoCapitalize', 'autoCorrect',
  'autoSave',
  'itemProp', 'itemScope', 'itemType', 'itemRef', 'itemID'
];

var tagConvention = /^[a-z][^-]*$/;
function isTagName(node) {
  if (tagConvention.test(node.parent.name.name)) {
    return !node.parent.attributes.some(function(attrNode) {
      return (
        attrNode.type === 'JSXAttribute' &&
        attrNode.name.type === 'JSXIdentifier' &&
        attrNode.name.name === 'is'
      );
    });
  }
  return false;
}

function getStandardName(name) {
  if (DOM_ATTRIBUTE_NAMES[name]) {
    return DOM_ATTRIBUTE_NAMES[name];
  }
  var i;
  var found = DOM_PROPERTY_NAMES.some(function(element, index) {
    i = index;
    return element.toLowerCase() === name;
  });
  return found ? DOM_PROPERTY_NAMES[i] : null;
}

module.exports = function(context) {

  return {

    JSXAttribute: function(node) {
      var name = context.getSource(node.name);
      var standardName = getStandardName(name);
      if (!isTagName(node) || !standardName) {
        return;
      }
      context.report({
        node: node,
        message: UNKNOWN_MESSAGE,
        data: {
          name: name,
          standardName: standardName
        },
        fix: function(fixer) {
          return fixer.replaceText(node.name, standardName);
        }
      });
    }
  };

};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/prefer-es6-class.js": [function(require,module,exports){
'use strict';

var Components = require('../util/Components');

module.exports = Components.detect(function(context, components, utils) {
  var configuration = context.options[0] || 'always';

  return {
    ObjectExpression: function(node) {
      if (utils.isES5Component(node) && configuration === 'always') {
        context.report(node, 'Component should use es6 class instead of createClass');
      }
    },
    ClassDeclaration: function(node) {
      if (utils.isES6Component(node) && configuration === 'never') {
        context.report(node, 'Component should use createClass instead of es6 class');
      }
    }
  };
});

module.exports.schema = [{
  enum: ['always', 'never']
}];

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js"}],

"/node_modules/eslint-plugin-react/lib/rules/prop-types.js": [function(require,module,exports){
'use strict';

var Components = require('../util/Components');
var variable = require('../util/variable');

module.exports = Components.detect(function(context, components, utils) {

  var configuration = context.options[0] || {};
  var ignored = configuration.ignore || [];
  var customValidators = configuration.customValidators || [];
  var stack = null;

  var MISSING_MESSAGE = '\'{{name}}\' is missing in props validation';

  function typeScope(key, value) {
    if (arguments.length === 0) {
      return stack[stack.length - 1];
    } else if (arguments.length === 1) {
      return stack[stack.length - 1][key];
    }
    stack[stack.length - 1][key] = value;
    return value;
  }

  function isPropTypesUsage(node) {
    var isClassUsage = (
      (utils.getParentES6Component() || utils.getParentES5Component()) &&
      node.object.type === 'ThisExpression' && node.property.name === 'props'
    );
    var isStatelessFunctionUsage = node.object.name === 'props';
    return isClassUsage || isStatelessFunctionUsage;
  }

  function isAnnotatedPropsDeclaration(node) {
    if (node && node.type === /*ClassProperty*/'Property' && node.kind == 'class') {
      var tokens = context.getFirstTokens(node, 2);
      if (
        node.typeAnnotation && (
          tokens[0].value === 'props' ||
          (tokens[1] && tokens[1].value === 'props')
        )
      ) {
        return true;
      }
    }
    return false;
  }

  function isPropTypesDeclaration(node) {

    if (node && node.type === /*ClassProperty*/'Property' && node.kind == 'class') {
      var tokens = context.getFirstTokens(node, 2);
      if (
        tokens[0].value === 'propTypes' ||
        (tokens[1] && tokens[1].value === 'propTypes')
      ) {
        return true;
      }
      return false;
    }

    return Boolean(
      node &&
      node.name === 'propTypes'
    );

  }

  function isIgnored(name) {
    return ignored.indexOf(name) !== -1;
  }

  function hasCustomValidator(validator) {
    return customValidators.indexOf(validator) !== -1;
  }

  function mustBeValidated(component) {
    return Boolean(
      component &&
      component.usedPropTypes &&
      !component.ignorePropsValidation
    );
  }

  function _isDeclaredInComponent(declaredPropTypes, keyList) {
    for (var i = 0, j = keyList.length; i < j; i++) {
      var key = keyList[i];
      var propType = (
        declaredPropTypes[key] ||
        declaredPropTypes.__ANY_KEY__
      );

      if (!propType) {
        return key === '__COMPUTED_PROP__';
      }
      if (propType === true) {
        return true;
      }
      if (propType.children === true) {
        return true;
      }
      if (propType.acceptedProperties) {
        return key in propType.acceptedProperties;
      }
      if (propType.type === 'union') {
        if (i + 1 >= j) {
          return true;
        }
        var unionTypes = propType.children;
        var unionPropType = {};
        for (var k = 0, z = unionTypes.length; k < z; k++) {
          unionPropType[key] = unionTypes[k];
          var isValid = _isDeclaredInComponent(
            unionPropType,
            keyList.slice(i)
          );
          if (isValid) {
            return true;
          }
        }

        return false;
      }
      declaredPropTypes = propType.children;
    }
    return true;
  }

  function isDeclaredInComponent(node, names) {
    while (node) {
      var component = components.get(node);
      var isDeclared =
        component && component.confidence === 2 &&
        _isDeclaredInComponent(component.declaredPropTypes || {}, names)
      ;
      if (isDeclared) {
        return true;
      }
      node = node.parent;
    }
    return false;
  }

  function hasSpreadOperator(node) {
    var tokens = context.getTokens(node);
    return tokens.length && tokens[0].value === '...';
  }

  function getKeyValue(node) {
    if (node.type === 'ObjectTypeProperty') {
      var tokens = context.getFirstTokens(node, 1);
      return tokens[0].value;
    }
    var key = node.key || node.argument;
    return key.type === 'Identifier' ? key.name : key.value;
  }

  function iterateProperties(properties, fn) {
    if (properties.length && typeof fn === 'function') {
      for (var i = 0, j = properties.length; i < j; i++) {
        var node = properties[i];
        var key = getKeyValue(node);

        var value = node.value;
        fn(key, value);
      }
    }
  }

  function buildReactDeclarationTypes(value) {
    if (
      value &&
      value.callee &&
      value.callee.object &&
      hasCustomValidator(value.callee.object.name)
    ) {
      return true;
    }

    if (
      value &&
      value.type === 'MemberExpression' &&
      value.property &&
      value.property.name &&
      value.property.name === 'isRequired'
    ) {
      value = value.object;
    }

    if (
      value &&
      value.type === 'CallExpression' &&
      value.callee &&
      value.callee.property &&
      value.callee.property.name &&
      value.arguments &&
      value.arguments.length > 0
    ) {
      var callName = value.callee.property.name;
      var argument = value.arguments[0];
      switch (callName) {
        case 'shape':
          if (argument.type !== 'ObjectExpression') {
            return true;
          }
          var shapeTypeDefinition = {
            type: 'shape',
            children: {}
          };
          iterateProperties(argument.properties, function(childKey, childValue) {
            shapeTypeDefinition.children[childKey] = buildReactDeclarationTypes(childValue);
          });
          return shapeTypeDefinition;
        case 'arrayOf':
        case 'objectOf':
          return {
            type: 'object',
            children: {
              __ANY_KEY__: buildReactDeclarationTypes(argument)
            }
          };
        case 'oneOfType':
          if (
            !argument.elements ||
            !argument.elements.length
          ) {
            return true;
          }
          var unionTypeDefinition = {
            type: 'union',
            children: []
          };
          for (var i = 0, j = argument.elements.length; i < j; i++) {
            var type = buildReactDeclarationTypes(argument.elements[i]);
            if (type !== true) {
              if (type.children === true) {
                unionTypeDefinition.children = true;
                return unionTypeDefinition;
              }
            }

            unionTypeDefinition.children.push(type);
          }
          if (unionTypeDefinition.length === 0) {
            return true;
          }
          return unionTypeDefinition;
        case 'instanceOf':
          return {
            type: 'instance',
            children: true
          };
        case 'oneOf':
        default:
          return true;
      }
    }
    return true;
  }

  function buildTypeAnnotationDeclarationTypes(annotation) {
    switch (annotation.type) {
      case 'GenericTypeAnnotation':
        if (typeScope(annotation.id.name)) {
          return buildTypeAnnotationDeclarationTypes(typeScope(annotation.id.name));
        }
        return true;
      case 'ObjectTypeAnnotation':
        var shapeTypeDefinition = {
          type: 'shape',
          children: {}
        };
        iterateProperties(annotation.properties, function(childKey, childValue) {
          shapeTypeDefinition.children[childKey] = buildTypeAnnotationDeclarationTypes(childValue);
        });
        return shapeTypeDefinition;
      case 'UnionTypeAnnotation':
        var unionTypeDefinition = {
          type: 'union',
          children: []
        };
        for (var i = 0, j = annotation.types.length; i < j; i++) {
          var type = buildTypeAnnotationDeclarationTypes(annotation.types[i]);
          if (type !== true) {
            if (type.children === true) {
              unionTypeDefinition.children = true;
              return unionTypeDefinition;
            }
          }

          unionTypeDefinition.children.push(type);
        }
        if (unionTypeDefinition.children.length === 0) {
          return true;
        }
        return unionTypeDefinition;
      case 'ArrayTypeAnnotation':
        return {
          type: 'object',
          children: {
            __ANY_KEY__: buildTypeAnnotationDeclarationTypes(annotation.elementType)
          }
        };
      default:
        return true;
    }
  }

  function inConstructor() {
    var scope = context.getScope();
    while (scope) {
      if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {
        return true;
      }
      scope = scope.upper;
    }
    return false;
  }

  function getPropertyName(node) {
    var isDirectProp = /^props(\.|\[)/.test(context.getSource(node));
    var isInClassComponent = utils.getParentES6Component() || utils.getParentES5Component();
    var isNotInConstructor = !inConstructor(node);
    if (isDirectProp && isInClassComponent && isNotInConstructor) {
      return void 0;
    }
    if (!isDirectProp) {
      node = node.parent;
    }
    var property = node.property;
    if (property) {
      switch (property.type) {
        case 'Identifier':
          if (node.computed) {
            return '__COMPUTED_PROP__';
          }
          return property.name;
        case 'MemberExpression':
          return void 0;
        case 'Literal':
          if (typeof property.value === 'string') {
            return property.value;
          }
        default:
          if (node.computed) {
            return '__COMPUTED_PROP__';
          }
          break;
      }
    }
    return void 0;
  }

  function markPropTypesAsUsed(node, parentNames) {
    parentNames = parentNames || [];
    var type;
    var name;
    var allNames;
    var properties;
    switch (node.type) {
      case 'MemberExpression':
        name = getPropertyName(node);
        if (name) {
          allNames = parentNames.concat(name);
          if (node.parent.type === 'MemberExpression') {
            markPropTypesAsUsed(node.parent, allNames);
          }
          type = name !== '__COMPUTED_PROP__' ? 'direct' : null;
        } else if (
          node.parent.id &&
          node.parent.id.properties &&
          node.parent.id.properties.length &&
          getKeyValue(node.parent.id.properties[0])
        ) {
          type = 'destructuring';
          properties = node.parent.id.properties;
        }
        break;
      case 'VariableDeclarator':
        for (var i = 0, j = node.id.properties.length; i < j; i++) {
          var thisDestructuring = (
            (node.id.properties[i].key.name === 'props' || node.id.properties[i].key.value === 'props') &&
            node.id.properties[i].value.type === 'ObjectPattern'
          );
          var statelessDestructuring = node.init.name === 'props' && utils.getParentStatelessComponent();

          if (thisDestructuring) {
            properties = node.id.properties[i].value.properties;
          } else if (statelessDestructuring) {
            properties = node.id.properties;
          } else {
            continue;
          }
          type = 'destructuring';
          break;
        }
        break;
      default:
        throw new Error(node.type + ' ASTNodes are not handled by markPropTypesAsUsed');
    }

    var component = components.get(utils.getParentComponent());
    var usedPropTypes = component && component.usedPropTypes || [];

    switch (type) {
      case 'direct':
        if (Object.prototype[name]) {
          break;
        }

        var isDirectProp = /^props(\.|\[)/.test(context.getSource(node));

        usedPropTypes.push({
          name: name,
          allNames: allNames,
          node: !isDirectProp && !inConstructor(node) ? node.parent.property : node.property
        });
        break;
      case 'destructuring':
        for (var k = 0, l = properties.length; k < l; k++) {
          if (hasSpreadOperator(properties[k]) || properties[k].computed) {
            continue;
          }
          var propName = getKeyValue(properties[k]);

          var currentNode = node;
          allNames = [];
          while (currentNode.property && currentNode.property.name !== 'props') {
            allNames.unshift(currentNode.property.name);
            currentNode = currentNode.object;
          }
          allNames.push(propName);

          if (propName) {
            usedPropTypes.push({
              name: propName,
              allNames: allNames,
              node: properties[k]
            });
          }
        }
        break;
      default:
        break;
    }

    components.set(node, {
      usedPropTypes: usedPropTypes
    });
  }

  function markPropTypesAsDeclared(node, propTypes) {
    var component = components.get(node);
    var declaredPropTypes = component && component.declaredPropTypes || {};
    var ignorePropsValidation = false;

    switch (propTypes && propTypes.type) {
      case 'ObjectTypeAnnotation':
        iterateProperties(propTypes.properties, function(key, value) {
          declaredPropTypes[key] = buildTypeAnnotationDeclarationTypes(value);
        });
        break;
      case 'ObjectExpression':
        iterateProperties(propTypes.properties, function(key, value) {
          if (!value) {
            ignorePropsValidation = true;
            return;
          }
          declaredPropTypes[key] = buildReactDeclarationTypes(value);
        });
        break;
      case 'MemberExpression':
        var curDeclaredPropTypes = declaredPropTypes;
        while (
          propTypes &&
          propTypes.parent &&
          propTypes.parent.type !== 'AssignmentExpression' &&
          propTypes.property &&
          curDeclaredPropTypes
        ) {
          var propName = propTypes.property.name;
          if (propName in curDeclaredPropTypes) {
            curDeclaredPropTypes = curDeclaredPropTypes[propName].children;
            propTypes = propTypes.parent;
          } else {
            propTypes = null;
          }
        }
        if (propTypes && propTypes.parent && propTypes.property) {
          curDeclaredPropTypes[propTypes.property.name] =
            buildReactDeclarationTypes(propTypes.parent.right);
        }
        break;
      case 'Identifier':
        var variablesInScope = variable.variablesInScope(context);
        for (var i = 0, j = variablesInScope.length; i < j; i++) {
          if (variablesInScope[i].name !== propTypes.name) {
            continue;
          }
          var defInScope = variablesInScope[i].defs[variablesInScope[i].defs.length - 1];
          markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init);
          return;
        }
        ignorePropsValidation = true;
        break;
      case null:
        break;
      default:
        ignorePropsValidation = true;
        break;
    }

    components.set(node, {
      declaredPropTypes: declaredPropTypes,
      ignorePropsValidation: ignorePropsValidation
    });
  }

  function reportUndeclaredPropTypes(component) {
    var allNames;
    for (var i = 0, j = component.usedPropTypes.length; i < j; i++) {
      allNames = component.usedPropTypes[i].allNames;
      if (
        isIgnored(allNames[0]) ||
        isDeclaredInComponent(component.node, allNames)
      ) {
        continue;
      }
      context.report(
        component.usedPropTypes[i].node,
        MISSING_MESSAGE, {
          name: allNames.join('.').replace(/\.__COMPUTED_PROP__/g, '[]')
        }
      );
    }
  }

  function resolveTypeAnnotation(node) {
    var annotation = node.typeAnnotation || node;
    while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {
      annotation = annotation.typeAnnotation;
    }
    if (annotation.type === 'GenericTypeAnnotation' && typeScope(annotation.id.name)) {
      return typeScope(annotation.id.name);
    }
    return annotation;
  }

  return {
Property: function(node) {
      if (node.kind == 'class' && isAnnotatedPropsDeclaration(node)) {
        markPropTypesAsDeclared(node, resolveTypeAnnotation(node));
      } else if (isPropTypesDeclaration(node)) {
        markPropTypesAsDeclared(node, node.value);
      }
    },

    VariableDeclarator: function(node) {
      var destructuring = node.init && node.id && node.id.type === 'ObjectPattern';
      var thisDestructuring = destructuring && node.init.type === 'ThisExpression';
      var statelessDestructuring = destructuring && node.init.name === 'props' && utils.getParentStatelessComponent();

      if (!thisDestructuring && !statelessDestructuring) {
        return;
      }
      markPropTypesAsUsed(node);
    },

    MemberExpression: function(node) {
      var type;
      if (isPropTypesUsage(node)) {
        type = 'usage';
      } else if (isPropTypesDeclaration(node.property)) {
        type = 'declaration';
      }

      switch (type) {
        case 'usage':
          markPropTypesAsUsed(node);
          break;
        case 'declaration':
          var component = utils.getRelatedComponent(node);
          if (!component) {
            return;
          }
          markPropTypesAsDeclared(component.node, node.parent.right || node.parent);
          break;
        default:
          break;
      }
    },

    MethodDefinition: function(node) {
      if (!isPropTypesDeclaration(node.key)) {
        return;
      }

      var i = node.value.body.body.length - 1;
      for (; i >= 0; i--) {
        if (node.value.body.body[i].type === 'ReturnStatement') {
          break;
        }
      }

      if (i >= 0) {
        markPropTypesAsDeclared(node, node.value.body.body[i].argument);
      }
    },

    ObjectExpression: function(node) {
      node.properties.forEach(function(property) {
        if (!isPropTypesDeclaration(property.key)) {
          return;
        }
        markPropTypesAsDeclared(node, property.value);
      });
    },

    TypeAlias: function(node) {
      typeScope(node.id.name, node.right);
    },

    Program: function() {
      stack = [{}];
    },

    BlockStatement: function () {
      stack.push(Object.create(typeScope()));
    },

    'BlockStatement:exit': function () {
      stack.pop();
    },

    'Program:exit': function() {
      stack = null;
      var list = components.list();
      for (var component in list) {
        if (!list.hasOwnProperty(component) || !mustBeValidated(list[component])) {
          continue;
        }
        reportUndeclaredPropTypes(list[component]);
      }
    }
  };

});

module.exports.schema = [{
  type: 'object',
  properties: {
    ignore: {
      type: 'array',
      items: {
        type: 'string'
      }
    },
    customValidators: {
      type: 'array',
      items: {
        type: 'string'
      }
    }
  },
  additionalProperties: false
}];

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js","../util/variable":"/node_modules/eslint-plugin-react/lib/util/variable.js"}],

"/node_modules/eslint-plugin-react/lib/rules/react-in-jsx-scope.js": [function(require,module,exports){
'use strict';

var variableUtil = require('../util/variable');
var pragmaUtil = require('../util/pragma');

module.exports = function(context) {

  var pragma = pragmaUtil.getFromContext(context);
  var NOT_DEFINED_MESSAGE = '\'{{name}}\' must be in scope when using JSX';

  return {

    JSXOpeningElement: function(node) {
      var variables = variableUtil.variablesInScope(context);
      if (variableUtil.findVariable(variables, pragma)) {
        return;
      }
      context.report(node, NOT_DEFINED_MESSAGE, {
        name: pragma
      });
    },

    BlockComment: function(node) {
      pragma = pragmaUtil.getFromNode(node) || pragma;
    }

  };

};

module.exports.schema = [];

},
   {"../util/pragma":"/node_modules/eslint-plugin-react/lib/util/pragma.js","../util/variable":"/node_modules/eslint-plugin-react/lib/util/variable.js"}],

"/node_modules/eslint-plugin-react/lib/rules/require-extension.js": [function(require,module,exports){
'use strict';

var path = require('path');

var DEFAULTS = {
  extentions: ['.jsx']
};

var PKG_REGEX = /^[^\.]((?!\/).)*$/;

module.exports = function(context) {

  function isPackage(id) {
    return PKG_REGEX.test(id);
  }

  function isRequire(expression) {
    return expression.callee.name === 'require';
  }

  function getId(expression) {
    return expression.arguments[0] && expression.arguments[0].value;
  }

  function getExtension(id) {
    return path.extname(id || '');
  }

  function getExtentionsConfig() {
    return context.options[0] && context.options[0].extensions || DEFAULTS.extentions;
  }

  var forbiddenExtensions = getExtentionsConfig().reduce(function (extensions, extension) {
    extensions[extension] = true;
    return extensions;
  }, Object.create(null));

  function isForbiddenExtension(ext) {
    return ext in forbiddenExtensions;
  }

  return {

    CallExpression: function(node) {
      if (isRequire(node)) {
        var id = getId(node);
        var ext = getExtension(id);
        if (!isPackage(id) && isForbiddenExtension(ext)) {
          context.report(node, 'Unable to require module with extension \'' + ext + '\'');
        }
      }
    }

  };

};

module.exports.schema = [{
  type: 'object',
  properties: {
    extensions: {
      type: 'array',
      items: {
        type: 'string'
      }
    }
  },
  additionalProperties: false
}];

},
   {"path":"/node_modules/browserify/node_modules/path-browserify/index.js"}],

"/node_modules/eslint-plugin-react/lib/rules/self-closing-comp.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var tagConvention = /^[a-z]|\-/;
  function isTagName(name) {
    return tagConvention.test(name);
  }

  function isComponent(node) {
    return node.name && node.name.type === 'JSXIdentifier' && !isTagName(node.name.name);
  }

  function hasChildren(node) {
    var childrens = node.parent.children;
    if (
      !childrens.length ||
      (childrens.length === 1 && childrens[0].type === 'Literal' && !childrens[0].value.trim())
    ) {
      return false;
    }
    return true;
  }

  return {

    JSXOpeningElement: function(node) {
      if (!isComponent(node) || node.selfClosing || hasChildren(node)) {
        return;
      }
      context.report(node, 'Empty components are self-closing');
    }
  };

};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/sort-comp.js": [function(require,module,exports){
'use strict';

var util = require('util');

var Components = require('../util/Components');

function getMethodsOrder(defaultConfig, userConfig) {
  userConfig = userConfig || {};

  var groups = util._extend(defaultConfig.groups, userConfig.groups);
  var order = userConfig.order || defaultConfig.order;

  var config = [];
  var entry;
  for (var i = 0, j = order.length; i < j; i++) {
    entry = order[i];
    if (groups.hasOwnProperty(entry)) {
      config = config.concat(groups[entry]);
    } else {
      config.push(entry);
    }
  }

  return config;
}

module.exports = Components.detect(function(context, components) {

  var errors = {};

  var MISPOSITION_MESSAGE = '{{propA}} should be placed {{position}} {{propB}}';

  var methodsOrder = getMethodsOrder({
    order: [
      'lifecycle',
      'everything-else',
      'render'
    ],
    groups: {
      lifecycle: [
        'displayName',
        'propTypes',
        'contextTypes',
        'childContextTypes',
        'mixins',
        'statics',
        'defaultProps',
        'constructor',
        'getDefaultProps',
        'state',
        'getInitialState',
        'getChildContext',
        'componentWillMount',
        'componentDidMount',
        'componentWillReceiveProps',
        'shouldComponentUpdate',
        'componentWillUpdate',
        'componentDidUpdate',
        'componentWillUnmount'
      ]
    }
  }, context.options[0]);

  var regExpRegExp = /\/(.*)\/([g|y|i|m]*)/;

  function getRefPropIndexes(method) {
    var isRegExp;
    var matching;
    var i;
    var j;
    var indexes = [];
    for (i = 0, j = methodsOrder.length; i < j; i++) {
      isRegExp = methodsOrder[i].match(regExpRegExp);
      if (isRegExp) {
        matching = new RegExp(isRegExp[1], isRegExp[2]).test(method);
      } else {
        matching = methodsOrder[i] === method;
      }
      if (matching) {
        indexes.push(i);
      }
    }

    if (indexes.length === 0) {
      for (i = 0, j = methodsOrder.length; i < j; i++) {
        if (methodsOrder[i] === 'everything-else') {
          indexes.push(i);
        }
      }
    }

    if (indexes.length === 0) {
      indexes.push(Infinity);
    }

    return indexes;
  }

  function getPropertyName(node) {

    if (node.type === /*ClassProperty*/'Property' && node.kind == 'class') {
      var tokens = context.getFirstTokens(node, 2);
      return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
    }

    return node.key.name;
  }

  function storeError(propA, propB) {
    if (!errors[propA.index]) {
      errors[propA.index] = {
        node: propA.node,
        score: 0,
        closest: {
          distance: Infinity,
          ref: {
            node: null,
            index: 0
          }
        }
      };
    }
    errors[propA.index].score++;
    if (Math.abs(propA.index - propB.index) > errors[propA.index].closest.distance) {
      return;
    }
    errors[propA.index].closest.distance = Math.abs(propA.index - propB.index);
    errors[propA.index].closest.ref.node = propB.node;
    errors[propA.index].closest.ref.index = propB.index;
  }

  function dedupeErrors() {
    for (var i in errors) {
      if (!errors.hasOwnProperty(i)) {
        continue;
      }
      var index = errors[i].closest.ref.index;
      if (!errors[index]) {
        continue;
      }
      if (errors[i].score > errors[index].score) {
        delete errors[index];
      } else {
        delete errors[i];
      }
    }
  }

  function reportErrors() {
    dedupeErrors();

    var nodeA;
    var nodeB;
    var indexA;
    var indexB;
    for (var i in errors) {
      if (!errors.hasOwnProperty(i)) {
        continue;
      }

      nodeA = errors[i].node;
      nodeB = errors[i].closest.ref.node;
      indexA = i;
      indexB = errors[i].closest.ref.index;

      context.report(nodeA, MISPOSITION_MESSAGE, {
        propA: getPropertyName(nodeA),
        propB: getPropertyName(nodeB),
        position: indexA < indexB ? 'before' : 'after'
      });
    }
  }

  function getComponentProperties(node) {
    switch (node.type) {
      case 'ClassDeclaration':
        return node.body.body;
      case 'ObjectExpression':
        return node.properties;
      default:
        return [];
    }
  }

  function comparePropsOrder(propertiesNames, propA, propB) {
    var i;
    var j;
    var k;
    var l;
    var refIndexA;
    var refIndexB;

    var refIndexesA = getRefPropIndexes(propA);
    var refIndexesB = getRefPropIndexes(propB);

    var classIndexA = propertiesNames.indexOf(propA);
    var classIndexB = propertiesNames.indexOf(propB);

    for (i = 0, j = refIndexesA.length; i < j; i++) {
      refIndexA = refIndexesA[i];

      for (k = 0, l = refIndexesB.length; k < l; k++) {
        refIndexB = refIndexesB[k];

        if (
          refIndexA === refIndexB ||
          refIndexA < refIndexB && classIndexA < classIndexB ||
          refIndexA > refIndexB && classIndexA > classIndexB
        ) {
          return {
            correct: true,
            indexA: classIndexA,
            indexB: classIndexB
          };
        }

      }
    }

    return {
      correct: false,
      indexA: refIndexA,
      indexB: refIndexB
    };
  }

  function checkPropsOrder(properties) {
    var propertiesNames = properties.map(getPropertyName);
    var i;
    var j;
    var k;
    var l;
    var propA;
    var propB;
    var order;

    for (i = 0, j = propertiesNames.length; i < j; i++) {
      propA = propertiesNames[i];

      for (k = 0, l = propertiesNames.length; k < l; k++) {
        propB = propertiesNames[k];

        order = comparePropsOrder(propertiesNames, propA, propB);

        if (order.correct === true) {
          continue;
        }

        storeError({
          node: properties[i],
          index: order.indexA
        }, {
          node: properties[k],
          index: order.indexB
        });
      }
    }

  }

  return {
    'Program:exit': function() {
      var list = components.list();
      for (var component in list) {
        if (!list.hasOwnProperty(component)) {
          continue;
        }
        var properties = getComponentProperties(list[component].node);
        checkPropsOrder(properties);
      }

      reportErrors();
    }
  };

});

module.exports.schema = [{
  type: 'object',
  properties: {
    order: {
      type: 'array',
      items: {
        type: 'string'
      }
    },
    groups: {
      type: 'object',
      patternProperties: {
        '^.*$': {
          type: 'array',
          items: {
            type: 'string'
          }
        }
      }
    }
  },
  additionalProperties: false
}];

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js","util":"/node_modules/browserify/node_modules/util/util.js"}],

"/node_modules/eslint-plugin-react/lib/rules/wrap-multilines.js": [function(require,module,exports){
'use strict';

var DEFAULTS = {
  declaration: true,
  assignment: true,
  return: true
};

module.exports = function(context) {

  var sourceCode = context.getSourceCode();

  function isParenthesised(node) {
    var previousToken = context.getTokenBefore(node);
    var nextToken = context.getTokenAfter(node);

    return previousToken && nextToken &&
      previousToken.value === '(' && previousToken.range[1] <= node.range[0] &&
      nextToken.value === ')' && nextToken.range[0] >= node.range[1];
  }

  function isMultilines(node) {
    return node.loc.start.line !== node.loc.end.line;
  }

  function check(node) {
    if (!node || node.type !== 'JSXElement') {
      return;
    }

    if (!isParenthesised(node) && isMultilines(node)) {
      context.report({
        node: node,
        message: 'Missing parentheses around multilines JSX',
        fix: function(fixer) {
          return fixer.replaceText(node, '(' + sourceCode.getText(node) + ')');
        }
      });
    }
  }

  function isEnabled(type) {
    var userOptions = context.options[0] || {};
    if (({}).hasOwnProperty.call(userOptions, type)) {
      return userOptions[type];
    }
    return DEFAULTS[type];
  }

  return {

    VariableDeclarator: function(node) {
      if (isEnabled('declaration')) {
        check(node.init);
      }
    },

    AssignmentExpression: function(node) {
      if (isEnabled('assignment')) {
        check(node.right);
      }
    },

    ReturnStatement: function(node) {
      if (isEnabled('return')) {
        check(node.argument);
      }
    }
  };

};

module.exports.schema = [{
  type: 'object',
  properties: {
    declaration: {
      type: 'boolean'
    },
    assignment: {
      type: 'boolean'
    },
    return: {
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/util/Components.js": [function(require,module,exports){
'use strict';

var util = require('util');
var variableUtil = require('./variable');
var pragmaUtil = require('./pragma');

function Components() {
  this._list = {};
  this._getId = function(node) {
    return node && node.range.join(':');
  };
}

Components.prototype.add = function(node, confidence) {
  var id = this._getId(node);
  if (this._list[id]) {
    if (confidence === 0 || this._list[id].confidence === 0) {
      this._list[id].confidence = 0;
    } else {
      this._list[id].confidence = Math.max(this._list[id].confidence, confidence);
    }
    return;
  }
  this._list[id] = {
    node: node,
    confidence: confidence
  };
};

Components.prototype.get = function(node) {
  var id = this._getId(node);
  return this._list[id];
};

Components.prototype.set = function(node, props) {
  while (node && !this._list[this._getId(node)]) {
    node = node.parent;
  }
  if (!node) {
    return;
  }
  var id = this._getId(node);
  this._list[id] = util._extend(this._list[id], props);
};

Components.prototype.list = function() {
  var list = {};
  for (var i in this._list) {
    if (!this._list.hasOwnProperty(i) || this._list[i].confidence < 2) {
      continue;
    }
    list[i] = this._list[i];
  }
  return list;
};

Components.prototype.length = function() {
  var length = 0;
  for (var i in this._list) {
    if (!this._list.hasOwnProperty(i) || this._list[i].confidence < 2) {
      continue;
    }
    length++;
  }
  return length;
};

function componentRule(rule, context) {

  var pragma = pragmaUtil.getFromContext(context);
  var sourceCode = context.getSourceCode();
  var components = new Components();

  var utils = {

    isES5Component: function(node) {
      if (!node.parent) {
        return false;
      }
      return new RegExp('^(' + pragma + '\\.)?createClass$').test(sourceCode.getText(node.parent.callee));
    },

    isES6Component: function(node) {
      if (!node.superClass) {
        return false;
      }
      return new RegExp('^(' + pragma + '\\.)?Component$').test(sourceCode.getText(node.superClass));
    },

    isReturningJSX: function(node) {
      var property;
      switch (node.type) {
        case 'ReturnStatement':
          property = 'argument';
          break;
        case 'ArrowFunctionExpression':
          property = 'body';
          break;
        default:
          return false;
      }

      var returnsJSX =
        node[property] &&
        node[property].type === 'JSXElement'
      ;
      var returnsReactCreateElement =
        node[property] &&
        node[property].callee &&
        node[property].callee.property &&
        node[property].callee.property.name === 'createElement'
      ;

      return Boolean(returnsJSX || returnsReactCreateElement);
    },

    getParentComponent: function() {
      return (
        utils.getParentES6Component() ||
        utils.getParentES5Component() ||
        utils.getParentStatelessComponent()
      );
    },

    getParentES5Component: function() {
      var scope = context.getScope();
      while (scope) {
        var node = scope.block && scope.block.parent && scope.block.parent.parent;
        if (node && utils.isES5Component(node)) {
          return node;
        }
        scope = scope.upper;
      }
      return null;
    },

    getParentES6Component: function() {
      var scope = context.getScope();
      while (scope && scope.type !== 'class') {
        scope = scope.upper;
      }
      var node = scope && scope.block;
      if (!node || !utils.isES6Component(node)) {
        return null;
      }
      return node;
    },

    getParentStatelessComponent: function() {
      var scope = context.getScope();
      while (scope) {
        var node = scope.block;
        var isFunction = /Function/.test(node.type); // Ignore non functions
        var isNotMethod = !node.parent || node.parent.type !== 'MethodDefinition'; // Ignore classes methods
        var isNotArgument = !node.parent || node.parent.type !== 'CallExpression'; // Ignore arguments (callback, etc.)
        if (isFunction && isNotMethod && isNotArgument) {
          return node;
        }
        scope = scope.upper;
      }
      return null;
    },

    getRelatedComponent: function(node) {
      var i;
      var j;
      var k;
      var l;
      var componentPath = [];
      while (node) {
        if (node.property && node.property.type === 'Identifier') {
          componentPath.push(node.property.name);
        }
        if (node.object && node.object.type === 'Identifier') {
          componentPath.push(node.object.name);
        }
        node = node.object;
      }
      componentPath.reverse();

      var variableName = componentPath.shift();
      if (!variableName) {
        return null;
      }
      var variableInScope;
      var variables = variableUtil.variablesInScope(context);
      for (i = 0, j = variables.length; i < j; i++) {
        if (variables[i].name === variableName) {
          variableInScope = variables[i];
          break;
        }
      }
      if (!variableInScope) {
        return null;
      }

      var defInScope;
      var defs = variableInScope.defs;
      for (i = 0, j = defs.length; i < j; i++) {
        if (defs[i].type === 'ClassName' || defs[i].type === 'FunctionName' || defs[i].type === 'Variable') {
          defInScope = defs[i];
          break;
        }
      }
      if (!defInScope || !defInScope.node) {
        return null;
      }
      node = defInScope.node.init || defInScope.node;

      for (i = 0, j = componentPath.length; i < j; i++) {
        if (!node.properties) {
          continue;
        }
        for (k = 0, l = node.properties.length; k < l; k++) {
          if (node.properties[k].key.name === componentPath[i]) {
            node = node.properties[k];
            break;
          }
        }
        if (!node || !node.value) {
          return null;
        }
        node = node.value;
      }

      return components.get(node);
    }
  };

  var detectionInstructions = {
    ClassDeclaration: function(node) {
      if (!utils.isES6Component(node)) {
        return;
      }
      components.add(node, 2);
    },
Property: function(node) {
      node = node.kind == 'class' && utils.getParentComponent();
      if (!node) {
        return;
      }
      components.add(node, 2);
    },

    ObjectExpression: function(node) {
      if (!utils.isES5Component(node)) {
        return;
      }
      components.add(node, 2);
    },

    FunctionExpression: function(node) {
      node = utils.getParentComponent();
      if (!node) {
        return;
      }
      components.add(node, 1);
    },

    FunctionDeclaration: function(node) {
      node = utils.getParentComponent();
      if (!node) {
        return;
      }
      components.add(node, 1);
    },

    ArrowFunctionExpression: function(node) {
      node = utils.getParentComponent();
      if (!node) {
        return;
      }
      if (node.expression && utils.isReturningJSX(node)) {
        components.add(node, 2);
      } else {
        components.add(node, 1);
      }
    },

    ThisExpression: function(node) {
      node = utils.getParentComponent();
      if (!node || !/Function/.test(node.type)) {
        return;
      }
      components.add(node, 0);
    },

    BlockComment: function(node) {
      pragma = pragmaUtil.getFromNode(node) || pragma;
    },

    ReturnStatement: function(node) {
      if (!utils.isReturningJSX(node)) {
        return;
      }
      node = utils.getParentComponent();
      if (!node) {
        return;
      }
      components.add(node, 2);
    }
  };

  var ruleInstructions = rule(context, components, utils);
  var updatedRuleInstructions = util._extend({}, ruleInstructions);
  Object.keys(detectionInstructions).forEach(function(instruction) {
    updatedRuleInstructions[instruction] = function(node) {
      detectionInstructions[instruction](node);
      return ruleInstructions[instruction] ? ruleInstructions[instruction](node) : void 0;
    };
  });
  return updatedRuleInstructions;
}

Components.detect = function(rule) {
  return componentRule.bind(this, rule);
};

module.exports = Components;

},
   {"./pragma":"/node_modules/eslint-plugin-react/lib/util/pragma.js","./variable":"/node_modules/eslint-plugin-react/lib/util/variable.js","util":"/node_modules/browserify/node_modules/util/util.js"}],

"/node_modules/eslint-plugin-react/lib/util/pragma.js": [function(require,module,exports){
'use strict';

var JSX_ANNOTATION_REGEX = /^\*\s*@jsx\s+([^\s]+)/;

function getFromContext(context) {
  var pragma = 'React';
  if (context.settings.react && context.settings.react.pragma) {
    pragma = context.settings.react.pragma;
  } else if (context.options[0] && context.options[0].pragma) {
    pragma = context.options[0].pragma;
  }
  return pragma.split('.')[0];
}

function getFromNode(node) {
  var matches = JSX_ANNOTATION_REGEX.exec(node.value);
  if (!matches) {
    return false;
  }
  return matches[1].split('.')[0];
}

module.exports = {
  getFromContext: getFromContext,
  getFromNode: getFromNode
};

},
   {}],

"/node_modules/eslint-plugin-react/lib/util/variable.js": [function(require,module,exports){
'use strict';

function markVariableAsUsed(context, name) {
  var scope = context.getScope();
  var variables;
  var i;
  var len;
  var found = false;

  if (scope.type === 'global') {
    while (scope.childScopes.length) {
      scope = scope.childScopes[0];
    }
  }

  do {
    variables = scope.variables;
    for (i = 0, len = variables.length; i < len; i++) {
      if (variables[i].name === name) {
        variables[i].eslintUsed = true;
        found = true;
      }
    }
    scope = scope.upper;
  } while (scope);

  return found;
}

function findVariable(variables, name) {
  var i;
  var len;

  for (i = 0, len = variables.length; i < len; i++) {
    if (variables[i].name === name) {
      return true;
    }
  }

  return false;
}

function variablesInScope(context) {
  var scope = context.getScope();
  var variables = scope.variables;

  while (scope.type !== 'global') {
    scope = scope.upper;
    variables = scope.variables.concat(variables);
  }
  if (scope.childScopes.length) {
    variables = scope.childScopes[0].variables.concat(variables);
    if (scope.childScopes[0].childScopes.length) {
      variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
    }
  }

  return variables;
}

module.exports = {
  findVariable: findVariable,
  variablesInScope: variablesInScope,
  markVariableAsUsed: markVariableAsUsed
};

},
   {}],

"/node_modules/estraverse/estraverse.js": [function(require,module,exports){
(function clone(exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        objectCreate,
        objectKeys,
        BREAK,
        SKIP,
        REMOVE;

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    objectCreate = Object.create || (function () {
        function F() { }

        return function (o) {
            F.prototype = o;
            return new F();
        };
    })();

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function extend(to, from) {
        var keys = objectKeys(from), key, i, len;
        for (i = 0, len = keys.length; i < len; i += 1) {
            key = keys[i];
            to[key] = from[key];
        }
        return to;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        AssignmentPattern: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'superClass', 'body'],
        ClassExpression: ['id', 'superClass', 'body'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['exported', 'local'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: ['imported', 'local'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MetaProperty: ['meta', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        RestElement: [ 'argument' ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handler', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        if (!this.__current.path) {
            return null;
        }

        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    Controller.prototype.parents = function parents() {
        var i, iz, result;

        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = visitor.fallback === 'iteration';
        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        worklist = this.__worklist;
        leavelist = this.__leavelist;

        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = node.type || element.wrap;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = objectKeys(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                key = element.ref.key;
                parent = element.ref.parent;

                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        worklist = this.__worklist;
        leavelist = this.__leavelist;

        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = objectKeys(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = require('./package.json').version;
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}(exports));

},
   {"./package.json":"/node_modules/estraverse/package.json"}],

"/node_modules/estraverse/package.json": [function(require,module,exports){
module.exports={
  "name": "estraverse",
  "description": "ECMAScript JS AST traversal functions",
  "homepage": "https://github.com/estools/estraverse",
  "main": "estraverse.js",
  "version": "4.1.1",
  "engines": {
    "node": ">=0.10.0"
  },
  "maintainers": [
    {
      "name": "constellation",
      "email": "utatane.tea@gmail.com"
    },
    {
      "name": "michaelficarra",
      "email": "npm@michael.ficarra.me"
    },
    {
      "name": "nzakas",
      "email": "nicholas@nczconsulting.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/estools/estraverse.git"
  },
  "devDependencies": {
    "chai": "^2.1.1",
    "coffee-script": "^1.8.0",
    "espree": "^1.11.0",
    "gulp": "^3.8.10",
    "gulp-bump": "^0.2.2",
    "gulp-filter": "^2.0.0",
    "gulp-git": "^1.0.1",
    "gulp-tag-version": "^1.2.1",
    "jshint": "^2.5.6",
    "mocha": "^2.1.0"
  },
  "license": "BSD-2-Clause",
  "scripts": {
    "test": "npm run-script lint && npm run-script unit-test",
    "lint": "jshint estraverse.js",
    "unit-test": "mocha --compilers coffee:coffee-script/register"
  },
  "gitHead": "bbcccbfe98296585e4311c8755e1d00dcd581e3c",
  "bugs": {
    "url": "https://github.com/estools/estraverse/issues"
  },
  "_id": "estraverse@4.1.1",
  "_shasum": "f6caca728933a850ef90661d0e17982ba47111a2",
  "_from": "estraverse@>=4.1.1 <5.0.0",
  "_npmVersion": "2.14.4",
  "_nodeVersion": "4.1.1",
  "_npmUser": {
    "name": "constellation",
    "email": "utatane.tea@gmail.com"
  },
  "dist": {
    "shasum": "f6caca728933a850ef90661d0e17982ba47111a2",
    "tarball": "http://registry.npmjs.org/estraverse/-/estraverse-4.1.1.tgz"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.1.1.tgz",
  "readme": "ERROR: No README data found!"
}

},
   {}],

"/node_modules/esutils/lib/ast.js": [function(require,module,exports){
arguments[4]["/node_modules/doctrine/node_modules/esutils/lib/ast.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/esutils/lib/code.js": [function(require,module,exports){
(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    ES5Regex = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());

},
   {}],

"/node_modules/esutils/lib/keyword.js": [function(require,module,exports){
(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) { return false; }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) { return false; }

        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) { return false; }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());

},
   {"./code":"/node_modules/esutils/lib/code.js"}],

"/node_modules/esutils/lib/utils.js": [function(require,module,exports){
arguments[4]["/node_modules/doctrine/node_modules/esutils/lib/utils.js"][0].apply(exports,arguments)
},
   {"./ast":"/node_modules/esutils/lib/ast.js","./code":"/node_modules/esutils/lib/code.js","./keyword":"/node_modules/esutils/lib/keyword.js"}],

"/node_modules/globals/globals.json": [function(require,module,exports){
module.exports={
	"builtin": {
		"Array": false,
		"ArrayBuffer": false,
		"Boolean": false,
		"constructor": false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"System": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"es5": {
		"Array": false,
		"Boolean": false,
		"constructor": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"propertyIsEnumerable": false,
		"RangeError": false,
		"ReferenceError": false,
		"RegExp": false,
		"String": false,
		"SyntaxError": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false
	},
	"es6": {
		"Array": false,
		"ArrayBuffer": false,
		"Boolean": false,
		"constructor": false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"System": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"browser": {
		"addEventListener": false,
		"alert": false,
		"AnalyserNode": false,
		"AnimationEvent": false,
		"applicationCache": false,
		"ApplicationCache": false,
		"ApplicationCacheErrorEvent": false,
		"atob": false,
		"Attr": false,
		"Audio": false,
		"AudioBuffer": false,
		"AudioBufferSourceNode": false,
		"AudioContext": false,
		"AudioDestinationNode": false,
		"AudioListener": false,
		"AudioNode": false,
		"AudioParam": false,
		"AudioProcessingEvent": false,
		"AutocompleteErrorEvent": false,
		"BarProp": false,
		"BatteryManager": false,
		"BeforeUnloadEvent": false,
		"BiquadFilterNode": false,
		"Blob": false,
		"blur": false,
		"btoa": false,
		"Cache": false,
		"caches": false,
		"CacheStorage": false,
		"cancelAnimationFrame": false,
		"CanvasGradient": false,
		"CanvasPattern": false,
		"CanvasRenderingContext2D": false,
		"CDATASection": false,
		"ChannelMergerNode": false,
		"ChannelSplitterNode": false,
		"CharacterData": false,
		"clearInterval": false,
		"clearTimeout": false,
		"clientInformation": false,
		"ClientRect": false,
		"ClientRectList": false,
		"ClipboardEvent": false,
		"CloseEvent": false,
		"Comment": false,
		"CompositionEvent": false,
		"confirm": false,
		"console": false,
		"ConvolverNode": false,
		"crypto": false,
		"Crypto": false,
		"CryptoKey": false,
		"CSS": false,
		"CSSFontFaceRule": false,
		"CSSImportRule": false,
		"CSSKeyframeRule": false,
		"CSSKeyframesRule": false,
		"CSSMediaRule": false,
		"CSSPageRule": false,
		"CSSRule": false,
		"CSSRuleList": false,
		"CSSStyleDeclaration": false,
		"CSSStyleRule": false,
		"CSSStyleSheet": false,
		"CSSSupportsRule": false,
		"CSSUnknownRule": false,
		"CSSViewportRule": false,
		"CustomEvent": false,
		"DataTransfer": false,
		"DataTransferItem": false,
		"DataTransferItemList": false,
		"Debug": false,
		"defaultStatus": false,
		"defaultstatus": false,
		"DelayNode": false,
		"DeviceMotionEvent": false,
		"DeviceOrientationEvent": false,
		"devicePixelRatio": false,
		"dispatchEvent": false,
		"document": false,
		"Document": false,
		"DocumentFragment": false,
		"DocumentType": false,
		"DOMError": false,
		"DOMException": false,
		"DOMImplementation": false,
		"DOMParser": false,
		"DOMSettableTokenList": false,
		"DOMStringList": false,
		"DOMStringMap": false,
		"DOMTokenList": false,
		"DragEvent": false,
		"DynamicsCompressorNode": false,
		"Element": false,
		"ElementTimeControl": false,
		"ErrorEvent": false,
		"event": false,
		"Event": false,
		"EventSource": false,
		"EventTarget": false,
		"external": false,
		"fetch": false,
		"File": false,
		"FileError": false,
		"FileList": false,
		"FileReader": false,
		"FocusEvent": false,
		"FontFace": false,
		"FormData": false,
		"frameElement": false,
		"frames": false,
		"GainNode": false,
		"Gamepad": false,
		"GamepadButton": false,
		"GamepadEvent": false,
		"getComputedStyle": false,
		"getSelection": false,
		"HashChangeEvent": false,
		"Headers": false,
		"History": false,
		"HTMLAllCollection": false,
		"HTMLAnchorElement": false,
		"HTMLAppletElement": false,
		"HTMLAreaElement": false,
		"HTMLAudioElement": false,
		"HTMLBaseElement": false,
		"HTMLBlockquoteElement": false,
		"HTMLBodyElement": false,
		"HTMLBRElement": false,
		"HTMLButtonElement": false,
		"HTMLCanvasElement": false,
		"HTMLCollection": false,
		"HTMLContentElement": false,
		"HTMLDataListElement": false,
		"HTMLDetailsElement": false,
		"HTMLDialogElement": false,
		"HTMLDirectoryElement": false,
		"HTMLDivElement": false,
		"HTMLDListElement": false,
		"HTMLDocument": false,
		"HTMLElement": false,
		"HTMLEmbedElement": false,
		"HTMLFieldSetElement": false,
		"HTMLFontElement": false,
		"HTMLFormControlsCollection": false,
		"HTMLFormElement": false,
		"HTMLFrameElement": false,
		"HTMLFrameSetElement": false,
		"HTMLHeadElement": false,
		"HTMLHeadingElement": false,
		"HTMLHRElement": false,
		"HTMLHtmlElement": false,
		"HTMLIFrameElement": false,
		"HTMLImageElement": false,
		"HTMLInputElement": false,
		"HTMLIsIndexElement": false,
		"HTMLKeygenElement": false,
		"HTMLLabelElement": false,
		"HTMLLayerElement": false,
		"HTMLLegendElement": false,
		"HTMLLIElement": false,
		"HTMLLinkElement": false,
		"HTMLMapElement": false,
		"HTMLMarqueeElement": false,
		"HTMLMediaElement": false,
		"HTMLMenuElement": false,
		"HTMLMetaElement": false,
		"HTMLMeterElement": false,
		"HTMLModElement": false,
		"HTMLObjectElement": false,
		"HTMLOListElement": false,
		"HTMLOptGroupElement": false,
		"HTMLOptionElement": false,
		"HTMLOptionsCollection": false,
		"HTMLOutputElement": false,
		"HTMLParagraphElement": false,
		"HTMLParamElement": false,
		"HTMLPictureElement": false,
		"HTMLPreElement": false,
		"HTMLProgressElement": false,
		"HTMLQuoteElement": false,
		"HTMLScriptElement": false,
		"HTMLSelectElement": false,
		"HTMLShadowElement": false,
		"HTMLSourceElement": false,
		"HTMLSpanElement": false,
		"HTMLStyleElement": false,
		"HTMLTableCaptionElement": false,
		"HTMLTableCellElement": false,
		"HTMLTableColElement": false,
		"HTMLTableElement": false,
		"HTMLTableRowElement": false,
		"HTMLTableSectionElement": false,
		"HTMLTemplateElement": false,
		"HTMLTextAreaElement": false,
		"HTMLTitleElement": false,
		"HTMLTrackElement": false,
		"HTMLUListElement": false,
		"HTMLUnknownElement": false,
		"HTMLVideoElement": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBEnvironment": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"Image": false,
		"ImageBitmap": false,
		"ImageData": false,
		"indexedDB": false,
		"innerHeight": false,
		"innerWidth": false,
		"InputEvent": false,
		"InputMethodContext": false,
		"Intl": false,
		"KeyboardEvent": false,
		"length": false,
		"localStorage": false,
		"location": false,
		"Location": false,
		"locationbar": false,
		"matchMedia": false,
		"MediaElementAudioSourceNode": false,
		"MediaEncryptedEvent": false,
		"MediaError": false,
		"MediaKeyError": false,
		"MediaKeyEvent": false,
		"MediaKeyMessageEvent": false,
		"MediaKeys": false,
		"MediaKeySession": false,
		"MediaKeyStatusMap": false,
		"MediaKeySystemAccess": false,
		"MediaList": false,
		"MediaQueryList": false,
		"MediaQueryListEvent": false,
		"MediaSource": false,
		"MediaStreamAudioDestinationNode": false,
		"MediaStreamAudioSourceNode": false,
		"MediaStreamEvent": false,
		"MediaStreamTrack": false,
		"menubar": false,
		"MessageChannel": false,
		"MessageEvent": false,
		"MessagePort": false,
		"MIDIAccess": false,
		"MIDIConnectionEvent": false,
		"MIDIInput": false,
		"MIDIInputMap": false,
		"MIDIMessageEvent": false,
		"MIDIOutput": false,
		"MIDIOutputMap": false,
		"MIDIPort": false,
		"MimeType": false,
		"MimeTypeArray": false,
		"MouseEvent": false,
		"MutationEvent": false,
		"MutationObserver": false,
		"MutationRecord": false,
		"NamedNodeMap": false,
		"navigator": false,
		"Navigator": false,
		"Node": false,
		"NodeFilter": false,
		"NodeIterator": false,
		"NodeList": false,
		"Notification": false,
		"OfflineAudioCompletionEvent": false,
		"OfflineAudioContext": false,
		"offscreenBuffering": false,
		"onbeforeunload": true,
		"onblur": true,
		"onerror": true,
		"onfocus": true,
		"onload": true,
		"onresize": true,
		"onunload": true,
		"openDatabase": false,
		"Option": false,
		"OscillatorNode": false,
		"PageTransitionEvent": false,
		"pageXOffset": false,
		"pageYOffset": false,
		"Path2D": false,
		"performance": false,
		"Performance": false,
		"PerformanceEntry": false,
		"PerformanceMark": false,
		"PerformanceMeasure": false,
		"PerformanceNavigation": false,
		"PerformanceResourceTiming": false,
		"PerformanceTiming": false,
		"PeriodicWave": false,
		"Permissions": false,
		"PermissionStatus": false,
		"personalbar": false,
		"Plugin": false,
		"PluginArray": false,
		"PopStateEvent": false,
		"postMessage": false,
		"ProcessingInstruction": false,
		"ProgressEvent": false,
		"prompt": false,
		"PushManager": false,
		"PushSubscription": false,
		"RadioNodeList": false,
		"Range": false,
		"ReadableByteStream": false,
		"ReadableStream": false,
		"removeEventListener": false,
		"Request": false,
		"requestAnimationFrame": false,
		"Response": false,
		"RTCIceCandidate": false,
		"RTCSessionDescription": false,
		"Screen": false,
		"ScreenOrientation": false,
		"ScriptProcessorNode": false,
		"SecurityPolicyViolationEvent": false,
		"Selection": false,
		"ServiceWorker": false,
		"ServiceWorkerContainer": false,
		"ServiceWorkerRegistration": false,
		"sessionStorage": false,
		"setInterval": false,
		"setTimeout": false,
		"ShadowRoot": false,
		"SharedWorker": false,
		"showModalDialog": false,
		"speechSynthesis": false,
		"SpeechSynthesisEvent": false,
		"SpeechSynthesisUtterance": false,
		"Storage": false,
		"StorageEvent": false,
		"styleMedia": false,
		"StyleSheet": false,
		"StyleSheetList": false,
		"SubtleCrypto": false,
		"SVGAElement": false,
		"SVGAltGlyphDefElement": false,
		"SVGAltGlyphElement": false,
		"SVGAltGlyphItemElement": false,
		"SVGAngle": false,
		"SVGAnimateColorElement": false,
		"SVGAnimatedAngle": false,
		"SVGAnimatedBoolean": false,
		"SVGAnimatedEnumeration": false,
		"SVGAnimatedInteger": false,
		"SVGAnimatedLength": false,
		"SVGAnimatedLengthList": false,
		"SVGAnimatedNumber": false,
		"SVGAnimatedNumberList": false,
		"SVGAnimatedPathData": false,
		"SVGAnimatedPoints": false,
		"SVGAnimatedPreserveAspectRatio": false,
		"SVGAnimatedRect": false,
		"SVGAnimatedString": false,
		"SVGAnimatedTransformList": false,
		"SVGAnimateElement": false,
		"SVGAnimateMotionElement": false,
		"SVGAnimateTransformElement": false,
		"SVGAnimationElement": false,
		"SVGCircleElement": false,
		"SVGClipPathElement": false,
		"SVGColor": false,
		"SVGColorProfileElement": false,
		"SVGColorProfileRule": false,
		"SVGComponentTransferFunctionElement": false,
		"SVGCSSRule": false,
		"SVGCursorElement": false,
		"SVGDefsElement": false,
		"SVGDescElement": false,
		"SVGDiscardElement": false,
		"SVGDocument": false,
		"SVGElement": false,
		"SVGElementInstance": false,
		"SVGElementInstanceList": false,
		"SVGEllipseElement": false,
		"SVGEvent": false,
		"SVGExternalResourcesRequired": false,
		"SVGFEBlendElement": false,
		"SVGFEColorMatrixElement": false,
		"SVGFEComponentTransferElement": false,
		"SVGFECompositeElement": false,
		"SVGFEConvolveMatrixElement": false,
		"SVGFEDiffuseLightingElement": false,
		"SVGFEDisplacementMapElement": false,
		"SVGFEDistantLightElement": false,
		"SVGFEDropShadowElement": false,
		"SVGFEFloodElement": false,
		"SVGFEFuncAElement": false,
		"SVGFEFuncBElement": false,
		"SVGFEFuncGElement": false,
		"SVGFEFuncRElement": false,
		"SVGFEGaussianBlurElement": false,
		"SVGFEImageElement": false,
		"SVGFEMergeElement": false,
		"SVGFEMergeNodeElement": false,
		"SVGFEMorphologyElement": false,
		"SVGFEOffsetElement": false,
		"SVGFEPointLightElement": false,
		"SVGFESpecularLightingElement": false,
		"SVGFESpotLightElement": false,
		"SVGFETileElement": false,
		"SVGFETurbulenceElement": false,
		"SVGFilterElement": false,
		"SVGFilterPrimitiveStandardAttributes": false,
		"SVGFitToViewBox": false,
		"SVGFontElement": false,
		"SVGFontFaceElement": false,
		"SVGFontFaceFormatElement": false,
		"SVGFontFaceNameElement": false,
		"SVGFontFaceSrcElement": false,
		"SVGFontFaceUriElement": false,
		"SVGForeignObjectElement": false,
		"SVGGElement": false,
		"SVGGeometryElement": false,
		"SVGGlyphElement": false,
		"SVGGlyphRefElement": false,
		"SVGGradientElement": false,
		"SVGGraphicsElement": false,
		"SVGHKernElement": false,
		"SVGICCColor": false,
		"SVGImageElement": false,
		"SVGLangSpace": false,
		"SVGLength": false,
		"SVGLengthList": false,
		"SVGLinearGradientElement": false,
		"SVGLineElement": false,
		"SVGLocatable": false,
		"SVGMarkerElement": false,
		"SVGMaskElement": false,
		"SVGMatrix": false,
		"SVGMetadataElement": false,
		"SVGMissingGlyphElement": false,
		"SVGMPathElement": false,
		"SVGNumber": false,
		"SVGNumberList": false,
		"SVGPaint": false,
		"SVGPathElement": false,
		"SVGPathSeg": false,
		"SVGPathSegArcAbs": false,
		"SVGPathSegArcRel": false,
		"SVGPathSegClosePath": false,
		"SVGPathSegCurvetoCubicAbs": false,
		"SVGPathSegCurvetoCubicRel": false,
		"SVGPathSegCurvetoCubicSmoothAbs": false,
		"SVGPathSegCurvetoCubicSmoothRel": false,
		"SVGPathSegCurvetoQuadraticAbs": false,
		"SVGPathSegCurvetoQuadraticRel": false,
		"SVGPathSegCurvetoQuadraticSmoothAbs": false,
		"SVGPathSegCurvetoQuadraticSmoothRel": false,
		"SVGPathSegLinetoAbs": false,
		"SVGPathSegLinetoHorizontalAbs": false,
		"SVGPathSegLinetoHorizontalRel": false,
		"SVGPathSegLinetoRel": false,
		"SVGPathSegLinetoVerticalAbs": false,
		"SVGPathSegLinetoVerticalRel": false,
		"SVGPathSegList": false,
		"SVGPathSegMovetoAbs": false,
		"SVGPathSegMovetoRel": false,
		"SVGPatternElement": false,
		"SVGPoint": false,
		"SVGPointList": false,
		"SVGPolygonElement": false,
		"SVGPolylineElement": false,
		"SVGPreserveAspectRatio": false,
		"SVGRadialGradientElement": false,
		"SVGRect": false,
		"SVGRectElement": false,
		"SVGRenderingIntent": false,
		"SVGScriptElement": false,
		"SVGSetElement": false,
		"SVGStopElement": false,
		"SVGStringList": false,
		"SVGStylable": false,
		"SVGStyleElement": false,
		"SVGSVGElement": false,
		"SVGSwitchElement": false,
		"SVGSymbolElement": false,
		"SVGTests": false,
		"SVGTextContentElement": false,
		"SVGTextElement": false,
		"SVGTextPathElement": false,
		"SVGTextPositioningElement": false,
		"SVGTitleElement": false,
		"SVGTransform": false,
		"SVGTransformable": false,
		"SVGTransformList": false,
		"SVGTRefElement": false,
		"SVGTSpanElement": false,
		"SVGUnitTypes": false,
		"SVGURIReference": false,
		"SVGUseElement": false,
		"SVGViewElement": false,
		"SVGViewSpec": false,
		"SVGVKernElement": false,
		"SVGZoomAndPan": false,
		"SVGZoomEvent": false,
		"Text": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"TextEvent": false,
		"TextMetrics": false,
		"TextTrack": false,
		"TextTrackCue": false,
		"TextTrackCueList": false,
		"TextTrackList": false,
		"TimeEvent": false,
		"TimeRanges": false,
		"Touch": false,
		"TouchEvent": false,
		"TouchList": false,
		"TrackEvent": false,
		"TransitionEvent": false,
		"TreeWalker": false,
		"UIEvent": false,
		"URL": false,
		"ValidityState": false,
		"VTTCue": false,
		"WaveShaperNode": false,
		"WebGLActiveInfo": false,
		"WebGLBuffer": false,
		"WebGLContextEvent": false,
		"WebGLFramebuffer": false,
		"WebGLProgram": false,
		"WebGLRenderbuffer": false,
		"WebGLRenderingContext": false,
		"WebGLShader": false,
		"WebGLShaderPrecisionFormat": false,
		"WebGLTexture": false,
		"WebGLUniformLocation": false,
		"WebSocket": false,
		"WheelEvent": false,
		"window": false,
		"Window": false,
		"Worker": false,
		"XDomainRequest": false,
		"XMLDocument": false,
		"XMLHttpRequest": false,
		"XMLHttpRequestEventTarget": false,
		"XMLHttpRequestProgressEvent": false,
		"XMLHttpRequestUpload": false,
		"XMLSerializer": false,
		"XPathEvaluator": false,
		"XPathException": false,
		"XPathExpression": false,
		"XPathNamespace": false,
		"XPathNSResolver": false,
		"XPathResult": false,
		"XSLTProcessor": false
	},
	"worker": {
		"applicationCache": false,
		"atob": false,
		"Blob": false,
		"BroadcastChannel": false,
		"btoa": false,
		"Cache": false,
		"caches": false,
		"clearInterval": false,
		"clearTimeout": false,
		"close": true,
		"console": false,
		"fetch": false,
		"FileReaderSync": false,
		"FormData": false,
		"Headers": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"ImageData": false,
		"importScripts": true,
		"indexedDB": false,
		"location": false,
		"MessageChannel": false,
		"MessagePort": false,
		"name": false,
		"navigator": false,
		"Notification": false,
		"onclose": true,
		"onconnect": true,
		"onerror": true,
		"onlanguagechange": true,
		"onmessage": true,
		"onoffline": true,
		"ononline": true,
		"onrejectionhandled": true,
		"onunhandledrejection": true,
		"performance": false,
		"Performance": false,
		"PerformanceEntry": false,
		"PerformanceMark": false,
		"PerformanceMeasure": false,
		"PerformanceNavigation": false,
		"PerformanceResourceTiming": false,
		"PerformanceTiming": false,
		"postMessage": true,
		"Promise": false,
		"Request": false,
		"Response": false,
		"self": true,
		"ServiceWorkerRegistration": false,
		"setInterval": false,
		"setTimeout": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"URL": false,
		"WebSocket": false,
		"Worker": false,
		"XMLHttpRequest": false
	},
	"node": {
		"__dirname": false,
		"__filename": false,
		"arguments": false,
		"Buffer": false,
		"clearImmediate": false,
		"clearInterval": false,
		"clearTimeout": false,
		"console": false,
		"exports": true,
		"GLOBAL": false,
		"global": false,
		"module": false,
		"process": false,
		"require": false,
		"root": false,
		"setImmediate": false,
		"setInterval": false,
		"setTimeout": false
	},
	"commonjs": {
		"exports": true,
		"module": false,
		"require": false,
		"global": false
	},
	"amd": {
		"define": false,
		"require": false
	},
	"mocha": {
		"after": false,
		"afterEach": false,
		"before": false,
		"beforeEach": false,
		"context": false,
		"describe": false,
		"it": false,
		"mocha": false,
		"setup": false,
		"specify": false,
		"suite": false,
		"suiteSetup": false,
		"suiteTeardown": false,
		"teardown": false,
		"test": false,
		"xcontext": false,
		"xdescribe": false,
		"xit": false,
		"xspecify": false
	},
	"jasmine": {
		"afterAll": false,
		"afterEach": false,
		"beforeAll": false,
		"beforeEach": false,
		"describe": false,
		"expect": false,
		"fail": false,
		"fdescribe": false,
		"fit": false,
		"it": false,
		"jasmine": false,
		"pending": false,
		"runs": false,
		"spyOn": false,
		"waits": false,
		"waitsFor": false,
		"xdescribe": false,
		"xit": false
	},
	"jest": {
		"afterEach": false,
		"beforeEach": false,
		"describe": false,
		"expect": false,
		"it": false,
		"jest": false,
		"pit": false,
		"require": false,
		"xdescribe": false,
		"xit": false
	},
	"qunit": {
		"asyncTest": false,
		"deepEqual": false,
		"equal": false,
		"expect": false,
		"module": false,
		"notDeepEqual": false,
		"notEqual": false,
		"notOk": false,
		"notPropEqual": false,
		"notStrictEqual": false,
		"ok": false,
		"propEqual": false,
		"QUnit": false,
		"raises": false,
		"start": false,
		"stop": false,
		"strictEqual": false,
		"test": false,
		"throws": false
	},
	"phantomjs": {
		"console": true,
		"exports": true,
		"phantom": true,
		"require": true,
		"WebPage": true
	},
	"couch": {
		"emit": false,
		"exports": false,
		"getRow": false,
		"log": false,
		"module": false,
		"provides": false,
		"require": false,
		"respond": false,
		"send": false,
		"start": false,
		"sum": false
	},
	"rhino": {
		"defineClass": false,
		"deserialize": false,
		"gc": false,
		"help": false,
		"importClass": false,
		"importPackage": false,
		"java": false,
		"load": false,
		"loadClass": false,
		"Packages": false,
		"print": false,
		"quit": false,
		"readFile": false,
		"readUrl": false,
		"runCommand": false,
		"seal": false,
		"serialize": false,
		"spawn": false,
		"sync": false,
		"toint32": false,
		"version": false
	},
	"nashorn": {
		"__DIR__": false,
		"__FILE__": false,
		"__LINE__": false,
		"com": false,
		"edu": false,
		"exit": false,
		"Java": false,
		"java": false,
		"javafx": false,
		"JavaImporter": false,
		"javax": false,
		"JSAdapter": false,
		"load": false,
		"loadWithNewGlobal": false,
		"org": false,
		"Packages": false,
		"print": false,
		"quit": false
	},
	"wsh": {
		"ActiveXObject": true,
		"Enumerator": true,
		"GetObject": true,
		"ScriptEngine": true,
		"ScriptEngineBuildVersion": true,
		"ScriptEngineMajorVersion": true,
		"ScriptEngineMinorVersion": true,
		"VBArray": true,
		"WScript": true,
		"WSH": true,
		"XDomainRequest": true
	},
	"jquery": {
		"$": false,
		"jQuery": false
	},
	"yui": {
		"Y": false,
		"YUI": false,
		"YUI_config": false
	},
	"shelljs": {
		"cat": false,
		"cd": false,
		"chmod": false,
		"config": false,
		"cp": false,
		"dirs": false,
		"echo": false,
		"env": false,
		"error": false,
		"exec": false,
		"exit": false,
		"find": false,
		"grep": false,
		"ls": false,
		"ln": false,
		"mkdir": false,
		"mv": false,
		"popd": false,
		"pushd": false,
		"pwd": false,
		"rm": false,
		"sed": false,
		"target": false,
		"tempdir": false,
		"test": false,
		"which": false
	},
	"prototypejs": {
		"$": false,
		"$$": false,
		"$A": false,
		"$break": false,
		"$continue": false,
		"$F": false,
		"$H": false,
		"$R": false,
		"$w": false,
		"Abstract": false,
		"Ajax": false,
		"Autocompleter": false,
		"Builder": false,
		"Class": false,
		"Control": false,
		"Draggable": false,
		"Draggables": false,
		"Droppables": false,
		"Effect": false,
		"Element": false,
		"Enumerable": false,
		"Event": false,
		"Field": false,
		"Form": false,
		"Hash": false,
		"Insertion": false,
		"ObjectRange": false,
		"PeriodicalExecuter": false,
		"Position": false,
		"Prototype": false,
		"Scriptaculous": false,
		"Selector": false,
		"Sortable": false,
		"SortableObserver": false,
		"Sound": false,
		"Template": false,
		"Toggle": false,
		"Try": false
	},
	"meteor": {
		"$": false,
		"_": false,
		"Accounts": false,
		"App": false,
		"Assets": false,
		"Blaze": false,
		"check": false,
		"Cordova": false,
		"DDP": false,
		"DDPServer": false,
		"Deps": false,
		"EJSON": false,
		"Email": false,
		"HTTP": false,
		"Log": false,
		"Match": false,
		"Meteor": false,
		"Mongo": false,
		"MongoInternals": false,
		"Npm": false,
		"Package": false,
		"Plugin": false,
		"process": false,
		"Random": false,
		"ReactiveDict": false,
		"ReactiveVar": false,
		"Router": false,
		"Session": false,
		"share": false,
		"Spacebars": false,
		"Template": false,
		"Tinytest": false,
		"Tracker": false,
		"UI": false,
		"Utils": false,
		"WebApp": false,
		"WebAppInternals": false
	},
	"mongo": {
		"_isWindows": false,
		"_rand": false,
		"BulkWriteResult": false,
		"cat": false,
		"cd": false,
		"connect": false,
		"db": false,
		"getHostName": false,
		"getMemInfo": false,
		"hostname": false,
		"listFiles": false,
		"load": false,
		"ls": false,
		"md5sumFile": false,
		"mkdir": false,
		"Mongo": false,
		"ObjectId": false,
		"PlanCache": false,
		"print": false,
		"printjson": false,
		"pwd": false,
		"quit": false,
		"removeFile": false,
		"rs": false,
		"sh": false,
		"UUID": false,
		"version": false,
		"WriteResult": false
	},
	"applescript": {
		"$": false,
		"Application": false,
		"Automation": false,
		"console": false,
		"delay": false,
		"Library": false,
		"ObjC": false,
		"ObjectSpecifier": false,
		"Path": false,
		"Progress": false,
		"Ref": false
	},
	"serviceworker": {
		"caches": false,
		"Cache": false,
		"CacheStorage": false,
		"Client": false,
		"clients": false,
		"Clients": false,
		"ExtendableEvent": false,
		"ExtendableMessageEvent": false,
		"FetchEvent": false,
		"importScripts": false,
		"registration": false,
		"self": false,
		"ServiceWorker": false,
		"ServiceWorkerContainer": false,
		"ServiceWorkerGlobalScope": false,
		"ServiceWorkerMessageEvent": false,
		"ServiceWorkerRegistration": false,
		"skipWaiting": false,
		"WindowClient": false
	},
	"atomtest": {
		"advanceClock": false,
		"fakeClearInterval": false,
		"fakeClearTimeout": false,
		"fakeSetInterval": false,
		"fakeSetTimeout": false,
		"resetTimeouts": false,
		"waitsForPromise": false
	},
	"embertest": {
		"andThen": false,
		"click": false,
		"currentPath": false,
		"currentRouteName": false,
		"currentURL": false,
		"fillIn": false,
		"find": false,
		"findWithAssert": false,
		"keyEvent": false,
		"pauseTest": false,
		"triggerEvent": false,
		"visit": false
	},
	"protractor": {
		"$": false,
		"$$": false,
		"browser": false,
		"By": false,
		"by": false,
		"DartObject": false,
		"element": false,
		"protractor": false
	},
	"shared-node-browser": {
		"clearInterval": false,
		"clearTimeout": false,
		"console": false,
		"setInterval": false,
		"setTimeout": false
	},
	"webextensions": {
		"browser": false,
		"chrome": false,
		"opr": false
	},
	"greasemonkey": {
		"GM_addStyle": false,
		"GM_deleteValue": false,
		"GM_getResourceText": false,
		"GM_getResourceURL": false,
		"GM_getValue": false,
		"GM_info": false,
		"GM_listValues": false,
		"GM_log": false,
		"GM_openInTab": false,
		"GM_registerMenuCommand": false,
		"GM_setClipboard": false,
		"GM_setValue": false,
		"GM_xmlhttpRequest": false,
		"unsafeWindow": false
	}
}

},
   {}],

"/node_modules/globals/index.js": [function(require,module,exports){
module.exports = require('./globals.json');

},
   {"./globals.json":"/node_modules/globals/globals.json"}],

"/node_modules/is-my-json-valid/formats.js": [function(require,module,exports){
exports['date-time'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\d{2}:\d{2}:\d{2}(\.\d+)?([zZ]|[+-]\d{2}:\d{2})$/
exports['date'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/
exports['time'] = /^\d{2}:\d{2}:\d{2}$/
exports['email'] = /^\S+@\S+$/
exports['ip-address'] = exports['ipv4'] = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
exports['ipv6'] = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/
exports['uri'] = /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/
exports['color'] = /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/
exports['hostname'] = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]))*$/
exports['alpha'] = /^[a-zA-Z]+$/
exports['alphanumeric'] = /^[a-zA-Z0-9]+$/
exports['style'] = /\s*(.+?):\s*([^;]+);?/g
exports['phone'] = /^\+(?:[0-9] ?){6,14}[0-9]$/
exports['utc-millisec'] = /^[0-9]+(\.?[0-9]+)?$/

},
   {}],

"/node_modules/is-my-json-valid/index.js": [function(require,module,exports){
var genobj = require('generate-object-property')
var genfun = require('generate-function')
var jsonpointer = require('jsonpointer')
var xtend = require('xtend')
var formats = require('./formats')

var get = function(obj, additionalSchemas, ptr) {
  if (/^https?:\/\//.test(ptr)) return null

  var visit = function(sub) {
    if (sub && sub.id === ptr) return sub
    if (typeof sub !== 'object' || !sub) return null
    return Object.keys(sub).reduce(function(res, k) {
      return res || visit(sub[k])
    }, null)
  }

  var res = visit(obj)
  if (res) return res

  ptr = ptr.replace(/^#/, '')
  ptr = ptr.replace(/\/$/, '')

  try {
    return jsonpointer.get(obj, decodeURI(ptr))
  } catch (err) {
    var end = ptr.indexOf('#')
    var other
    if (end !== 0) {
      if (end === -1) {
        other = additionalSchemas[ptr]
      } else {
        var ext = ptr.slice(0, end)
        other = additionalSchemas[ext]
        var fragment = ptr.slice(end).replace(/^#/, '')
        try {
          return jsonpointer.get(other, fragment)
        } catch (err) {}
      }
    } else {
      other = additionalSchemas[ptr]
    }
    return other || null
  }
}

var formatName = function(field) {
  field = JSON.stringify(field)
  var pattern = /\[([^\[\]"]+)\]/
  while (pattern.test(field)) field = field.replace(pattern, '."+$1+"')
  return field
}

var types = {}

types.any = function() {
  return 'true'
}

types.null = function(name) {
  return name+' === null'
}

types.boolean = function(name) {
  return 'typeof '+name+' === "boolean"'
}

types.array = function(name) {
  return 'Array.isArray('+name+')'
}

types.object = function(name) {
  return 'typeof '+name+' === "object" && '+name+' && !Array.isArray('+name+')'
}

types.number = function(name) {
  return 'typeof '+name+' === "number"'
}

types.integer = function(name) {
  return 'typeof '+name+' === "number" && (Math.floor('+name+') === '+name+' || '+name+' > 9007199254740992 || '+name+' < -9007199254740992)'
}

types.string = function(name) {
  return 'typeof '+name+' === "string"'
}

var unique = function(array) {
  var list = []
  for (var i = 0; i < array.length; i++) {
    list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i])
  }
  for (var i = 1; i < list.length; i++) {
    if (list.indexOf(list[i]) !== i) return false
  }
  return true
}

var toType = function(node) {
  return node.type
}

var compile = function(schema, cache, root, reporter, opts) {
  var fmts = opts ? xtend(formats, opts.formats) : formats
  var scope = {unique:unique, formats:fmts}
  var verbose = opts ? !!opts.verbose : false;
  var greedy = opts && opts.greedy !== undefined ?
    opts.greedy : false;

  var syms = {}
  var gensym = function(name) {
    return name+(syms[name] = (syms[name] || 0)+1)
  }

  var reversePatterns = {}
  var patterns = function(p) {
    if (reversePatterns[p]) return reversePatterns[p]
    var n = gensym('pattern')
    scope[n] = new RegExp(p)
    reversePatterns[p] = n
    return n
  }

  var vars = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','x','y','z']
  var genloop = function() {
    var v = vars.shift()
    vars.push(v+v[0])
    return v
  }

  var visit = function(name, node, reporter, filter) {
    var properties = node.properties
    var type = node.type
    var tuple = false

    if (Array.isArray(node.items)) { // tuple type
      properties = {}
      node.items.forEach(function(item, i) {
        properties[i] = item
      })
      type = 'array'
      tuple = true
    }

    var indent = 0
    var error = function(msg, prop, value) {
      validate('errors++')
      if (reporter === true) {
        validate('if (validate.errors === null) validate.errors = []')
        if (verbose) {
          validate('validate.errors.push({field:%s,message:%s,value:%s})', formatName(prop || name), JSON.stringify(msg), value || name)
        } else {
          validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg))
        }
      }
    }

    if (node.required === true) {
      indent++
      validate('if (%s === undefined) {', name)
      error('is required')
      validate('} else {')
    } else {
      indent++
      validate('if (%s !== undefined) {', name)
    }

    var valid = [].concat(type)
      .map(function(t) {
        return types[t || 'any'](name)
      })
      .join(' || ') || 'true'

    if (valid !== 'true') {
      indent++
      validate('if (!(%s)) {', valid)
      error('is the wrong type')
      validate('} else {')
    }

    if (tuple) {
      if (node.additionalItems === false) {
        validate('if (%s.length > %d) {', name, node.items.length)
        error('has additional items')
        validate('}')
      } else if (node.additionalItems) {
        var i = genloop()
        validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i)
        visit(name+'['+i+']', node.additionalItems, reporter, filter)
        validate('}')
      }
    }

    if (node.format && fmts[node.format]) {
      if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name))
      var n = gensym('format')
      scope[n] = fmts[node.format]

      if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name)
      else validate('if (!%s.test(%s)) {', n, name)
      error('must be '+node.format+' format')
      validate('}')
      if (type !== 'string' && formats[node.format]) validate('}')
    }

    if (Array.isArray(node.required)) {
      var isUndefined = function(req) {
        return genobj(name, req) + ' === undefined'
      }

      var checkRequired = function (req) {
        var prop = genobj(name, req);
        validate('if (%s === undefined) {', prop)
        error('is required', prop)
        validate('missing++')
        validate('}')
      }
      validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true')
      validate('var missing = 0')
      node.required.map(checkRequired)
      validate('}');
      if (!greedy) {
        validate('if (missing === 0) {')
        indent++
      }
    }

    if (node.uniqueItems) {
      if (type !== 'array') validate('if (%s) {', types.array(name))
      validate('if (!(unique(%s))) {', name)
      error('must be unique')
      validate('}')
      if (type !== 'array') validate('}')
    }

    if (node.enum) {
      var complex = node.enum.some(function(e) {
        return typeof e === 'object'
      })

      var compare = complex ?
        function(e) {
          return 'JSON.stringify('+name+')'+' !== JSON.stringify('+JSON.stringify(e)+')'
        } :
        function(e) {
          return name+' !== '+JSON.stringify(e)
        }

      validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false')
      error('must be an enum value')
      validate('}')
    }

    if (node.dependencies) {
      if (type !== 'object') validate('if (%s) {', types.object(name))

      Object.keys(node.dependencies).forEach(function(key) {
        var deps = node.dependencies[key]
        if (typeof deps === 'string') deps = [deps]

        var exists = function(k) {
          return genobj(name, k) + ' !== undefined'
        }

        if (Array.isArray(deps)) {
          validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true')
          error('dependencies not set')
          validate('}')
        }
        if (typeof deps === 'object') {
          validate('if (%s !== undefined) {', genobj(name, key))
          visit(name, deps, reporter, filter)
          validate('}')
        }
      })

      if (type !== 'object') validate('}')
    }

    if (node.additionalProperties || node.additionalProperties === false) {
      if (type !== 'object') validate('if (%s) {', types.object(name))

      var i = genloop()
      var keys = gensym('keys')

      var toCompare = function(p) {
        return keys+'['+i+'] !== '+JSON.stringify(p)
      }

      var toTest = function(p) {
        return '!'+patterns(p)+'.test('+keys+'['+i+'])'
      }

      var additionalProp = Object.keys(properties || {}).map(toCompare)
        .concat(Object.keys(node.patternProperties || {}).map(toTest))
        .join(' && ') || 'true'

      validate('var %s = Object.keys(%s)', keys, name)
        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
          ('if (%s) {', additionalProp)

      if (node.additionalProperties === false) {
        if (filter) validate('delete %s', name+'['+keys+'['+i+']]')
        error('has additional properties', null, JSON.stringify(name+'.') + ' + ' + keys + '['+i+']')
      } else {
        visit(name+'['+keys+'['+i+']]', node.additionalProperties, reporter, filter)
      }

      validate
          ('}')
        ('}')

      if (type !== 'object') validate('}')
    }

    if (node.$ref) {
      var sub = get(root, opts && opts.schemas || {}, node.$ref)
      if (sub) {
        var fn = cache[node.$ref]
        if (!fn) {
          cache[node.$ref] = function proxy(data) {
            return fn(data)
          }
          fn = compile(sub, cache, root, false, opts)
        }
        var n = gensym('ref')
        scope[n] = fn
        validate('if (!(%s(%s))) {', n, name)
        error('referenced schema does not match')
        validate('}')
      }
    }

    if (node.not) {
      var prev = gensym('prev')
      validate('var %s = errors', prev)
      visit(name, node.not, false, filter)
      validate('if (%s === errors) {', prev)
      error('negative schema matches')
      validate('} else {')
        ('errors = %s', prev)
      ('}')
    }

    if (node.items && !tuple) {
      if (type !== 'array') validate('if (%s) {', types.array(name))

      var i = genloop()
      validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i)
      visit(name+'['+i+']', node.items, reporter, filter)
      validate('}')

      if (type !== 'array') validate('}')
    }

    if (node.patternProperties) {
      if (type !== 'object') validate('if (%s) {', types.object(name))
      var keys = gensym('keys')
      var i = genloop()
      validate
        ('var %s = Object.keys(%s)', keys, name)
        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)

      Object.keys(node.patternProperties).forEach(function(key) {
        var p = patterns(key)
        validate('if (%s.test(%s)) {', p, keys+'['+i+']')
        visit(name+'['+keys+'['+i+']]', node.patternProperties[key], reporter, filter)
        validate('}')
      })

      validate('}')
      if (type !== 'object') validate('}')
    }

    if (node.pattern) {
      var p = patterns(node.pattern)
      if (type !== 'string') validate('if (%s) {', types.string(name))
      validate('if (!(%s.test(%s))) {', p, name)
      error('pattern mismatch')
      validate('}')
      if (type !== 'string') validate('}')
    }

    if (node.allOf) {
      node.allOf.forEach(function(sch) {
        visit(name, sch, reporter, filter)
      })
    }

    if (node.anyOf && node.anyOf.length) {
      var prev = gensym('prev')

      node.anyOf.forEach(function(sch, i) {
        if (i === 0) {
          validate('var %s = errors', prev)
        } else {
          validate('if (errors !== %s) {', prev)
            ('errors = %s', prev)
        }
        visit(name, sch, false, false)
      })
      node.anyOf.forEach(function(sch, i) {
        if (i) validate('}')
      })
      validate('if (%s !== errors) {', prev)
      error('no schemas match')
      validate('}')
    }

    if (node.oneOf && node.oneOf.length) {
      var prev = gensym('prev')
      var passes = gensym('passes')

      validate
        ('var %s = errors', prev)
        ('var %s = 0', passes)

      node.oneOf.forEach(function(sch, i) {
        visit(name, sch, false, false)
        validate('if (%s === errors) {', prev)
          ('%s++', passes)
        ('} else {')
          ('errors = %s', prev)
        ('}')
      })

      validate('if (%s !== 1) {', passes)
      error('no (or more than one) schemas match')
      validate('}')
    }

    if (node.multipleOf !== undefined) {
      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))

      var factor = ((node.multipleOf | 0) !== node.multipleOf) ? Math.pow(10, node.multipleOf.toString().split('.').pop().length) : 1
      if (factor > 1) validate('if ((%d*%s) % %d) {', factor, name, factor*node.multipleOf)
      else validate('if (%s % %d) {', name, node.multipleOf)

      error('has a remainder')
      validate('}')

      if (type !== 'number' && type !== 'integer') validate('}')
    }

    if (node.maxProperties !== undefined) {
      if (type !== 'object') validate('if (%s) {', types.object(name))

      validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties)
      error('has more properties than allowed')
      validate('}')

      if (type !== 'object') validate('}')
    }

    if (node.minProperties !== undefined) {
      if (type !== 'object') validate('if (%s) {', types.object(name))

      validate('if (Object.keys(%s).length < %d) {', name, node.minProperties)
      error('has less properties than allowed')
      validate('}')

      if (type !== 'object') validate('}')
    }

    if (node.maxItems !== undefined) {
      if (type !== 'array') validate('if (%s) {', types.array(name))

      validate('if (%s.length > %d) {', name, node.maxItems)
      error('has more items than allowed')
      validate('}')

      if (type !== 'array') validate('}')
    }

    if (node.minItems !== undefined) {
      if (type !== 'array') validate('if (%s) {', types.array(name))

      validate('if (%s.length < %d) {', name, node.minItems)
      error('has less items than allowed')
      validate('}')

      if (type !== 'array') validate('}')
    }

    if (node.maxLength !== undefined) {
      if (type !== 'string') validate('if (%s) {', types.string(name))

      validate('if (%s.length > %d) {', name, node.maxLength)
      error('has longer length than allowed')
      validate('}')

      if (type !== 'string') validate('}')
    }

    if (node.minLength !== undefined) {
      if (type !== 'string') validate('if (%s) {', types.string(name))

      validate('if (%s.length < %d) {', name, node.minLength)
      error('has less length than allowed')
      validate('}')

      if (type !== 'string') validate('}')
    }

    if (node.minimum !== undefined) {
      validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum)
      error('is less than minimum')
      validate('}')
    }

    if (node.maximum !== undefined) {
      validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum)
      error('is more than maximum')
      validate('}')
    }

    if (properties) {
      Object.keys(properties).forEach(function(p) {
        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('if (%s !== null) {', name)

        visit(genobj(name, p), properties[p], reporter, filter)

        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('}')
      })
    }

    while (indent--) validate('}')
  }

  var validate = genfun
    ('function validate(data) {')
      ('validate.errors = null')
      ('var errors = 0')

  visit('data', schema, reporter, opts && opts.filter)

  validate
      ('return errors === 0')
    ('}')

  validate = validate.toFunction(scope)
  validate.errors = null

  if (Object.defineProperty) {
    Object.defineProperty(validate, 'error', {
      get: function() {
        if (!validate.errors) return ''
        return validate.errors.map(function(err) {
          return err.field + ' ' + err.message;
        }).join('\n')
      }
    })
  }

  validate.toJSON = function() {
    return schema
  }

  return validate
}

module.exports = function(schema, opts) {
  if (typeof schema === 'string') schema = JSON.parse(schema)
  return compile(schema, {}, schema, true, opts)
}

module.exports.filter = function(schema, opts) {
  var validate = module.exports(schema, xtend(opts, {filter: true}))
  return function(sch) {
    validate(sch)
    return sch
  }
}

},
   {"./formats":"/node_modules/is-my-json-valid/formats.js","generate-function":"/node_modules/is-my-json-valid/node_modules/generate-function/index.js","generate-object-property":"/node_modules/is-my-json-valid/node_modules/generate-object-property/index.js","jsonpointer":"/node_modules/is-my-json-valid/node_modules/jsonpointer/jsonpointer.js","xtend":"/node_modules/is-my-json-valid/node_modules/xtend/immutable.js"}],

"/node_modules/is-my-json-valid/node_modules/generate-function/index.js": [function(require,module,exports){
var util = require('util')

var INDENT_START = /[\{\[]/
var INDENT_END = /[\}\]]/

module.exports = function() {
  var lines = []
  var indent = 0

  var push = function(str) {
    var spaces = ''
    while (spaces.length < indent*2) spaces += '  '
    lines.push(spaces+str)
  }

  var line = function(fmt) {
    if (!fmt) return line

    if (INDENT_END.test(fmt.trim()[0]) && INDENT_START.test(fmt[fmt.length-1])) {
      indent--
      push(util.format.apply(util, arguments))
      indent++
      return line
    }
    if (INDENT_START.test(fmt[fmt.length-1])) {
      push(util.format.apply(util, arguments))
      indent++
      return line
    }
    if (INDENT_END.test(fmt.trim()[0])) {
      indent--
      push(util.format.apply(util, arguments))
      return line
    }

    push(util.format.apply(util, arguments))
    return line
  }

  line.toString = function() {
    return lines.join('\n')
  }

  line.toFunction = function(scope) {
    var src = 'return ('+line.toString()+')'

    var keys = Object.keys(scope || {}).map(function(key) {
      return key
    })

    var vals = keys.map(function(key) {
      return scope[key]
    })

    return Function.apply(null, keys.concat(src)).apply(null, vals)
  }

  if (arguments.length) line.apply(null, arguments)

  return line
}

},
   {"util":"/node_modules/browserify/node_modules/util/util.js"}],

"/node_modules/is-my-json-valid/node_modules/generate-object-property/index.js": [function(require,module,exports){
var isProperty = require('is-property')

var gen = function(obj, prop) {
  return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'
}

gen.valid = isProperty
gen.property = function (prop) {
 return isProperty(prop) ? prop : JSON.stringify(prop)
}

module.exports = gen

},
   {"is-property":"/node_modules/is-my-json-valid/node_modules/generate-object-property/node_modules/is-property/is-property.js"}],

"/node_modules/is-my-json-valid/node_modules/generate-object-property/node_modules/is-property/is-property.js": [function(require,module,exports){
"use strict"
function isProperty(str) {
  return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str)
}
module.exports = isProperty
},
   {}],

"/node_modules/is-my-json-valid/node_modules/jsonpointer/jsonpointer.js": [function(require,module,exports){
var untilde = function(str) {
  return str.replace(/~./g, function(m) {
    switch (m) {
      case "~0":
        return "~";
      case "~1":
        return "/";
    }
    throw new Error("Invalid tilde escape: " + m);
  });
}

var traverse = function(obj, pointer, value) {
  var part = untilde(pointer.shift());
  if(!obj.hasOwnProperty(part)) {
    return null;
  }
  if(pointer.length !== 0) { // keep traversin!
    return traverse(obj[part], pointer, value);
  }
  if(typeof value === "undefined") {
    return obj[part];
  }
  var old_value = obj[part];
  if(value === null) {
    delete obj[part];
  } else {
    obj[part] = value;
  }
  return old_value;
}

var validate_input = function(obj, pointer) {
  if(typeof obj !== "object") {
    throw new Error("Invalid input object.");
  }

  if(pointer === "") {
    return [];
  }

  if(!pointer) {
    throw new Error("Invalid JSON pointer.");
  }

  pointer = pointer.split("/");
  var first = pointer.shift();
  if (first !== "") {
    throw new Error("Invalid JSON pointer.");
  }

  return pointer;
}

var get = function(obj, pointer) {
  pointer = validate_input(obj, pointer);
  if (pointer.length === 0) {
    return obj;
  }
  return traverse(obj, pointer);
}

var set = function(obj, pointer, value) {
  pointer = validate_input(obj, pointer);
  if (pointer.length === 0) {
    throw new Error("Invalid JSON pointer for set.")
  }
  return traverse(obj, pointer, value);
}

exports.get = get
exports.set = set

},
   {}],

"/node_modules/is-my-json-valid/node_modules/xtend/immutable.js": [function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},
   {}],

"/node_modules/lodash/lodash.js": [function(require,module,exports){
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);
    exports.escapeRegExp = function escapeRegExp(string) {
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    exports.assign = Object.assign;
},
   {}],

"/node_modules/object-assign/index.js": [function(require,module,exports){
'use strict';
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},
   {}],

"/tmp/ast-utils.js": [function(require,module,exports){
"use strict";

var esutils = require("esutils");

var anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/;
var arrayOrTypedArrayPattern = /Array$/;
var arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;
var bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;
var breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/;
var thisTagPattern = /^[\s\*]*@this/m;

function isModifyingReference(reference, index, references) {
    var identifier = reference.identifier;

    return (identifier &&
        reference.init === false &&
        reference.isWrite() &&
        (index === 0 || references[index - 1].identifier !== identifier)
    );
}

function isES5Constructor(node) {
    return (
        node.id &&
        node.id.name[0] === node.id.name[0].toLocaleUpperCase()
    );
}

function getUpperFunction(node) {
    while (node) {
        if (anyFunctionPattern.test(node.type)) {
            return node;
        }
        node = node.parent;
    }
    return null;
}

function isNullOrUndefined(node) {
    return (
        (node.type === "Literal" && node.value === null) ||
        (node.type === "Identifier" && node.name === "undefined") ||
        (node.type === "UnaryExpression" && node.operator === "void")
    );
}

function isCallee(node) {
    return node.parent.type === "CallExpression" && node.parent.callee === node;
}

function isReflectApply(node) {
    return (
        node.type === "MemberExpression" &&
        node.object.type === "Identifier" &&
        node.object.name === "Reflect" &&
        node.property.type === "Identifier" &&
        node.property.name === "apply" &&
        node.computed === false
    );
}

function isArrayFromMethod(node) {
    return (
        node.type === "MemberExpression" &&
        node.object.type === "Identifier" &&
        arrayOrTypedArrayPattern.test(node.object.name) &&
        node.property.type === "Identifier" &&
        node.property.name === "from" &&
        node.computed === false
    );
}

function isMethodWhichHasThisArg(node) {
    while (node) {
        if (node.type === "Identifier") {
            return arrayMethodPattern.test(node.name);
        }
        if (node.type === "MemberExpression" && !node.computed) {
            node = node.property;
            continue;
        }

        break;
    }

    return false;
}

function hasJSDocThisTag(node, sourceCode) {
    var jsdocComment = sourceCode.getJSDocComment(node);
    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {
        return true;
    }

    return sourceCode.getComments(node).leading.some(function(comment) {
        return thisTagPattern.test(comment.value);
    });
}

module.exports = {

    isTokenOnSameLine: function(left, right) {
        return left.loc.end.line === right.loc.start.line;
    },

    isNullOrUndefined: isNullOrUndefined,
    isCallee: isCallee,
    isES5Constructor: isES5Constructor,
    getUpperFunction: getUpperFunction,
    isArrayFromMethod: isArrayFromMethod,

    isStringLiteral: function(node) {
        return (
            (node.type === "Literal" && typeof node.value === "string") ||
            node.type === "TemplateLiteral"
        );
    },

    isBreakableStatement: function(node) {
        return breakableTypePattern.test(node.type);
    },

    getLabel: function(node) {
        if (node.parent.type === "LabeledStatement") {
            return node.parent.label.name;
        }
        return null;
    },

    getModifyingReferences: function(references) {
        return references.filter(isModifyingReference);
    },

    isSurroundedBy: function(val, character) {
        return val[0] === character && val[val.length - 1] === character;
    },

    isDirectiveComment: function(node) {
        var comment = node.value.trim();
        return (
            node.type === "Line" && comment.indexOf("eslint-") === 0 ||
            node.type === "Block" && (
                comment.indexOf("global ") === 0 ||
                comment.indexOf("eslint ") === 0 ||
                comment.indexOf("eslint-") === 0
            )
        );
    },

    getTrailingStatement: esutils.ast.trailingStatement,

    getVariableByName: function(initScope, name) {
        var scope = initScope;
        while (scope) {
            var variable = scope.set.get(name);
            if (variable) {
                return variable;
            }

            scope = scope.upper;
        }

        return null;
    },

    isDefaultThisBinding: function(node, sourceCode) {
        if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {
            return false;
        }

        while (node) {
            var parent = node.parent;
            switch (parent.type) {
                case "LogicalExpression":
                case "ConditionalExpression":
                    node = parent;
                    break;

                case "ReturnStatement":
                    var func = getUpperFunction(parent);
                    if (func === null || !isCallee(func)) {
                        return true;
                    }
                    node = func.parent;
                    break;

                case "Property":
                    return false;

                case "AssignmentExpression":
                    return (
                        parent.right !== node ||
                        parent.left.type !== "MemberExpression"
                    );

                case "MethodDefinition":
                    return false;

                case "MemberExpression":
                    return (
                        parent.object !== node ||
                        parent.property.type !== "Identifier" ||
                        !bindOrCallOrApplyPattern.test(parent.property.name) ||
                        !isCallee(parent) ||
                        parent.parent.arguments.length === 0 ||
                        isNullOrUndefined(parent.parent.arguments[0])
                    );

                case "CallExpression":
                    if (isReflectApply(parent.callee)) {
                        return (
                            parent.arguments.length !== 3 ||
                            parent.arguments[0] !== node ||
                            isNullOrUndefined(parent.arguments[1])
                        );
                    }
                    if (isArrayFromMethod(parent.callee)) {
                        return (
                            parent.arguments.length !== 3 ||
                            parent.arguments[1] !== node ||
                            isNullOrUndefined(parent.arguments[2])
                        );
                    }
                    if (isMethodWhichHasThisArg(parent.callee)) {
                        return (
                            parent.arguments.length !== 2 ||
                            parent.arguments[0] !== node ||
                            isNullOrUndefined(parent.arguments[1])
                        );
                    }
                    return true;

                default:
                    return true;
            }
        }

        return true;
    }
};

},
   {"esutils":"/node_modules/esutils/lib/utils.js"}],

"/tmp/code-path-analysis/code-path-analyzer.js": [function(require,module,exports){
"use strict";

var assert = require("assert"),
    CodePath = require("./code-path"),
    CodePathSegment = require("./code-path-segment"),
    IdGenerator = require("./id-generator"),
    debug = require("./debug-helpers"),
    astUtils = require("../ast-utils");

function isCaseNode(node) {
    return Boolean(node.test);
}

function isForkingByTrueOrFalse(node) {
    var parent = node.parent;
    switch (parent.type) {
        case "ConditionalExpression":
        case "IfStatement":
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForStatement":
            return parent.test === node;

        case "LogicalExpression":
            return true;

        default:
            return false;
    }
}

function getBooleanValueIfSimpleConstant(node) {
    if (node.type === "Literal") {
        return Boolean(node.value);
    }
    return void 0;
}

function isIdentifierReference(node) {
    var parent = node.parent;

    switch (parent.type) {
        case "LabeledStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "ArrayPattern":
        case "RestElement":
        case "ImportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "CatchClause":
            return false;

        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
        case "ClassDeclaration":
        case "ClassExpression":
        case "VariableDeclarator":
            return parent.id !== node;

        case "Property":
        case "MethodDefinition":
            return (
                parent.key !== node ||
                parent.computed ||
                parent.shorthand
            );

        case "AssignmentPattern":
            return parent.key !== node;

        default:
            return true;
    }
}

function forwardCurrentToHead(analyzer, node) {
    var codePath = analyzer.codePath;
    var state = CodePath.getState(codePath);
    var currentSegments = state.currentSegments;
    var headSegments = state.headSegments;
    var end = Math.max(currentSegments.length, headSegments.length);
    var i, currentSegment, headSegment;

    for (i = 0; i < end; ++i) {
        currentSegment = currentSegments[i];
        headSegment = headSegments[i];

        if (currentSegment !== headSegment && currentSegment) {
            debug.dump("onCodePathSegmentEnd " + currentSegment.id);

            if (currentSegment.reachable) {
                analyzer.emitter.emit(
                    "onCodePathSegmentEnd",
                    currentSegment,
                    node);
            }
        }
    }

    state.currentSegments = headSegments;

    for (i = 0; i < end; ++i) {
        currentSegment = currentSegments[i];
        headSegment = headSegments[i];

        if (currentSegment !== headSegment && headSegment) {
            debug.dump("onCodePathSegmentStart " + headSegment.id);

            CodePathSegment.markUsed(headSegment);
            if (headSegment.reachable) {
                analyzer.emitter.emit(
                    "onCodePathSegmentStart",
                    headSegment,
                    node);
            }
        }
    }

}

function leaveFromCurrentSegment(analyzer, node) {
    var state = CodePath.getState(analyzer.codePath);
    var currentSegments = state.currentSegments;

    for (var i = 0; i < currentSegments.length; ++i) {
        var currentSegment = currentSegments[i];

        debug.dump("onCodePathSegmentEnd " + currentSegment.id);
        if (currentSegment.reachable) {
            analyzer.emitter.emit(
                "onCodePathSegmentEnd",
                currentSegment,
                node);
        }
    }
    state.currentSegments = [];
}

function preprocess(analyzer, node) {
    var codePath = analyzer.codePath;
    var state = CodePath.getState(codePath);
    var parent = node.parent;

    switch (parent.type) {
        case "LogicalExpression":
            if (parent.right === node) {
                state.makeLogicalRight();
            }
            break;

        case "ConditionalExpression":
        case "IfStatement":
            if (parent.consequent === node) {
                state.makeIfConsequent();
            } else if (parent.alternate === node) {
                state.makeIfAlternate();
            }
            break;

        case "SwitchCase":
            if (parent.consequent[0] === node) {
                state.makeSwitchCaseBody(false, !parent.test);
            }
            break;

        case "TryStatement":
            if (parent.handler === node) {
                state.makeCatchBlock();
            } else if (parent.finalizer === node) {
                state.makeFinallyBlock();
            }
            break;

        case "WhileStatement":
            if (parent.test === node) {
                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));
            } else {
                assert(parent.body === node);
                state.makeWhileBody();
            }
            break;

        case "DoWhileStatement":
            if (parent.body === node) {
                state.makeDoWhileBody();
            } else {
                assert(parent.test === node);
                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));
            }
            break;

        case "ForStatement":
            if (parent.test === node) {
                state.makeForTest(getBooleanValueIfSimpleConstant(node));
            } else if (parent.update === node) {
                state.makeForUpdate();
            } else if (parent.body === node) {
                state.makeForBody();
            }
            break;

        case "ForInStatement":
        case "ForOfStatement":
            if (parent.left === node) {
                state.makeForInOfLeft();
            } else if (parent.right === node) {
                state.makeForInOfRight();
            } else {
                assert(parent.body === node);
                state.makeForInOfBody();
            }
            break;

        case "AssignmentPattern":
            if (parent.right === node) {
                state.pushForkContext();
                state.forkBypassPath();
                state.forkPath();
            }
            break;

        default:
            break;
    }
}

function processCodePathToEnter(analyzer, node) {
    var codePath = analyzer.codePath;
    var state = codePath && CodePath.getState(codePath);
    var parent = node.parent;

    switch (node.type) {
        case "Program":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
            if (codePath) {
                forwardCurrentToHead(analyzer, node);
                debug.dumpState(node, state, false);
            }

            codePath = analyzer.codePath = new CodePath(
                analyzer.idGenerator.next(),
                codePath,
                analyzer.onLooped
            );
            state = CodePath.getState(codePath);

            debug.dump("onCodePathStart " + codePath.id);
            analyzer.emitter.emit("onCodePathStart", codePath, node);
            break;

        case "LogicalExpression":
            state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));
            break;

        case "ConditionalExpression":
        case "IfStatement":
            state.pushChoiceContext("test", false);
            break;

        case "SwitchStatement":
            state.pushSwitchContext(
                node.cases.some(isCaseNode),
                astUtils.getLabel(node));
            break;

        case "TryStatement":
            state.pushTryContext(Boolean(node.finalizer));
            break;

        case "SwitchCase":
            if (parent.discriminant !== node && parent.cases[0] !== node) {
                state.forkPath();
            }
            break;

        case "WhileStatement":
        case "DoWhileStatement":
        case "ForStatement":
        case "ForInStatement":
        case "ForOfStatement":
            state.pushLoopContext(node.type, astUtils.getLabel(node));
            break;

        case "LabeledStatement":
            if (!astUtils.isBreakableStatement(node.body)) {
                state.pushBreakContext(false, node.label.name);
            }
            break;

        default:
            break;
    }

    forwardCurrentToHead(analyzer, node);
    debug.dumpState(node, state, false);
}

function processCodePathToExit(analyzer, node) {
    var codePath = analyzer.codePath;
    var state = CodePath.getState(codePath);
    var dontForward = false;

    switch (node.type) {
        case "IfStatement":
        case "ConditionalExpression":
        case "LogicalExpression":
            state.popChoiceContext();
            break;

        case "SwitchStatement":
            state.popSwitchContext();
            break;

        case "SwitchCase":
            if (node.consequent.length === 0) {
                state.makeSwitchCaseBody(true, !node.test);
            }
            if (state.forkContext.reachable) {
                dontForward = true;
            }
            break;

        case "TryStatement":
            state.popTryContext();
            break;

        case "BreakStatement":
            forwardCurrentToHead(analyzer, node);
            state.makeBreak(node.label && node.label.name);
            dontForward = true;
            break;

        case "ContinueStatement":
            forwardCurrentToHead(analyzer, node);
            state.makeContinue(node.label && node.label.name);
            dontForward = true;
            break;

        case "ReturnStatement":
            forwardCurrentToHead(analyzer, node);
            state.makeReturn();
            dontForward = true;
            break;

        case "ThrowStatement":
            forwardCurrentToHead(analyzer, node);
            state.makeThrow();
            dontForward = true;
            break;

        case "Identifier":
            if (isIdentifierReference(node)) {
                state.makeFirstThrowablePathInTryBlock();
                dontForward = true;
            }
            break;

        case "CallExpression":
        case "MemberExpression":
        case "NewExpression":
            state.makeFirstThrowablePathInTryBlock();
            break;

        case "WhileStatement":
        case "DoWhileStatement":
        case "ForStatement":
        case "ForInStatement":
        case "ForOfStatement":
            state.popLoopContext();
            break;

        case "AssignmentPattern":
            state.popForkContext();
            break;

        case "LabeledStatement":
            if (!astUtils.isBreakableStatement(node.body)) {
                state.popBreakContext();
            }
            break;

        default:
            break;
    }

    if (!dontForward && (!node.parent || node.type !== node.parent.type)) {
        forwardCurrentToHead(analyzer, node);
    }
    debug.dumpState(node, state, true);
}

function postprocess(analyzer, node) {
    switch (node.type) {
        case "Program":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
            var codePath = analyzer.codePath;

            CodePath.getState(codePath).makeFinal();

            leaveFromCurrentSegment(analyzer, node);

            debug.dump("onCodePathEnd " + codePath.id);
            analyzer.emitter.emit("onCodePathEnd", codePath, node);
            debug.dumpDot(codePath);

            codePath = analyzer.codePath = analyzer.codePath.upper;
            if (codePath) {
                debug.dumpState(node, CodePath.getState(codePath), true);
            }
            break;

        default:
            break;
    }
}

function CodePathAnalyzer(eventGenerator) {
    this.original = eventGenerator;
    this.emitter = eventGenerator.emitter;
    this.codePath = null;
    this.idGenerator = new IdGenerator("s");
    this.currentNode = null;
    this.onLooped = this.onLooped.bind(this);
}

CodePathAnalyzer.prototype = {
    constructor: CodePathAnalyzer,

    enterNode: function(node) {
        this.currentNode = node;

        if (node.parent) {
            preprocess(this, node);
        }

        processCodePathToEnter(this, node);

        this.original.enterNode(node);

        this.currentNode = null;
    },

    leaveNode: function(node) {
        this.currentNode = node;

        processCodePathToExit(this, node);

        this.original.leaveNode(node);

        postprocess(this, node);

        this.currentNode = null;
    },

    onLooped: function(fromSegment, toSegment) {
        if (fromSegment.reachable && toSegment.reachable) {
            debug.dump("onCodePathSegmentLoop " + fromSegment.id + " -> " + toSegment.id);
            this.emitter.emit(
                "onCodePathSegmentLoop",
                fromSegment,
                toSegment,
                this.currentNode
            );
        }
    }
};

module.exports = CodePathAnalyzer;

},
   {"../ast-utils":"/tmp/ast-utils.js","./code-path":"/tmp/code-path-analysis/code-path.js","./code-path-segment":"/tmp/code-path-analysis/code-path-segment.js","./debug-helpers":"/tmp/code-path-analysis/debug-helpers.js","./id-generator":"/tmp/code-path-analysis/id-generator.js","assert":"/node_modules/browserify/node_modules/assert/assert.js"}],

"/tmp/code-path-analysis/code-path-segment.js": [function(require,module,exports){
"use strict";

var assert = require("assert"),
    debug = require("./debug-helpers");

function flattenUnusedSegments(segments) {
    var done = Object.create(null);
    var retv = [];

    for (var i = 0; i < segments.length; ++i) {
        var segment = segments[i];

        if (done[segment.id]) {
            continue;
        }

        if (!segment.internal.used) {
            for (var j = 0; j < segment.allPrevSegments.length; ++j) {
                var prevSegment = segment.allPrevSegments[j];

                if (!done[prevSegment.id]) {
                    done[prevSegment.id] = true;
                    retv.push(prevSegment);
                }
            }
        } else {
            done[segment.id] = true;
            retv.push(segment);
        }
    }

    return retv;
}

function isReachable(segment) {
    return segment.reachable;
}

function CodePathSegment(id, allPrevSegments, reachable) {
    this.id = id;

    this.nextSegments = [];

    this.prevSegments = allPrevSegments.filter(isReachable);

    this.allNextSegments = [];

    this.allPrevSegments = allPrevSegments;

    this.reachable = reachable;

    Object.defineProperty(this, "internal", {value: {
        used: false,
        loopedPrevSegments: []
    }});

    if (debug.enabled) {
        this.internal.nodes = [];
        this.internal.exitNodes = [];
    }
}

CodePathSegment.prototype = {
    constructor: CodePathSegment,

    isLoopedPrevSegment: function(segment) {
        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;
    }
};

CodePathSegment.newRoot = function(id) {
    return new CodePathSegment(id, [], true);
};

CodePathSegment.newNext = function(id, allPrevSegments) {
    return new CodePathSegment(
        id,
        flattenUnusedSegments(allPrevSegments),
        allPrevSegments.some(isReachable));
};

CodePathSegment.newUnreachable = function(id, allPrevSegments) {
    return new CodePathSegment(id, flattenUnusedSegments(allPrevSegments), false);
};

CodePathSegment.newDisconnected = function(id, allPrevSegments) {
    return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
};

CodePathSegment.markUsed = function(segment) {
    assert(!segment.internal.used, segment.id + " is marked twice.");
    segment.internal.used = true;

    var i;
    if (segment.reachable) {
        for (i = 0; i < segment.allPrevSegments.length; ++i) {
            var prevSegment = segment.allPrevSegments[i];

            prevSegment.allNextSegments.push(segment);
            prevSegment.nextSegments.push(segment);
        }
    } else {
        for (i = 0; i < segment.allPrevSegments.length; ++i) {
            segment.allPrevSegments[i].allNextSegments.push(segment);
        }
    }
};

CodePathSegment.markPrevSegmentAsLooped = function(segment, prevSegment) {
    segment.internal.loopedPrevSegments.push(prevSegment);
};

module.exports = CodePathSegment;

},
   {"./debug-helpers":"/tmp/code-path-analysis/debug-helpers.js","assert":"/node_modules/browserify/node_modules/assert/assert.js"}],

"/tmp/code-path-analysis/code-path-state.js": [function(require,module,exports){
"use strict";

var CodePathSegment = require("./code-path-segment"),
    ForkContext = require("./fork-context");

function addToReturnedOrThrown(dest, others, all, segments) {
    for (var i = 0; i < segments.length; ++i) {
        var segment = segments[i];

        dest.push(segment);
        if (others.indexOf(segment) === -1) {
            all.push(segment);
        }
    }
}

function getContinueContext(state, label) {
    if (!label) {
        return state.loopContext;
    }

    var context = state.loopContext;
    while (context) {
        if (context.label === label) {
            return context;
        }
        context = context.upper;
    }

    return null;
}

function getBreakContext(state, label) {
    var context = state.breakContext;
    while (context) {
        if (label ? context.label === label : context.breakable) {
            return context;
        }
        context = context.upper;
    }

    return null;
}

function getReturnContext(state) {
    var context = state.tryContext;
    while (context) {
        if (context.hasFinalizer && context.position !== "finally") {
            return context;
        }
        context = context.upper;
    }

    return state;
}

function getThrowContext(state) {
    var context = state.tryContext;
    while (context) {
        if (context.position === "try" ||
            (context.hasFinalizer && context.position === "catch")
        ) {
            return context;
        }
        context = context.upper;
    }

    return state;
}

function remove(xs, x) {
    xs.splice(xs.indexOf(x), 1);
}

function removeConnection(prevSegments, nextSegments) {
    for (var i = 0; i < prevSegments.length; ++i) {
        var prevSegment = prevSegments[i];
        var nextSegment = nextSegments[i];

        remove(prevSegment.nextSegments, nextSegment);
        remove(prevSegment.allNextSegments, nextSegment);
        remove(nextSegment.prevSegments, prevSegment);
        remove(nextSegment.allPrevSegments, prevSegment);
    }
}

function makeLooped(state, fromSegments, toSegments) {
    var end = Math.min(fromSegments.length, toSegments.length);
    for (var i = 0; i < end; ++i) {
        var fromSegment = fromSegments[i];
        var toSegment = toSegments[i];

        if (toSegment.reachable) {
            fromSegment.nextSegments.push(toSegment);
        }
        if (fromSegment.reachable) {
            toSegment.prevSegments.push(fromSegment);
        }
        fromSegment.allNextSegments.push(toSegment);
        toSegment.allPrevSegments.push(fromSegment);

        if (toSegment.allPrevSegments.length >= 2) {
            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
        }

        state.notifyLooped(fromSegment, toSegment);
    }
}

function finalizeTestSegmentsOfFor(context, choiceContext, head) {
    if (!choiceContext.processed) {
        choiceContext.trueForkContext.add(head);
        choiceContext.falseForkContext.add(head);
    }

    if (context.test !== true) {
        context.brokenForkContext.addAll(choiceContext.falseForkContext);
    }
    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
}

function CodePathState(idGenerator, onLooped) {
    this.idGenerator = idGenerator;
    this.notifyLooped = onLooped;
    this.forkContext = ForkContext.newRoot(idGenerator);
    this.choiceContext = null;
    this.switchContext = null;
    this.tryContext = null;
    this.loopContext = null;
    this.breakContext = null;

    this.currentSegments = [];
    this.initialSegment = this.forkContext.head[0];

    var final = this.finalSegments = [];
    var returned = this.returnedForkContext = [];
    var thrown = this.thrownForkContext = [];
    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
}

CodePathState.prototype = {
    constructor: CodePathState,

    get headSegments() {
        return this.forkContext.head;
    },

    get parentForkContext() {
        var current = this.forkContext;
        return current && current.upper;
    },

    pushForkContext: function(forkLeavingPath) {
        this.forkContext = ForkContext.newEmpty(
            this.forkContext,
            forkLeavingPath
        );

        return this.forkContext;
    },

    popForkContext: function() {
        var lastContext = this.forkContext;

        this.forkContext = lastContext.upper;
        this.forkContext.replaceHead(lastContext.makeNext(0, -1));

        return lastContext;
    },

    forkPath: function() {
        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
    },

    forkBypassPath: function() {
        this.forkContext.add(this.parentForkContext.head);
    },

    pushChoiceContext: function(kind, isForkingAsResult) {
        this.choiceContext = {
            upper: this.choiceContext,
            kind: kind,
            isForkingAsResult: isForkingAsResult,
            trueForkContext: ForkContext.newEmpty(this.forkContext),
            falseForkContext: ForkContext.newEmpty(this.forkContext),
            processed: false
        };
    },

    popChoiceContext: function() {
        var context = this.choiceContext;
        this.choiceContext = context.upper;

        var forkContext = this.forkContext;
        var headSegments = forkContext.head;

        switch (context.kind) {
            case "&&":
            case "||":
                if (!context.processed) {
                    context.trueForkContext.add(headSegments);
                    context.falseForkContext.add(headSegments);
                }

                if (context.isForkingAsResult) {
                    var parentContext = this.choiceContext;
                    parentContext.trueForkContext.addAll(context.trueForkContext);
                    parentContext.falseForkContext.addAll(context.falseForkContext);
                    parentContext.processed = true;

                    return context;
                }
                break;

            case "test":
                if (!context.processed) {
                    context.trueForkContext.clear();
                    context.trueForkContext.add(headSegments);
                } else {
                    context.falseForkContext.clear();
                    context.falseForkContext.add(headSegments);
                }
                break;

            case "loop":
                return context;

            default:
                throw new Error("unreachable");
        }

        var prevForkContext = context.trueForkContext;
        prevForkContext.addAll(context.falseForkContext);
        forkContext.replaceHead(prevForkContext.makeNext(0, -1));

        return context;
    },

    makeLogicalRight: function() {
        var context = this.choiceContext;
        var forkContext = this.forkContext;

        if (context.processed) {
            var prevForkContext =
                context.kind === "&&" ? context.trueForkContext :
                context.falseForkContext;

            forkContext.replaceHead(prevForkContext.makeNext(0, -1));
            prevForkContext.clear();

            context.processed = false;
        } else {
            if (context.kind === "&&") {
                context.falseForkContext.add(forkContext.head);
            } else {
                context.trueForkContext.add(forkContext.head);
            }

            forkContext.replaceHead(forkContext.makeNext(-1, -1));
        }
    },

    makeIfConsequent: function() {
        var context = this.choiceContext;
        var forkContext = this.forkContext;

        if (!context.processed) {
            context.trueForkContext.add(forkContext.head);
            context.falseForkContext.add(forkContext.head);
        }
        context.processed = false;

        forkContext.replaceHead(
            context.trueForkContext.makeNext(0, -1)
        );
    },

    makeIfAlternate: function() {
        var context = this.choiceContext;
        var forkContext = this.forkContext;

        context.trueForkContext.clear();
        context.trueForkContext.add(forkContext.head);
        context.processed = true;

        forkContext.replaceHead(
            context.falseForkContext.makeNext(0, -1)
        );
    },

    pushSwitchContext: function(hasCase, label) {
        this.switchContext = {
            upper: this.switchContext,
            hasCase: hasCase,
            defaultSegments: null,
            defaultBodySegments: null,
            foundDefault: false,
            lastIsDefault: false,
            countForks: 0
        };
        this.pushBreakContext(true, label);
    },

    popSwitchContext: function() {
        var context = this.switchContext;
        this.switchContext = context.upper;

        var forkContext = this.forkContext;
        var brokenForkContext = this.popBreakContext().brokenForkContext;

        if (context.countForks === 0) {
            if (!brokenForkContext.empty) {
                brokenForkContext.add(forkContext.makeNext(-1, -1));
                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
            }
            return;
        }

        var lastSegments = forkContext.head;
        this.forkBypassPath();
        var lastCaseSegments = forkContext.head;

        brokenForkContext.add(lastSegments);

        if (!context.lastIsDefault) {
            if (context.defaultBodySegments) {
                removeConnection(context.defaultSegments, context.defaultBodySegments);
                makeLooped(this, lastCaseSegments, context.defaultBodySegments);
            } else {
                brokenForkContext.add(lastCaseSegments);
            }
        }

        for (var i = 0; i < context.countForks; ++i) {
            this.forkContext = this.forkContext.upper;
        }
        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
    },

    makeSwitchCaseBody: function(isEmpty, isDefault) {
        var context = this.switchContext;
        if (!context.hasCase) {
            return;
        }

        var parentForkContext = this.forkContext;
        var forkContext = this.pushForkContext();
        forkContext.add(parentForkContext.makeNext(0, -1));

        if (isDefault) {
            context.defaultSegments = parentForkContext.head;
            if (isEmpty) {
                context.foundDefault = true;
            } else {
                context.defaultBodySegments = forkContext.head;
            }
        } else {
            if (!isEmpty && context.foundDefault) {
                context.foundDefault = false;
                context.defaultBodySegments = forkContext.head;
            }
        }
        context.lastIsDefault = isDefault;
        context.countForks += 1;
    },

    pushTryContext: function(hasFinalizer) {
        this.tryContext = {
            upper: this.tryContext,
            position: "try",
            hasFinalizer: hasFinalizer,
            returnedForkContext: hasFinalizer
                ? ForkContext.newEmpty(this.forkContext)
                : null,
            thrownForkContext: ForkContext.newEmpty(this.forkContext),
            lastOfTryIsReachable: false,
            lastOfCatchIsReachable: false
        };
    },

    popTryContext: function() {
        var context = this.tryContext;
        this.tryContext = context.upper;

        if (context.position === "catch") {
            this.popForkContext();
            return;
        }
        var returned = context.returnedForkContext;
        var thrown = context.thrownForkContext;
        if (returned.empty && thrown.empty) {
            return;
        }

        var headSegments = this.forkContext.head;
        this.forkContext = this.forkContext.upper;
        var normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);
        var leavingSegments = headSegments.slice(headSegments.length / 2 | 0);

        if (!returned.empty) {
            getReturnContext(this).returnedForkContext.add(leavingSegments);
        }
        if (!thrown.empty) {
            getThrowContext(this).thrownForkContext.add(leavingSegments);
        }

        this.forkContext.replaceHead(normalSegments);

        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {
            this.forkContext.makeUnreachable();
        }
    },

    makeCatchBlock: function() {
        var context = this.tryContext;
        var forkContext = this.forkContext;
        var thrown = context.thrownForkContext;

        context.position = "catch";
        context.thrownForkContext = ForkContext.newEmpty(forkContext);
        context.lastOfTryIsReachable = forkContext.reachable;

        thrown.add(forkContext.head);
        var thrownSegments = thrown.makeNext(0, -1);

        this.pushForkContext();
        this.forkBypassPath();
        this.forkContext.add(thrownSegments);
    },

    makeFinallyBlock: function() {
        var context = this.tryContext;
        var forkContext = this.forkContext;
        var returned = context.returnedForkContext;
        var thrown = context.thrownForkContext;
        var headOfLeavingSegments = forkContext.head;

        if (context.position === "catch") {
            this.popForkContext();
            forkContext = this.forkContext;

            context.lastOfCatchIsReachable = forkContext.reachable;
        } else {
            context.lastOfTryIsReachable = forkContext.reachable;
        }
        context.position = "finally";

        if (returned.empty && thrown.empty) {
            return;
        }

        var segments = forkContext.makeNext(-1, -1);
        var j;
        for (var i = 0; i < forkContext.count; ++i) {
            var prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];

            for (j = 0; j < returned.segmentsList.length; ++j) {
                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);
            }
            for (j = 0; j < thrown.segmentsList.length; ++j) {
                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);
            }

            segments.push(CodePathSegment.newNext(
                this.idGenerator.next(),
                prevSegsOfLeavingSegment));
        }

        this.pushForkContext(true);
        this.forkContext.add(segments);
    },

    makeFirstThrowablePathInTryBlock: function() {
        var forkContext = this.forkContext;
        if (!forkContext.reachable) {
            return;
        }

        var context = getThrowContext(this);
        if (context === this ||
            context.position !== "try" ||
            !context.thrownForkContext.empty
        ) {
            return;
        }

        context.thrownForkContext.add(forkContext.head);
        forkContext.replaceHead(forkContext.makeNext(-1, -1));
    },

    pushLoopContext: function(type, label) {
        var forkContext = this.forkContext;
        var breakContext = this.pushBreakContext(true, label);

        switch (type) {
            case "WhileStatement":
                this.pushChoiceContext("loop", false);
                this.loopContext = {
                    upper: this.loopContext,
                    type: type,
                    label: label,
                    test: void 0,
                    continueDestSegments: null,
                    brokenForkContext: breakContext.brokenForkContext
                };
                break;

            case "DoWhileStatement":
                this.pushChoiceContext("loop", false);
                this.loopContext = {
                    upper: this.loopContext,
                    type: type,
                    label: label,
                    test: void 0,
                    entrySegments: null,
                    continueForkContext: ForkContext.newEmpty(forkContext),
                    brokenForkContext: breakContext.brokenForkContext
                };
                break;

            case "ForStatement":
                this.pushChoiceContext("loop", false);
                this.loopContext = {
                    upper: this.loopContext,
                    type: type,
                    label: label,
                    test: void 0,
                    endOfInitSegments: null,
                    testSegments: null,
                    endOfTestSegments: null,
                    updateSegments: null,
                    endOfUpdateSegments: null,
                    continueDestSegments: null,
                    brokenForkContext: breakContext.brokenForkContext
                };
                break;

            case "ForInStatement":
            case "ForOfStatement":
                this.loopContext = {
                    upper: this.loopContext,
                    type: type,
                    label: label,
                    prevSegments: null,
                    leftSegments: null,
                    endOfLeftSegments: null,
                    continueDestSegments: null,
                    brokenForkContext: breakContext.brokenForkContext
                };
                break;

            default:
                throw new Error("unknown type: \"" + type + "\"");
        }
    },

    popLoopContext: function() {
        var context = this.loopContext;
        this.loopContext = context.upper;

        var forkContext = this.forkContext;
        var brokenForkContext = this.popBreakContext().brokenForkContext;
        var choiceContext;

        switch (context.type) {
            case "WhileStatement":
            case "ForStatement":
                choiceContext = this.popChoiceContext();
                makeLooped(
                    this,
                    forkContext.head,
                    context.continueDestSegments);
                break;

            case "DoWhileStatement":
                choiceContext = this.popChoiceContext();

                if (!choiceContext.processed) {
                    choiceContext.trueForkContext.add(forkContext.head);
                    choiceContext.falseForkContext.add(forkContext.head);
                }
                if (context.test !== true) {
                    brokenForkContext.addAll(choiceContext.falseForkContext);
                }

                var segmentsList = choiceContext.trueForkContext.segmentsList;
                for (var i = 0; i < segmentsList.length; ++i) {
                    makeLooped(
                        this,
                        segmentsList[i],
                        context.entrySegments);
                }
                break;

            case "ForInStatement":
            case "ForOfStatement":
                brokenForkContext.add(forkContext.head);
                makeLooped(
                    this,
                    forkContext.head,
                    context.leftSegments);
                break;

            default:
                throw new Error("unreachable");
        }

        if (brokenForkContext.empty) {
            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
        } else {
            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
        }
    },

    makeWhileTest: function(test) {
        var context = this.loopContext;
        var forkContext = this.forkContext;
        var testSegments = forkContext.makeNext(0, -1);

        context.test = test;
        context.continueDestSegments = testSegments;
        forkContext.replaceHead(testSegments);
    },

    makeWhileBody: function() {
        var context = this.loopContext;
        var choiceContext = this.choiceContext;
        var forkContext = this.forkContext;

        if (!choiceContext.processed) {
            choiceContext.trueForkContext.add(forkContext.head);
            choiceContext.falseForkContext.add(forkContext.head);
        }

        if (context.test !== true) {
            context.brokenForkContext.addAll(choiceContext.falseForkContext);
        }
        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
    },

    makeDoWhileBody: function() {
        var context = this.loopContext;
        var forkContext = this.forkContext;
        var bodySegments = forkContext.makeNext(-1, -1);

        context.entrySegments = bodySegments;
        forkContext.replaceHead(bodySegments);
    },

    makeDoWhileTest: function(test) {
        var context = this.loopContext;
        var forkContext = this.forkContext;

        context.test = test;

        if (!context.continueForkContext.empty) {
            context.continueForkContext.add(forkContext.head);
            var testSegments = context.continueForkContext.makeNext(0, -1);

            forkContext.replaceHead(testSegments);
        }
    },

    makeForTest: function(test) {
        var context = this.loopContext;
        var forkContext = this.forkContext;
        var endOfInitSegments = forkContext.head;
        var testSegments = forkContext.makeNext(-1, -1);

        context.test = test;
        context.endOfInitSegments = endOfInitSegments;
        context.continueDestSegments = context.testSegments = testSegments;
        forkContext.replaceHead(testSegments);
    },

    makeForUpdate: function() {
        var context = this.loopContext;
        var choiceContext = this.choiceContext;
        var forkContext = this.forkContext;

        if (context.testSegments) {
            finalizeTestSegmentsOfFor(
                context,
                choiceContext,
                forkContext.head);
        } else {
            context.endOfInitSegments = forkContext.head;
        }

        var updateSegments = forkContext.makeDisconnected(-1, -1);
        context.continueDestSegments = context.updateSegments = updateSegments;
        forkContext.replaceHead(updateSegments);
    },

    makeForBody: function() {
        var context = this.loopContext;
        var choiceContext = this.choiceContext;
        var forkContext = this.forkContext;

        if (context.updateSegments) {
            context.endOfUpdateSegments = forkContext.head;

            if (context.testSegments) {
                makeLooped(
                    this,
                    context.endOfUpdateSegments,
                    context.testSegments);
            }
        } else if (context.testSegments) {
            finalizeTestSegmentsOfFor(
                context,
                choiceContext,
                forkContext.head);
        } else {
            context.endOfInitSegments = forkContext.head;
        }

        var bodySegments = context.endOfTestSegments;
        if (!bodySegments) {
            var prevForkContext = ForkContext.newEmpty(forkContext);
            prevForkContext.add(context.endOfInitSegments);
            if (context.endOfUpdateSegments) {
                prevForkContext.add(context.endOfUpdateSegments);
            }

            bodySegments = prevForkContext.makeNext(0, -1);
        }
        context.continueDestSegments = context.continueDestSegments || bodySegments;
        forkContext.replaceHead(bodySegments);
    },

    makeForInOfLeft: function() {
        var context = this.loopContext;
        var forkContext = this.forkContext;
        var leftSegments = forkContext.makeDisconnected(-1, -1);

        context.prevSegments = forkContext.head;
        context.leftSegments = context.continueDestSegments = leftSegments;
        forkContext.replaceHead(leftSegments);
    },

    makeForInOfRight: function() {
        var context = this.loopContext;
        var forkContext = this.forkContext;
        var temp = ForkContext.newEmpty(forkContext);
        temp.add(context.prevSegments);
        var rightSegments = temp.makeNext(-1, -1);

        context.endOfLeftSegments = forkContext.head;
        forkContext.replaceHead(rightSegments);
    },

    makeForInOfBody: function() {
        var context = this.loopContext;
        var forkContext = this.forkContext;
        var temp = ForkContext.newEmpty(forkContext);
        temp.add(context.endOfLeftSegments);
        var bodySegments = temp.makeNext(-1, -1);

        makeLooped(this, forkContext.head, context.leftSegments);

        context.brokenForkContext.add(forkContext.head);
        forkContext.replaceHead(bodySegments);
    },

    pushBreakContext: function(breakable, label) {
        this.breakContext = {
            upper: this.breakContext,
            breakable: breakable,
            label: label,
            brokenForkContext: ForkContext.newEmpty(this.forkContext)
        };
        return this.breakContext;
    },

    popBreakContext: function() {
        var context = this.breakContext;
        var forkContext = this.forkContext;
        this.breakContext = context.upper;

        if (!context.breakable) {
            var brokenForkContext = context.brokenForkContext;
            if (!brokenForkContext.empty) {
                brokenForkContext.add(forkContext.head);
                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
            }
        }

        return context;
    },

    makeBreak: function(label) {
        var forkContext = this.forkContext;
        if (!forkContext.reachable) {
            return;
        }

        var context = getBreakContext(this, label);
        if (context) {
            context.brokenForkContext.add(forkContext.head);
        }
        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    },

    makeContinue: function(label) {
        var forkContext = this.forkContext;
        if (!forkContext.reachable) {
            return;
        }

        var context = getContinueContext(this, label);
        if (context) {
            if (context.continueDestSegments) {
                makeLooped(this, forkContext.head, context.continueDestSegments);

                if (context.type === "ForInStatement" ||
                    context.type === "ForOfStatement"
                ) {
                    context.brokenForkContext.add(forkContext.head);
                }
            } else {
                context.continueForkContext.add(forkContext.head);
            }
        }
        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    },

    makeReturn: function() {
        var forkContext = this.forkContext;
        if (forkContext.reachable) {
            getReturnContext(this).returnedForkContext.add(forkContext.head);
            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
        }
    },

    makeThrow: function() {
        var forkContext = this.forkContext;
        if (forkContext.reachable) {
            getThrowContext(this).thrownForkContext.add(forkContext.head);
            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
        }
    },

    makeFinal: function() {
        var segments = this.currentSegments;
        if (segments.length > 0 && segments[0].reachable) {
            this.returnedForkContext.add(segments);
        }
    }
};

module.exports = CodePathState;

},
   {"./code-path-segment":"/tmp/code-path-analysis/code-path-segment.js","./fork-context":"/tmp/code-path-analysis/fork-context.js"}],

"/tmp/code-path-analysis/code-path.js": [function(require,module,exports){
"use strict";

var CodePathState = require("./code-path-state");
var IdGenerator = require("./id-generator");

function CodePath(id, upper, onLooped) {
    this.id = id;

    this.upper = upper;

    this.childCodePaths = [];

    Object.defineProperty(
        this,
        "internal",
        {value: new CodePathState(new IdGenerator(id + "_"), onLooped)});

    if (upper) {
        upper.childCodePaths.push(this);
    }
}

CodePath.prototype = {
    constructor: CodePath,

    get initialSegment() {
        return this.internal.initialSegment;
    },

    get finalSegments() {
        return this.internal.finalSegments;
    },

    get returnedSegments() {
        return this.internal.returnedForkContext;
    },

    get thrownSegments() {
        return this.internal.thrownForkContext;
    },

    get currentSegments() {
        return this.internal.currentSegments;
    },

    traverseSegments: function(options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = null;
        }

        options = options || {};
        var startSegment = options.first || this.internal.initialSegment;
        var lastSegment = options.last;

        var item = null;
        var index = 0;
        var end = 0;
        var segment = null;
        var visited = Object.create(null);
        var stack = [[startSegment, 0]];
        var skippedSegment = null;
        var broken = false;
        var controller = {
            skip: function() {
                if (stack.length <= 1) {
                    broken = true;
                } else {
                    skippedSegment = stack[stack.length - 2][0];
                }
            },
            break: function() {
                broken = true;
            }
        };

        function isVisited(prevSegment) {
            return (
                visited[prevSegment.id] ||
                segment.isLoopedPrevSegment(prevSegment)
            );
        }

        while (stack.length > 0) {
            item = stack[stack.length - 1];
            segment = item[0];
            index = item[1];

            if (index === 0) {
                if (visited[segment.id]) {
                    stack.pop();
                    continue;
                }
                if (segment !== startSegment &&
                    segment.prevSegments.length > 0 &&
                    !segment.prevSegments.every(isVisited)
                ) {
                    stack.pop();
                    continue;
                }
                if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {
                    skippedSegment = null;
                }
                visited[segment.id] = true;

                if (!skippedSegment) {
                    callback.call(this, segment, controller); // eslint-disable-line callback-return
                    if (segment === lastSegment) {
                        controller.skip();
                    }
                    if (broken) {
                        break;
                    }
                }
            }

            end = segment.nextSegments.length - 1;
            if (index < end) {
                item[1] += 1;
                stack.push([segment.nextSegments[index], 0]);
            } else if (index === end) {
                item[0] = segment.nextSegments[index];
                item[1] = 0;
            } else {
                stack.pop();
            }
        }
    }
};

CodePath.getState = function getState(codePath) {
    return codePath.internal;
};

module.exports = CodePath;

},
   {"./code-path-state":"/tmp/code-path-analysis/code-path-state.js","./id-generator":"/tmp/code-path-analysis/id-generator.js"}],

"/tmp/code-path-analysis/debug-helpers.js": [function(require,module,exports){
"use strict";

var debug = require("debug")("eslint:code-path");

function getId(segment) { // eslint-disable-line require-jsdoc
    return segment.id + (segment.reachable ? "" : "!");
}

module.exports = {
    enabled: debug.enabled,

    dump: debug,

    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) {
        for (var i = 0; i < state.currentSegments.length; ++i) {
            var segInternal = state.currentSegments[i].internal;
            if (leaving) {
                segInternal.exitNodes.push(node);
            } else {
                segInternal.nodes.push(node);
            }
        }

        debug(
            state.currentSegments.map(getId).join(",") + ") " +
            node.type + (leaving ? ":exit" : "")
        );
    },

    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) {
        var text =
            "\n" +
            "digraph {\n" +
            "node[shape=box,style=\"rounded,filled\",fillcolor=white];\n" +
            "initial[label=\"\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";

        if (codePath.returnedSegments.length > 0) {
            text += "final[label=\"\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
        }
        if (codePath.thrownSegments.length > 0) {
            text += "thrown[label=\"✘\",shape=circle,width=0.3,height=0.3,fixedsize];\n";
        }

        var traceMap = Object.create(null);
        var arrows = this.makeDotArrows(codePath, traceMap);

        for (var id in traceMap) { // eslint-disable-line guard-for-in
            var segment = traceMap[id];

            text += id + "[";

            if (segment.reachable) {
                text += "label=\"";
            } else {
                text += "style=\"rounded,dashed,filled\",fillcolor=\"#FF9800\",label=\"<<unreachable>>\\n";
            }

            if (segment.internal.nodes.length > 0) {
                text += segment.internal.nodes.map(function(node) {
                    switch (node.type) {
                        case "Identifier": return node.type + " (" + node.name + ")";
                        case "Literal": return node.type + " (" + node.value + ")";
                        default: return node.type;
                    }
                }).join("\\n");
            } else if (segment.internal.exitNodes.length > 0) {
                text += segment.internal.exitNodes.map(function(node) {
                    switch (node.type) {
                        case "Identifier": return node.type + ":exit (" + node.name + ")";
                        case "Literal": return node.type + ":exit (" + node.value + ")";
                        default: return node.type + ":exit";
                    }
                }).join("\\n");
            } else {
                text += "????";
            }

            text += "\"];\n";
        }

        text += arrows + "\n";
        text += "}";
        debug("DOT", text);
    },

    makeDotArrows: function(codePath, traceMap) {
        var stack = [[codePath.initialSegment, 0]];
        var done = traceMap || Object.create(null);
        var lastId = codePath.initialSegment.id;
        var text = "initial->" + codePath.initialSegment.id;

        while (stack.length > 0) {
            var item = stack.pop();
            var segment = item[0];
            var index = item[1];
            if (done[segment.id] && index === 0) {
                continue;
            }
            done[segment.id] = segment;

            var nextSegment = segment.allNextSegments[index];
            if (!nextSegment) {
                continue;
            }

            if (lastId === segment.id) {
                text += "->" + nextSegment.id;
            } else {
                text += ";\n" + segment.id + "->" + nextSegment.id;
            }
            lastId = nextSegment.id;

            stack.unshift([segment, 1 + index]);
            stack.push([nextSegment, 0]);
        }

        codePath.returnedSegments.forEach(function(finalSegment) {
            if (lastId === finalSegment.id) {
                text += "->final";
            } else {
                text += ";\n" + finalSegment.id + "->final";
            }
            lastId = null;
        });

        codePath.thrownSegments.forEach(function(finalSegment) {
            if (lastId === finalSegment.id) {
                text += "->thrown";
            } else {
                text += ";\n" + finalSegment.id + "->thrown";
            }
            lastId = null;
        });

        return text + ";";
    }
};

},
   {"debug":"/node_modules/debug/browser.js"}],

"/tmp/code-path-analysis/fork-context.js": [function(require,module,exports){
"use strict";

var assert = require("assert"),
    CodePathSegment = require("./code-path-segment");

function isReachable(segment) {
    return segment.reachable;
}

function makeSegments(context, begin, end, create) {
    var list = context.segmentsList;
    if (begin < 0) {
        begin = list.length + begin;
    }
    if (end < 0) {
        end = list.length + end;
    }

    var segments = [];
    for (var i = 0; i < context.count; ++i) {
        var allPrevSegments = [];

        for (var j = begin; j <= end; ++j) {
            allPrevSegments.push(list[j][i]);
        }

        segments.push(create(context.idGenerator.next(), allPrevSegments));
    }

    return segments;
}

function mergeExtraSegments(context, segments) {
    while (segments.length > context.count) {
        var merged = [];
        for (var i = 0, length = segments.length / 2 | 0; i < length; ++i) {
            merged.push(CodePathSegment.newNext(
                context.idGenerator.next(),
                [segments[i], segments[i + length]]
            ));
        }
        segments = merged;
    }
    return segments;
}

function ForkContext(idGenerator, upper, count) {
    this.idGenerator = idGenerator;
    this.upper = upper;
    this.count = count;
    this.segmentsList = [];
}

ForkContext.prototype = {
    constructor: ForkContext,

    get head() {
        var list = this.segmentsList;
        return list.length === 0 ? [] : list[list.length - 1];
    },

    get empty() {
        return this.segmentsList.length === 0;
    },

    get reachable() {
        var segments = this.head;
        return segments.length > 0 && segments.some(isReachable);
    },

    makeNext: function(begin, end) {
        return makeSegments(this, begin, end, CodePathSegment.newNext);
    },

    makeUnreachable: function(begin, end) {
        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);
    },

    makeDisconnected: function(begin, end) {
        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);
    },

    add: function(segments) {
        assert(segments.length >= this.count, segments.length + " >= " + this.count);

        this.segmentsList.push(mergeExtraSegments(this, segments));
    },

    replaceHead: function(segments) {
        assert(segments.length >= this.count, segments.length + " >= " + this.count);

        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));
    },

    addAll: function(context) {
        assert(context.count === this.count);

        var source = context.segmentsList;
        for (var i = 0; i < source.length; ++i) {
            this.segmentsList.push(source[i]);
        }
    },

    clear: function() {
        this.segmentsList = [];
    }
};

ForkContext.newRoot = function(idGenerator) {
    var context = new ForkContext(idGenerator, null, 1);

    context.add([CodePathSegment.newRoot(idGenerator.next())]);

    return context;
};

ForkContext.newEmpty = function(parentContext, forkLeavingPath) {
    return new ForkContext(
        parentContext.idGenerator,
        parentContext,
        (forkLeavingPath ? 2 : 1) * parentContext.count);
};

module.exports = ForkContext;

},
   {"./code-path-segment":"/tmp/code-path-analysis/code-path-segment.js","assert":"/node_modules/browserify/node_modules/assert/assert.js"}],

"/tmp/code-path-analysis/id-generator.js": [function(require,module,exports){
"use strict";

function IdGenerator(prefix) {
    this.prefix = String(prefix);
    this.n = 0;
}

IdGenerator.prototype.next = function() {
    this.n = 1 + this.n | 0;
    if (this.n < 0) {
        this.n = 1;
    }
    return this.prefix + this.n;
};

module.exports = IdGenerator;

},
   {}],

"/tmp/config/config-ops.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash"),
    debug = require("debug"),
    Environments = require("./environments");

debug = debug("eslint:config-ops");

var RULE_SEVERITY_STRINGS = ["off", "warn", "error"],
    RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce(function(map, value, index) {
        map[value] = index;
        return map;
    }, {});

module.exports = {

    createEmptyConfig: function() {
        return {
            globals: {},
            env: {},
            rules: {},
            parserOptions: {}
        };
    },

    createEnvironmentConfig: function(env) {

        var envConfig = this.createEmptyConfig();

        if (env) {

            envConfig.env = env;

            Object.keys(env).filter(function(name) {
                return env[name];
            }).forEach(function(name) {
                var environment = Environments.get(name);

                if (environment) {
                    debug("Creating config for environment " + name);
                    if (environment.globals) {
                        lodash.assign(envConfig.globals, environment.globals);
                    }

                    if (environment.parserOptions) {
                        lodash.assign(envConfig.parserOptions, environment.parserOptions);
                    }
                }
            });
        }

        return envConfig;
    },

    applyEnvironments: function(config) {
        if (config.env && typeof config.env === "object") {
            debug("Apply environment settings to config");
            return this.merge(this.createEnvironmentConfig(config.env), config);
        }

        return config;
    },

    merge: function deepmerge(target, src, combine, isRule) {
        var array = Array.isArray(src) || Array.isArray(target);
        var dst = array && [] || {};

        combine = !!combine;
        isRule = !!isRule;
        if (array) {
            target = target || [];

            if (isRule && Array.isArray(src) && src.length > 1) {
                dst = dst.concat(src);
            } else {
                dst = dst.concat(target);
            }
            if (typeof src !== "object" && !Array.isArray(src)) {
                src = [src];
            }
            Object.keys(src).forEach(function(e, i) {
                e = src[i];
                if (typeof dst[i] === "undefined") {
                    dst[i] = e;
                } else if (typeof e === "object") {
                    if (isRule) {
                        dst[i] = e;
                    } else {
                        dst[i] = deepmerge(target[i], e, combine, isRule);
                    }
                } else {
                    if (!combine) {
                        dst[i] = e;
                    } else {
                        if (dst.indexOf(e) === -1) {
                            dst.push(e);
                        }
                    }
                }
            });
        } else {
            if (target && typeof target === "object") {
                Object.keys(target).forEach(function(key) {
                    dst[key] = target[key];
                });
            }
            Object.keys(src).forEach(function(key) {
                if (Array.isArray(src[key]) || Array.isArray(target[key])) {
                    dst[key] = deepmerge(target[key], src[key], key === "plugins", isRule);
                } else if (typeof src[key] !== "object" || !src[key] || key === "exported" || key === "astGlobals") {
                    dst[key] = src[key];
                } else {
                    dst[key] = deepmerge(target[key] || {}, src[key], combine, key === "rules");
                }
            });
        }

        return dst;
    },

    normalize: function(config) {

        if (config.rules) {
            Object.keys(config.rules).forEach(function(ruleId) {
                var ruleConfig = config.rules[ruleId];

                if (typeof ruleConfig === "string") {
                    config.rules[ruleId] = RULE_SEVERITY[ruleConfig.toLowerCase()] || 0;
                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "string") {
                    ruleConfig[0] = RULE_SEVERITY[ruleConfig[0].toLowerCase()] || 0;
                }
            });
        }
    },

    normalizeToStrings: function(config) {

        if (config.rules) {
            Object.keys(config.rules).forEach(function(ruleId) {
                var ruleConfig = config.rules[ruleId];

                if (typeof ruleConfig === "number") {
                    config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];
                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "number") {
                    ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];
                }
            });
        }
    },

    isErrorSeverity: function(ruleConfig) {

        var severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;

        if (typeof severity === "string") {
            severity = RULE_SEVERITY[severity.toLowerCase()] || 0;
        }

        return (typeof severity === "number" && severity === 2);
    }

};

},
   {"./environments":"/tmp/config/environments.js","debug":"/node_modules/debug/browser.js","lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/config/config-validator.js": [function(require,module,exports){
"use strict";

var rules = require("../rules"),
    Environments = require("./environments"),
    schemaValidator = require("is-my-json-valid");

var validators = {
    rules: Object.create(null)
};

function getRuleOptionsSchema(id) {
    var rule = rules.get(id),
        schema = rule && rule.schema || rule && rule.meta && rule.meta.schema;

    if (Array.isArray(schema)) {
        if (schema.length) {
            return {
                "type": "array",
                "items": schema,
                "minItems": 0,
                "maxItems": schema.length
            };
        } else {
            return {
                "type": "array",
                "minItems": 0,
                "maxItems": 0
            };
        }
    }

    return schema || null;
}

function validateRuleOptions(id, options, source) {
    var validateRule = validators.rules[id],
        message,
        severity,
        localOptions,
        schema = getRuleOptionsSchema(id),
        validSeverity = true;

    if (!validateRule && schema) {
        validateRule = schemaValidator(schema, { verbose: true });
        validators.rules[id] = validateRule;
    }

    if (Array.isArray(options)) {
        localOptions = options.concat();    // clone
        severity = localOptions.shift();
    } else {
        severity = options;
        localOptions = [];
    }



    if (validateRule) {
        validateRule(localOptions);
    }

    if ((validateRule && validateRule.errors) || !validSeverity) {
        message = [
            source, ":\n",
            "\tConfiguration for rule \"", id, "\" is invalid:\n"
        ];

        if (!validSeverity) {
            message.push(
                "\tSeverity should be one of the following: 0 = off, 1 = warning, 2 = error (you passed \"", severity, "\").\n");
        }

        if (validateRule && validateRule.errors) {
            validateRule.errors.forEach(function(error) {
                message.push(
                    "\tValue \"", error.value, "\" ", error.message, ".\n"
                );
            });
        }

        throw new Error(message.join(""));
    }
}

function validateEnvironment(environment, source) {

    if (!environment) {
        return;
    }

    if (Array.isArray(environment)) {
        throw new Error("Environment must not be an array");
    }

    if (typeof environment === "object") {
        Object.keys(environment).forEach(function(env) {
            if (!Environments.get(env)) {
                var message = [
                    source, ":\n",
                    "\tEnvironment key \"", env, "\" is unknown\n"
                ];
                throw new Error(message.join(""));
            }
        });
    } else {
        throw new Error("Environment must be an object");
    }
}

function validate(config, source) {

    if (typeof config.rules === "object") {
        Object.keys(config.rules).forEach(function(id) {
            validateRuleOptions(id, config.rules[id], source);
        });
    }

    validateEnvironment(config.env, source);
}

module.exports = {
    getRuleOptionsSchema: getRuleOptionsSchema,
    validate: validate,
    validateRuleOptions: validateRuleOptions
};

},
   {"../rules":"/tmp/rules.js","./environments":"/tmp/config/environments.js","is-my-json-valid":"/node_modules/is-my-json-valid/index.js"}],

"/tmp/config/environments.js": [function(require,module,exports){
"use strict";

var debug = require("debug"),
    envs = require("../../conf/environments");

debug = debug("eslint:enviroments");

var environments = Object.create(null);

function load() {
    Object.keys(envs).forEach(function(envName) {
        environments[envName] = envs[envName];
    });
}

load();

module.exports = {

    load: load,

    get: function(name) {
        return environments[name] || null;
    },

    define: function(name, env) {
        environments[name] = env;
    },

    importPlugin: function(plugin, pluginName) {
        if (plugin.environments) {
            Object.keys(plugin.environments).forEach(function(envName) {
                this.define(pluginName + "/" + envName, plugin.environments[envName]);
            }, this);
        }
    },

    testReset: function() {
        environments = Object.create(null);
        load();
    }
};

},
   {"../../conf/environments":"/conf/environments.js","debug":"/node_modules/debug/browser.js"}],

"/tmp/eslint.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash"),
    espree = require("espree"),
    estraverse = require("estraverse"),
    escope = require("escope"),
    Environments = require("./config/environments"),
    blankScriptAST = require("../conf/blank-script.json"),
    rules = require("./rules"),
    RuleContext = require("./rule-context"),
    timing = require("./timing"),
    SourceCode = require("./util/source-code"),
    NodeEventGenerator = require("./util/node-event-generator"),
    CommentEventGenerator = require("./util/comment-event-generator"),
    EventEmitter = require("events").EventEmitter,
    ConfigOps = require("./config/config-ops"),
    validator = require("./config/config-validator"),
    replacements = require("../conf/replacements.json"),
    assert = require("assert"),
    CodePathAnalyzer = require("./code-path-analysis/code-path-analyzer");

var DEFAULT_PARSER = require("../conf/eslint.json").parser;

function parseBooleanConfig(string, comment) {
    var items = {};
    string = string.replace(/\s*:\s*/g, ":");
    string = string.replace(/\s*,\s*/g, ",");
    string.split(/\s|,+/).forEach(function(name) {
        if (!name) {
            return;
        }
        var pos = name.indexOf(":"),
            value;
        if (pos !== -1) {
            value = name.substring(pos + 1, name.length);
            name = name.substring(0, pos);
        }

        items[name] = {
            value: (value === "true"),
            comment: comment
        };

    });
    return items;
}

function parseJsonConfig(string, location, messages) {
    var items = {};
    string = string.replace(/([a-zA-Z0-9\-\/]+):/g, "\"$1\":").replace(/(\]|[0-9])\s+(?=")/, "$1,");
    try {
        items = JSON.parse("{" + string + "}");
    } catch (ex) {

        messages.push({
            ruleId: null,
            fatal: true,
            severity: 2,
            source: null,
            message: "Failed to parse JSON from '" + string + "': " + ex.message,
            line: location.start.line,
            column: location.start.column + 1
        });

    }

    return items;
}

function parseListConfig(string) {
    var items = {};
    string = string.replace(/\s*,\s*/g, ",");
    string.split(/,+/).forEach(function(name) {
        name = name.trim();
        if (!name) {
            return;
        }
        items[name] = true;
    });
    return items;
}

function addDeclaredGlobals(program, globalScope, config) {
    var declaredGlobals = {},
        exportedGlobals = {},
        explicitGlobals = {},
        builtin = Environments.get("builtin");

    lodash.assign(declaredGlobals, builtin);

    Object.keys(config.env).forEach(function(name) {
        if (config.env[name]) {
            var env = Environments.get(name),
                environmentGlobals = env && env.globals;
            if (environmentGlobals) {
                lodash.assign(declaredGlobals, environmentGlobals);
            }
        }
    });

    lodash.assign(exportedGlobals, config.exported);
    lodash.assign(declaredGlobals, config.globals);
    lodash.assign(explicitGlobals, config.astGlobals);

    Object.keys(declaredGlobals).forEach(function(name) {
        var variable = globalScope.set.get(name);
        if (!variable) {
            variable = new escope.Variable(name, globalScope);
            variable.eslintExplicitGlobal = false;
            globalScope.variables.push(variable);
            globalScope.set.set(name, variable);
        }
        variable.writeable = declaredGlobals[name];
    });

    Object.keys(explicitGlobals).forEach(function(name) {
        var variable = globalScope.set.get(name);
        if (!variable) {
            variable = new escope.Variable(name, globalScope);
            variable.eslintExplicitGlobal = true;
            variable.eslintExplicitGlobalComment = explicitGlobals[name].comment;
            globalScope.variables.push(variable);
            globalScope.set.set(name, variable);
        }
        variable.writeable = explicitGlobals[name].value;
    });

    Object.keys(exportedGlobals).forEach(function(name) {
        var variable = globalScope.set.get(name);
        if (variable) {
            variable.eslintUsed = true;
        }
    });

    globalScope.through = globalScope.through.filter(function(reference) {
        var name = reference.identifier.name;
        var variable = globalScope.set.get(name);
        if (variable) {
            reference.resolved = variable;
            variable.references.push(reference);
            return false;
        }
        return true;
    });
}

function disableReporting(reportingConfig, start, rulesToDisable) {

    if (rulesToDisable.length) {
        rulesToDisable.forEach(function(rule) {
            reportingConfig.push({
                start: start,
                end: null,
                rule: rule
            });
        });
    } else {
        reportingConfig.push({
            start: start,
            end: null,
            rule: null
        });
    }
}

function enableReporting(reportingConfig, start, rulesToEnable) {
    var i;

    if (rulesToEnable.length) {
        rulesToEnable.forEach(function(rule) {
            for (i = reportingConfig.length - 1; i >= 0; i--) {
                if (!reportingConfig[i].end && reportingConfig[i].rule === rule ) {
                    reportingConfig[i].end = start;
                    break;
                }
            }
        });
    } else {
        var prevStart;
        for (i = reportingConfig.length - 1; i >= 0; i--) {
            if (prevStart && prevStart !== reportingConfig[i].start) {
                break;
            }

            if (!reportingConfig[i].end) {
                reportingConfig[i].end = start;
                prevStart = reportingConfig[i].start;
            }
        }
    }
}

function modifyConfigsFromComments(filename, ast, config, reportingConfig, messages) {

    var commentConfig = {
        exported: {},
        astGlobals: {},
        rules: {},
        env: {}
    };
    var commentRules = {};

    ast.comments.forEach(function(comment) {

        var value = comment.value.trim();
        var match = /^(eslint(-\w+){0,3}|exported|globals?)(\s|$)/.exec(value);

        if (match) {
            value = value.substring(match.index + match[1].length);

            if (comment.type === "Block") {
                switch (match[1]) {
                    case "exported":
                        lodash.assign(commentConfig.exported, parseBooleanConfig(value, comment));
                        break;

                    case "globals":
                    case "global":
                        lodash.assign(commentConfig.astGlobals, parseBooleanConfig(value, comment));
                        break;

                    case "eslint-env":
                        lodash.assign(commentConfig.env, parseListConfig(value));
                        break;

                    case "eslint-disable":
                        disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));
                        break;

                    case "eslint-enable":
                        enableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));
                        break;

                    case "eslint":
                        var items = parseJsonConfig(value, comment.loc, messages);
                        Object.keys(items).forEach(function(name) {
                            var ruleValue = items[name];
                            validator.validateRuleOptions(name, ruleValue, filename + " line " + comment.loc.start.line);
                            commentRules[name] = ruleValue;
                        });
                        break;

                }
            } else {
                if (match[1] === "eslint-disable-line") {
                    disableReporting(reportingConfig, { "line": comment.loc.start.line, "column": 0 }, Object.keys(parseListConfig(value)));
                    enableReporting(reportingConfig, comment.loc.end, Object.keys(parseListConfig(value)));
                } else if (match[1] === "eslint-disable-next-line") {
                    disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));
                    enableReporting(reportingConfig, { "line": comment.loc.start.line + 2 }, Object.keys(parseListConfig(value)));
                }
            }
        }
    });

    Object.keys(commentConfig.env).forEach(function(name) {
        var env = Environments.get(name);
        if (env) {
            commentConfig = ConfigOps.merge(commentConfig, env);
        }
    });
    lodash.assign(commentConfig.rules, commentRules);

    return ConfigOps.merge(config, commentConfig);
}

function isDisabledByReportingConfig(reportingConfig, ruleId, location) {

    for (var i = 0, c = reportingConfig.length; i < c; i++) {

        var ignore = reportingConfig[i];
        if ((!ignore.rule || ignore.rule === ruleId) &&
            (location.line > ignore.start.line || (location.line === ignore.start.line && location.column >= ignore.start.column)) &&
            (!ignore.end || (location.line < ignore.end.line || (location.line === ignore.end.line && location.column <= ignore.end.column)))) {
            return true;
        }
    }

    return false;
}

function prepareConfig(config) {

    config.globals = config.globals || config.global || {};
    delete config.global;

    var copiedRules = {},
        parserOptions = {},
        preparedConfig;

    if (typeof config.rules === "object") {
        Object.keys(config.rules).forEach(function(k) {
            var rule = config.rules[k];
            if (rule === null) {
                throw new Error("Invalid config for rule '" + k + "'\.");
            }
            if (Array.isArray(rule)) {
                copiedRules[k] = rule.slice();
            } else {
                copiedRules[k] = rule;
            }
        });
    }

    if (typeof config.env === "object") {
        Object.keys(config.env).forEach(function(envName) {
            var env = Environments.get(envName);
            if (config.env[envName] && env && env.parserOptions) {
                parserOptions = ConfigOps.merge(parserOptions, env.parserOptions);
            }
        });
    }

    preparedConfig = {
        rules: copiedRules,
        parser: config.parser || DEFAULT_PARSER,
        globals: ConfigOps.merge({}, config.globals),
        env: ConfigOps.merge({}, config.env || {}),
        settings: ConfigOps.merge({}, config.settings || {}),
        parserOptions: ConfigOps.merge(parserOptions, config.parserOptions || {})
    };

    if (preparedConfig.parserOptions.sourceType === "module") {
        if (!preparedConfig.parserOptions.ecmaFeatures) {
            preparedConfig.parserOptions.ecmaFeatures = {};
        }

        preparedConfig.parserOptions.ecmaFeatures.globalReturn = false;

        if (!preparedConfig.parserOptions.ecmaVersion || preparedConfig.parserOptions.ecmaVersion < 6) {
            preparedConfig.parserOptions.ecmaVersion = 6;
        }
    }

    return preparedConfig;
}

function createStubRule(message) {

    function createRuleModule(context) {
        return {
            Program: function(node) {
                context.report(node, message);
            }
        };
    }

    if (message) {
        return createRuleModule;
    } else {
        throw new Error("No message passed to stub rule");
    }
}

function getRuleReplacementMessage(ruleId) {
    if (ruleId in replacements.rules) {
        var newRules = replacements.rules[ruleId];
        return "Rule \'" + ruleId + "\' was removed and replaced by: " + newRules.join(", ");
    }
    return null;
}

var eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)\*\//g;

function findEslintEnv(text) {
    var match, retv;

    eslintEnvPattern.lastIndex = 0;
    while ((match = eslintEnvPattern.exec(text))) {
        retv = lodash.assign(retv || {}, parseListConfig(match[1]));
    }

    return retv;
}

function stripUnicodeBOM(text) {
    if (text.charCodeAt(0) === 0xFEFF) {
        return text.slice(1);
    }
    return text;
}

module.exports = (function() {

    var api = Object.create(new EventEmitter()),
        messages = [],
        currentConfig = null,
        currentScopes = null,
        scopeMap = null,
        scopeManager = null,
        currentFilename = null,
        controller = null,
        reportingConfig = [],
        sourceCode = null;

    function parse(text, config) {

        var parser,
            parserOptions = {
                loc: true,
                range: true,
                raw: true,
                tokens: true,
                comment: true,
                attachComment: true
            };

        try {
            parser = require(config.parser);
        } catch (ex) {
            messages.push({
                ruleId: null,
                fatal: true,
                severity: 2,
                source: null,
                message: ex.message,
                line: 0,
                column: 0
            });

            return null;
        }

        if (config.parserOptions) {
            parserOptions = lodash.assign({}, config.parserOptions, parserOptions);
        }

        try {
            return parser.parse(text, parserOptions);
        } catch (ex) {

            var message = ex.message.replace(/^line \d+:/i, "").trim();
            var source = (ex.lineNumber) ? SourceCode.splitLines(text)[ex.lineNumber] : null;

            messages.push({
                ruleId: null,
                fatal: true,
                severity: 2,
                source: source,
                message: "Parsing error: " + message,

                line: ex.lineNumber,
                column: ex.column
            });

            return null;
        }
    }

    function getRuleSeverity(ruleConfig) {
        if (typeof ruleConfig === "number") {
            return ruleConfig;
        } else if (Array.isArray(ruleConfig)) {
            return ruleConfig[0];
        } else {
            return 0;
        }
    }

    function getRuleOptions(ruleConfig) {
        if (Array.isArray(ruleConfig)) {
            return ruleConfig.slice(1);
        } else {
            return [];
        }
    }

    api.setMaxListeners(0);

    api.reset = function() {
        this.removeAllListeners();
        messages = [];
        currentConfig = null;
        currentScopes = null;
        scopeMap = null;
        scopeManager = null;
        controller = null;
        reportingConfig = [];
        sourceCode = null;
    };

    api.verify = function(textOrSourceCode, config, filenameOrOptions, saveState) {

        var ast,
            shebang,
            ecmaFeatures,
            ecmaVersion,
            allowInlineConfig,
            text = (typeof textOrSourceCode === "string") ? textOrSourceCode : null;

        if (typeof filenameOrOptions === "object") {
            currentFilename = filenameOrOptions.filename;
            allowInlineConfig = filenameOrOptions.allowInlineConfig;
            saveState = filenameOrOptions.saveState;
        } else {
            currentFilename = filenameOrOptions;
        }

        if (!saveState) {
            this.reset();
        }

        var envInFile = findEslintEnv(text || textOrSourceCode.text);
        if (envInFile) {
            if (!config || !config.env) {
                config = lodash.assign({}, config || {}, {env: envInFile});
            } else {
                config = lodash.assign({}, config);
                config.env = lodash.assign({}, config.env, envInFile);
            }
        }

        config = prepareConfig(config || {});

        if (text !== null) {
            if (text.trim().length === 0) {
                sourceCode = new SourceCode(text, blankScriptAST);
                return messages;
            }

            ast = parse(
                stripUnicodeBOM(text).replace(/^#!([^\r\n]+)/, function(match, captured) {
                    shebang = captured;
                    return "//" + captured;
                }),
                config
            );

            if (ast) {
                sourceCode = new SourceCode(text, ast);
            }

        } else {
            sourceCode = textOrSourceCode;
            ast = sourceCode.ast;
        }

        if (ast) {

            if (allowInlineConfig !== false) {
                config = modifyConfigsFromComments(currentFilename, ast, config, reportingConfig, messages);
            }

            ConfigOps.normalize(config);

            Object.keys(config.rules).filter(function(key) {
                return getRuleSeverity(config.rules[key]) > 0;
            }).forEach(function(key) {
                var ruleCreator,
                    severity,
                    options,
                    rule;

                ruleCreator = rules.get(key);
                if (!ruleCreator) {
                    var replacementMsg = getRuleReplacementMessage(key);
                    if (replacementMsg) {
                        ruleCreator = createStubRule(replacementMsg);
                    } else {
                        ruleCreator = createStubRule("Definition for rule '" + key + "' was not found");
                    }
                    rules.define(key, ruleCreator);
                }

                severity = getRuleSeverity(config.rules[key]);
                options = getRuleOptions(config.rules[key]);

                try {
                    var ruleContext = new RuleContext(
                        key, api, severity, options,
                        config.settings, config.parserOptions, config.parser, ruleCreator.meta);
                    rule = ruleCreator.create ? ruleCreator.create(ruleContext) :
                        ruleCreator(ruleContext);

                    Object.keys(rule).forEach(function(nodeType) {
                        api.on(nodeType, timing.enabled
                            ? timing.time(key, rule[nodeType])
                            : rule[nodeType]
                        );
                    });
                } catch (ex) {
                    ex.message = "Error while loading rule '" + key + "': " + ex.message;
                    throw ex;
                }
            });

            currentConfig = config;
            controller = new estraverse.Controller();

            ecmaFeatures = currentConfig.parserOptions.ecmaFeatures || {};
            ecmaVersion = currentConfig.parserOptions.ecmaVersion || 5;

            scopeManager = escope.analyze(ast, {
                ignoreEval: true,
                nodejsScope: ecmaFeatures.globalReturn,
                impliedStrict: ecmaFeatures.impliedStrict,
                ecmaVersion: ecmaVersion,
                sourceType: currentConfig.parserOptions.sourceType || "script",
                childVisitorKeys: espree.VisitorKeys,
                fallback: "none"
            });
            currentScopes = scopeManager.scopes;

            scopeMap = [];
            currentScopes.forEach(function(scope, index) {
                var range = scope.block.range[0];

                if (!scopeMap[range]) {
                    scopeMap[range] = index;
                }
            });

            addDeclaredGlobals(ast, currentScopes[0], currentConfig);

            if (shebang && ast.comments.length && ast.comments[0].value === shebang) {
                ast.comments.splice(0, 1);

                if (ast.body.length && ast.body[0].leadingComments && ast.body[0].leadingComments[0].value === shebang) {
                    ast.body[0].leadingComments.splice(0, 1);
                }
            }

            var eventGenerator = new NodeEventGenerator(api);
            eventGenerator = new CodePathAnalyzer(eventGenerator);
            eventGenerator = new CommentEventGenerator(eventGenerator, sourceCode);

            controller.traverse(ast, {
                enter: function(node, parent) {
                    node.parent = parent;
                    eventGenerator.enterNode(node);
                },
                leave: function(node) {
                    eventGenerator.leaveNode(node);
                },
                keys: espree.VisitorKeys
            });
        }

        messages.sort(function(a, b) {
            var lineDiff = a.line - b.line;

            if (lineDiff === 0) {
                return a.column - b.column;
            } else {
                return lineDiff;
            }
        });

        return messages;
    };

    api.report = function(ruleId, severity, node, location, message, opts, fix, meta) {
        if (node) {
            assert.strictEqual(typeof node, "object", "Node must be an object");
        }

        if (typeof location === "string") {
            assert.ok(node, "Node must be provided when reporting error if location is not provided");

            meta = fix;
            fix = opts;
            opts = message;
            message = location;
            location = node.loc.start;
        }
        if (isDisabledByReportingConfig(reportingConfig, ruleId, location)) {
            return;
        }

        if (opts) {
            message = message.replace(/\{\{\s*(.+?)\s*\}\}/g, function(fullMatch, term) {
                if (term in opts) {
                    return opts[term];
                }

                return fullMatch;
            });
        }

        var problem = {
            ruleId: ruleId,
            severity: severity,
            message: message,
            line: location.line,
            column: location.column + 1,   // switch to 1-base instead of 0-base
            nodeType: node && node.type,
            source: sourceCode.lines[location.line] || ""
        };

        if (fix && Array.isArray(fix.range) && (typeof fix.text === "string") && (!meta || !meta.docs || meta.docs.fixable)) {
            problem.fix = fix;
        }

        messages.push(problem);
    };

    api.getSourceCode = function() {
        return sourceCode;
    };

    var externalMethods = {
        getSource: "getText",
        getSourceLines: "getLines",
        getAllComments: "getAllComments",
        getNodeByRangeIndex: "getNodeByRangeIndex",
        getComments: "getComments",
        getJSDocComment: "getJSDocComment",
        getFirstToken: "getFirstToken",
        getFirstTokens: "getFirstTokens",
        getLastToken: "getLastToken",
        getLastTokens: "getLastTokens",
        getTokenAfter: "getTokenAfter",
        getTokenBefore: "getTokenBefore",
        getTokenByRangeStart: "getTokenByRangeStart",
        getTokens: "getTokens",
        getTokensAfter: "getTokensAfter",
        getTokensBefore: "getTokensBefore",
        getTokensBetween: "getTokensBetween"
    };

    Object.keys(externalMethods).forEach(function(methodName) {
        var exMethodName = externalMethods[methodName];

        api[methodName] = function(a, b, c, d, e) {
            if (sourceCode) {
                return sourceCode[exMethodName](a, b, c, d, e);
            }
            return null;
        };
    });

    api.getAncestors = function() {
        return controller.parents();
    };

    api.getScope = function() {
        var parents = controller.parents(),
            scope = currentScopes[0];

        if (parents.length) {

            var current = controller.current();
            if (currentConfig.parserOptions.ecmaVersion >= 6) {
                if (["BlockStatement", "SwitchStatement", "CatchClause", "FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(current.type) >= 0) {
                    parents.push(current);
                }
            } else {
                if (["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(current.type) >= 0) {
                    parents.push(current);
                }
            }

            for (var i = parents.length - 1; i >= 0; --i) {

                scope = scopeManager.acquire(parents[i], true);
                if (scope) {
                    if (scope.type === "function-expression-name") {
                        return scope.childScopes[0];
                    } else {
                        return scope;
                    }
                }

            }

        }

        return currentScopes[0];
    };

    api.markVariableAsUsed = function(name) {
        var scope = this.getScope(),
            hasGlobalReturn = currentConfig.parserOptions.ecmaFeatures && currentConfig.parserOptions.ecmaFeatures.globalReturn,
            specialScope = hasGlobalReturn || currentConfig.parserOptions.sourceType === "module",
            variables,
            i,
            len;

        if (scope.type === "global" && specialScope) {
            scope = scope.childScopes[0];
        }

        do {
            variables = scope.variables;
            for (i = 0, len = variables.length; i < len; i++) {
                if (variables[i].name === name) {
                    variables[i].eslintUsed = true;
                    return true;
                }
            }
        } while ( (scope = scope.upper) );

        return false;
    };

    api.getFilename = function() {
        if (typeof currentFilename === "string") {
            return currentFilename;
        } else {
            return "<input>";
        }
    };

    var defineRule = api.defineRule = function(ruleId, ruleModule) {
        rules.define(ruleId, ruleModule);
    };

    api.defineRules = function(rulesToDefine) {
        Object.getOwnPropertyNames(rulesToDefine).forEach(function(ruleId) {
            defineRule(ruleId, rulesToDefine[ruleId]);
        });
    };

    api.defaults = function() {
        return require("../conf/eslint.json");
    };

    api.getDeclaredVariables = function(node) {
        return (scopeManager && scopeManager.getDeclaredVariables(node)) || [];
    };

    return api;

}());

},
   {"../conf/blank-script.json":"/conf/blank-script.json","../conf/eslint.json":"/conf/eslint.json","../conf/replacements.json":"/conf/replacements.json","./code-path-analysis/code-path-analyzer":"/tmp/code-path-analysis/code-path-analyzer.js","./config/config-ops":"/tmp/config/config-ops.js","./config/config-validator":"/tmp/config/config-validator.js","./config/environments":"/tmp/config/environments.js","./rule-context":"/tmp/rule-context.js","./rules":"/tmp/rules.js","./timing":"/tmp/timing.js","./util/comment-event-generator":"/tmp/util/comment-event-generator.js","./util/node-event-generator":"/tmp/util/node-event-generator.js","./util/source-code":"/tmp/util/source-code.js","assert":"/node_modules/browserify/node_modules/assert/assert.js","escope":"/node_modules/escope/lib/index.js","espree":"espree","estraverse":"/node_modules/estraverse/estraverse.js","events":"/node_modules/browserify/node_modules/events/events.js","lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/load-rules.js": [function(require,module,exports){
module.exports = function() {
    var rules = require('eslint-plugin-react').rules;
    Object.keys(rules).forEach(function(k) {rules['react/' + k] = rules[k]; });
    rules["accessor-pairs"] = require("./rules/accessor-pairs");
    rules["array-bracket-spacing"] = require("./rules/array-bracket-spacing");
    rules["array-callback-return"] = require("./rules/array-callback-return");
    rules["arrow-body-style"] = require("./rules/arrow-body-style");
    rules["arrow-parens"] = require("./rules/arrow-parens");
    rules["arrow-spacing"] = require("./rules/arrow-spacing");
    rules["block-scoped-var"] = require("./rules/block-scoped-var");
    rules["block-spacing"] = require("./rules/block-spacing");
    rules["brace-style"] = require("./rules/brace-style");
    rules["callback-return"] = require("./rules/callback-return");
    rules["camelcase"] = require("./rules/camelcase");
    rules["comma-dangle"] = require("./rules/comma-dangle");
    rules["comma-spacing"] = require("./rules/comma-spacing");
    rules["comma-style"] = require("./rules/comma-style");
    rules["complexity"] = require("./rules/complexity");
    rules["computed-property-spacing"] = require("./rules/computed-property-spacing");
    rules["consistent-return"] = require("./rules/consistent-return");
    rules["consistent-this"] = require("./rules/consistent-this");
    rules["constructor-super"] = require("./rules/constructor-super");
    rules["curly"] = require("./rules/curly");
    rules["default-case"] = require("./rules/default-case");
    rules["dot-location"] = require("./rules/dot-location");
    rules["dot-notation"] = require("./rules/dot-notation");
    rules["eol-last"] = require("./rules/eol-last");
    rules["eqeqeq"] = require("./rules/eqeqeq");
    rules["func-names"] = require("./rules/func-names");
    rules["func-style"] = require("./rules/func-style");
    rules["generator-star-spacing"] = require("./rules/generator-star-spacing");
    rules["global-require"] = require("./rules/global-require");
    rules["guard-for-in"] = require("./rules/guard-for-in");
    rules["handle-callback-err"] = require("./rules/handle-callback-err");
    rules["id-blacklist"] = require("./rules/id-blacklist");
    rules["id-length"] = require("./rules/id-length");
    rules["id-match"] = require("./rules/id-match");
    rules["indent"] = require("./rules/indent");
    rules["init-declarations"] = require("./rules/init-declarations");
    rules["jsx-quotes"] = require("./rules/jsx-quotes");
    rules["key-spacing"] = require("./rules/key-spacing");
    rules["keyword-spacing"] = require("./rules/keyword-spacing");
    rules["linebreak-style"] = require("./rules/linebreak-style");
    rules["lines-around-comment"] = require("./rules/lines-around-comment");
    rules["max-depth"] = require("./rules/max-depth");
    rules["max-len"] = require("./rules/max-len");
    rules["max-nested-callbacks"] = require("./rules/max-nested-callbacks");
    rules["max-params"] = require("./rules/max-params");
    rules["max-statements"] = require("./rules/max-statements");
    rules["new-cap"] = require("./rules/new-cap");
    rules["new-parens"] = require("./rules/new-parens");
    rules["newline-after-var"] = require("./rules/newline-after-var");
    rules["newline-before-return"] = require("./rules/newline-before-return");
    rules["newline-per-chained-call"] = require("./rules/newline-per-chained-call");
    rules["no-alert"] = require("./rules/no-alert");
    rules["no-array-constructor"] = require("./rules/no-array-constructor");
    rules["no-bitwise"] = require("./rules/no-bitwise");
    rules["no-caller"] = require("./rules/no-caller");
    rules["no-case-declarations"] = require("./rules/no-case-declarations");
    rules["no-catch-shadow"] = require("./rules/no-catch-shadow");
    rules["no-class-assign"] = require("./rules/no-class-assign");
    rules["no-cond-assign"] = require("./rules/no-cond-assign");
    rules["no-confusing-arrow"] = require("./rules/no-confusing-arrow");
    rules["no-console"] = require("./rules/no-console");
    rules["no-const-assign"] = require("./rules/no-const-assign");
    rules["no-constant-condition"] = require("./rules/no-constant-condition");
    rules["no-continue"] = require("./rules/no-continue");
    rules["no-control-regex"] = require("./rules/no-control-regex");
    rules["no-debugger"] = require("./rules/no-debugger");
    rules["no-delete-var"] = require("./rules/no-delete-var");
    rules["no-div-regex"] = require("./rules/no-div-regex");
    rules["no-dupe-args"] = require("./rules/no-dupe-args");
    rules["no-dupe-class-members"] = require("./rules/no-dupe-class-members");
    rules["no-dupe-keys"] = require("./rules/no-dupe-keys");
    rules["no-duplicate-case"] = require("./rules/no-duplicate-case");
    rules["no-else-return"] = require("./rules/no-else-return");
    rules["no-empty-character-class"] = require("./rules/no-empty-character-class");
    rules["no-empty-function"] = require("./rules/no-empty-function");
    rules["no-empty-pattern"] = require("./rules/no-empty-pattern");
    rules["no-empty"] = require("./rules/no-empty");
    rules["no-eq-null"] = require("./rules/no-eq-null");
    rules["no-eval"] = require("./rules/no-eval");
    rules["no-ex-assign"] = require("./rules/no-ex-assign");
    rules["no-extend-native"] = require("./rules/no-extend-native");
    rules["no-extra-bind"] = require("./rules/no-extra-bind");
    rules["no-extra-boolean-cast"] = require("./rules/no-extra-boolean-cast");
    rules["no-extra-label"] = require("./rules/no-extra-label");
    rules["no-extra-parens"] = require("./rules/no-extra-parens");
    rules["no-extra-semi"] = require("./rules/no-extra-semi");
    rules["no-fallthrough"] = require("./rules/no-fallthrough");
    rules["no-floating-decimal"] = require("./rules/no-floating-decimal");
    rules["no-func-assign"] = require("./rules/no-func-assign");
    rules["no-implicit-coercion"] = require("./rules/no-implicit-coercion");
    rules["no-implicit-globals"] = require("./rules/no-implicit-globals");
    rules["no-implied-eval"] = require("./rules/no-implied-eval");
    rules["no-inline-comments"] = require("./rules/no-inline-comments");
    rules["no-inner-declarations"] = require("./rules/no-inner-declarations");
    rules["no-invalid-regexp"] = require("./rules/no-invalid-regexp");
    rules["no-invalid-this"] = require("./rules/no-invalid-this");
    rules["no-irregular-whitespace"] = require("./rules/no-irregular-whitespace");
    rules["no-iterator"] = require("./rules/no-iterator");
    rules["no-label-var"] = require("./rules/no-label-var");
    rules["no-labels"] = require("./rules/no-labels");
    rules["no-lone-blocks"] = require("./rules/no-lone-blocks");
    rules["no-lonely-if"] = require("./rules/no-lonely-if");
    rules["no-loop-func"] = require("./rules/no-loop-func");
    rules["no-magic-numbers"] = require("./rules/no-magic-numbers");
    rules["no-mixed-requires"] = require("./rules/no-mixed-requires");
    rules["no-mixed-spaces-and-tabs"] = require("./rules/no-mixed-spaces-and-tabs");
    rules["no-multi-spaces"] = require("./rules/no-multi-spaces");
    rules["no-multi-str"] = require("./rules/no-multi-str");
    rules["no-multiple-empty-lines"] = require("./rules/no-multiple-empty-lines");
    rules["no-native-reassign"] = require("./rules/no-native-reassign");
    rules["no-negated-condition"] = require("./rules/no-negated-condition");
    rules["no-negated-in-lhs"] = require("./rules/no-negated-in-lhs");
    rules["no-nested-ternary"] = require("./rules/no-nested-ternary");
    rules["no-new-func"] = require("./rules/no-new-func");
    rules["no-new-object"] = require("./rules/no-new-object");
    rules["no-new-require"] = require("./rules/no-new-require");
    rules["no-new-symbol"] = require("./rules/no-new-symbol");
    rules["no-new-wrappers"] = require("./rules/no-new-wrappers");
    rules["no-new"] = require("./rules/no-new");
    rules["no-obj-calls"] = require("./rules/no-obj-calls");
    rules["no-octal-escape"] = require("./rules/no-octal-escape");
    rules["no-octal"] = require("./rules/no-octal");
    rules["no-param-reassign"] = require("./rules/no-param-reassign");
    rules["no-path-concat"] = require("./rules/no-path-concat");
    rules["no-plusplus"] = require("./rules/no-plusplus");
    rules["no-process-env"] = require("./rules/no-process-env");
    rules["no-process-exit"] = require("./rules/no-process-exit");
    rules["no-proto"] = require("./rules/no-proto");
    rules["no-redeclare"] = require("./rules/no-redeclare");
    rules["no-regex-spaces"] = require("./rules/no-regex-spaces");
    rules["no-restricted-globals"] = require("./rules/no-restricted-globals");
    rules["no-restricted-imports"] = require("./rules/no-restricted-imports");
    rules["no-restricted-modules"] = require("./rules/no-restricted-modules");
    rules["no-restricted-syntax"] = require("./rules/no-restricted-syntax");
    rules["no-return-assign"] = require("./rules/no-return-assign");
    rules["no-script-url"] = require("./rules/no-script-url");
    rules["no-self-assign"] = require("./rules/no-self-assign");
    rules["no-self-compare"] = require("./rules/no-self-compare");
    rules["no-sequences"] = require("./rules/no-sequences");
    rules["no-shadow-restricted-names"] = require("./rules/no-shadow-restricted-names");
    rules["no-shadow"] = require("./rules/no-shadow");
    rules["no-spaced-func"] = require("./rules/no-spaced-func");
    rules["no-sparse-arrays"] = require("./rules/no-sparse-arrays");
    rules["no-sync"] = require("./rules/no-sync");
    rules["no-ternary"] = require("./rules/no-ternary");
    rules["no-this-before-super"] = require("./rules/no-this-before-super");
    rules["no-throw-literal"] = require("./rules/no-throw-literal");
    rules["no-trailing-spaces"] = require("./rules/no-trailing-spaces");
    rules["no-undef-init"] = require("./rules/no-undef-init");
    rules["no-undef"] = require("./rules/no-undef");
    rules["no-undefined"] = require("./rules/no-undefined");
    rules["no-underscore-dangle"] = require("./rules/no-underscore-dangle");
    rules["no-unexpected-multiline"] = require("./rules/no-unexpected-multiline");
    rules["no-unmodified-loop-condition"] = require("./rules/no-unmodified-loop-condition");
    rules["no-unneeded-ternary"] = require("./rules/no-unneeded-ternary");
    rules["no-unreachable"] = require("./rules/no-unreachable");
    rules["no-unused-expressions"] = require("./rules/no-unused-expressions");
    rules["no-unused-labels"] = require("./rules/no-unused-labels");
    rules["no-unused-vars"] = require("./rules/no-unused-vars");
    rules["no-use-before-define"] = require("./rules/no-use-before-define");
    rules["no-useless-call"] = require("./rules/no-useless-call");
    rules["no-useless-concat"] = require("./rules/no-useless-concat");
    rules["no-useless-constructor"] = require("./rules/no-useless-constructor");
    rules["no-var"] = require("./rules/no-var");
    rules["no-void"] = require("./rules/no-void");
    rules["no-warning-comments"] = require("./rules/no-warning-comments");
    rules["no-whitespace-before-property"] = require("./rules/no-whitespace-before-property");
    rules["no-with"] = require("./rules/no-with");
    rules["object-curly-spacing"] = require("./rules/object-curly-spacing");
    rules["object-shorthand"] = require("./rules/object-shorthand");
    rules["one-var-declaration-per-line"] = require("./rules/one-var-declaration-per-line");
    rules["one-var"] = require("./rules/one-var");
    rules["operator-assignment"] = require("./rules/operator-assignment");
    rules["operator-linebreak"] = require("./rules/operator-linebreak");
    rules["padded-blocks"] = require("./rules/padded-blocks");
    rules["prefer-arrow-callback"] = require("./rules/prefer-arrow-callback");
    rules["prefer-const"] = require("./rules/prefer-const");
    rules["prefer-reflect"] = require("./rules/prefer-reflect");
    rules["prefer-rest-params"] = require("./rules/prefer-rest-params");
    rules["prefer-spread"] = require("./rules/prefer-spread");
    rules["prefer-template"] = require("./rules/prefer-template");
    rules["quote-props"] = require("./rules/quote-props");
    rules["quotes"] = require("./rules/quotes");
    rules["radix"] = require("./rules/radix");
    rules["require-jsdoc"] = require("./rules/require-jsdoc");
    rules["require-yield"] = require("./rules/require-yield");
    rules["semi-spacing"] = require("./rules/semi-spacing");
    rules["semi"] = require("./rules/semi");
    rules["sort-imports"] = require("./rules/sort-imports");
    rules["sort-vars"] = require("./rules/sort-vars");
    rules["space-before-blocks"] = require("./rules/space-before-blocks");
    rules["space-before-function-paren"] = require("./rules/space-before-function-paren");
    rules["space-in-parens"] = require("./rules/space-in-parens");
    rules["space-infix-ops"] = require("./rules/space-infix-ops");
    rules["space-unary-ops"] = require("./rules/space-unary-ops");
    rules["spaced-comment"] = require("./rules/spaced-comment");
    rules["strict"] = require("./rules/strict");
    rules["template-curly-spacing"] = require("./rules/template-curly-spacing");
    rules["use-isnan"] = require("./rules/use-isnan");
    rules["valid-jsdoc"] = require("./rules/valid-jsdoc");
    rules["valid-typeof"] = require("./rules/valid-typeof");
    rules["vars-on-top"] = require("./rules/vars-on-top");
    rules["wrap-iife"] = require("./rules/wrap-iife");
    rules["wrap-regex"] = require("./rules/wrap-regex");
    rules["yield-star-spacing"] = require("./rules/yield-star-spacing");
    rules["yoda"] = require("./rules/yoda");

    return rules;
};
},
   {"./rules/accessor-pairs":"/tmp/rules/accessor-pairs.js","./rules/array-bracket-spacing":"/tmp/rules/array-bracket-spacing.js","./rules/array-callback-return":"/tmp/rules/array-callback-return.js","./rules/arrow-body-style":"/tmp/rules/arrow-body-style.js","./rules/arrow-parens":"/tmp/rules/arrow-parens.js","./rules/arrow-spacing":"/tmp/rules/arrow-spacing.js","./rules/block-scoped-var":"/tmp/rules/block-scoped-var.js","./rules/block-spacing":"/tmp/rules/block-spacing.js","./rules/brace-style":"/tmp/rules/brace-style.js","./rules/callback-return":"/tmp/rules/callback-return.js","./rules/camelcase":"/tmp/rules/camelcase.js","./rules/comma-dangle":"/tmp/rules/comma-dangle.js","./rules/comma-spacing":"/tmp/rules/comma-spacing.js","./rules/comma-style":"/tmp/rules/comma-style.js","./rules/complexity":"/tmp/rules/complexity.js","./rules/computed-property-spacing":"/tmp/rules/computed-property-spacing.js","./rules/consistent-return":"/tmp/rules/consistent-return.js","./rules/consistent-this":"/tmp/rules/consistent-this.js","./rules/constructor-super":"/tmp/rules/constructor-super.js","./rules/curly":"/tmp/rules/curly.js","./rules/default-case":"/tmp/rules/default-case.js","./rules/dot-location":"/tmp/rules/dot-location.js","./rules/dot-notation":"/tmp/rules/dot-notation.js","./rules/eol-last":"/tmp/rules/eol-last.js","./rules/eqeqeq":"/tmp/rules/eqeqeq.js","./rules/func-names":"/tmp/rules/func-names.js","./rules/func-style":"/tmp/rules/func-style.js","./rules/generator-star-spacing":"/tmp/rules/generator-star-spacing.js","./rules/global-require":"/tmp/rules/global-require.js","./rules/guard-for-in":"/tmp/rules/guard-for-in.js","./rules/handle-callback-err":"/tmp/rules/handle-callback-err.js","./rules/id-blacklist":"/tmp/rules/id-blacklist.js","./rules/id-length":"/tmp/rules/id-length.js","./rules/id-match":"/tmp/rules/id-match.js","./rules/indent":"/tmp/rules/indent.js","./rules/init-declarations":"/tmp/rules/init-declarations.js","./rules/jsx-quotes":"/tmp/rules/jsx-quotes.js","./rules/key-spacing":"/tmp/rules/key-spacing.js","./rules/keyword-spacing":"/tmp/rules/keyword-spacing.js","./rules/linebreak-style":"/tmp/rules/linebreak-style.js","./rules/lines-around-comment":"/tmp/rules/lines-around-comment.js","./rules/max-depth":"/tmp/rules/max-depth.js","./rules/max-len":"/tmp/rules/max-len.js","./rules/max-nested-callbacks":"/tmp/rules/max-nested-callbacks.js","./rules/max-params":"/tmp/rules/max-params.js","./rules/max-statements":"/tmp/rules/max-statements.js","./rules/new-cap":"/tmp/rules/new-cap.js","./rules/new-parens":"/tmp/rules/new-parens.js","./rules/newline-after-var":"/tmp/rules/newline-after-var.js","./rules/newline-before-return":"/tmp/rules/newline-before-return.js","./rules/newline-per-chained-call":"/tmp/rules/newline-per-chained-call.js","./rules/no-alert":"/tmp/rules/no-alert.js","./rules/no-array-constructor":"/tmp/rules/no-array-constructor.js","./rules/no-bitwise":"/tmp/rules/no-bitwise.js","./rules/no-caller":"/tmp/rules/no-caller.js","./rules/no-case-declarations":"/tmp/rules/no-case-declarations.js","./rules/no-catch-shadow":"/tmp/rules/no-catch-shadow.js","./rules/no-class-assign":"/tmp/rules/no-class-assign.js","./rules/no-cond-assign":"/tmp/rules/no-cond-assign.js","./rules/no-confusing-arrow":"/tmp/rules/no-confusing-arrow.js","./rules/no-console":"/tmp/rules/no-console.js","./rules/no-const-assign":"/tmp/rules/no-const-assign.js","./rules/no-constant-condition":"/tmp/rules/no-constant-condition.js","./rules/no-continue":"/tmp/rules/no-continue.js","./rules/no-control-regex":"/tmp/rules/no-control-regex.js","./rules/no-debugger":"/tmp/rules/no-debugger.js","./rules/no-delete-var":"/tmp/rules/no-delete-var.js","./rules/no-div-regex":"/tmp/rules/no-div-regex.js","./rules/no-dupe-args":"/tmp/rules/no-dupe-args.js","./rules/no-dupe-class-members":"/tmp/rules/no-dupe-class-members.js","./rules/no-dupe-keys":"/tmp/rules/no-dupe-keys.js","./rules/no-duplicate-case":"/tmp/rules/no-duplicate-case.js","./rules/no-else-return":"/tmp/rules/no-else-return.js","./rules/no-empty":"/tmp/rules/no-empty.js","./rules/no-empty-character-class":"/tmp/rules/no-empty-character-class.js","./rules/no-empty-function":"/tmp/rules/no-empty-function.js","./rules/no-empty-pattern":"/tmp/rules/no-empty-pattern.js","./rules/no-eq-null":"/tmp/rules/no-eq-null.js","./rules/no-eval":"/tmp/rules/no-eval.js","./rules/no-ex-assign":"/tmp/rules/no-ex-assign.js","./rules/no-extend-native":"/tmp/rules/no-extend-native.js","./rules/no-extra-bind":"/tmp/rules/no-extra-bind.js","./rules/no-extra-boolean-cast":"/tmp/rules/no-extra-boolean-cast.js","./rules/no-extra-label":"/tmp/rules/no-extra-label.js","./rules/no-extra-parens":"/tmp/rules/no-extra-parens.js","./rules/no-extra-semi":"/tmp/rules/no-extra-semi.js","./rules/no-fallthrough":"/tmp/rules/no-fallthrough.js","./rules/no-floating-decimal":"/tmp/rules/no-floating-decimal.js","./rules/no-func-assign":"/tmp/rules/no-func-assign.js","./rules/no-implicit-coercion":"/tmp/rules/no-implicit-coercion.js","./rules/no-implicit-globals":"/tmp/rules/no-implicit-globals.js","./rules/no-implied-eval":"/tmp/rules/no-implied-eval.js","./rules/no-inline-comments":"/tmp/rules/no-inline-comments.js","./rules/no-inner-declarations":"/tmp/rules/no-inner-declarations.js","./rules/no-invalid-regexp":"/tmp/rules/no-invalid-regexp.js","./rules/no-invalid-this":"/tmp/rules/no-invalid-this.js","./rules/no-irregular-whitespace":"/tmp/rules/no-irregular-whitespace.js","./rules/no-iterator":"/tmp/rules/no-iterator.js","./rules/no-label-var":"/tmp/rules/no-label-var.js","./rules/no-labels":"/tmp/rules/no-labels.js","./rules/no-lone-blocks":"/tmp/rules/no-lone-blocks.js","./rules/no-lonely-if":"/tmp/rules/no-lonely-if.js","./rules/no-loop-func":"/tmp/rules/no-loop-func.js","./rules/no-magic-numbers":"/tmp/rules/no-magic-numbers.js","./rules/no-mixed-requires":"/tmp/rules/no-mixed-requires.js","./rules/no-mixed-spaces-and-tabs":"/tmp/rules/no-mixed-spaces-and-tabs.js","./rules/no-multi-spaces":"/tmp/rules/no-multi-spaces.js","./rules/no-multi-str":"/tmp/rules/no-multi-str.js","./rules/no-multiple-empty-lines":"/tmp/rules/no-multiple-empty-lines.js","./rules/no-native-reassign":"/tmp/rules/no-native-reassign.js","./rules/no-negated-condition":"/tmp/rules/no-negated-condition.js","./rules/no-negated-in-lhs":"/tmp/rules/no-negated-in-lhs.js","./rules/no-nested-ternary":"/tmp/rules/no-nested-ternary.js","./rules/no-new":"/tmp/rules/no-new.js","./rules/no-new-func":"/tmp/rules/no-new-func.js","./rules/no-new-object":"/tmp/rules/no-new-object.js","./rules/no-new-require":"/tmp/rules/no-new-require.js","./rules/no-new-symbol":"/tmp/rules/no-new-symbol.js","./rules/no-new-wrappers":"/tmp/rules/no-new-wrappers.js","./rules/no-obj-calls":"/tmp/rules/no-obj-calls.js","./rules/no-octal":"/tmp/rules/no-octal.js","./rules/no-octal-escape":"/tmp/rules/no-octal-escape.js","./rules/no-param-reassign":"/tmp/rules/no-param-reassign.js","./rules/no-path-concat":"/tmp/rules/no-path-concat.js","./rules/no-plusplus":"/tmp/rules/no-plusplus.js","./rules/no-process-env":"/tmp/rules/no-process-env.js","./rules/no-process-exit":"/tmp/rules/no-process-exit.js","./rules/no-proto":"/tmp/rules/no-proto.js","./rules/no-redeclare":"/tmp/rules/no-redeclare.js","./rules/no-regex-spaces":"/tmp/rules/no-regex-spaces.js","./rules/no-restricted-globals":"/tmp/rules/no-restricted-globals.js","./rules/no-restricted-imports":"/tmp/rules/no-restricted-imports.js","./rules/no-restricted-modules":"/tmp/rules/no-restricted-modules.js","./rules/no-restricted-syntax":"/tmp/rules/no-restricted-syntax.js","./rules/no-return-assign":"/tmp/rules/no-return-assign.js","./rules/no-script-url":"/tmp/rules/no-script-url.js","./rules/no-self-assign":"/tmp/rules/no-self-assign.js","./rules/no-self-compare":"/tmp/rules/no-self-compare.js","./rules/no-sequences":"/tmp/rules/no-sequences.js","./rules/no-shadow":"/tmp/rules/no-shadow.js","./rules/no-shadow-restricted-names":"/tmp/rules/no-shadow-restricted-names.js","./rules/no-spaced-func":"/tmp/rules/no-spaced-func.js","./rules/no-sparse-arrays":"/tmp/rules/no-sparse-arrays.js","./rules/no-sync":"/tmp/rules/no-sync.js","./rules/no-ternary":"/tmp/rules/no-ternary.js","./rules/no-this-before-super":"/tmp/rules/no-this-before-super.js","./rules/no-throw-literal":"/tmp/rules/no-throw-literal.js","./rules/no-trailing-spaces":"/tmp/rules/no-trailing-spaces.js","./rules/no-undef":"/tmp/rules/no-undef.js","./rules/no-undef-init":"/tmp/rules/no-undef-init.js","./rules/no-undefined":"/tmp/rules/no-undefined.js","./rules/no-underscore-dangle":"/tmp/rules/no-underscore-dangle.js","./rules/no-unexpected-multiline":"/tmp/rules/no-unexpected-multiline.js","./rules/no-unmodified-loop-condition":"/tmp/rules/no-unmodified-loop-condition.js","./rules/no-unneeded-ternary":"/tmp/rules/no-unneeded-ternary.js","./rules/no-unreachable":"/tmp/rules/no-unreachable.js","./rules/no-unused-expressions":"/tmp/rules/no-unused-expressions.js","./rules/no-unused-labels":"/tmp/rules/no-unused-labels.js","./rules/no-unused-vars":"/tmp/rules/no-unused-vars.js","./rules/no-use-before-define":"/tmp/rules/no-use-before-define.js","./rules/no-useless-call":"/tmp/rules/no-useless-call.js","./rules/no-useless-concat":"/tmp/rules/no-useless-concat.js","./rules/no-useless-constructor":"/tmp/rules/no-useless-constructor.js","./rules/no-var":"/tmp/rules/no-var.js","./rules/no-void":"/tmp/rules/no-void.js","./rules/no-warning-comments":"/tmp/rules/no-warning-comments.js","./rules/no-whitespace-before-property":"/tmp/rules/no-whitespace-before-property.js","./rules/no-with":"/tmp/rules/no-with.js","./rules/object-curly-spacing":"/tmp/rules/object-curly-spacing.js","./rules/object-shorthand":"/tmp/rules/object-shorthand.js","./rules/one-var":"/tmp/rules/one-var.js","./rules/one-var-declaration-per-line":"/tmp/rules/one-var-declaration-per-line.js","./rules/operator-assignment":"/tmp/rules/operator-assignment.js","./rules/operator-linebreak":"/tmp/rules/operator-linebreak.js","./rules/padded-blocks":"/tmp/rules/padded-blocks.js","./rules/prefer-arrow-callback":"/tmp/rules/prefer-arrow-callback.js","./rules/prefer-const":"/tmp/rules/prefer-const.js","./rules/prefer-reflect":"/tmp/rules/prefer-reflect.js","./rules/prefer-rest-params":"/tmp/rules/prefer-rest-params.js","./rules/prefer-spread":"/tmp/rules/prefer-spread.js","./rules/prefer-template":"/tmp/rules/prefer-template.js","./rules/quote-props":"/tmp/rules/quote-props.js","./rules/quotes":"/tmp/rules/quotes.js","./rules/radix":"/tmp/rules/radix.js","./rules/require-jsdoc":"/tmp/rules/require-jsdoc.js","./rules/require-yield":"/tmp/rules/require-yield.js","./rules/semi":"/tmp/rules/semi.js","./rules/semi-spacing":"/tmp/rules/semi-spacing.js","./rules/sort-imports":"/tmp/rules/sort-imports.js","./rules/sort-vars":"/tmp/rules/sort-vars.js","./rules/space-before-blocks":"/tmp/rules/space-before-blocks.js","./rules/space-before-function-paren":"/tmp/rules/space-before-function-paren.js","./rules/space-in-parens":"/tmp/rules/space-in-parens.js","./rules/space-infix-ops":"/tmp/rules/space-infix-ops.js","./rules/space-unary-ops":"/tmp/rules/space-unary-ops.js","./rules/spaced-comment":"/tmp/rules/spaced-comment.js","./rules/strict":"/tmp/rules/strict.js","./rules/template-curly-spacing":"/tmp/rules/template-curly-spacing.js","./rules/use-isnan":"/tmp/rules/use-isnan.js","./rules/valid-jsdoc":"/tmp/rules/valid-jsdoc.js","./rules/valid-typeof":"/tmp/rules/valid-typeof.js","./rules/vars-on-top":"/tmp/rules/vars-on-top.js","./rules/wrap-iife":"/tmp/rules/wrap-iife.js","./rules/wrap-regex":"/tmp/rules/wrap-regex.js","./rules/yield-star-spacing":"/tmp/rules/yield-star-spacing.js","./rules/yoda":"/tmp/rules/yoda.js","eslint-plugin-react":"/node_modules/eslint-plugin-react/index.js"}],

"/tmp/rule-context.js": [function(require,module,exports){
"use strict";

var RuleFixer = require("./util/rule-fixer");

var PASSTHROUGHS = [
    "getAllComments",
    "getAncestors",
    "getComments",
    "getDeclaredVariables",
    "getFilename",
    "getFirstToken",
    "getFirstTokens",
    "getJSDocComment",
    "getLastToken",
    "getLastTokens",
    "getNodeByRangeIndex",
    "getScope",
    "getSource",
    "getSourceLines",
    "getTokenAfter",
    "getTokenBefore",
    "getTokenByRangeStart",
    "getTokens",
    "getTokensAfter",
    "getTokensBefore",
    "getTokensBetween",
    "markVariableAsUsed"
];

function RuleContext(ruleId, eslint, severity, options, settings, parserOptions, parserPath, meta) {
    this.id = ruleId;
    this.options = options;
    this.settings = settings;
    this.parserOptions = parserOptions;
    this.parserPath = parserPath;
    this.meta = meta;

    this.eslint = eslint;
    this.severity = severity;

    Object.freeze(this);
}

RuleContext.prototype = {
    constructor: RuleContext,

    getSourceCode: function() {
        return this.eslint.getSourceCode();
    },

    report: function(nodeOrDescriptor, location, message, opts) {
        var descriptor,
            fix = null;

        if (arguments.length === 1) {
            descriptor = nodeOrDescriptor;

            if (typeof descriptor.fix === "function") {
                fix = descriptor.fix(new RuleFixer());
            }

            this.eslint.report(
                this.id,
                this.severity,
                descriptor.node,
                descriptor.loc || descriptor.node.loc.start,
                descriptor.message,
                descriptor.data,
                fix,
                this.meta
            );

            return;
        }

        this.eslint.report(
            this.id,
            this.severity,
            nodeOrDescriptor,
            location,
            message,
            opts,
            this.meta
        );
    }
};

PASSTHROUGHS.forEach(function(name) {
    this[name] = function(a, b, c, d, e) {
        return this.eslint[name](a, b, c, d, e);
    };
}, RuleContext.prototype);

module.exports = RuleContext;

},
   {"./util/rule-fixer":"/tmp/util/rule-fixer.js"}],

"/tmp/rules.js": [function(require,module,exports){
"use strict";

var loadRules = require("./load-rules");

var rules = Object.create(null);

function define(ruleId, ruleModule) {
    rules[ruleId] = ruleModule;
}

function load(rulesDir, cwd) {
    var newRules = loadRules(rulesDir, cwd);
    Object.keys(newRules).forEach(function(ruleId) {
        define(ruleId, newRules[ruleId]);
    });
}

function importPlugin(pluginRules, pluginName) {
    Object.keys(pluginRules).forEach(function(ruleId) {
        var qualifiedRuleId = pluginName + "/" + ruleId,
            rule = pluginRules[ruleId];

        define(qualifiedRuleId, rule);
    });
}

function get(ruleId) {
    if (typeof rules[ruleId] === "string") {
        return require(rules[ruleId]);
    } else {
        return rules[ruleId];
    }
}

function testClear() {
    rules = Object.create(null);
}

module.exports = {
    define: define,
    load: load,
    import: importPlugin,
    get: get,
    testClear: testClear,

    testReset: function() {
        testClear();
        load();
    }
};

load();

},
   {"./load-rules":"/tmp/load-rules.js"}],

"/tmp/rules/accessor-pairs.js": [function(require,module,exports){
"use strict";

function isIdentifier(node, name) {
    return node.type === "Identifier" && node.name === name;
}

function isArgumentOfMethodCall(node, index, object, property) {
    var parent = node.parent;
    return (
        parent.type === "CallExpression" &&
        parent.callee.type === "MemberExpression" &&
        parent.callee.computed === false &&
        isIdentifier(parent.callee.object, object) &&
        isIdentifier(parent.callee.property, property) &&
        parent.arguments[index] === node
    );
}

function isPropertyDescriptor(node) {
    if (isArgumentOfMethodCall(node, 2, "Object", "defineProperty") ||
        isArgumentOfMethodCall(node, 2, "Reflect", "defineProperty")
    ) {
        return true;
    }

    node = node.parent.parent;
    return node.type === "ObjectExpression" && (
        isArgumentOfMethodCall(node, 1, "Object", "create") ||
        isArgumentOfMethodCall(node, 1, "Object", "defineProperties")
    );
}

module.exports = {
    meta: {
        docs: {
            description: "Enforces getter/setter pairs in objects",
            category: "Best Practices",
            recommended: false
        },
        schema: [{
            "type": "object",
            "properties": {
                "getWithoutSet": {
                    "type": "boolean"
                },
                "setWithoutGet": {
                    "type": "boolean"
                }
            },
            "additionalProperties": false
        }]
    },
    create: function(context) {
        var config = context.options[0] || {};
        var checkGetWithoutSet = config.getWithoutSet === true;
        var checkSetWithoutGet = config.setWithoutGet !== false;

        function checkLonelySetGet(node) {
            var isSetPresent = false;
            var isGetPresent = false;
            var isDescriptor = isPropertyDescriptor(node);

            for (var i = 0, end = node.properties.length; i < end; i++) {
                var property = node.properties[i];

                var propToCheck = "";
                if (property.kind === "init") {
                    if (isDescriptor && !property.computed) {
                        propToCheck = property.key.name;
                    }
                } else {
                    propToCheck = property.kind;
                }

                switch (propToCheck) {
                    case "set":
                        isSetPresent = true;
                        break;

                    case "get":
                        isGetPresent = true;
                        break;

                    default:
                }

                if (isSetPresent && isGetPresent) {
                    break;
                }
            }

            if (checkSetWithoutGet && isSetPresent && !isGetPresent) {
                context.report(node, "Getter is not present");
            } else if (checkGetWithoutSet && isGetPresent && !isSetPresent) {
                context.report(node, "Setter is not present");
            }
        }

        return {
            "ObjectExpression": function(node) {
                if (checkSetWithoutGet || checkGetWithoutSet) {
                    checkLonelySetGet(node);
                }
            }
        };
    }
};

},
   {}],

"/tmp/rules/array-bracket-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = {
    meta: {
        docs: {
            description: "Enforce spacing inside array brackets",
            category: "Stylistic Issues",
            recommended: false,
            fixable: "whitespace"
        },
        schema: [
            {
                "enum": ["always", "never"]
            },
            {
                "type": "object",
                "properties": {
                    "singleValue": {
                        "type": "boolean"
                    },
                    "objectsInArrays": {
                        "type": "boolean"
                    },
                    "arraysInArrays": {
                        "type": "boolean"
                    }
                },
                "additionalProperties": false
            }
        ]
    },
    create: function(context) {
        var spaced = context.options[0] === "always",
            sourceCode = context.getSourceCode();

        function isOptionSet(option) {
            return context.options[1] ? context.options[1][option] === !spaced : false;
        }

        var options = {
            spaced: spaced,
            singleElementException: isOptionSet("singleValue"),
            objectsInArraysException: isOptionSet("objectsInArrays"),
            arraysInArraysException: isOptionSet("arraysInArrays")
        };

        function reportNoBeginningSpace(node, token) {
            context.report({
                node: node,
                loc: token.loc.start,
                message: "There should be no space after '" + token.value + "'",
                fix: function(fixer) {
                    var nextToken = context.getSourceCode().getTokenAfter(token);
                    return fixer.removeRange([token.range[1], nextToken.range[0]]);
                }
            });
        }

        function reportNoEndingSpace(node, token) {
            context.report({
                node: node,
                loc: token.loc.start,
                message: "There should be no space before '" + token.value + "'",
                fix: function(fixer) {
                    var previousToken = context.getSourceCode().getTokenBefore(token);
                    return fixer.removeRange([previousToken.range[1], token.range[0]]);
                }
            });
        }

        function reportRequiredBeginningSpace(node, token) {
            context.report({
                node: node,
                loc: token.loc.start,
                message: "A space is required after '" + token.value + "'",
                fix: function(fixer) {
                    return fixer.insertTextAfter(token, " ");
                }
            });
        }

        function reportRequiredEndingSpace(node, token) {
            context.report({
                node: node,
                loc: token.loc.start,
                message: "A space is required before '" + token.value + "'",
                fix: function(fixer) {
                    return fixer.insertTextBefore(token, " ");
                }
            });
        }

        function isObjectType(node) {
            return node && (node.type === "ObjectExpression" || node.type === "ObjectPattern");
        }

        function isArrayType(node) {
            return node && (node.type === "ArrayExpression" || node.type === "ArrayPattern");
        }

        function validateArraySpacing(node) {
            if (options.spaced && node.elements.length === 0) {
                return;
            }

            var first = context.getFirstToken(node),
                second = context.getFirstToken(node, 1),
                penultimate = context.getLastToken(node, 1),
                last = context.getLastToken(node),
                firstElement = node.elements[0],
                lastElement = node.elements[node.elements.length - 1];

            var openingBracketMustBeSpaced =
                options.objectsInArraysException && isObjectType(firstElement) ||
                options.arraysInArraysException && isArrayType(firstElement) ||
                options.singleElementException && node.elements.length === 1
                    ? !options.spaced : options.spaced;

            var closingBracketMustBeSpaced =
                options.objectsInArraysException && isObjectType(lastElement) ||
                options.arraysInArraysException && isArrayType(lastElement) ||
                options.singleElementException && node.elements.length === 1
                    ? !options.spaced : options.spaced;

            if (astUtils.isTokenOnSameLine(first, second)) {
                if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {
                    reportRequiredBeginningSpace(node, first);
                }
                if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {
                    reportNoBeginningSpace(node, first);
                }
            }

            if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {
                if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {
                    reportRequiredEndingSpace(node, last);
                }
                if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {
                    reportNoEndingSpace(node, last);
                }
            }
        }

        return {
            ArrayPattern: validateArraySpacing,
            ArrayExpression: validateArraySpacing
        };
    }
};

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/array-callback-return.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

var TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;
var TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/;

function isReachable(segment) {
    return segment.reachable;
}

function getLocation(node, sourceCode) {
    if (node.type === "ArrowFunctionExpression") {
        return sourceCode.getTokenBefore(node.body);
    }
    return node.id || node;
}

function getIdentifierName(node) {
    return node.type === "Identifier" ? node.name : "";
}

function getConstantStringValue(node) {
    switch (node.type) {
        case "Literal":
            return String(node.value);

        case "TemplateLiteral":
            return node.expressions.length === 0
                ? node.quasis[0].value.cooked
                : "";

        default:
            return "";
    }
}

function isTargetMethod(node) {
    return (
        node.type === "MemberExpression" &&
        TARGET_METHODS.test(
            (node.computed ? getConstantStringValue : getIdentifierName)(node.property)
        )
    );
}

function isCallbackOfArrayMethod(node) {
    while (node) {
        var parent = node.parent;
        switch (parent.type) {
            case "LogicalExpression":
            case "ConditionalExpression":
                node = parent;
                break;

            case "ReturnStatement":
                var func = astUtils.getUpperFunction(parent);
                if (func === null || !astUtils.isCallee(func)) {
                    return false;
                }
                node = func.parent;
                break;

            case "CallExpression":
                if (astUtils.isArrayFromMethod(parent.callee)) {
                    return (
                        parent.arguments.length >= 2 &&
                        parent.arguments[1] === node
                    );
                }
                if (isTargetMethod(parent.callee)) {
                    return (
                        parent.arguments.length >= 1 &&
                        parent.arguments[0] === node
                    );
                }
                return false;

            default:
                return false;
        }
    }

    return false;
}

module.exports = function(context) {
    var funcInfo = {
        upper: null,
        codePath: null,
        hasReturn: false,
        shouldCheck: false
    };

    function checkLastSegment(node) {
        if (funcInfo.shouldCheck &&
            funcInfo.codePath.currentSegments.some(isReachable)
        ) {
            context.report({
                node: node,
                loc: getLocation(node, context.getSourceCode()).loc.start,
                message: funcInfo.hasReturn
                    ? "Expected to return a value at the end of this function."
                    : "Expected to return a value in this function."
            });
        }
    }

    return {
        "onCodePathStart": function(codePath, node) {
            funcInfo = {
                upper: funcInfo,
                codePath: codePath,
                hasReturn: false,
                shouldCheck:
                    TARGET_NODE_TYPE.test(node.type) &&
                    node.body.type === "BlockStatement" &&
                    isCallbackOfArrayMethod(node)
            };
        },

        "onCodePathEnd": function() {
            funcInfo = funcInfo.upper;
        },

        "ReturnStatement": function(node) {
            if (funcInfo.shouldCheck) {
                funcInfo.hasReturn = true;

                if (!node.argument) {
                    context.report({
                        node: node,
                        message: "Expected a return value."
                    });
                }
            }
        },

        "FunctionExpression:exit": checkLastSegment,
        "ArrowFunctionExpression:exit": checkLastSegment
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/arrow-body-style.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var always = context.options[0] === "always";
    var asNeeded = !context.options[0] || context.options[0] === "as-needed";

    function validate(node) {
        var arrowBody = node.body;
        if (arrowBody.type === "BlockStatement") {
            var blockBody = arrowBody.body;

            if (blockBody.length !== 1) {
                return;
            }

            if (asNeeded && blockBody[0].type === "ReturnStatement") {
                context.report({
                    node: node,
                    loc: arrowBody.loc.start,
                    message: "Unexpected block statement surrounding arrow body."
                });
            }
        } else {
            if (always) {
                context.report({
                    node: node,
                    loc: arrowBody.loc.start,
                    message: "Expected block statement surrounding arrow body."
                });
            }
        }
    }

    return {
        "ArrowFunctionExpression": validate
    };
};

module.exports.schema = [
    {
        "enum": ["always", "as-needed"]
    }
];

},
   {}],

"/tmp/rules/arrow-parens.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var message = "Expected parentheses around arrow function argument.";
    var asNeededMessage = "Unexpected parentheses around single function argument";
    var asNeeded = context.options[0] === "as-needed";

    function parens(node) {
        var token = context.getFirstToken(node);

        if (asNeeded && node.params.length === 1 && node.params[0].type === "Identifier") {
            if (token.type === "Punctuator" && token.value === "(") {
                context.report(node, asNeededMessage);
            }
            return;
        }

        if (token.type === "Identifier") {
            var after = context.getTokenAfter(token);

            if (after.value !== ")") {
                context.report(node, message);
            }
        }
    }

    return {
        "ArrowFunctionExpression": parens
    };
};

module.exports.schema = [
    {
        "enum": ["always", "as-needed"]
    }
];

},
   {}],

"/tmp/rules/arrow-spacing.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var rule = { before: true, after: true };
    var option = context.options[0] || {};
    rule.before = option.before !== false;
    rule.after = option.after !== false;

    function getTokens(node) {
        var t = context.getFirstToken(node);
        var before;
        while (t.type !== "Punctuator" || t.value !== "=>") {
            before = t;
            t = context.getTokenAfter(t);
        }
        var after = context.getTokenAfter(t);
        return { before: before, arrow: t, after: after };
    }

    function countSpaces(tokens) {
        var before = tokens.arrow.range[0] - tokens.before.range[1];
        var after = tokens.after.range[0] - tokens.arrow.range[1];
        return { before: before, after: after };
    }

    function spaces(node) {
        var tokens = getTokens(node);
        var countSpace = countSpaces(tokens);

        if (rule.before) {
            if (countSpace.before === 0) {
                context.report({
                    node: tokens.before,
                    message: "Missing space before =>",
                    fix: function(fixer) {
                        return fixer.insertTextBefore(tokens.arrow, " ");
                    }
                });
            }
        } else {
            if (countSpace.before > 0) {
                context.report({
                    node: tokens.before,
                    message: "Unexpected space before =>",
                    fix: function(fixer) {
                        return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);
                    }
                });
            }
        }

        if (rule.after) {
            if (countSpace.after === 0) {
                context.report({
                    node: tokens.after,
                    message: "Missing space after =>",
                    fix: function(fixer) {
                        return fixer.insertTextAfter(tokens.arrow, " ");
                    }
                });
            }
        } else {
            if (countSpace.after > 0) {
                context.report({
                    node: tokens.after,
                    message: "Unexpected space after =>",
                    fix: function(fixer) {
                        return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);
                    }
                });
            }
        }
    }

    return {
        "ArrowFunctionExpression": spaces
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "before": {
                "type": "boolean"
            },
            "after": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/block-scoped-var.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var stack = [];

    function enterScope(node) {
        stack.push(node.range);
    }

    function exitScope() {
        stack.pop();
    }

    function report(reference) {
        var identifier = reference.identifier;
        context.report(
            identifier,
            "'{{name}}' used outside of binding context.",
            {name: identifier.name});
    }

    function checkForVariables(node) {
        if (node.kind !== "var") {
            return;
        }

        var scopeRange = stack[stack.length - 1];

        function isOutsideOfScope(reference) {
            var idRange = reference.identifier.range;
            return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
        }

        var variables = context.getDeclaredVariables(node);
        for (var i = 0; i < variables.length; ++i) {
            variables[i]
                .references
                .filter(isOutsideOfScope)
                .forEach(report);
        }
    }

    return {
        "Program": function(node) {
            stack = [node.range];
        },

        "BlockStatement": enterScope,
        "BlockStatement:exit": exitScope,
        "ForStatement": enterScope,
        "ForStatement:exit": exitScope,
        "ForInStatement": enterScope,
        "ForInStatement:exit": exitScope,
        "ForOfStatement": enterScope,
        "ForOfStatement:exit": exitScope,
        "SwitchStatement": enterScope,
        "SwitchStatement:exit": exitScope,
        "CatchClause": enterScope,
        "CatchClause:exit": exitScope,

        "VariableDeclaration": checkForVariables
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/block-spacing.js": [function(require,module,exports){
"use strict";

var util = require("../ast-utils");

module.exports = function(context) {
    var always = (context.options[0] !== "never"),
        message = always ? "Requires a space" : "Unexpected space(s)",
        sourceCode = context.getSourceCode();

    function getOpenBrace(node) {
        if (node.type === "SwitchStatement") {
            if (node.cases.length > 0) {
                return context.getTokenBefore(node.cases[0]);
            }
            return context.getLastToken(node, 1);
        }
        return context.getFirstToken(node);
    }

    function isValid(left, right) {
        return (
            !util.isTokenOnSameLine(left, right) ||
            sourceCode.isSpaceBetweenTokens(left, right) === always
        );
    }

    function checkSpacingInsideBraces(node) {
        var openBrace = getOpenBrace(node);
        var closeBrace = context.getLastToken(node);
        var firstToken = sourceCode.getTokenOrCommentAfter(openBrace);
        var lastToken = sourceCode.getTokenOrCommentBefore(closeBrace);

        if (openBrace.type !== "Punctuator" ||
            openBrace.value !== "{" ||
            closeBrace.type !== "Punctuator" ||
            closeBrace.value !== "}" ||
            firstToken === closeBrace
        ) {
            return;
        }

        if (!always && firstToken.type === "Line") {
            return;
        }

        if (!isValid(openBrace, firstToken)) {
            context.report({
                node: node,
                loc: openBrace.loc.start,
                message: message + " after '{'.",
                fix: function(fixer) {
                    if (always) {
                        return fixer.insertTextBefore(firstToken, " ");
                    }

                    return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
                }
            });
        }
        if (!isValid(lastToken, closeBrace)) {
            context.report({
                node: node,
                loc: closeBrace.loc.start,
                message: message + " before '}'.",
                fix: function(fixer) {
                    if (always) {
                        return fixer.insertTextAfter(lastToken, " ");
                    }

                    return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
                }
            });
        }
    }

    return {
        BlockStatement: checkSpacingInsideBraces,
        SwitchStatement: checkSpacingInsideBraces
    };
};

module.exports.schema = [
    {enum: ["always", "never"]}
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/brace-style.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var style = context.options[0] || "1tbs",
        params = context.options[1] || {},
        sourceCode = context.getSourceCode();

    var OPEN_MESSAGE = "Opening curly brace does not appear on the same line as controlling statement.",
        OPEN_MESSAGE_ALLMAN = "Opening curly brace appears on the same line as controlling statement.",
        BODY_MESSAGE = "Statement inside of curly braces should be on next line.",
        CLOSE_MESSAGE = "Closing curly brace does not appear on the same line as the subsequent block.",
        CLOSE_MESSAGE_SINGLE = "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
        CLOSE_MESSAGE_STROUSTRUP_ALLMAN = "Closing curly brace appears on the same line as the subsequent block.";

    function isBlock(node) {
        return node && node.type === "BlockStatement";
    }

    function isCurlyPunctuator(token) {
        return token.value === "{" || token.value === "}";
    }

    function checkBlock() {
        var blockProperties = arguments;

        return function(node) {
            [].forEach.call(blockProperties, function(blockProp) {
                var block = node[blockProp], previousToken, curlyToken, curlyTokenEnd, curlyTokensOnSameLine;

                if (!isBlock(block)) {
                    return;
                }

                previousToken = sourceCode.getTokenBefore(block);
                curlyToken = sourceCode.getFirstToken(block);
                curlyTokenEnd = sourceCode.getLastToken(block);
                curlyTokensOnSameLine = curlyToken.loc.start.line === curlyTokenEnd.loc.start.line;

                if (style !== "allman" && previousToken.loc.start.line !== curlyToken.loc.start.line) {
                    context.report(node, OPEN_MESSAGE);
                } else if (style === "allman" && previousToken.loc.start.line === curlyToken.loc.start.line && !params.allowSingleLine) {
                    context.report(node, OPEN_MESSAGE_ALLMAN);
                }

                if (!block.body.length || curlyTokensOnSameLine && params.allowSingleLine) {
                    return;
                }

                if (curlyToken.loc.start.line === block.body[0].loc.start.line) {
                    context.report(block.body[0], BODY_MESSAGE);
                } else if (curlyTokenEnd.loc.start.line === block.body[block.body.length - 1].loc.start.line) {
                    context.report(block.body[block.body.length - 1], CLOSE_MESSAGE_SINGLE);
                }
            });
        };
    }

    function checkIfStatement(node) {
        var tokens;

        checkBlock("consequent", "alternate")(node);

        if (node.alternate) {

            tokens = sourceCode.getTokensBefore(node.alternate, 2);

            if (style === "1tbs") {
                if (tokens[0].loc.start.line !== tokens[1].loc.start.line &&
                    node.consequent.type === "BlockStatement" &&
                    isCurlyPunctuator(tokens[0]) ) {
                    context.report(node.alternate, CLOSE_MESSAGE);
                }
            } else if (tokens[0].loc.start.line === tokens[1].loc.start.line) {
                context.report(node.alternate, CLOSE_MESSAGE_STROUSTRUP_ALLMAN);
            }

        }
    }

    function checkTryStatement(node) {
        var tokens;

        checkBlock("block", "finalizer")(node);

        if (isBlock(node.finalizer)) {
            tokens = sourceCode.getTokensBefore(node.finalizer, 2);
            if (style === "1tbs") {
                if (tokens[0].loc.start.line !== tokens[1].loc.start.line) {
                    context.report(node.finalizer, CLOSE_MESSAGE);
                }
            } else if (tokens[0].loc.start.line === tokens[1].loc.start.line) {
                context.report(node.finalizer, CLOSE_MESSAGE_STROUSTRUP_ALLMAN);
            }
        }
    }

    function checkCatchClause(node) {
        var previousToken = sourceCode.getTokenBefore(node),
            firstToken = sourceCode.getFirstToken(node);

        checkBlock("body")(node);

        if (isBlock(node.body)) {
            if (style === "1tbs") {
                if (previousToken.loc.start.line !== firstToken.loc.start.line) {
                    context.report(node, CLOSE_MESSAGE);
                }
            } else {
                if (previousToken.loc.start.line === firstToken.loc.start.line) {
                    context.report(node, CLOSE_MESSAGE_STROUSTRUP_ALLMAN);
                }
            }
        }
    }

    function checkSwitchStatement(node) {
        var tokens;
        if (node.cases && node.cases.length) {
            tokens = sourceCode.getTokensBefore(node.cases[0], 2);
        } else {
            tokens = sourceCode.getLastTokens(node, 3);
        }

        if (style !== "allman" && tokens[0].loc.start.line !== tokens[1].loc.start.line) {
            context.report(node, OPEN_MESSAGE);
        } else if (style === "allman" && tokens[0].loc.start.line === tokens[1].loc.start.line) {
            context.report(node, OPEN_MESSAGE_ALLMAN);
        }
    }

    return {
        "FunctionDeclaration": checkBlock("body"),
        "FunctionExpression": checkBlock("body"),
        "ArrowFunctionExpression": checkBlock("body"),
        "IfStatement": checkIfStatement,
        "TryStatement": checkTryStatement,
        "CatchClause": checkCatchClause,
        "DoWhileStatement": checkBlock("body"),
        "WhileStatement": checkBlock("body"),
        "WithStatement": checkBlock("body"),
        "ForStatement": checkBlock("body"),
        "ForInStatement": checkBlock("body"),
        "ForOfStatement": checkBlock("body"),
        "SwitchStatement": checkSwitchStatement
    };

};

module.exports.schema = [
    {
        "enum": ["1tbs", "stroustrup", "allman"]
    },
    {
        "type": "object",
        "properties": {
            "allowSingleLine": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/callback-return.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var callbacks = context.options[0] || ["callback", "cb", "next"];

    function findClosestParentOfType(node, types) {
        if (!node.parent) {
            return null;
        }
        if (types.indexOf(node.parent.type) === -1) {
            return findClosestParentOfType(node.parent, types);
        }
        return node.parent;
    }

    function isCallback(node) {
        return node.callee.type === "Identifier" && callbacks.indexOf(node.callee.name) > -1;
    }

    function isCallbackExpression(node, parentNode) {
        if (!parentNode || parentNode.type !== "ExpressionStatement") {
            return false;
        }

        if (parentNode.expression === node) {
            return true;
        }

        if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") {
            if (parentNode.expression.right === node) {
                return true;
            }
        }

        return false;
    }

    return {
        "CallExpression": function(node) {

            if (!isCallback(node)) {
                return;
            }

            var closestBlock = findClosestParentOfType(node, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {},
                lastItem, parentType;

            if (closestBlock.type === "ReturnStatement" ) {
                return;
            }

            if (closestBlock.type === "ArrowFunctionExpression") {
                return;
            }

            if (closestBlock.type === "BlockStatement") {

                lastItem = closestBlock.body[closestBlock.body.length - 1];

                if (isCallbackExpression(node, lastItem)) {

                    parentType = closestBlock.parent.type;

                    if (parentType === "FunctionExpression" ||
                        parentType === "FunctionDeclaration" ||
                        parentType === "ArrowFunctionExpression"
                    ) {
                        return;
                    }

                }

                if (lastItem.type === "ReturnStatement") {

                    if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {
                        return;
                    }
                }

            }

            if (findClosestParentOfType(node, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"])) {
                context.report(node, "Expected return with your callback function.");
            }

        }

    };
};

module.exports.schema = [{
    type: "array",
    items: { type: "string" }
}];

},
   {}],

"/tmp/rules/camelcase.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var reported = [];

    function isUnderscored(name) {

        return name.indexOf("_") > -1 && name !== name.toUpperCase();
    }

    function report(node) {
        if (reported.indexOf(node) < 0) {
            reported.push(node);
            context.report(node, "Identifier '{{name}}' is not in camel case.", { name: node.name });
        }
    }

    var options = context.options[0] || {},
        properties = options.properties || "";

    if (properties !== "always" && properties !== "never") {
        properties = "always";
    }

    return {

        "Identifier": function(node) {
            var name = node.name.replace(/^_+|_+$/g, ""),
                effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;

            if (node.parent.type === "MemberExpression") {

                if (properties === "never") {
                    return;
                }

                if (node.parent.object.type === "Identifier" &&
                        node.parent.object.name === node.name &&
                        isUnderscored(name)) {
                    report(node);

                } else if (effectiveParent.type === "AssignmentExpression" &&
                        isUnderscored(name) &&
                        (effectiveParent.right.type !== "MemberExpression" ||
                        effectiveParent.left.type === "MemberExpression" &&
                        effectiveParent.left.property.name === node.name)) {
                    report(node);
                }

            } else if (node.parent.type === "Property") {
                if (properties === "never") {
                    return;
                }

                if (node.parent.parent && node.parent.parent.type === "ObjectPattern" &&
                        node.parent.key === node && node.parent.value !== node) {
                    return;
                }

                if (isUnderscored(name) && effectiveParent.type !== "CallExpression") {
                    report(node);
                }

            } else if (isUnderscored(name) && effectiveParent.type !== "CallExpression") {
                report(node);
            }
        }

    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "properties": {
                "enum": ["always", "never"]
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/comma-dangle.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

function isTrailingCommaAllowed(node, lastItem) {
    switch (node.type) {
        case "ArrayPattern":
            return (
                lastItem.type !== "RestElement" &&
                lastItem.type !== "SpreadElement"
            );

        case "ArrayExpression":
            return (
                node.parent.type !== "ForOfStatement" ||
                node.parent.left !== node ||
                lastItem.type !== "SpreadElement"
            );

        default:
            return true;
    }
}

module.exports = function(context) {
    var mode = context.options[0];
    var UNEXPECTED_MESSAGE = "Unexpected trailing comma.";
    var MISSING_MESSAGE = "Missing trailing comma.";

    function isMultiline(node) {
        var lastItem = lodash.last(node.properties || node.elements || node.specifiers);
        if (!lastItem) {
            return false;
        }

        var sourceCode = context.getSourceCode(),
            penultimateToken = sourceCode.getLastToken(lastItem),
            lastToken = sourceCode.getTokenAfter(penultimateToken);

        while (lastToken.value === ")") {
            penultimateToken = lastToken;
            lastToken = sourceCode.getTokenAfter(lastToken);
        }

        if (lastToken.value === ",") {
            penultimateToken = lastToken;
            lastToken = sourceCode.getTokenAfter(lastToken);
        }

        return lastToken.loc.end.line !== penultimateToken.loc.end.line;
    }

    function forbidTrailingComma(node) {
        var lastItem = lodash.last(node.properties || node.elements || node.specifiers);
        if (!lastItem || (node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier")) {
            return;
        }

        var sourceCode = context.getSourceCode(),
            trailingToken;

        if (node.type === "ObjectExpression" || node.type === "ArrayExpression") {
            trailingToken = sourceCode.getTokenBefore(sourceCode.getLastToken(node));
        } else {
            trailingToken = sourceCode.getTokenAfter(lastItem);
        }

        if (trailingToken.value === ",") {
            context.report(
                lastItem,
                trailingToken.loc.start,
                UNEXPECTED_MESSAGE);
        }
    }

    function forceTrailingComma(node) {
        var lastItem = lodash.last(node.properties || node.elements || node.specifiers);
        if (!lastItem || (node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier")) {
            return;
        }
        if (!isTrailingCommaAllowed(node, lastItem)) {
            forbidTrailingComma(node);
            return;
        }

        var sourceCode = context.getSourceCode(),
            trailingToken;

        if (node.type === "ObjectExpression" || node.type === "ArrayExpression") {
            trailingToken = sourceCode.getTokenBefore(sourceCode.getLastToken(node));
        } else {
            trailingToken = sourceCode.getTokenAfter(lastItem);
        }

        if (trailingToken.value !== ",") {
            context.report(
                lastItem,
                lastItem.loc.end,
                MISSING_MESSAGE);
        }
    }

    function forceTrailingCommaIfMultiline(node) {
        if (isMultiline(node)) {
            forceTrailingComma(node);
        } else {
            forbidTrailingComma(node);
        }
    }

    function allowTrailingCommaIfMultiline(node) {
        if (!isMultiline(node)) {
            forbidTrailingComma(node);
        }
    }

    var checkForTrailingComma;
    if (mode === "always") {
        checkForTrailingComma = forceTrailingComma;
    } else if (mode === "always-multiline") {
        checkForTrailingComma = forceTrailingCommaIfMultiline;
    } else if (mode === "only-multiline") {
        checkForTrailingComma = allowTrailingCommaIfMultiline;
    } else {
        checkForTrailingComma = forbidTrailingComma;
    }

    return {
        "ObjectExpression": checkForTrailingComma,
        "ObjectPattern": checkForTrailingComma,
        "ArrayExpression": checkForTrailingComma,
        "ArrayPattern": checkForTrailingComma,
        "ImportDeclaration": checkForTrailingComma,
        "ExportNamedDeclaration": checkForTrailingComma
    };
};

module.exports.schema = [
    {
        "enum": ["always", "always-multiline", "only-multiline", "never"]
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/comma-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var sourceCode = context.getSourceCode();
    var tokensAndComments = sourceCode.tokensAndComments;

    var options = {
        before: context.options[0] ? !!context.options[0].before : false,
        after: context.options[0] ? !!context.options[0].after : true
    };

    var commaTokensToIgnore = [];

    function isComma(token) {
        return !!token && (token.type === "Punctuator") && (token.value === ",");
    }

    function report(node, dir, otherNode) {
        context.report({
            node: node,
            fix: function(fixer) {
                if (options[dir]) {
                    if (dir === "before") {
                        return fixer.insertTextBefore(node, " ");
                    } else {
                        return fixer.insertTextAfter(node, " ");
                    }
                } else {
                    var start, end;
                    var newText = "";

                    if (dir === "before") {
                        start = otherNode.range[1];
                        end = node.range[0];
                    } else {
                        start = node.range[1];
                        end = otherNode.range[0];
                    }

                    return fixer.replaceTextRange([start, end], newText);
                }
            },
            message: options[dir] ?
              "A space is required " + dir + " ','." :
              "There should be no space " + dir + " ','."
        });
    }

    function validateCommaItemSpacing(tokens, reportItem) {
        if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) &&
                (options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma))
        ) {
            report(reportItem, "before", tokens.left);
        }

        if (tokens.right && !options.after && tokens.right.type === "Line") {
            return;
        }

        if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) &&
                (options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right))
        ) {
            report(reportItem, "after", tokens.right);
        }
    }

    function addNullElementsToIgnoreList(node) {
        var previousToken = context.getFirstToken(node);

        node.elements.forEach(function(element) {
            var token;

            if (element === null) {
                token = context.getTokenAfter(previousToken);

                if (isComma(token)) {
                    commaTokensToIgnore.push(token);
                }
            } else {
                token = context.getTokenAfter(element);
            }

            previousToken = token;
        });
    }

    return {
        "Program:exit": function() {

            var previousToken,
                nextToken;

            tokensAndComments.forEach(function(token, i) {

                if (!isComma(token)) {
                    return;
                }

                if (token && token.type === "JSXText") {
                    return;
                }

                previousToken = tokensAndComments[i - 1];
                nextToken = tokensAndComments[i + 1];

                validateCommaItemSpacing({
                    comma: token,
                    left: isComma(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,
                    right: isComma(nextToken) ? null : nextToken
                }, token);
            });
        },
        "ArrayExpression": addNullElementsToIgnoreList,
        "ArrayPattern": addNullElementsToIgnoreList

    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "before": {
                "type": "boolean"
            },
            "after": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/comma-style.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var style = context.options[0] || "last",
        exceptions = {};

    if (context.options.length === 2 && context.options[1].hasOwnProperty("exceptions")) {
        exceptions = context.options[1].exceptions;
    }

    function isComma(token) {
        return !!token && (token.type === "Punctuator") && (token.value === ",");
    }

    function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {

        if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&
                astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {

            return;

        } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&
                !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {

            context.report(reportItem, {
                line: commaToken.loc.end.line,
                column: commaToken.loc.start.column
            }, "Bad line breaking before and after ','.");

        } else if (style === "first" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {

            context.report(reportItem, "',' should be placed first.");

        } else if (style === "last" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {

            context.report(reportItem, {
                line: commaToken.loc.end.line,
                column: commaToken.loc.end.column
            }, "',' should be placed last.");
        }
    }

    function validateComma(node, property) {
        var items = node[property],
            arrayLiteral = (node.type === "ArrayExpression"),
            previousItemToken;

        if (items.length > 1 || arrayLiteral) {

            previousItemToken = context.getFirstToken(node);

            items.forEach(function(item) {
                var commaToken = item ? context.getTokenBefore(item) : previousItemToken,
                    currentItemToken = item ? context.getFirstToken(item) : context.getTokenAfter(commaToken),
                    reportItem = item || currentItemToken;

                if (isComma(commaToken)) {
                    validateCommaItemSpacing(previousItemToken, commaToken,
                            currentItemToken, reportItem);
                }

                previousItemToken = item ? context.getLastToken(item) : previousItemToken;
            });

            if (arrayLiteral) {

                var lastToken = context.getLastToken(node),
                    nextToLastToken = context.getTokenBefore(lastToken);

                if (isComma(nextToLastToken)) {
                    validateCommaItemSpacing(
                        context.getTokenBefore(nextToLastToken),
                        nextToLastToken,
                        lastToken,
                        lastToken
                    );
                }
            }
        }
    }

    var nodes = {};

    if (!exceptions.VariableDeclaration) {
        nodes.VariableDeclaration = function(node) {
            validateComma(node, "declarations");
        };
    }
    if (!exceptions.ObjectExpression) {
        nodes.ObjectExpression = function(node) {
            validateComma(node, "properties");
        };
    }
    if (!exceptions.ArrayExpression) {
        nodes.ArrayExpression = function(node) {
            validateComma(node, "elements");
        };
    }

    return nodes;
};

module.exports.schema = [
    {
        "enum": ["first", "last"]
    },
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "object",
                "additionalProperties": {
                    "type": "boolean"
                }
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/complexity.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var option = context.options[0],
        THRESHOLD = 20;

    if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
        THRESHOLD = option.maximum;
    }
    if (typeof option === "number") {
        THRESHOLD = option;
    }

    var fns = [];

    function startFunction() {
        fns.push(1);
    }

    function endFunction(node) {
        var complexity = fns.pop(),
            name = "anonymous";

        if (node.id) {
            name = node.id.name;
        } else if (node.parent.type === "MethodDefinition" || node.parent.type === "Property") {
            name = node.parent.key.name;
        }

        if (complexity > THRESHOLD) {
            context.report(node, "Function '{{name}}' has a complexity of {{complexity}}.", { name: name, complexity: complexity });
        }
    }

    function increaseComplexity() {
        if (fns.length) {
            fns[fns.length - 1] ++;
        }
    }

    function increaseSwitchComplexity(node) {
        if (node.test) {
            increaseComplexity(node);
        }
    }

    function increaseLogicalComplexity(node) {
        if (node.operator === "||") {
            increaseComplexity(node);
        }
    }

    return {
        "FunctionDeclaration": startFunction,
        "FunctionExpression": startFunction,
        "ArrowFunctionExpression": startFunction,
        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction,

        "CatchClause": increaseComplexity,
        "ConditionalExpression": increaseComplexity,
        "LogicalExpression": increaseLogicalComplexity,
        "ForStatement": increaseComplexity,
        "ForInStatement": increaseComplexity,
        "ForOfStatement": increaseComplexity,
        "IfStatement": increaseComplexity,
        "SwitchCase": increaseSwitchComplexity,
        "WhileStatement": increaseComplexity,
        "DoWhileStatement": increaseComplexity
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "type": "integer",
                "minimum": 0
            },
            {
                "type": "object",
                "properties": {
                    "maximum": {
                        "type": "integer",
                        "minimum": 0
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/computed-property-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    var sourceCode = context.getSourceCode();
    var propertyNameMustBeSpaced = context.options[0] === "always"; // default is "never"

    function reportNoBeginningSpace(node, token, tokenAfter) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "There should be no space after '" + token.value + "'",
            fix: function(fixer) {
                return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
            }
        });
    }

    function reportNoEndingSpace(node, token, tokenBefore) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "There should be no space before '" + token.value + "'",
            fix: function(fixer) {
                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
            }
        });
    }

    function reportRequiredBeginningSpace(node, token) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "A space is required after '" + token.value + "'",
            fix: function(fixer) {
                return fixer.insertTextAfter(token, " ");
            }
        });
    }

    function reportRequiredEndingSpace(node, token) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "A space is required before '" + token.value + "'",
            fix: function(fixer) {
                return fixer.insertTextBefore(token, " ");
            }
        });
    }

    function checkSpacing(propertyName) {
        return function(node) {
            if (!node.computed) {
                return;
            }

            var property = node[propertyName];

            var before = context.getTokenBefore(property),
                first = context.getFirstToken(property),
                last = context.getLastToken(property),
                after = context.getTokenAfter(property);

            if (astUtils.isTokenOnSameLine(before, first)) {
                if (propertyNameMustBeSpaced) {
                    if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {
                        reportRequiredBeginningSpace(node, before);
                    }
                } else {
                    if (sourceCode.isSpaceBetweenTokens(before, first)) {
                        reportNoBeginningSpace(node, before, first);
                    }
                }
            }

            if (astUtils.isTokenOnSameLine(last, after)) {
                if (propertyNameMustBeSpaced) {
                    if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {
                        reportRequiredEndingSpace(node, after);
                    }
                } else {
                    if (sourceCode.isSpaceBetweenTokens(last, after)) {
                        reportNoEndingSpace(node, after, last);
                    }
                }
            }
        };
    }


    return {
        Property: checkSpacing("key"),
        MemberExpression: checkSpacing("property")
    };

};

module.exports.schema = [
    {
        "enum": ["always", "never"]
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/consistent-return.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isUnreachable(segment) {
    return !segment.reachable;
}

module.exports = function(context) {
    var funcInfo = null;

    function checkLastSegment(node) {
        var loc, type;

        if (!funcInfo.hasReturnValue ||
            funcInfo.codePath.currentSegments.every(isUnreachable) ||
            astUtils.isES5Constructor(node)
        ) {
            return;
        }

        if (node.type === "Program") {
            loc = {line: 1, column: 0};
            type = "program";
        } else if (node.type === "ArrowFunctionExpression") {
            loc = context.getSourceCode().getTokenBefore(node.body).loc.start;
            type = "function";
        } else if (
            node.parent.type === "MethodDefinition" ||
            (node.parent.type === "Property" && node.parent.method)
        ) {
            loc = node.parent.key.loc.start;
            type = "method";
        } else {
            loc = (node.id || node).loc.start;
            type = "function";
        }

        context.report({
            node: node,
            loc: loc,
            message: "Expected to return a value at the end of this {{type}}.",
            data: {type: type}
        });
    }

    return {
        "onCodePathStart": function(codePath) {
            funcInfo = {
                upper: funcInfo,
                codePath: codePath,
                hasReturn: false,
                hasReturnValue: false,
                message: ""
            };
        },
        "onCodePathEnd": function() {
            funcInfo = funcInfo.upper;
        },

        "ReturnStatement": function(node) {
            var hasReturnValue = Boolean(node.argument);

            if (!funcInfo.hasReturn) {
                funcInfo.hasReturn = true;
                funcInfo.hasReturnValue = hasReturnValue;
                funcInfo.message = "Expected " + (hasReturnValue ? "a" : "no") + " return value.";
            } else if (funcInfo.hasReturnValue !== hasReturnValue) {
                context.report({node: node, message: funcInfo.message});
            }
        },

        "Program:exit": checkLastSegment,
        "FunctionDeclaration:exit": checkLastSegment,
        "FunctionExpression:exit": checkLastSegment,
        "ArrowFunctionExpression:exit": checkLastSegment
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/consistent-this.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var aliases = [];

    if (context.options.length === 0) {
        aliases.push("that");
    } else {
        aliases = context.options;
    }

    function reportBadAssignment(node, alias) {
        context.report(node,
            "Designated alias '{{alias}}' is not assigned to 'this'.",
            { alias: alias });
    }

    function checkAssignment(node, name, value) {
        var isThis = value.type === "ThisExpression";

        if (aliases.indexOf(name) !== -1) {
            if (!isThis || node.operator && node.operator !== "=") {
                reportBadAssignment(node, name);
            }
        } else if (isThis) {
            context.report(node,
                "Unexpected alias '{{name}}' for 'this'.", { name: name });
        }
    }

    function checkWasAssigned(alias, scope) {
        var variable = scope.set.get(alias);

        if (!variable) {
            return;
        }

        if (variable.defs.some(function(def) {
            return def.node.type === "VariableDeclarator" &&
            def.node.init !== null;
        })) {
            return;
        }

        if (!variable.references.some(function(reference) {
            var write = reference.writeExpr;
            return (
                reference.from === scope &&
                write && write.type === "ThisExpression" &&
                write.parent.operator === "="
            );
        })) {
            variable.defs.map(function(def) {
                return def.node;
            }).forEach(function(node) {
                reportBadAssignment(node, alias);
            });
        }
    }

    function ensureWasAssigned() {
        var scope = context.getScope();

        aliases.forEach(function(alias) {
            checkWasAssigned(alias, scope);
        });
    }

    return {
        "Program:exit": ensureWasAssigned,
        "FunctionExpression:exit": ensureWasAssigned,
        "FunctionDeclaration:exit": ensureWasAssigned,

        "VariableDeclarator": function(node) {
            var id = node.id;
            var isDestructuring =
                id.type === "ArrayPattern" || id.type === "ObjectPattern";

            if (node.init !== null && !isDestructuring) {
                checkAssignment(node, id.name, node.init);
            }
        },

        "AssignmentExpression": function(node) {
            if (node.left.type === "Identifier") {
                checkAssignment(node, node.left.name, node.right);
            }
        }
    };

};

module.exports.schema = {
    "type": "array",
    "items": {
        "type": "string",
        "minLength": 1
    },
    "uniqueItems": true
};

},
   {}],

"/tmp/rules/constructor-super.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isConstructorFunction(node) {
    return (
        node.type === "FunctionExpression" &&
        node.parent.type === "MethodDefinition" &&
        node.parent.kind === "constructor"
    );
}

module.exports = function(context) {
    var funcInfo = null;

    var segInfoMap = Object.create(null);

    function isCalledInSomePath(segment) {
        return segInfoMap[segment.id].calledInSomePaths;
    }

    function isCalledInEveryPath(segment) {
        if (segment.nextSegments.length === 1 &&
            segment.nextSegments[0].isLoopedPrevSegment(segment)
        ) {
            return true;
        }
        return segInfoMap[segment.id].calledInEveryPaths;
    }

    return {
        "onCodePathStart": function(codePath, node) {
            if (isConstructorFunction(node)) {
                var classNode = node.parent.parent.parent;
                funcInfo = {
                    upper: funcInfo,
                    isConstructor: true,
                    hasExtends: Boolean(
                        classNode.superClass &&
                        !astUtils.isNullOrUndefined(classNode.superClass)
                    ),
                    codePath: codePath
                };
            } else {
                funcInfo = {
                    upper: funcInfo,
                    isConstructor: false,
                    hasExtends: false,
                    codePath: codePath
                };
            }
        },

        "onCodePathEnd": function(codePath, node) {
            var hasExtends = funcInfo.hasExtends;
            funcInfo = funcInfo.upper;
            if (!hasExtends) {
                return;
            }

            var segments = codePath.returnedSegments;
            var calledInEveryPaths = segments.every(isCalledInEveryPath);
            var calledInSomePaths = segments.some(isCalledInSomePath);
            if (!calledInEveryPaths) {
                context.report({
                    message: calledInSomePaths ?
                        "Lacked a call of 'super()' in some code paths." :
                        "Expected to call 'super()'.",
                    node: node.parent
                });
            }
        },

        "onCodePathSegmentStart": function(segment) {
            if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
                return;
            }

            var info = segInfoMap[segment.id] = {
                calledInSomePaths: false,
                calledInEveryPaths: false,
                validNodes: []
            };

            var prevSegments = segment.prevSegments;
            if (prevSegments.length > 0) {
                info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
                info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
            }
        },

        "onCodePathSegmentLoop": function(fromSegment, toSegment) {
            if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
                return;
            }

            var isRealLoop = toSegment.prevSegments.length >= 2;
            funcInfo.codePath.traverseSegments(
                {first: toSegment, last: fromSegment},
                function(segment) {
                    var info = segInfoMap[segment.id];

                    var prevSegments = segment.prevSegments;
                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);

                    if (info.calledInSomePaths || isRealLoop) {
                        var nodes = info.validNodes;
                        info.validNodes = [];

                        for (var i = 0; i < nodes.length; ++i) {
                            var node = nodes[i];
                            context.report({
                                message: "Unexpected duplicate 'super()'.",
                                node: node
                            });
                        }
                    }
                }
            );
        },

        "CallExpression:exit": function(node) {
            if (node.callee.type !== "Super") {
                return;
            }

            if (!(funcInfo && funcInfo.isConstructor)) {
                return;
            }

            if (funcInfo.hasExtends) {
                var segments = funcInfo.codePath.currentSegments;
                var duplicate = false;
                for (var i = 0; i < segments.length; ++i) {
                    var info = segInfoMap[segments[i].id];

                    duplicate = duplicate || info.calledInSomePaths;
                    info.calledInSomePaths = info.calledInEveryPaths = true;
                }

                if (duplicate) {
                    context.report({
                        message: "Unexpected duplicate 'super()'.",
                        node: node
                    });
                } else {
                    info.validNodes.push(node);
                }
            } else {
                context.report({
                    message: "Unexpected 'super()'.",
                    node: node
                });
            }
        },

        "Program:exit": function() {
            segInfoMap = Object.create(null);
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/curly.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var multiOnly = (context.options[0] === "multi");
    var multiLine = (context.options[0] === "multi-line");
    var multiOrNest = (context.options[0] === "multi-or-nest");
    var consistent = (context.options[1] === "consistent");

    function isCollapsedOneLiner(node) {
        var before = context.getTokenBefore(node),
            last = context.getLastToken(node);
        return before.loc.start.line === last.loc.end.line;
    }

    function isOneLiner(node) {
        var first = context.getFirstToken(node),
            last = context.getLastToken(node);

        return first.loc.start.line === last.loc.end.line;
    }

    function getElseKeyword(node) {
        var sourceCode = context.getSourceCode();
        var token = sourceCode.getTokenAfter(node.consequent);

        while (token.type !== "Keyword" || token.value !== "else") {
            token = sourceCode.getTokenAfter(token);
        }

        return token;
    }

    function requiresBraceOfConsequent(node) {
        if (node.alternate && node.consequent.type === "BlockStatement") {
            if (node.consequent.body.length >= 2) {
                return true;
            }

            node = node.consequent.body[0];
            while (node) {
                if (node.type === "IfStatement" && !node.alternate) {
                    return true;
                }
                node = astUtils.getTrailingStatement(node);
            }
        }

        return false;
    }

    function reportExpectedBraceError(node, name, suffix) {
        context.report({
            node: node,
            loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
            message: "Expected { after '{{name}}'{{suffix}}.",
            data: {
                name: name,
                suffix: (suffix ? " " + suffix : "")
            }
        });
    }

    function reportUnnecessaryBraceError(node, name, suffix) {
        context.report({
            node: node,
            loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
            message: "Unnecessary { after '{{name}}'{{suffix}}.",
            data: {
                name: name,
                suffix: (suffix ? " " + suffix : "")
            }
        });
    }

    function prepareCheck(node, body, name, suffix) {
        var hasBlock = (body.type === "BlockStatement");
        var expected = null;

        if (node.type === "IfStatement" && node.consequent === body && requiresBraceOfConsequent(node)) {
            expected = true;
        } else if (multiOnly) {
            if (hasBlock && body.body.length === 1) {
                expected = false;
            }
        } else if (multiLine) {
            if (!isCollapsedOneLiner(body)) {
                expected = true;
            }
        } else if (multiOrNest) {
            if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {
                expected = false;
            } else if (!isOneLiner(body)) {
                expected = true;
            }
        } else {
            expected = true;
        }

        return {
            actual: hasBlock,
            expected: expected,
            check: function() {
                if (this.expected !== null && this.expected !== this.actual) {
                    if (this.expected) {
                        reportExpectedBraceError(node, name, suffix);
                    } else {
                        reportUnnecessaryBraceError(node, name, suffix);
                    }
                }
            }
        };
    }

    function prepareIfChecks(node) {
        var preparedChecks = [];
        do {
            preparedChecks.push(prepareCheck(node, node.consequent, "if", "condition"));
            if (node.alternate && node.alternate.type !== "IfStatement") {
                preparedChecks.push(prepareCheck(node, node.alternate, "else"));
                break;
            }
            node = node.alternate;
        } while (node);

        if (consistent) {
            var expected = preparedChecks.some(function(preparedCheck) {
                if (preparedCheck.expected !== null) {
                    return preparedCheck.expected;
                }
                return preparedCheck.actual;
            });

            preparedChecks.forEach(function(preparedCheck) {
                preparedCheck.expected = expected;
            });
        }

        return preparedChecks;
    }

    return {
        "IfStatement": function(node) {
            if (node.parent.type !== "IfStatement") {
                prepareIfChecks(node).forEach(function(preparedCheck) {
                    preparedCheck.check();
                });
            }
        },

        "WhileStatement": function(node) {
            prepareCheck(node, node.body, "while", "condition").check();
        },

        "DoWhileStatement": function(node) {
            prepareCheck(node, node.body, "do").check();
        },

        "ForStatement": function(node) {
            prepareCheck(node, node.body, "for", "condition").check();
        },

        "ForInStatement": function(node) {
            prepareCheck(node, node.body, "for-in").check();
        },

        "ForOfStatement": function(node) {
            prepareCheck(node, node.body, "for-of").check();
        }
    };
};

module.exports.schema = {
    "anyOf": [
        {
            "type": "array",
            "items": [
                {
                    "enum": ["all"]
                }
            ],
            "minItems": 0,
            "maxItems": 1
        },
        {
            "type": "array",
            "items": [
                {
                    "enum": ["multi", "multi-line", "multi-or-nest"]
                },
                {
                    "enum": ["consistent"]
                }
            ],
            "minItems": 0,
            "maxItems": 2
        }
    ]
};

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/default-case.js": [function(require,module,exports){
"use strict";

var COMMENT_VALUE = "no default";

module.exports = function(context) {

    function last(collection) {
        return collection[collection.length - 1];
    }

    return {

        "SwitchStatement": function(node) {

            if (!node.cases.length) {
                return;
            }

            var hasDefault = node.cases.some(function(v) {
                return v.test === null;
            });

            if (!hasDefault) {

                var comment;
                var comments;

                var lastCase = last(node.cases);
                comments = context.getComments(lastCase).trailing;

                if (comments.length) {
                    comment = last(comments);
                }

                if (!comment || comment.value.trim() !== COMMENT_VALUE) {
                    context.report(node, "Expected a default case.");
                }
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/dot-location.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var config = context.options[0],
        onObject = config === "object" || !config;

    function checkDotLocation(obj, prop, node) {
        var dot = context.getTokenBefore(prop);

        if (dot.type === "Punctuator" && dot.value === ".") {
            if (onObject) {
                if (!astUtils.isTokenOnSameLine(obj, dot)) {
                    context.report(node, dot.loc.start, "Expected dot to be on same line as object.");
                }
            } else if (!astUtils.isTokenOnSameLine(dot, prop)) {
                context.report(node, dot.loc.start, "Expected dot to be on same line as property.");
            }
        }
    }

    function checkNode(node) {
        checkDotLocation(node.object, node.property, node);
    }

    return {
        "MemberExpression": checkNode
    };
};

module.exports.schema = [
    {
        "enum": ["object", "property"]
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/dot-notation.js": [function(require,module,exports){
"use strict";

var validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
var keywords = require("../util/keywords");

module.exports = function(context) {
    var options = context.options[0] || {};
    var allowKeywords = options.allowKeywords === void 0 || !!options.allowKeywords;

    var allowPattern;
    if (options.allowPattern) {
        allowPattern = new RegExp(options.allowPattern);
    }

    return {
        "MemberExpression": function(node) {
            if (
                node.computed &&
                node.property.type === "Literal" &&
                validIdentifier.test(node.property.value) &&
                (allowKeywords || keywords.indexOf("" + node.property.value) === -1)
            ) {
                if (!(allowPattern && allowPattern.test(node.property.value))) {
                    context.report(node.property, "[" + JSON.stringify(node.property.value) + "] is better written in dot notation.");
                }
            }
            if (
                !allowKeywords &&
                !node.computed &&
                keywords.indexOf("" + node.property.name) !== -1
            ) {
                context.report(node.property, "." + node.property.name + " is a syntax error.");
            }
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allowKeywords": {
                "type": "boolean"
            },
            "allowPattern": {
                "type": "string"
            }
        },
        "additionalProperties": false
    }
];

},
   {"../util/keywords":"/tmp/util/keywords.js"}],

"/tmp/rules/eol-last.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Program": function checkBadEOF(node) {
            var src = context.getSource(),
                location = {column: 1},
                linebreakStyle = context.options[0] || "unix",
                linebreak = linebreakStyle === "unix" ? "\n" : "\r\n";

            if (src[src.length - 1] !== "\n") {
                location.line = src.split(/\n/g).length;
                context.report({
                    node: node,
                    loc: location,
                    message: "Newline required at end of file but not found.",
                    fix: function(fixer) {
                        return fixer.insertTextAfterRange([0, src.length], linebreak);
                    }
                });
            }
        }

    };

};

module.exports.schema = [
    {
        "enum": ["unix", "windows"]
    }
];

},
   {}],

"/tmp/rules/eqeqeq.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isTypeOf(node) {
        return node.type === "UnaryExpression" && node.operator === "typeof";
    }

    function isTypeOfBinary(node) {
        return isTypeOf(node.left) || isTypeOf(node.right);
    }

    function areLiteralsAndSameType(node) {
        return node.left.type === "Literal" && node.right.type === "Literal" &&
                typeof node.left.value === typeof node.right.value;
    }

    function isNullCheck(node) {
        return (node.right.type === "Literal" && node.right.value === null) ||
                (node.left.type === "Literal" && node.left.value === null);
    }

    function getOperatorLocation(node) {
        var opToken = context.getTokenAfter(node.left);
        return {line: opToken.loc.start.line, column: opToken.loc.start.column};
    }

    return {
        "BinaryExpression": function(node) {
            if (node.operator !== "==" && node.operator !== "!=") {
                return;
            }

            if (context.options[0] === "smart" && (isTypeOfBinary(node) ||
                    areLiteralsAndSameType(node) || isNullCheck(node))) {
                return;
            }

            if (context.options[0] === "allow-null" && isNullCheck(node)) {
                return;
            }

            context.report({
                node: node,
                loc: getOperatorLocation(node),
                message: "Expected '{{op}}=' and instead saw '{{op}}'.",
                data: { op: node.operator }
            });

        }
    };

};

module.exports.schema = [
    {
        "enum": ["smart", "allow-null"]
    }
];

},
   {}],

"/tmp/rules/func-names.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isObjectOrClassMethod() {
        var parent = context.getAncestors().pop();

        return (parent.type === "MethodDefinition" || (
            parent.type === "Property" && (
                parent.method ||
                parent.kind === "get" ||
                parent.kind === "set"
            )
        ));
    }

    return {
        "FunctionExpression": function(node) {

            var name = node.id && node.id.name;

            if (!name && !isObjectOrClassMethod()) {
                context.report(node, "Missing function expression name.");
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/func-style.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var style = context.options[0],
        allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions === true,
        enforceDeclarations = (style === "declaration"),
        stack = [];

    var nodesToCheck = {
        "Program": function() {
            stack = [];
        },

        "FunctionDeclaration": function(node) {
            stack.push(false);

            if (!enforceDeclarations && node.parent.type !== "ExportDefaultDeclaration") {
                context.report(node, "Expected a function expression.");
            }
        },
        "FunctionDeclaration:exit": function() {
            stack.pop();
        },

        "FunctionExpression": function(node) {
            stack.push(false);

            if (enforceDeclarations && node.parent.type === "VariableDeclarator") {
                context.report(node.parent, "Expected a function declaration.");
            }
        },
        "FunctionExpression:exit": function() {
            stack.pop();
        },

        "ThisExpression": function() {
            if (stack.length > 0) {
                stack[stack.length - 1] = true;
            }
        }
    };

    if (!allowArrowFunctions) {
        nodesToCheck.ArrowFunctionExpression = function() {
            stack.push(false);
        };

        nodesToCheck["ArrowFunctionExpression:exit"] = function(node) {
            var hasThisExpr = stack.pop();

            if (enforceDeclarations && !hasThisExpr && node.parent.type === "VariableDeclarator") {
                context.report(node.parent, "Expected a function declaration.");
            }
        };
    }

    return nodesToCheck;

};

module.exports.schema = [
    {
        "enum": ["declaration", "expression"]
    },
    {
        "type": "object",
        "properties": {
            "allowArrowFunctions": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/generator-star-spacing.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var mode = (function(option) {
        if (!option || typeof option === "string") {
            return {
                before: { before: true, after: false },
                after: { before: false, after: true },
                both: { before: true, after: true },
                neither: { before: false, after: false }
            }[option || "before"];
        }
        return option;
    }(context.options[0]));

    function checkSpacing(side, leftToken, rightToken) {
        if (!!(rightToken.range[0] - leftToken.range[1]) !== mode[side]) {
            var after = leftToken.value === "*";
            var spaceRequired = mode[side];
            var node = after ? leftToken : rightToken;
            var type = spaceRequired ? "Missing" : "Unexpected";
            var message = type + " space " + side + " *.";
            context.report({
                node: node,
                message: message,
                fix: function(fixer) {
                    if (spaceRequired) {
                        if (after) {
                            return fixer.insertTextAfter(node, " ");
                        }
                        return fixer.insertTextBefore(node, " ");
                    }
                    return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
                }
            });
        }
    }

    function checkFunction(node) {
        var prevToken, starToken, nextToken;

        if (!node.generator) {
            return;
        }

        if (node.parent.method || node.parent.type === "MethodDefinition") {
            starToken = context.getTokenBefore(node, 1);
        } else {
            starToken = context.getFirstToken(node, 1);
        }

        prevToken = context.getTokenBefore(starToken);
        if (prevToken.value === "function" || prevToken.value === "static") {
            checkSpacing("before", prevToken, starToken);
        }

        nextToken = context.getTokenAfter(starToken);
        checkSpacing("after", starToken, nextToken);
    }

    return {
        "FunctionDeclaration": checkFunction,
        "FunctionExpression": checkFunction
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["before", "after", "both", "neither"]
            },
            {
                "type": "object",
                "properties": {
                    "before": {"type": "boolean"},
                    "after": {"type": "boolean"}
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/global-require.js": [function(require,module,exports){
"use strict";

var ACCEPTABLE_PARENTS = [
    "AssignmentExpression",
    "VariableDeclarator",
    "MemberExpression",
    "ExpressionStatement",
    "CallExpression",
    "ConditionalExpression",
    "Program",
    "VariableDeclaration"
];

function findReference(scope, node) {
    var references = scope.references.filter(function(reference) {
        return reference.identifier.range[0] === node.range[0] &&
            reference.identifier.range[1] === node.range[1];
    });

    if (references.length === 1) {
        return references[0];
    } else {
        return null;
    }
}

function isShadowed(scope, node) {
    var reference = findReference(scope, node);
    return reference && reference.resolved && reference.resolved.defs.length > 0;
}

module.exports = function(context) {
    return {
        "CallExpression": function(node) {
            var currentScope = context.getScope(),
                isGoodRequire;

            if (node.callee.name === "require" && !isShadowed(currentScope, node.callee)) {
                isGoodRequire = context.getAncestors().every(function(parent) {
                    return ACCEPTABLE_PARENTS.indexOf(parent.type) > -1;
                });
                if (!isGoodRequire) {
                    context.report(node, "Unexpected require().");
                }
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/guard-for-in.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "ForInStatement": function(node) {

            var body = node.body.type === "BlockStatement" ? node.body.body[0] : node.body;

            if (body && body.type !== "IfStatement") {
                context.report(node, "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/handle-callback-err.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var errorArgument = context.options[0] || "err";

    function isPattern(stringToCheck) {
        var firstChar = stringToCheck[0];
        return firstChar === "^";
    }

    function matchesConfiguredErrorName(name) {
        if (isPattern(errorArgument)) {
            var regexp = new RegExp(errorArgument);
            return regexp.test(name);
        }
        return name === errorArgument;
    }

    function getParameters(scope) {
        return scope.variables.filter(function(variable) {
            return variable.defs[0] && variable.defs[0].type === "Parameter";
        });
    }

    function checkForError(node) {
        var scope = context.getScope(),
            parameters = getParameters(scope),
            firstParameter = parameters[0];

        if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {
            if (firstParameter.references.length === 0) {
                context.report(node, "Expected error to be handled.");
            }
        }
    }

    return {
        "FunctionDeclaration": checkForError,
        "FunctionExpression": checkForError,
        "ArrowFunctionExpression": checkForError
    };

};

module.exports.schema = [
    {
        "type": "string"
    }
];

},
   {}],

"/tmp/rules/id-blacklist.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {


    var blacklist = context.options;


    function isInvalid(name) {
        return blacklist.indexOf(name) !== -1;
    }

    function shouldReport(effectiveParent, name) {
        return effectiveParent.type !== "CallExpression"
            && effectiveParent.type !== "NewExpression" &&
            isInvalid(name);
    }

    function report(node) {
        context.report(node, "Identifier '{{name}}' is blacklisted", {
            name: node.name
        });
    }

    return {

        "Identifier": function(node) {
            var name = node.name,
                effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;

            if (node.parent.type === "MemberExpression") {

                if (node.parent.object.type === "Identifier" &&
                    node.parent.object.name === node.name) {
                    if (isInvalid(name)) {
                        report(node);
                    }

                } else if (effectiveParent.type === "AssignmentExpression" &&
                    (effectiveParent.right.type !== "MemberExpression" ||
                    effectiveParent.left.type === "MemberExpression" &&
                    effectiveParent.left.property.name === node.name)) {
                    if (isInvalid(name)) {
                        report(node);
                    }
                }

            } else if (node.parent.type === "Property") {

                if (shouldReport(effectiveParent, name)) {
                    report(node);
                }

            } else if (shouldReport(effectiveParent, name)) {
                report(node);
            }
        }

    };

};
module.exports.schema = {
    "type": "array",
    "items": {
        "type": "string"
    },
    "uniqueItems": true
};

},
   {}],

"/tmp/rules/id-length.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var options = context.options[0] || {};
    var minLength = typeof options.min !== "undefined" ? options.min : 2;
    var maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
    var properties = options.properties !== "never";
    var exceptions = (options.exceptions ? options.exceptions : [])
        .reduce(function(obj, item) {
            obj[item] = true;

            return obj;
        }, {});

    var SUPPORTED_EXPRESSIONS = {
        "MemberExpression": properties && function(parent) {
            return !parent.computed && (
                parent.parent.left === parent || (
                    parent.parent.type === "Property" && parent.parent.value === parent &&
                    parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent
                )
            );
        },
        "AssignmentPattern": function(parent, node) {
            return parent.left === node;
        },
        "VariableDeclarator": function(parent, node) {
            return parent.id === node;
        },
        "Property": properties && function(parent, node) {
            return parent.key === node;
        },
        "ImportDefaultSpecifier": true,
        "RestElement": true,
        "FunctionExpression": true,
        "ArrowFunctionExpression": true,
        "ClassDeclaration": true,
        "FunctionDeclaration": true,
        "MethodDefinition": true,
        "CatchClause": true
    };

    return {
        Identifier: function(node) {
            var name = node.name;
            var parent = node.parent;

            var isShort = name.length < minLength;
            var isLong = name.length > maxLength;
            if (!(isShort || isLong) || exceptions[name]) {
                return;  // Nothing to report
            }

            var isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];

            if (isValidExpression && (isValidExpression === true || isValidExpression(parent, node))) {
                context.report(
                    node,
                    isShort ?
                        "Identifier name '{{name}}' is too short. (< {{min}})" :
                        "Identifier name '{{name}}' is too long. (> {{max}})",
                    { name: name, min: minLength, max: maxLength }
                );
            }
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "min": {
                "type": "number"
            },
            "max": {
                "type": "number"
            },
            "exceptions": {
                "type": "array",
                "uniqueItems": true,
                "items": {
                    "type": "string"
                }
            },
            "properties": {
                "enum": ["always", "never"]
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/id-match.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var pattern = context.options[0] || "^.+$",
        regexp = new RegExp(pattern);

    var options = context.options[1] || {},
        properties = options.properties;

    properties = !!properties;


    function isInvalid(name) {
        return !regexp.test(name);
    }

    function shouldReport(effectiveParent, name) {
        return effectiveParent.type !== "CallExpression"
            && effectiveParent.type !== "NewExpression" &&
            isInvalid(name);
    }

    function report(node) {
        context.report(node, "Identifier '{{name}}' does not match the pattern '{{pattern}}'.", {
            name: node.name,
            pattern: pattern
        });
    }

    return {

        "Identifier": function(node) {
            var name = node.name,
                effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;

            if (node.parent.type === "MemberExpression") {
                if (!properties) {
                    return;
                }

                if (node.parent.object.type === "Identifier" &&
                    node.parent.object.name === node.name) {
                    if (isInvalid(name)) {
                        report(node);
                    }

                } else if (effectiveParent.type === "AssignmentExpression" &&
                    (effectiveParent.right.type !== "MemberExpression" ||
                    effectiveParent.left.type === "MemberExpression" &&
                    effectiveParent.left.property.name === node.name)) {
                    if (isInvalid(name)) {
                        report(node);
                    }
                }

            } else if (node.parent.type === "Property") {
                if (!properties) {
                    return;
                }

                if (shouldReport(effectiveParent, name)) {
                    report(node);
                }

            } else if (shouldReport(effectiveParent, name)) {
                report(node);
            }
        }

    };

};

module.exports.schema = [
    {
        "type": "string"
    },
    {
        "type": "object",
        "properties": {
            "properties": {
                "type": "boolean"
            }
        }
    }
];

},
   {}],

"/tmp/rules/indent.js": [function(require,module,exports){
"use strict";

var util = require("util");
var lodash = require("lodash");

module.exports = function(context) {

    var MESSAGE = "Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.";
    var DEFAULT_VARIABLE_INDENT = 1;

    var indentType = "space";
    var indentSize = 4;
    var options = {
        SwitchCase: 0,
        VariableDeclarator: {
            var: DEFAULT_VARIABLE_INDENT,
            let: DEFAULT_VARIABLE_INDENT,
            const: DEFAULT_VARIABLE_INDENT
        }
    };

    if (context.options.length) {
        if (context.options[0] === "tab") {
            indentSize = 1;
            indentType = "tab";
        } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === "number") {
            indentSize = context.options[0];
            indentType = "space";
        }

        if (context.options[1]) {
            var opts = context.options[1];
            options.SwitchCase = opts.SwitchCase || 0;
            var variableDeclaratorRules = opts.VariableDeclarator;
            if (typeof variableDeclaratorRules === "number") {
                options.VariableDeclarator = {
                    var: variableDeclaratorRules,
                    let: variableDeclaratorRules,
                    const: variableDeclaratorRules
                };
            } else if (typeof variableDeclaratorRules === "object") {
                lodash.assign(options.VariableDeclarator, variableDeclaratorRules);
            }
        }
    }

    var indentPattern = {
        normal: indentType === "space" ? /^ +/ : /^\t+/,
        excludeCommas: indentType === "space" ? /^[ ,]+/ : /^[\t,]+/
    };

    var caseIndentStore = {};

    function report(node, needed, gotten, loc, isLastNodeCheck) {
        var msgContext = {
            needed: needed,
            type: indentType,
            characters: needed === 1 ? "character" : "characters",
            gotten: gotten
        };
        var indentChar = indentType === "space" ? " " : "\t";

        function getFixerFunction() {
            var rangeToFix = [];

            if (needed > gotten) {
                var spaces = "" + new Array(needed - gotten + 1).join(indentChar);  // replace with repeat in future

                if (isLastNodeCheck === true) {
                    rangeToFix = [
                        node.range[1] - 1,
                        node.range[1] - 1
                    ];
                } else {
                    rangeToFix = [
                        node.range[0],
                        node.range[0]
                    ];
                }

                return function(fixer) {
                    return fixer.insertTextBeforeRange(rangeToFix, spaces);
                };
            } else {
                if (isLastNodeCheck === true) {
                    rangeToFix = [
                        node.range[1] - (gotten - needed) - 1,
                        node.range[1] - 1
                    ];
                } else {
                    rangeToFix = [
                        node.range[0] - (gotten - needed),
                        node.range[0]
                    ];
                }

                return function(fixer) {
                    return fixer.removeRange(rangeToFix);
                };
            }
        }

        if (loc) {
            context.report({
                node: node,
                loc: loc,
                message: MESSAGE,
                data: msgContext,
                fix: getFixerFunction()
            });
        } else {
            context.report({
                node: node,
                message: MESSAGE,
                data: msgContext,
                fix: getFixerFunction()
            });
        }
    }

    function getNodeIndent(node, byLastLine, excludeCommas) {
        var token = byLastLine ? context.getLastToken(node) : context.getFirstToken(node);
        var src = context.getSource(token, token.loc.start.column);
        var regExp = excludeCommas ? indentPattern.excludeCommas : indentPattern.normal;
        var indent = regExp.exec(src);

        return indent ? indent[0].length : 0;
    }

    function isNodeFirstInLine(node, byEndLocation) {
        var firstToken = byEndLocation === true ? context.getLastToken(node, 1) : context.getTokenBefore(node),
            startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,
            endLine = firstToken ? firstToken.loc.end.line : -1;

        return startLine !== endLine;
    }

    function checkNodeIndent(node, indent, excludeCommas) {
        var nodeIndent = getNodeIndent(node, false, excludeCommas);
        if (
            node.type !== "ArrayExpression" && node.type !== "ObjectExpression" &&
            nodeIndent !== indent && isNodeFirstInLine(node)
        ) {
            report(node, indent, nodeIndent);
        }
    }

    function checkNodesIndent(nodes, indent, excludeCommas) {
        nodes.forEach(function(node) {
            if (node.type === "IfStatement" && node.alternate) {
                var elseToken = context.getTokenBefore(node.alternate);
                checkNodeIndent(elseToken, indent, excludeCommas);
            }
            checkNodeIndent(node, indent, excludeCommas);
        });
    }

    function checkLastNodeLineIndent(node, lastLineIndent) {
        var lastToken = context.getLastToken(node);
        var endIndent = getNodeIndent(lastToken, true);

        if (endIndent !== lastLineIndent && isNodeFirstInLine(node, true)) {
            report(
                node,
                lastLineIndent,
                endIndent,
                { line: lastToken.loc.start.line, column: lastToken.loc.start.column },
                true
            );
        }
    }

    function checkFirstNodeLineIndent(node, firstLineIndent) {
        var startIndent = getNodeIndent(node, false);
        if (startIndent !== firstLineIndent && isNodeFirstInLine(node)) {
            report(
                node,
                firstLineIndent,
                startIndent,
                { line: node.loc.start.line, column: node.loc.start.column }
            );
        }
    }

    function getVariableDeclaratorNode(node) {
        var parent = node.parent;

        while (parent.type !== "VariableDeclarator" && parent.type !== "Program") {
            parent = parent.parent;
        }

        return parent.type === "VariableDeclarator" ? parent : null;
    }

    function isNodeInVarOnTop(node, varNode) {
        return varNode &&
            varNode.parent.loc.start.line === node.loc.start.line &&
            varNode.parent.declarations.length > 1;
    }

    function isArgBeforeCalleeNodeMultiline(node) {
        var parent = node.parent;

        if (parent.arguments.length >= 2 && parent.arguments[1] === node) {
            return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;
        }

        return false;
    }

    function checkIndentInFunctionBlock(node) {

        var calleeNode = node.parent; // FunctionExpression
        var indent;

        if (calleeNode.parent &&
            (calleeNode.parent.type === "Property" ||
            calleeNode.parent.type === "ArrayExpression")) {
            indent = getNodeIndent(calleeNode, false, false);
        } else {
            indent = getNodeIndent(calleeNode);
        }

        if (calleeNode.parent.type === "CallExpression") {
            var calleeParent = calleeNode.parent;

            if (calleeNode.type !== "FunctionExpression" && calleeNode.type !== "ArrowFunctionExpression") {
                if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {
                    indent = getNodeIndent(calleeParent);
                }
            } else {
                if (isArgBeforeCalleeNodeMultiline(calleeNode) &&
                    calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&
                    !isNodeFirstInLine(calleeNode)) {
                    indent = getNodeIndent(calleeParent);
                }
            }
        }

        indent += indentSize;

        var parentVarNode = getVariableDeclaratorNode(node);
        if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {
            indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
        }

        if (node.body.length > 0) {
            checkNodesIndent(node.body, indent);
        }

        checkLastNodeLineIndent(node, indent - indentSize);
    }


    function isSingleLineNode(node) {
        var lastToken = context.getLastToken(node),
            startLine = node.loc.start.line,
            endLine = lastToken.loc.end.line;

        return startLine === endLine;
    }

    function isFirstArrayElementOnSameLine(node) {
        if (node.type === "ArrayExpression" && node.elements[0]) {
            return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === "ObjectExpression";
        } else {
            return false;
        }
    }

    function checkIndentInArrayOrObjectBlock(node) {
        if (isSingleLineNode(node)) {
            return;
        }

        var elements = (node.type === "ArrayExpression") ? node.elements : node.properties;

        elements = elements.filter(function(elem) {
            return elem !== null;
        });

        if (elements.length > 0 && elements[0].loc.start.line === node.loc.start.line) {
            return;
        }

        var nodeIndent;
        var elementsIndent;
        var parentVarNode = getVariableDeclaratorNode(node);

        if (isNodeFirstInLine(node)) {
            var parent = node.parent;
            var effectiveParent = parent;

            if (parent.type === "MemberExpression") {
                if (isNodeFirstInLine(parent)) {
                    effectiveParent = parent.parent.parent;
                } else {
                    effectiveParent = parent.parent;
                }
            }
            nodeIndent = getNodeIndent(effectiveParent);
            if (parentVarNode && parentVarNode.loc.start.line !== node.loc.start.line) {
                if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
                    if (parentVarNode.loc.start.line === effectiveParent.loc.start.line) {
                        nodeIndent = nodeIndent + (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);
                    } else if (
                        parent.type === "ObjectExpression" ||
                        parent.type === "ArrayExpression" ||
                        parent.type === "CallExpression" ||
                        parent.type === "ArrowFunctionExpression" ||
                        parent.type === "NewExpression"
                    ) {
                        nodeIndent = nodeIndent + indentSize;
                    }
                }
            } else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && effectiveParent.type !== "MemberExpression" && effectiveParent.type !== "ExpressionStatement" && effectiveParent.type !== "AssignmentExpression" && effectiveParent.type !== "Property") {
                nodeIndent = nodeIndent + indentSize;
            }

            elementsIndent = nodeIndent + indentSize;

            checkFirstNodeLineIndent(node, nodeIndent);
        } else {
            nodeIndent = getNodeIndent(node);
            elementsIndent = nodeIndent + indentSize;
        }

        if (isNodeInVarOnTop(node, parentVarNode)) {
            elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
        }

        checkNodesIndent(elements, elementsIndent, true);

        if (elements.length > 0) {
            if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
                return;
            }
        }

        checkLastNodeLineIndent(node, elementsIndent - indentSize);
    }

    function isNodeBodyBlock(node) {
        return node.type === "BlockStatement" || (node.body && node.body.type === "BlockStatement") ||
            (node.consequent && node.consequent.type === "BlockStatement");
    }

    function blockIndentationCheck(node) {
        if (isSingleLineNode(node)) {
            return;
        }

        if (node.parent && (
                node.parent.type === "FunctionExpression" ||
                node.parent.type === "FunctionDeclaration" ||
                node.parent.type === "ArrowFunctionExpression"
        )) {
            checkIndentInFunctionBlock(node);
            return;
        }

        var indent;
        var nodesToCheck = [];

        var statementsWithProperties = [
            "IfStatement", "WhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DoWhileStatement"
        ];

        if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {
            indent = getNodeIndent(node.parent);
        } else {
            indent = getNodeIndent(node);
        }

        if (node.type === "IfStatement" && node.consequent.type !== "BlockStatement") {
            nodesToCheck = [node.consequent];
        } else if (util.isArray(node.body)) {
            nodesToCheck = node.body;
        } else {
            nodesToCheck = [node.body];
        }

        if (nodesToCheck.length > 0) {
            checkNodesIndent(nodesToCheck, indent + indentSize);
        }

        if (node.type === "BlockStatement") {
            checkLastNodeLineIndent(node, indent);
        }
    }

    function filterOutSameLineVars(node) {
        return node.declarations.reduce(function(finalCollection, elem) {
            var lastElem = finalCollection[finalCollection.length - 1];

            if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||
                (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {
                finalCollection.push(elem);
            }

            return finalCollection;
        }, []);
    }

    function checkIndentInVariableDeclarations(node) {
        var elements = filterOutSameLineVars(node);
        var nodeIndent = getNodeIndent(node);
        var lastElement = elements[elements.length - 1];

        var elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];

        checkNodesIndent(elements, elementsIndent, true);

        if (context.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {
            return;
        }

        var tokenBeforeLastElement = context.getTokenBefore(lastElement);

        if (tokenBeforeLastElement.value === ",") {
            checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement));
        } else {
            checkLastNodeLineIndent(node, elementsIndent - indentSize);
        }
    }

    function blockLessNodes(node) {
        if (node.body.type !== "BlockStatement") {
            blockIndentationCheck(node);
        }
    }

    function expectedCaseIndent(node, switchIndent) {
        var switchNode = (node.type === "SwitchStatement") ? node : node.parent;
        var caseIndent;

        if (caseIndentStore[switchNode.loc.start.line]) {
            return caseIndentStore[switchNode.loc.start.line];
        } else {
            if (typeof switchIndent === "undefined") {
                switchIndent = getNodeIndent(switchNode);
            }

            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
                caseIndent = switchIndent;
            } else {
                caseIndent = switchIndent + (indentSize * options.SwitchCase);
            }

            caseIndentStore[switchNode.loc.start.line] = caseIndent;
            return caseIndent;
        }
    }

    return {
        "Program": function(node) {
            if (node.body.length > 0) {
                checkNodesIndent(node.body, getNodeIndent(node));
            }
        },

        "ClassBody": blockIndentationCheck,

        "BlockStatement": blockIndentationCheck,

        "WhileStatement": blockLessNodes,

        "ForStatement": blockLessNodes,

        "ForInStatement": blockLessNodes,

        "ForOfStatement": blockLessNodes,

        "DoWhileStatement": blockLessNodes,

        "IfStatement": function(node) {
            if (node.consequent.type !== "BlockStatement" && node.consequent.loc.start.line > node.loc.start.line) {
                blockIndentationCheck(node);
            }
        },

        "VariableDeclaration": function(node) {
            if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {
                checkIndentInVariableDeclarations(node);
            }
        },

        "ObjectExpression": function(node) {
            checkIndentInArrayOrObjectBlock(node);
        },

        "ArrayExpression": function(node) {
            checkIndentInArrayOrObjectBlock(node);
        },

        "SwitchStatement": function(node) {
            var switchIndent = getNodeIndent(node);
            var caseIndent = expectedCaseIndent(node, switchIndent);
            checkNodesIndent(node.cases, caseIndent);


            checkLastNodeLineIndent(node, switchIndent);
        },

        "SwitchCase": function(node) {
            if (isSingleLineNode(node)) {
                return;
            }
            var caseIndent = expectedCaseIndent(node);
            checkNodesIndent(node.consequent, caseIndent + indentSize);
        }
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["tab"]
            },
            {
                "type": "integer",
                "minimum": 0
            }
        ]
    },
    {
        "type": "object",
        "properties": {
            "SwitchCase": {
                "type": "integer",
                "minimum": 0
            },
            "VariableDeclarator": {
                "oneOf": [
                    {
                        "type": "integer",
                        "minimum": 0
                    },
                    {
                        "type": "object",
                        "properties": {
                            "var": {
                                "type": "integer",
                                "minimum": 0
                            },
                            "let": {
                                "type": "integer",
                                "minimum": 0
                            },
                            "const": {
                                "type": "integer",
                                "minimum": 0
                            }
                        }
                    }
                ]
            }
        },
        "additionalProperties": false
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js","util":"/node_modules/browserify/node_modules/util/util.js"}],

"/tmp/rules/init-declarations.js": [function(require,module,exports){
"use strict";

function isForLoop(block) {
    return block.type === "ForInStatement" ||
    block.type === "ForOfStatement" ||
    block.type === "ForStatement";
}

function isInitialized(node) {
    var declaration = node.parent;
    var block = declaration.parent;

    if (isForLoop(block)) {
        if (block.type === "ForStatement") {
            return block.init === declaration;
        }
        return block.left === declaration;
    }
    return Boolean(node.init);
}

module.exports = function(context) {

    var MODE_ALWAYS = "always",
        MODE_NEVER = "never";

    var mode = context.options[0] || MODE_ALWAYS;
    var params = context.options[1] || {};
    return {
        "VariableDeclaration:exit": function(node) {

            var kind = node.kind,
                declarations = node.declarations;

            for (var i = 0; i < declarations.length; ++i) {
                var declaration = declarations[i],
                    id = declaration.id,
                    initialized = isInitialized(declaration),
                    isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);
                if (id.type !== "Identifier") {
                    continue;
                }

                if (mode === MODE_ALWAYS && !initialized) {
                    context.report(declaration, "Variable '" + id.name + "' should be initialized on declaration.");
                } else if (mode === MODE_NEVER && kind !== "const" && initialized && !isIgnoredForLoop) {
                    context.report(declaration, "Variable '" + id.name + "' should not be initialized on declaration.");
                }
            }
        }
    };
};

module.exports.schema = {
    "anyOf": [
        {
            "type": "array",
            "items": [
                {
                    "enum": ["always"]
                }
            ],
            "minItems": 0,
            "maxItems": 1
        },
        {
            "type": "array",
            "items": [
                {
                    "enum": ["never"]
                },
                {
                    "type": "object",
                    "properties": {
                        "ignoreForLoopInit": {
                            "type": "boolean"
                        }
                    },
                    "additionalProperties": false
                }
            ],
            "minItems": 0,
            "maxItems": 2
        }
    ]
};

},
   {}],

"/tmp/rules/jsx-quotes.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

var QUOTE_SETTINGS = {
    "prefer-double": {
        quote: "\"",
        description: "singlequote",
        convert: function(str) {
            return str.replace(/'/g, "\"");
        }
    },
    "prefer-single": {
        quote: "'",
        description: "doublequote",
        convert: function(str) {
            return str.replace(/"/g, "'");
        }
    }
};

module.exports = function(context) {
    var quoteOption = context.options[0] || "prefer-double",
        setting = QUOTE_SETTINGS[quoteOption];

    function usesExpectedQuotes(node) {
        return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);
    }

    return {
        "JSXAttribute": function(node) {
            var attributeValue = node.value;

            if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {
                context.report({
                    node: attributeValue,
                    message: "Unexpected usage of " + setting.description + ".",
                    fix: function(fixer) {
                        return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));
                    }
                });
            }
        }
    };
};

module.exports.schema = [
    {
        "enum": [ "prefer-single", "prefer-double" ]
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/key-spacing.js": [function(require,module,exports){
"use strict";

function containsLineTerminator(str) {
    return /[\n\r\u2028\u2029]/.test(str);
}

function last(arr) {
    return arr[arr.length - 1];
}

function continuesPropertyGroup(lastMember, candidate) {
    var groupEndLine = lastMember.loc.start.line,
        candidateStartLine = candidate.loc.start.line,
        comments, i;

    if (candidateStartLine - groupEndLine <= 1) {
        return true;
    }

    comments = candidate.leadingComments;
    if (
        comments &&
        comments[0].loc.start.line - groupEndLine <= 1 &&
        candidateStartLine - last(comments).loc.end.line <= 1
    ) {
        for (i = 1; i < comments.length; i++) {
            if (comments[i].loc.start.line - comments[i - 1].loc.end.line > 1) {
                return false;
            }
        }
        return true;
    }

    return false;
}

function isSingleLine(node) {
    return (node.loc.end.line === node.loc.start.line);
}

function initOptions(toOptions, fromOptions) {
    toOptions.mode = fromOptions.mode || "strict";

    if (typeof fromOptions.align !== "undefined") {
        toOptions.align = fromOptions.align;
    }

    if (typeof fromOptions.beforeColon !== "undefined") {
        toOptions.beforeColon = +fromOptions.beforeColon;
    } else {
        toOptions.beforeColon = 0;
    }

    if (typeof fromOptions.afterColon !== "undefined") {
        toOptions.afterColon = +fromOptions.afterColon;
    } else {
        toOptions.afterColon = 1;
    }

    return toOptions;
}

var messages = {
    key: "{{error}} space after {{computed}}key '{{key}}'.",
    value: "{{error}} space before value for {{computed}}key '{{key}}'."
};

module.exports = function(context) {

    var options = context.options[0] || {},
        multiLineOptions = initOptions({}, (options.multiLine || options)),
        singleLineOptions = initOptions({}, (options.singleLine || options));

    function isKeyValueProperty(property) {
        return !(
            property.method ||
            property.shorthand ||
            property.kind !== "init" ||
            property.type !== "Property" // Could be "ExperimentalSpreadProperty" or "SpreadProperty"
        );
    }

    function getLastTokenBeforeColon(node) {
        var prevNode;

        while (node && (node.type !== "Punctuator" || node.value !== ":")) {
            prevNode = node;
            node = context.getTokenAfter(node);
        }

        return prevNode;
    }

    function getNextColon(node) {

        while (node && (node.type !== "Punctuator" || node.value !== ":")) {
            node = context.getTokenAfter(node);
        }

        return node;
    }

    function getKey(property) {
        var key = property.key;

        if (property.computed) {
            return context.getSource().slice(key.range[0], key.range[1]);
        }

        return property.key.name || property.key.value;
    }

    function report(property, side, whitespace, expected, mode) {
        var diff = whitespace.length - expected,
            key = property.key,
            firstTokenAfterColon = context.getTokenAfter(getNextColon(key)),
            location = side === "key" ? key.loc.start : firstTokenAfterColon.loc.start;

        if ((
            diff && mode === "strict" ||
            diff < 0 && mode === "minimum" ||
            diff > 0 && !expected && mode === "minimum") &&
            !(expected && containsLineTerminator(whitespace))
        ) {
            context.report(property[side], location, messages[side], {
                error: diff > 0 ? "Extra" : "Missing",
                computed: property.computed ? "computed " : "",
                key: getKey(property)
            });
        }
    }

    function getKeyWidth(property) {
        var startToken, endToken;

        startToken = context.getFirstToken(property);
        endToken = getLastTokenBeforeColon(property.key);

        return endToken.range[1] - startToken.range[0];
    }

    function getPropertyWhitespace(property) {
        var whitespace = /(\s*):(\s*)/.exec(context.getSource().slice(
            property.key.range[1], property.value.range[0]
        ));

        if (whitespace) {
            return {
                beforeColon: whitespace[1],
                afterColon: whitespace[2]
            };
        }
        return null;
    }

    function createGroups(node) {
        if (node.properties.length === 1) {
            return [node.properties];
        }

        return node.properties.reduce(function(groups, property) {
            var currentGroup = last(groups),
                prev = last(currentGroup);

            if (!prev || continuesPropertyGroup(prev, property)) {
                currentGroup.push(property);
            } else {
                groups.push([property]);
            }

            return groups;
        }, [
            []
        ]);
    }

    function verifyGroupAlignment(properties) {
        var length = properties.length,
            widths = properties.map(getKeyWidth), // Width of keys, including quotes
            targetWidth = Math.max.apply(null, widths),
            i, property, whitespace, width,
            align = multiLineOptions.align,
            beforeColon = multiLineOptions.beforeColon,
            afterColon = multiLineOptions.afterColon,
            mode = multiLineOptions.mode;

        targetWidth += (align === "colon" ? beforeColon : afterColon);

        for (i = 0; i < length; i++) {
            property = properties[i];
            whitespace = getPropertyWhitespace(property);
            if (whitespace) { // Object literal getters/setters lack a colon
                width = widths[i];

                if (align === "value") {
                    report(property, "key", whitespace.beforeColon, beforeColon, mode);
                    report(property, "value", whitespace.afterColon, targetWidth - width, mode);
                } else { // align = "colon"
                    report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
                    report(property, "value", whitespace.afterColon, afterColon, mode);
                }
            }
        }
    }

    function verifyAlignment(node) {
        createGroups(node).forEach(function(group) {
            verifyGroupAlignment(group.filter(isKeyValueProperty));
        });
    }

    function verifySpacing(node, lineOptions) {
        var actual = getPropertyWhitespace(node);
        if (actual) { // Object literal getters/setters lack colons
            report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
            report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
        }
    }

    function verifyListSpacing(properties) {
        var length = properties.length;

        for (var i = 0; i < length; i++) {
            verifySpacing(properties[i], singleLineOptions);
        }
    }

    if (multiLineOptions.align) { // Verify vertical alignment

        return {
            "ObjectExpression": function(node) {
                if (isSingleLine(node)) {
                    verifyListSpacing(node.properties);
                } else {
                    verifyAlignment(node);
                }
            }
        };

    } else { // Obey beforeColon and afterColon in each property as configured

        return {
            "Property": function(node) {
                verifySpacing(node, isSingleLine(node) ? singleLineOptions : multiLineOptions);
            }
        };

    }

};

module.exports.schema = [{
    "anyOf": [
        {
            "type": "object",
            "properties": {
                "align": {
                    "enum": ["colon", "value"]
                },
                "mode": {
                    "enum": ["strict", "minimum"]
                },
                "beforeColon": {
                    "type": "boolean"
                },
                "afterColon": {
                    "type": "boolean"
                }
            },
            "additionalProperties": false
        },
        {
            "type": "object",
            "properties": {
                "singleLine": {
                    "type": "object",
                    "properties": {
                        "mode": {
                            "enum": ["strict", "minimum"]
                        },
                        "beforeColon": {
                            "type": "boolean"
                        },
                        "afterColon": {
                            "type": "boolean"
                        }
                    },
                    "additionalProperties": false
                },
                "multiLine": {
                    "type": "object",
                    "properties": {
                        "align": {
                            "enum": ["colon", "value"]
                        },
                        "mode": {
                            "enum": ["strict", "minimum"]
                        },
                        "beforeColon": {
                            "type": "boolean"
                        },
                        "afterColon": {
                            "type": "boolean"
                        }
                    },
                    "additionalProperties": false
                }
            },
            "additionalProperties": false
        }
    ]
}];

},
   {}],

"/tmp/rules/keyword-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils"),
    keywords = require("../util/keywords");

var PREV_TOKEN = /^[\)\]\}>]$/;
var NEXT_TOKEN = /^(?:[\(\[\{<~!]|\+\+?|--?)$/;
var PREV_TOKEN_M = /^[\)\]\}>*]$/;
var NEXT_TOKEN_M = /^[\{*]$/;
var TEMPLATE_OPEN_PAREN = /\$\{$/;
var TEMPLATE_CLOSE_PAREN = /^\}/;
var CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/;
var KEYS = keywords.concat(["as", "await", "from", "get", "let", "of", "set", "yield"]);

(function() {
    KEYS.sort();
    for (var i = 1; i < KEYS.length; ++i) {
        if (KEYS[i] === KEYS[i - 1]) {
            throw new Error("Duplication was found in the keyword list: " + KEYS[i]);
        }
    }
}());

function isOpenParenOfTemplate(token) {
    return token.type === "Template" && TEMPLATE_OPEN_PAREN.test(token.value);
}

function isCloseParenOfTemplate(token) {
    return token.type === "Template" && TEMPLATE_CLOSE_PAREN.test(token.value);
}

module.exports = function(context) {
    var sourceCode = context.getSourceCode();

    function expectSpaceBefore(token, pattern) {
        pattern = pattern || PREV_TOKEN;

        var prevToken = sourceCode.getTokenBefore(token);
        if (prevToken &&
            (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&
            !isOpenParenOfTemplate(prevToken) &&
            astUtils.isTokenOnSameLine(prevToken, token) &&
            !sourceCode.isSpaceBetweenTokens(prevToken, token)
        ) {
            context.report({
                loc: token.loc.start,
                message: "Expected space(s) before \"{{value}}\".",
                data: token,
                fix: function(fixer) {
                    return fixer.insertTextBefore(token, " ");
                }
            });
        }
    }

    function unexpectSpaceBefore(token, pattern) {
        pattern = pattern || PREV_TOKEN;

        var prevToken = sourceCode.getTokenBefore(token);
        if (prevToken &&
            (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&
            !isOpenParenOfTemplate(prevToken) &&
            astUtils.isTokenOnSameLine(prevToken, token) &&
            sourceCode.isSpaceBetweenTokens(prevToken, token)
        ) {
            context.report({
                loc: token.loc.start,
                message: "Unexpected space(s) before \"{{value}}\".",
                data: token,
                fix: function(fixer) {
                    return fixer.removeRange([prevToken.range[1], token.range[0]]);
                }
            });
        }
    }

    function expectSpaceAfter(token, pattern) {
        pattern = pattern || NEXT_TOKEN;

        var nextToken = sourceCode.getTokenAfter(token);
        if (nextToken &&
            (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&
            !isCloseParenOfTemplate(nextToken) &&
            astUtils.isTokenOnSameLine(token, nextToken) &&
            !sourceCode.isSpaceBetweenTokens(token, nextToken)
        ) {
            context.report({
                loc: token.loc.start,
                message: "Expected space(s) after \"{{value}}\".",
                data: token,
                fix: function(fixer) {
                    return fixer.insertTextAfter(token, " ");
                }
            });
        }
    }

    function unexpectSpaceAfter(token, pattern) {
        pattern = pattern || NEXT_TOKEN;

        var nextToken = sourceCode.getTokenAfter(token);
        if (nextToken &&
            (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&
            !isCloseParenOfTemplate(nextToken) &&
            astUtils.isTokenOnSameLine(token, nextToken) &&
            sourceCode.isSpaceBetweenTokens(token, nextToken)
        ) {
            context.report({
                loc: token.loc.start,
                message: "Unexpected space(s) after \"{{value}}\".",
                data: token,
                fix: function(fixer) {
                    return fixer.removeRange([token.range[1], nextToken.range[0]]);
                }
            });
        }
    }
    function noop() {}
    
    function parseOptions(options) {
        var before = !options || options.before !== false;
        var after = !options || options.after !== false;
        var defaultValue = {
            before: before ? expectSpaceBefore : unexpectSpaceBefore,
            after: after ? expectSpaceAfter : unexpectSpaceAfter
        };
        var overrides = (options && options.overrides) || {};
        var retv = Object.create(null);

        for (var i = 0; i < KEYS.length; ++i) {
            var key = KEYS[i];
            var override = overrides[key];

            if (override) {
                var thisBefore = ("before" in override) ? override.before : before;
                var thisAfter = ("after" in override) ? override.after : after;
                retv[key] = {
                    before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
                    after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
                };
                if (typeof thisBefore != "boolean")
                    retv[key].before = noop;
                if (typeof thisAfter != "boolean")
                    retv[key].after = noop;
            } else {
                retv[key] = defaultValue;
            }
        }

        return retv;
    }

    var checkMethodMap = parseOptions(context.options[0]);

    function checkSpacingBefore(token, pattern) {
        checkMethodMap[token.value].before(token, pattern);
    }

    function checkSpacingAfter(token, pattern) {
        checkMethodMap[token.value].after(token, pattern);
    }

    function checkSpacingAround(token) {
        checkSpacingBefore(token);
        checkSpacingAfter(token);
    }

    function checkSpacingAroundFirstToken(node) {
        var firstToken = node && sourceCode.getFirstToken(node);
        if (firstToken && firstToken.type === "Keyword") {
            checkSpacingAround(firstToken);
        }
    }

    function checkSpacingBeforeFirstToken(node) {
        var firstToken = node && sourceCode.getFirstToken(node);
        if (firstToken && firstToken.type === "Keyword") {
            checkSpacingBefore(firstToken);
        }
    }

    function checkSpacingAroundTokenBefore(node) {
        if (node) {
            var token = sourceCode.getTokenBefore(node);
            while (token.type !== "Keyword") {
                token = sourceCode.getTokenBefore(token);
            }

            checkSpacingAround(token);
        }
    }

    function checkSpacingForClass(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.superClass);
    }

    function checkSpacingForIfStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.alternate);
    }

    function checkSpacingForTryStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundFirstToken(node.handler);
        checkSpacingAroundTokenBefore(node.finalizer);
    }

    function checkSpacingForDoWhileStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.test);
    }

    function checkSpacingForForInStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.right);
    }

    function checkSpacingForForOfStatement(node) {
        checkSpacingAroundFirstToken(node);

        var token = sourceCode.getTokenBefore(node.right);
        while (token.value !== "of") {
            token = sourceCode.getTokenBefore(token);
        }
        checkSpacingAround(token);
    }

    function checkSpacingForModuleDeclaration(node) {
        var firstToken = sourceCode.getFirstToken(node);
        checkSpacingBefore(firstToken, PREV_TOKEN_M);
        checkSpacingAfter(firstToken, NEXT_TOKEN_M);

        if (node.source) {
            var fromToken = sourceCode.getTokenBefore(node.source);
            checkSpacingBefore(fromToken, PREV_TOKEN_M);
            checkSpacingAfter(fromToken, NEXT_TOKEN_M);
        }
    }

    function checkSpacingForImportNamespaceSpecifier(node) {
        var asToken = sourceCode.getFirstToken(node, 1);
        checkSpacingBefore(asToken, PREV_TOKEN_M);
    }

    function checkSpacingForProperty(node) {
        if (node.static) {
            checkSpacingAroundFirstToken(node);
        }
        if (node.kind === "get" || node.kind === "set") {
            var token = sourceCode.getFirstToken(
                node,
                node.static ? 1 : 0
            );
            checkSpacingAround(token);
        }
    }

    return {
        DebuggerStatement: checkSpacingAroundFirstToken,
        WithStatement: checkSpacingAroundFirstToken,

        BreakStatement: checkSpacingAroundFirstToken,
        ContinueStatement: checkSpacingAroundFirstToken,
        ReturnStatement: checkSpacingAroundFirstToken,
        ThrowStatement: checkSpacingAroundFirstToken,
        TryStatement: checkSpacingForTryStatement,

        IfStatement: checkSpacingForIfStatement,
        SwitchStatement: checkSpacingAroundFirstToken,
        SwitchCase: checkSpacingAroundFirstToken,

        DoWhileStatement: checkSpacingForDoWhileStatement,
        ForInStatement: checkSpacingForForInStatement,
        ForOfStatement: checkSpacingForForOfStatement,
        ForStatement: checkSpacingAroundFirstToken,
        WhileStatement: checkSpacingAroundFirstToken,

        ClassDeclaration: checkSpacingForClass,
        ExportNamedDeclaration: checkSpacingForModuleDeclaration,
        ExportDefaultDeclaration: checkSpacingAroundFirstToken,
        ExportAllDeclaration: checkSpacingForModuleDeclaration,
        FunctionDeclaration: checkSpacingBeforeFirstToken,
        ImportDeclaration: checkSpacingForModuleDeclaration,
        VariableDeclaration: checkSpacingAroundFirstToken,

        ClassExpression: checkSpacingForClass,
        FunctionExpression: checkSpacingBeforeFirstToken,
        NewExpression: checkSpacingBeforeFirstToken,
        Super: checkSpacingBeforeFirstToken,
        ThisExpression: checkSpacingBeforeFirstToken,
        UnaryExpression: checkSpacingBeforeFirstToken,
        YieldExpression: checkSpacingBeforeFirstToken,

        ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,
        MethodDefinition: checkSpacingForProperty,
        Property: checkSpacingForProperty
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "before": {"type": "boolean"},
            "after": {"type": "boolean"},
            "overrides": {
                "type": "object",
                "properties": KEYS.reduce(function(retv, key) {
                    retv[key] = {
                        "type": "object",
                        "properties": {
                            "before": {"type": "boolean"},
                            "after": {"type": "boolean"}
                        },
                        "additionalProperties": false
                    };
                    return retv;
                }, {}),
                "additionalProperties": false
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js","../util/keywords":"/tmp/util/keywords.js"}],

"/tmp/rules/linebreak-style.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var EXPECTED_LF_MSG = "Expected linebreaks to be 'LF' but found 'CRLF'.",
        EXPECTED_CRLF_MSG = "Expected linebreaks to be 'CRLF' but found 'LF'.";

    function createFix(range, text) {
        return function(fixer) {
            return fixer.replaceTextRange(range, text);
        };
    }

    return {
        "Program": function checkForlinebreakStyle(node) {
            var linebreakStyle = context.options[0] || "unix",
                expectedLF = linebreakStyle === "unix",
                expectedLFChars = expectedLF ? "\n" : "\r\n",
                source = context.getSource(),
                pattern = /\r\n|\r|\n|\u2028|\u2029/g,
                match,
                index,
                range;

            var i = 0;
            while ((match = pattern.exec(source)) !== null) {
                i++;
                if (match[0] === expectedLFChars) {
                    continue;
                }

                index = match.index;
                range = [index, index + match[0].length];
                context.report({
                    node: node,
                    loc: {
                        line: i,
                        column: context.getSourceLines()[i - 1].length
                    },
                    message: expectedLF ? EXPECTED_LF_MSG : EXPECTED_CRLF_MSG,
                    fix: createFix(range, expectedLFChars)
                });
            }
        }
    };
};

module.exports.schema = [
    {
        "enum": ["unix", "windows"]
    }
];

},
   {}],

"/tmp/rules/lines-around-comment.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

function getEmptyLineNums(lines) {
    var emptyLines = lines.map(function(line, i) {
        return {
            code: line.trim(),
            num: i + 1
        };
    }).filter(function(line) {
        return !line.code;
    }).map(function(line) {
        return line.num;
    });
    return emptyLines;
}

function getCommentLineNums(comments) {
    var lines = [];
    comments.forEach(function(token) {
        var start = token.loc.start.line;
        var end = token.loc.end.line;
        lines.push(start, end);
    });
    return lines;
}

function contains(val, array) {
    return array.indexOf(val) > -1;
}

module.exports = function(context) {

    var options = context.options[0] ? lodash.assign({}, context.options[0]) : {};
    options.beforeLineComment = options.beforeLineComment || false;
    options.afterLineComment = options.afterLineComment || false;
    options.beforeBlockComment = typeof options.beforeBlockComment !== "undefined" ? options.beforeBlockComment : true;
    options.afterBlockComment = options.afterBlockComment || false;
    options.allowBlockStart = options.allowBlockStart || false;
    options.allowBlockEnd = options.allowBlockEnd || false;

    var sourceCode = context.getSourceCode();
    function codeAroundComment(node) {
        var token;

        token = node;
        do {
            token = sourceCode.getTokenOrCommentBefore(token);
        } while (token && (token.type === "Block" || token.type === "Line"));

        if (token && token.loc.end.line === node.loc.start.line) {
            return true;
        }

        token = node;
        do {
            token = sourceCode.getTokenOrCommentAfter(token);
        } while (token && (token.type === "Block" || token.type === "Line"));

        if (token && token.loc.start.line === node.loc.end.line) {
            return true;
        }

        return false;
    }

    function isCommentInsideNodeType(node, parent, nodeType) {
        return parent.type === nodeType ||
            (parent.body && parent.body.type === nodeType) ||
            (parent.consequent && parent.consequent.type === nodeType);
    }

    function isCommentAtParentStart(node, nodeType) {
        var ancestors = context.getAncestors();
        var parent;

        if (ancestors.length) {
            parent = ancestors.pop();
        }

        return parent && isCommentInsideNodeType(node, parent, nodeType) &&
                node.loc.start.line - parent.loc.start.line === 1;
    }

    function isCommentAtParentEnd(node, nodeType) {
        var ancestors = context.getAncestors();
        var parent;

        if (ancestors.length) {
            parent = ancestors.pop();
        }

        return parent && isCommentInsideNodeType(node, parent, nodeType) &&
                parent.loc.end.line - node.loc.end.line === 1;
    }

    function isCommentAtBlockStart(node) {
        return isCommentAtParentStart(node, "ClassBody") || isCommentAtParentStart(node, "BlockStatement");
    }

    function isCommentAtBlockEnd(node) {
        return isCommentAtParentEnd(node, "ClassBody") || isCommentAtParentEnd(node, "BlockStatement");
    }

    function isCommentAtObjectStart(node) {
        return isCommentAtParentStart(node, "ObjectExpression") || isCommentAtParentStart(node, "ObjectPattern");
    }

    function isCommentAtObjectEnd(node) {
        return isCommentAtParentEnd(node, "ObjectExpression") || isCommentAtParentEnd(node, "ObjectPattern");
    }

    function isCommentAtArrayStart(node) {
        return isCommentAtParentStart(node, "ArrayExpression") || isCommentAtParentStart(node, "ArrayPattern");
    }

    function isCommentAtArrayEnd(node) {
        return isCommentAtParentEnd(node, "ArrayExpression") || isCommentAtParentEnd(node, "ArrayPattern");
    }

    function checkForEmptyLine(node, opts) {

        var lines = context.getSourceLines(),
            numLines = lines.length + 1,
            comments = context.getAllComments(),
            commentLines = getCommentLineNums(comments),
            emptyLines = getEmptyLineNums(lines),
            commentAndEmptyLines = commentLines.concat(emptyLines);

        var after = opts.after,
            before = opts.before;

        var prevLineNum = node.loc.start.line - 1,
            nextLineNum = node.loc.end.line + 1,
            commentIsNotAlone = codeAroundComment(node);

        var blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(node),
            blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(node),
            objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(node),
            objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(node),
            arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(node),
            arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(node);

        var exceptionStartAllowed = blockStartAllowed || objectStartAllowed || arrayStartAllowed;
        var exceptionEndAllowed = blockEndAllowed || objectEndAllowed || arrayEndAllowed;

        if (prevLineNum < 1) {
            before = false;
        }
        if (nextLineNum >= numLines) {
            after = false;
        }

        if (commentIsNotAlone) {
            return;
        }

        if (!exceptionStartAllowed && before && !contains(prevLineNum, commentAndEmptyLines)) {
            context.report(node, "Expected line before comment.");
        }

        if (!exceptionEndAllowed && after && !contains(nextLineNum, commentAndEmptyLines)) {
            context.report(node, "Expected line after comment.");
        }

    }

    return {

        "LineComment": function(node) {
            if (options.beforeLineComment || options.afterLineComment) {
                checkForEmptyLine(node, {
                    after: options.afterLineComment,
                    before: options.beforeLineComment
                });
            }
        },

        "BlockComment": function(node) {
            if (options.beforeBlockComment || options.afterBlockComment) {
                checkForEmptyLine(node, {
                    after: options.afterBlockComment,
                    before: options.beforeBlockComment
                });
            }
        }

    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "beforeBlockComment": {
                "type": "boolean"
            },
            "afterBlockComment": {
                "type": "boolean"
            },
            "beforeLineComment": {
                "type": "boolean"
            },
            "afterLineComment": {
                "type": "boolean"
            },
            "allowBlockStart": {
                "type": "boolean"
            },
            "allowBlockEnd": {
                "type": "boolean"
            },
            "allowObjectStart": {
                "type": "boolean"
            },
            "allowObjectEnd": {
                "type": "boolean"
            },
            "allowArrayStart": {
                "type": "boolean"
            },
            "allowArrayEnd": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/max-depth.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var functionStack = [],
        option = context.options[0],
        maxDepth = 4;

    if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
        maxDepth = option.maximum;
    }
    if (typeof option === "number") {
        maxDepth = option;
    }

    function startFunction() {
        functionStack.push(0);
    }

    function endFunction() {
        functionStack.pop();
    }

    function pushBlock(node) {
        var len = ++functionStack[functionStack.length - 1];

        if (len > maxDepth) {
            context.report(node, "Blocks are nested too deeply ({{depth}}).",
                    { depth: len });
        }
    }

    function popBlock() {
        functionStack[functionStack.length - 1]--;
    }

    return {
        "Program": startFunction,
        "FunctionDeclaration": startFunction,
        "FunctionExpression": startFunction,
        "ArrowFunctionExpression": startFunction,

        "IfStatement": function(node) {
            if (node.parent.type !== "IfStatement") {
                pushBlock(node);
            }
        },
        "SwitchStatement": pushBlock,
        "TryStatement": pushBlock,
        "DoWhileStatement": pushBlock,
        "WhileStatement": pushBlock,
        "WithStatement": pushBlock,
        "ForStatement": pushBlock,
        "ForInStatement": pushBlock,
        "ForOfStatement": pushBlock,

        "IfStatement:exit": popBlock,
        "SwitchStatement:exit": popBlock,
        "TryStatement:exit": popBlock,
        "DoWhileStatement:exit": popBlock,
        "WhileStatement:exit": popBlock,
        "WithStatement:exit": popBlock,
        "ForStatement:exit": popBlock,
        "ForInStatement:exit": popBlock,
        "ForOfStatement:exit": popBlock,

        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction,
        "Program:exit": endFunction
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "type": "integer",
                "minimum": 0
            },
            {
                "type": "object",
                "properties": {
                    "maximum": {
                        "type": "integer",
                        "minimum": 0
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/max-len.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var URL_REGEXP = /[^:/?#]:\/\/[^?#]/;

    function computeLineLength(line, tabWidth) {
        var extraCharacterCount = 0;
        line.replace(/\t/g, function(match, offset) {
            var totalOffset = offset + extraCharacterCount,
                previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,
                spaceCount = tabWidth - previousTabStopOffset;
            extraCharacterCount += spaceCount - 1;  // -1 for the replaced tab
        });
        return line.length + extraCharacterCount;
    }

    var lastOption = context.options[context.options.length - 1];
    var options = typeof lastOption === "object" ? Object.create(lastOption) : {};
    if (typeof context.options[0] === "number") {
        options.code = context.options[0];
    }
    if (typeof context.options[1] === "number") {
        options.tabWidth = context.options[1];
    }

    var maxLength = options.code || 80,
        tabWidth = options.tabWidth || 4,
        ignorePattern = options.ignorePattern || null,
        ignoreComments = options.ignoreComments || false,
        ignoreTrailingComments = options.ignoreTrailingComments || options.ignoreComments || false,
        ignoreUrls = options.ignoreUrls || false,
        maxCommentLength = options.comments;

    if (ignorePattern) {
        ignorePattern = new RegExp(ignorePattern);
    }

    function isTrailingComment(line, lineNumber, comment) {
        return comment &&
            (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&
            (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
    }

    function isFullLineComment(line, lineNumber, comment) {
        var start = comment.loc.start,
            end = comment.loc.end;

        return comment &&
            (start.line < lineNumber || (start.line === lineNumber && start.column === 0)) &&
            (end.line > lineNumber || end.column === line.length);
    }

    function stripTrailingComment(line, lineNumber, comment) {
        return line.slice(0, comment.loc.start.column).replace(/\s+$/, "");
    }

    function checkProgramForMaxLength(node) {
        var lines = context.getSourceLines(),
            comments = ignoreComments || maxCommentLength ? context.getAllComments() : [],
            commentsIndex = 0;

        lines.forEach(function(line, i) {
            var lineNumber = i + 1;
            var lineIsComment = false;

            if (commentsIndex < comments.length) {
                do {
                    var comment = comments[++commentsIndex];
                } while (comment && comment.loc.start.line <= lineNumber);
                comment = comments[--commentsIndex];

                if (isFullLineComment(line, lineNumber, comment)) {
                    lineIsComment = true;
                } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {
                    line = stripTrailingComment(line, lineNumber, comment);
                }
            }
            if (ignorePattern && ignorePattern.test(line) ||
                ignoreUrls && URL_REGEXP.test(line)) {
                return;
            }

            var lineLength = computeLineLength(line, tabWidth);

            if (lineIsComment && ignoreComments) {
                return;
            }

            if (lineIsComment && lineLength > maxCommentLength) {
                context.report(node, { line: lineNumber, column: 0 }, "Line " + (i + 1) + " exceeds the maximum comment line length of " + maxCommentLength + ".");
            } else if (lineLength > maxLength) {
                context.report(node, { line: lineNumber, column: 0 }, "Line " + (i + 1) + " exceeds the maximum line length of " + maxLength + ".");
            }
        });
    }


    return {
        "Program": checkProgramForMaxLength
    };

};

var OPTIONS_SCHEMA = {
    "type": "object",
    "properties": {
        "code": {
            "type": "integer",
            "minimum": 0
        },
        "comments": {
            "type": "integer",
            "minimum": 0
        },
        "tabWidth": {
            "type": "integer",
            "minimum": 0
        },
        "ignorePattern": {
            "type": "string"
        },
        "ignoreComments": {
            "type": "boolean"
        },
        "ignoreUrls": {
            "type": "boolean"
        },
        "ignoreTrailingComments": {
            "type": "boolean"
        }
    },
    "additionalProperties": false
};

var OPTIONS_OR_INTEGER_SCHEMA = {
    "anyOf": [
        OPTIONS_SCHEMA,
        {
            "type": "integer",
            "minimum": 0
        }
    ]
};

module.exports.schema = [
    OPTIONS_OR_INTEGER_SCHEMA,
    OPTIONS_OR_INTEGER_SCHEMA,
    OPTIONS_SCHEMA
];

},
   {}],

"/tmp/rules/max-nested-callbacks.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var option = context.options[0],
        THRESHOLD = 10;

    if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
        THRESHOLD = option.maximum;
    }
    if (typeof option === "number") {
        THRESHOLD = option;
    }

    var callbackStack = [];

    function checkFunction(node) {
        var parent = node.parent;

        if (parent.type === "CallExpression") {
            callbackStack.push(node);
        }

        if (callbackStack.length > THRESHOLD) {
            var opts = {num: callbackStack.length, max: THRESHOLD};
            context.report(node, "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}.", opts);
        }
    }

    function popStack() {
        callbackStack.pop();
    }

    return {
        "ArrowFunctionExpression": checkFunction,
        "ArrowFunctionExpression:exit": popStack,

        "FunctionExpression": checkFunction,
        "FunctionExpression:exit": popStack
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "type": "integer",
                "minimum": 0
            },
            {
                "type": "object",
                "properties": {
                    "maximum": {
                        "type": "integer",
                        "minimum": 0
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/max-params.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var option = context.options[0],
        numParams = 3;

    if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
        numParams = option.maximum;
    }
    if (typeof option === "number") {
        numParams = option;
    }

    function checkFunction(node) {
        if (node.params.length > numParams) {
            context.report(node, "This function has too many parameters ({{count}}). Maximum allowed is {{max}}.", {
                count: node.params.length,
                max: numParams
            });
        }
    }

    return {
        "FunctionDeclaration": checkFunction,
        "ArrowFunctionExpression": checkFunction,
        "FunctionExpression": checkFunction
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "type": "integer",
                "minimum": 0
            },
            {
                "type": "object",
                "properties": {
                    "maximum": {
                        "type": "integer",
                        "minimum": 0
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/max-statements.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var functionStack = [],
        option = context.options[0],
        maxStatements = 10,
        ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,
        topLevelFunctions = [];

    if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
        maxStatements = option.maximum;
    }
    if (typeof option === "number") {
        maxStatements = option;
    }

    function reportIfTooManyStatements(node, count, max) {
        if (count > max) {
            context.report(
                node,
                "This function has too many statements ({{count}}). Maximum allowed is {{max}}.",
                { count: count, max: max });
        }
    }

    function startFunction() {
        functionStack.push(0);
    }

    function endFunction(node) {
        var count = functionStack.pop();
        if (ignoreTopLevelFunctions && functionStack.length === 0) {
            topLevelFunctions.push({ node: node, count: count});
        } else {
            reportIfTooManyStatements(node, count, maxStatements);
        }
    }

    function countStatements(node) {
        functionStack[functionStack.length - 1] += node.body.length;
    }

    return {
        "FunctionDeclaration": startFunction,
        "FunctionExpression": startFunction,
        "ArrowFunctionExpression": startFunction,

        "BlockStatement": countStatements,

        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction,

        "Program:exit": function() {
            if (topLevelFunctions.length === 1) {
                return;
            }

            topLevelFunctions.forEach(function(element) {
                var count = element.count;
                var node = element.node;
                reportIfTooManyStatements(node, count, maxStatements);
            });
        }
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "type": "integer",
                "minimum": 0
            },
            {
                "type": "object",
                "properties": {
                    "maximum": {
                        "type": "integer",
                        "minimum": 0
                    }
                },
                "additionalProperties": false
            }
        ]
    },
    {
        "type": "object",
        "properties": {
            "ignoreTopLevelFunctions": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/new-cap.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

var CAPS_ALLOWED = [
    "Array",
    "Boolean",
    "Date",
    "Error",
    "Function",
    "Number",
    "Object",
    "RegExp",
    "String",
    "Symbol"
];

function checkArray(obj, key, fallback) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {
        throw new TypeError(key + ", if provided, must be an Array");
    }
    return obj[key] || fallback;
}

function invert(map, key) {
    map[key] = true;
    return map;
}

function calculateCapIsNewExceptions(config) {
    var capIsNewExceptions = checkArray(config, "capIsNewExceptions", CAPS_ALLOWED);

    if (capIsNewExceptions !== CAPS_ALLOWED) {
        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);
    }

    return capIsNewExceptions.reduce(invert, {});
}

module.exports = function(context) {

    var config = context.options[0] ? lodash.assign({}, context.options[0]) : {};
    config.newIsCap = config.newIsCap !== false;
    config.capIsNew = config.capIsNew !== false;
    var skipProperties = config.properties === false;

    var newIsCapExceptions = checkArray(config, "newIsCapExceptions", []).reduce(invert, {});

    var capIsNewExceptions = calculateCapIsNewExceptions(config);

    var listeners = {};

    function extractNameFromExpression(node) {

        var name = "",
            property;

        if (node.callee.type === "MemberExpression") {
            property = node.callee.property;

            if (property.type === "Literal" && (typeof property.value === "string")) {
                name = property.value;
            } else if (property.type === "Identifier" && !node.callee.computed) {
                name = property.name;
            }
        } else {
            name = node.callee.name;
        }
        return name;
    }

    function getCap(str) {
        var firstChar = str.charAt(0);

        var firstCharLower = firstChar.toLowerCase();
        var firstCharUpper = firstChar.toUpperCase();

        if (firstCharLower === firstCharUpper) {
            return "non-alpha";
        } else if (firstChar === firstCharLower) {
            return "lower";
        } else {
            return "upper";
        }
    }

    function isCapAllowed(allowedMap, node, calleeName) {
        if (allowedMap[calleeName] || allowedMap[context.getSource(node.callee)]) {
            return true;
        }

        if (calleeName === "UTC" && node.callee.type === "MemberExpression") {
            return node.callee.object.type === "Identifier" &&
                node.callee.object.name === "Date";
        }

        return skipProperties && node.callee.type === "MemberExpression";
    }

    function report(node, message) {
        var callee = node.callee;

        if (callee.type === "MemberExpression") {
            callee = callee.property;
        }

        context.report(node, callee.loc.start, message);
    }

    if (config.newIsCap) {
        listeners.NewExpression = function(node) {

            var constructorName = extractNameFromExpression(node);
            if (constructorName) {
                var capitalization = getCap(constructorName);
                var isAllowed = capitalization !== "lower" || isCapAllowed(newIsCapExceptions, node, constructorName);
                if (!isAllowed) {
                    report(node, "A constructor name should not start with a lowercase letter.");
                }
            }
        };
    }

    if (config.capIsNew) {
        listeners.CallExpression = function(node) {

            var calleeName = extractNameFromExpression(node);
            if (calleeName) {
                var capitalization = getCap(calleeName);
                var isAllowed = capitalization !== "upper" || isCapAllowed(capIsNewExceptions, node, calleeName);
                if (!isAllowed) {
                    report(node, "A function with a name starting with an uppercase letter should only be used as a constructor.");
                }
            }
        };
    }

    return listeners;
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "newIsCap": {
                "type": "boolean"
            },
            "capIsNew": {
                "type": "boolean"
            },
            "newIsCapExceptions": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "capIsNewExceptions": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "properties": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/new-parens.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "NewExpression": function(node) {
            var tokens = context.getTokens(node);
            var prenticesTokens = tokens.filter(function(token) {
                return token.value === "(" || token.value === ")";
            });
            if (prenticesTokens.length < 2) {
                context.report(node, "Missing '()' invoking a constructor");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/newline-after-var.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var ALWAYS_MESSAGE = "Expected blank line after variable declarations.",
        NEVER_MESSAGE = "Unexpected blank line after variable declarations.";

    var sourceCode = context.getSourceCode();

    var mode = context.options[0] === "never" ? "never" : "always";

    var commentEndLine = context.getAllComments().reduce(function(result, token) {
        result[token.loc.start.line] = token.loc.end.line;
        return result;
    }, {});


    function isVar(keyword) {
        return keyword === "var" || keyword === "let" || keyword === "const";
    }

    function isForTypeSpecifier(keyword) {
        return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
    }

    function isExportSpecifier(nodeType) {
        return nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" ||
            nodeType === "ExportDefaultDeclaration" || nodeType === "ExportAllDeclaration";
    }

    function isLastNode(node) {
        var token = sourceCode.getTokenAfter(node);
        return !token || (token.type === "Punctuator" && token.value === "}");
    }

    function hasBlankLineAfterComment(token, commentStartLine) {
        var commentEnd = commentEndLine[commentStartLine];
        if (commentEndLine[commentEnd + 1]) {
            return hasBlankLineAfterComment(token, commentEnd + 1);
        }
        return (token.loc.start.line > commentEndLine[commentStartLine] + 1);
    }

    function checkForBlankLine(node) {
        var lastToken = sourceCode.getLastToken(node),
            nextToken = sourceCode.getTokenAfter(node),
            nextLineNum = lastToken.loc.end.line + 1,
            noNextLineToken,
            hasNextLineComment;

        if (!nextToken) {
            return;
        }

        if (isForTypeSpecifier(node.parent.type)) {
            return;
        }

        if (isExportSpecifier(node.parent.type)) {
            return;
        }

        if (nextToken.type === "Keyword" && isVar(nextToken.value)) {
            return;
        }

        if (isLastNode(node)) {
            return;
        }

        noNextLineToken = nextToken.loc.start.line > nextLineNum;
        hasNextLineComment = (typeof commentEndLine[nextLineNum] !== "undefined");

        if (mode === "never" && noNextLineToken && !hasNextLineComment) {
            context.report(node, NEVER_MESSAGE, { identifier: node.name });
        }

        if (
            mode === "always" && (
                !noNextLineToken ||
                hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)
            )
        ) {
            context.report(node, ALWAYS_MESSAGE, { identifier: node.name });
        }
    }

    return {
        "VariableDeclaration": checkForBlankLine
    };

};

module.exports.schema = [
    {
        "enum": ["never", "always"]
    }
];

},
   {}],

"/tmp/rules/newline-before-return.js": [function(require,module,exports){

"use strict";

module.exports = function(context) {
    var sourceCode = context.getSourceCode();

    function isPrecededByTokens(node, testTokens) {
        var tokenBefore = sourceCode.getTokenBefore(node);

        return testTokens.some(function(token) {
            return tokenBefore.value === token;
        });
    }

    function isFirstNode(node) {
        var parentType = node.parent.type;

        if (node.parent.body) {
            return Array.isArray(node.parent.body)
              ? node.parent.body[0] === node
              : node.parent.body === node;
        }

        if (parentType === "IfStatement") {
            return isPrecededByTokens(node, ["else", ")"]);
        } else if (parentType === "DoWhileStatement") {
            return isPrecededByTokens(node, ["do"]);
        } else if (parentType === "SwitchCase") {
            return isPrecededByTokens(node, [":"]);
        } else {
            return isPrecededByTokens(node, [")"]);
        }
    }

    function calcCommentLines(node, tokenBefore) {
        var comments = sourceCode.getComments(node).leading;
        var numLinesComments = 0;

        if (!comments.length) {
            return numLinesComments;
        }

        comments.forEach(function(comment) {
            numLinesComments++;

            if (comment.type === "Block") {
                numLinesComments += comment.loc.end.line - comment.loc.start.line;
            }

            if (comment.loc.start.line === tokenBefore.loc.end.line) {
                numLinesComments--;
            }

            if (comment.loc.end.line === node.loc.start.line) {
                numLinesComments--;
            }
        });

        return numLinesComments;
    }

    function hasNewlineBefore(node) {
        var tokenBefore = sourceCode.getTokenBefore(node);
        var lineNumTokenBefore = tokenBefore.loc.end.line;
        var lineNumNode = node.loc.start.line;
        var commentLines = calcCommentLines(node, tokenBefore);

        return (lineNumNode - lineNumTokenBefore - commentLines) > 1;
    }

    function reportError(node, isExpected) {
        var expected = isExpected ? "Expected" : "Unexpected";

        context.report({
            node: node,
            message: expected + " newline before return statement."
        });
    }

    return {
        ReturnStatement: function(node) {
            if (isFirstNode(node) && hasNewlineBefore(node)) {
                reportError(node, false);
            } else if (!isFirstNode(node) && !hasNewlineBefore(node)) {
                reportError(node, true);
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/newline-per-chained-call.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var options = context.options[0] || {},
        ignoreChainWithDepth = options.ignoreChainWithDepth || 2;

    return {
        "CallExpression:exit": function(node) {
            if (!node.callee || node.callee.type !== "MemberExpression") {
                return;
            }

            var callee = node.callee;
            var parent = callee.object;
            var depth = 1;

            while (parent && parent.callee) {
                depth += 1;
                parent = parent.callee.object;
            }

            if (depth > ignoreChainWithDepth && callee.property.loc.start.line === callee.object.loc.end.line) {
                context.report(
                    callee.property,
                    callee.property.loc.start,
                    "Expected line break after `" + context.getSource(callee.object).replace(/\r\n|\r|\n/g, "\\n") + "`."
                );
            }
        }
    };
};

module.exports.schema = [{
    "type": "object",
    "properties": {
        "ignoreChainWithDepth": {
            "type": "integer",
            "minimum": 1,
            "maximum": 10
        }
    },
    "additionalProperties": false
}];

},
   {}],

"/tmp/rules/no-alert.js": [function(require,module,exports){
"use strict";

function isProhibitedIdentifier(name) {
    return /^(alert|confirm|prompt)$/.test(name);
}

function report(context, node, identifierName) {
    context.report(node, "Unexpected {{name}}.", { name: identifierName });
}

function getPropertyName(memberExpressionNode) {
    if (memberExpressionNode.computed) {
        if (memberExpressionNode.property.type === "Literal") {
            return memberExpressionNode.property.value;
        }
    } else {
        return memberExpressionNode.property.name;
    }
    return null;
}

function findReference(scope, node) {
    var references = scope.references.filter(function(reference) {
        return reference.identifier.range[0] === node.range[0] &&
            reference.identifier.range[1] === node.range[1];
    });

    if (references.length === 1) {
        return references[0];
    }
    return null;
}

function isShadowed(scope, globalScope, node) {
    var reference = findReference(scope, node);
    return reference && reference.resolved && reference.resolved.defs.length > 0;
}

function isGlobalThisReferenceOrGlobalWindow(scope, globalScope, node) {
    if (scope.type === "global" && node.type === "ThisExpression") {
        return true;
    } else if (node.name === "window") {
        return !isShadowed(scope, globalScope, node);
    }

    return false;
}

module.exports = function(context) {
    var globalScope;

    return {

        "Program": function() {
            globalScope = context.getScope();
        },

        "CallExpression": function(node) {
            var callee = node.callee,
                identifierName,
                currentScope = context.getScope();

            if (callee.type === "Identifier") {
                identifierName = callee.name;

                if (!isShadowed(currentScope, globalScope, callee) && isProhibitedIdentifier(callee.name)) {
                    report(context, node, identifierName);
                }

            } else if (callee.type === "MemberExpression" && isGlobalThisReferenceOrGlobalWindow(currentScope, globalScope, callee.object)) {
                identifierName = getPropertyName(callee);

                if (isProhibitedIdentifier(identifierName)) {
                    report(context, node, identifierName);
                }
            }

        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-array-constructor.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function check(node) {
        if (
            node.arguments.length !== 1 &&
            node.callee.type === "Identifier" &&
            node.callee.name === "Array"
        ) {
            context.report(node, "The array literal notation [] is preferrable.");
        }
    }

    return {
        "CallExpression": check,
        "NewExpression": check
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-bitwise.js": [function(require,module,exports){
"use strict";

var BITWISE_OPERATORS = [
    "^", "|", "&", "<<", ">>", ">>>",
    "^=", "|=", "&=", "<<=", ">>=", ">>>=",
    "~"
];

module.exports = function(context) {
    var options = context.options[0] || {};
    var allowed = options.allow || [];
    var int32Hint = options.int32Hint === true;

    function report(node) {
        context.report(node, "Unexpected use of '{{operator}}'.", { operator: node.operator });
    }

    function hasBitwiseOperator(node) {
        return BITWISE_OPERATORS.indexOf(node.operator) !== -1;
    }

    function allowedOperator(node) {
        return allowed.indexOf(node.operator) !== -1;
    }

    function isInt32Hint(node) {
        return int32Hint && node.operator === "|" && node.right &&
          node.right.type === "Literal" && node.right.value === 0;
    }

    function checkNodeForBitwiseOperator(node) {
        if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {
            report(node);
        }
    }

    return {
        "AssignmentExpression": checkNodeForBitwiseOperator,
        "BinaryExpression": checkNodeForBitwiseOperator,
        "UnaryExpression": checkNodeForBitwiseOperator
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allow": {
                "type": "array",
                "items": {
                    "enum": BITWISE_OPERATORS
                },
                "uniqueItems": true
            },
            "int32Hint": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-caller.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "MemberExpression": function(node) {
            var objectName = node.object.name,
                propertyName = node.property.name;

            if (objectName === "arguments" && !node.computed && propertyName && propertyName.match(/^calle[er]$/)) {
                context.report(node, "Avoid arguments.{{property}}.", { property: propertyName });
            }

        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-case-declarations.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isLexicalDeclaration(node) {
        switch (node.type) {
            case "FunctionDeclaration":
            case "ClassDeclaration":
                return true;
            case "VariableDeclaration":
                return node.kind !== "var";
            default:
                return false;
        }
    }

    return {
        "SwitchCase": function(node) {
            for (var i = 0; i < node.consequent.length; i++) {
                var statement = node.consequent[i];
                if (isLexicalDeclaration(statement)) {
                    context.report({
                        node: node,
                        message: "Unexpected lexical declaration in case block."
                    });
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-catch-shadow.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    function paramIsShadowing(scope, name) {
        return astUtils.getVariableByName(scope, name) !== null;
    }

    return {

        "CatchClause": function(node) {
            var scope = context.getScope();

            if (scope.block === node) {
                scope = scope.upper;
            }

            if (paramIsShadowing(scope, node.param.name)) {
                context.report(node, "Value of '{{name}}' may be overwritten in IE 8 and earlier.",
                        { name: node.param.name });
            }
        }
    };

};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-class-assign.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    function checkVariable(variable) {
        astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
            context.report(
                reference.identifier,
                "'{{name}}' is a class.",
                {name: reference.identifier.name});

        });
    }

    function checkForClass(node) {
        context.getDeclaredVariables(node).forEach(checkVariable);
    }

    return {
        "ClassDeclaration": checkForClass,
        "ClassExpression": checkForClass
    };

};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-cond-assign.js": [function(require,module,exports){
"use strict";

var NODE_DESCRIPTIONS = {
    "DoWhileStatement": "a 'do...while' statement",
    "ForStatement": "a 'for' statement",
    "IfStatement": "an 'if' statement",
    "WhileStatement": "a 'while' statement"
};

module.exports = function(context) {

    var prohibitAssign = (context.options[0] || "except-parens");

    function isConditionalTestExpression(node) {
        return node.parent &&
            node.parent.test &&
            node === node.parent.test;
    }

    function findConditionalAncestor(node) {
        var currentAncestor = node;

        do {
            if (isConditionalTestExpression(currentAncestor)) {
                return currentAncestor.parent;
            }
        } while ((currentAncestor = currentAncestor.parent));

        return null;
    }

    function isParenthesised(node) {
        var previousToken = context.getTokenBefore(node),
            nextToken = context.getTokenAfter(node);

        return previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }

    function isParenthesisedTwice(node) {
        var previousToken = context.getTokenBefore(node, 1),
            nextToken = context.getTokenAfter(node, 1);

        return isParenthesised(node) &&
            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }

    function testForAssign(node) {
        if (node.test &&
            (node.test.type === "AssignmentExpression") &&
            (node.type === "ForStatement" ?
                !isParenthesised(node.test) :
                !isParenthesisedTwice(node.test)
            )
        ) {
            context.report({
                node: node,
                loc: node.test.loc.start,
                message: "Expected a conditional expression and instead saw an assignment."
            });
        }
    }

    function testForConditionalAncestor(node) {
        var ancestor = findConditionalAncestor(node);

        if (ancestor) {
            context.report(ancestor, "Unexpected assignment within {{type}}.", {
                type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
            });
        }
    }

    if (prohibitAssign === "always") {
        return {
            "AssignmentExpression": testForConditionalAncestor
        };
    }

    return {
        "DoWhileStatement": testForAssign,
        "ForStatement": testForAssign,
        "IfStatement": testForAssign,
        "WhileStatement": testForAssign
    };

};

module.exports.schema = [
    {
        "enum": ["except-parens", "always"]
    }
];

},
   {}],

"/tmp/rules/no-confusing-arrow.js": [function(require,module,exports){
"use strict";

function isConditional(node) {
    return node.body && node.body.type === "ConditionalExpression";
}

module.exports = function(context) {
    function checkArrowFunc(node) {
        if (isConditional(node)) {
            context.report(node, "Arrow function used ambiguously with a conditional expression.");
        }
    }

    return {
        "ArrowFunctionExpression": checkArrowFunc
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-console.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "MemberExpression": function(node) {

            if (node.object.name === "console") {
                var blockConsole = true;

                if ( context.options.length > 0 ) {
                    var allowedProperties = context.options[0].allow;
                    var passedProperty = node.property.name;
                    var propertyIsAllowed = (allowedProperties.indexOf(passedProperty) > -1);

                    if (propertyIsAllowed) {
                        blockConsole = false;
                    }
                }

                if (blockConsole) {
                    context.report(node, "Unexpected console statement.");
                }
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allow": {
                "type": "array",
                "items": {
                    "type": "string"
                },
                "minItems": 1,
                "uniqueItems": true
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-const-assign.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    function checkVariable(variable) {
        astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
            context.report(
                reference.identifier,
                "'{{name}}' is constant.",
                {name: reference.identifier.name});
        });
    }

    return {
        "VariableDeclaration": function(node) {
            if (node.kind === "const") {
                context.getDeclaredVariables(node).forEach(checkVariable);
            }
        }
    };

};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-constant-condition.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isConstant(node) {
        switch (node.type) {
            case "Literal":
            case "ArrowFunctionExpression":
            case "FunctionExpression":
            case "ObjectExpression":
            case "ArrayExpression":
                return true;
            case "UnaryExpression":
                return isConstant(node.argument);
            case "BinaryExpression":
            case "LogicalExpression":
                return isConstant(node.left) && isConstant(node.right) && node.operator !== "in";
            case "AssignmentExpression":
                return (node.operator === "=") && isConstant(node.right);
            case "SequenceExpression":
                return isConstant(node.expressions[node.expressions.length - 1]);
        }
        return false;
    }

    function checkConstantCondition(node) {
        if (node.test && isConstant(node.test)) {
            context.report(node, "Unexpected constant condition.");
        }
    }

    return {
        "ConditionalExpression": checkConstantCondition,
        "IfStatement": checkConstantCondition,
        "WhileStatement": checkConstantCondition,
        "DoWhileStatement": checkConstantCondition,
        "ForStatement": checkConstantCondition
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-continue.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "ContinueStatement": function(node) {
            context.report(node, "Unexpected use of continue statement");
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-control-regex.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function getRegExp(node) {
        if (node.value instanceof RegExp) {
            return node.value;
        } else if (typeof node.value === "string") {

            var parent = context.getAncestors().pop();
            if ((parent.type === "NewExpression" || parent.type === "CallExpression") &&
                parent.callee.type === "Identifier" && parent.callee.name === "RegExp"
            ) {
                try {
                    return new RegExp(node.value);
                } catch (ex) {
                    return null;
                }
            }
        }

        return null;
    }

    return {
        "Literal": function(node) {
            var computedValue,
                regex = getRegExp(node);

            if (regex) {
                computedValue = regex.toString();
                if (/[\x00-\x1f]/.test(computedValue)) {
                    context.report(node, "Unexpected control character in regular expression.");
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-debugger.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "DebuggerStatement": function(node) {
            context.report(node, "Unexpected 'debugger' statement.");
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-delete-var.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "UnaryExpression": function(node) {
            if (node.operator === "delete" && node.argument.type === "Identifier") {
                context.report(node, "Variables should not be deleted.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-div-regex.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Literal": function(node) {
            var token = context.getFirstToken(node);

            if (token.type === "RegularExpression" && token.value[1] === "=") {
                context.report(node, "A regular expression literal can be confused with '/='.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-dupe-args.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isParameter(def) {
        return def.type === "Parameter";
    }

    function checkParams(node) {
        var variables = context.getDeclaredVariables(node);
        var keyMap = Object.create(null);

        for (var i = 0; i < variables.length; ++i) {
            var variable = variables[i];

            var key = "$" + variable.name; // to avoid __proto__.
            if (!isParameter(variable.defs[0]) || keyMap[key]) {
                continue;
            }
            keyMap[key] = true;

            var defs = variable.defs.filter(isParameter);
            if (defs.length >= 2) {
                context.report({
                    node: node,
                    message: "Duplicate param '{{name}}'.",
                    data: {name: variable.name}
                });
            }
        }
    }

    return {
        "FunctionDeclaration": checkParams,
        "FunctionExpression": checkParams
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-dupe-class-members.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var stack = [];

    function getState(name, isStatic) {
        var stateMap = stack[stack.length - 1];
        var key = "$" + name; // to avoid "__proto__".

        if (!stateMap[key]) {
            stateMap[key] = {
                nonStatic: {init: false, get: false, set: false},
                static: {init: false, get: false, set: false}
            };
        }

        return stateMap[key][isStatic ? "static" : "nonStatic"];
    }

    function getName(node) {
        switch (node.type) {
            case "Identifier": return node.name;
            case "Literal": return String(node.value);

            default: return "";
        }
    }

    return {
        "Program": function() {
            stack = [];
        },

        "ClassBody": function() {
            stack.push(Object.create(null));
        },

        "ClassBody:exit": function() {
            stack.pop();
        },

        "MethodDefinition": function(node) {
            if (node.computed) {
                return;
            }

            var name = getName(node.key);
            var state = getState(name, node.static);
            var isDuplicate = false;
            if (node.kind === "get") {
                isDuplicate = (state.init || state.get);
                state.get = true;
            } else if (node.kind === "set") {
                isDuplicate = (state.init || state.set);
                state.set = true;
            } else {
                isDuplicate = (state.init || state.get || state.set);
                state.init = true;
            }

            if (isDuplicate) {
                context.report(node, "Duplicate name '{{name}}'.", {name: name});
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-dupe-keys.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "ObjectExpression": function(node) {

            var nodeProps = Object.create(null);

            node.properties.forEach(function(property) {

                if (property.type !== "Property") {
                    return;
                }

                var keyName = property.key.name || property.key.value,
                    key = property.kind + "-" + keyName,
                    checkProperty = (!property.computed || property.key.type === "Literal");

                if (checkProperty) {
                    if (nodeProps[key]) {
                        context.report(node, property.loc.start, "Duplicate key '{{key}}'.", { key: keyName });
                    } else {
                        nodeProps[key] = true;
                    }
                }
            });

        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-duplicate-case.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "SwitchStatement": function(node) {
            var mapping = {};

            node.cases.forEach(function(switchCase) {
                var key = context.getSource(switchCase.test);
                if (mapping[key]) {
                    context.report(switchCase, "Duplicate case label.");
                } else {
                    mapping[key] = switchCase;
                }
            });
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-else-return.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function displayReport(node) {
        context.report(node, "Unexpected 'else' after 'return'.");
    }

    function checkForReturn(node) {
        return node.type === "ReturnStatement";
    }

    function naiveHasReturn(node) {
        if (node.type === "BlockStatement") {
            var body = node.body,
                lastChildNode = body[body.length - 1];

            return lastChildNode && checkForReturn(lastChildNode);
        }
        return checkForReturn(node);
    }

    function hasElse(node) {
        return node.alternate && node.consequent && node.alternate.type !== "IfStatement";
    }

    function checkForIf(node) {
        return node.type === "IfStatement" && hasElse(node) &&
            naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
    }

    function checkForReturnOrIf(node) {
        return checkForReturn(node) || checkForIf(node);
    }


    function alwaysReturns(node) {
        if (node.type === "BlockStatement") {
            return node.body.some(checkForReturnOrIf);
        } else {
            return checkForReturnOrIf(node);
        }
    }

    return {

        "IfStatement": function(node) {
            var parent = context.getAncestors().pop(),
                consequents,
                alternate;

            if (parent.type === "IfStatement" && parent.alternate === node) {
                return;
            }

            for (consequents = []; node.type === "IfStatement"; node = node.alternate) {
                if (!node.alternate) {
                    return;
                }
                consequents.push(node.consequent);
                alternate = node.alternate;
            }

            if (consequents.every(alwaysReturns)) {
                displayReport(alternate);
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-empty-character-class.js": [function(require,module,exports){
"use strict";

var regex = /^\/([^\\[]|\\.|\[([^\\\]]|\\.)+\])*\/[gimuy]*$/;

module.exports = function(context) {

    return {

        "Literal": function(node) {
            var token = context.getFirstToken(node);
            if (token.type === "RegularExpression" && !regex.test(token.value)) {
                context.report(node, "Empty class.");
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-empty-function.js": [function(require,module,exports){
"use strict";

var ALLOW_OPTIONS = Object.freeze([
    "functions",
    "arrowFunctions",
    "generatorFunctions",
    "methods",
    "generatorMethods",
    "getters",
    "setters",
    "constructors"
]);
var SHOW_KIND = Object.freeze({
    functions: "function",
    arrowFunctions: "arrow function",
    generatorFunctions: "generator function",
    asyncFunctions: "async function",
    methods: "method",
    generatorMethods: "generator method",
    asyncMethods: "async method",
    getters: "getter",
    setters: "setter",
    constructors: "constructor"
});

function getKind(node) {
    var parent = node.parent;
    var kind = "";

    if (node.type === "ArrowFunctionExpression") {
        return "arrowFunctions";
    }

    if (parent.type === "Property") {
        if (parent.kind === "get") {
            return "getters";
        }
        if (parent.kind === "set") {
            return "setters";
        }
        kind = parent.method ? "methods" : "functions";

    } else if (parent.type === "MethodDefinition") {
        if (parent.kind === "get") {
            return "getters";
        }
        if (parent.kind === "set") {
            return "setters";
        }
        if (parent.kind === "constructor") {
            return "constructors";
        }
        kind = "methods";

    } else {
        kind = "functions";
    }

    var prefix = "";
    if (node.generator) {
        prefix = "generator";
    } else if (node.async) {
        prefix = "async";
    } else {
        return kind;
    }
    return prefix + kind[0].toUpperCase() + kind.slice(1);
}

module.exports = function(context) {
    var options = context.options[0] || {};
    var allowed = options.allow || [];

    function reportIfEmpty(node) {
        var kind = getKind(node);

        if (allowed.indexOf(kind) === -1 &&
            node.body.type === "BlockStatement" &&
            node.body.body.length === 0 &&
            context.getComments(node.body).trailing.length === 0
        ) {
            context.report({
                node: node,
                loc: node.body.loc.start,
                message: "Unexpected empty " + SHOW_KIND[kind] + "."
            });
        }
    }

    return {
        ArrowFunctionExpression: reportIfEmpty,
        FunctionDeclaration: reportIfEmpty,
        FunctionExpression: reportIfEmpty
    };
};

module.exports.schema = [
    {
        type: "object",
        properties: {
            allow: {
                type: "array",
                items: {enum: ALLOW_OPTIONS},
                uniqueItems: true
            }
        },
        additionalProperties: false
    }
];

},
   {}],

"/tmp/rules/no-empty-pattern.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    return {
        "ObjectPattern": function(node) {
            if (node.properties.length === 0) {
                context.report(node, "Unexpected empty object pattern.");
            }
        },
        "ArrayPattern": function(node) {
            if (node.elements.length === 0) {
                context.report(node, "Unexpected empty array pattern.");
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-empty.js": [function(require,module,exports){
"use strict";

var FUNCTION_TYPE = /^(?:ArrowFunctionExpression|Function(?:Declaration|Expression))$/;

module.exports = function(context) {
    return {
        "BlockStatement": function(node) {
            if (node.body.length !== 0) {
                return;
            }

            if (FUNCTION_TYPE.test(node.parent.type)) {
                return;
            }

            if (context.getComments(node).trailing.length > 0) {
                return;
            }

            context.report(node, "Empty block statement.");
        },

        "SwitchStatement": function(node) {

            if (typeof node.cases === "undefined" || node.cases.length === 0) {
                context.report(node, "Empty switch statement.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-eq-null.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "BinaryExpression": function(node) {
            var badOperator = node.operator === "==" || node.operator === "!=";

            if (node.right.type === "Literal" && node.right.raw === "null" && badOperator ||
                    node.left.type === "Literal" && node.left.raw === "null" && badOperator) {
                context.report(node, "Use ‘===’ to compare with ‘null’.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-eval.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

var candidatesOfGlobalObject = Object.freeze([
    "global",
    "window"
]);

function isIdentifier(node, name) {
    return node.type === "Identifier" && node.name === name;
}

function isConstant(node, name) {
    switch (node.type) {
        case "Literal":
            return node.value === name;

        case "TemplateLiteral":
            return (
                node.expressions.length === 0 &&
                node.quasis[0].value.cooked === name
            );

        default:
            return false;
    }
}

function isMember(node, name) {
    return (
        node.type === "MemberExpression" &&
        (node.computed ? isConstant : isIdentifier)(node.property, name)
    );
}

module.exports = function(context) {
    var allowIndirect = Boolean(
        context.options[0] &&
        context.options[0].allowIndirect
    );
    var sourceCode = context.getSourceCode();
    var funcInfo = null;

    function enterVarScope(node) {
        var strict = context.getScope().isStrict;

        funcInfo = {
            upper: funcInfo,
            node: node,
            strict: strict,
            defaultThis: false,
            initialized: strict
        };
    }

    function exitVarScope() {
        funcInfo = funcInfo.upper;
    }

    function report(node) {
        var locationNode = node;
        var parent = node.parent;

        if (node.type === "MemberExpression") {
            locationNode = node.property;
        }
        if (parent.type === "CallExpression" && parent.callee === node) {
            node = parent;
        }

        context.report({
            node: node,
            loc: locationNode.loc.start,
            message: "eval can be harmful."
        });
    }

    function reportAccessingEvalViaGlobalObject(globalScope) {
        for (var i = 0; i < candidatesOfGlobalObject.length; ++i) {
            var name = candidatesOfGlobalObject[i];
            var variable = astUtils.getVariableByName(globalScope, name);
            if (!variable) {
                continue;
            }

            var references = variable.references;
            for (var j = 0; j < references.length; ++j) {
                var identifier = references[j].identifier;
                var node = identifier.parent;

                while (isMember(node, name)) {
                    node = node.parent;
                }

                if (isMember(node, "eval")) {
                    report(node);
                }
            }
        }
    }

    function reportAccessingEval(globalScope) {
        var variable = astUtils.getVariableByName(globalScope, "eval");
        if (!variable) {
            return;
        }

        var references = variable.references;
        for (var i = 0; i < references.length; ++i) {
            var reference = references[i];
            var id = reference.identifier;

            if (id.name === "eval" && !astUtils.isCallee(id)) {
                report(id);
            }
        }
    }

    if (allowIndirect) {
        return {
            "CallExpression:exit": function(node) {
                var callee = node.callee;
                if (isIdentifier(callee, "eval")) {
                    report(callee);
                }
            }
        };
    }

    return {
        "CallExpression:exit": function(node) {
            var callee = node.callee;
            if (isIdentifier(callee, "eval")) {
                report(callee);
            }
        },

        "Program": function(node) {
            var scope = context.getScope(),
                features = context.parserOptions.ecmaFeatures || {},
                strict =
                    scope.isStrict ||
                    node.sourceType === "module" ||
                    (features.globalReturn && scope.childScopes[0].isStrict);

            funcInfo = {
                upper: null,
                node: node,
                strict: strict,
                defaultThis: true,
                initialized: true
            };
        },

        "Program:exit": function() {
            var globalScope = context.getScope();

            exitVarScope();
            reportAccessingEval(globalScope);
            reportAccessingEvalViaGlobalObject(globalScope);
        },

        "FunctionDeclaration": enterVarScope,
        "FunctionDeclaration:exit": exitVarScope,
        "FunctionExpression": enterVarScope,
        "FunctionExpression:exit": exitVarScope,
        "ArrowFunctionExpression": enterVarScope,
        "ArrowFunctionExpression:exit": exitVarScope,

        "ThisExpression": function(node) {
            if (!isMember(node.parent, "eval")) {
                return;
            }

            if (!funcInfo.initialized) {
                funcInfo.initialized = true;
                funcInfo.defaultThis = astUtils.isDefaultThisBinding(
                    funcInfo.node,
                    sourceCode
                );
            }
            if (!funcInfo.strict && funcInfo.defaultThis) {
                report(node.parent);
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allowIndirect": {"type": "boolean"}
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-ex-assign.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    function checkVariable(variable) {
        astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
            context.report(
                reference.identifier,
                "Do not assign to the exception parameter.");
        });
    }

    return {
        "CatchClause": function(node) {
            context.getDeclaredVariables(node).forEach(checkVariable);
        }
    };

};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-extend-native.js": [function(require,module,exports){
"use strict";

var globals = require("globals");

module.exports = function(context) {

    var config = context.options[0] || {};
    var exceptions = config.exceptions || [];
    var modifiedBuiltins = Object.keys(globals.builtin).filter(function(builtin) {
        return builtin[0].toUpperCase() === builtin[0];
    });

    if (exceptions.length) {
        modifiedBuiltins = modifiedBuiltins.filter(function(builtIn) {
            return exceptions.indexOf(builtIn) === -1;
        });
    }

    return {

        "AssignmentExpression": function(node) {
            var lhs = node.left, affectsProto;

            if (lhs.type !== "MemberExpression" || lhs.object.type !== "MemberExpression") {
                return;
            }

            affectsProto = lhs.object.computed ?
                lhs.object.property.type === "Literal" && lhs.object.property.value === "prototype" :
                lhs.object.property.name === "prototype";

            if (!affectsProto) {
                return;
            }

            modifiedBuiltins.forEach(function(builtin) {
                if (lhs.object.object.name === builtin) {
                    context.report(node, builtin + " prototype is read only, properties should not be added.");
                }
            });
        },

        "CallExpression": function(node) {

            var callee = node.callee,
                subject,
                object;

            if (callee.type === "MemberExpression" &&
                callee.object.name === "Object" &&
                (callee.property.name === "defineProperty" || callee.property.name === "defineProperties")) {

                subject = node.arguments[0];
                object = subject && subject.object;
                if (object &&
                    object.type === "Identifier" &&
                    (modifiedBuiltins.indexOf(object.name) > -1) &&
                    subject.property.name === "prototype") {

                    context.report(node, object.name + " prototype is read only, properties should not be added.");
                }
            }

        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "array",
                "items": {
                    "type": "string"
                },
                "uniqueItems": true
            }
        },
        "additionalProperties": false
    }
];

},
   {"globals":"/node_modules/globals/index.js"}],

"/tmp/rules/no-extra-bind.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var scopeInfo = null;

    function report(node) {
        context.report({
            node: node.parent.parent,
            message: "The function binding is unnecessary.",
            loc: node.parent.property.loc.start
        });
    }

    function getPropertyName(node) {
        if (node.computed) {
            switch (node.property.type) {
                case "Literal":
                    return String(node.property.value);
                case "TemplateLiteral":
                    if (node.property.expressions.length === 0) {
                        return node.property.quasis[0].value.cooked;
                    }
                default:
                    return false;
            }
        }
        return node.property.name;
    }

    function isCalleeOfBindMethod(node) {
        var parent = node.parent;
        var grandparent = parent.parent;
        return (
            grandparent &&
            grandparent.type === "CallExpression" &&
            grandparent.callee === parent &&
            grandparent.arguments.length === 1 &&
            parent.type === "MemberExpression" &&
            parent.object === node &&
            getPropertyName(parent) === "bind"
        );
    }

    function enterFunction(node) {
        scopeInfo = {
            isBound: isCalleeOfBindMethod(node),
            thisFound: false,
            upper: scopeInfo
        };
    }

    function exitFunction(node) {
        if (scopeInfo.isBound && !scopeInfo.thisFound) {
            report(node);
        }

        scopeInfo = scopeInfo.upper;
    }

    function exitArrowFunction(node) {
        if (isCalleeOfBindMethod(node)) {
            report(node);
        }
    }

    function markAsThisFound() {
        if (scopeInfo) {
            scopeInfo.thisFound = true;
        }
    }

    return {
        "ArrowFunctionExpression:exit": exitArrowFunction,
        "FunctionDeclaration": enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        "FunctionExpression": enterFunction,
        "FunctionExpression:exit": exitFunction,
        "ThisExpression": markAsThisFound
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-extra-boolean-cast.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var BOOLEAN_NODE_TYPES = [
        "IfStatement",
        "DoWhileStatement",
        "WhileStatement",
        "ConditionalExpression",
        "ForStatement"
    ];

    function isInBooleanContext(node, parent) {
        return (
            (BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 &&
                node === parent.test) ||
            (parent.type === "UnaryExpression" &&
                parent.operator === "!")
        );
    }


    return {
        "UnaryExpression": function(node) {
            var ancestors = context.getAncestors(),
                parent = ancestors.pop(),
                grandparent = ancestors.pop();

            if (node.operator !== "!" ||
                    parent.type !== "UnaryExpression" ||
                    parent.operator !== "!") {
                return;
            }

            if (isInBooleanContext(parent, grandparent) ||
                ((grandparent.type === "CallExpression" || grandparent.type === "NewExpression") &&
                    grandparent.callee.type === "Identifier" &&
                    grandparent.callee.name === "Boolean")
            ) {
                context.report(node, "Redundant double negation.");
            }
        },
        "CallExpression": function(node) {
            var parent = node.parent;

            if (node.callee.type !== "Identifier" || node.callee.name !== "Boolean") {
                return;
            }

            if (isInBooleanContext(node, parent)) {
                context.report(node, "Redundant Boolean call.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-extra-label.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    var scopeInfo = null;

    function enterBreakableStatement(node) {
        scopeInfo = {
            label: astUtils.getLabel(node),
            breakable: true,
            upper: scopeInfo
        };
    }

    function exitBreakableStatement() {
        scopeInfo = scopeInfo.upper;
    }

    function enterLabeledStatement(node) {
        if (!astUtils.isBreakableStatement(node.body)) {
            scopeInfo = {
                label: node.label.name,
                breakable: false,
                upper: scopeInfo
            };
        }
    }

    function exitLabeledStatement(node) {
        if (!astUtils.isBreakableStatement(node.body)) {
            scopeInfo = scopeInfo.upper;
        }
    }

    function reportIfUnnecessary(node) {
        if (!node.label) {
            return;
        }

        var labelNode = node.label;
        var label = labelNode.name;
        var info = scopeInfo;

        while (info) {
            if (info.breakable || info.label === label) {
                if (info.breakable && info.label === label) {
                    context.report({
                        node: labelNode,
                        message: "This label '{{name}}' is unnecessary.",
                        data: labelNode
                    });
                }
                return;
            }

            info = info.upper;
        }
    }

    return {
        "WhileStatement": enterBreakableStatement,
        "WhileStatement:exit": exitBreakableStatement,
        "DoWhileStatement": enterBreakableStatement,
        "DoWhileStatement:exit": exitBreakableStatement,
        "ForStatement": enterBreakableStatement,
        "ForStatement:exit": exitBreakableStatement,
        "ForInStatement": enterBreakableStatement,
        "ForInStatement:exit": exitBreakableStatement,
        "ForOfStatement": enterBreakableStatement,
        "ForOfStatement:exit": exitBreakableStatement,
        "SwitchStatement": enterBreakableStatement,
        "SwitchStatement:exit": exitBreakableStatement,
        "LabeledStatement": enterLabeledStatement,
        "LabeledStatement:exit": exitLabeledStatement,
        "BreakStatement": reportIfUnnecessary,
        "ContinueStatement": reportIfUnnecessary
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-extra-parens.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var ALL_NODES = context.options[0] !== "functions";
    var EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;
    var sourceCode = context.getSourceCode();

    function ruleApplies(node) {
        return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
    }

    function isParenthesised(node) {
        var previousToken = context.getTokenBefore(node),
            nextToken = context.getTokenAfter(node);

        return previousToken && nextToken &&
            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }

    function isParenthesisedTwice(node) {
        var previousToken = context.getTokenBefore(node, 1),
            nextToken = context.getTokenAfter(node, 1);

        return isParenthesised(node) && previousToken && nextToken &&
            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }

    function hasExcessParens(node) {
        return ruleApplies(node) && isParenthesised(node);
    }

    function hasDoubleExcessParens(node) {
        return ruleApplies(node) && isParenthesisedTwice(node);
    }

    function isCondAssignException(node) {
        return EXCEPT_COND_ASSIGN && node.test.type === "AssignmentExpression";
    }

    function hasExcessParensNoLineTerminator(token, node) {
        if (token.loc.end.line === node.loc.start.line) {
            return hasExcessParens(node);
        }

        return hasDoubleExcessParens(node);
    }

    function isHeadOfExpressionStatement(node) {
        var parent = node.parent;
        while (parent) {
            switch (parent.type) {
                case "SequenceExpression":
                    if (parent.expressions[0] !== node || isParenthesised(node)) {
                        return false;
                    }
                    break;

                case "UnaryExpression":
                case "UpdateExpression":
                    if (parent.prefix || isParenthesised(node)) {
                        return false;
                    }
                    break;

                case "BinaryExpression":
                case "LogicalExpression":
                    if (parent.left !== node || isParenthesised(node)) {
                        return false;
                    }
                    break;

                case "ConditionalExpression":
                    if (parent.test !== node || isParenthesised(node)) {
                        return false;
                    }
                    break;

                case "CallExpression":
                    if (parent.callee !== node || isParenthesised(node)) {
                        return false;
                    }
                    break;

                case "MemberExpression":
                    if (parent.object !== node || isParenthesised(node)) {
                        return false;
                    }
                    break;

                case "ExpressionStatement":
                    return true;

                default:
                    return false;
            }

            node = parent;
            parent = parent.parent;
        }

        throw new Error("unreachable");
    }

    function precedence(node) {

        switch (node.type) {
            case "SequenceExpression":
                return 0;

            case "AssignmentExpression":
            case "ArrowFunctionExpression":
            case "YieldExpression":
                return 1;

            case "ConditionalExpression":
                return 3;

            case "LogicalExpression":
                switch (node.operator) {
                    case "||":
                        return 4;
                    case "&&":
                        return 5;
                }

            case "BinaryExpression":
                switch (node.operator) {
                    case "|":
                        return 6;
                    case "^":
                        return 7;
                    case "&":
                        return 8;
                    case "==":
                    case "!=":
                    case "===":
                    case "!==":
                        return 9;
                    case "<":
                    case "<=":
                    case ">":
                    case ">=":
                    case "in":
                    case "instanceof":
                        return 10;
                    case "<<":
                    case ">>":
                    case ">>>":
                        return 11;
                    case "+":
                    case "-":
                        return 12;
                    case "*":
                    case "/":
                    case "%":
                        return 13;
                }
            case "UnaryExpression":
                return 14;
            case "UpdateExpression":
                return 15;
            case "CallExpression":
                if (node.callee.type === "FunctionExpression") {
                    return -1;
                }
                return 16;
            case "NewExpression":
                return 17;
        }
        return 18;
    }

    function report(node) {
        var previousToken = context.getTokenBefore(node);
        context.report(node, previousToken.loc.start, "Gratuitous parentheses around expression.");
    }

    function dryUnaryUpdate(node) {
        if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {
            report(node.argument);
        }
    }

    function dryCallNew(node) {
        if (hasExcessParens(node.callee) && precedence(node.callee) >= precedence(node) && !(
            node.type === "CallExpression" &&
            node.callee.type === "FunctionExpression" &&
            !hasDoubleExcessParens(node.callee)
        )) {
            report(node.callee);
        }
        if (node.arguments.length === 1) {
            if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= precedence({type: "AssignmentExpression"})) {
                report(node.arguments[0]);
            }
        } else {
            [].forEach.call(node.arguments, function(arg) {
                if (hasExcessParens(arg) && precedence(arg) >= precedence({type: "AssignmentExpression"})) {
                    report(arg);
                }
            });
        }
    }

    function dryBinaryLogical(node) {
        var prec = precedence(node);
        if (hasExcessParens(node.left) && precedence(node.left) >= prec) {
            report(node.left);
        }
        if (hasExcessParens(node.right) && precedence(node.right) > prec) {
            report(node.right);
        }
    }

    return {
        "ArrayExpression": function(node) {
            [].forEach.call(node.elements, function(e) {
                if (e && hasExcessParens(e) && precedence(e) >= precedence({type: "AssignmentExpression"})) {
                    report(e);
                }
            });
        },
        "ArrowFunctionExpression": function(node) {
            if (node.body.type !== "BlockStatement") {
                if (node.body.type !== "ObjectExpression" && hasExcessParens(node.body) && precedence(node.body) >= precedence({type: "AssignmentExpression"})) {
                    report(node.body);
                    return;
                }

                if (node.body.type === "ObjectExpression" && hasDoubleExcessParens(node.body)) {
                    report(node.body);
                    return;
                }
            }
        },
        "AssignmentExpression": function(node) {
            if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {
                report(node.right);
            }
        },
        "BinaryExpression": dryBinaryLogical,
        "CallExpression": dryCallNew,
        "ConditionalExpression": function(node) {
            if (hasExcessParens(node.test) && precedence(node.test) >= precedence({type: "LogicalExpression", operator: "||"})) {
                report(node.test);
            }
            if (hasExcessParens(node.consequent) && precedence(node.consequent) >= precedence({type: "AssignmentExpression"})) {
                report(node.consequent);
            }
            if (hasExcessParens(node.alternate) && precedence(node.alternate) >= precedence({type: "AssignmentExpression"})) {
                report(node.alternate);
            }
        },
        "DoWhileStatement": function(node) {
            if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
                report(node.test);
            }
        },
        "ExpressionStatement": function(node) {
            var firstToken, secondToken, firstTokens;
            if (hasExcessParens(node.expression)) {
                firstTokens = context.getFirstTokens(node.expression, 2);
                firstToken = firstTokens[0];
                secondToken = firstTokens[1];

                if (
                    !firstToken ||
                    firstToken.value !== "{" &&
                    firstToken.value !== "function" &&
                    firstToken.value !== "class" &&
                    (
                        firstToken.value !== "let" ||
                        !secondToken ||
                        secondToken.value !== "["
                    )
                ) {
                    report(node.expression);
                }
            }
        },
        "ForInStatement": function(node) {
            if (hasExcessParens(node.right)) {
                report(node.right);
            }
        },
        "ForOfStatement": function(node) {
            if (hasExcessParens(node.right)) {
                report(node.right);
            }
        },
        "ForStatement": function(node) {
            if (node.init && hasExcessParens(node.init)) {
                report(node.init);
            }

            if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {
                report(node.test);
            }

            if (node.update && hasExcessParens(node.update)) {
                report(node.update);
            }
        },
        "IfStatement": function(node) {
            if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
                report(node.test);
            }
        },
        "LogicalExpression": dryBinaryLogical,
        "MemberExpression": function(node) {
            if (
                hasExcessParens(node.object) &&
                precedence(node.object) >= precedence(node) &&
                (
                    node.computed ||
                    !(
                        (node.object.type === "Literal" &&
                        typeof node.object.value === "number" &&
                        /^[0-9]+$/.test(context.getFirstToken(node.object).value))
                        ||
                        (node.object.type === "Literal" && node.object.regex)
                    )
                ) &&
                !(
                    (node.object.type === "FunctionExpression" || node.object.type === "ClassExpression") &&
                    isHeadOfExpressionStatement(node) &&
                    !hasDoubleExcessParens(node.object)
                )
            ) {
                report(node.object);
            }
            if (node.computed && hasExcessParens(node.property)) {
                report(node.property);
            }
        },
        "NewExpression": dryCallNew,
        "ObjectExpression": function(node) {
            [].forEach.call(node.properties, function(e) {
                var v = e.value;
                if (v && hasExcessParens(v) && precedence(v) >= precedence({type: "AssignmentExpression"})) {
                    report(v);
                }
            });
        },
        "ReturnStatement": function(node) {
            var returnToken = sourceCode.getFirstToken(node);

            if (node.argument &&
                    hasExcessParensNoLineTerminator(returnToken, node.argument) &&
                    !(node.argument.type === "Literal" && node.argument.regex)) {
                report(node.argument);
            }
        },
        "SequenceExpression": function(node) {
            [].forEach.call(node.expressions, function(e) {
                if (hasExcessParens(e) && precedence(e) >= precedence(node)) {
                    report(e);
                }
            });
        },
        "SwitchCase": function(node) {
            if (node.test && hasExcessParens(node.test)) {
                report(node.test);
            }
        },
        "SwitchStatement": function(node) {
            if (hasDoubleExcessParens(node.discriminant)) {
                report(node.discriminant);
            }
        },
        "ThrowStatement": function(node) {
            var throwToken = sourceCode.getFirstToken(node);

            if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {
                report(node.argument);
            }
        },
        "UnaryExpression": dryUnaryUpdate,
        "UpdateExpression": dryUnaryUpdate,
        "VariableDeclarator": function(node) {
            if (node.init && hasExcessParens(node.init) &&
                    precedence(node.init) >= precedence({type: "AssignmentExpression"}) &&
                    !(node.init.type === "Literal" && node.init.regex)) {
                report(node.init);
            }
        },
        "WhileStatement": function(node) {
            if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
                report(node.test);
            }
        },
        "WithStatement": function(node) {
            if (hasDoubleExcessParens(node.object)) {
                report(node.object);
            }
        },
        "YieldExpression": function(node) {
            var yieldToken;

            if (node.argument) {
                yieldToken = sourceCode.getFirstToken(node);

                if ((precedence(node.argument) >= precedence(node) &&
                        hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||
                        hasDoubleExcessParens(node.argument)) {
                    report(node.argument);
                }
            }
        }
    };

};

module.exports.schema = {
    "anyOf": [
        {
            "type": "array",
            "items": [
                {
                    "enum": ["functions"]
                }
            ],
            "minItems": 0,
            "maxItems": 1
        },
        {
            "type": "array",
            "items": [
                {
                    "enum": ["all"]
                },
                {
                    "type": "object",
                    "properties": {
                        "conditionalAssign": {"type": "boolean"}
                    },
                    "additionalProperties": false
                }
            ],
            "minItems": 0,
            "maxItems": 2
        }
    ]
};

},
   {}],

"/tmp/rules/no-extra-semi.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function report(nodeOrToken) {
        context.report({
            node: nodeOrToken,
            message: "Unnecessary semicolon.",
            fix: function(fixer) {
                return fixer.remove(nodeOrToken);
            }
        });
    }

    function checkForPartOfClassBody(firstToken) {
        for (var token = firstToken;
            token.type === "Punctuator" && token.value !== "}";
            token = context.getTokenAfter(token)
        ) {
            if (token.value === ";") {
                report(token);
            }
        }
    }

    return {
        "EmptyStatement": function(node) {
            var parent = node.parent,
                allowedParentTypes = ["ForStatement", "ForInStatement", "ForOfStatement", "WhileStatement", "DoWhileStatement"];

            if (allowedParentTypes.indexOf(parent.type) === -1) {
                report(node);
            }
        },

        "ClassBody": function(node) {
            checkForPartOfClassBody(context.getFirstToken(node, 1)); // 0 is `{`.
        },

        "MethodDefinition": function(node) {
            checkForPartOfClassBody(context.getTokenAfter(node));
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-fallthrough.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

var FALLTHROUGH_COMMENT = /falls?\s?through/i;

function hasFallthroughComment(node, context) {
    var sourceCode = context.getSourceCode();
    var comment = lodash.last(sourceCode.getComments(node).leading);

    return Boolean(comment && FALLTHROUGH_COMMENT.test(comment.value));
}

function isReachable(segment) {
    return segment.reachable;
}

module.exports = function(context) {
    var currentCodePath = null;

    var fallthroughCase = null;

    return {
        "onCodePathStart": function(codePath) {
            currentCodePath = codePath;
        },
        "onCodePathEnd": function() {
            currentCodePath = currentCodePath.upper;
        },

        "SwitchCase": function(node) {
            if (fallthroughCase && !hasFallthroughComment(node, context)) {
                context.report({
                    message: "Expected a 'break' statement before '{{type}}'.",
                    data: {type: node.test ? "case" : "default"},
                    node: node
                });
            }
            fallthroughCase = null;
        },

        "SwitchCase:exit": function(node) {
            if (currentCodePath.currentSegments.some(isReachable) &&
                node.consequent.length > 0 &&
                lodash.last(node.parent.cases) !== node
            ) {
                fallthroughCase = node;
            }
        }
    };
};

module.exports.schema = [];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/no-floating-decimal.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "Literal": function(node) {

            if (typeof node.value === "number") {
                if (node.raw.indexOf(".") === 0) {
                    context.report(node, "A leading decimal point can be confused with a dot.");
                }
                if (node.raw.indexOf(".") === node.raw.length - 1) {
                    context.report(node, "A trailing decimal point can be confused with a dot.");
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-func-assign.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    function checkReference(references) {
        astUtils.getModifyingReferences(references).forEach(function(reference) {
            context.report(
                reference.identifier,
                "'{{name}}' is a function.",
                {name: reference.identifier.name});
        });
    }

    function checkVariable(variable) {
        if (variable.defs[0].type === "FunctionName") {
            checkReference(variable.references);
        }
    }

    function checkForFunction(node) {
        context.getDeclaredVariables(node).forEach(checkVariable);
    }

    return {
        "FunctionDeclaration": checkForFunction,
        "FunctionExpression": checkForFunction
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-implicit-coercion.js": [function(require,module,exports){
"use strict";

var INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/;
var ALLOWABLE_OPERATORS = ["~", "!!", "+", "*"];

function parseOptions(options) {
    options = options || {};
    return {
        boolean: "boolean" in options ? Boolean(options.boolean) : true,
        number: "number" in options ? Boolean(options.number) : true,
        string: "string" in options ? Boolean(options.string) : true,
        allow: options.allow || []
    };
}

function isDoubleLogicalNegating(node) {
    return (
        node.operator === "!" &&
        node.argument.type === "UnaryExpression" &&
        node.argument.operator === "!"
    );
}

function isBinaryNegatingOfIndexOf(node) {
    return (
        node.operator === "~" &&
        node.argument.type === "CallExpression" &&
        node.argument.callee.type === "MemberExpression" &&
        node.argument.callee.property.type === "Identifier" &&
        INDEX_OF_PATTERN.test(node.argument.callee.property.name)
    );
}

function isMultiplyByOne(node) {
    return node.operator === "*" && (
        node.left.type === "Literal" && node.left.value === 1 ||
        node.right.type === "Literal" && node.right.value === 1
    );
}

function isNumeric(node) {
    return (
        node.type === "Literal" && typeof node.value === "number" ||
        node.type === "CallExpression" && (
            node.callee.name === "Number" ||
            node.callee.name === "parseInt" ||
            node.callee.name === "parseFloat"
        )
    );
}

function getNonNumericOperand(node) {
    var left = node.left,
        right = node.right;

    if (right.type !== "BinaryExpression" && !isNumeric(right)) {
        return right;
    }

    if (left.type !== "BinaryExpression" && !isNumeric(left)) {
        return left;
    }

    return null;
}

function isConcatWithEmptyString(node) {
    return node.operator === "+" && (
        (node.left.type === "Literal" && node.left.value === "") ||
        (node.right.type === "Literal" && node.right.value === "")
    );
}

function isAppendEmptyString(node) {
    return node.operator === "+=" && node.right.type === "Literal" && node.right.value === "";
}

function getOtherOperand(node, value) {
    if (node.left.type === "Literal" && node.left.value === value) {
        return node.right;
    }
    return node.left;
}
module.exports = function(context) {
    var options = parseOptions(context.options[0]),
        operatorAllowed = false;

    return {
        "UnaryExpression": function(node) {
            operatorAllowed = options.allow.indexOf("!!") >= 0;
            if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {
                context.report(
                    node,
                    "use `Boolean({{code}})` instead.", {
                        code: context.getSource(node.argument.argument)
                    });
            }
            operatorAllowed = options.allow.indexOf("~") >= 0;
            if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {
                context.report(
                    node,
                    "use `{{code}} !== -1` instead.", {
                        code: context.getSource(node.argument)
                    });
            }

            operatorAllowed = options.allow.indexOf("+") >= 0;
            if (!operatorAllowed && options.number && node.operator === "+" && !isNumeric(node.argument)) {
                context.report(
                    node,
                    "use `Number({{code}})` instead.", {
                        code: context.getSource(node.argument)
                    });
            }
        },

        "BinaryExpression:exit": function(node) {
            operatorAllowed = options.allow.indexOf("*") >= 0;
            var nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);
            if (nonNumericOperand) {
                context.report(
                    node,
                    "use `Number({{code}})` instead.", {
                        code: context.getSource(nonNumericOperand)
                    });
            }

            operatorAllowed = options.allow.indexOf("+") >= 0;
            if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {
                context.report(
                    node,
                    "use `String({{code}})` instead.", {
                        code: context.getSource(getOtherOperand(node, ""))
                    });
            }
        },

        "AssignmentExpression": function(node) {
            operatorAllowed = options.allow.indexOf("+") >= 0;
            if (options.string && isAppendEmptyString(node)) {
                context.report(
                    node,
                    "use `{{code}} = String({{code}})` instead.", {
                        code: context.getSource(getOtherOperand(node, ""))
                    });
            }
        }
    };
};

module.exports.schema = [{
    "type": "object",
    "properties": {
        "boolean": {
            "type": "boolean"
        },
        "number": {
            "type": "boolean"
        },
        "string": {
            "type": "boolean"
        },
        "allow": {
            "type": "array",
            "items": {
                "enum": ALLOWABLE_OPERATORS
            },
            "uniqueItems": true
        }
    },
    "additionalProperties": false
}];

},
   {}],

"/tmp/rules/no-implicit-globals.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    return {
        "Program": function() {
            var scope = context.getScope();

            scope.variables.forEach(function(variable) {
                if (variable.writeable) {
                    return;
                }

                variable.defs.forEach(function(def) {
                    if (def.type === "FunctionName" || (def.type === "Variable" && def.parent.kind === "var")) {
                        context.report(def.node, "Implicit global variable, assign as global property instead.");
                    }
                });
            });

            scope.implicit.variables.forEach(function(variable) {
                var scopeVariable = scope.set.get(variable.name);
                if (scopeVariable && scopeVariable.writeable) {
                    return;
                }

                variable.defs.forEach(function(def) {
                    context.report(def.node, "Implicit global variable, assign as global property instead.");
                });
            });
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-implied-eval.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var CALLEE_RE = /set(?:Timeout|Interval)|execScript/;

    var impliedEvalAncestorsStack = [];

    function last(arr) {
        return arr ? arr[arr.length - 1] : null;
    }

    function isImpliedEvalMemberExpression(node) {
        var object = node.object,
            property = node.property,
            hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);

        return object.name === "window" && hasImpliedEvalName;
    }

    function isImpliedEvalCallExpression(node) {
        var isMemberExpression = (node.callee.type === "MemberExpression"),
            isIdentifier = (node.callee.type === "Identifier"),
            isImpliedEvalCallee =
                (isIdentifier && CALLEE_RE.test(node.callee.name)) ||
                (isMemberExpression && isImpliedEvalMemberExpression(node.callee));

        return isImpliedEvalCallee && node.arguments.length;
    }

    function hasImpliedEvalParent(node) {
        return node.parent === last(last(impliedEvalAncestorsStack)) &&
            (node.parent.type !== "CallExpression" || node === node.parent.arguments[0]);
    }

    function checkString(node) {
        if (hasImpliedEvalParent(node)) {
            var substack = impliedEvalAncestorsStack.pop();
            context.report(substack[0], "Implied eval. Consider passing a function instead of a string.");
        }
    }

    return {
        "CallExpression": function(node) {
            if (isImpliedEvalCallExpression(node)) {
                impliedEvalAncestorsStack.push([node]);
            }
        },

        "CallExpression:exit": function(node) {
            if (node === last(last(impliedEvalAncestorsStack))) {
                impliedEvalAncestorsStack.pop();
            }
        },

        "BinaryExpression": function(node) {
            if (node.operator === "+" && hasImpliedEvalParent(node)) {
                last(impliedEvalAncestorsStack).push(node);
            }
        },

        "BinaryExpression:exit": function(node) {
            if (node === last(last(impliedEvalAncestorsStack))) {
                last(impliedEvalAncestorsStack).pop();
            }
        },

        "Literal": function(node) {
            if (typeof node.value === "string") {
                checkString(node);
            }
        },

        "TemplateLiteral": function(node) {
            checkString(node);
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-inline-comments.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    function testCodeAroundComment(node) {

        var startLine = String(context.getSourceLines()[node.loc.start.line]);
        var endLine = String(context.getSourceLines()[node.loc.end.line]);

        var preamble = startLine.slice(0, node.loc.start.column).trim();

        var postamble = endLine.slice(node.loc.end.column).trim();

        var isDirective = astUtils.isDirectiveComment(node);

        if (!isDirective && (preamble || postamble)) {
            context.report(node, "Unexpected comment inline with code.");
        }
    }

    return {

        "LineComment": testCodeAroundComment,
        "BlockComment": testCodeAroundComment

    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-inner-declarations.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function nearestBody() {
        var ancestors = context.getAncestors(),
            ancestor = ancestors.pop(),
            generation = 1;

        while (ancestor && ["Program", "FunctionDeclaration",
                "FunctionExpression", "ArrowFunctionExpression"
                ].indexOf(ancestor.type) < 0) {
            generation += 1;
            ancestor = ancestors.pop();
        }

        return {
            type: ancestor.type,
            distance: generation
        };
    }

    function check(node) {
        var body = nearestBody(node),
            valid = ((body.type === "Program" && body.distance === 1) ||
                body.distance === 2);

        if (!valid) {
            context.report(node, "Move {{type}} declaration to {{body}} root.",
                {
                    type: (node.type === "FunctionDeclaration" ?
                        "function" : "variable"),
                    body: (body.type === "Program" ?
                        "program" : "function body")
                }
            );
        }
    }

    return {

        "FunctionDeclaration": check,
        "VariableDeclaration": function(node) {
            if (context.options[0] === "both" && node.kind === "var") {
                check(node);
            }
        }

    };

};

module.exports.schema = [
    {
        "enum": ["functions", "both"]
    }
];

},
   {}],

"/tmp/rules/no-invalid-regexp.js": [function(require,module,exports){
"use strict";

var espree = require("espree");

module.exports = function(context) {

    var options = context.options[0],
        allowedFlags = "";

    if (options && options.allowConstructorFlags) {
        allowedFlags = options.allowConstructorFlags.join("");
    }

    function isString(node) {
        return node && node.type === "Literal" && typeof node.value === "string";
    }

    function check(node) {
        if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0])) {
            var flags = isString(node.arguments[1]) ? node.arguments[1].value : "";

            if (allowedFlags) {
                flags = flags.replace(new RegExp("[" + allowedFlags + "]", "gi"), "");
            }

            try {
                void new RegExp(node.arguments[0].value);
            } catch (e) {
                context.report(node, e.message);
            }

            if (flags) {

                try {
                    espree.parse("/./" + flags, context.parserOptions);
                } catch (ex) {
                    context.report(node, "Invalid flags supplied to RegExp constructor '" + flags + "'");
                }
            }

        }
    }

    return {
        "CallExpression": check,
        "NewExpression": check
    };

};

module.exports.schema = [{
    "type": "object",
    "properties": {
        "allowConstructorFlags": {
            "type": "array",
            "items": {
                "type": "string"
            }
        }
    },
    "additionalProperties": false
}];

},
   {"espree":"espree"}],

"/tmp/rules/no-invalid-this.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    var stack = [],
        sourceCode = context.getSourceCode();

    stack.getCurrent = function() {
        var current = this[this.length - 1];
        if (!current.init) {
            current.init = true;
            current.valid = !astUtils.isDefaultThisBinding(
                current.node,
                sourceCode);
        }
        return current;
    };

    function enterFunction(node) {
        stack.push({
            init: !context.getScope().isStrict,
            node: node,
            valid: true
        });
    }

    function exitFunction() {
        stack.pop();
    }

    return {
        "Program": function(node) {
            var scope = context.getScope(),
                features = context.parserOptions.ecmaFeatures || {};

            stack.push({
                init: true,
                node: node,
                valid: !(
                    scope.isStrict ||
                    node.sourceType === "module" ||
                    (features.globalReturn && scope.childScopes[0].isStrict)
                )
            });
        },
        "Program:exit": function() {
            stack.pop();
        },

        "FunctionDeclaration": enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        "FunctionExpression": enterFunction,
        "FunctionExpression:exit": exitFunction,

        "ThisExpression": function(node) {
            var current = stack.getCurrent();
            if (current && !current.valid) {
                context.report(node, "Unexpected 'this'.");
            }
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-irregular-whitespace.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var irregularWhitespace = /[\u0085\u00A0\ufeff\f\v\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mg,
        irregularLineTerminators = /[\u2028\u2029]/mg;

    var errors = [];

    var commentNodes = [];

    var options = context.options[0] || {};
    var skipComments = !!options.skipComments;

    function removeWhitespaceError(node) {
        var locStart = node.loc.start;
        var locEnd = node.loc.end;

        errors = errors.filter(function(error) {
            var errorLoc = error[1];
            if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {
                if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {
                    return false;
                }
            }
            return true;
        });
    }

    function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {
        if (typeof node.value === "string") {
            if (node.raw.match(irregularWhitespace) || node.raw.match(irregularLineTerminators)) {
                removeWhitespaceError(node);
            }
        }
    }

    function removeInvalidNodeErrorsInComment(node) {
        if (node.value.match(irregularWhitespace) || node.value.match(irregularLineTerminators)) {
            removeWhitespaceError(node);
        }
    }

    function checkForIrregularWhitespace(node) {
        var sourceLines = context.getSourceLines();

        sourceLines.forEach(function(sourceLine, lineIndex) {
            var lineNumber = lineIndex + 1,
                location,
                match;

            while ((match = irregularWhitespace.exec(sourceLine)) !== null) {
                location = {
                    line: lineNumber,
                    column: match.index
                };

                errors.push([node, location, "Irregular whitespace not allowed"]);
            }
        });
    }

    function checkForIrregularLineTerminators(node) {
        var source = context.getSource(),
            sourceLines = context.getSourceLines(),
            linebreaks = source.match(/\r\n|\r|\n|\u2028|\u2029/g),
            lastLineIndex = -1,
            lineIndex,
            location,
            match;

        while ((match = irregularLineTerminators.exec(source)) !== null) {
            lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;

            location = {
                line: lineIndex + 1,
                column: sourceLines[lineIndex].length
            };

            errors.push([node, location, "Irregular whitespace not allowed"]);
            lastLineIndex = lineIndex;
        }
    }

    function rememberCommentNode(node) {
        commentNodes.push(node);
    }

    function noop() {}

    return {
        "Program": function(node) {
            checkForIrregularWhitespace(node);
            checkForIrregularLineTerminators(node);
        },

        "Identifier": removeInvalidNodeErrorsInIdentifierOrLiteral,
        "Literal": removeInvalidNodeErrorsInIdentifierOrLiteral,
        "LineComment": skipComments ? rememberCommentNode : noop,
        "BlockComment": skipComments ? rememberCommentNode : noop,
        "Program:exit": function() {

            if (skipComments) {
                commentNodes.forEach(removeInvalidNodeErrorsInComment);
            }

            errors.forEach(function(error) {
                context.report.apply(context, error);
            });
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "skipComments": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-iterator.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "MemberExpression": function(node) {

            if (node.property &&
                    (node.property.type === "Identifier" && node.property.name === "__iterator__" && !node.computed) ||
                    (node.property.type === "Literal" && node.property.value === "__iterator__")) {
                context.report(node, "Reserved name '__iterator__'.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-label-var.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    function findIdentifier(scope, name) {
        return astUtils.getVariableByName(scope, name) !== null;
    }

    return {

        "LabeledStatement": function(node) {

            var scope = context.getScope();

            if (findIdentifier(scope, node.label.name)) {
                context.report(node, "Found identifier with same name as label.");
            }
        }

    };

};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-labels.js": [function(require,module,exports){
"use strict";

var LOOP_TYPES = /^(?:While|DoWhile|For|ForIn|ForOf)Statement$/;

module.exports = function(context) {
    var options = context.options[0];
    var allowLoop = Boolean(options && options.allowLoop);
    var allowSwitch = Boolean(options && options.allowSwitch);
    var scopeInfo = null;

    function getBodyKind(node) {
        var type = node.type;

        if (LOOP_TYPES.test(type)) {
            return "loop";
        }
        if (type === "SwitchStatement") {
            return "switch";
        }
        return "other";
    }

    function isAllowed(kind) {
        switch (kind) {
            case "loop": return allowLoop;
            case "switch": return allowSwitch;
            default: return false;
        }
    }

    function getKind(label) {
        var info = scopeInfo;
        while (info) {
            if (info.label === label) {
                return info.kind;
            }
            info = info.upper;
        }

        return "other";
    }

    return {
        "LabeledStatement": function(node) {
            scopeInfo = {
                label: node.label.name,
                kind: getBodyKind(node.body),
                upper: scopeInfo
            };
        },

        "LabeledStatement:exit": function(node) {
            if (!isAllowed(scopeInfo.kind)) {
                context.report({
                    node: node,
                    message: "Unexpected labeled statement."
                });
            }

            scopeInfo = scopeInfo.upper;
        },

        "BreakStatement": function(node) {
            if (node.label && !isAllowed(getKind(node.label.name))) {
                context.report({
                    node: node,
                    message: "Unexpected label in break statement."
                });
            }
        },

        "ContinueStatement": function(node) {
            if (node.label && !isAllowed(getKind(node.label.name))) {
                context.report({
                    node: node,
                    message: "Unexpected label in continue statement."
                });
            }
        }
    };

};

module.exports.schema = [
    {
        type: "object",
        properties: {
            allowLoop: {
                type: "boolean"
            },
            allowSwitch: {
                type: "boolean"
            }
        },
        additionalProperties: false
    }
];

},
   {}],

"/tmp/rules/no-lone-blocks.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var loneBlocks = [],
        ruleDef;

    function report(node) {
        var parent = context.getAncestors().pop();
        context.report(node, parent.type === "Program" ?
            "Block is redundant." :
            "Nested block is redundant."
        );
    }

    function isLoneBlock() {
        var parent = context.getAncestors().pop();
        return parent.type === "BlockStatement" || parent.type === "Program";
    }

    function markLoneBlock() {
        if (loneBlocks.length === 0) {
            return;
        }

        var block = context.getAncestors().pop();

        if (loneBlocks[loneBlocks.length - 1] === block) {
            loneBlocks.pop();
        }
    }

    ruleDef = {
        BlockStatement: function(node) {
            if (isLoneBlock(node)) {
                report(node);
            }
        }
    };

    if (context.parserOptions.ecmaVersion >= 6) {
        ruleDef = {
            "BlockStatement": function(node) {
                if (isLoneBlock(node)) {
                    loneBlocks.push(node);
                }
            },
            "BlockStatement:exit": function(node) {
                if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {
                    loneBlocks.pop();
                    report(node);
                }
            }
        };

        ruleDef.VariableDeclaration = function(node) {
            if (node.kind === "let" || node.kind === "const") {
                markLoneBlock(node);
            }
        };

        ruleDef.FunctionDeclaration = function(node) {
            if (context.getScope().isStrict) {
                markLoneBlock(node);
            }
        };

        ruleDef.ClassDeclaration = markLoneBlock;
    }

    return ruleDef;
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-lonely-if.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "IfStatement": function(node) {
            var ancestors = context.getAncestors(),
                parent = ancestors.pop(),
                grandparent = ancestors.pop();

            if (parent && parent.type === "BlockStatement" &&
                    parent.body.length === 1 && grandparent &&
                    grandparent.type === "IfStatement" &&
                    parent === grandparent.alternate) {
                context.report(node, "Unexpected if as the only statement in an else block.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-loop-func.js": [function(require,module,exports){
"use strict";

function getContainingLoopNode(node) {
    var parent = node.parent;
    while (parent) {
        switch (parent.type) {
            case "WhileStatement":
            case "DoWhileStatement":
                return parent;

            case "ForStatement":
                if (parent.init !== node) {
                    return parent;
                }
                break;

            case "ForInStatement":
            case "ForOfStatement":
                if (parent.right !== node) {
                    return parent;
                }
                break;

            case "ArrowFunctionExpression":
            case "FunctionExpression":
            case "FunctionDeclaration":
                return null;

            default:
                break;
        }

        node = parent;
        parent = node.parent;
    }

    return null;
}

function getTopLoopNode(node, excludedNode) {
    var retv = null;
    var border = excludedNode ? excludedNode.range[1] : 0;

    while (node && node.range[0] >= border) {
        retv = node;
        node = getContainingLoopNode(node);
    }

    return retv;
}

function isSafe(funcNode, loopNode, reference) {
    var variable = reference.resolved;
    var definition = variable && variable.defs[0];
    var declaration = definition && definition.parent;
    var kind = (declaration && declaration.type === "VariableDeclaration")
        ? declaration.kind
        : "";

    if (kind === "const") {
        return true;
    }

    if (kind === "let" &&
        declaration.range[0] > loopNode.range[0] &&
        declaration.range[1] < loopNode.range[1]
    ) {
        return true;
    }

    var border = getTopLoopNode(
        loopNode,
        (kind === "let") ? declaration : null
    ).range[0];

    function isSafeReference(upperRef) {
        var id = upperRef.identifier;
        return (
            !upperRef.isWrite() ||
            variable.scope.variableScope === upperRef.from.variableScope &&
            id.range[0] < border
        );
    }

    return Boolean(variable) && variable.references.every(isSafeReference);
}

module.exports = function(context) {
    function checkForLoops(node) {
        var loopNode = getContainingLoopNode(node);
        if (!loopNode) {
            return;
        }

        var references = context.getScope().through;
        if (references.length > 0 &&
            !references.every(isSafe.bind(null, node, loopNode))
        ) {
            context.report(node, "Don't make functions within a loop");
        }
    }

    return {
        "ArrowFunctionExpression": checkForLoops,
        "FunctionExpression": checkForLoops,
        "FunctionDeclaration": checkForLoops
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-magic-numbers.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var config = context.options[0] || {},
        detectObjects = !!config.detectObjects,
        enforceConst = !!config.enforceConst,
        ignore = config.ignore || [],
        ignoreArrayIndexes = !!config.ignoreArrayIndexes;

    function isNumber(node) {
        return typeof node.value === "number";
    }

    function shouldIgnoreNumber(num) {
        return ignore.indexOf(num) !== -1;
    }

    function shouldIgnoreParseInt(parent, node) {
        return parent.type === "CallExpression" && node === parent.arguments[1] &&
            (parent.callee.name === "parseInt" ||
            parent.callee.type === "MemberExpression" &&
            parent.callee.object.name === "Number" &&
            parent.callee.property.name === "parseInt");
    }

    function shouldIgnoreJSXNumbers(parent) {
        return parent.type.indexOf("JSX") === 0;
    }

    function shouldIgnoreArrayIndexes(parent) {
        return parent.type === "MemberExpression" && ignoreArrayIndexes;
    }

    return {
        "Literal": function(node) {
            var parent = node.parent,
                value = node.value,
                raw = node.raw,
                okTypes = detectObjects ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];

            if (!isNumber(node)) {
                return;
            }

            if (parent.type === "UnaryExpression" && parent.operator === "-") {
                node = parent;
                parent = node.parent;
                value = -value;
                raw = "-" + raw;
            }

            if (shouldIgnoreNumber(value) ||
                shouldIgnoreParseInt(parent, node) ||
                shouldIgnoreArrayIndexes(parent) ||
                shouldIgnoreJSXNumbers(parent)) {
                return;
            }

            if (parent.type === "VariableDeclarator") {
                if (enforceConst && parent.parent.kind !== "const") {
                    context.report({
                        node: node,
                        message: "Number constants declarations must use 'const'"
                    });
                }
            } else if (okTypes.indexOf(parent.type) === -1) {
                context.report({
                    node: node,
                    message: "No magic number: " + raw
                });
            }
        }
    };
};

module.exports.schema = [{
    "type": "object",
    "properties": {
        "detectObjects": {
            "type": "boolean"
        },
        "enforceConst": {
            "type": "boolean"
        },
        "ignore": {
            "type": "array",
            "items": {
                "type": "number"
            },
            "uniqueItems": true
        },
        "ignoreArrayIndexes": {
            "type": "boolean"
        }
    },
    "additionalProperties": false
}];

},
   {}],

"/tmp/rules/no-mixed-requires.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var grouping = false,
        allowCall = false,
        options = context.options[0];

    if (typeof options === "object") {
        grouping = options.grouping;
        allowCall = options.allowCall;
    } else {
        grouping = !!options;
    }

    function getBuiltinModules() {
        return [
            "assert", "buffer", "child_process", "cluster", "crypto",
            "dgram", "dns", "domain", "events", "fs", "http", "https",
            "net", "os", "path", "punycode", "querystring", "readline",
            "repl", "smalloc", "stream", "string_decoder", "tls", "tty",
            "url", "util", "v8", "vm", "zlib"
        ];
    }

    var BUILTIN_MODULES = getBuiltinModules();

    var DECL_REQUIRE = "require",
        DECL_UNINITIALIZED = "uninitialized",
        DECL_OTHER = "other";

    var REQ_CORE = "core",
        REQ_FILE = "file",
        REQ_MODULE = "module",
        REQ_COMPUTED = "computed";

    function getDeclarationType(initExpression) {
        if (!initExpression) {
            return DECL_UNINITIALIZED;
        }

        if (initExpression.type === "CallExpression" &&
            initExpression.callee.type === "Identifier" &&
            initExpression.callee.name === "require"
        ) {
            return DECL_REQUIRE;
        } else if (allowCall &&
            initExpression.type === "CallExpression" &&
            initExpression.callee.type === "CallExpression"
        ) {
            return getDeclarationType(initExpression.callee);
        } else if (initExpression.type === "MemberExpression") {
            return getDeclarationType(initExpression.object);
        }

        return DECL_OTHER;
    }

    function inferModuleType(initExpression) {
        if (initExpression.type === "MemberExpression") {
            return inferModuleType(initExpression.object);
        } else if (initExpression.arguments.length === 0) {
            return REQ_COMPUTED;
        }

        var arg = initExpression.arguments[0];

        if (arg.type !== "Literal" || typeof arg.value !== "string") {
            return REQ_COMPUTED;
        }

        if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {
            return REQ_CORE;
        } else if (/^\.{0,2}\//.test(arg.value)) {
            return REQ_FILE;
        } else {
            return REQ_MODULE;
        }
    }

    function isMixed(declarations) {
        var contains = {};

        declarations.forEach(function(declaration) {
            var type = getDeclarationType(declaration.init);
            contains[type] = true;
        });

        return !!(
            contains[DECL_REQUIRE] &&
            (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER])
        );
    }

    function isGrouped(declarations) {
        var found = {};

        declarations.forEach(function(declaration) {
            if (getDeclarationType(declaration.init) === DECL_REQUIRE) {
                found[inferModuleType(declaration.init)] = true;
            }
        });

        return Object.keys(found).length <= 1;
    }


    return {

        "VariableDeclaration": function(node) {

            if (isMixed(node.declarations)) {
                context.report(
                    node,
                    "Do not mix 'require' and other declarations."
                );
            } else if (grouping && !isGrouped(node.declarations)) {
                context.report(
                    node,
                    "Do not mix core, module, file and computed requires."
                );
            }
        }
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "type": "boolean"
            },
            {
                "type": "object",
                "properties": {
                    "grouping": {
                        "type": "boolean"
                    },
                    "allowCall": {
                        "type": "boolean"
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/no-mixed-spaces-and-tabs.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var smartTabs,
        ignoredLocs = [];

    switch (context.options[0]) {
        case true: // Support old syntax, maybe add deprecation warning here
        case "smart-tabs":
            smartTabs = true;
            break;
        default:
            smartTabs = false;
    }

    function beforeLoc(loc, line, column) {
        if (line < loc.start.line) {
            return true;
        }
        return line === loc.start.line && column < loc.start.column;
    }

    function afterLoc(loc, line, column) {
        if (line > loc.end.line) {
            return true;
        }
        return line === loc.end.line && column > loc.end.column;
    }

    return {

        "TemplateElement": function(node) {
            ignoredLocs.push(node.loc);
        },

        "Program:exit": function(node) {
            var regex = /^(?=[\t ]*(\t | \t))/,
                match,
                lines = context.getSourceLines(),
                comments = context.getAllComments();

            comments.forEach(function(comment) {
                ignoredLocs.push(comment.loc);
            });

            ignoredLocs.sort(function(first, second) {
                if (beforeLoc(first, second.start.line, second.start.column)) {
                    return 1;
                }

                if (beforeLoc(second, first.start.line, second.start.column)) {
                    return -1;
                }

                return 0;
            });

            if (smartTabs) {
                regex = /^(?=[\t ]* \t)/;
            }

            lines.forEach(function(line, i) {
                match = regex.exec(line);

                if (match) {
                    var lineNumber = i + 1,
                        column = match.index + 1;

                    for (var j = 0; j < ignoredLocs.length; j++) {
                        if (beforeLoc(ignoredLocs[j], lineNumber, column)) {
                            continue;
                        }
                        if (afterLoc(ignoredLocs[j], lineNumber, column)) {
                            continue;
                        }

                        return;
                    }

                    context.report(node, { line: lineNumber, column: column }, "Mixed spaces and tabs.");
                }
            });
        }

    };

};

module.exports.schema = [
    {
        "enum": ["smart-tabs", true, false]
    }
];

},
   {}],

"/tmp/rules/no-multi-spaces.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var exceptions = { "Property": true },
        hasExceptions = true,
        options = context.options[0],
        lastCommentIndex = 0;

    if (options && options.exceptions) {
        Object.keys(options.exceptions).forEach(function(key) {
            if (options.exceptions[key]) {
                exceptions[key] = true;
            } else {
                delete exceptions[key];
            }
        });
        hasExceptions = Object.keys(exceptions).length > 0;
    }

    function isIndexInComment(index, comments) {

        var comment;

        while (lastCommentIndex < comments.length) {

            comment = comments[lastCommentIndex];

            if (comment.range[0] <= index && index < comment.range[1]) {
                return true;
            } else if (index > comment.range[1]) {
                lastCommentIndex++;
            } else {
                break;
            }

        }

        return false;
    }

    return {
        "Program": function() {

            var source = context.getSource(),
                allComments = context.getAllComments(),
                pattern = /[^\n\r\u2028\u2029\t ].? {2,}/g,  // note: repeating space
                token,
                previousToken,
                parent;


            function createFix(leftToken, rightToken) {
                return function(fixer) {
                    return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], " ");
                };
            }

            while (pattern.test(source)) {

                if (!isIndexInComment(pattern.lastIndex, allComments)) {

                    token = context.getTokenByRangeStart(pattern.lastIndex);
                    if (token) {
                        previousToken = context.getTokenBefore(token);

                        if (hasExceptions) {
                            parent = context.getNodeByRangeIndex(pattern.lastIndex - 1);
                        }

                        if (!parent || !exceptions[parent.type]) {
                            context.report({
                                node: token,
                                loc: token.loc.start,
                                message: "Multiple spaces found before '{{value}}'.",
                                data: { value: token.value },
                                fix: createFix(previousToken, token)
                            });
                        }
                    }

                }
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "object",
                "patternProperties": {
                    "^([A-Z][a-z]*)+$": {
                        "type": "boolean"
                    }
                },
                "additionalProperties": false
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-multi-str.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isJSXElement(node) {
        return node.type.indexOf("JSX") === 0;
    }

    return {

        "Literal": function(node) {
            var lineBreak = /\n/;

            if (lineBreak.test(node.raw) && !isJSXElement(node.parent)) {
                context.report(node, "Multiline support is limited to browsers supporting ES5 only.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-multiple-empty-lines.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var max = 2,
        maxEOF,
        maxBOF;

    var notEmpty = [];

    if (context.options.length) {
        max = context.options[0].max;
        maxEOF = context.options[0].maxEOF;
        maxBOF = context.options[0].maxBOF;
    }

    return {

        "TemplateLiteral": function(node) {
            var start = node.loc.start.line;
            var end = node.loc.end.line;
            while (start <= end) {
                notEmpty.push(start);
                start++;
            }
        },

        "Program:exit": function checkBlankLines(node) {
            var lines = context.getSourceLines(),
                currentLocation = -1,
                lastLocation,
                blankCounter = 0,
                location,
                firstOfEndingBlankLines,
                firstNonBlankLine = -1,
                trimmedLines = [];

            lines.forEach(function(str, i) {
                var trimmed = str.trim();
                if ((firstNonBlankLine === -1) && (trimmed !== "")) {
                    firstNonBlankLine = i;
                }

                trimmedLines.push(trimmed);
            });

            notEmpty.forEach(function(x, i) {
                trimmedLines[i] = x;
            });

            if (typeof maxEOF === "undefined") {
                if (trimmedLines[trimmedLines.length - 1] === "") {
                    trimmedLines = trimmedLines.slice(0, -1);
                }
                firstOfEndingBlankLines = trimmedLines.length;
            } else {
                firstOfEndingBlankLines = trimmedLines.length;
                while (trimmedLines[firstOfEndingBlankLines - 1] === ""
                        && firstOfEndingBlankLines > 0) {
                    firstOfEndingBlankLines--;
                }
            }

            if (firstNonBlankLine > maxBOF) {
                context.report(node, 0,
                        "Too many blank lines at the beginning of file. Max of " + maxBOF + " allowed.");
            }

            lastLocation = currentLocation;
            currentLocation = trimmedLines.indexOf("", currentLocation + 1);
            while (currentLocation !== -1) {
                lastLocation = currentLocation;
                currentLocation = trimmedLines.indexOf("", currentLocation + 1);
                if (lastLocation === currentLocation - 1) {
                    blankCounter++;
                } else {
                    location = {
                        line: lastLocation ,
                        column: 0
                    };
                    if (lastLocation < firstOfEndingBlankLines) {
                        if (blankCounter >= max) {
                            context.report(node, location,
                                    "More than " + max + " blank " + (max === 1 ? "line" : "lines") + " not allowed.");
                        }
                    } else {
                        if (blankCounter > maxEOF) {
                            context.report(node, location,
                                    "Too many blank lines at the end of file. Max of " + maxEOF + " allowed.");
                        }
                    }

                    blankCounter = 0;
                }
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "max": {
                "type": "integer",
                "minimum": 0
            },
            "maxEOF": {
                "type": "integer",
                "minimum": 0
            },
            "maxBOF": {
                "type": "integer",
                "minimum": 0
            }
        },
        "required": ["max"],
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-native-reassign.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var config = context.options[0];
    var exceptions = (config && config.exceptions) || [];

    function checkReference(reference, index, references) {
        var identifier = reference.identifier;

        if (reference.init === false &&
            reference.isWrite() &&
            (index === 0 || references[index - 1].identifier !== identifier)
        ) {
            context.report({
                node: identifier,
                message: "{{name}} is a read-only native object.",
                data: identifier
            });
        }
    }

    function checkVariable(variable) {
        if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
            variable.references.forEach(checkReference);
        }
    }

    return {
        "Program": function() {
            var globalScope = context.getScope();
            globalScope.variables.forEach(checkVariable);
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "array",
                "items": {"type": "string"},
                "uniqueItems": true
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-negated-condition.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function hasElseWithoutCondition(node) {
        return node.alternate && node.alternate.type !== "IfStatement";
    }

    function isNegatedUnaryExpression(test) {
        return test.type === "UnaryExpression" && test.operator === "!";
    }

    function isNegatedBinaryExpression(test) {
        return test.type === "BinaryExpression" &&
            (test.operator === "!=" || test.operator === "!==");
    }

    function isNegatedIf(node) {
        return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);
    }

    return {
        "IfStatement": function(node) {
            if (!hasElseWithoutCondition(node)) {
                return;
            }

            if (isNegatedIf(node)) {
                context.report(node, "Unexpected negated condition.");
            }
        },
        "ConditionalExpression": function(node) {
            if (isNegatedIf(node)) {
                context.report(node, "Unexpected negated condition.");
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-negated-in-lhs.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "BinaryExpression": function(node) {
            if (node.operator === "in" && node.left.type === "UnaryExpression" && node.left.operator === "!") {
                context.report(node, "The 'in' expression's left operand is negated");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-nested-ternary.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "ConditionalExpression": function(node) {
            if (node.alternate.type === "ConditionalExpression" ||
                    node.consequent.type === "ConditionalExpression") {
                context.report(node, "Do not nest ternary expressions");
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-new-func.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function validateCallee(node) {
        if (node.callee.name === "Function") {
            context.report(node, "The Function constructor is eval.");
        }
    }

    return {
        "NewExpression": validateCallee,
        "CallExpression": validateCallee
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-new-object.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "NewExpression": function(node) {
            if (node.callee.name === "Object") {
                context.report(node, "The object literal notation {} is preferrable.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-new-require.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "NewExpression": function(node) {
            if (node.callee.type === "Identifier" && node.callee.name === "require") {
                context.report(node, "Unexpected use of new with require.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-new-symbol.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "Program:exit": function() {
            var globalScope = context.getScope();
            var variable = globalScope.set.get("Symbol");
            if (variable && variable.defs.length === 0) {
                variable.references.forEach(function(ref) {
                    var node = ref.identifier;
                    if (node.parent && node.parent.type === "NewExpression") {
                        context.report(node, "`Symbol` cannot be called as a constructor.");
                    }
                });
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-new-wrappers.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "NewExpression": function(node) {
            var wrapperObjects = ["String", "Number", "Boolean", "Math", "JSON"];
            if (wrapperObjects.indexOf(node.callee.name) > -1) {
                context.report(node, "Do not use {{fn}} as a constructor.", { fn: node.callee.name });
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-new.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "ExpressionStatement": function(node) {

            if (node.expression.type === "NewExpression") {
                context.report(node, "Do not use 'new' for side effects.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-obj-calls.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "CallExpression": function(node) {

            if (node.callee.type === "Identifier") {
                var name = node.callee.name;
                if (name === "Math" || name === "JSON") {
                    context.report(node, "'{{name}}' is not a function.", { name: name });
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-octal-escape.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Literal": function(node) {
            if (typeof node.value !== "string") {
                return;
            }

            var match = node.raw.match(/^([^\\]|\\[^0-7])*\\([0-3][0-7]{1,2}|[4-7][0-7]|[0-7])/),
                octalDigit;

            if (match) {
                octalDigit = match[2];

                if (match[2] !== "0" || typeof match[3] !== "undefined") {
                    context.report(node, "Don't use octal: '\\{{octalDigit}}'. Use '\\u....' instead.",
                            { octalDigit: octalDigit });
                }
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-octal.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Literal": function(node) {
            if (typeof node.value === "number" && /^0[0-7]/.test(node.raw)) {
                context.report(node, "Octal literals should not be used.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-param-reassign.js": [function(require,module,exports){
"use strict";

var stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/;

module.exports = function(context) {
    var props = context.options[0] && Boolean(context.options[0].props);

    function isModifying(reference) {
        if (reference.isWrite()) {
            return true;
        }

        if (props) {
            var node = reference.identifier;
            var parent = node.parent;
            while (parent && !stopNodePattern.test(parent.type)) {
                switch (parent.type) {
                    case "AssignmentExpression":
                        return parent.left === node;

                    case "UpdateExpression":
                        return true;

                    case "UnaryExpression":
                        if (parent.operator === "delete") {
                            return true;
                        }
                        break;

                    case "CallExpression":
                        if (parent.callee !== node) {
                            return false;
                        }
                        break;

                    case "MemberExpression":
                        if (parent.property === node) {
                            return false;
                        }
                        break;

                    default:
                        break;
                }

                node = parent;
                parent = parent.parent;
            }
        }

        return false;
    }

    function checkReference(reference, index, references) {
        var identifier = reference.identifier;

        if (identifier &&
            !reference.init &&
            isModifying(reference) &&
            (index === 0 || references[index - 1].identifier !== identifier)
        ) {
            context.report(
                identifier,
                "Assignment to function parameter '{{name}}'.",
                {name: identifier.name});
        }
    }

    function checkVariable(variable) {
        if (variable.defs[0].type === "Parameter") {
            variable.references.forEach(checkReference);
        }
    }

    function checkForFunction(node) {
        context.getDeclaredVariables(node).forEach(checkVariable);
    }

    return {
        "FunctionDeclaration:exit": checkForFunction,
        "FunctionExpression:exit": checkForFunction,
        "ArrowFunctionExpression:exit": checkForFunction
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "props": {"type": "boolean"}
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-path-concat.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var MATCHER = /^__(?:dir|file)name$/;

    return {

        "BinaryExpression": function(node) {

            var left = node.left,
                right = node.right;

            if (node.operator === "+" &&
                    ((left.type === "Identifier" && MATCHER.test(left.name)) ||
                    (right.type === "Identifier" && MATCHER.test(right.name)))
            ) {

                context.report(node, "Use path.join() or path.resolve() instead of + to create paths.");
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-plusplus.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var config = context.options[0],
        allowInForAfterthought = false;

    if (typeof config === "object") {
        allowInForAfterthought = config.allowForLoopAfterthoughts === true;
    }

    return {

        "UpdateExpression": function(node) {
            if (allowInForAfterthought && node.parent.type === "ForStatement") {
                return;
            }
            context.report(node, "Unary operator '" + node.operator + "' used.");
        }

    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allowForLoopAfterthoughts": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-process-env.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "MemberExpression": function(node) {
            var objectName = node.object.name,
                propertyName = node.property.name;

            if (objectName === "process" && !node.computed && propertyName && propertyName === "env") {
                context.report(node, "Unexpected use of process.env.");
            }

        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-process-exit.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "CallExpression": function(node) {
            var callee = node.callee;

            if (callee.type === "MemberExpression" && callee.object.name === "process" &&
                callee.property.name === "exit"
            ) {
                context.report(node, "Don't use process.exit(); throw an error instead.");
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-proto.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "MemberExpression": function(node) {

            if (node.property &&
                    (node.property.type === "Identifier" && node.property.name === "__proto__" && !node.computed) ||
                    (node.property.type === "Literal" && node.property.value === "__proto__")) {
                context.report(node, "The '__proto__' property is deprecated.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-redeclare.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var options = {
        builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals)
    };

    function findVariablesInScope(scope) {
        scope.variables.forEach(function(variable) {
            var hasBuiltin = options.builtinGlobals && "writeable" in variable;
            var count = (hasBuiltin ? 1 : 0) + variable.identifiers.length;

            if (count >= 2) {
                variable.identifiers.sort(function(a, b) {
                    return a.range[1] - b.range[1];
                });

                for (var i = (hasBuiltin ? 0 : 1), l = variable.identifiers.length; i < l; i++) {
                    context.report(
                        variable.identifiers[i],
                        "'{{a}}' is already defined",
                        {a: variable.name});
                }
            }
        });

    }

    function checkForGlobal(node) {
        var scope = context.getScope(),
            parserOptions = context.parserOptions,
            ecmaFeatures = parserOptions.ecmaFeatures || {};

        if (ecmaFeatures.globalReturn || node.sourceType === "module") {
            findVariablesInScope(scope.childScopes[0]);
        } else {
            findVariablesInScope(scope);
        }
    }

    function checkForBlock() {
        findVariablesInScope(context.getScope());
    }

    if (context.parserOptions.ecmaVersion >= 6) {
        return {
            "Program": checkForGlobal,
            "BlockStatement": checkForBlock,
            "SwitchStatement": checkForBlock
        };
    } else {
        return {
            "Program": checkForGlobal,
            "FunctionDeclaration": checkForBlock,
            "FunctionExpression": checkForBlock,
            "ArrowFunctionExpression": checkForBlock
        };
    }
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "builtinGlobals": {"type": "boolean"}
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-regex-spaces.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Literal": function(node) {
            var token = context.getFirstToken(node),
                nodeType = token.type,
                nodeValue = token.value,
                multipleSpacesRegex = /( {2,})+?/,
                regexResults;

            if (nodeType === "RegularExpression") {
                regexResults = multipleSpacesRegex.exec(nodeValue);

                if (regexResults !== null) {
                    context.report(node, "Spaces are hard to count. Use {" + regexResults[0].length + "}.");
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-restricted-globals.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var restrictedGlobals = context.options;

    if (restrictedGlobals.length === 0) {
        return {};
    }

    function reportReference(reference) {
        context.report(reference.identifier, "Unexpected use of '{{name}}'", {
            name: reference.identifier.name
        });
    }

    function isRestricted(name) {
        return restrictedGlobals.indexOf(name) >= 0;
    }

    return {
        "Program": function() {
            var scope = context.getScope();

            scope.variables.forEach(function(variable) {
                if (!variable.defs.length && isRestricted(variable.name)) {
                    variable.references.forEach(reportReference);
                }
            });

            scope.through.forEach(function(reference) {
                if (isRestricted(reference.identifier.name)) {
                    reportReference(reference);
                }
            });

        }
    };
};

module.exports.schema = {
    "type": "array",
    "items": {
        "type": "string"
    },
    "uniqueItems": true
};


},
   {}],

"/tmp/rules/no-restricted-imports.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var restrictedImports = context.options;

    if (restrictedImports.length === 0) {
        return {};
    }

    return {
        "ImportDeclaration": function(node) {
            if (node && node.source && node.source.value) {

                var value = node.source.value.trim();

                if (restrictedImports.indexOf(value) !== -1) {
                    context.report(node, "'{{importName}}' import is restricted from being used.", {
                        importName: value
                    });
                }
            }
        }
    };
};

module.exports.schema = {
    "type": "array",
    "items": {
        "type": "string"
    },
    "uniqueItems": true
};

},
   {}],

"/tmp/rules/no-restricted-modules.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var restrictedModules = context.options;

    if (restrictedModules.length === 0) {
        return {};
    }

    function isString(node) {
        return node && node.type === "Literal" && typeof node.value === "string";
    }

    function isRequireCall(node) {
        return node.callee.type === "Identifier" && node.callee.name === "require";
    }

    function getRestrictedModuleName(node) {
        var moduleName;

        if (node.arguments.length && isString(node.arguments[0])) {
            var argumentValue = node.arguments[0].value.trim();

            if (restrictedModules.indexOf(argumentValue) !== -1) {
                moduleName = argumentValue;
            }
        }

        return moduleName;
    }

    return {
        "CallExpression": function(node) {
            if (isRequireCall(node)) {
                var restrictedModuleName = getRestrictedModuleName(node);

                if (restrictedModuleName) {
                    context.report(node, "'{{moduleName}}' module is restricted from being used.", {
                        moduleName: restrictedModuleName
                    });
                }
            }
        }
    };
};

module.exports.schema = {
    "type": "array",
    "items": {
        "type": "string"
    },
    "uniqueItems": true
};

},
   {}],

"/tmp/rules/no-restricted-syntax.js": [function(require,module,exports){
"use strict";

var nodeTypes = require("espree").Syntax;

module.exports = function(context) {
    function warn(node) {
        context.report(node, "Using '{{type}}' is not allowed.", node);
    }

    return context.options.reduce(function(result, nodeType) {
        result[nodeType] = warn;

        return result;
    }, {});

};

module.exports.schema = {
    "type": "array",
    "items": [
        {
            "enum": Object.keys(nodeTypes).map(function(k) {
                return nodeTypes[k];
            })
        }
    ],
    "uniqueItems": true,
    "minItems": 0
};

},
   {"espree":"espree"}],

"/tmp/rules/no-return-assign.js": [function(require,module,exports){
"use strict";

function isAssignment(node) {
    return node && node.type === "AssignmentExpression";
}

function isEnclosedInParens(node, context) {
    var prevToken = context.getTokenBefore(node);
    var nextToken = context.getTokenAfter(node);

    return prevToken.value === "(" && nextToken.value === ")";
}

module.exports = function(context) {
    var always = (context.options[0] || "except-parens") !== "except-parens";

    function checkForAssignInReturn(nodeToCheck, nodeToReport, message) {
        if (isAssignment(nodeToCheck) && (always || !isEnclosedInParens(nodeToCheck, context))) {
            context.report(nodeToReport, message);
        }
    }

    return {
        "ReturnStatement": function(node) {
            var message = "Return statement should not contain assignment.";
            checkForAssignInReturn(node.argument, node, message);
        },
        "ArrowFunctionExpression": function(node) {
            if (node.body.type !== "BlockStatement") {
                var message = "Arrow function should not return assignment.";
                checkForAssignInReturn(node.body, node, message);
            }
        }
    };
};

module.exports.schema = [
    {
        "enum": ["except-parens", "always"]
    }
];

},
   {}],

"/tmp/rules/no-script-url.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Literal": function(node) {

            var value;

            if (node.value && typeof node.value === "string") {
                value = node.value.toLowerCase();

                if (value.indexOf("javascript:") === 0) {
                    context.report(node, "Script URL is a form of eval.");
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-self-assign.js": [function(require,module,exports){
"use strict";

function eachSelfAssignment(left, right, report) {
    var i, j;

    if (!left || !right) {
    } else if (
        left.type === "Identifier" &&
        right.type === "Identifier" &&
        left.name === right.name
    ) {
        report(right);
    } else if (
        left.type === "ArrayPattern" &&
        right.type === "ArrayExpression"
    ) {
        var end = Math.min(left.elements.length, right.elements.length);
        for (i = 0; i < end; ++i) {
            var rightElement = right.elements[i];

            eachSelfAssignment(left.elements[i], rightElement, report);

            if (rightElement && rightElement.type === "SpreadElement") {
                break;
            }
        }
    } else if (
        left.type === "RestElement" &&
        right.type === "SpreadElement"
    ) {
        eachSelfAssignment(left.argument, right.argument, report);
    } else if (
        left.type === "ObjectPattern" &&
        right.type === "ObjectExpression" &&
        right.properties.length >= 1
    ) {
        var startJ = 0;
        for (i = right.properties.length - 1; i >= 0; --i) {
            if (right.properties[i].type === "ExperimentalSpreadProperty") {
                startJ = i + 1;
                break;
            }
        }

        for (i = 0; i < left.properties.length; ++i) {
            for (j = startJ; j < right.properties.length; ++j) {
                eachSelfAssignment(
                    left.properties[i],
                    right.properties[j],
                    report
                );
            }
        }
    } else if (
        left.type === "Property" &&
        right.type === "Property" &&
        !left.computed &&
        !right.computed &&
        right.kind === "init" &&
        !right.method &&
        left.key.name === right.key.name
    ) {
        eachSelfAssignment(left.value, right.value, report);
    }
}

module.exports = function(context) {
    function report(node) {
        context.report({
            node: node,
            message: "'{{name}}' is assigned to itself.",
            data: node
        });
    }

    return {
        "AssignmentExpression": function(node) {
            if (node.operator === "=") {
                eachSelfAssignment(node.left, node.right, report);
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-self-compare.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "BinaryExpression": function(node) {
            var operators = ["===", "==", "!==", "!=", ">", "<", ">=", "<="];
            if (operators.indexOf(node.operator) > -1 &&
                (node.left.type === "Identifier" && node.right.type === "Identifier" && node.left.name === node.right.name ||
                node.left.type === "Literal" && node.right.type === "Literal" && node.left.value === node.right.value)) {
                context.report(node, "Comparing to itself is potentially pointless.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-sequences.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var parenthesized = {
        "DoWhileStatement": "test",
        "IfStatement": "test",
        "SwitchStatement": "discriminant",
        "WhileStatement": "test",
        "WithStatement": "object"

    };

    function requiresExtraParens(node) {
        return node.parent && parenthesized[node.parent.type] &&
                node === node.parent[parenthesized[node.parent.type]];
    }

    function isParenthesised(node) {
        var previousToken = context.getTokenBefore(node),
            nextToken = context.getTokenAfter(node);

        return previousToken && nextToken &&
            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }

    function isParenthesisedTwice(node) {
        var previousToken = context.getTokenBefore(node, 1),
            nextToken = context.getTokenAfter(node, 1);

        return isParenthesised(node) && previousToken && nextToken &&
            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }

    return {
        "SequenceExpression": function(node) {
            if (node.parent.type === "ForStatement" &&
                    (node === node.parent.init || node === node.parent.update)) {
                return;
            }

            if (requiresExtraParens(node)) {
                if (isParenthesisedTwice(node)) {
                    return;
                }
            } else {
                if (isParenthesised(node)) {
                    return;
                }
            }

            var child = context.getTokenAfter(node.expressions[0]);
            context.report(node, child.loc.start, "Unexpected use of comma operator.");
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-shadow-restricted-names.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var RESTRICTED = ["undefined", "NaN", "Infinity", "arguments", "eval"];

    function checkForViolation(id) {
        if (RESTRICTED.indexOf(id.name) > -1) {
            context.report(id, "Shadowing of global property '" + id.name + "'.");
        }
    }

    return {
        "VariableDeclarator": function(node) {
            checkForViolation(node.id);
        },
        "ArrowFunctionExpression": function(node) {
            [].map.call(node.params, checkForViolation);
        },
        "FunctionExpression": function(node) {
            if (node.id) {
                checkForViolation(node.id);
            }
            [].map.call(node.params, checkForViolation);
        },
        "FunctionDeclaration": function(node) {
            if (node.id) {
                checkForViolation(node.id);
                [].map.call(node.params, checkForViolation);
            }
        },
        "CatchClause": function(node) {
            checkForViolation(node.param);
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-shadow.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var options = {
        builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals),
        hoist: (context.options[0] && context.options[0].hoist) || "functions",
        allow: (context.options[0] && context.options[0].allow) || []
    };

    function isAllowed(variable) {
        return options.allow.indexOf(variable.name) !== -1;
    }

    function isDuplicatedClassNameVariable(variable) {
        var block = variable.scope.block;
        return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
    }

    function isOnInitializer(variable, scopeVar) {
        var outerScope = scopeVar.scope;
        var outerDef = scopeVar.defs[0];
        var outer = outerDef && outerDef.parent && outerDef.parent.range;
        var innerScope = variable.scope;
        var innerDef = variable.defs[0];
        var inner = innerDef && innerDef.name.range;

        return (
            outer &&
            inner &&
            outer[0] < inner[0] &&
            inner[1] < outer[1] &&
            ((innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression") || innerDef.node.type === "ClassExpression") &&
            outerScope === innerScope.upper
        );
    }

    function getNameRange(variable) {
        var def = variable.defs[0];
        return def && def.name.range;
    }

    function isInTdz(variable, scopeVar) {
        var outerDef = scopeVar.defs[0];
        var inner = getNameRange(variable);
        var outer = getNameRange(scopeVar);
        return (
            inner &&
            outer &&
            inner[1] < outer[0] &&
            (options.hoist !== "functions" || !outerDef || outerDef.node.type !== "FunctionDeclaration")
        );
    }

    function checkForShadows(scope) {
        var variables = scope.variables;
        for (var i = 0; i < variables.length; ++i) {
            var variable = variables[i];

            if (variable.identifiers.length === 0 ||
                isDuplicatedClassNameVariable(variable) ||
                isAllowed(variable)
            ) {
                continue;
            }

            var shadowed = astUtils.getVariableByName(scope.upper, variable.name);
            if (shadowed &&
                (shadowed.identifiers.length > 0 || (options.builtinGlobals && "writeable" in shadowed)) &&
                !isOnInitializer(variable, shadowed) &&
                !(options.hoist !== "all" && isInTdz(variable, shadowed))
            ) {
                context.report({
                    node: variable.identifiers[0],
                    message: "'{{name}}' is already declared in the upper scope.",
                    data: variable
                });
            }
        }
    }

    return {
        "Program:exit": function() {
            var globalScope = context.getScope();
            var stack = globalScope.childScopes.slice();
            var scope;

            while (stack.length) {
                scope = stack.pop();
                stack.push.apply(stack, scope.childScopes);
                checkForShadows(scope);
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "builtinGlobals": {"type": "boolean"},
            "hoist": {"enum": ["all", "functions", "never"]},
            "allow": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-spaced-func.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var sourceCode = context.getSourceCode();

    function detectOpenSpaces(node) {
        var lastCalleeToken = sourceCode.getLastToken(node.callee),
            prevToken = lastCalleeToken,
            parenToken = sourceCode.getTokenAfter(lastCalleeToken);

        while (
            parenToken &&
            parenToken.range[1] < node.range[1] &&
            parenToken.value !== "("
        ) {
            prevToken = parenToken;
            parenToken = sourceCode.getTokenAfter(parenToken);
        }

        if (parenToken &&
            parenToken.range[1] < node.range[1] &&
            sourceCode.isSpaceBetweenTokens(prevToken, parenToken)
        ) {
            context.report({
                node: node,
                loc: lastCalleeToken.loc.start,
                message: "Unexpected space between function name and paren.",
                fix: function(fixer) {
                    return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
                }
            });
        }
    }

    return {
        "CallExpression": detectOpenSpaces,
        "NewExpression": detectOpenSpaces
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-sparse-arrays.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {


    return {

        "ArrayExpression": function(node) {

            var emptySpot = node.elements.indexOf(null) > -1;

            if (emptySpot) {
                context.report(node, "Unexpected comma in middle of array.");
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-sync.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "MemberExpression": function(node) {
            var propertyName = node.property.name,
                syncRegex = /.*Sync$/;

            if (syncRegex.exec(propertyName) !== null) {
                context.report(node, "Unexpected sync method: '" + propertyName + "'.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-ternary.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "ConditionalExpression": function(node) {
            context.report(node, "Ternary operator used.");
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-this-before-super.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isConstructorFunction(node) {
    return (
        node.type === "FunctionExpression" &&
        node.parent.type === "MethodDefinition" &&
        node.parent.kind === "constructor"
    );
}

module.exports = function(context) {
    var funcInfo = null;

    var segInfoMap = Object.create(null);

    function isCalled(segment) {
        return segInfoMap[segment.id].superCalled;
    }

    function isInConstructorOfDerivedClass() {
        return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
    }

    function isBeforeCallOfSuper() {
        return (
            isInConstructorOfDerivedClass(funcInfo) &&
            !funcInfo.codePath.currentSegments.every(isCalled)
        );
    }

    function setInvalid(node) {
        var segments = funcInfo.codePath.currentSegments;
        for (var i = 0; i < segments.length; ++i) {
            segInfoMap[segments[i].id].invalidNodes.push(node);
        }
    }

    function setSuperCalled() {
        var segments = funcInfo.codePath.currentSegments;
        for (var i = 0; i < segments.length; ++i) {
            segInfoMap[segments[i].id].superCalled = true;
        }
    }

    return {
        "onCodePathStart": function(codePath, node) {
            if (isConstructorFunction(node)) {
                var classNode = node.parent.parent.parent;
                funcInfo = {
                    upper: funcInfo,
                    isConstructor: true,
                    hasExtends: Boolean(
                        classNode.superClass &&
                        !astUtils.isNullOrUndefined(classNode.superClass)
                    ),
                    codePath: codePath
                };
            } else {
                funcInfo = {
                    upper: funcInfo,
                    isConstructor: false,
                    hasExtends: false,
                    codePath: codePath
                };
            }
        },

        "onCodePathEnd": function(codePath) {
            var isDerivedClass = funcInfo.hasExtends;
            funcInfo = funcInfo.upper;
            if (!isDerivedClass) {
                return;
            }

            codePath.traverseSegments(function(segment, controller) {
                var info = segInfoMap[segment.id];

                for (var i = 0; i < info.invalidNodes.length; ++i) {
                    var invalidNode = info.invalidNodes[i];

                    context.report({
                        message: "'{{kind}}' is not allowed before 'super()'.",
                        node: invalidNode,
                        data: {
                            kind: invalidNode.type === "Super" ? "super" : "this"
                        }
                    });
                }

                if (info.superCalled) {
                    controller.skip();
                }
            });
        },

        "onCodePathSegmentStart": function(segment) {
            if (!isInConstructorOfDerivedClass(funcInfo)) {
                return;
            }

            segInfoMap[segment.id] = {
                superCalled: (
                    segment.prevSegments.length > 0 &&
                    segment.prevSegments.every(isCalled)
                ),
                invalidNodes: []
            };
        },

        "onCodePathSegmentLoop": function(fromSegment, toSegment) {
            if (!isInConstructorOfDerivedClass(funcInfo)) {
                return;
            }

            funcInfo.codePath.traverseSegments(
                {first: toSegment, last: fromSegment},
                function(segment, controller) {
                    var info = segInfoMap[segment.id];
                    if (info.superCalled) {
                        info.invalidNodes = [];
                        controller.skip();
                    } else if (
                        segment.prevSegments.length > 0 &&
                        segment.prevSegments.every(isCalled)
                    ) {
                        info.superCalled = true;
                        info.invalidNodes = [];
                    }
                }
            );
        },

        "ThisExpression": function(node) {
            if (isBeforeCallOfSuper()) {
                setInvalid(node);
            }
        },

        "Super": function(node) {
            if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {
                setInvalid(node);
            }
        },

        "CallExpression:exit": function(node) {
            if (node.callee.type === "Super" && isBeforeCallOfSuper()) {
                setSuperCalled();
            }
        },

        "Program:exit": function() {
            segInfoMap = Object.create(null);
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-throw-literal.js": [function(require,module,exports){
"use strict";

function couldBeError(node) {
    switch (node.type) {
        case "Identifier":
        case "CallExpression":
        case "NewExpression":
        case "MemberExpression":
        case "TaggedTemplateExpression":
        case "YieldExpression":
            return true; // possibly an error object.

        case "AssignmentExpression":
            return couldBeError(node.right);

        case "SequenceExpression":
            var exprs = node.expressions;
            return exprs.length !== 0 && couldBeError(exprs[exprs.length - 1]);

        case "LogicalExpression":
            return couldBeError(node.left) || couldBeError(node.right);

        case "ConditionalExpression":
            return couldBeError(node.consequent) || couldBeError(node.alternate);

        default:
            return false;
    }
}

module.exports = function(context) {

    return {

        "ThrowStatement": function(node) {
            if (!couldBeError(node.argument)) {
                context.report(node, "Expected an object to be thrown.");
            } else if (node.argument.type === "Identifier") {
                if (node.argument.name === "undefined") {
                    context.report(node, "Do not throw undefined.");
                }
            }

        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-trailing-spaces.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var BLANK_CLASS = "[ \t\u00a0\u2000-\u200b\u2028\u2029\u3000]",
        SKIP_BLANK = "^" + BLANK_CLASS + "*$",
        NONBLANK = BLANK_CLASS + "+$";

    var options = context.options[0] || {},
        skipBlankLines = options.skipBlankLines || false;

    function report(node, location, fixRange) {
        context.report({
            node: node,
            loc: location,
            message: "Trailing spaces not allowed.",
            fix: function(fixer) {
                return fixer.removeRange(fixRange);
            }
        });
    }


    return {

        "Program": function checkTrailingSpaces(node) {

            var src = context.getSource(),
                re = new RegExp(NONBLANK),
                skipMatch = new RegExp(SKIP_BLANK),
                matches, lines = src.split(/\r?\n/),
                linebreaks = context.getSource().match(/\r\n|\r|\n|\u2028|\u2029/g),
                location,
                totalLength = 0,
                fixRange = [];

            for (var i = 0, ii = lines.length; i < ii; i++) {
                matches = re.exec(lines[i]);

                var linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;
                var lineLength = lines[i].length + linebreakLength;

                if (matches) {

                    if (skipBlankLines && skipMatch.test(lines[i])) {
                        continue;
                    }
                    location = {
                        line: i,
                        column: matches.index
                    };

                    fixRange = [totalLength + location.column, totalLength + lineLength - linebreakLength];

                    report(node, location, fixRange);
                }

                totalLength += lineLength;
            }
        }

    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "skipBlankLines": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-undef-init.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "VariableDeclarator": function(node) {
            var name = node.id.name,
                init = node.init && node.init.name;

            if (init === "undefined" && node.parent.kind !== "const") {
                context.report(node, "It's not necessary to initialize '{{name}}' to undefined.", { name: name });
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-undef.js": [function(require,module,exports){
"use strict";

function hasTypeOfOperator(node) {
    var parent = node.parent;
    return parent.type === "UnaryExpression" && parent.operator === "typeof";
}

module.exports = function(context) {
    var options = context.options[0];
    var considerTypeOf = options && options.typeof === true || false;

    return {
        "Program:exit": function(/* node */) {
            var globalScope = context.getScope();

            globalScope.through.forEach(function(ref) {
                var identifier = ref.identifier;

                if (!considerTypeOf && hasTypeOfOperator(identifier)) {
                    return;
                }

                context.report({
                    node: identifier,
                    message: "'{{name}}' is not defined.",
                    data: identifier
                });
            });
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "typeof": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-undefined.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Identifier": function(node) {
            if (node.name === "undefined") {
                var parent = context.getAncestors().pop();
                if (!parent || parent.type !== "MemberExpression" || node !== parent.property || parent.computed) {
                    context.report(node, "Unexpected use of undefined.");
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-underscore-dangle.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var options = context.options[0] || {};
    var ALLOWED_VARIABLES = options.allow ? options.allow : [];
    var allowAfterThis = typeof options.allowAfterThis !== "undefined" ? options.allowAfterThis : false;

    function isAllowed(identifier) {
        return ALLOWED_VARIABLES.some(function(ident) {
            return ident === identifier;
        });
    }

    function hasTrailingUnderscore(identifier) {
        var len = identifier.length;

        return identifier !== "_" && (identifier[0] === "_" || identifier[len - 1] === "_");
    }

    function isSpecialCaseIdentifierForMemberExpression(identifier) {
        return identifier === "__proto__";
    }

    function isSpecialCaseIdentifierInVariableExpression(identifier) {
        return identifier === "_";
    }

    function checkForTrailingUnderscoreInFunctionDeclaration(node) {
        if (node.id) {
            var identifier = node.id.name;

            if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !isAllowed(identifier)) {
                context.report(node, "Unexpected dangling '_' in '" + identifier + "'.");
            }
        }
    }

    function checkForTrailingUnderscoreInVariableExpression(node) {
        var identifier = node.id.name;

        if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) &&
            !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {
            context.report(node, "Unexpected dangling '_' in '" + identifier + "'.");
        }
    }

    function checkForTrailingUnderscoreInMemberExpression(node) {
        var identifier = node.property.name,
            isMemberOfThis = node.object.type === "ThisExpression";

        if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) &&
            !(isMemberOfThis && allowAfterThis) &&
            !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {
            context.report(node, "Unexpected dangling '_' in '" + identifier + "'.");
        }
    }

    return {
        "FunctionDeclaration": checkForTrailingUnderscoreInFunctionDeclaration,
        "VariableDeclarator": checkForTrailingUnderscoreInVariableExpression,
        "MemberExpression": checkForTrailingUnderscoreInMemberExpression
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allow": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "allowAfterThis": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-unexpected-multiline.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var FUNCTION_MESSAGE = "Unexpected newline between function and ( of function call.";
    var PROPERTY_MESSAGE = "Unexpected newline between object and [ of property access.";
    var TAGGED_TEMPLATE_MESSAGE = "Unexpected newline between template tag and template literal.";

    function checkForBreakAfter(node, msg) {
        var nodeExpressionEnd = node;
        var openParen = context.getTokenAfter(node);

        while (openParen.value === ")") {
            nodeExpressionEnd = openParen;
            openParen = context.getTokenAfter(nodeExpressionEnd);
        }

        if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {
            context.report(node, openParen.loc.start, msg, { char: openParen.value });
        }
    }

    return {

        "MemberExpression": function(node) {
            if (!node.computed) {
                return;
            }
            checkForBreakAfter(node.object, PROPERTY_MESSAGE);
        },

        "TaggedTemplateExpression": function(node) {
            if (node.tag.loc.end.line === node.quasi.loc.start.line) {
                return;
            }
            context.report(node, node.loc.start, TAGGED_TEMPLATE_MESSAGE);
        },

        "CallExpression": function(node) {
            if (node.arguments.length === 0) {
                return;
            }
            checkForBreakAfter(node.callee, FUNCTION_MESSAGE);
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-unmodified-loop-condition.js": [function(require,module,exports){
"use strict";

var Map = require("es6-map"),
    espree = require("espree"),
    estraverse = require("estraverse"),
    astUtils = require("../ast-utils");

var pushAll = Function.apply.bind(Array.prototype.push);
var SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/;
var LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/;
var GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/;
var SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/;
var DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/;

function isWriteReference(reference) {
    if (reference.init) {
        var def = reference.resolved && reference.resolved.defs[0];
        if (!def || def.type !== "Variable" || def.parent.kind !== "var") {
            return false;
        }
    }
    return reference.isWrite();
}

function isUnmodified(condition) {
    return !condition.modified;
}

function isUnmodifiedAndNotBelongToGroup(condition) {
    return !condition.modified && condition.groups.length === 0;
}

function isInRange(node, reference) {
    var or = node.range;
    var ir = reference.identifier.range;
    return or[0] <= ir[0] && ir[1] <= or[1];
}

var isInLoop = {
    WhileStatement: isInRange,
    DoWhileStatement: isInRange,
    ForStatement: function(node, reference) {
        return (
            isInRange(node, reference) &&
            !(node.init && isInRange(node.init, reference))
        );
    }
};

function hasDynamicExpressions(root) {
    var retv = false;

    estraverse.traverse(root, {
        enter: function(node) {
            if (DYNAMIC_PATTERN.test(node.type)) {
                retv = true;
                this.break();
            } else if (SKIP_PATTERN.test(node.type)) {
                this.skip();
            }
        },
        keys: espree.VisitorKeys
    });

    return retv;
}

function toLoopCondition(reference) {
    if (reference.init) {
        return null;
    }

    var groups = [];
    var child = reference.identifier;
    var node = child.parent;
    while (node) {
        if (SENTINEL_PATTERN.test(node.type)) {
            if (LOOP_PATTERN.test(node.type) && node.test === child) {
                return {
                    reference: reference,
                    groups: groups,
                    isInLoop: isInLoop[node.type].bind(null, node),
                    modified: false
                };
            }
            break;
        }

        if (GROUP_PATTERN.test(node.type)) {
            if (hasDynamicExpressions(node)) {
                break;
            } else {
                groups.push(node);
            }
        }

        child = node;
        node = node.parent;
    }

    return null;
}

function getEncloseFunctionDeclaration(reference) {
    var node = reference.identifier;

    while (node) {
        if (node.type === "FunctionDeclaration") {
            return node.id ? node : null;
        }

        node = node.parent;
    }

    return null;
}

function updateModifiedFlag(conditions, modifiers) {
    var funcNode, funcVar;

    for (var i = 0; i < conditions.length; ++i) {
        var condition = conditions[i];

        for (var j = 0; !condition.modified && j < modifiers.length; ++j) {
            var modifier = modifiers[j];
            var inLoop = condition.isInLoop(modifier) || Boolean(
                (funcNode = getEncloseFunctionDeclaration(modifier)) &&
                (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) &&
                funcVar.references.some(condition.isInLoop)
            );
            condition.modified = inLoop;
        }
    }
}

module.exports = function(context) {
    var groupMap = null;

    function report(condition) {
        var node = condition.reference.identifier;

        context.report({
            node: node,
            message: "'{{name}}' is not modified in this loop.",
            data: node
        });
    }

    function registerConditionsToGroup(conditions) {
        for (var i = 0; i < conditions.length; ++i) {
            var condition = conditions[i];

            for (var j = 0; j < condition.groups.length; ++j) {
                var be = condition.groups[j];
                var group = groupMap.get(be);
                if (!group) {
                    group = [];
                    groupMap.set(be, group);
                }
                group.push(condition);
            }
        }
    }

    function checkConditionsInGroup(conditions) {
        if (conditions.every(isUnmodified)) {
            conditions.forEach(report);
        }
    }

    function checkReferences(variable) {
        var conditions = variable
            .references
            .map(toLoopCondition)
            .filter(Boolean);

        if (conditions.length === 0) {
            return;
        }

        registerConditionsToGroup(conditions);

        var modifiers = variable.references.filter(isWriteReference);
        if (modifiers.length > 0) {
            updateModifiedFlag(conditions, modifiers);
        }

        conditions
            .filter(isUnmodifiedAndNotBelongToGroup)
            .forEach(report);
    }

    return {
        "Program:exit": function() {
            var queue = [context.getScope()];
            groupMap = new Map();

            var scope;
            while ((scope = queue.pop())) {
                pushAll(queue, scope.childScopes);
                scope.variables.forEach(checkReferences);
            }

            groupMap.forEach(checkConditionsInGroup);
            groupMap = null;
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js","es6-map":"/node_modules/es6-map/index.js","espree":"espree","estraverse":"/node_modules/estraverse/estraverse.js"}],

"/tmp/rules/no-unneeded-ternary.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var options = context.options[0] || {};
    var defaultAssignment = options.defaultAssignment !== false;

    function isBooleanLiteral(node) {
        return node.type === "Literal" && typeof node.value === "boolean";
    }

    function matchesDefaultAssignment(node) {
        return node.test.type === "Identifier" &&
               node.consequent.type === "Identifier" &&
               node.test.name === node.consequent.name;
    }

    return {

        "ConditionalExpression": function(node) {
            if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {
                context.report(node, node.consequent.loc.start, "Unnecessary use of boolean literals in conditional expression");
            } else if (!defaultAssignment && matchesDefaultAssignment(node)) {
                context.report(node, node.consequent.loc.start, "Unnecessary use of conditional expression for default assignment");
            }
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "defaultAssignment": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-unreachable.js": [function(require,module,exports){
"use strict";

function isInitialized(node) {
    return Boolean(node.init);
}

function isUnreachable(segment) {
    return !segment.reachable;
}

module.exports = function(context) {
    var currentCodePath = null;

    function reportIfUnreachable(node) {
        if (currentCodePath.currentSegments.every(isUnreachable)) {
            context.report({message: "Unreachable code.", node: node});
        }
    }

    return {
        "onCodePathStart": function(codePath) {
            currentCodePath = codePath;
        },
        "onCodePathEnd": function() {
            currentCodePath = currentCodePath.upper;
        },

        BlockStatement: reportIfUnreachable,
        BreakStatement: reportIfUnreachable,
        ClassDeclaration: reportIfUnreachable,
        ContinueStatement: reportIfUnreachable,
        DebuggerStatement: reportIfUnreachable,
        DoWhileStatement: reportIfUnreachable,
        EmptyStatement: reportIfUnreachable,
        ExpressionStatement: reportIfUnreachable,
        ForInStatement: reportIfUnreachable,
        ForOfStatement: reportIfUnreachable,
        ForStatement: reportIfUnreachable,
        IfStatement: reportIfUnreachable,
        ImportDeclaration: reportIfUnreachable,
        LabeledStatement: reportIfUnreachable,
        ReturnStatement: reportIfUnreachable,
        SwitchStatement: reportIfUnreachable,
        ThrowStatement: reportIfUnreachable,
        TryStatement: reportIfUnreachable,
        VariableDeclaration: function(node) {
            if (node.kind !== "var" || node.declarations.some(isInitialized)) {
                reportIfUnreachable(node);
            }
        },
        WhileStatement: reportIfUnreachable,
        WithStatement: reportIfUnreachable,
        ExportNamedDeclaration: reportIfUnreachable,
        ExportDefaultDeclaration: reportIfUnreachable,
        ExportAllDeclaration: reportIfUnreachable
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-unused-expressions.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var config = context.options[0] || {},
        allowShortCircuit = config.allowShortCircuit || false,
        allowTernary = config.allowTernary || false;

    function looksLikeDirective(node) {
        return node.type === "ExpressionStatement" &&
            node.expression.type === "Literal" && typeof node.expression.value === "string";
    }

    function takeWhile(predicate, list) {
        for (var i = 0, l = list.length; i < l; ++i) {
            if (!predicate(list[i])) {
                break;
            }
        }
        return [].slice.call(list, 0, i);
    }

    function directives(node) {
        return takeWhile(looksLikeDirective, node.body);
    }

    function isDirective(node, ancestors) {
        var parent = ancestors[ancestors.length - 1],
            grandparent = ancestors[ancestors.length - 2];
        return (parent.type === "Program" || parent.type === "BlockStatement" &&
                (/Function/.test(grandparent.type))) &&
                directives(parent).indexOf(node) >= 0;
    }

    function isValidExpression(node) {
        if (allowTernary) {
            if (node.type === "ConditionalExpression") {
                return isValidExpression(node.consequent) && isValidExpression(node.alternate);
            }
        }
        if (allowShortCircuit) {
            if (node.type === "LogicalExpression") {
                return isValidExpression(node.right);
            }
        }

        return /^(?:Assignment|Call|New|Update|Yield)Expression$/.test(node.type) ||
            (node.type === "UnaryExpression" && ["delete", "void"].indexOf(node.operator) >= 0);
    }

    return {
        "ExpressionStatement": function(node) {
            if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {
                context.report(node, "Expected an assignment or function call and instead saw an expression.");
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allowShortCircuit": {
                "type": "boolean"
            },
            "allowTernary": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-unused-labels.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var scopeInfo = null;

    function enterLabeledScope(node) {
        scopeInfo = {
            label: node.label.name,
            used: false,
            upper: scopeInfo
        };
    }

    function exitLabeledScope(node) {
        if (!scopeInfo.used) {
            context.report({
                node: node.label,
                message: "'{{name}}:' is defined but never used.",
                data: node.label
            });
        }

        scopeInfo = scopeInfo.upper;
    }

    function markAsUsed(node) {
        if (!node.label) {
            return;
        }

        var label = node.label.name;
        var info = scopeInfo;
        while (info) {
            if (info.label === label) {
                info.used = true;
                break;
            }
            info = info.upper;
        }
    }

    return {
        "LabeledStatement": enterLabeledScope,
        "LabeledStatement:exit": exitLabeledScope,
        "BreakStatement": markAsUsed,
        "ContinueStatement": markAsUsed
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-unused-vars.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

module.exports = function(context) {

    var MESSAGE = "'{{name}}' is defined but never used";

    var config = {
        vars: "all",
        args: "after-used"
    };

    var firstOption = context.options[0];

    if (firstOption) {
        if (typeof firstOption === "string") {
            config.vars = firstOption;
        } else {
            config.vars = firstOption.vars || config.vars;
            config.args = firstOption.args || config.args;

            if (firstOption.varsIgnorePattern) {
                config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern);
            }

            if (firstOption.argsIgnorePattern) {
                config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern);
            }
        }
    }

    function isExported(variable) {

        var definition = variable.defs[0];

        if (definition) {

            var node = definition.node;
            if (node.type === "VariableDeclarator") {
                node = node.parent;
            } else if (definition.type === "Parameter") {
                return false;
            }

            return node.parent.type.indexOf("Export") === 0;
        } else {
            return false;
        }
    }

    function isReadRef(ref) {
        return ref.isRead();
    }

    function isSelfReference(ref, nodes) {
        var scope = ref.from;

        while (scope) {
            if (nodes.indexOf(scope.block) >= 0) {
                return true;
            }

            scope = scope.upper;
        }

        return false;
    }

    function isUsedVariable(variable) {
        var functionNodes = variable.defs.filter(function(def) {
                return def.type === "FunctionName";
            }).map(function(def) {
                return def.node;
            }),
            isFunctionDefinition = functionNodes.length > 0;

        return variable.references.some(function(ref) {
            return isReadRef(ref) && !(isFunctionDefinition && isSelfReference(ref, functionNodes));
        });
    }

    function collectUnusedVariables(scope, unusedVars) {
        var variables = scope.variables;
        var childScopes = scope.childScopes;
        var i, l;

        if (scope.type !== "TDZ" && (scope.type !== "global" || config.vars === "all")) {
            for (i = 0, l = variables.length; i < l; ++i) {
                var variable = variables[i];

                if (scope.type === "class" && scope.block.id === variable.identifiers[0]) {
                    continue;
                }
                if (scope.functionExpressionScope || variable.eslintUsed) {
                    continue;
                }
                if (scope.type === "function" && variable.name === "arguments" && variable.identifiers.length === 0) {
                    continue;
                }

                var def = variable.defs[0];
                if (def) {
                    var type = def.type;

                    if (type === "CatchClause") {
                        continue;
                    }

                    if (type === "Parameter") {
                        if (def.node.parent.type === "Property" && def.node.parent.kind === "set") {
                            continue;
                        }

                        if (config.args === "none") {
                            continue;
                        }

                        if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {
                            continue;
                        }

                        if (config.args === "after-used" && def.index < def.node.params.length - 1) {
                            continue;
                        }
                    } else {
                        if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {
                            continue;
                        }
                    }
                }

                if (!isUsedVariable(variable) && !isExported(variable)) {
                    unusedVars.push(variable);
                }
            }
        }

        for (i = 0, l = childScopes.length; i < l; ++i) {
            collectUnusedVariables(childScopes[i], unusedVars);
        }

        return unusedVars;
    }

    function getColumnInComment(variable, comment) {
        var namePattern = new RegExp("[\\s,]" + lodash.escapeRegExp(variable.name) + "(?:$|[\\s,:])", "g");

        namePattern.lastIndex = comment.value.indexOf("global") + 6;

        var match = namePattern.exec(comment.value);
        return match ? match.index + 1 : 0;
    }

    function getLocation(variable) {
        var comment = variable.eslintExplicitGlobalComment;
        var baseLoc = comment.loc.start;
        var column = getColumnInComment(variable, comment);
        var prefix = comment.value.slice(0, column);
        var lineInComment = (prefix.match(/\n/g) || []).length;

        if (lineInComment > 0) {
            column -= 1 + prefix.lastIndexOf("\n");
        } else {
            column += baseLoc.column + 2;
        }

        return {
            line: baseLoc.line + lineInComment,
            column: column
        };
    }

    return {
        "Program:exit": function(programNode) {
            var unusedVars = collectUnusedVariables(context.getScope(), []);

            for (var i = 0, l = unusedVars.length; i < l; ++i) {
                var unusedVar = unusedVars[i];

                if (unusedVar.eslintExplicitGlobal) {
                    context.report({
                        node: programNode,
                        loc: getLocation(unusedVar),
                        message: MESSAGE,
                        data: unusedVar
                    });
                } else if (unusedVar.defs.length > 0) {
                    context.report({
                        node: unusedVar.identifiers[0],
                        message: MESSAGE,
                        data: unusedVar
                    });
                }
            }
        }
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["all", "local"]
            },
            {
                "type": "object",
                "properties": {
                    "vars": {
                        "enum": ["all", "local"]
                    },
                    "varsIgnorePattern": {
                        "type": "string"
                    },
                    "args": {
                        "enum": ["all", "after-used", "none"]
                    },
                    "argsIgnorePattern": {
                        "type": "string"
                    }
                }
            }
        ]
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/no-use-before-define.js": [function(require,module,exports){
"use strict";

var SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;

function parseOptions(options) {
    var functions = true;
    var classes = true;

    if (typeof options === "string") {
        functions = (options !== "nofunc");
    } else if (typeof options === "object" && options !== null) {
        functions = options.functions !== false;
        classes = options.classes !== false;
    }

    return {functions: functions, classes: classes};
}

function alwaysFalse() {
    return false;
}

function isFunction(variable) {
    return variable.defs[0].type === "FunctionName";
}

function isOuterClass(variable, reference) {
    return (
        variable.defs[0].type === "ClassName" &&
        variable.scope.variableScope !== reference.from.variableScope
    );
}

function isFunctionOrOuterClass(variable, reference) {
    return isFunction(variable, reference) || isOuterClass(variable, reference);
}

function isInRange(node, location) {
    return node && node.range[0] <= location && location <= node.range[1];
}

function isInInitializer(variable, reference) {
    if (variable.scope !== reference.from) {
        return false;
    }

    var node = variable.identifiers[0].parent;
    var location = reference.identifier.range[1];

    while (node) {
        if (node.type === "VariableDeclarator") {
            if (isInRange(node.init, location)) {
                return true;
            }
            break;
        } else if (node.type === "AssignmentPattern") {
            if (isInRange(node.right, location)) {
                return true;
            }
        } else if (SENTINEL_TYPE.test(node.type)) {
            break;
        }

        node = node.parent;
    }

    return false;
}

module.exports = function(context) {
    var options = parseOptions(context.options[0]);

    var isAllowed;
    if (options.functions && options.classes) {
        isAllowed = alwaysFalse;
    } else if (options.functions) {
        isAllowed = isOuterClass;
    } else if (options.classes) {
        isAllowed = isFunction;
    } else {
        isAllowed = isFunctionOrOuterClass;
    }

    function findVariablesInScope(scope) {
        scope.references.forEach(function(reference) {
            var variable = reference.resolved;

            if (reference.init ||
                !variable ||
                variable.identifiers.length === 0 ||
                (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||
                isAllowed(variable, reference)
            ) {
                return;
            }

            context.report({
                node: reference.identifier,
                message: "'{{name}}' was used before it was defined",
                data: reference.identifier
            });
        });
    }

    function findVariables() {
        var scope = context.getScope();
        findVariablesInScope(scope);
    }

    var ruleDefinition = {
        "Program:exit": function(node) {
            var scope = context.getScope(),
                ecmaFeatures = context.parserOptions.ecmaFeatures || {};

            findVariablesInScope(scope);

            if (ecmaFeatures.globalReturn || node.sourceType === "module") {
                findVariablesInScope(scope.childScopes[0]);
            }
        }
    };

    if (context.parserOptions.ecmaVersion >= 6) {
        ruleDefinition["BlockStatement:exit"] =
            ruleDefinition["SwitchStatement:exit"] = findVariables;

        ruleDefinition["ArrowFunctionExpression:exit"] = function(node) {
            if (node.body.type !== "BlockStatement") {
                findVariables(node);
            }
        };
    } else {
        ruleDefinition["FunctionExpression:exit"] =
            ruleDefinition["FunctionDeclaration:exit"] =
            ruleDefinition["ArrowFunctionExpression:exit"] = findVariables;
    }

    return ruleDefinition;
};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["nofunc"]
            },
            {
                "type": "object",
                "properties": {
                    "functions": {"type": "boolean"},
                    "classes": {"type": "boolean"}
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/no-useless-call.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isCallOrNonVariadicApply(node) {
    return (
        node.callee.type === "MemberExpression" &&
        node.callee.property.type === "Identifier" &&
        node.callee.computed === false &&
        (
            (node.callee.property.name === "call" && node.arguments.length >= 1) ||
            (node.callee.property.name === "apply" && node.arguments.length === 2 && node.arguments[1].type === "ArrayExpression")
        )
    );
}

function equalTokens(left, right, context) {
    var tokensL = context.getTokens(left);
    var tokensR = context.getTokens(right);

    if (tokensL.length !== tokensR.length) {
        return false;
    }
    for (var i = 0; i < tokensL.length; ++i) {
        if (tokensL[i].type !== tokensR[i].type ||
            tokensL[i].value !== tokensR[i].value
        ) {
            return false;
        }
    }

    return true;
}

function isValidThisArg(expectedThis, thisArg, context) {
    if (!expectedThis) {
        return astUtils.isNullOrUndefined(thisArg);
    }
    return equalTokens(expectedThis, thisArg, context);
}

module.exports = function(context) {
    return {
        "CallExpression": function(node) {
            if (!isCallOrNonVariadicApply(node)) {
                return;
            }

            var applied = node.callee.object;
            var expectedThis = (applied.type === "MemberExpression") ? applied.object : null;
            var thisArg = node.arguments[0];

            if (isValidThisArg(expectedThis, thisArg, context)) {
                context.report(
                    node,
                    "unnecessary '.{{name}}()'.",
                    {name: node.callee.property.name});
            }
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-useless-concat.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isConcatenation(node) {
    return node.type === "BinaryExpression" && node.operator === "+";
}

function getLeft(node) {
    var left = node.left;
    while (isConcatenation(left)) {
        left = left.right;
    }
    return left;
}

function getRight(node) {
    var right = node.right;
    while (isConcatenation(right)) {
        right = right.left;
    }
    return right;
}

module.exports = function(context) {
    return {
        BinaryExpression: function(node) {
            if (node.operator !== "+") {
                return;
            }

            var left = getLeft(node);
            var right = getRight(node);

            if (astUtils.isStringLiteral(left) &&
                astUtils.isStringLiteral(right) &&
                astUtils.isTokenOnSameLine(left, right)
            ) {
                var operatorToken = context.getTokenAfter(left);
                while (operatorToken.value !== "+") {
                    operatorToken = context.getTokenAfter(operatorToken);
                }

                context.report(
                    node,
                    operatorToken.loc.start,
                    "Unexpected string concatenation of literals.");
            }
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-useless-constructor.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isRedundantSuperCall(body, ctorParams) {
        if (body.length !== 1 ||
            body[0].type !== "ExpressionStatement" ||
            body[0].expression.callee.type !== "Super") {
            return false;
        }

        var superArgs = body[0].expression.arguments;
        var firstSuperArg = superArgs[0];
        var lastSuperArgIndex = superArgs.length - 1;
        var lastSuperArg = superArgs[lastSuperArgIndex];
        var isSimpleParameterList = ctorParams.every(function(param) {
            return param.type === "Identifier" || param.type === "RestElement";
        });

        function isSameIdentifier(arg, index) {
            return (
                arg.type === "Identifier" &&
                arg.name === ctorParams[index].name
            );
        }

        var spreadsArguments =
            superArgs.length === 1 &&
            firstSuperArg.type === "SpreadElement" &&
            firstSuperArg.argument.name === "arguments";

        var passesParamsAsArgs =
            superArgs.length === ctorParams.length &&
            superArgs.every(isSameIdentifier) ||
            superArgs.length <= ctorParams.length &&
            superArgs.slice(0, -1).every(isSameIdentifier) &&
            lastSuperArg.type === "SpreadElement" &&
            ctorParams[lastSuperArgIndex].type === "RestElement" &&
            lastSuperArg.argument.name === ctorParams[lastSuperArgIndex].argument.name;

        return isSimpleParameterList && (spreadsArguments || passesParamsAsArgs);
    }

    function checkForConstructor(node) {
        if (node.kind !== "constructor") {
            return;
        }

        var body = node.value.body.body;

        if (!node.parent.parent.superClass && body.length === 0 ||
            node.parent.parent.superClass && isRedundantSuperCall(body, node.value.params)) {
            context.report(node, "Useless constructor.");
        }
    }


    return {
        "MethodDefinition": checkForConstructor
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-var.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "VariableDeclaration": function(node) {
            if (node.kind === "var") {
                context.report(node, "Unexpected var, use let or const instead.");
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-void.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "UnaryExpression": function(node) {
            if (node.operator === "void") {
                context.report(node, "Expected 'undefined' and instead saw 'void'.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-warning-comments.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var configuration = context.options[0] || {},
        warningTerms = configuration.terms || ["todo", "fixme", "xxx"],
        location = configuration.location || "start",
        selfConfigRegEx = /\bno-warning-comments\b/,
        warningRegExps;

    function convertToRegExp(term) {
        var escaped = term.replace(/[-\/\\$\^*+?.()|\[\]{}]/g, "\\$&"),
            suffix = /\w$/.test(term) ? "\\b" : "",
            prefix;

        if (location === "start") {
            prefix = "^\\s*";
        } else if (/^\w/.test(term)) {
            prefix = "\\b";
        } else {
            prefix = "";
        }

        return new RegExp(prefix + escaped + suffix, "i");
    }

    function commentContainsWarningTerm(comment) {
        var matches = [];

        warningRegExps.forEach(function(regex, index) {
            if (regex.test(comment)) {
                matches.push(warningTerms[index]);
            }
        });

        return matches;
    }

    function checkComment(node) {
        if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {
            return;
        }

        var matches = commentContainsWarningTerm(node.value);

        matches.forEach(function(matchedTerm) {
            context.report(node, "Unexpected '" + matchedTerm + "' comment.");
        });
    }

    warningRegExps = warningTerms.map(convertToRegExp);
    return {
        "BlockComment": checkComment,
        "LineComment": checkComment
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "terms": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "location": {
                "enum": ["start", "anywhere"]
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-whitespace-before-property.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    var sourceCode = context.getSourceCode();

    function findOpeningBracket(node) {
        var token = sourceCode.getTokenBefore(node.property);

        while (token.value !== "[") {
            token = sourceCode.getTokenBefore(token);
        }
        return token;
    }

    function reportError(node) {
        context.report({
            node: node,
            message: "Unexpected whitespace before property {{propName}}.",
            data: {
                propName: sourceCode.getText(node.property)
            }
        });
    }

    return {
        MemberExpression: function(node) {
            var rightToken;
            var leftToken;

            if (!astUtils.isTokenOnSameLine(node.object, node.property)) {
                return;
            }

            if (node.computed) {
                rightToken = findOpeningBracket(node);
                leftToken = sourceCode.getTokenBefore(rightToken);
            } else {
                rightToken = sourceCode.getFirstToken(node.property);
                leftToken = sourceCode.getTokenBefore(rightToken, 1);
            }

            if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
                reportError(node);
            }
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-with.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "WithStatement": function(node) {
            context.report(node, "Unexpected use of 'with' statement.");
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/object-curly-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    var spaced = context.options[0] === "always",
        sourceCode = context.getSourceCode();

    function isOptionSet(option) {
        return context.options[1] ? context.options[1][option] === !spaced : false;
    }

    var options = {
        spaced: spaced,
        arraysInObjectsException: isOptionSet("arraysInObjects"),
        objectsInObjectsException: isOptionSet("objectsInObjects")
    };

    function reportNoBeginningSpace(node, token) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "There should be no space after '" + token.value + "'",
            fix: function(fixer) {
                var nextToken = context.getSourceCode().getTokenAfter(token);
                return fixer.removeRange([token.range[1], nextToken.range[0]]);
            }
        });
    }

    function reportNoEndingSpace(node, token) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "There should be no space before '" + token.value + "'",
            fix: function(fixer) {
                var previousToken = context.getSourceCode().getTokenBefore(token);
                return fixer.removeRange([previousToken.range[1], token.range[0]]);
            }
        });
    }

    function reportRequiredBeginningSpace(node, token) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "A space is required after '" + token.value + "'",
            fix: function(fixer) {
                return fixer.insertTextAfter(token, " ");
            }
        });
    }

    function reportRequiredEndingSpace(node, token) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "A space is required before '" + token.value + "'",
            fix: function(fixer) {
                return fixer.insertTextBefore(token, " ");
            }
        });
    }

    function validateBraceSpacing(node, first, second, penultimate, last) {
        var closingCurlyBraceMustBeSpaced =
            options.arraysInObjectsException && penultimate.value === "]" ||
            options.objectsInObjectsException && penultimate.value === "}"
                ? !options.spaced : options.spaced,
            firstSpaced, lastSpaced;

        if (astUtils.isTokenOnSameLine(first, second)) {
            firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);
            if (options.spaced && !firstSpaced) {
                reportRequiredBeginningSpace(node, first);
            }
            if (!options.spaced && firstSpaced) {
                reportNoBeginningSpace(node, first);
            }
        }

        if (astUtils.isTokenOnSameLine(penultimate, last)) {
            lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);
            if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
                reportRequiredEndingSpace(node, last);
            }
            if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
                reportNoEndingSpace(node, last);
            }
        }
    }

    function checkForObject(node) {
        if (node.properties.length === 0) {
            return;
        }

        var first = sourceCode.getFirstToken(node),
            last = sourceCode.getLastToken(node),
            second = sourceCode.getTokenAfter(first),
            penultimate = sourceCode.getTokenBefore(last);

        validateBraceSpacing(node, first, second, penultimate, last);
    }

    function checkForImport(node) {
        if (node.specifiers.length === 0) {
            return;
        }

        var firstSpecifier = node.specifiers[0],
            lastSpecifier = node.specifiers[node.specifiers.length - 1];

        if (lastSpecifier.type !== "ImportSpecifier") {
            return;
        }
        if (firstSpecifier.type !== "ImportSpecifier") {
            firstSpecifier = node.specifiers[1];
        }

        var first = sourceCode.getTokenBefore(firstSpecifier),
            last = sourceCode.getTokenAfter(lastSpecifier);

        if (last.value === ",") {
            last = sourceCode.getTokenAfter(last);
        }

        var second = sourceCode.getTokenAfter(first),
            penultimate = sourceCode.getTokenBefore(last);

        validateBraceSpacing(node, first, second, penultimate, last);
    }

    function checkForExport(node) {
        if (node.specifiers.length === 0) {
            return;
        }

        var firstSpecifier = node.specifiers[0],
            lastSpecifier = node.specifiers[node.specifiers.length - 1],
            first = sourceCode.getTokenBefore(firstSpecifier),
            last = sourceCode.getTokenAfter(lastSpecifier);

        if (last.value === ",") {
            last = sourceCode.getTokenAfter(last);
        }

        var second = sourceCode.getTokenAfter(first),
            penultimate = sourceCode.getTokenBefore(last);

        validateBraceSpacing(node, first, second, penultimate, last);
    }

    return {
        ObjectPattern: checkForObject,

        ObjectExpression: checkForObject,

        ImportDeclaration: checkForImport,

        ExportNamedDeclaration: checkForExport
    };

};

module.exports.schema = [
    {
        "enum": ["always", "never"]
    },
    {
        "type": "object",
        "properties": {
            "arraysInObjects": {
                "type": "boolean"
            },
            "objectsInObjects": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/object-shorthand.js": [function(require,module,exports){
"use strict";

var OPTIONS = {
    always: "always",
    never: "never",
    methods: "methods",
    properties: "properties"
};

module.exports = function(context) {
    var APPLY = context.options[0] || OPTIONS.always;
    var APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
    var APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
    var APPLY_NEVER = APPLY === OPTIONS.never;

    var PARAMS = context.options[1] || {};
    var IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;

    function isConstructor(name) {
        var firstChar = name.charAt(0);

        return firstChar === firstChar.toUpperCase();
    }

    return {
        "Property": function(node) {
            var isConciseProperty = node.method || node.shorthand,
                type;

            if (APPLY_NEVER && isConciseProperty) {
                type = node.method ? "method" : "property";
                context.report(node, "Expected longform " + type + " syntax.");
            }

            if (APPLY_NEVER || isConciseProperty) {
                return;
            }

            if (node.kind === "get" || node.kind === "set" || node.computed) {
                return;
            }

            if (node.value.type === "FunctionExpression" && !node.value.id && APPLY_TO_METHODS) {
                if (IGNORE_CONSTRUCTORS && isConstructor(node.key.name)) {
                    return;
                }

                context.report(node, "Expected method shorthand.");
            } else if (node.value.type === "Identifier" && node.key.name === node.value.name && APPLY_TO_PROPS) {

                context.report(node, "Expected property shorthand.");
            } else if (node.value.type === "Identifier" && node.key.type === "Literal" && node.key.value === node.value.name && APPLY_TO_PROPS) {

                context.report(node, "Expected property shorthand.");
            }
        }
    };

};

module.exports.schema = {
    "anyOf": [
        {
            "type": "array",
            "items": [
                {
                    "enum": ["always", "methods", "properties", "never"]
                }
            ],
            "minItems": 0,
            "maxItems": 1
        },
        {
            "type": "array",
            "items": [
                {
                    "enum": ["always", "methods"]
                },
                {
                    "type": "object",
                    "properties": {
                        "ignoreConstructors": {
                            "type": "boolean"
                        }
                    },
                    "additionalProperties": false
                }
            ],
            "minItems": 0,
            "maxItems": 2
        }
    ]
};

},
   {}],

"/tmp/rules/one-var-declaration-per-line.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var ERROR_MESSAGE = "Expected variable declaration to be on a new line.";
    var always = context.options[0] === "always";


    function isForTypeSpecifier(keyword) {
        return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
    }

    function checkForNewLine(node) {
        if (isForTypeSpecifier(node.parent.type)) {
            return;
        }

        var declarations = node.declarations;
        var prev;
        declarations.forEach(function(current) {
            if (prev && prev.loc.end.line === current.loc.start.line) {
                if (always || prev.init || current.init) {
                    context.report({
                        node: node,
                        message: ERROR_MESSAGE,
                        loc: current.loc.start
                    });
                }
            }
            prev = current;
        });
    }

    return {
        "VariableDeclaration": checkForNewLine
    };

};

module.exports.schema = [
    {
        "enum": ["always", "initializations"]
    }
];

},
   {}],

"/tmp/rules/one-var.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var MODE_ALWAYS = "always",
        MODE_NEVER = "never";

    var mode = context.options[0] || MODE_ALWAYS;

    var options = {
    };

    if (typeof mode === "string") { // simple options configuration with just a string
        options.var = { uninitialized: mode, initialized: mode};
        options.let = { uninitialized: mode, initialized: mode};
        options.const = { uninitialized: mode, initialized: mode};
    } else if (typeof mode === "object") { // options configuration is an object
        if (mode.hasOwnProperty("var") && typeof mode.var === "string") {
            options.var = { uninitialized: mode.var, initialized: mode.var};
        }
        if (mode.hasOwnProperty("let") && typeof mode.let === "string") {
            options.let = { uninitialized: mode.let, initialized: mode.let};
        }
        if (mode.hasOwnProperty("const") && typeof mode.const === "string") {
            options.const = { uninitialized: mode.const, initialized: mode.const};
        }
        if (mode.hasOwnProperty("uninitialized")) {
            if (!options.var) {
                options.var = {};
            }
            if (!options.let) {
                options.let = {};
            }
            if (!options.const) {
                options.const = {};
            }
            options.var.uninitialized = mode.uninitialized;
            options.let.uninitialized = mode.uninitialized;
            options.const.uninitialized = mode.uninitialized;
        }
        if (mode.hasOwnProperty("initialized")) {
            if (!options.var) {
                options.var = {};
            }
            if (!options.let) {
                options.let = {};
            }
            if (!options.const) {
                options.const = {};
            }
            options.var.initialized = mode.initialized;
            options.let.initialized = mode.initialized;
            options.const.initialized = mode.initialized;
        }
    }

    var functionStack = [];
    var blockStack = [];

    function startBlock() {
        blockStack.push({
            let: {initialized: false, uninitialized: false},
            const: {initialized: false, uninitialized: false}
        });
    }

    function startFunction() {
        functionStack.push({initialized: false, uninitialized: false});
        startBlock();
    }

    function endBlock() {
        blockStack.pop();
    }

    function endFunction() {
        functionStack.pop();
        endBlock();
    }

    function recordTypes(statementType, declarations, currentScope) {
        for (var i = 0; i < declarations.length; i++) {
            if (declarations[i].init === null) {
                if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {
                    currentScope.uninitialized = true;
                }
            } else {
                if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {
                    currentScope.initialized = true;
                }
            }
        }
    }

    function getCurrentScope(statementType) {
        var currentScope;
        if (statementType === "var") {
            currentScope = functionStack[functionStack.length - 1];
        } else if (statementType === "let") {
            currentScope = blockStack[blockStack.length - 1].let;
        } else if (statementType === "const") {
            currentScope = blockStack[blockStack.length - 1].const;
        }
        return currentScope;
    }

    function countDeclarations(declarations) {
        var counts = { uninitialized: 0, initialized: 0 };
        for (var i = 0; i < declarations.length; i++) {
            if (declarations[i].init === null) {
                counts.uninitialized++;
            } else {
                counts.initialized++;
            }
        }
        return counts;
    }

    function hasOnlyOneStatement(statementType, declarations) {

        var declarationCounts = countDeclarations(declarations);
        var currentOptions = options[statementType] || {};
        var currentScope = getCurrentScope(statementType);

        if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {
            if (currentScope.uninitialized || currentScope.initialized) {
                return false;
            }
        }

        if (declarationCounts.uninitialized > 0) {
            if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {
                return false;
            }
        }
        if (declarationCounts.initialized > 0) {
            if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {
                return false;
            }
        }
        recordTypes(statementType, declarations, currentScope);
        return true;
    }


    return {
        "Program": startFunction,
        "FunctionDeclaration": startFunction,
        "FunctionExpression": startFunction,
        "ArrowFunctionExpression": startFunction,
        "BlockStatement": startBlock,
        "ForStatement": startBlock,
        "ForInStatement": startBlock,
        "ForOfStatement": startBlock,
        "SwitchStatement": startBlock,

        "VariableDeclaration": function(node) {
            var parent = node.parent,
                type, declarations, declarationCounts;

            type = node.kind;
            if (!options[type]) {
                return;
            }

            declarations = node.declarations;
            declarationCounts = countDeclarations(declarations);

            if (!hasOnlyOneStatement(type, declarations)) {
                if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {
                    context.report(node, "Combine this with the previous '" + type + "' statement.");
                } else {
                    if (options[type].initialized === MODE_ALWAYS) {
                        context.report(node, "Combine this with the previous '" + type + "' statement with initialized variables.");
                    }
                    if (options[type].uninitialized === MODE_ALWAYS) {
                        context.report(node, "Combine this with the previous '" + type + "' statement with uninitialized variables.");
                    }
                }
            }
            if (parent.type !== "ForStatement" || parent.init !== node) {
                var totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;
                if (totalDeclarations > 1) {
                    if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {
                        context.report(node, "Split '" + type + "' declarations into multiple statements.");
                    } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {
                        context.report(node, "Split initialized '" + type + "' declarations into multiple statements.");
                    } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {
                        context.report(node, "Split uninitialized '" + type + "' declarations into multiple statements.");
                    }
                }
            }
        },

        "ForStatement:exit": endBlock,
        "ForOfStatement:exit": endBlock,
        "ForInStatement:exit": endBlock,
        "SwitchStatement:exit": endBlock,
        "BlockStatement:exit": endBlock,
        "Program:exit": endFunction,
        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["always", "never"]
            },
            {
                "type": "object",
                "properties": {
                    "var": {
                        "enum": ["always", "never"]
                    },
                    "let": {
                        "enum": ["always", "never"]
                    },
                    "const": {
                        "enum": ["always", "never"]
                    }
                },
                "additionalProperties": false
            },
            {
                "type": "object",
                "properties": {
                    "initialized": {
                        "enum": ["always", "never"]
                    },
                    "uninitialized": {
                        "enum": ["always", "never"]
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/operator-assignment.js": [function(require,module,exports){
"use strict";

function isCommutativeOperatorWithShorthand(operator) {
    return ["*", "&", "^", "|"].indexOf(operator) >= 0;
}

function isNonCommutativeOperatorWithShorthand(operator) {
    return ["+", "-", "/", "%", "<<", ">>", ">>>"].indexOf(operator) >= 0;
}

function same(a, b) {
    if (a.type !== b.type) {
        return false;
    }

    switch (a.type) {
        case "Identifier":
            return a.name === b.name;
        case "Literal":
            return a.value === b.value;
        case "MemberExpression":
            return same(a.object, b.object) && same(a.property, b.property);
        default:
            return false;
    }
}

module.exports = function(context) {

    function verify(node) {
        var expr, left, operator;

        if (node.operator !== "=" || node.right.type !== "BinaryExpression") {
            return;
        }

        left = node.left;
        expr = node.right;
        operator = expr.operator;

        if (isCommutativeOperatorWithShorthand(operator)) {
            if (same(left, expr.left) || same(left, expr.right)) {
                context.report(node, "Assignment can be replaced with operator assignment.");
            }
        } else if (isNonCommutativeOperatorWithShorthand(operator)) {
            if (same(left, expr.left)) {
                context.report(node, "Assignment can be replaced with operator assignment.");
            }
        }
    }

    function prohibit(node) {
        if (node.operator !== "=") {
            context.report(node, "Unexpected operator assignment shorthand.");
        }
    }

    return {
        "AssignmentExpression": context.options[0] !== "never" ? verify : prohibit
    };

};

module.exports.schema = [
    {
        "enum": ["always", "never"]
    }
];

},
   {}],

"/tmp/rules/operator-linebreak.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash"),
    astUtils = require("../ast-utils");

module.exports = function(context) {

    var usedDefaultGlobal = !context.options[0];
    var globalStyle = context.options[0] || "after";
    var options = context.options[1] || {};
    var styleOverrides = options.overrides ? lodash.assign({}, options.overrides) : {};

    if (usedDefaultGlobal && !styleOverrides["?"]) {
        styleOverrides["?"] = "before";
    }

    if (usedDefaultGlobal && !styleOverrides[":"]) {
        styleOverrides[":"] = "before";
    }

    function validateNode(node, leftSide) {
        var leftToken = context.getLastToken(leftSide);
        var operatorToken = context.getTokenAfter(leftToken);

        while (operatorToken.value === ")") {
            leftToken = operatorToken;
            operatorToken = context.getTokenAfter(operatorToken);
        }

        var rightToken = context.getTokenAfter(operatorToken);
        var operator = operatorToken.value;
        var operatorStyleOverride = styleOverrides[operator];
        var style = operatorStyleOverride || globalStyle;

        if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&
                astUtils.isTokenOnSameLine(operatorToken, rightToken)) {

            return;

        } else if (operatorStyleOverride !== "ignore" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&
                !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {

            context.report(node, {
                line: operatorToken.loc.end.line,
                column: operatorToken.loc.end.column
            }, "Bad line breaking before and after '" + operator + "'.");

        } else if (style === "before" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {

            context.report(node, {
                line: operatorToken.loc.end.line,
                column: operatorToken.loc.end.column
            }, "'" + operator + "' should be placed at the beginning of the line.");

        } else if (style === "after" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {

            context.report(node, {
                line: operatorToken.loc.end.line,
                column: operatorToken.loc.end.column
            }, "'" + operator + "' should be placed at the end of the line.");

        } else if (style === "none") {

            context.report(node, {
                line: operatorToken.loc.end.line,
                column: operatorToken.loc.end.column
            }, "There should be no line break before or after '" + operator + "'");

        }
    }

    function validateBinaryExpression(node) {
        validateNode(node, node.left);
    }

    return {
        "BinaryExpression": validateBinaryExpression,
        "LogicalExpression": validateBinaryExpression,
        "AssignmentExpression": validateBinaryExpression,
        "VariableDeclarator": function(node) {
            if (node.init) {
                validateNode(node, node.id);
            }
        },
        "ConditionalExpression": function(node) {
            validateNode(node, node.test);
            validateNode(node, node.consequent);
        }
    };
};

module.exports.schema = [
    {
        "enum": ["after", "before", "none", null]
    },
    {
        "type": "object",
        "properties": {
            "overrides": {
                "type": "object",
                "properties": {
                    "anyOf": {
                        "type": "string",
                        "enum": ["after", "before", "none", "ignore"]
                    }
                }
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js","lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/padded-blocks.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var options = {};
    var config = context.options[0] || "always";

    if (typeof config === "string") {
        options.blocks = config === "always";
    } else {
        if (config.hasOwnProperty("blocks")) {
            options.blocks = config.blocks === "always";
        }
        if (config.hasOwnProperty("switches")) {
            options.switches = config.switches === "always";
        }
        if (config.hasOwnProperty("classes")) {
            options.classes = config.classes === "always";
        }
    }

    var ALWAYS_MESSAGE = "Block must be padded by blank lines.",
        NEVER_MESSAGE = "Block must not be padded by blank lines.";

    var sourceCode = context.getSourceCode();

    function getOpenBrace(node) {
        if (node.type === "SwitchStatement") {
            return sourceCode.getTokenBefore(node.cases[0]);
        }
        return sourceCode.getFirstToken(node);
    }

    function isComment(node) {
        return node.type === "Line" || node.type === "Block";
    }

    function isTokenTopPadded(token) {
        var tokenStartLine = token.loc.start.line,
            expectedFirstLine = tokenStartLine + 2,
            first,
            firstLine;

        first = token;
        do {
            first = sourceCode.getTokenOrCommentAfter(first);
        } while (isComment(first) && first.loc.start.line === tokenStartLine);

        firstLine = first.loc.start.line;
        return expectedFirstLine <= firstLine;
    }

    function isTokenBottomPadded(token) {
        var blockEnd = token.loc.end.line,
            expectedLastLine = blockEnd - 2,
            last,
            lastLine;

        last = token;
        do {
            last = sourceCode.getTokenOrCommentBefore(last);
        } while (isComment(last) && last.loc.end.line === blockEnd);

        lastLine = last.loc.end.line;
        return lastLine <= expectedLastLine;
    }

    function requirePaddingFor(node) {
        switch (node.type) {
            case "BlockStatement":
                return options.blocks;
            case "SwitchStatement":
                return options.switches;
            case "ClassBody":
                return options.classes;
            default:
                throw new Error("unreachable");
        }
    }

    function checkPadding(node) {
        var openBrace = getOpenBrace(node),
            closeBrace = sourceCode.getLastToken(node),
            blockHasTopPadding = isTokenTopPadded(openBrace),
            blockHasBottomPadding = isTokenBottomPadded(closeBrace);

        if (requirePaddingFor(node)) {
            if (!blockHasTopPadding) {
                context.report({
                    node: node,
                    loc: { line: openBrace.loc.start.line, column: openBrace.loc.start.column },
                    message: ALWAYS_MESSAGE
                });
            }
            if (!blockHasBottomPadding) {
                context.report({
                    node: node,
                    loc: {line: closeBrace.loc.end.line, column: closeBrace.loc.end.column - 1 },
                    message: ALWAYS_MESSAGE
                });
            }
        } else {
            if (blockHasTopPadding) {
                context.report({
                    node: node,
                    loc: { line: openBrace.loc.start.line, column: openBrace.loc.start.column },
                    message: NEVER_MESSAGE
                });
            }

            if (blockHasBottomPadding) {
                context.report({
                    node: node,
                    loc: {line: closeBrace.loc.end.line, column: closeBrace.loc.end.column - 1 },
                    message: NEVER_MESSAGE
                });
            }
        }
    }

    var rule = {};
    if (options.hasOwnProperty("switches")) {
        rule.SwitchStatement = function(node) {
            if (node.cases.length === 0) {
                return;
            }
            checkPadding(node);
        };
    }

    if (options.hasOwnProperty("blocks")) {
        rule.BlockStatement = function(node) {
            if (node.body.length === 0) {
                return;
            }
            checkPadding(node);
        };
    }

    if (options.hasOwnProperty("classes")) {
        rule.ClassBody = function(node) {
            if (node.body.length === 0) {
                return;
            }
            checkPadding(node);
        };
    }

    return rule;
};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["always", "never"]
            },
            {
                "type": "object",
                "properties": {
                    "blocks": {
                        "enum": ["always", "never"]
                    },
                    "switches": {
                        "enum": ["always", "never"]
                    },
                    "classes": {
                        "enum": ["always", "never"]
                    }
                },
                "additionalProperties": false,
                "minProperties": 1
            }
        ]
    }
];

},
   {}],

"/tmp/rules/prefer-arrow-callback.js": [function(require,module,exports){
"use strict";

function isFunctionName(variable) {
    return variable && variable.defs[0].type === "FunctionName";
}

function checkMetaProperty(node, metaName, propertyName) {
    if (typeof node.meta === "string") {
        return node.meta === metaName && node.property === propertyName;
    }
    return node.meta.name === metaName && node.property.name === propertyName;
}

function getVariableOfArguments(scope) {
    var variables = scope.variables;
    for (var i = 0; i < variables.length; ++i) {
        var variable = variables[i];
        if (variable.name === "arguments") {
            return (variable.identifiers.length === 0) ? variable : null;
        }
    }

    return null;
}

function getCallbackInfo(node) {
    var retv = {isCallback: false, isLexicalThis: false};
    var parent = node.parent;
    while (node) {
        switch (parent.type) {
            case "LogicalExpression":
            case "ConditionalExpression":
                break;

            case "MemberExpression":
                if (parent.object === node &&
                    !parent.property.computed &&
                    parent.property.type === "Identifier" &&
                    parent.property.name === "bind" &&
                    parent.parent.type === "CallExpression" &&
                    parent.parent.callee === parent
                ) {
                    retv.isLexicalThis = (
                        parent.parent.arguments.length === 1 &&
                        parent.parent.arguments[0].type === "ThisExpression"
                    );
                    node = parent;
                    parent = parent.parent;
                } else {
                    return retv;
                }
                break;

            case "CallExpression":
            case "NewExpression":
                if (parent.callee !== node) {
                    retv.isCallback = true;
                }
                return retv;

            default:
                return retv;
        }

        node = parent;
        parent = parent.parent;
    }

    throw new Error("unreachable");
}

module.exports = function(context) {
    var stack = [];

    function enterScope() {
        stack.push({this: false, super: false, meta: false});
    }

    function exitScope() {
        return stack.pop();
    }

    return {
        Program: function() {
            stack = [];
        },

        ThisExpression: function() {
            var info = stack[stack.length - 1];
            if (info) {
                info.this = true;
            }
        },
        Super: function() {
            var info = stack[stack.length - 1];
            if (info) {
                info.super = true;
            }
        },
        MetaProperty: function(node) {
            var info = stack[stack.length - 1];
            if (info && checkMetaProperty(node, "new", "target")) {
                info.meta = true;
            }
        },

        FunctionDeclaration: enterScope,
        "FunctionDeclaration:exit": exitScope,

        FunctionExpression: enterScope,
        "FunctionExpression:exit": function(node) {
            var scopeInfo = exitScope();

            if (node.generator) {
                return;
            }

            var nameVar = context.getDeclaredVariables(node)[0];
            if (isFunctionName(nameVar) && nameVar.references.length > 0) {
                return;
            }

            var variable = getVariableOfArguments(context.getScope());
            if (variable && variable.references.length > 0) {
                return;
            }

            var callbackInfo = getCallbackInfo(node);
            if (callbackInfo.isCallback &&
                (!scopeInfo.this || callbackInfo.isLexicalThis) &&
                !scopeInfo.super &&
                !scopeInfo.meta
            ) {
                context.report(node, "Unexpected function expression.");
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/prefer-const.js": [function(require,module,exports){
"use strict";

var LOOP_TYPES = /^(?:While|DoWhile|For|ForIn|ForOf)Statement$/;
var FOR_IN_OF_TYPES = /^For(?:In|Of)Statement$/;
var SENTINEL_TYPES = /(?:Declaration|Statement)$/;
var END_POSITION_TYPES = /^(?:Assignment|Update)/;

function getWriteReferenceIfOnce(variable) {
    var retv = null;

    var references = variable.references;
    for (var i = 0; i < references.length; ++i) {
        var reference = references[i];

        if (reference.isWrite()) {
            if (retv && !(retv.init && reference.init)) {
                return null;
            }
            retv = reference;
        }
    }

    return retv;
}

function isInLoopHead(reference) {
    var node = reference.identifier;
    var parent = node.parent;
    var assignment = false;

    while (parent) {
        if (LOOP_TYPES.test(parent.type)) {
            return true;
        }

        if (assignment &&
            parent.type === "VariableDeclaration" &&
            FOR_IN_OF_TYPES.test(parent.parent.type) &&
            parent.parent.left === parent
        ) {
            return true;
        }
        if (parent.type === "AssignmentPattern") {
            assignment = true;
        }

        if (SENTINEL_TYPES.test(parent.type)) {
            break;
        }

        node = parent;
        parent = parent.parent;
    }

    return false;
}

function getEndPosition(writer) {
    var node = writer.identifier;
    var end = node.range[1];

    while ((node = node.parent)) {
        if (END_POSITION_TYPES.test(node.type)) {
            end = node.range[1];
        }
        if (SENTINEL_TYPES.test(node.type)) {
            break;
        }
    }

    return end;
}

function isInScope(writer) {
    var start = getEndPosition(writer);
    var end = writer.from.block.range[1];

    return function(reference) {
        if (!reference.isRead()) {
            return true;
        }

        var range = reference.identifier.range;
        return start <= range[0] && range[1] <= end;
    };
}

module.exports = function(context) {

    function checkForVariables(scope) {
        if (scope.type === "TDZ") {
            return;
        }

        var variables = scope.variables;
        for (var i = 0; i < variables.length; ++i) {
            var variable = variables[i];
            var def = variable.defs[0];
            var declaration = def && def.parent;
            var statement = declaration && declaration.parent;
            var references = variable.references;
            var identifier = variable.identifiers[0];

            if (!declaration ||
                declaration.type !== "VariableDeclaration" ||
                declaration.kind !== "let" ||
                (statement.type === "ForStatement" && statement.init === declaration)
            ) {
                continue;
            }

            var writer = getWriteReferenceIfOnce(variable);
            if (writer &&
                !(variable.eslintUsed && variable.scope !== writer.from) &&
                !isInLoopHead(writer) &&
                references.every(isInScope(writer))
            ) {
                context.report({
                    node: identifier,
                    message: "'{{name}}' is never reassigned, use 'const' instead.",
                    data: identifier
                });
            }
        }
    }

    var pushAll = Function.apply.bind(Array.prototype.push);

    return {
        "Program:exit": function() {
            var stack = [context.getScope()];
            while (stack.length) {
                var scope = stack.pop();
                pushAll(stack, scope.childScopes);

                checkForVariables(scope);
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/prefer-reflect.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var existingNames = {
        "apply": "Function.prototype.apply",
        "call": "Function.prototype.call",
        "defineProperty": "Object.defineProperty",
        "getOwnPropertyDescriptor": "Object.getOwnPropertyDescriptor",
        "getPrototypeOf": "Object.getPrototypeOf",
        "setPrototypeOf": "Object.setPrototypeOf",
        "isExtensible": "Object.isExtensible",
        "getOwnPropertyNames": "Object.getOwnPropertyNames",
        "preventExtensions": "Object.preventExtensions"
    };

    var reflectSubsitutes = {
        "apply": "Reflect.apply",
        "call": "Reflect.apply",
        "defineProperty": "Reflect.defineProperty",
        "getOwnPropertyDescriptor": "Reflect.getOwnPropertyDescriptor",
        "getPrototypeOf": "Reflect.getPrototypeOf",
        "setPrototypeOf": "Reflect.setPrototypeOf",
        "isExtensible": "Reflect.isExtensible",
        "getOwnPropertyNames": "Reflect.getOwnPropertyNames",
        "preventExtensions": "Reflect.preventExtensions"
    };

    var exceptions = (context.options[0] || {}).exceptions || [];

    function report(node, existing, substitute) {
        context.report(node, "Avoid using {{existing}}, instead use {{substitute}}", {
            existing: existing,
            substitute: substitute
        });
    }

    return {
        "CallExpression": function(node) {
            var methodName = (node.callee.property || {}).name;
            var isReflectCall = (node.callee.object || {}).name === "Reflect";
            var hasReflectSubsitute = reflectSubsitutes.hasOwnProperty(methodName);
            var userConfiguredException = exceptions.indexOf(methodName) !== -1;
            if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {
                report(node, existingNames[methodName], reflectSubsitutes[methodName]);
            }
        },
        "UnaryExpression": function(node) {
            var isDeleteOperator = node.operator === "delete";
            var targetsIdentifier = node.argument.type === "Identifier";
            var userConfiguredException = exceptions.indexOf("delete") !== -1;
            if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {
                report(node, "the delete keyword", "Reflect.deleteProperty");
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "array",
                "items": {
                    "enum": [
                        "apply",
                        "call",
                        "delete",
                        "defineProperty",
                        "getOwnPropertyDescriptor",
                        "getPrototypeOf",
                        "setPrototypeOf",
                        "isExtensible",
                        "getOwnPropertyNames",
                        "preventExtensions"
                    ]
                },
                "uniqueItems": true
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/prefer-rest-params.js": [function(require,module,exports){
"use strict";

function getVariableOfArguments(scope) {
    var variables = scope.variables;
    for (var i = 0; i < variables.length; ++i) {
        var variable = variables[i];
        if (variable.name === "arguments") {
            return (variable.identifiers.length === 0) ? variable : null;
        }
    }

    return null;
}

module.exports = function(context) {

    function report(reference) {
        context.report({
            node: reference.identifier,
            message: "Use the rest parameters instead of 'arguments'."
        });
    }

    function checkForArguments() {
        var argumentsVar = getVariableOfArguments(context.getScope());
        if (argumentsVar) {
            argumentsVar.references.forEach(report);
        }
    }

    return {
        FunctionDeclaration: checkForArguments,
        FunctionExpression: checkForArguments
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/prefer-spread.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isVariadicApplyCalling(node) {
    return (
        node.callee.type === "MemberExpression" &&
        node.callee.property.type === "Identifier" &&
        node.callee.property.name === "apply" &&
        node.callee.computed === false &&
        node.arguments.length === 2 &&
        node.arguments[1].type !== "ArrayExpression"
    );
}

function equalTokens(left, right, context) {
    var tokensL = context.getTokens(left);
    var tokensR = context.getTokens(right);

    if (tokensL.length !== tokensR.length) {
        return false;
    }
    for (var i = 0; i < tokensL.length; ++i) {
        if (tokensL[i].type !== tokensR[i].type ||
            tokensL[i].value !== tokensR[i].value
        ) {
            return false;
        }
    }

    return true;
}

function isValidThisArg(expectedThis, thisArg, context) {
    if (!expectedThis) {
        return astUtils.isNullOrUndefined(thisArg);
    }
    return equalTokens(expectedThis, thisArg, context);
}

module.exports = function(context) {
    return {
        "CallExpression": function(node) {
            if (!isVariadicApplyCalling(node)) {
                return;
            }

            var applied = node.callee.object;
            var expectedThis = (applied.type === "MemberExpression") ? applied.object : null;
            var thisArg = node.arguments[0];

            if (isValidThisArg(expectedThis, thisArg, context)) {
                context.report(node, "use the spread operator instead of the '.apply()'.");
            }
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/prefer-template.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isConcatenation(node) {
    return node.type === "BinaryExpression" && node.operator === "+";
}

function getTopConcatBinaryExpression(node) {
    while (isConcatenation(node.parent)) {
        node = node.parent;
    }
    return node;
}

function hasNonStringLiteral(node) {
    if (isConcatenation(node)) {
        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);
    }
    return !astUtils.isStringLiteral(node);
}

module.exports = function(context) {
    var done = Object.create(null);

    function checkForStringConcat(node) {
        if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {
            return;
        }

        var topBinaryExpr = getTopConcatBinaryExpression(node.parent);

        if (done[topBinaryExpr.range[0]]) {
            return;
        }
        done[topBinaryExpr.range[0]] = true;

        if (hasNonStringLiteral(topBinaryExpr)) {
            context.report(
                topBinaryExpr,
                "Unexpected string concatenation.");
        }
    }

    return {
        Program: function() {
            done = Object.create(null);
        },

        Literal: checkForStringConcat,
        TemplateLiteral: checkForStringConcat
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/quote-props.js": [function(require,module,exports){
"use strict";

var espree = require("espree"),
    keywords = require("../util/keywords");

module.exports = function(context) {

    var MODE = context.options[0],
        KEYWORDS = context.options[1] && context.options[1].keywords,
        CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,
        NUMBERS = context.options[1] && context.options[1].numbers,

        MESSAGE_UNNECESSARY = "Unnecessarily quoted property '{{property}}' found.",
        MESSAGE_UNQUOTED = "Unquoted property '{{property}}' found.",
        MESSAGE_NUMERIC = "Unquoted number literal '{{property}}' used as key.",
        MESSAGE_RESERVED = "Unquoted reserved word '{{property}}' used as key.";


    function isKeyword(tokenStr) {
        return keywords.indexOf(tokenStr) >= 0;
    }

    function areQuotesRedundant(tokens, skipNumberLiterals) {
        return tokens.length === 1 &&
            (["Identifier", "Keyword", "Null", "Boolean"].indexOf(tokens[0].type) >= 0 ||
            (tokens[0].type === "Numeric" && !skipNumberLiterals && "" + +tokens[0].value === tokens[0].value));
    }

    function checkUnnecessaryQuotes(node) {
        var key = node.key,
            isKeywordToken,
            tokens;

        if (node.method || node.computed || node.shorthand) {
            return;
        }

        if (key.type === "Literal" && typeof key.value === "string") {
            try {
                tokens = espree.tokenize(key.value);
            } catch (e) {
                return;
            }

            if (tokens.length !== 1) {
                return;
            }

            isKeywordToken = isKeyword(tokens[0].value);

            if (isKeywordToken && KEYWORDS) {
                return;
            }

            if (CHECK_UNNECESSARY && areQuotesRedundant(tokens, NUMBERS)) {
                context.report(node, MESSAGE_UNNECESSARY, {property: key.value});
            }
        } else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
            context.report(node, MESSAGE_RESERVED, {property: key.name});
        } else if (NUMBERS && key.type === "Literal" && typeof key.value === "number") {
            context.report(node, MESSAGE_NUMERIC, {property: key.value});
        }
    }

    function checkOmittedQuotes(node) {
        var key = node.key;

        if (!node.method && !node.computed && !node.shorthand && !(key.type === "Literal" && typeof key.value === "string")) {
            context.report(node, MESSAGE_UNQUOTED, {
                property: key.name || key.value
            });
        }
    }

    function checkConsistency(node, checkQuotesRedundancy) {
        var quotes = false,
            lackOfQuotes = false,
            necessaryQuotes = false;

        node.properties.forEach(function(property) {
            var key = property.key,
                tokens;

            if (!key || property.method || property.computed || property.shorthand) {
                return;
            }

            if (key.type === "Literal" && typeof key.value === "string") {

                quotes = true;

                if (checkQuotesRedundancy) {
                    try {
                        tokens = espree.tokenize(key.value);
                    } catch (e) {
                        necessaryQuotes = true;
                        return;
                    }

                    necessaryQuotes = necessaryQuotes || !areQuotesRedundant(tokens) || KEYWORDS && isKeyword(tokens[0].value);
                }
            } else if (KEYWORDS && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
                necessaryQuotes = true;
                context.report(node, "Properties should be quoted as '{{property}}' is a reserved word.", {property: key.name});
            } else {
                lackOfQuotes = true;
            }

            if (quotes && lackOfQuotes) {
                context.report(node, "Inconsistently quoted property '{{key}}' found.", {
                    key: key.name || key.value
                });
            }
        });

        if (checkQuotesRedundancy && quotes && !necessaryQuotes) {
            context.report(node, "Properties shouldn't be quoted as all quotes are redundant.");
        }
    }

    return {
        "Property": function(node) {
            if (MODE === "always" || !MODE) {
                checkOmittedQuotes(node);
            }
            if (MODE === "as-needed") {
                checkUnnecessaryQuotes(node);
            }
        },
        "ObjectExpression": function(node) {
            if (MODE === "consistent") {
                checkConsistency(node, false);
            }
            if (MODE === "consistent-as-needed") {
                checkConsistency(node, true);
            }
        }
    };

};

module.exports.schema = {
    "anyOf": [
        {
            "type": "array",
            "items": [
                {
                    "enum": ["always", "as-needed", "consistent", "consistent-as-needed"]
                }
            ],
            "minItems": 0,
            "maxItems": 1
        },
        {
            "type": "array",
            "items": [
                {
                    "enum": ["always", "as-needed", "consistent", "consistent-as-needed"]
                },
                {
                    "type": "object",
                    "properties": {
                        "keywords": {
                            "type": "boolean"
                        },
                        "unnecessary": {
                            "type": "boolean"
                        },
                        "numbers": {
                            "type": "boolean"
                        }
                    },
                    "additionalProperties": false
                }
            ],
            "minItems": 0,
            "maxItems": 2
        }
    ]
};

},
   {"../util/keywords":"/tmp/util/keywords.js","espree":"espree"}],

"/tmp/rules/quotes.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

var QUOTE_SETTINGS = {
    "double": {
        quote: "\"",
        alternateQuote: "'",
        description: "doublequote"
    },
    "single": {
        quote: "'",
        alternateQuote: "\"",
        description: "singlequote"
    },
    "backtick": {
        quote: "`",
        alternateQuote: "\"",
        description: "backtick"
    }
};
QUOTE_SETTINGS.double.convert =
QUOTE_SETTINGS.single.convert =
QUOTE_SETTINGS.backtick.convert = function(str) {
    var newQuote = this.quote;
    var oldQuote = str[0];
    if (newQuote === oldQuote) {
        return str;
    }
    return newQuote + str.slice(1, -1).replace(/\\(\${|\r\n?|\n|.)|["'`]|\${|(\r\n?|\n)/g, function(match, escaped, newline) {
        if (escaped === oldQuote || oldQuote === "`" && escaped === "${") {
            return escaped; // unescape
        }
        if (match === newQuote || newQuote === "`" && match === "${") {
            return "\\" + match; // escape
        }
        if (newline && oldQuote === "`") {
            return "\\n"; // escape newlines
        }
        return match;
    }) + newQuote;
};

var AVOID_ESCAPE = "avoid-escape",
    FUNCTION_TYPE = /^(?:Arrow)?Function(?:Declaration|Expression)$/;

module.exports = function(context) {

    var quoteOption = context.options[0],
        settings = QUOTE_SETTINGS[quoteOption || "double"],
        avoidEscape = context.options[1] === AVOID_ESCAPE,
        sourceCode = context.getSourceCode();

    function isJSXElement(node) {
        return node.type.indexOf("JSX") === 0;
    }

    function isDirective(node) {
        return (
            node.type === "ExpressionStatement" &&
            node.expression.type === "Literal" &&
            typeof node.expression.value === "string"
        );
    }

    function isPartOfDirectivePrologue(node) {
        var block = node.parent.parent;
        if (block.type !== "Program" && (block.type !== "BlockStatement" || !FUNCTION_TYPE.test(block.parent.type))) {
            return false;
        }

        for (var i = 0; i < block.body.length; ++i) {
            var statement = block.body[i];

            if (statement === node.parent) {
                return true;
            }
            if (!isDirective(statement)) {
                break;
            }
        }

        return false;
    }

    function isAllowedAsNonBacktick(node) {
        var parent = node.parent;

        switch (parent.type) {
            case "ExpressionStatement":
                return isPartOfDirectivePrologue(node);

            case "Property":
                return parent.key === node && !parent.computed;

            case "ImportDeclaration":
            case "ExportNamedDeclaration":
            case "ExportAllDeclaration":
                return parent.source === node;

            default:
                return false;
        }
    }

    return {

        "Literal": function(node) {
            var val = node.value,
                rawVal = node.raw,
                isValid;

            if (settings && typeof val === "string") {
                isValid = (quoteOption === "backtick" && isAllowedAsNonBacktick(node)) ||
                    isJSXElement(node.parent) ||
                    astUtils.isSurroundedBy(rawVal, settings.quote);

                if (!isValid && avoidEscape) {
                    isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
                }

                if (!isValid) {
                    context.report({
                        node: node,
                        message: "Strings must use " + settings.description + ".",
                        fix: function(fixer) {
                            return fixer.replaceText(node, settings.convert(node.raw));
                        }
                    });
                }
            }
        },

        "TemplateLiteral": function(node) {

            if (quoteOption === "backtick" || node.parent.type === "TaggedTemplateExpression") {
                return;
            }

            var shouldWarn = node.quasis.length === 1 && (node.quasis[0].value.cooked.indexOf("\n") === -1);

            if (shouldWarn) {
                context.report({
                    node: node,
                    message: "Strings must use " + settings.description + ".",
                    fix: function(fixer) {
                        return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
                    }
                });
            }
        }
    };

};

module.exports.schema = [
    {
        "enum": ["single", "double", "backtick"]
    },
    {
        "enum": ["avoid-escape"]
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/radix.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var MODE_ALWAYS = "always",
        MODE_AS_NEEDED = "as-needed";

    var mode = context.options[0] || MODE_ALWAYS;

    return {
        "CallExpression": function(node) {

            var radix;

            if (!(node.callee.name === "parseInt" || (
                    node.callee.type === "MemberExpression" &&
                    node.callee.object.name === "Number" &&
                    node.callee.property.name === "parseInt"
                )
            )) {
                return;
            }

            if (node.arguments.length === 0) {
                context.report({
                    node: node,
                    message: "Missing parameters."
                });
            } else if (node.arguments.length < 2 && mode === MODE_ALWAYS) {
                context.report({
                    node: node,
                    message: "Missing radix parameter."
                });
            } else if (node.arguments.length > 1 && mode === MODE_AS_NEEDED &&
                (node.arguments[1] && node.arguments[1].type === "Literal" &&
                    node.arguments[1].value === 10)
            ) {
                context.report({
                    node: node,
                    message: "Redundant radix parameter."
                });
            } else {

                radix = node.arguments[1];

                if (radix &&
                    ((radix.type === "Literal" && typeof radix.value !== "number") ||
                    (radix.type === "Identifier" && radix.name === "undefined"))
                ) {
                    context.report({
                        node: node,
                        message: "Invalid radix parameter."
                    });
                }
            }

        }
    };

};

module.exports.schema = [
    {
        "enum": ["always", "as-needed"]
    }
];


},
   {}],

"/tmp/rules/require-jsdoc.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

module.exports = function(context) {
    var source = context.getSourceCode();
    var DEFAULT_OPTIONS = {
        "FunctionDeclaration": true,
        "MethodDefinition": false,
        "ClassDeclaration": false
    };
    var options = lodash.assign(DEFAULT_OPTIONS, context.options[0] && context.options[0].require || {});

    function report(node) {
        context.report(node, "Missing JSDoc comment.");
    }

    function checkClassMethodJsDoc(node) {
        if (node.parent.type === "MethodDefinition") {
            var jsdocComment = source.getJSDocComment(node);

            if (!jsdocComment) {
                report(node);
            }
        }
    }

    function checkJsDoc(node) {
        var jsdocComment = source.getJSDocComment(node);

        if (!jsdocComment) {
            report(node);
        }
    }

    return {
        "FunctionDeclaration": function(node) {
            if (options.FunctionDeclaration) {
                checkJsDoc(node);
            }
        },
        "FunctionExpression": function(node) {
            if (options.MethodDefinition) {
                checkClassMethodJsDoc(node);
            }
        },
        "ClassDeclaration": function(node) {
            if (options.ClassDeclaration) {
                checkJsDoc(node);
            }
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "require": {
                "type": "object",
                "properties": {
                    "ClassDeclaration": {
                        "type": "boolean"
                    },
                    "MethodDefinition": {
                        "type": "boolean"
                    },
                    "FunctionDeclaration": {
                        "type": "boolean"
                    }
                },
                "additionalProperties": false
            }
        },
        "additionalProperties": false
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/require-yield.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var stack = [];

    function beginChecking(node) {
        if (node.generator) {
            stack.push(0);
        }
    }

    function endChecking(node) {
        if (!node.generator) {
            return;
        }

        var countYield = stack.pop();
        if (countYield === 0 && node.body.body.length > 0) {
            context.report(
                node,
                "This generator function does not have 'yield'.");
        }
    }

    return {
        "FunctionDeclaration": beginChecking,
        "FunctionDeclaration:exit": endChecking,
        "FunctionExpression": beginChecking,
        "FunctionExpression:exit": endChecking,

        "YieldExpression": function() {
            if (stack.length > 0) {
                stack[stack.length - 1] += 1;
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/semi-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var config = context.options[0],
        requireSpaceBefore = false,
        requireSpaceAfter = true,
        sourceCode = context.getSourceCode();

    if (typeof config === "object") {
        if (config.hasOwnProperty("before")) {
            requireSpaceBefore = config.before;
        }
        if (config.hasOwnProperty("after")) {
            requireSpaceAfter = config.after;
        }
    }

    function hasLeadingSpace(token) {
        var tokenBefore = context.getTokenBefore(token);
        return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);
    }

    function hasTrailingSpace(token) {
        var tokenAfter = context.getTokenAfter(token);
        return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);
    }

    function isLastTokenInCurrentLine(token) {
        var tokenAfter = context.getTokenAfter(token);
        return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
    }

    function isFirstTokenInCurrentLine(token) {
        var tokenBefore = context.getTokenBefore(token);
        return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));
    }

    function isBeforeClosingParen(token) {
        var nextToken = context.getTokenAfter(token);
        return (
            nextToken &&
            nextToken.type === "Punctuator" &&
            (nextToken.value === "}" || nextToken.value === ")")
        );
    }

    function isSemicolon(token) {
        return token.type === "Punctuator" && token.value === ";";
    }

    function checkSemicolonSpacing(token, node) {
        var location;

        if (isSemicolon(token)) {
            location = token.loc.start;

            if (hasLeadingSpace(token)) {
                if (!requireSpaceBefore) {
                    context.report({
                        node: node,
                        loc: location,
                        message: "Unexpected whitespace before semicolon.",
                        fix: function(fixer) {
                            var tokenBefore = context.getTokenBefore(token);
                            return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
                        }
                    });
                }
            } else {
                if (requireSpaceBefore) {
                    context.report({
                        node: node,
                        loc: location,
                        message: "Missing whitespace before semicolon.",
                        fix: function(fixer) {
                            return fixer.insertTextBefore(token, " ");
                        }
                    });
                }
            }

            if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
                if (hasTrailingSpace(token)) {
                    if (!requireSpaceAfter) {
                        context.report({
                            node: node,
                            loc: location,
                            message: "Unexpected whitespace after semicolon.",
                            fix: function(fixer) {
                                var tokenAfter = context.getTokenAfter(token);
                                return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
                            }
                        });
                    }
                } else {
                    if (requireSpaceAfter) {
                        context.report({
                            node: node,
                            loc: location,
                            message: "Missing whitespace after semicolon.",
                            fix: function(fixer) {
                                return fixer.insertTextAfter(token, " ");
                            }
                        });
                    }
                }
            }
        }
    }

    function checkNode(node) {
        var token = context.getLastToken(node);
        checkSemicolonSpacing(token, node);
    }

    return {
        "VariableDeclaration": checkNode,
        "ExpressionStatement": checkNode,
        "BreakStatement": checkNode,
        "ContinueStatement": checkNode,
        "DebuggerStatement": checkNode,
        "ReturnStatement": checkNode,
        "ThrowStatement": checkNode,
        "ForStatement": function(node) {
            if (node.init) {
                checkSemicolonSpacing(context.getTokenAfter(node.init), node);
            }

            if (node.test) {
                checkSemicolonSpacing(context.getTokenAfter(node.test), node);
            }
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "before": {
                "type": "boolean"
            },
            "after": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/semi.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var OPT_OUT_PATTERN = /[\[\(\/\+\-]/; // One of [(/+-
    var options = context.options[1];
    var never = context.options[0] === "never",
        exceptOneLine = options && options.omitLastInOneLineBlock === true,
        sourceCode = context.getSourceCode();

    function report(node, missing) {
        var message,
            fix,
            lastToken = sourceCode.getLastToken(node),
            loc = lastToken.loc;

        if (!missing) {
            message = "Missing semicolon.";
            loc = loc.end;
            fix = function(fixer) {
                return fixer.insertTextAfter(lastToken, ";");
            };
        } else {
            message = "Extra semicolon.";
            loc = loc.start;
            fix = function(fixer) {
                return fixer.remove(lastToken);
            };
        }

        context.report({
            node: node,
            loc: loc,
            message: message,
            fix: fix
        });

    }

    function isSemicolon(token) {
        return (token.type === "Punctuator" && token.value === ";");
    }

    function isUnnecessarySemicolon(lastToken) {
        var isDivider, isOptOutToken, lastTokenLine, nextToken, nextTokenLine;

        if (!isSemicolon(lastToken)) {
            return false;
        }

        nextToken = context.getTokenAfter(lastToken);

        if (!nextToken) {
            return true;
        }

        lastTokenLine = lastToken.loc.end.line;
        nextTokenLine = nextToken.loc.start.line;
        isOptOutToken = OPT_OUT_PATTERN.test(nextToken.value);
        isDivider = (nextToken.value === "}" || nextToken.value === ";");

        return (lastTokenLine !== nextTokenLine && !isOptOutToken) || isDivider;
    }

    function isOneLinerBlock(node) {
        var nextToken = context.getTokenAfter(node);
        if (!nextToken || nextToken.value !== "}") {
            return false;
        }

        var parent = node.parent;
        return parent && parent.type === "BlockStatement" &&
          parent.loc.start.line === parent.loc.end.line;
    }

    function checkForSemicolon(node) {
        var lastToken = context.getLastToken(node);

        if (never) {
            if (isUnnecessarySemicolon(lastToken)) {
                report(node, true);
            }
        } else {
            if (!isSemicolon(lastToken)) {
                if (!exceptOneLine || !isOneLinerBlock(node)) {
                    report(node);
                }
            } else {
                if (exceptOneLine && isOneLinerBlock(node)) {
                    report(node, true);
                }
            }
        }
    }

    function checkForSemicolonForVariableDeclaration(node) {
        var ancestors = context.getAncestors(),
            parentIndex = ancestors.length - 1,
            parent = ancestors[parentIndex];

        if ((parent.type !== "ForStatement" || parent.init !== node) &&
            (!/^For(?:In|Of)Statement/.test(parent.type) || parent.left !== node)
        ) {
            checkForSemicolon(node);
        }
    }

    return {
        "VariableDeclaration": checkForSemicolonForVariableDeclaration,
        "ExpressionStatement": checkForSemicolon,
        "ReturnStatement": checkForSemicolon,
        "ThrowStatement": checkForSemicolon,
        "DoWhileStatement": checkForSemicolon,
        "DebuggerStatement": checkForSemicolon,
        "BreakStatement": checkForSemicolon,
        "ContinueStatement": checkForSemicolon,
        "ImportDeclaration": checkForSemicolon,
        "ExportAllDeclaration": checkForSemicolon,
        "ExportNamedDeclaration": function(node) {
            if (!node.declaration) {
                checkForSemicolon(node);
            }
        },
        "ExportDefaultDeclaration": function(node) {
            if (!/(?:Class|Function)Declaration/.test(node.declaration.type)) {
                checkForSemicolon(node);
            }
        }
    };

};

module.exports.schema = {
    "anyOf": [
        {
            "type": "array",
            "items": [
                {
                    "enum": ["never"]
                }
            ],
            "minItems": 0,
            "maxItems": 1
        },
        {
            "type": "array",
            "items": [
                {
                    "enum": ["always"]
                },
                {
                    "type": "object",
                    "properties": {
                        "omitLastInOneLineBlock": {"type": "boolean"}
                    },
                    "additionalProperties": false
                }
            ],
            "minItems": 0,
            "maxItems": 2
        }
    ]
};

},
   {}],

"/tmp/rules/sort-imports.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var configuration = context.options[0] || {},
        ignoreCase = configuration.ignoreCase || false,
        ignoreMemberSort = configuration.ignoreMemberSort || false,
        memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || ["none", "all", "multiple", "single"],
        previousDeclaration = null;

    function usedMemberSyntax(node) {
        if (node.specifiers.length === 0) {
            return "none";
        } else if (node.specifiers[0].type === "ImportNamespaceSpecifier") {
            return "all";
        } else if (node.specifiers.length === 1) {
            return "single";
        } else {
            return "multiple";
        }
    }

    function getMemberParameterGroupIndex(node) {
        return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));
    }

    function getFirstLocalMemberName(node) {
        if (node.specifiers[0]) {
            return node.specifiers[0].local.name;
        } else {
            return null;
        }
    }

    return {
        "ImportDeclaration": function(node) {
            if (previousDeclaration) {
                var currentLocalMemberName = getFirstLocalMemberName(node),
                    currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),
                    previousLocalMemberName = getFirstLocalMemberName(previousDeclaration),
                    previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);

                if (ignoreCase) {
                    previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();
                    currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();
                }

                if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {
                    if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {
                        context.report({
                            node: node,
                            message: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.",
                            data: {
                                syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],
                                syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]
                            }
                        });
                    }
                } else {
                    if (previousLocalMemberName &&
                        currentLocalMemberName &&
                        currentLocalMemberName < previousLocalMemberName
                    ) {
                        context.report({
                            node: node,
                            message: "Imports should be sorted alphabetically."
                        });
                    }
                }
            }

            if (!ignoreMemberSort && node.specifiers.length > 1) {
                var previousSpecifier = null;
                var previousSpecifierName = null;

                for (var i = 0; i < node.specifiers.length; ++i) {
                    var currentSpecifier = node.specifiers[i];
                    if (currentSpecifier.type !== "ImportSpecifier") {
                        continue;
                    }

                    var currentSpecifierName = currentSpecifier.local.name;
                    if (ignoreCase) {
                        currentSpecifierName = currentSpecifierName.toLowerCase();
                    }

                    if (previousSpecifier && currentSpecifierName < previousSpecifierName) {
                        context.report({
                            node: currentSpecifier,
                            message: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
                            data: {
                                memberName: currentSpecifier.local.name
                            }
                        });
                    }

                    previousSpecifier = currentSpecifier;
                    previousSpecifierName = currentSpecifierName;
                }
            }

            previousDeclaration = node;
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "ignoreCase": {
                "type": "boolean"
            },
            "memberSyntaxSortOrder": {
                "type": "array",
                "items": {
                    "enum": ["none", "all", "multiple", "single"]
                },
                "uniqueItems": true,
                "minItems": 4,
                "maxItems": 4
            },
            "ignoreMemberSort": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/sort-vars.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var configuration = context.options[0] || {},
        ignoreCase = configuration.ignoreCase || false;

    return {
        "VariableDeclaration": function(node) {
            node.declarations.reduce(function(memo, decl) {
                if (decl.id.type === "ObjectPattern" || decl.id.type === "ArrayPattern") {
                    return memo;
                }

                var lastVariableName = memo.id.name,
                    currenVariableName = decl.id.name;

                if (ignoreCase) {
                    lastVariableName = lastVariableName.toLowerCase();
                    currenVariableName = currenVariableName.toLowerCase();
                }

                if (currenVariableName < lastVariableName) {
                    context.report(decl, "Variables within the same declaration block should be sorted alphabetically");
                    return memo;
                } else {
                    return decl;
                }
            }, node.declarations[0]);
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "ignoreCase": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/space-before-blocks.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    var config = context.options[0],
        sourceCode = context.getSourceCode(),
        checkFunctions = true,
        checkKeywords = true,
        checkClasses = true;

    if (typeof config === "object") {
        checkFunctions = config.functions !== "never";
        checkKeywords = config.keywords !== "never";
        checkClasses = config.classes !== "never";
    } else if (config === "never") {
        checkFunctions = false;
        checkKeywords = false;
        checkClasses = false;
    }

    function isConflicted(token) {
        return (token.type === "Punctuator" && token.value === "=>") || token.type === "Keyword";
    }

    function checkPrecedingSpace(node) {
        var precedingToken = context.getTokenBefore(node),
            hasSpace,
            parent,
            requireSpace;

        if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) {
            hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);
            parent = context.getAncestors().pop();
            if (parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration") {
                requireSpace = checkFunctions;
            } else if (node.type === "ClassBody") {
                requireSpace = checkClasses;
            } else {
                requireSpace = checkKeywords;
            }

            if (requireSpace) {
                if (!hasSpace) {
                    context.report({
                        node: node,
                        message: "Missing space before opening brace.",
                        fix: function(fixer) {
                            return fixer.insertTextBefore(node, " ");
                        }
                    });
                }
            } else {
                if (hasSpace) {
                    context.report({
                        node: node,
                        message: "Unexpected space before opening brace.",
                        fix: function(fixer) {
                            return fixer.removeRange([precedingToken.range[1], node.range[0]]);
                        }
                    });
                }
            }
        }
    }

    function checkSpaceBeforeCaseBlock(node) {
        var cases = node.cases,
            firstCase,
            openingBrace;

        if (cases.length > 0) {
            firstCase = cases[0];
            openingBrace = context.getTokenBefore(firstCase);
        } else {
            openingBrace = context.getLastToken(node, 1);
        }

        checkPrecedingSpace(openingBrace);
    }

    return {
        "BlockStatement": checkPrecedingSpace,
        "ClassBody": checkPrecedingSpace,
        "SwitchStatement": checkSpaceBeforeCaseBlock
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["always", "never"]
            },
            {
                "type": "object",
                "properties": {
                    "keywords": {
                        "enum": ["always", "never"]
                    },
                    "functions": {
                        "enum": ["always", "never"]
                    },
                    "classes": {
                        "enum": ["always", "never"]
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/space-before-function-paren.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var configuration = context.options[0],
        sourceCode = context.getSourceCode(),
        requireAnonymousFunctionSpacing = true,
        requireNamedFunctionSpacing = true;

    if (typeof configuration === "object") {
        requireAnonymousFunctionSpacing = configuration.anonymous !== "never";
        requireNamedFunctionSpacing = configuration.named !== "never";
    } else if (configuration === "never") {
        requireAnonymousFunctionSpacing = false;
        requireNamedFunctionSpacing = false;
    }

    function isNamedFunction(node) {
        var parent;

        if (node.id) {
            return true;
        }

        parent = node.parent;
        return parent.type === "MethodDefinition" ||
            (parent.type === "Property" &&
                (
                    parent.kind === "get" ||
                    parent.kind === "set" ||
                    parent.method
                )
            );
    }

    function validateSpacingBeforeParentheses(node) {
        var isNamed = isNamedFunction(node),
            leftToken,
            rightToken,
            location;

        if (node.generator && !isNamed) {
            return;
        }

        rightToken = sourceCode.getFirstToken(node);
        while (rightToken.value !== "(") {
            rightToken = sourceCode.getTokenAfter(rightToken);
        }
        leftToken = context.getTokenBefore(rightToken);
        location = leftToken.loc.end;

        if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
            if ((isNamed && !requireNamedFunctionSpacing) || (!isNamed && !requireAnonymousFunctionSpacing)) {
                context.report({
                    node: node,
                    loc: location,
                    message: "Unexpected space before function parentheses.",
                    fix: function(fixer) {
                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
                    }
                });
            }
        } else {
            if ((isNamed && requireNamedFunctionSpacing) || (!isNamed && requireAnonymousFunctionSpacing)) {
                context.report({
                    node: node,
                    loc: location,
                    message: "Missing space before function parentheses.",
                    fix: function(fixer) {
                        return fixer.insertTextAfter(leftToken, " ");
                    }
                });
            }
        }
    }

    return {
        "FunctionDeclaration": validateSpacingBeforeParentheses,
        "FunctionExpression": validateSpacingBeforeParentheses
    };
};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["always", "never"]
            },
            {
                "type": "object",
                "properties": {
                    "anonymous": {
                        "enum": ["always", "never"]
                    },
                    "named": {
                        "enum": ["always", "never"]
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/space-in-parens.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var MISSING_SPACE_MESSAGE = "There must be a space inside this paren.",
        REJECTED_SPACE_MESSAGE = "There should be no spaces inside this paren.",
        ALWAYS = context.options[0] === "always",

        exceptionsArrayOptions = (context.options.length === 2) ? context.options[1].exceptions : [],
        options = {},
        exceptions;

    if (exceptionsArrayOptions.length) {
        options.braceException = exceptionsArrayOptions.indexOf("{}") !== -1;
        options.bracketException = exceptionsArrayOptions.indexOf("[]") !== -1;
        options.parenException = exceptionsArrayOptions.indexOf("()") !== -1;
        options.empty = exceptionsArrayOptions.indexOf("empty") !== -1;
    }

    function getExceptions() {
        var openers = [],
            closers = [];
        if (options.braceException) {
            openers.push("{");
            closers.push("}");
        }

        if (options.bracketException) {
            openers.push("[");
            closers.push("]");
        }

        if (options.parenException) {
            openers.push("(");
            closers.push(")");
        }

        if (options.empty) {
            openers.push(")");
            closers.push("(");
        }

        return {
            openers: openers,
            closers: closers
        };
    }

    var sourceCode = context.getSourceCode();

    function isOpenerException(token) {
        return token.type === "Punctuator" && exceptions.openers.indexOf(token.value) >= 0;
    }

    function isCloserException(token) {
        return token.type === "Punctuator" && exceptions.closers.indexOf(token.value) >= 0;
    }

    function shouldOpenerHaveSpace(left, right) {
        if (sourceCode.isSpaceBetweenTokens(left, right)) {
            return false;
        }

        if (ALWAYS) {
            if (right.type === "Punctuator" && right.value === ")") {
                return false;
            }
            return !isOpenerException(right);
        } else {
            return isOpenerException(right);
        }
    }

    function shouldCloserHaveSpace(left, right) {
        if (left.type === "Punctuator" && left.value === "(") {
            return false;
        }

        if (sourceCode.isSpaceBetweenTokens(left, right)) {
            return false;
        }

        if (ALWAYS) {
            return !isCloserException(left);
        } else {
            return isCloserException(left);
        }
    }

    function shouldOpenerRejectSpace(left, right) {
        if (right.type === "Line") {
            return false;
        }

        if (!astUtils.isTokenOnSameLine(left, right)) {
            return false;
        }

        if (!sourceCode.isSpaceBetweenTokens(left, right)) {
            return false;
        }

        if (ALWAYS) {
            return isOpenerException(right);
        } else {
            return !isOpenerException(right);
        }
    }

    function shouldCloserRejectSpace(left, right) {
        if (left.type === "Punctuator" && left.value === "(") {
            return false;
        }

        if (!astUtils.isTokenOnSameLine(left, right)) {
            return false;
        }

        if (!sourceCode.isSpaceBetweenTokens(left, right)) {
            return false;
        }

        if (ALWAYS) {
            return isCloserException(left);
        } else {
            return !isCloserException(left);
        }
    }

    return {
        "Program": function checkParenSpaces(node) {
            var tokens, prevToken, nextToken;
            exceptions = getExceptions();
            tokens = sourceCode.tokensAndComments;

            tokens.forEach(function(token, i) {
                prevToken = tokens[i - 1];
                nextToken = tokens[i + 1];

                if (token.type !== "Punctuator") {
                    return;
                }

                if (token.value !== "(" && token.value !== ")") {
                    return;
                }

                if (token.value === "(" && shouldOpenerHaveSpace(token, nextToken)) {
                    context.report({
                        node: node,
                        loc: token.loc.start,
                        message: MISSING_SPACE_MESSAGE,
                        fix: function(fixer) {
                            return fixer.insertTextAfter(token, " ");
                        }
                    });
                } else if (token.value === "(" && shouldOpenerRejectSpace(token, nextToken)) {
                    context.report({
                        node: node,
                        loc: token.loc.start,
                        message: REJECTED_SPACE_MESSAGE,
                        fix: function(fixer) {
                            return fixer.removeRange([token.range[1], nextToken.range[0]]);
                        }
                    });
                } else if (token.value === ")" && shouldCloserHaveSpace(prevToken, token)) {
                    context.report({
                        node: node,
                        loc: token.loc.start,
                        message: MISSING_SPACE_MESSAGE,
                        fix: function(fixer) {
                            return fixer.insertTextBefore(token, " ");
                        }
                    });
                } else if (token.value === ")" && shouldCloserRejectSpace(prevToken, token)) {
                    context.report({
                        node: node,
                        loc: token.loc.start,
                        message: REJECTED_SPACE_MESSAGE,
                        fix: function(fixer) {
                            return fixer.removeRange([prevToken.range[1], token.range[0]]);
                        }
                    });
                }
            });
        }
    };

};

module.exports.schema = [
    {
        "enum": ["always", "never"]
    },
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "array",
                "items": {
                    "enum": ["{}", "[]", "()", "empty"]
                },
                "uniqueItems": true
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/space-infix-ops.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;

    var OPERATORS = [
        "*", "/", "%", "+", "-", "<<", ">>", ">>>", "<", "<=", ">", ">=", "in",
        "instanceof", "==", "!=", "===", "!==", "&", "^", "|", "&&", "||", "=",
        "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "^=", "|=",
        "?", ":", ",", "**"
    ];

    function getFirstNonSpacedToken(left, right) {
        var op, tokens = context.getTokensBetween(left, right, 1);
        for (var i = 1, l = tokens.length - 1; i < l; ++i) {
            op = tokens[i];
            if (
                op.type === "Punctuator" &&
                OPERATORS.indexOf(op.value) >= 0 &&
                (tokens[i - 1].range[1] >= op.range[0] || op.range[1] >= tokens[i + 1].range[0])
            ) {
                return op;
            }
        }
        return null;
    }

    function report(mainNode, culpritToken) {
        context.report({
            node: mainNode,
            loc: culpritToken.loc.start,
            message: "Infix operators must be spaced.",
            fix: function(fixer) {
                var previousToken = context.getTokenBefore(culpritToken);
                var afterToken = context.getTokenAfter(culpritToken);
                var fixString = "";

                if (culpritToken.range[0] - previousToken.range[1] === 0) {
                    fixString = " ";
                }

                fixString += culpritToken.value;

                if (afterToken.range[0] - culpritToken.range[1] === 0) {
                    fixString += " ";
                }

                return fixer.replaceText(culpritToken, fixString);
            }
        });
    }

    function checkBinary(node) {
        var nonSpacedNode = getFirstNonSpacedToken(node.left, node.right);

        if (nonSpacedNode) {
            if (!(int32Hint && context.getSource(node).substr(-2) === "|0")) {
                report(node, nonSpacedNode);
            }
        }
    }

    function checkConditional(node) {
        var nonSpacedConsequesntNode = getFirstNonSpacedToken(node.test, node.consequent);
        var nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate);

        if (nonSpacedConsequesntNode) {
            report(node, nonSpacedConsequesntNode);
        } else if (nonSpacedAlternateNode) {
            report(node, nonSpacedAlternateNode);
        }
    }

    function checkVar(node) {
        var nonSpacedNode;

        if (node.init) {
            nonSpacedNode = getFirstNonSpacedToken(node.id, node.init);
            if (nonSpacedNode) {
                report(node, nonSpacedNode);
            }
        }
    }

    return {
        "AssignmentExpression": checkBinary,
        "AssignmentPattern": checkBinary,
        "BinaryExpression": checkBinary,
        "LogicalExpression": checkBinary,
        "ConditionalExpression": checkConditional,
        "VariableDeclarator": checkVar
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "int32Hint": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/space-unary-ops.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var options = context.options && Array.isArray(context.options) && context.options[0] || { words: true, nonwords: false };

    function isFirstBangInBangBangExpression(node) {
        return node && node.type === "UnaryExpression" && node.argument.operator === "!" &&
            node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
    }

    function isArgumentObjectExpression(node) {
        return node.argument && node.argument.type && node.argument.type === "ObjectExpression";
    }

    function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
        word = word || firstToken.value;

        if (options.words) {
            if (secondToken.range[0] === firstToken.range[1]) {
                context.report({
                    node: node,
                    message: "Unary word operator '" + word + "' must be followed by whitespace.",
                    fix: function(fixer) {
                        return fixer.insertTextAfter(firstToken, " ");
                    }
                });
            }
        }

        if (!options.words && isArgumentObjectExpression(node)) {
            if (secondToken.range[0] > firstToken.range[1]) {
                context.report({
                    node: node,
                    message: "Unexpected space after unary word operator '" + word + "'.",
                    fix: function(fixer) {
                        return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                    }
                });
            }
        }
    }

    function checkForSpaces(node) {
        var tokens = context.getFirstTokens(node, 2),
            firstToken = tokens[0],
            secondToken = tokens[1];

        if ((node.type === "NewExpression" || node.prefix) && firstToken.type === "Keyword") {
            checkUnaryWordOperatorForSpaces(node, firstToken, secondToken);
            return;
        }

        if (options.nonwords) {
            if (node.prefix) {
                if (isFirstBangInBangBangExpression(node)) {
                    return;
                }
                if (firstToken.range[1] === secondToken.range[0]) {
                    context.report({
                        node: node,
                        message: "Unary operator '" + firstToken.value + "' must be followed by whitespace.",
                        fix: function(fixer) {
                            return fixer.insertTextAfter(firstToken, " ");
                        }
                    });
                }
            } else {
                if (firstToken.range[1] === secondToken.range[0]) {
                    context.report({
                        node: node,
                        message: "Space is required before unary expressions '" + secondToken.value + "'.",
                        fix: function(fixer) {
                            return fixer.insertTextBefore(secondToken, " ");
                        }
                    });
                }
            }
        } else {
            if (node.prefix) {
                if (secondToken.range[0] > firstToken.range[1]) {
                    context.report({
                        node: node,
                        message: "Unexpected space after unary operator '" + firstToken.value + "'.",
                        fix: function(fixer) {
                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                        }
                    });
                }
            } else {
                if (secondToken.range[0] > firstToken.range[1]) {
                    context.report({
                        node: node,
                        message: "Unexpected space before unary operator '" + secondToken.value + "'.",
                        fix: function(fixer) {
                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                        }
                    });
                }
            }
        }
    }

    return {
        "UnaryExpression": checkForSpaces,
        "UpdateExpression": checkForSpaces,
        "NewExpression": checkForSpaces,
        "YieldExpression": function(node) {
            var tokens = context.getFirstTokens(node, 3),
                word = "yield";

            if (!node.argument || node.delegate) {
                return;
            }

            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "words": {
                "type": "boolean"
            },
            "nonwords": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/spaced-comment.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

function escape(s) {
    var isOneChar = s.length === 1;
    s = lodash.escapeRegExp(s);
    return isOneChar ? s : "(?:" + s + ")";
}

function escapeAndRepeat(s) {
    return escape(s) + "+";
}

function parseMarkersOption(markers) {
    markers = markers ? markers.slice(0) : [];

    if (markers.indexOf("*") === -1) {
        markers.push("*");
    }

    return markers;
}

function createAlwaysStylePattern(markers, exceptions) {
    var pattern = "^";

    if (markers.length === 1) {
        pattern += escape(markers[0]);
    } else {
        pattern += "(?:";
        pattern += markers.map(escape).join("|");
        pattern += ")";
    }
    pattern += "?"; // or nothing.

    if (exceptions.length === 0) {
        pattern += "\\s";
    } else {
        pattern += "(?:\\s|";
        if (exceptions.length === 1) {
            pattern += escapeAndRepeat(exceptions[0]);
        } else {
            pattern += "(?:";
            pattern += exceptions.map(escapeAndRepeat).join("|");
            pattern += ")";
        }
        pattern += "(?:$|[\n\r]))"; // the sequence continues until the end.
    }
    return new RegExp(pattern);
}

function createNeverStylePattern(markers) {
    var pattern = "^(" + markers.map(escape).join("|") + ")?[ \t]+";
    return new RegExp(pattern);
}

module.exports = function(context) {
    var requireSpace = context.options[0] !== "never";

    var config = context.options[1] || {};
    var styleRules = ["block", "line"].reduce(function(rule, type) {
        var markers = parseMarkersOption(config[type] && config[type].markers || config.markers);
        var exceptions = config[type] && config[type].exceptions || config.exceptions || [];

        rule[type] = {
            regex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
            hasExceptions: exceptions.length > 0,
            markers: new RegExp("^(" + markers.map(escape).join("|") + ")")
        };

        return rule;
    }, {});

    function report(node, message, match) {
        var type = node.type.toLowerCase(),
            commentIdentifier = type === "block" ? "/*" : "//";

        context.report({
            node: node,
            fix: function(fixer) {
                var start = node.range[0],
                    end = start + 2;

                if (requireSpace) {
                    if (match) {
                        end += match[0].length;
                    }
                    return fixer.insertTextAfterRange([start, end], " ");
                } else {
                    end += match[0].length;
                    return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : ""));
                }
            },
            message: message
        });
    }

    function checkCommentForSpace(node) {
        var type = node.type.toLowerCase(),
            rule = styleRules[type],
            commentIdentifier = type === "block" ? "/*" : "//";

        if (node.value.length === 0 || type === "block") {
            return;
        }

        if (requireSpace) {
            if (!rule.regex.test(node.value)) {
                var hasMarker = rule.markers.exec(node.value);
                var marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;
                if (rule.hasExceptions) {
                    report(node, "Expected exception block, space or tab after '" + marker + "' in comment.", hasMarker);
                } else {
                    report(node, "Expected space or tab after '" + marker + "' in comment.", hasMarker);
                }
            }
        } else {
            var matched = rule.regex.exec(node.value);
            if (matched) {
                if (!matched[1]) {
                    report(node, "Unexpected space or tab after '" + commentIdentifier + "' in comment.", matched);
                } else {
                    report(node, "Unexpected space or tab after marker (" + matched[1] + ") in comment.", matched);
                }
            }
        }
    }

    return {

        "LineComment": checkCommentForSpace,
        "BlockComment": checkCommentForSpace

    };
};

module.exports.schema = [
    {
        "enum": ["always", "never"]
    },
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "markers": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "line": {
                "type": "object",
                "properties": {
                    "exceptions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "markers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "additionalProperties": false
            },
            "block": {
                "type": "object",
                "properties": {
                    "exceptions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "markers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "additionalProperties": false
            }
        },
        "additionalProperties": false
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/strict.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

var messages = {
    function: "Use the function form of 'use strict'.",
    global: "Use the global form of 'use strict'.",
    multiple: "Multiple 'use strict' directives.",
    never: "Strict mode is not permitted.",
    unnecessary: "Unnecessary 'use strict' directive.",
    module: "'use strict' is unnecessary inside of modules.",
    implied: "'use strict' is unnecessary when implied strict mode is enabled.",
    unnecessaryInClasses: "'use strict' is unnecessary inside of classes."
};

function getUseStrictDirectives(statements) {
    var directives = [],
        i, statement;

    for (i = 0; i < statements.length; i++) {
        statement = statements[i];

        if (
            statement.type === "ExpressionStatement" &&
            statement.expression.type === "Literal" &&
            statement.expression.value === "use strict"
        ) {
            directives[i] = statement;
        } else {
            break;
        }
    }

    return directives;
}

module.exports = function(context) {

    var mode = context.options[0] || "safe",
        ecmaFeatures = context.parserOptions.ecmaFeatures || {},
        scopes = [],
        classScopes = [],
        rule;

    if (ecmaFeatures.impliedStrict) {
        mode = "implied";
    } else if (mode === "safe") {
        mode = ecmaFeatures.globalReturn ? "global" : "function";
    }

    function reportSlice(nodes, start, end, message) {
        var i;

        for (i = start; i < end; i++) {
            context.report(nodes[i], message);
        }
    }

    function reportAll(nodes, message) {
        reportSlice(nodes, 0, nodes.length, message);
    }

    function reportAllExceptFirst(nodes, message) {
        reportSlice(nodes, 1, nodes.length, message);
    }

    function enterFunctionInFunctionMode(node, useStrictDirectives) {
        var isInClass = classScopes.length > 0,
            isParentGlobal = scopes.length === 0 && classScopes.length === 0,
            isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],
            isStrict = useStrictDirectives.length > 0;

        if (isStrict) {
            if (isParentStrict) {
                context.report(useStrictDirectives[0], messages.unnecessary);
            } else if (isInClass) {
                context.report(useStrictDirectives[0], messages.unnecessaryInClasses);
            }

            reportAllExceptFirst(useStrictDirectives, messages.multiple);
        } else if (isParentGlobal) {
            context.report(node, messages.function);
        }

        scopes.push(isParentStrict || isStrict);
    }

    function exitFunctionInFunctionMode() {
        scopes.pop();
    }

    function enterFunction(node) {
        var isBlock = node.body.type === "BlockStatement",
            useStrictDirectives = isBlock ?
                getUseStrictDirectives(node.body.body) : [];

        if (mode === "function") {
            enterFunctionInFunctionMode(node, useStrictDirectives);
        } else {
            reportAll(useStrictDirectives, messages[mode]);
        }
    }

    rule = {
        "Program": function(node) {
            var useStrictDirectives = getUseStrictDirectives(node.body);

            if (node.sourceType === "module") {
                mode = "module";
            }

            if (mode === "global") {
                if (node.body.length > 0 && useStrictDirectives.length === 0) {
                    context.report(node, messages.global);
                }
                reportAllExceptFirst(useStrictDirectives, messages.multiple);
            } else {
                reportAll(useStrictDirectives, messages[mode]);
            }
        },
        "FunctionDeclaration": enterFunction,
        "FunctionExpression": enterFunction,
        "ArrowFunctionExpression": enterFunction
    };

    if (mode === "function") {
        lodash.assign(rule, {
            "ClassBody": function() {
                classScopes.push(true);
            },
            "ClassBody:exit": function() {
                classScopes.pop();
            },

            "FunctionDeclaration:exit": exitFunctionInFunctionMode,
            "FunctionExpression:exit": exitFunctionInFunctionMode,
            "ArrowFunctionExpression:exit": exitFunctionInFunctionMode
        });
    }

    return rule;
};

module.exports.schema = [
    {
        "enum": ["never", "global", "function", "safe"]
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/template-curly-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

var OPEN_PAREN = /\$\{$/;
var CLOSE_PAREN = /^\}/;

module.exports = function(context) {
    var sourceCode = context.getSourceCode();
    var always = context.options[0] === "always";
    var prefix = always ? "Expected" : "Unexpected";

    function checkSpacingBefore(token) {
        var prevToken = sourceCode.getTokenBefore(token);
        if (prevToken &&
            CLOSE_PAREN.test(token.value) &&
            astUtils.isTokenOnSameLine(prevToken, token) &&
            sourceCode.isSpaceBetweenTokens(prevToken, token) !== always
        ) {
            context.report({
                loc: token.loc.start,
                message: prefix + " space(s) before '}'.",
                fix: function(fixer) {
                    if (always) {
                        return fixer.insertTextBefore(token, " ");
                    }
                    return fixer.removeRange([
                        prevToken.range[1],
                        token.range[0]
                    ]);
                }
            });
        }
    }

    function checkSpacingAfter(token) {
        var nextToken = sourceCode.getTokenAfter(token);
        if (nextToken &&
            OPEN_PAREN.test(token.value) &&
            astUtils.isTokenOnSameLine(token, nextToken) &&
            sourceCode.isSpaceBetweenTokens(token, nextToken) !== always
        ) {
            context.report({
                loc: {
                    line: token.loc.end.line,
                    column: token.loc.end.column - 2
                },
                message: prefix + " space(s) after '${'.",
                fix: function(fixer) {
                    if (always) {
                        return fixer.insertTextAfter(token, " ");
                    }
                    return fixer.removeRange([
                        token.range[1],
                        nextToken.range[0]
                    ]);
                }
            });
        }
    }

    return {
        TemplateElement: function(node) {
            var token = sourceCode.getFirstToken(node);
            checkSpacingBefore(token);
            checkSpacingAfter(token);
        }
    };
};

module.exports.schema = [
    {enum: ["always", "never"]}
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/use-isnan.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "BinaryExpression": function(node) {
            if (/^(?:[<>]|[!=]=)=?$/.test(node.operator) && (node.left.name === "NaN" || node.right.name === "NaN")) {
                context.report(node, "Use the isNaN function to compare with NaN.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/valid-jsdoc.js": [function(require,module,exports){
"use strict";

var doctrine = require("doctrine");

module.exports = function(context) {

    var options = context.options[0] || {},
        prefer = options.prefer || {},
        sourceCode = context.getSourceCode(),

        requireReturn = options.requireReturn !== false,
        requireParamDescription = options.requireParamDescription !== false,
        requireReturnDescription = options.requireReturnDescription !== false,
        requireReturnType = options.requireReturnType !== false,
        preferType = options.preferType || {},
        checkPreferType = Object.keys(preferType).length !== 0;

    var fns = [];

    function isTypeClass(node) {
        return node.type === "ClassExpression" || node.type === "ClassDeclaration";
    }

    function startFunction(node) {
        fns.push({
            returnPresent: (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") ||
                isTypeClass(node)
        });
    }

    function addReturn(node) {
        var functionState = fns[fns.length - 1];

        if (functionState && node.argument !== null) {
            functionState.returnPresent = true;
        }
    }

    function isValidReturnType(tag) {
        return tag.type === null || tag.type.name === "void" || tag.type.type === "UndefinedLiteral";
    }

    function canTypeBeValidated(type) {
        return type !== "UndefinedLiteral" && // {undefined} as there is no name property available.
               type !== "NullLiteral" && // {null}
               type !== "NullableLiteral" && // {?}
               type !== "FunctionType" && // {function(a)}
               type !== "AllLiteral"; // {*}
    }

    function getCurrentExpectedTypes(type) {
        var currentType;
        var expectedType;

        if (!type.name) {
            currentType = type.expression.name;
        } else {
            currentType = type.name;
        }

        expectedType = preferType[currentType];

        return {
            currentType: currentType,
            expectedType: expectedType
        };
    }

    function validateTagType(tag, jsdocNode) {
        if (!tag.type || !canTypeBeValidated(tag.type.type)) {
            return;
        }

        var typesToCheck = [];
        var elements = [];

        if (tag.type.type === "TypeApplication") { // {Array.<String>}
            elements = tag.type.applications;
            typesToCheck.push(getCurrentExpectedTypes(tag.type));
        } else if (tag.type.type === "RecordType") { // {{20:String}}
            elements = tag.type.fields;
        } else if (tag.type.type === "UnionType") { // {String|number|Test}
            elements = tag.type.elements;
        } else {
            typesToCheck.push(getCurrentExpectedTypes(tag.type));
        }

        elements.forEach(function(type) {
            type = type.value ? type.value : type; // we have to use type.value for RecordType
            if (canTypeBeValidated(type.type)) {
                typesToCheck.push(getCurrentExpectedTypes(type));
            }
        });

        typesToCheck.forEach(function(type) {
            if (type.expectedType &&
                type.expectedType !== type.currentType) {
                context.report({
                    node: jsdocNode,
                    message: "Use '{{expectedType}}' instead of '{{currentType}}'.",
                    data: {
                        currentType: type.currentType,
                        expectedType: type.expectedType
                    }
                });
            }
        });
    }

    function checkJSDoc(node) {
        var jsdocNode = sourceCode.getJSDocComment(node),
            functionData = fns.pop(),
            hasReturns = false,
            hasConstructor = false,
            isInterface = false,
            isOverride = false,
            params = Object.create(null),
            jsdoc;

        if (jsdocNode) {

            try {
                jsdoc = doctrine.parse(jsdocNode.value, {
                    strict: true,
                    unwrap: true,
                    sloppy: true
                });
            } catch (ex) {

                if (/braces/i.test(ex.message)) {
                    context.report(jsdocNode, "JSDoc type missing brace.");
                } else {
                    context.report(jsdocNode, "JSDoc syntax error.");
                }

                return;
            }

            jsdoc.tags.forEach(function(tag) {

                switch (tag.title.toLowerCase()) {

                    case "param":
                    case "arg":
                    case "argument":
                        if (!tag.type) {
                            context.report(jsdocNode, "Missing JSDoc parameter type for '{{name}}'.", { name: tag.name });
                        }

                        if (!tag.description && requireParamDescription) {
                            context.report(jsdocNode, "Missing JSDoc parameter description for '{{name}}'.", { name: tag.name });
                        }

                        if (params[tag.name]) {
                            context.report(jsdocNode, "Duplicate JSDoc parameter '{{name}}'.", { name: tag.name });
                        } else if (tag.name.indexOf(".") === -1) {
                            params[tag.name] = 1;
                        }
                        break;

                    case "return":
                    case "returns":
                        hasReturns = true;

                        if (!requireReturn && !functionData.returnPresent && (tag.type === null || !isValidReturnType(tag))) {
                            context.report(jsdocNode, "Unexpected @" + tag.title + " tag; function has no return statement.");
                        } else {
                            if (requireReturnType && !tag.type) {
                                context.report(jsdocNode, "Missing JSDoc return type.");
                            }

                            if (!isValidReturnType(tag) && !tag.description && requireReturnDescription) {
                                context.report(jsdocNode, "Missing JSDoc return description.");
                            }
                        }

                        break;

                    case "constructor":
                    case "class":
                        hasConstructor = true;
                        break;

                    case "override":
                    case "inheritdoc":
                        isOverride = true;
                        break;

                    case "interface":
                        isInterface = true;
                        break;

                }

                if (prefer.hasOwnProperty(tag.title) && tag.title !== prefer[tag.title]) {
                    context.report(jsdocNode, "Use @{{name}} instead.", { name: prefer[tag.title] });
                }

                if (checkPreferType) {
                    validateTagType(tag, jsdocNode);
                }
            });

            if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&
                node.parent.kind !== "get" && node.parent.kind !== "constructor" &&
                node.parent.kind !== "set" && !isTypeClass(node)) {
                if (requireReturn || functionData.returnPresent) {
                    context.report(jsdocNode, "Missing JSDoc @" + (prefer.returns || "returns") + " for function.");
                }
            }

            var jsdocParams = Object.keys(params);

            if (node.params) {
                node.params.forEach(function(param, i) {
                    var name = param.name;

                    if (param.type === "Identifier") {
                        if (jsdocParams[i] && (name !== jsdocParams[i])) {
                            context.report(jsdocNode, "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.", {
                                name: name,
                                jsdocName: jsdocParams[i]
                            });
                        } else if (!params[name] && !isOverride) {
                            context.report(jsdocNode, "Missing JSDoc for parameter '{{name}}'.", {
                                name: name
                            });
                        }
                    }
                });
            }

            if (options.matchDescription) {
                var regex = new RegExp(options.matchDescription);

                if (!regex.test(jsdoc.description)) {
                    context.report(jsdocNode, "JSDoc description does not satisfy the regex pattern.");
                }
            }

        }

    }

    return {
        "ArrowFunctionExpression": startFunction,
        "FunctionExpression": startFunction,
        "FunctionDeclaration": startFunction,
        "ClassExpression": startFunction,
        "ClassDeclaration": startFunction,
        "ArrowFunctionExpression:exit": checkJSDoc,
        "FunctionExpression:exit": checkJSDoc,
        "FunctionDeclaration:exit": checkJSDoc,
        "ClassExpression:exit": checkJSDoc,
        "ClassDeclaration:exit": checkJSDoc,
        "ReturnStatement": addReturn
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "prefer": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                }
            },
            "preferType": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                }
            },
            "requireReturn": {
                "type": "boolean"
            },
            "requireParamDescription": {
                "type": "boolean"
            },
            "requireReturnDescription": {
                "type": "boolean"
            },
            "matchDescription": {
                "type": "string"
            },
            "requireReturnType": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {"doctrine":"/node_modules/doctrine/lib/doctrine.js"}],

"/tmp/rules/valid-typeof.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var VALID_TYPES = ["symbol", "undefined", "object", "boolean", "number", "string", "function"],
        OPERATORS = ["==", "===", "!=", "!=="];

    return {

        "UnaryExpression": function(node) {
            var parent, sibling;

            if (node.operator === "typeof") {
                parent = context.getAncestors().pop();

                if (parent.type === "BinaryExpression" && OPERATORS.indexOf(parent.operator) !== -1) {
                    sibling = parent.left === node ? parent.right : parent.left;

                    if (sibling.type === "Literal" && VALID_TYPES.indexOf(sibling.value) === -1) {
                        context.report(sibling, "Invalid typeof comparison value");
                    }
                }
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/vars-on-top.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var errorMessage = "All 'var' declarations must be at the top of the function scope.";

    function looksLikeDirective(node) {
        return node.type === "ExpressionStatement" &&
            node.expression.type === "Literal" && typeof node.expression.value === "string";
    }

    function looksLikeImport(node) {
        return node.type === "ImportDeclaration" || node.type === "ImportSpecifier" ||
            node.type === "ImportDefaultSpecifier" || node.type === "ImportNamespaceSpecifier";
    }

    function isVarOnTop(node, statements) {
        var i = 0, l = statements.length;

        for (; i < l; ++i) {
            if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {
                break;
            }
        }

        for (; i < l; ++i) {
            if (statements[i].type !== "VariableDeclaration") {
                return false;
            }
            if (statements[i] === node) {
                return true;
            }
        }

        return false;
    }

    function globalVarCheck(node, parent) {
        if (!isVarOnTop(node, parent.body)) {
            context.report(node, errorMessage);
        }
    }

    function blockScopeVarCheck(node, parent, grandParent) {
        if (!(/Function/.test(grandParent.type) &&
                parent.type === "BlockStatement" &&
                isVarOnTop(node, parent.body))) {
            context.report(node, errorMessage);
        }
    }

    return {
        "VariableDeclaration": function(node) {
            var ancestors = context.getAncestors();
            var parent = ancestors.pop();
            var grandParent = ancestors.pop();

            if (node.kind === "var") { // check variable is `var` type and not `let` or `const`
                if (parent.type === "Program") { // That means its a global variable
                    globalVarCheck(node, parent);
                } else {
                    blockScopeVarCheck(node, parent, grandParent);
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/wrap-iife.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var style = context.options[0] || "outside";

    function wrapped(node) {
        var previousToken = context.getTokenBefore(node),
            nextToken = context.getTokenAfter(node);
        return previousToken && previousToken.value === "(" &&
            nextToken && nextToken.value === ")";
    }

    return {

        "CallExpression": function(node) {
            if (node.callee.type === "FunctionExpression") {
                var callExpressionWrapped = wrapped(node),
                    functionExpressionWrapped = wrapped(node.callee);

                if (!callExpressionWrapped && !functionExpressionWrapped) {
                    context.report(node, "Wrap an immediate function invocation in parentheses.");
                } else if (style === "inside" && !functionExpressionWrapped) {
                    context.report(node, "Wrap only the function expression in parens.");
                } else if (style === "outside" && !callExpressionWrapped) {
                    context.report(node, "Move the invocation into the parens that contain the function.");
                }
            }
        }
    };

};

module.exports.schema = [
    {
        "enum": ["outside", "inside", "any"]
    }
];

},
   {}],

"/tmp/rules/wrap-regex.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Literal": function(node) {
            var token = context.getFirstToken(node),
                nodeType = token.type,
                source,
                grandparent,
                ancestors;

            if (nodeType === "RegularExpression") {
                source = context.getTokenBefore(node);
                ancestors = context.getAncestors();
                grandparent = ancestors[ancestors.length - 1];

                if (grandparent.type === "MemberExpression" && grandparent.object === node &&
                    (!source || source.value !== "(")) {
                    context.report(node, "Wrap the regexp literal in parens to disambiguate the slash.");
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/yield-star-spacing.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var sourceCode = context.getSourceCode();

    var mode = (function(option) {
        if (!option || typeof option === "string") {
            return {
                before: { before: true, after: false },
                after: { before: false, after: true },
                both: { before: true, after: true },
                neither: { before: false, after: false }
            }[option || "after"];
        }
        return option;
    }(context.options[0]));

    function checkSpacing(side, leftToken, rightToken) {
        if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {
            var after = leftToken.value === "*";
            var spaceRequired = mode[side];
            var node = after ? leftToken : rightToken;
            var type = spaceRequired ? "Missing" : "Unexpected";
            var message = type + " space " + side + " *.";
            context.report({
                node: node,
                message: message,
                fix: function(fixer) {
                    if (spaceRequired) {
                        if (after) {
                            return fixer.insertTextAfter(node, " ");
                        }
                        return fixer.insertTextBefore(node, " ");
                    }
                    return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
                }
            });
        }
    }

    function checkExpression(node) {
        if (!node.delegate) {
            return;
        }

        var tokens = sourceCode.getFirstTokens(node, 3);
        var yieldToken = tokens[0];
        var starToken = tokens[1];
        var nextToken = tokens[2];

        checkSpacing("before", yieldToken, starToken);
        checkSpacing("after", starToken, nextToken);
    }

    return {
        "YieldExpression": checkExpression
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["before", "after", "both", "neither"]
            },
            {
                "type": "object",
                "properties": {
                    "before": {"type": "boolean"},
                    "after": {"type": "boolean"}
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/yoda.js": [function(require,module,exports){
"use strict";

function isComparisonOperator(operator) {
    return (/^(==|===|!=|!==|<|>|<=|>=)$/).test(operator);
}

function isEqualityOperator(operator) {
    return (/^(==|===)$/).test(operator);
}

function isRangeTestOperator(operator) {
    return ["<", "<="].indexOf(operator) >= 0;
}

function looksLikeLiteral(node) {
    return (node.type === "UnaryExpression" &&
        node.operator === "-" &&
        node.prefix &&
        node.argument.type === "Literal" &&
        typeof node.argument.value === "number");
}

function getNormalizedLiteral(node) {
    if (node.type === "Literal") {
        return node;
    }

    if (looksLikeLiteral(node)) {
        return {
            type: "Literal",
            value: -node.argument.value,
            raw: "-" + node.argument.value
        };
    }

    return null;
}

function same(a, b) {
    if (a.type !== b.type) {
        return false;
    }

    switch (a.type) {
        case "Identifier":
            return a.name === b.name;
        case "Literal":
            return a.value === b.value;
        case "MemberExpression":
            return same(a.object, b.object) && same(a.property, b.property);
        case "ThisExpression":
            return true;
        default:
            return false;
    }
}

module.exports = function(context) {

    var always = (context.options[0] === "always");
    var exceptRange = (context.options[1] && context.options[1].exceptRange);
    var onlyEquality = (context.options[1] && context.options[1].onlyEquality);

    function isRangeTest(node) {
        var left = node.left,
            right = node.right;

        function isBetweenTest() {
            var leftLiteral, rightLiteral;

            return (node.operator === "&&" &&
                (leftLiteral = getNormalizedLiteral(left.left)) &&
                (rightLiteral = getNormalizedLiteral(right.right)) &&
                leftLiteral.value <= rightLiteral.value &&
                same(left.right, right.left));
        }

        function isOutsideTest() {
            var leftLiteral, rightLiteral;

            return (node.operator === "||" &&
                (leftLiteral = getNormalizedLiteral(left.right)) &&
                (rightLiteral = getNormalizedLiteral(right.left)) &&
                leftLiteral.value <= rightLiteral.value &&
                same(left.left, right.right));
        }

        function isParenWrapped() {
            var tokenBefore, tokenAfter;

            return ((tokenBefore = context.getTokenBefore(node)) &&
                tokenBefore.value === "(" &&
                (tokenAfter = context.getTokenAfter(node)) &&
                tokenAfter.value === ")");
        }

        return (node.type === "LogicalExpression" &&
            left.type === "BinaryExpression" &&
            right.type === "BinaryExpression" &&
            isRangeTestOperator(left.operator) &&
            isRangeTestOperator(right.operator) &&
            (isBetweenTest() || isOutsideTest()) &&
            isParenWrapped());
    }

    return {
        "BinaryExpression": always ? function(node) {

            if (
                (node.right.type === "Literal" || looksLikeLiteral(node.right)) &&
                !(node.left.type === "Literal" || looksLikeLiteral(node.left)) &&
                !(!isEqualityOperator(node.operator) && onlyEquality) &&
                isComparisonOperator(node.operator) &&
                !(exceptRange && isRangeTest(context.getAncestors().pop()))
            ) {
                context.report(node, "Expected literal to be on the left side of " + node.operator + ".");
            }

        } : function(node) {

            if (
                (node.left.type === "Literal" || looksLikeLiteral(node.left)) &&
                !(node.right.type === "Literal" || looksLikeLiteral(node.right)) &&
                !(!isEqualityOperator(node.operator) && onlyEquality) &&
                isComparisonOperator(node.operator) &&
                !(exceptRange && isRangeTest(context.getAncestors().pop()))
            ) {
                context.report(node, "Expected literal to be on the right side of " + node.operator + ".");
            }

        }
    };

};

module.exports.schema = [
    {
        "enum": ["always", "never"]
    },
    {
        "type": "object",
        "properties": {
            "exceptRange": {
                "type": "boolean"
            },
            "onlyEquality": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/timing.js": [function(require,module,exports){
(function (process){
"use strict";

function alignLeft(str, len, ch) {
    return str + new Array(len - str.length + 1).join(ch || " ");
}

function alignRight(str, len, ch) {
    return new Array(len - str.length + 1).join(ch || " ") + str;
}

var enabled = !!process.env.TIMING;

var HEADERS = ["Rule", "Time (ms)", "Relative"];
var ALIGN = [alignLeft, alignRight, alignRight];

function display(data) {
    var total = 0;
    var rows = Object.keys(data)
        .map(function(key) {
            var time = data[key];
            total += time;
            return [key, time];
        })
        .sort(function(a, b) {
            return b[1] - a[1];
        })
        .slice(0, 10);

    rows.forEach(function(row) {
        row.push((row[1] * 100 / total).toFixed(1) + "%");
        row[1] = row[1].toFixed(3);
    });

    rows.unshift(HEADERS);

    var widths = [];
    rows.forEach(function(row) {
        var len = row.length, i, n;
        for (i = 0; i < len; i++) {
            n = row[i].length;
            if (!widths[i] || n > widths[i]) {
                widths[i] = n;
            }
        }
    });

    var table = rows.map(function(row) {
        return row.map(function(cell, index) {
            return ALIGN[index](cell, widths[index]);
        }).join(" | ");
    });
    table.splice(1, 0, widths.map(function(w, index) {
        if (index !== 0 && index !== widths.length - 1) {
            w++;
        }

        return ALIGN[index](":", w + 1, "-");
    }).join("|"));

    console.log(table.join("\n"));
}

module.exports = (function() {

    var data = Object.create(null);

    function time(key, fn) {
        if (typeof data[key] === "undefined") {
            data[key] = 0;
        }

        return function() {
            var t = process.hrtime();
            fn.apply(null, Array.prototype.slice.call(arguments));
            t = process.hrtime(t);
            data[key] += t[0] * 1e3 + t[1] / 1e6;
        };
    }

    if (enabled) {
        process.on("exit", function() {
            display(data);
        });
    }

    return {
        time: time,
        enabled: enabled
    };

}());

}).call(this,require('_process'))
},
   {"_process":"/node_modules/browserify/node_modules/process/browser.js"}],

"/tmp/token-store.js": [function(require,module,exports){
"use strict";

module.exports = function(tokens) {
    var api = {},
        starts = Object.create(null),
        ends = Object.create(null),
        index, length, range;

    function get(start, end) {
        var result = [],
            i;

        for (i = Math.max(0, start); i < end && i < length; i++) {
            result.push(tokens[i]);
        }

        return result;
    }

    function lastTokenIndex(node) {
        var end = node.range[1],
            cursor = ends[end];

        if (typeof cursor === "undefined") {
            cursor = starts[end] - 1;
        }

        if (isNaN(cursor)) {
            cursor = length - 1;
        }

        return cursor;
    }

    for (index = 0, length = tokens.length; index < length; index++) {
        range = tokens[index].range;
        starts[range[0]] = index;
        ends[range[1]] = index;
    }

    api.getTokensBefore = function(node, beforeCount) {
        var first = starts[node.range[0]];
        return get(first - (beforeCount || 0), first);
    };

    api.getTokenBefore = function(node, skip) {
        return tokens[starts[node.range[0]] - (skip || 0) - 1];
    };

    api.getTokensAfter = function(node, afterCount) {
        var start = lastTokenIndex(node) + 1;
        return get(start, start + (afterCount || 0));
    };

    api.getTokenAfter = function(node, skip) {
        return tokens[lastTokenIndex(node) + (skip || 0) + 1];
    };

    api.getTokens = function(node, beforeCount, afterCount) {
        return get(
            starts[node.range[0]] - (beforeCount || 0),
            lastTokenIndex(node) + (afterCount || 0) + 1
        );
    };

    api.getFirstTokens = function(node, count) {
        var first = starts[node.range[0]];
        return get(
            first,
            Math.min(lastTokenIndex(node) + 1, first + (count || 0))
        );
    };

    api.getFirstToken = function(node, skip) {
        return tokens[starts[node.range[0]] + (skip || 0)];
    };

    api.getLastTokens = function(node, count) {
        var last = lastTokenIndex(node) + 1;
        return get(Math.max(starts[node.range[0]], last - (count || 0)), last);
    };

    api.getLastToken = function(node, skip) {
        return tokens[lastTokenIndex(node) - (skip || 0)];
    };

    api.getTokensBetween = function(left, right, padding) {
        padding = padding || 0;
        return get(
            lastTokenIndex(left) + 1 - padding,
            starts[right.range[0]] + padding
        );
    };

    api.getTokenByRangeStart = function(startIndex) {
        return (tokens[starts[startIndex]] || null);
    };

    return api;
};

},
   {}],

"/tmp/util/comment-event-generator.js": [function(require,module,exports){
"use strict";

function emitComments(comments, emitter, locs, eventName) {
    if (comments.length > 0) {
        comments.forEach(function(node) {
            var index = locs.indexOf(node.loc);
            if (index >= 0) {
                locs.splice(index, 1);
            } else {
                locs.push(node.loc);
                emitter.emit(node.type + eventName, node);
            }
        });
    }
}

function emitCommentsEnter(generator, comments) {
    emitComments(
        comments,
        generator.emitter,
        generator.commentLocsEnter,
        "Comment");
}

function emitCommentsExit(generator, comments) {
    emitComments(
        comments,
        generator.emitter,
        generator.commentLocsExit,
        "Comment:exit");
}

function CommentEventGenerator(originalEventGenerator, sourceCode) {
    this.original = originalEventGenerator;
    this.emitter = originalEventGenerator.emitter;
    this.sourceCode = sourceCode;
    this.commentLocsEnter = [];
    this.commentLocsExit = [];
}

CommentEventGenerator.prototype = {
    constructor: CommentEventGenerator,

    enterNode: function enterNode(node) {
        var comments = this.sourceCode.getComments(node);

        emitCommentsEnter(this, comments.leading);
        this.original.enterNode(node);
        emitCommentsEnter(this, comments.trailing);
    },

    leaveNode: function leaveNode(node) {
        var comments = this.sourceCode.getComments(node);

        emitCommentsExit(this, comments.trailing);
        this.original.leaveNode(node);
        emitCommentsExit(this, comments.leading);
    }
};

module.exports = CommentEventGenerator;

},
   {}],

"/tmp/util/keywords.js": [function(require,module,exports){
"use strict";

module.exports = [
    "abstract",
    "boolean",
    "break",
    "byte",
    "case",
    "catch",
    "char",
    "class",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "double",
    "else",
    "enum",
    "export",
    "extends",
    "false",
    "final",
    "finally",
    "float",
    "for",
    "function",
    "goto",
    "if",
    "implements",
    "import",
    "in",
    "instanceof",
    "int",
    "interface",
    "long",
    "native",
    "new",
    "null",
    "package",
    "private",
    "protected",
    "public",
    "return",
    "short",
    "static",
    "super",
    "switch",
    "synchronized",
    "this",
    "throw",
    "throws",
    "transient",
    "true",
    "try",
    "typeof",
    "var",
    "void",
    "volatile",
    "while",
    "with"
];

},
   {}],

"/tmp/util/node-event-generator.js": [function(require,module,exports){
"use strict";

function NodeEventGenerator(emitter) {
    this.emitter = emitter;
}

NodeEventGenerator.prototype = {
    constructor: NodeEventGenerator,

    enterNode: function enterNode(node) {
        this.emitter.emit(node.type, node);
    },

    leaveNode: function leaveNode(node) {
        this.emitter.emit(node.type + ":exit", node);
    }
};

module.exports = NodeEventGenerator;

},
   {}],

"/tmp/util/rule-fixer.js": [function(require,module,exports){
"use strict";

function insertTextAt(index, text) {
    return {
        range: [index, index],
        text: text
    };
}

function RuleFixer() {
    Object.freeze(this);
}

RuleFixer.prototype = {
    constructor: RuleFixer,

    insertTextAfter: function(nodeOrToken, text) {
        return this.insertTextAfterRange(nodeOrToken.range, text);
    },

    insertTextAfterRange: function(range, text) {
        return insertTextAt(range[1], text);
    },

    insertTextBefore: function(nodeOrToken, text) {
        return this.insertTextBeforeRange(nodeOrToken.range, text);
    },

    insertTextBeforeRange: function(range, text) {
        return insertTextAt(range[0], text);
    },

    replaceText: function(nodeOrToken, text) {
        return this.replaceTextRange(nodeOrToken.range, text);
    },

    replaceTextRange: function(range, text) {
        return {
            range: range,
            text: text
        };
    },

    remove: function(nodeOrToken) {
        return this.removeRange(nodeOrToken.range);
    },

    removeRange: function(range) {
        return {
            range: range,
            text: ""
        };
    }

};


module.exports = RuleFixer;

},
   {}],

"/tmp/util/source-code.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash"),
    createTokenStore = require("../token-store.js"),
    espree = require("espree"),
    estraverse = require("estraverse");

function validate(ast) {

    if (!ast.tokens) {
        throw new Error("AST is missing the tokens array.");
    }

    if (!ast.comments) {
        throw new Error("AST is missing the comments array.");
    }

    if (!ast.loc) {
        throw new Error("AST is missing location information.");
    }

    if (!ast.range) {
        throw new Error("AST is missing range information");
    }
}

function findJSDocComment(comments, line) {

    if (comments) {
        for (var i = comments.length - 1; i >= 0; i--) {
            if (comments[i].type === "Block" && comments[i].value.charAt(0) === "*") {

                if (line - comments[i].loc.end.line <= 1) {
                    return comments[i];
                } else {
                    break;
                }
            }
        }
    }

    return null;
}

function looksLikeExport(astNode) {
    return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" ||
        astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
}


function SourceCode(text, ast) {
    validate(ast);

    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);

    this.text = (this.hasBOM ? text.slice(1) : text);

    this.ast = ast;

    this.lines = SourceCode.splitLines(this.text);

    this.tokensAndComments = ast.tokens.concat(ast.comments).sort(function(left, right) {
        return left.range[0] - right.range[0];
    });

    var tokenStore = createTokenStore(ast.tokens);
    Object.keys(tokenStore).forEach(function(methodName) {
        this[methodName] = tokenStore[methodName];
    }, this);

    var tokensAndCommentsStore = createTokenStore(this.tokensAndComments);
    this.getTokenOrCommentBefore = tokensAndCommentsStore.getTokenBefore;
    this.getTokenOrCommentAfter = tokensAndCommentsStore.getTokenAfter;

    Object.freeze(this);
    Object.freeze(this.lines);
}

SourceCode.splitLines = function(text) {
    return text.split(/\r\n|\r|\n|\u2028|\u2029/g);
};

SourceCode.prototype = {
    constructor: SourceCode,

    getText: function(node, beforeCount, afterCount) {
        if (node) {
            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),
                node.range[1] + (afterCount || 0));
        } else {
            return this.text;
        }

    },

    getLines: function() {
        return this.lines;
    },

    getAllComments: function() {
        return this.ast.comments;
    },

    getComments: function(node) {

        var leadingComments = node.leadingComments || [],
            trailingComments = node.trailingComments || [];

        if (node.type === "Program") {
            if (node.body.length === 0) {
                leadingComments = node.comments;
            }
        }

        return {
            leading: leadingComments,
            trailing: trailingComments
        };
    },

    getJSDocComment: function(node) {

        var parent = node.parent;

        switch (node.type) {
            case "ClassDeclaration":
            case "FunctionDeclaration":
                if (looksLikeExport(parent)) {
                    return findJSDocComment(parent.leadingComments, parent.loc.start.line);
                }
                return findJSDocComment(node.leadingComments, node.loc.start.line);

            case "ClassExpression":
                return findJSDocComment(parent.parent.leadingComments, parent.parent.loc.start.line);

            case "ArrowFunctionExpression":
            case "FunctionExpression":

                if (parent.type !== "CallExpression" && parent.type !== "NewExpression") {
                    while (parent && !parent.leadingComments && !/Function/.test(parent.type) && parent.type !== "MethodDefinition" && parent.type !== "Property") {
                        parent = parent.parent;
                    }

                    return parent && (parent.type !== "FunctionDeclaration") ? findJSDocComment(parent.leadingComments, parent.loc.start.line) : null;
                } else if (node.leadingComments) {
                    return findJSDocComment(node.leadingComments, node.loc.start.line);
                }

            default:
                return null;
        }
    },

    getNodeByRangeIndex: function(index) {
        var result = null;
        var resultParent = null;

        estraverse.traverse(this.ast, {
            enter: function(node, parent) {
                if (node.range[0] <= index && index < node.range[1]) {
                    result = node;
                    resultParent = parent;
                } else {
                    this.skip();
                }
            },
            leave: function(node) {
                if (node === result) {
                    this.break();
                }
            },
            keys: espree.VisitorKeys
        });

        return result ? lodash.assign({parent: resultParent}, result) : null;
    },

    isSpaceBetweenTokens: function(first, second) {
        var text = this.text.slice(first.range[1], second.range[0]);
        return /\s/.test(text.replace(/\/\*.*?\*\//g, ""));
    }
};


module.exports = SourceCode;

},
   {"../token-store.js":"/tmp/token-store.js","espree":"espree","estraverse":"/node_modules/estraverse/estraverse.js","lodash":"/node_modules/lodash/lodash.js"}]},{},["/tmp/eslint.js"])("/tmp/eslint.js")
});
})()
});

define("plugins/c9.ide.language.javascript.eslint/worker/js-yaml",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.jsyaml=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';


var loader = require('./js-yaml/loader');
var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = require('./js-yaml/type');
module.exports.Schema              = require('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require('./js-yaml/exception');
module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/dumper":3,"./js-yaml/exception":4,"./js-yaml/loader":5,"./js-yaml/schema":7,"./js-yaml/schema/core":8,"./js-yaml/schema/default_full":9,"./js-yaml/schema/default_safe":10,"./js-yaml/schema/failsafe":11,"./js-yaml/schema/json":12,"./js-yaml/type":13}],2:[function(require,module,exports){
'use strict';


function isNothing(subject) {
  return (undefined === subject) || (null === subject);
}


function isObject(subject) {
  return ('object' === typeof subject) && (null !== subject);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) {
    return sequence;
  } else if (isNothing(sequence)) {
    return [];
  } else {
    return [ sequence ];
  }
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],3:[function(require,module,exports){
'use strict';


var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');


var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */


var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';


var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];


function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (null === map) {
    return {};
  }

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if ('!!' === tag.slice(0, 2)) {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap[tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}


function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


function State(options) {
  this.schema      = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent      = Math.max(1, (options['indent'] || 2));
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}


function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

function writeScalar(state, object) {
  var isQuoted, checkpoint, position, length, character, first;

  state.dump = '';
  isQuoted = false;
  checkpoint = 0;
  first = object.charCodeAt(0) || 0;

  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
    isQuoted = true;
  } else if (0 === object.length) {
    isQuoted = true;
  } else if (CHAR_SPACE    === first ||
             CHAR_SPACE    === object.charCodeAt(object.length - 1)) {
    isQuoted = true;
  } else if (CHAR_MINUS    === first ||
             CHAR_QUESTION === first) {
    isQuoted = true;
  }

  for (position = 0, length = object.length; position < length; position += 1) {
    character = object.charCodeAt(position);

    if (!isQuoted) {
      if (CHAR_TAB                  === character ||
          CHAR_LINE_FEED            === character ||
          CHAR_CARRIAGE_RETURN      === character ||
          CHAR_COMMA                === character ||
          CHAR_LEFT_SQUARE_BRACKET  === character ||
          CHAR_RIGHT_SQUARE_BRACKET === character ||
          CHAR_LEFT_CURLY_BRACKET   === character ||
          CHAR_RIGHT_CURLY_BRACKET  === character ||
          CHAR_SHARP                === character ||
          CHAR_AMPERSAND            === character ||
          CHAR_ASTERISK             === character ||
          CHAR_EXCLAMATION          === character ||
          CHAR_VERTICAL_LINE        === character ||
          CHAR_GREATER_THAN         === character ||
          CHAR_SINGLE_QUOTE         === character ||
          CHAR_DOUBLE_QUOTE         === character ||
          CHAR_PERCENT              === character ||
          CHAR_COMMERCIAL_AT        === character ||
          CHAR_COLON                === character ||
          CHAR_GRAVE_ACCENT         === character) {
        isQuoted = true;
      }
    }

    if (ESCAPE_SEQUENCES[character] ||
        !((0x00020 <= character && character <= 0x00007E) ||
          (0x00085 === character)                         ||
          (0x000A0 <= character && character <= 0x00D7FF) ||
          (0x0E000 <= character && character <= 0x00FFFD) ||
          (0x10000 <= character && character <= 0x10FFFF))) {
      state.dump += object.slice(checkpoint, position);
      state.dump += ESCAPE_SEQUENCES[character] || encodeHex(character);
      checkpoint = position + 1;
      isQuoted = true;
    }
  }

  if (checkpoint < position) {
    state.dump += object.slice(checkpoint, position);
  }

  if (!isQuoted && testImplicitResolving(state, state.dump)) {
    isQuoted = true;
  }

  if (isQuoted) {
    state.dump = '"' + state.dump + '"';
  }
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    if (writeNode(state, level, object[index], false, false)) {
      if (0 !== index) {
        _result += ', ';
      }
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || 0 !== index) {
        _result += generateNextLine(state, level);
      }
      _result += '- ' + state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (0 !== index) {
      pairBuffer += ', ';
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) {
      pairBuffer += '? ';
    }

    pairBuffer += state.dump + ': ';

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || 0 !== index) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (null !== state.tag && '?' !== state.tag) ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if ('[object Function]' === _toString.call(type.represent)) {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}
//
function writeNode(state, level, object, block, compact) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (0 > state.flowLevel || state.flowLevel > level);
  }

  if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {
    compact = false;
  }

  var objectOrArray = '[object Object]' === type || '[object Array]' === type,
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if ('[object Object]' === type) {
      if (block && (0 !== Object.keys(state.dump).length)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object Array]' === type) {
      if (block && (0 !== state.dump.length)) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object String]' === type) {
      if ('?' !== state.tag) {
        writeScalar(state, state.dump);
      }
    } else if (state.skipInvalid) {
      return false;
    } else {
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (null !== state.tag && '?' !== state.tag) {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var type = _toString.call(object),
      objectKeyList,
      index,
      length;

  if (null !== object && 'object' === typeof object) {
    index = objects.indexOf(object);
    if (-1 !== index) {
      if (-1 === duplicatesIndexes.indexOf(index)) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
    
      if(Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) {
    return state.dump + '\n';
  } else {
    return '';
  }
}


function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{"./common":2,"./exception":4,"./schema/default_full":9,"./schema/default_safe":10}],4:[function(require,module,exports){
'use strict';


function YAMLException(reason, mark) {
  this.name    = 'YAMLException';
  this.reason  = reason;
  this.mark    = mark;
  this.message = this.toString(false);
}


YAMLException.prototype.toString = function toString(compact) {
  var result;

  result = 'JS-YAML: ' + (this.reason || '(unknown reason)');

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],5:[function(require,module,exports){
'use strict';


var common              = require('./common');
var YAMLException       = require('./exception');
var Mark                = require('./mark');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uD800-\uDFFF\uFFFE\uFFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return 0x2C/* , */ === c ||
         0x5B/* [ */ === c ||
         0x5D/* ] */ === c ||
         0x7B/* { */ === c ||
         0x7D/* } */ === c;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  lc = c | 0x20;
  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
 return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  var error = generateError(state, message);

  if (state.onWarning) {
    state.onWarning.call(null, error);
  } else {
    throw error;
  }
}


var directiveHandlers = {

  'YAML': function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (null !== state.version) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (1 !== args.length) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (null === match) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (1 !== major) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (1 !== minor && 2 !== minor) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

  'TAG': function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (2 !== args.length) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      state.tagMap[handle] = prefix;
    }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length;
           _position < _length;
           _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(0x09 === _character ||
              0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
    }
  }
}

function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
  var index, quantity;

  keyNode = String(keyNode);

  if (null === _result) {
    _result = {};
  }

  if ('tag:yaml.org,2002:merge' === keyTag) {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index]);
      }
    } else {
      mergeMappings(state, _result, valueNode);
    }
  } else {
    _result[keyNode] = valueNode;
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (0x0A/* LF */ === ch) {
    state.position++;
  } else if (0x0D/* CR */ === ch) {
    state.position++;
    if (0x0A/* LF */ === state.input.charCodeAt(state.position)) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && 0x23/* # */ === ch) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && 0 !== ch);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (0x20/* Space */ === ch) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }

      if (state.lineIndent < checkIndent) {
        throwWarning(state, 'deficient indentation');
      }
    } else {
      break;
    }
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);
  if ((0x2D/* - */ === ch || 0x2E/* . */ === ch) &&
      state.input.charCodeAt(_position + 1) === ch &&
      state.input.charCodeAt(_position+ 2) === ch) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (1 === count) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)             ||
      is_FLOW_INDICATOR(ch)        ||
      0x23/* # */           === ch ||
      0x26/* & */           === ch ||
      0x2A/* * */           === ch ||
      0x21/* ! */           === ch ||
      0x7C/* | */           === ch ||
      0x3E/* > */           === ch ||
      0x27/* ' */           === ch ||
      0x22/* " */           === ch ||
      0x25/* % */           === ch ||
      0x40/* @ */           === ch ||
      0x60/* ` */           === ch) {
    return false;
  }

  if (0x3F/* ? */ === ch || 0x2D/* - */ === ch) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (0 !== ch) {
    if (0x3A/* : */ === ch) {
      following = state.input.charCodeAt(state.position+1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (0x23/* # */ === ch) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  } else {
    state.kind = _kind;
    state.result = _result;
    return false;
  }
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (0x27/* ' */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x27/* ' */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (0x27/* ' */ === ch) {
        captureStart = captureEnd = state.position;
        state.position++;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp, tmpEsc,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x22/* " */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x22/* " */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (0x5C/* \ */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += String.fromCharCode(hexResult);
        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D/* ] */;
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D/* } */;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (0 !== ch) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (0x3F/* ? */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && 0x3A/* : */ === ch) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (0x2C/* , */ === ch) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (0 !== ch) {
    ch = state.input.charCodeAt(++state.position);

    if (0x2B/* + */ === ch || 0x2D/* - */ === ch) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (0x2B/* + */ === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (0x23/* # */ === ch) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (0 !== ch));
    }
  }

  while (0 !== ch) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (0x20/* Space */ === ch)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (detectedIndent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat('\n', emptyLines + 1);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);
      } else if (0 === emptyLines) {
        if (detectedIndent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }
      } else {
        state.result += common.repeat('\n', emptyLines);
      }
    } else {
      if (detectedIndent) {
        state.result += common.repeat('\n', emptyLines + 1);
      } else {
        state.result += common.repeat('\n', emptyLines);
      }
    }

    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (0 !== ch))
    { ch = state.input.charCodeAt(++state.position); }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {

    if (0x2D/* - */ !== ch) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  } else {
    return false;
  }
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    //
    if ((0x3F/* ? */ === ch || 0x3A/* : */  === ch) && is_WS_OR_EOL(following)) {

      if (0x3F/* ? */ === ch) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
      }

      state.position += 1;
      ch = following;

    //
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (0x3A/* : */ === ch) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, keyTag, keyNode, valueNode);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (0 !== ch)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  //
  if (atExplicitKey) {
    storeMappingPair(state, _result, keyTag, keyNode, null);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x21/* ! */ !== ch) {
    return false;
  }

  if (null !== state.tag) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (0x3C/* < */ === ch) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (0x21/* ! */ === ch) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (0 !== ch && 0x3E/* > */ !== ch);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (0 !== ch && !is_WS_OR_EOL(ch)) {

      if (0x21/* ! */ === ch) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if ('!' === tagHandle) {
    state.tag = '!' + tagName;

  } else if ('!!' === tagHandle) {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x26/* & */ !== ch) {
    return false;
  }

  if (null !== state.anchor) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      len = state.length,
      input = state.input,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x2A/* * */ !== ch) {
    return false;
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      atNewLine  = false,
      isIndented = true,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent,
      _result;

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent === parentIndent) {
        isIndented = false;

      } else if (state.lineIndent > parentIndent) {
        isIndented = true;

      } else {
        return false;
      }
    }
  }

  if (isIndented) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;

        if (state.lineIndent > parentIndent) {
          isIndented = true;
          allowBlockCollections = allowBlockStyles;

        } else if (state.lineIndent === parentIndent) {
          isIndented = false;
          allowBlockCollections = allowBlockStyles;

        } else {
          return true;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (isIndented || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (isIndented) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (null !== state.tag || null !== state.anchor) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (null === state.tag) {
            state.tag = '?';
          }
        }

        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (null !== state.tag && '!' !== state.tag) {
    if ('?' === state.tag) {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
           typeIndex < typeQuantity;
           typeIndex += 1) {
        type = state.implicitTypes[typeIndex];
        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (null !== state.anchor) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
      type = state.typeMap[state.tag];

      if (null !== state.result && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwWarning(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  return null !== state.tag || null !== state.anchor || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || 0x25/* % */ !== ch) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (0 !== ch && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (0 !== ch) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (0x23/* # */ === ch) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (0 !== ch && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) {
        break;
      }

      _position = state.position;

      while (0 !== ch && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (0 !== ch) {
      readLineBreak(state);
    }

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (0 === state.lineIndent &&
      0x2D/* - */ === state.input.charCodeAt(state.position) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 1) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 2)) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (0x2E/* . */ === state.input.charCodeAt(state.position)) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (0 !== input.length &&
      0x0A/* LF */ !== input.charCodeAt(input.length - 1) &&
      0x0D/* CR */ !== input.charCodeAt(input.length - 1)) {
    input += '\n';
  }

  var state = new State(input, options);

  if (PATTERN_NON_PRINTABLE.test(state.input)) {
    throwError(state, 'the stream contains non-printable characters');
  }
  state.input += '\0';

  while (0x20/* Space */ === state.input.charCodeAt(state.position)) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options), index, length;

  if (0 === documents.length) {
    return undefined;
  } else if (1 === documents.length) {
    return documents[0];
  } else {
    throw new YAMLException('expected a single document in the stream, but found more');
  }
}


function safeLoadAll(input, output, options) {
  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":2,"./exception":4,"./mark":6,"./schema/default_full":9,"./schema/default_safe":10}],6:[function(require,module,exports){
'use strict';


var common = require('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) {
    return null;
  }

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":2}],7:[function(require,module,exports){
'use strict';


var common        = require('./common');
var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return -1 === exclude.indexOf(index);
  });
}


function compileMap(/* lists... */) {
  var result = {}, index, length;

  function collectType(type) {
    result[type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && 'scalar' !== type.loadKind) {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
  case 1:
    schemas = Schema.DEFAULT;
    types = arguments[0];
    break;

  case 2:
    schemas = arguments[0];
    types = arguments[1];
    break;

  default:
    throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":2,"./exception":4,"./type":13}],8:[function(require,module,exports){
//

'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./json')
  ]
});

},{"../schema":7,"./json":12}],9:[function(require,module,exports){
//
//

'use strict';


var Schema = require('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require('./default_safe')
  ],
  explicit: [
    require('../type/js/undefined'),
    require('../type/js/regexp'),
    require('../type/js/function')
  ]
});

},{"../schema":7,"../type/js/function":18,"../type/js/regexp":19,"../type/js/undefined":20,"./default_safe":10}],10:[function(require,module,exports){
//

'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./core')
  ],
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../schema":7,"../type/binary":14,"../type/merge":22,"../type/omap":24,"../type/pairs":25,"../type/set":27,"../type/timestamp":29,"./core":8}],11:[function(require,module,exports){

'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":7,"../type/map":21,"../type/seq":26,"../type/str":28}],12:[function(require,module,exports){
//

'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./failsafe')
  ],
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../schema":7,"../type/bool":15,"../type/float":16,"../type/int":17,"../type/null":23,"./failsafe":11}],13:[function(require,module,exports){
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (null !== map) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":4}],14:[function(require,module,exports){
'use strict';
var NodeBuffer = require('buffer').Buffer;
var Type       = require('../type');
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;
  for (idx = 0; idx < max; idx ++) {
    code = map.indexOf(data.charAt(idx));
    if (code > 64) { continue; }
    if (code < 0) { return false; }

    bitlen += 6;
  }
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var code, idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];
  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }
  tailbits = (max % 4)*6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }
  if (NodeBuffer) {
    return new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":13,"buffer":30}],15:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return '[object Boolean]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":13}],16:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
  '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  '|[-+]?\\.(?:inf|Inf|INF)' +
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  var value, sign, base, digits;

  if (!YAML_FLOAT_PATTERN.test(data)) {
    return false;
  }
  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = '-' === value[0] ? -1 : 1;
  digits = [];

  if (0 <= '+-'.indexOf(value[0])) {
    value = value.slice(1);
  }

  if ('.inf' === value) {
    return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if ('.nan' === value) {
    return NaN;

  } else if (0 <= value.indexOf(':')) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  } else {
    return sign * parseFloat(value, 10);
  }
}

function representYamlFloat(object, style) {
  if (isNaN(object)) {
    switch (style) {
    case 'lowercase':
      return '.nan';
    case 'uppercase':
      return '.NAN';
    case 'camelcase':
      return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '.inf';
    case 'uppercase':
      return '.INF';
    case 'camelcase':
      return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '-.inf';
    case 'uppercase':
      return '-.INF';
    case 'camelcase':
      return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  } else {
    return object.toString(10);
  }
}

function isFloat(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 !== object % 1 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":2,"../type":13}],17:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) { return false; }

  ch = data[index];
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    if (index+1 === max) { return true; }
    ch = data[++index];
    if (ch === 'b') {
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (ch !== '0' && ch !== '1') {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }


    if (ch === 'x') {
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (!isHexCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') { continue; }
      if (!isOctCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    return hasDigits;
  }
  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') { continue; }
    if (ch === ':') { break; }
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  if (!hasDigits) { return false; }
  if (ch !== ':') { return true; }
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') { sign = -1; }
    value = value.slice(1);
    ch = value[0];
  }

  if ('0' === value) {
    return 0;
  }

  if (ch === '0') {
    if (value[1] === 'b') {
      return sign * parseInt(value.slice(2), 2);
    }
    if (value[1] === 'x') {
      return sign * parseInt(value, 16);
    }
    return sign * parseInt(value, 8);

  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 === object % 1 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (object) { return '0b' + object.toString(2); },
    octal:       function (object) { return '0'  + object.toString(8); },
    decimal:     function (object) { return        object.toString(10); },
    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":2,"../type":13}],18:[function(require,module,exports){
'use strict';

var esprima;
//
//
var Type = require('../../type');

function resolveJavascriptFunction(data) {
  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true }),
        params = [],
        body;

    if ('Program'             !== ast.type         ||
        1                     !== ast.body.length  ||
        'ExpressionStatement' !== ast.body[0].type ||
        'FunctionExpression'  !== ast.body[0].expression.type) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if ('Program'             !== ast.type         ||
      1                     !== ast.body.length  ||
      'ExpressionStatement' !== ast.body[0].type ||
      'FunctionExpression'  !== ast.body[0].expression.type) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;
  return new Function(params, source.slice(body[0]+1, body[1]-1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return '[object Function]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":13,"esprima":"esprima"}],19:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }

    if (modifiers.length > 3) { return false; }
    if (regexp[regexp.length - modifiers.length - 1] !== '/') { return false; }

    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  try {
    var dummy = new RegExp(regexp, modifiers);
    return true;
  } catch (error) {
    return false;
  }
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) {
    result += 'g';
  }

  if (object.multiline) {
    result += 'm';
  }

  if (object.ignoreCase) {
    result += 'i';
  }

  return result;
}

function isRegExp(object) {
  return '[object RegExp]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":13}],20:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return 'undefined' === typeof object;
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":13}],21:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping'
});

},{"../type":13}],22:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return '<<' === data;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge,
});

},{"../type":13}],23:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return null === object;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":13}],24:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) {
          pairHasKey = true;
        } else {
          return false;
        }
      }
    }

    if (!pairHasKey) {
      return false;
    }

    if (-1 === objectKeys.indexOf(pairKey)) {
      objectKeys.push(pairKey);
    } else {
      return false;
    }
  }

  return true;
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap
});

},{"../type":13}],25:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    keys = Object.keys(pair);

    if (1 !== keys.length) {
      return false;
    }

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":13}],26:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence'
});

},{"../type":13}],27:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (null !== object[key]) {
        return false;
      }
    }
  }

  return true;
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet
});

},{"../type":13}],28:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar'
});

},{"../type":13}],29:[function(require,module,exports){
'use strict';

var Type = require('../type');

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:(?:[Tt]|[ \\t]+)'              + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute

function resolveYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    return false;
  }

  return true;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    throw new Error('Date resolve error');
  }
  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }
  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if ('-' === match[9]) {
      delta = -delta;
    }
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) {
    date.setTime(date.getTime() - delta);
  }

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":13}],30:[function(require,module,exports){

},{}],"/":[function(require,module,exports){
'use strict';


var yaml = require('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":1}]},{},[])("/")
});
});

define("plugins/c9.ide.language.javascript.eslint/worker/strip-json-comments",[], function(require, exports, module) {

	function stripJsonComments(str) {
		var currentChar;
		var nextChar;
		var insideString = false;
		var insideComment = false;
		var ret = '';

		for (var i = 0; i < str.length; i++) {
			currentChar = str[i];
			nextChar = str[i + 1];

			if (!insideComment && str[i - 1] !== '\\' && currentChar === '"') {
				insideString = !insideString;
			}

			if (insideString) {
				ret += currentChar;
				continue;
			}

			if (!insideComment && currentChar + nextChar === '//') {
				insideComment = 'single';
				i++;
			} else if (insideComment === 'single' && currentChar + nextChar === '\r\n') {
				insideComment = false;
				i++;
				ret += currentChar;
				ret += nextChar;
				continue;
			} else if (insideComment === 'single' && currentChar === '\n') {
				insideComment = false;
			} else if (!insideComment && currentChar + nextChar === '/*') {
				insideComment = 'multi';
				i++;
				continue;
			} else if (insideComment === 'multi' && currentChar + nextChar === '*/') {
				insideComment = false;
				i++;
				continue;
			}

			if (insideComment) {
				continue;
			}

			ret += currentChar;
		}

		return ret;
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = stripJsonComments;
	} else {
		window.stripJsonComments = stripJsonComments;
	}
	
});

define("plugins/c9.ide.language.javascript.eslint/worker/eslint_worker",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var workerUtil = require('plugins/c9.ide.language/worker_util');
var linter = require("./eslint_browserified");
var handler = module.exports = Object.create(baseLanguageHandler);
var util = require("plugins/c9.ide.language/worker_util");
var yaml = require("./js-yaml");
var stripJsonComments = require("./strip-json-comments");

var defaultRules;
var defaultEnv = {
    "browser": false,
    "amd": true,
    "builtin": true,
    "node": true,
    "jasmine": false,
    "mocha": true,
    "es6": true,
    "jquery": false,
    "meteor": false,
};
var defaultParserOptions = {
    ecmaFeatures: {
        globalReturn: true, // allow return statements in the global scope
        jsx: true, // enable JSX
        experimentalObjectRestSpread: true
    },
    ecmaVersion: 6,
};
var defaultGlobals = require("plugins/c9.ide.language.javascript/scope_analyzer").GLOBALS;
var userConfig;
var userConfigRaw;

handler.init = function(callback) {
    var rules = defaultRules = {};
    
    rules["handle-callback-err"] = 1;
    rules["no-debugger"] = 1;
    rules["no-undef"] = 1;
    rules["no-inner-declarations"] = [1, "functions"];
    rules["no-native-reassign"] = 1;
    rules["no-new-func"] = 1;
    rules["no-new-wrappers"] = 1;
    rules["no-cond-assign"] = [1, "except-parens"];
    rules["no-debugger"] = 3;
    rules["no-dupe-keys"] = 3;
    rules["no-eval"] = 1;
    rules["no-func-assign"] = 1;
    rules["no-extra-semi"] = 3;
    rules["no-invalid-regexp"] = 1;
    rules["no-irregular-whitespace"] = 3;
    rules["no-negated-in-lhs"] = 1;
    rules["no-regex-spaces"] = 3;
    rules["quote-props"] = 0;
    rules["no-unreachable"] = 1;
    rules["use-isnan"] = 2;
    rules["valid-typeof"] = 1;
    rules["no-redeclare"] = 3;
    rules["no-with"] = 1;
    rules["radix"] = 3;
    rules["no-delete-var"] = 2;
    rules["no-label-var"] = 3;
    rules["no-console"] = 0;
    rules["no-shadow-restricted-names"] = 2;
    rules["handle-callback-err"] = 1;
    rules["no-new-require"] = 2;

    for (var r in rules) {
        if (!(r in linter.defaults().rules))
            throw new Error("Unknown rule: ", r);
    }
    
    loadConfigFile(true, function(err) {
        if (err) console.error(err);
        util.$watchDir("/", handler);
        util.$onWatchDirChange(onWorkspaceDirChange);
    });
    
    callback();
};

function onWorkspaceDirChange(e) {
    e.data.files.forEach(function(f) {
        if (f.name === ".eslintrc")
            loadConfigFile();
    });
}

function loadConfigFile(initialLoad, callback) {
    util.readFile("/.eslintrc", "utf-8", function onResult(err, data) {
        if (err) return loadConfig(err);
        
        if (data === userConfigRaw)
            return callback && callback();

        userConfigRaw = data;
        var result;
        try {
            result = yaml.safeLoad(stripJsonComments(data));
        }
        catch (e) {
            return loadConfig(e);
        }
        loadConfig(null, result);
    });
    
    function loadConfig(err, result) {
        if (err && !callback)
            util.showError(err);
        userConfig = result;
        if (userConfig && userConfig.rules && userConfig.rules["semi"] != undefined)
            userConfig.semi = true;
        if (!initialLoad)
            util.refreshAllMarkers();
        callback && callback();
    }
}

handler.handlesLanguage = function(language) {
    return language === "javascript" || language == "jsx";
};

handler.analyze = function(value, ast, options, callback) {
    if (options.minimalAnalysis)
        return callback();
    callback(handler.analyzeSync(value, ast, options.path));
};

handler.getMaxFileSizeSupported = function() {
    return .5 * 10 * 1000 * 80;
};

handler.analyzeSync = function(value, ast, path) {
    var doc = this.doc;
    var markers = [];
    if (!workerUtil.isFeatureEnabled("hints"))
        return markers;

    var config = this.isFeatureEnabled("eslintrc") && userConfig || {};

    delete config.parser; // we only support espree

    config.rules = config.rules || defaultRules;
    config.env = config.env || defaultEnv;
    config.globals = config.globals || defaultGlobals;
    config.parserOptions = config.parserOptions || defaultParserOptions;
    if (config.parserOptions.ecmaVersion == null)
        config.parserOptions.ecmaVersion = 7;
    if (config.parserOptions.ecmaFeatures == null)
        config.parserOptions.ecmaFeatures = defaultParserOptions.ecmaFeatures;
    if (config.parserOptions.ecmaFeatures.experimentalObjectRestSpread == null)
        config.parserOptions.ecmaFeatures.experimentalObjectRestSpread = true;

    config.rules["no-unused-vars"] = [
        3,
        {
            vars: "all",
            args: handler.isFeatureEnabled("unusedFunctionArgs") ? "all" : "none"
        }
    ];
    config.rules["jsx-uses-vars"] = 2;
    config.rules["no-undef"] =
        handler.isFeatureEnabled("undeclaredVars") ? 1 : 0;
    
    if (!config.semi) {
        config.rules["semi"] =
            handler.isFeatureEnabled("semi") ? 3 : 0;
    }

    var isJson = this.path.match(/\.(json|run|settings|build)$/);
    if (isJson)
        value = "!" + value;

    try {
        var messages = linter.verify(value, config);
    }
    catch (e) {
        console.error(e.stack);
        if (e.message && e.message.match(/rule .* was not found/))
            workerUtil.showError("eslint: " + e.message);
        return [];
    }
    
    messages.forEach(function(m) {
        var level;
        if (m.severity === 2)
            level = "error";
        else if (m.severity === 1)
            level = "warning";
        else
            level = "info";
        
        if (isJson && level !== "error")
            return;

        if (m.message.match(/'([^']*)' is defined but never used/)) {
            var target = RegExp.$1;
            if (target.toUpperCase() === target && target.toLowerCase() !== target)
                return; // ignore unused constants
            if (target === "h")
                return; // ignore 'h', used in preact
            if (m.severity === 1)
                level = "info";
        }
        if (m.ruleId && m.ruleId.match(/space|spacing/) && m.severity === 1)
            level = "info";
        m.column--;

        var ec;
        if (m.message.match(/is not defined|was used before it was defined|is already declared|is already defined|unexpected identifier|defined but never used/i)) {
            var line = doc.getLine(m.line);
            var id = workerUtil.getFollowingIdentifier(line, m.column);
            if (m.message.match(/is already defined/) && line.match("for \\(var " + id))
                return;
            ec = m.column + id.length;
        }
        if (m.message.match(/'([^']*)' is not defined/)) {
            m.message = RegExp.$1 + " is not defined; please fix or add /*global " + RegExp.$1 + "*/";
        }
        if (m.message.match(/missing semicolon/i)) {
            var line = doc.getLine(m.line);
            if (line.substr(m.column).match(/\s*}/))
                return; // allow missing semi at end of block
            if ((m.line === doc.getLength() || m.line === doc.getLength() - 1)
                && line.match(/^\s*\}\)\s*$/))
                return;
            if (m.severity === 1)
                level = "info";
        }
            
        markers.push({
            pos: {
                sl: m.line,
                sc: m.column,
                ec: ec
            },
            type: level,
            level: level !== "info" && level,
            message: m.message
        });
    });
    return markers;
};
    
});

define("acorn/dist/walk",["require", "exports", "module", "./acorn"], function(require, exports, module) {

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).walk = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/src\\walk\\index.js":[function(_dereq_,module,exports){
//
//
//
"use strict";

exports.__esModule = true;
exports.simple = simple;
exports.ancestor = ancestor;
exports.recursive = recursive;
exports.findNodeAt = findNodeAt;
exports.findNodeAround = findNodeAround;
exports.findNodeAfter = findNodeAfter;
exports.findNodeBefore = findNodeBefore;
exports.make = make;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function simple(node, visitors, base, state, override) {
  if (!base) base = exports.base;(function c(node, st, override) {
    var type = override || node.type,
        found = visitors[type];
    base[type](node, st, c);
    if (found) found(node, st);
  })(node, state, override);
}
function ancestor(node, visitors, base, state) {
  if (!base) base = exports.base;
  if (!state) state = [];(function c(node, st, override) {
    var type = override || node.type,
        found = visitors[type];
    if (node != st[st.length - 1]) {
      st = st.slice();
      st.push(node);
    }
    base[type](node, st, c);
    if (found) found(node, st);
  })(node, state);
}
function recursive(node, state, funcs, base, override) {
  var visitor = funcs ? exports.make(funcs, base) : base;(function c(node, st, override) {
    visitor[override || node.type](node, st, c);
  })(node, state, override);
}

function makeTest(test) {
  if (typeof test == "string") return function (type) {
    return type == test;
  };else if (!test) return function () {
    return true;
  };else return test;
}

var Found = function Found(node, state) {


  this.node = node;this.state = state;
};
function findNodeAt(node, start, end, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      var type = override || node.type;
      if ((start == null || node.start <= start) && (end == null || node.end >= end)) base[type](node, st, c);
      if ((start == null || node.start == start) && (end == null || node.end == end) && test(type, node)) throw new Found(node, st);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) return e;
    throw e;
  }
}
function findNodeAround(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      var type = override || node.type;
      if (node.start > pos || node.end < pos) return;
      base[type](node, st, c);
      if (test(type, node)) throw new Found(node, st);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) return e;
    throw e;
  }
}
function findNodeAfter(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      if (node.end < pos) return;
      var type = override || node.type;
      if (node.start >= pos && test(type, node)) throw new Found(node, st);
      base[type](node, st, c);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) return e;
    throw e;
  }
}
function findNodeBefore(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  var max = undefined;(function c(node, st, override) {
    if (node.start > pos) return;
    var type = override || node.type;
    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) max = new Found(node, st);
    base[type](node, st, c);
  })(node, state);
  return max;
}
function make(funcs, base) {
  if (!base) base = exports.base;
  var visitor = {};
  for (var type in base) visitor[type] = base[type];
  for (var type in funcs) visitor[type] = funcs[type];
  return visitor;
}

function skipThrough(node, st, c) {
  c(node, st);
}
function ignore(_node, _st, _c) {}
var base = {};

exports.base = base;
base.Program = base.BlockStatement = function (node, st, c) {
  for (var i = 0; i < node.body.length; ++i) {
    c(node.body[i], st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = function (node, st, c) {
  return c(node.expression, st, "Expression");
};
base.IfStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Statement");
  if (node.alternate) c(node.alternate, st, "Statement");
};
base.LabeledStatement = function (node, st, c) {
  return c(node.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function (node, st, c) {
  c(node.object, st, "Expression");
  c(node.body, st, "Statement");
};
base.SwitchStatement = function (node, st, c) {
  c(node.discriminant, st, "Expression");
  for (var i = 0; i < node.cases.length; ++i) {
    var cs = node.cases[i];
    if (cs.test) c(cs.test, st, "Expression");
    for (var j = 0; j < cs.consequent.length; ++j) {
      c(cs.consequent[j], st, "Statement");
    }
  }
};
base.ReturnStatement = base.YieldExpression = function (node, st, c) {
  if (node.argument) c(node.argument, st, "Expression");
};
base.ThrowStatement = base.SpreadElement = function (node, st, c) {
  return c(node.argument, st, "Expression");
};
base.TryStatement = function (node, st, c) {
  c(node.block, st, "Statement");
  if (node.handler) {
    c(node.handler.param, st, "Pattern");
    c(node.handler.body, st, "ScopeBody");
  }
  if (node.finalizer) c(node.finalizer, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForStatement = function (node, st, c) {
  if (node.init) c(node.init, st, "ForInit");
  if (node.test) c(node.test, st, "Expression");
  if (node.update) c(node.update, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function (node, st, c) {
  c(node.left, st, "ForInit");
  c(node.right, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInit = function (node, st, c) {
  if (node.type == "VariableDeclaration") c(node, st);else c(node, st, "Expression");
};
base.DebuggerStatement = ignore;

base.FunctionDeclaration = function (node, st, c) {
  return c(node, st, "Function");
};
base.VariableDeclaration = function (node, st, c) {
  for (var i = 0; i < node.declarations.length; ++i) {
    c(node.declarations[i], st);
  }
};
base.VariableDeclarator = function (node, st, c) {
  c(node.id, st, "Pattern");
  if (node.init) c(node.init, st, "Expression");
};

base.Function = function (node, st, c) {
  if (node.id) c(node.id, st, "Pattern");
  for (var i = 0; i < node.params.length; i++) {
    c(node.params[i], st, "Pattern");
  }c(node.body, st, node.expression ? "ScopeExpression" : "ScopeBody");
};
base.ScopeBody = function (node, st, c) {
  return c(node, st, "Statement");
};
base.ScopeExpression = function (node, st, c) {
  return c(node, st, "Expression");
};

base.Pattern = function (node, st, c) {
  if (node.type == "Identifier") c(node, st, "VariablePattern");else if (node.type == "MemberExpression") c(node, st, "MemberPattern");else c(node, st);
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function (node, st, c) {
  return c(node.argument, st, "Pattern");
};
base.ArrayPattern = function (node, st, c) {
  for (var i = 0; i < node.elements.length; ++i) {
    var elt = node.elements[i];
    if (elt) c(elt, st, "Pattern");
  }
};
base.ObjectPattern = function (node, st, c) {
  for (var i = 0; i < node.properties.length; ++i) {
    c(node.properties[i].value, st, "Pattern");
  }
};

base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function (node, st, c) {
  for (var i = 0; i < node.elements.length; ++i) {
    var elt = node.elements[i];
    if (elt) c(elt, st, "Expression");
  }
};
base.ObjectExpression = function (node, st, c) {
  for (var i = 0; i < node.properties.length; ++i) {
    c(node.properties[i], st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {
  for (var i = 0; i < node.expressions.length; ++i) {
    c(node.expressions[i], st, "Expression");
  }
};
base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
  c(node.argument, st, "Expression");
};
base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
  c(node.left, st, "Expression");
  c(node.right, st, "Expression");
};
base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
  c(node.left, st, "Pattern");
  c(node.right, st, "Expression");
};
base.ConditionalExpression = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Expression");
  c(node.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function (node, st, c) {
  c(node.callee, st, "Expression");
  if (node.arguments) for (var i = 0; i < node.arguments.length; ++i) {
    c(node.arguments[i], st, "Expression");
  }
};
base.MemberExpression = function (node, st, c) {
  c(node.object, st, "Expression");
  if (node.computed) c(node.property, st, "Expression");
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
  if (node.declaration) c(node.declaration, st, node.type == "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
  if (node.source) c(node.source, st, "Expression");
};
base.ExportAllDeclaration = function (node, st, c) {
  c(node.source, st, "Expression");
};
base.ImportDeclaration = function (node, st, c) {
  for (var i = 0; i < node.specifiers.length; i++) {
    c(node.specifiers[i], st);
  }c(node.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;

base.TaggedTemplateExpression = function (node, st, c) {
  c(node.tag, st, "Expression");
  c(node.quasi, st);
};
base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
  return c(node, st, "Class");
};
base.Class = function (node, st, c) {
  if (node.id) c(node.id, st, "Pattern");
  if (node.superClass) c(node.superClass, st, "Expression");
  for (var i = 0; i < node.body.body.length; i++) {
    c(node.body.body[i], st);
  }
};
base.MethodDefinition = base.Property = function (node, st, c) {
  if (node.computed) c(node.key, st, "Expression");
  c(node.value, st, "Expression");
};

},{}]},{},["/src\\walk\\index.js"])("/src\\walk\\index.js")
});
});

define("tern/lib/def",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
//
//
//
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return exports.init = mod;
  if (typeof define == "function" && define.amd) // AMD
    return define({init: mod});
  tern.def = {init: mod};
})(function(exports, infer) {
  "use strict";

  function hop(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var TypeParser = exports.TypeParser = function(spec, start, base, forceNew) {
    this.pos = start || 0;
    this.spec = spec;
    this.base = base;
    this.forceNew = forceNew;
  };

  function unwrapType(type, self, args) {
    return type.call ? type(self, args) : type;
  }

  function extractProp(type, prop) {
    if (prop == "!ret") {
      if (type.retval) return type.retval;
      var rv = new infer.AVal;
      type.propagate(new infer.IsCallee(infer.ANull, [], null, rv));
      return rv;
    } else {
      return type.getProp(prop);
    }
  }

  function computedFunc(name, args, retType, generator) {
    return function(self, cArgs) {
      var realArgs = [];
      for (var i = 0; i < args.length; i++) realArgs.push(unwrapType(args[i], self, cArgs));
      return new infer.Fn(name, infer.ANull, realArgs, unwrapType(retType, self, cArgs), generator);
    };
  }
  function computedUnion(types) {
    return function(self, args) {
      var union = new infer.AVal;
      for (var i = 0; i < types.length; i++) unwrapType(types[i], self, args).propagate(union);
      union.maxWeight = 1e5;
      return union;
    };
  }
  function computedArray(inner) {
    return function(self, args) {
      return new infer.Arr(inner(self, args));
    };
  }
  function computedTuple(types) {
    return function(self, args) {
      return new infer.Arr(types.map(function(tp) { return unwrapType(tp, self, args) }))
    }
  }

  TypeParser.prototype = {
    eat: function(str) {
      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {
        this.pos += str.length;
        return true;
      }
    },
    word: function(re) {
      var word = "", ch, re = re || /[\w$]/;
      while ((ch = this.spec.charAt(this.pos)) && re.test(ch)) { word += ch; ++this.pos; }
      return word;
    },
    error: function() {
      throw new Error("Unrecognized type spec: " + this.spec + " (at " + this.pos + ")");
    },
    parseFnType: function(comp, name, top, generator) {
      var args = [], names = [], computed = false;
      if (!this.eat(")")) for (var i = 0; ; ++i) {
        var colon = this.spec.indexOf(": ", this.pos), argname;
        if (colon != -1) {
          argname = this.spec.slice(this.pos, colon);
          if (/^[$\w?]+$/.test(argname))
            this.pos = colon + 2;
          else
            argname = null;
        }
        names.push(argname);
        var argType = this.parseType(comp);
        if (argType.call) computed = true;
        args.push(argType);
        if (!this.eat(", ")) {
          this.eat(")") || this.error();
          break;
        }
      }
      var retType, computeRet, computeRetStart, fn;
      if (this.eat(" -> ")) {
        var retStart = this.pos;
        retType = this.parseType(true);
        if (retType.call && !computed) {
          computeRet = retType;
          retType = infer.ANull;
          computeRetStart = retStart;
        }
      } else {
        retType = infer.ANull;
      }
      if (computed) return computedFunc(name, args, retType, generator);

      if (top && (fn = this.base))
        infer.Fn.call(this.base, name, infer.ANull, args, names, retType, generator);
      else
        fn = new infer.Fn(name, infer.ANull, args, names, retType, generator);
      if (computeRet) fn.computeRet = computeRet;
      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);
      return fn;
    },
    parseType: function(comp, name, top) {
      var main = this.parseTypeMaybeProp(comp, name, top);
      if (!this.eat("|")) return main;
      var types = [main], computed = main.call;
      for (;;) {
        var next = this.parseTypeMaybeProp(comp, name, top);
        types.push(next);
        if (next.call) computed = true;
        if (!this.eat("|")) break;
      }
      if (computed) return computedUnion(types);
      var union = new infer.AVal;
      for (var i = 0; i < types.length; i++) types[i].propagate(union);
      union.maxWeight = 1e5;
      return union;
    },
    parseTypeMaybeProp: function(comp, name, top) {
      var result = this.parseTypeInner(comp, name, top);
      while (comp && this.eat(".")) result = this.extendWithProp(result);
      return result;
    },
    extendWithProp: function(base) {
      var propName = this.word(/[\w<>$!:]/) || this.error();
      if (base.apply) return function(self, args) {
        return extractProp(base(self, args), propName);
      };
      return extractProp(base, propName);
    },
    parseTypeInner: function(comp, name, top) {
      var gen
      if (this.eat("fn(") || (gen = this.eat("fn*("))) {
        return this.parseFnType(comp, name, top, gen);
      } else if (this.eat("[")) {
        var inner = this.parseType(comp), types, computed = inner.call
        while (this.eat(", ")) {
          if (!types) types = [inner]
          var next = this.parseType(comp)
          types.push(next)
          computed = computed || next.call
        }
        this.eat("]") || this.error()
        if (computed) return types ? computedTuple(types) : computedArray(inner)
        if (top && this.base) {
          infer.Arr.call(this.base, types || inner)
          return this.base
        }
        return new infer.Arr(types || inner)
      } else if (this.eat("+")) {
        var path = this.word(/[\w$<>\.:!]/)
        var base = infer.cx().localDefs[path + ".prototype"]
        if (!base) {
          var base = parsePath(path);
          if (!(base instanceof infer.Obj)) return base;
          var proto = descendProps(base, ["prototype"])
          if (proto && (proto = proto.getObjType()))
            base = proto
        }
        if (comp && this.eat("[")) return this.parsePoly(base);
        if (top && this.forceNew) return new infer.Obj(base);
        return infer.getInstance(base);
      } else if (this.eat(":")) {
        var name = this.word(/[\w$\.]/)
        return infer.getSymbol(name)
      } else if (comp && this.eat("!")) {
        var arg = this.word(/\d/);
        if (arg) {
          arg = Number(arg);
          return function(_self, args) {return args[arg] || infer.ANull;};
        } else if (this.eat("this")) {
          return function(self) {return self;};
        } else if (this.eat("custom:")) {
          var fname = this.word(/[\w$]/);
          return customFunctions[fname] || function() { return infer.ANull; };
        } else {
          return this.fromWord("!" + this.word(/[\w$<>\.!:]/));
        }
      } else if (this.eat("?")) {
        return infer.ANull;
      } else {
        return this.fromWord(this.word(/[\w$<>\.!:`]/));
      }
    },
    fromWord: function(spec) {
      var cx = infer.cx();
      switch (spec) {
      case "number": return cx.num;
      case "string": return cx.str;
      case "bool": return cx.bool;
      case "<top>": return cx.topScope;
      }
      if (cx.localDefs && spec in cx.localDefs) return cx.localDefs[spec];
      return parsePath(spec);
    },
    parsePoly: function(base) {
      var propName = "<i>", match;
      if (match = this.spec.slice(this.pos).match(/^\s*([\w$:]+)\s*=\s*/)) {
        propName = match[1];
        this.pos += match[0].length;
      }
      var value = this.parseType(true);
      if (!this.eat("]")) this.error();
      if (value.call) return function(self, args) {
        var instance = new infer.Obj(base);
        value(self, args).propagate(instance.defProp(propName));
        return instance;
      };
      var instance = new infer.Obj(base);
      value.propagate(instance.defProp(propName));
      return instance;
    }
  };

  function parseType(spec, name, base, forceNew) {
    var type = new TypeParser(spec, null, base, forceNew).parseType(false, name, true);
    if (/^fn\(/.test(spec)) for (var i = 0; i < type.args.length; ++i) (function(i) {
      var arg = type.args[i];
      if (arg instanceof infer.Fn && arg.args && arg.args.length) addEffect(type, function(_self, fArgs) {
        var fArg = fArgs[i];
        if (fArg) fArg.propagate(new infer.IsCallee(infer.cx().topScope, arg.args, null, infer.ANull));
      });
    })(i);
    return type;
  }

  function addEffect(fn, handler, replaceRet) {
    var oldCmp = fn.computeRet, rv = fn.retval;
    fn.computeRet = function(self, args, argNodes) {
      var handled = handler(self, args, argNodes);
      var old = oldCmp ? oldCmp(self, args, argNodes) : rv;
      return replaceRet ? handled : old;
    };
  }

  var parseEffect = exports.parseEffect = function(effect, fn) {
    var m;
    if (effect.indexOf("propagate ") == 0) {
      var p = new TypeParser(effect, 10);
      var origin = p.parseType(true);
      if (!p.eat(" ")) p.error();
      var target = p.parseType(true);
      addEffect(fn, function(self, args) {
        unwrapType(origin, self, args).propagate(unwrapType(target, self, args));
      });
    } else if (effect.indexOf("call ") == 0) {
      var andRet = effect.indexOf("and return ", 5) == 5;
      var p = new TypeParser(effect, andRet ? 16 : 5);
      var getCallee = p.parseType(true), getSelf = null, getArgs = [];
      if (p.eat(" this=")) getSelf = p.parseType(true);
      while (p.eat(" ")) getArgs.push(p.parseType(true));
      addEffect(fn, function(self, args) {
        var callee = unwrapType(getCallee, self, args);
        var slf = getSelf ? unwrapType(getSelf, self, args) : infer.ANull, as = [];
        for (var i = 0; i < getArgs.length; ++i) as.push(unwrapType(getArgs[i], self, args));
        var result = andRet ? new infer.AVal : infer.ANull;
        callee.propagate(new infer.IsCallee(slf, as, null, result));
        return result;
      }, andRet);
    } else if (m = effect.match(/^custom (\S+)\s*(.*)/)) {
      var customFunc = customFunctions[m[1]];
      if (customFunc) addEffect(fn, m[2] ? customFunc(m[2]) : customFunc);
    } else if (effect.indexOf("copy ") == 0) {
      var p = new TypeParser(effect, 5);
      var getFrom = p.parseType(true);
      p.eat(" ");
      var getTo = p.parseType(true);
      addEffect(fn, function(self, args) {
        var from = unwrapType(getFrom, self, args), to = unwrapType(getTo, self, args);
        from.forAllProps(function(prop, val, local) {
          if (local && prop != "<i>")
            to.propagate(new infer.DefProp(prop, val));
        });
      });
    } else {
      throw new Error("Unknown effect type: " + effect);
    }
  };

  var currentTopScope;

  var parsePath = exports.parsePath = function(path, scope) {
    var cx = infer.cx(), cached = cx.paths[path], origPath = path;
    if (cached != null) return cached;
    cx.paths[path] = infer.ANull;

    var base = scope || currentTopScope || cx.topScope;

    if (cx.localDefs) for (var name in cx.localDefs) {
      if (path.indexOf(name) == 0) {
        if (path == name) return cx.paths[path] = cx.localDefs[path];
        if (path.charAt(name.length) == ".") {
          base = cx.localDefs[name];
          path = path.slice(name.length + 1);
          break;
        }
      }
    }

    var result = descendProps(base, path.split("."))
    cx.paths[origPath] = result == infer.ANull ? null : result
    return result
  }

  function descendProps(base, parts) {
    for (var i = 0; i < parts.length && base != infer.ANull; ++i) {
      var prop = parts[i];
      if (prop.charAt(0) == "!") {
        if (prop == "!proto") {
          base = (base instanceof infer.Obj && base.proto) || infer.ANull;
        } else {
          var fn = base.getFunctionType();
          if (!fn) {
            base = infer.ANull;
          } else if (prop == "!ret") {
            base = fn.retval && fn.retval.getType(false) || infer.ANull;
          } else {
            var arg = fn.args && fn.args[Number(prop.slice(1))];
            base = (arg && arg.getType(false)) || infer.ANull;
          }
        }
      } else if (base instanceof infer.Obj &&
                 (prop == "prototype" && base instanceof infer.Fn || base.hasProp(prop))) {
        var propVal = base.getProp(prop);
        if (!propVal || propVal.isEmpty())
          base = infer.ANull;
        else
          base = propVal.types[0];
      } else {
        base = infer.ANull;
      }
    }
    return base;
  }

  function emptyObj(ctor) {
    var empty = Object.create(ctor.prototype);
    empty.props = Object.create(null);
    empty.isShell = true;
    return empty;
  }

  function isSimpleAnnotation(spec) {
    if (!spec["!type"] || /^(fn\(|\[)/.test(spec["!type"])) return false;
    for (var prop in spec)
      if (prop != "!type" && prop != "!doc" && prop != "!url" && prop != "!span" && prop != "!data")
        return false;
    return true;
  }

  function passOne(base, spec, path) {
    if (!base) {
      var tp = spec["!type"];
      if (tp) {
        if (/^fn\(/.test(tp)) base = emptyObj(infer.Fn);
        else if (tp.charAt(0) == "[") base = emptyObj(infer.Arr);
        else throw new Error("Invalid !type spec: " + tp);
      } else if (spec["!stdProto"]) {
        base = infer.cx().protos[spec["!stdProto"]];
      } else {
        base = emptyObj(infer.Obj);
      }
      base.name = path;
    }

    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
      var inner = spec[name];
      if (typeof inner == "string" || isSimpleAnnotation(inner)) continue;
      var prop = base.defProp(name);
      passOne(prop.getObjType(), inner, path ? path + "." + name : name).propagate(prop);
    }
    return base;
  }

  function passTwo(base, spec, path) {
    if (base.isShell) {
      delete base.isShell;
      var tp = spec["!type"];
      if (tp) {
        parseType(tp, path, base);
      } else {
        var proto = spec["!proto"] && parseType(spec["!proto"]);
        infer.Obj.call(base, proto instanceof infer.Obj ? proto : true, path);
      }
    }

    var effects = spec["!effects"];
    if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i)
      parseEffect(effects[i], base);
    copyInfo(spec, base);

    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
      var inner = spec[name], known = base.defProp(name), innerPath = path ? path + "." + name : name;
      if (typeof inner == "string") {
        if (known.isEmpty()) parseType(inner, innerPath).propagate(known);
      } else {
        if (!isSimpleAnnotation(inner))
          passTwo(known.getObjType(), inner, innerPath);
        else if (known.isEmpty())
          parseType(inner["!type"], innerPath, null, true).propagate(known);
        else
          continue;
        if (inner["!doc"]) known.doc = inner["!doc"];
        if (inner["!url"]) known.url = inner["!url"];
        if (inner["!span"]) known.span = inner["!span"];
      }
    }
    return base;
  }

  function copyInfo(spec, type) {
    if (spec["!doc"]) type.doc = spec["!doc"];
    if (spec["!url"]) type.url = spec["!url"];
    if (spec["!span"]) type.span = spec["!span"];
    if (spec["!data"]) type.metaData = spec["!data"];
  }

  function doLoadEnvironment(data, scope) {
    var cx = infer.cx(), server = cx.parent

    infer.addOrigin(cx.curOrigin = data["!name"] || "env#" + cx.origins.length);
    cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);

    if (server) server.signal("preLoadDef", data)

    passOne(scope, data);

    var def = data["!define"];
    if (def) {
      for (var name in def) {
        var spec = def[name];
        cx.localDefs[name] = typeof spec == "string" ? parsePath(spec) : passOne(null, spec, name);
      }
      for (var name in def) {
        var spec = def[name];
        if (typeof spec != "string") passTwo(cx.localDefs[name], def[name], name);
      }
    }

    passTwo(scope, data);

    if (server) server.signal("postLoadDef", data)

    cx.curOrigin = cx.localDefs = null;
  }

  exports.load = function(data, scope) {
    if (!scope) scope = infer.cx().topScope;
    var oldScope = currentTopScope;
    currentTopScope = scope;
    try {
      doLoadEnvironment(data, scope);
    } finally {
      currentTopScope = oldScope;
    }
  };

  exports.parse = function(data, origin, path) {
    var cx = infer.cx();
    if (origin) {
      cx.origin = origin;
      cx.localDefs = cx.definitions[origin];
    }

    try {
      if (typeof data == "string")
        return parseType(data, path);
      else
        return passTwo(passOne(null, data, path), data, path);
    } finally {
      if (origin) cx.origin = cx.localDefs = null;
    }
  };
  var customFunctions = Object.create(null);
  infer.registerFunction = function(name, f) { customFunctions[name] = f; };

  var IsCreated = infer.constraint({
    construct: function(created, target, spec) {
      this.created = created;
      this.target = target;
      this.spec = spec;
    },
    addType: function(tp) {
      if (tp instanceof infer.Obj && this.created++ < 5) {
        var derived = new infer.Obj(tp), spec = this.spec;
        if (spec instanceof infer.AVal) spec = spec.getObjType(false);
        if (spec instanceof infer.Obj) for (var prop in spec.props) {
          var cur = spec.props[prop].types[0];
          var p = derived.defProp(prop);
          if (cur && cur instanceof infer.Obj && cur.props.value) {
            var vtp = cur.props.value.getType(false);
            if (vtp) p.addType(vtp);
          }
        }
        this.target.addType(derived);
      }
    }
  });

  infer.registerFunction("Object_create", function(_self, args, argNodes) {
    if (argNodes && argNodes.length && argNodes[0].type == "Literal" && argNodes[0].value == null)
      return new infer.Obj();

    var result = new infer.AVal;
    if (args[0]) args[0].propagate(new IsCreated(0, result, args[1]));
    return result;
  });

  var PropSpec = infer.constraint({
    construct: function(target) { this.target = target; },
    addType: function(tp) {
      if (!(tp instanceof infer.Obj)) return;
      if (tp.hasProp("value"))
        tp.getProp("value").propagate(this.target);
      else if (tp.hasProp("get"))
        tp.getProp("get").propagate(new infer.IsCallee(infer.ANull, [], null, this.target));
    }
  });

  infer.registerFunction("Object_defineProperty", function(_self, args, argNodes) {
    if (argNodes && argNodes.length >= 3 && argNodes[1].type == "Literal" &&
        typeof argNodes[1].value == "string") {
      var obj = args[0], connect = new infer.AVal;
      obj.propagate(new infer.DefProp(argNodes[1].value, connect, argNodes[1]));
      args[2].propagate(new PropSpec(connect));
    }
    return infer.ANull;
  });

  infer.registerFunction("Object_defineProperties", function(_self, args, argNodes) {
    if (args.length >= 2) {
      var obj = args[0];
      args[1].forAllProps(function(prop, val, local) {
        if (!local) return;
        var connect = new infer.AVal;
        obj.propagate(new infer.DefProp(prop, connect, argNodes && argNodes[1]));
        val.propagate(new PropSpec(connect));
      });
    }
    return infer.ANull;
  });

  var IsBound = infer.constraint({
    construct: function(self, args, target) {
      this.self = self; this.args = args; this.target = target;
    },
    addType: function(tp) {
      if (!(tp instanceof infer.Fn)) return;
      this.target.addType(new infer.Fn(tp.name, infer.ANull, tp.args.slice(this.args.length),
                                       tp.argNames.slice(this.args.length), tp.retval, tp.generator));
      this.self.propagate(tp.self);
      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i)
        this.args[i].propagate(tp.args[i]);
    }
  });

  infer.registerFunction("Function_bind", function(self, args) {
    if (!args.length) return infer.ANull;
    var result = new infer.AVal;
    self.propagate(new IsBound(args[0], args.slice(1), result));
    return result;
  });

  infer.registerFunction("Array_ctor", function(_self, args) {
    var arr = new infer.Arr;
    if (args.length != 1 || !args[0].hasType(infer.cx().num)) {
      var content = arr.getProp("<i>");
      for (var i = 0; i < args.length; ++i) args[i].propagate(content);
    }
    return arr;
  });

  infer.registerFunction("Promise_ctor", function(_self, args, argNodes) {
    var defs6 = infer.cx().definitions.ecma6
    if (!defs6 || args.length < 1) return infer.ANull;
    var self = new infer.Obj(defs6["Promise.prototype"]);
    var valProp = self.defProp(":t", argNodes && argNodes[0]);
    var valArg = new infer.AVal;
    valArg.propagate(valProp);
    var exec = new infer.Fn("execute", infer.ANull, [valArg], ["value"], infer.ANull);
    var reject = defs6.Promise_reject;
    args[0].propagate(new infer.IsCallee(infer.ANull, [exec, reject], null, infer.ANull));
    return self;
  });

  var PromiseResolvesTo = infer.constraint({
    construct: function(output) { this.output = output; },
    addType: function(tp) {
      if (tp.constructor == infer.Obj && tp.name == "Promise" && tp.hasProp(":t"))
        tp.getProp(":t").propagate(this.output);
      else
        tp.propagate(this.output);
    }
  });

  var WG_PROMISE_KEEP_VALUE = 50;

  infer.registerFunction("Promise_then", function(self, args, argNodes) {
    var fn = args.length && args[0].getFunctionType();
    var defs6 = infer.cx().definitions.ecma6
    if (!fn || !defs6) return self;

    var result = new infer.Obj(defs6["Promise.prototype"]);
    var value = result.defProp(":t", argNodes && argNodes[0]), ty;
    if (fn.retval.isEmpty() && (ty = self.getType()) instanceof infer.Obj && ty.hasProp(":t"))
      ty.getProp(":t").propagate(value, WG_PROMISE_KEEP_VALUE);
    fn.retval.propagate(new PromiseResolvesTo(value));
    return result;
  });

  infer.registerFunction("getOwnPropertySymbols", function(_self, args) {
    if (!args.length) return infer.ANull
    var result = new infer.AVal
    args[0].forAllProps(function(prop, _val, local) {
      if (local && prop.charAt(0) == ":") result.addType(infer.getSymbol(prop.slice(1)))
    })
    return result
  })

  infer.registerFunction("getSymbol", function(_self, _args, argNodes) {
    if (argNodes.length && argNodes[0].type == "Literal" && typeof argNodes[0].value == "string")
      return infer.getSymbol(argNodes[0].value)
    else
      return infer.ANull
  })

  return exports;
});

});

define("tern/lib/signal",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports);
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports"], mod);
  mod((root.tern || (root.tern = {})).signal = {}); // Plain browser env
})(this, function(exports) {

  function on(type, f) {
    var handlers = this._handlers || (this._handlers = Object.create(null));
    (handlers[type] || (handlers[type] = [])).push(f);
  }

  function off(type, f) {
    var arr = this._handlers && this._handlers[type];
    if (arr) for (var i = 0; i < arr.length; ++i)
      if (arr[i] == f) { arr.splice(i, 1); break; }
  }

  var noHandlers = []
  function getHandlers(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length ? arr.slice() : noHandlers
  }

  function signal(type, a1, a2, a3, a4) {
    var arr = getHandlers(this, type)
    for (var i = 0; i < arr.length; ++i) arr[i].call(this, a1, a2, a3, a4)
  }

  function signalReturnFirst(type, a1, a2, a3, a4) {
    var arr = getHandlers(this, type)
    for (var i = 0; i < arr.length; ++i) {
      var result = arr[i].call(this, a1, a2, a3, a4)
      if (result) return result
    }
  }

  function hasHandler(type) {
    var arr = this._handlers && this._handlers[type]
    return arr && arr.length > 0 && arr
  }

  exports.mixin = function(obj) {
    obj.on = on; obj.off = off;
    obj.signal = signal;
    obj.signalReturnFirst = signalReturnFirst;
    obj.hasHandler = hasHandler;
    return obj;
  };
});

});

define("tern/lib/infer",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports, require("acorn"), require("acorn/dist/acorn_loose"), require("acorn/dist/walk"),
               require("./def"), require("./signal"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports", "acorn/dist/acorn", "acorn/dist/acorn_loose", "acorn/dist/walk", "./def", "./signal"], mod);
  mod(root.tern || (root.tern = {}), acorn, acorn, acorn.walk, tern.def, tern.signal); // Plain browser env
})(this, function(exports, acorn, acorn_loose, walk, def, signal) {
  "use strict";

  var toString = exports.toString = function(type, maxDepth, parent) {
    if (!type || type == parent || maxDepth && maxDepth < -3) return "?";
    return type.toString(maxDepth, parent);
  };
  var ANull = exports.ANull = signal.mixin({
    addType: function() {},
    propagate: function() {},
    getProp: function() { return ANull; },
    forAllProps: function() {},
    hasType: function() { return false; },
    isEmpty: function() { return true; },
    getFunctionType: function() {},
    getObjType: function() {},
    getSymbolType: function() {},
    getType: function() {},
    gatherProperties: function() {},
    propagatesTo: function() {},
    typeHint: function() {},
    propHint: function() {},
    toString: function() { return "?"; }
  });

  function extend(proto, props) {
    var obj = Object.create(proto);
    if (props) for (var prop in props) obj[prop] = props[prop];
    return obj;
  }
  var WG_DEFAULT = 100, WG_NEW_INSTANCE = 90, WG_MADEUP_PROTO = 10,
      WG_MULTI_MEMBER = 6, WG_CATCH_ERROR = 6,
      WG_PHANTOM_OBJ = 1,
      WG_GLOBAL_THIS = 90, WG_SPECULATIVE_THIS = 2, WG_SPECULATIVE_PROTO_THIS = 4;

  var AVal = exports.AVal = function() {
    this.types = [];
    this.forward = null;
    this.maxWeight = 0;
  };
  AVal.prototype = extend(ANull, {
    addType: function(type, weight) {
      weight = weight || WG_DEFAULT;
      if (this.maxWeight < weight) {
        this.maxWeight = weight;
        if (this.types.length == 1 && this.types[0] == type) return;
        this.types.length = 0;
      } else if (this.maxWeight > weight || this.types.indexOf(type) > -1) {
        return;
      }
      if (this.types.length > 5) {
        return;
      }
      this.signal("addType", type);
      this.types.push(type);
      var forward = this.forward;
      if (forward) withWorklist(function(add) {
        for (var i = 0; i < forward.length; ++i) add(type, forward[i], weight);
      });
    },

    propagate: function(target, weight) {
      if (target == ANull || (target instanceof Type && this.forward && this.forward.length > 2)) return;
      if (weight && weight != WG_DEFAULT) target = new Muffle(target, weight);
      (this.forward || (this.forward = [])).push(target);
      var types = this.types;
      if (types.length) withWorklist(function(add) {
        for (var i = 0; i < types.length; ++i) add(types[i], target, weight);
      });
    },

    getProp: function(prop) {
      if (prop == "__proto__" || prop == "✖") return ANull;
      var found = (this.props || (this.props = Object.create(null)))[prop];
      if (!found) {
        found = this.props[prop] = new AVal;
        this.propagate(new GetProp(prop, found));
      }
      return found;
    },

    forAllProps: function(c) {
      this.propagate(new ForAllProps(c));
    },

    hasType: function(type) {
      return this.types.indexOf(type) > -1;
    },
    isEmpty: function() { return this.types.length === 0; },
    getFunctionType: function() {
      for (var i = this.types.length - 1; i >= 0; --i)
        if (this.types[i] instanceof Fn) return this.types[i];
    },
    getObjType: function() {
      var seen = null;
      for (var i = this.types.length - 1; i >= 0; --i) {
        var type = this.types[i];
        if (!(type instanceof Obj)) continue;
        if (type.name) return type;
        if (!seen) seen = type;
      }
      return seen;
    },

    getSymbolType: function() {
      for (var i = this.types.length - 1; i >= 0; --i)
        if (this.types[i] instanceof Sym) return this.types[i]
    },

    getType: function(guess) {
      if (this.types.length === 0 && guess !== false) return this.makeupType();
      if (this.types.length === 1) return this.types[0];
      return canonicalType(this.types);
    },

    toString: function(maxDepth, parent) {
      if (this.types.length == 1) return toString(this.types[0], maxDepth, parent);
      var simplified = simplifyTypes(this.types);
      if (simplified.length > 2) return "?";
      return simplified.map(function(tp) { return toString(tp, maxDepth, parent); }).join("|");
    },

    makeupPropType: function(obj) {
      var propName = this.propertyName;

      var protoProp = obj.proto && obj.proto.hasProp(propName);
      if (protoProp) {
        var fromProto = protoProp.getType();
        if (fromProto) return fromProto;
      }

      if (propName != "<i>") {
        var computedProp = obj.hasProp("<i>");
        if (computedProp) return computedProp.getType();
      } else if (obj.props["<i>"] != this) {
        for (var prop in obj.props) {
          var val = obj.props[prop];
          if (!val.isEmpty()) return val.getType();
        }
      }
    },

    makeupType: function() {
      var computed = this.propertyOf && this.makeupPropType(this.propertyOf);
      if (computed) return computed;

      if (!this.forward) return null;
      for (var i = this.forward.length - 1; i >= 0; --i) {
        var hint = this.forward[i].typeHint();
        if (hint && !hint.isEmpty()) {guessing = true; return hint;}
      }

      var props = Object.create(null), foundProp = null;
      for (var i = 0; i < this.forward.length; ++i) {
        var prop = this.forward[i].propHint();
        if (prop && prop != "length" && prop != "<i>" && prop != "✖" && prop != cx.completingProperty) {
          props[prop] = true;
          foundProp = prop;
        }
      }
      if (!foundProp) return null;

      var objs = objsWithProp(foundProp);
      if (objs) {
        var matches = [];
        search: for (var i = 0; i < objs.length; ++i) {
          var obj = objs[i];
          for (var prop in props) if (!obj.hasProp(prop)) continue search;
          if (obj.hasCtor) obj = getInstance(obj);
          matches.push(obj);
        }
        var canon = canonicalType(matches);
        if (canon) {guessing = true; return canon;}
      }
    },

    typeHint: function() { return this.types.length ? this.getType() : null; },
    propagatesTo: function() { return this; },

    gatherProperties: function(f, depth) {
      for (var i = 0; i < this.types.length; ++i)
        this.types[i].gatherProperties(f, depth);
    },

    guessProperties: function(f) {
      var forward = this.forward;
      if (forward) for (var i = 0; i < forward.length; ++i) {
        var prop = forward[i].propHint();
        if (prop) f(prop, null, 0, function(rec) { if (forward[i].args) rec.type = "fn()?"; });
      }
      var guessed = this.makeupType();
      if (guessed) guessed.gatherProperties(f);
    }
  });

  function similarAVal(a, b, depth) {
    var typeA = a.getType(false), typeB = b.getType(false);
    if (!typeA || !typeB) return true;
    return similarType(typeA, typeB, depth);
  }

  function similarType(a, b, depth) {
    if (!a || depth >= 5) return b;
    if (!a || a == b) return a;
    if (!b) return a;
    if (a.constructor != b.constructor) return false;
    if (a.constructor == Arr) {
      var innerA = a.getProp("<i>").getType(false);
      if (!innerA) return b;
      var innerB = b.getProp("<i>").getType(false);
      if (!innerB || similarType(innerA, innerB, depth + 1)) return b;
    } else if (a.constructor == Obj) {
      var propsA = 0, propsB = 0, same = 0;
      for (var prop in a.props) {
        propsA++;
        if (prop in b.props && similarAVal(a.props[prop], b.props[prop], depth + 1))
          same++;
      }
      for (var prop in b.props) propsB++;
      if (propsA && propsB && same < Math.max(propsA, propsB) / 2) return false;
      return propsA > propsB ? a : b;
    } else if (a.constructor == Fn) {
      if (a.args.length != b.args.length ||
          !a.args.every(function(tp, i) { return similarAVal(tp, b.args[i], depth + 1); }) ||
          !similarAVal(a.retval, b.retval, depth + 1) || !similarAVal(a.self, b.self, depth + 1))
        return false;
      return a;
    } else {
      return false;
    }
  }

  var simplifyTypes = exports.simplifyTypes = function(types) {
    var found = [];
    outer: for (var i = 0; i < types.length; ++i) {
      var tp = types[i];
      for (var j = 0; j < found.length; j++) {
        var similar = similarType(tp, found[j], 0);
        if (similar) {
          found[j] = similar;
          continue outer;
        }
      }
      found.push(tp);
    }
    return found;
  };

  function canonicalType(types) {
    var arrays = 0, fns = 0, objs = 0, prim = null;
    for (var i = 0; i < types.length; ++i) {
      var tp = types[i];
      if (tp instanceof Arr) ++arrays;
      else if (tp instanceof Fn) ++fns;
      else if (tp instanceof Obj) ++objs;
      else if (tp instanceof Prim) {
        if (prim && tp.name != prim.name) return null;
        prim = tp;
      }
    }
    var kinds = (arrays && 1) + (fns && 1) + (objs && 1) + (prim && 1);
    if (kinds > 1) return null;
    if (prim) return prim;

    var maxScore = 0, maxTp = null;
    for (var i = 0; i < types.length; ++i) {
      var tp = types[i], score = 0;
      if (arrays) {
        score = tp.getProp("<i>").isEmpty() ? 1 : 2;
      } else if (fns) {
        score = 1;
        for (var j = 0; j < tp.args.length; ++j) if (!tp.args[j].isEmpty()) ++score;
        if (!tp.retval.isEmpty()) ++score;
      } else if (objs) {
        score = tp.name ? 100 : 2;
      }
      if (score >= maxScore) { maxScore = score; maxTp = tp; }
    }
    return maxTp;
  }
  var constraint = exports.constraint = function(methods) {
    var ctor = function() {
      this.origin = cx.curOrigin;
      this.construct.apply(this, arguments);
    };
    ctor.prototype = Object.create(ANull);
    for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];
    return ctor;
  };

  var GetProp = constraint({
    construct: function(prop, target) {
      this.prop = prop; this.target = target;
    },
    addType: function(type, weight) {
      if (type.getProp)
        type.getProp(this.prop).propagate(this.target, weight);
    },
    propHint: function() { return this.prop; },
    propagatesTo: function() {
      if (this.prop == "<i>" || !/[^\w_]/.test(this.prop))
        return {target: this.target, pathExt: "." + this.prop};
    }
  });

  var DefProp = exports.PropHasSubset = exports.DefProp = constraint({
    construct: function(prop, type, originNode) {
      this.prop = prop; this.type = type; this.originNode = originNode;
    },
    addType: function(type, weight) {
      if (!(type instanceof Obj)) return;
      var prop = type.defProp(this.prop, this.originNode);
      if (!prop.origin) prop.origin = this.origin;
      this.type.propagate(prop, weight);
    },
    propHint: function() { return this.prop; }
  });

  var ForAllProps = constraint({
    construct: function(c) { this.c = c; },
    addType: function(type) {
      if (!(type instanceof Obj)) return;
      type.forAllProps(this.c);
    }
  });

  function withDisabledComputing(fn, body) {
    cx.disabledComputing = {fn: fn, prev: cx.disabledComputing};
    var result = body();
    cx.disabledComputing = cx.disabledComputing.prev;
    return result;
  }
  var IsCallee = exports.IsCallee = constraint({
    construct: function(self, args, argNodes, retval) {
      this.self = self; this.args = args; this.argNodes = argNodes; this.retval = retval;
      this.disabled = cx.disabledComputing;
    },
    addType: function(fn, weight) {
      if (!(fn instanceof Fn)) return;
      for (var i = 0; i < this.args.length; ++i) {
        if (i < fn.args.length) this.args[i].propagate(fn.args[i], weight);
        if (fn.arguments) this.args[i].propagate(fn.arguments, weight);
      }
      this.self.propagate(fn.self, this.self == cx.topScope ? WG_GLOBAL_THIS : weight);
      var compute = fn.computeRet, result = fn.retval
      if (compute) for (var d = this.disabled; d; d = d.prev)
        if (d.fn == fn || fn.originNode && d.fn.originNode == fn.originNode) compute = null;
      if (compute) {
        var old = cx.disabledComputing;
        cx.disabledComputing = this.disabled;
        result = compute(this.self, this.args, this.argNodes)
        cx.disabledComputing = old;
      }
      maybeIterator(fn, result).propagate(this.retval, weight)
    },
    typeHint: function() {
      var names = [];
      for (var i = 0; i < this.args.length; ++i) names.push("?");
      return new Fn(null, this.self, this.args, names, ANull);
    },
    propagatesTo: function() {
      return {target: this.retval, pathExt: ".!ret"};
    }
  });

  var HasMethodCall = constraint({
    construct: function(propName, args, argNodes, retval) {
      this.propName = propName; this.args = args; this.argNodes = argNodes; this.retval = retval;
      this.disabled = cx.disabledComputing;
    },
    addType: function(obj, weight) {
      var callee = new IsCallee(obj, this.args, this.argNodes, this.retval);
      callee.disabled = this.disabled;
      obj.getProp(this.propName).propagate(callee, weight);
    },
    propHint: function() { return this.propName; }
  });

  var IsCtor = exports.IsCtor = constraint({
    construct: function(target, noReuse) {
      this.target = target; this.noReuse = noReuse;
    },
    addType: function(f, weight) {
      if (!(f instanceof Fn)) return;
      if (cx.parent && !cx.parent.options.reuseInstances) this.noReuse = true;
      f.getProp("prototype").propagate(new IsProto(this.noReuse ? false : f, this.target), weight);
    }
  });

  var getInstance = exports.getInstance = function(obj, ctor) {
    if (ctor === false) return new Obj(obj);

    if (!ctor) ctor = obj.hasCtor;
    if (!obj.instances) obj.instances = [];
    for (var i = 0; i < obj.instances.length; ++i) {
      var cur = obj.instances[i];
      if (cur.ctor == ctor) return cur.instance;
    }
    var instance = new Obj(obj, ctor && ctor.name);
    instance.origin = obj.origin;
    obj.instances.push({ctor: ctor, instance: instance});
    return instance;
  };

  var IsProto = exports.IsProto = constraint({
    construct: function(ctor, target) {
      this.ctor = ctor; this.target = target;
    },
    addType: function(o, _weight) {
      if (!(o instanceof Obj)) return;
      if ((this.count = (this.count || 0) + 1) > 8) return;
      if (o == cx.protos.Array)
        this.target.addType(new Arr);
      else
        this.target.addType(getInstance(o, this.ctor));
    }
  });

  var FnPrototype = constraint({
    construct: function(fn) { this.fn = fn; },
    addType: function(o, _weight) {
      if (o instanceof Obj && !o.hasCtor) {
        o.hasCtor = this.fn;
        var adder = new SpeculativeThis(o, this.fn);
        adder.addType(this.fn);
        o.forAllProps(function(_prop, val, local) {
          if (local) val.propagate(adder);
        });
      }
    }
  });

  var IsAdded = constraint({
    construct: function(other, target) {
      this.other = other; this.target = target;
    },
    addType: function(type, weight) {
      if (type == cx.str)
        this.target.addType(cx.str, weight);
      else if (type == cx.num && this.other.hasType(cx.num))
        this.target.addType(cx.num, weight);
    },
    typeHint: function() { return this.other; }
  });

  var IfObj = exports.IfObj = constraint({
    construct: function(target) { this.target = target; },
    addType: function(t, weight) {
      if (t instanceof Obj) this.target.addType(t, weight);
    },
    propagatesTo: function() { return this.target; }
  });

  var SpeculativeThis = constraint({
    construct: function(obj, ctor) { this.obj = obj; this.ctor = ctor; },
    addType: function(tp) {
      if (tp instanceof Fn && tp.self)
        tp.self.addType(getInstance(this.obj, this.ctor), WG_SPECULATIVE_PROTO_THIS);
    }
  });

  var HasProto = constraint({
    construct: function(obj) { this.obj = obj },
    addType: function(tp) {
      if (tp instanceof Obj && this.obj.proto == cx.protos.Object)
        this.obj.replaceProto(tp)
    }
  });

  var Muffle = constraint({
    construct: function(inner, weight) {
      this.inner = inner; this.weight = weight;
    },
    addType: function(tp, weight) {
      this.inner.addType(tp, Math.min(weight, this.weight));
    },
    propagatesTo: function() { return this.inner.propagatesTo(); },
    typeHint: function() { return this.inner.typeHint(); },
    propHint: function() { return this.inner.propHint(); }
  });
  var Type = exports.Type = function() {};
  Type.prototype = extend(ANull, {
    constructor: Type,
    propagate: function(c, w) { c.addType(this, w); },
    hasType: function(other) { return other == this; },
    isEmpty: function() { return false; },
    typeHint: function() { return this; },
    getType: function() { return this; }
  });

  var Prim = exports.Prim = function(proto, name) { this.name = name; this.proto = proto; };
  Prim.prototype = extend(Type.prototype, {
    constructor: Prim,
    toString: function() { return this.name; },
    getProp: function(prop) {return this.proto.hasProp(prop) || ANull;},
    gatherProperties: function(f, depth) {
      if (this.proto) this.proto.gatherProperties(f, depth);
    }
  });

  function isInteger(str) {
    var c0 = str.charCodeAt(0)
    if (c0 >= 48 && c0 <= 57) return !/\D/.test(str)
    else return false
  }

  var Obj = exports.Obj = function(proto, name) {
    if (!this.props) this.props = Object.create(null);
    this.proto = proto === true ? cx.protos.Object : proto;
    if (this.proto && !(this.proto instanceof Obj)) {
      throw new Error("bad " + Object.keys(this.proto).join())
    }
    if (proto && !name && proto.name && !(this instanceof Fn)) {
      var match = /^(.*)\.prototype$/.exec(this.proto.name);
      if (match) name = match[1];
    }
    this.name = name;
    this.maybeProps = null;
    this.origin = cx.curOrigin;
  };
  Obj.prototype = extend(Type.prototype, {
    constructor: Obj,
    toString: function(maxDepth) {
      if (maxDepth == null) maxDepth = 0;
      if (maxDepth <= 0 && this.name) return this.name;
      var props = [], etc = false;
      for (var prop in this.props) if (prop != "<i>") {
        if (props.length > 5) { etc = true; break; }
        if (maxDepth)
          props.push(prop + ": " + toString(this.props[prop], maxDepth - 1, this));
        else
          props.push(prop);
      }
      props.sort();
      if (etc) props.push("...");
      return "{" + props.join(", ") + "}";
    },
    hasProp: function(prop, searchProto) {
      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)
      var found = this.props[prop];
      if (searchProto !== false)
        for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];
      return found;
    },
    defProp: function(prop, originNode) {
      var found = this.hasProp(prop, false);
      if (found) {
        if (originNode && !found.originNode) found.originNode = originNode;
        return found;
      }
      if (prop == "__proto__" || prop == "✖") return ANull;
      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)

      var av = this.maybeProps && this.maybeProps[prop];
      if (av) {
        delete this.maybeProps[prop];
        this.maybeUnregProtoPropHandler();
      } else {
        av = new AVal;
        av.propertyOf = this;
        av.propertyName = prop;
      }

      this.props[prop] = av;
      av.originNode = originNode;
      av.origin = cx.curOrigin;
      this.broadcastProp(prop, av, true);
      return av;
    },
    getProp: function(prop) {
      var found = this.hasProp(prop, true) || (this.maybeProps && this.maybeProps[prop]);
      if (found) return found;
      if (prop == "__proto__" || prop == "✖") return ANull;
      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)
      var av = this.ensureMaybeProps()[prop] = new AVal;
      av.propertyOf = this;
      av.propertyName = prop;
      return av;
    },
    normalizeIntegerProp: function(_) { return "<i>" },
    broadcastProp: function(prop, val, local) {
      if (local) {
        this.signal("addProp", prop, val);
        if (!(this instanceof Scope)) registerProp(prop, this);
      }

      if (this.onNewProp) for (var i = 0; i < this.onNewProp.length; ++i) {
        var h = this.onNewProp[i];
        h.onProtoProp ? h.onProtoProp(prop, val, local) : h(prop, val, local);
      }
    },
    onProtoProp: function(prop, val, _local) {
      var maybe = this.maybeProps && this.maybeProps[prop];
      if (maybe) {
        delete this.maybeProps[prop];
        this.maybeUnregProtoPropHandler();
        this.proto.getProp(prop).propagate(maybe);
      }
      this.broadcastProp(prop, val, false);
    },
    replaceProto: function(proto) {
      if (this.proto && this.maybeProps)
        this.proto.unregPropHandler(this)
      this.proto = proto
      if (this.maybeProps)
        this.proto.forAllProps(this)
    },
    ensureMaybeProps: function() {
      if (!this.maybeProps) {
        if (this.proto) this.proto.forAllProps(this);
        this.maybeProps = Object.create(null);
      }
      return this.maybeProps;
    },
    removeProp: function(prop) {
      var av = this.props[prop];
      delete this.props[prop];
      this.ensureMaybeProps()[prop] = av;
      av.types.length = 0;
    },
    forAllProps: function(c) {
      if (!this.onNewProp) {
        this.onNewProp = [];
        if (this.proto) this.proto.forAllProps(this);
      }
      this.onNewProp.push(c);
      for (var o = this; o; o = o.proto) for (var prop in o.props) {
        if (c.onProtoProp)
          c.onProtoProp(prop, o.props[prop], o == this);
        else
          c(prop, o.props[prop], o == this);
      }
    },
    maybeUnregProtoPropHandler: function() {
      if (this.maybeProps) {
        for (var _n in this.maybeProps) return;
        this.maybeProps = null;
      }
      if (!this.proto || this.onNewProp && this.onNewProp.length) return;
      this.proto.unregPropHandler(this);
    },
    unregPropHandler: function(handler) {
      for (var i = 0; i < this.onNewProp.length; ++i)
        if (this.onNewProp[i] == handler) { this.onNewProp.splice(i, 1); break; }
      this.maybeUnregProtoPropHandler();
    },
    gatherProperties: function(f, depth) {
      for (var prop in this.props) if (prop != "<i>" && prop.charAt(0) != ":")
        f(prop, this, depth);
      if (this.proto) this.proto.gatherProperties(f, depth + 1);
    },
    getObjType: function() { return this; }
  });

  var Fn = exports.Fn = function(name, self, args, argNames, retval, generator) {
    Obj.call(this, cx.protos.Function, name);
    this.self = self;
    this.args = args;
    this.argNames = argNames;
    this.retval = retval;
    this.generator = generator
  };
  Fn.prototype = extend(Obj.prototype, {
    constructor: Fn,
    toString: function(maxDepth) {
      if (maxDepth == null) maxDepth = 0;
      var str = this.generator ? "fn*(" : "fn(";
      for (var i = 0; i < this.args.length; ++i) {
        if (i) str += ", ";
        var name = this.argNames[i];
        if (name && name != "?") str += name + ": ";
        str += maxDepth > -3 ? toString(this.args[i], maxDepth - 1, this) : "?";
      }
      str += ")";
      if (!this.retval.isEmpty())
        str += " -> " + (maxDepth > -3 ? toString(this.retval, maxDepth - 1, this) : "?");
      return str;
    },
    getProp: function(prop) {
      if (prop == "prototype") {
        var known = this.hasProp(prop, false);
        if (!known) {
          known = this.defProp(prop);
          var proto = new Obj(true, this.name && this.name + ".prototype");
          proto.origin = this.origin;
          known.addType(proto, WG_MADEUP_PROTO);
        }
        return known;
      }
      return Obj.prototype.getProp.call(this, prop);
    },
    defProp: function(prop, originNode) {
      if (prop == "prototype") {
        var found = this.hasProp(prop, false);
        if (found) return found;
        found = Obj.prototype.defProp.call(this, prop, originNode);
        found.origin = this.origin;
        found.propagate(new FnPrototype(this));
        return found;
      }
      return Obj.prototype.defProp.call(this, prop, originNode);
    },
    getFunctionType: function() { return this; }
  });

  var Arr = exports.Arr = function(contentType) {
    Obj.call(this, cx.protos.Array)
    var content = this.defProp("<i>")
    if (Array.isArray(contentType)) {
      this.tuple = contentType.length
      for (var i = 0; i < contentType.length; i++) {
        var prop = this.defProp(String(i))
        contentType[i].propagate(prop)
        prop.propagate(content)
      }
    } else if (contentType) {
      this.tuple = 0
      contentType.propagate(content)
    }
  };
  Arr.prototype = extend(Obj.prototype, {
    constructor: Arr,
    toString: function(maxDepth) {
      if (maxDepth == null) maxDepth = 0
      if (maxDepth <= -3) return "[?]"
      var content = ""
      if (this.tuple) {
        var similar
        for (var i = 0; i in this.props; i++) {
          var type = toString(this.getProp(String(i)), maxDepth - 1, this)
          if (similar == null)
            similar = type
          else if (similar != type)
            similar = false
          else
            similar = type
          content += (content ? ", " : "") + type
        }
        if (similar) content = similar
      } else {
        content = toString(this.getProp("<i>"), maxDepth - 1, this)
      }
      return "[" + content + "]"
    },
    normalizeIntegerProp: function(prop) {
      if (+prop < this.tuple) return prop
      else return "<i>"
    }
  });

  var Sym = exports.Sym = function(name, originNode) {
    Prim.call(this, cx.protos.Symbol, "Symbol")
    this.symName = name
    this.originNode = originNode
  }
  Sym.prototype = extend(Prim.prototype, {
    constructor: Sym,
    asPropName: function() { return ":" + this.symName },
    getSymbolType: function() { return this }
  })

  exports.getSymbol = function(name, originNode) {
    var cleanName = name.replace(/[^\w$\.]/g, "_")
    var known = cx.symbols[cleanName]
    if (known) {
      if (originNode && !known.originNode) known.originNode = originNode
      return known
    }
    return cx.symbols[cleanName] = new Sym(cleanName, originNode)
  }
  function registerProp(prop, obj) {
    var data = cx.props[prop] || (cx.props[prop] = []);
    data.push(obj);
  }

  function objsWithProp(prop) {
    return cx.props[prop];
  }
  exports.Context = function(defs, parent) {
    this.parent = parent;
    this.props = Object.create(null);
    this.protos = Object.create(null);
    this.origins = [];
    this.curOrigin = "ecma5";
    this.paths = Object.create(null);
    this.definitions = Object.create(null);
    this.purgeGen = 0;
    this.workList = null;
    this.disabledComputing = null;
    this.curSuperCtor = this.curSuper = null;
    this.symbols = Object.create(null)

    exports.withContext(this, function() {
      cx.protos.Object = new Obj(null, "Object.prototype");
      cx.topScope = new Scope();
      cx.topScope.name = "<top>";
      cx.protos.Array = new Obj(true, "Array.prototype");
      cx.protos.Function = new Fn("Function.prototype", ANull, [], [], ANull);
      cx.protos.Function.proto = cx.protos.Object;
      cx.protos.RegExp = new Obj(true, "RegExp.prototype");
      cx.protos.String = new Obj(true, "String.prototype");
      cx.protos.Number = new Obj(true, "Number.prototype");
      cx.protos.Boolean = new Obj(true, "Boolean.prototype");
      cx.protos.Symbol = new Obj(true, "Symbol.prototype");
      cx.str = new Prim(cx.protos.String, "string");
      cx.bool = new Prim(cx.protos.Boolean, "bool");
      cx.num = new Prim(cx.protos.Number, "number");
      cx.curOrigin = null;

      if (defs) for (var i = 0; i < defs.length; ++i)
        def.load(defs[i]);
    });
  };

  exports.Context.prototype.startAnalysis = function() {
    this.disabledComputing = this.workList = this.curSuperCtor = this.curSuper = null;
  };

  var cx = null;
  exports.cx = function() { return cx; };

  exports.withContext = function(context, f) {
    var old = cx;
    cx = context;
    try { return f(); }
    finally { cx = old; }
  };

  exports.TimedOut = function() {
    this.message = "Timed out";
    this.stack = (new Error()).stack;
  };
  exports.TimedOut.prototype = Object.create(Error.prototype);
  exports.TimedOut.prototype.name = "infer.TimedOut";

  var timeout;
  exports.withTimeout = function(ms, f) {
    var end = +new Date + ms;
    var oldEnd = timeout;
    if (oldEnd && oldEnd < end) return f();
    timeout = end;
    try { return f(); }
    finally { timeout = oldEnd; }
  };

  exports.addOrigin = function(origin) {
    if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);
  };

  var baseMaxWorkDepth = 20, reduceMaxWorkDepth = 0.0001;
  function withWorklist(f) {
    if (cx.workList) return f(cx.workList);

    var list = [], depth = 0;
    var add = cx.workList = function(type, target, weight) {
      if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length)
        list.push(type, target, weight, depth);
    };
    var ret = f(add);
    for (var i = 0; i < list.length; i += 4) {
      if (timeout && +new Date >= timeout)
        throw new exports.TimedOut();
      depth = list[i + 3] + 1;
      list[i + 1].addType(list[i], list[i + 2]);
    }
    cx.workList = null;
    return ret;
  }

  function withSuper(ctor, obj, f) {
    var oldCtor = cx.curSuperCtor, oldObj = cx.curSuper
    cx.curSuperCtor = ctor; cx.curSuper = obj
    var result = f()
    cx.curSuperCtor = oldCtor; cx.curSuper = oldObj
    return result
  }
  var Scope = exports.Scope = function(prev, originNode, isBlock) {
    Obj.call(this, prev || true);
    this.prev = prev;
    this.originNode = originNode
    this.isBlock = !!isBlock
  };
  Scope.prototype = extend(Obj.prototype, {
    constructor: Scope,
    defVar: function(name, originNode) {
      for (var s = this; ; s = s.proto) {
        var found = s.props[name];
        if (found) return found;
        if (!s.prev) return s.defProp(name, originNode);
      }
    }
  });

  function functionScope(scope) {
    while (scope.isBlock) scope = scope.prev
    return scope
  }
  function maybeInstantiate(scope, score) {
    var fn = functionScope(scope).fnType
    if (fn) fn.instantiateScore = (fn.instantiateScore || 0) + score;
  }

  var NotSmaller = {};
  function nodeSmallerThan(node, n) {
    try {
      walk.simple(node, {Expression: function() { if (--n <= 0) throw NotSmaller; }});
      return true;
    } catch(e) {
      if (e == NotSmaller) return false;
      throw e;
    }
  }

  function maybeTagAsInstantiated(node, fn) {
    var score = fn.instantiateScore;
    if (!cx.disabledComputing && score && fn.args.length && nodeSmallerThan(node, score * 5)) {
      maybeInstantiate(functionScope(fn.originNode.scope.prev), score / 2);
      setFunctionInstantiated(node, fn);
      return true;
    } else {
      fn.instantiateScore = null;
    }
  }

  function setFunctionInstantiated(node, fn) {
    for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal;
    fn.self = new AVal;
    fn.computeRet = function(self, args) {
      return withDisabledComputing(fn, function() {
        var oldOrigin = cx.curOrigin;
        cx.curOrigin = fn.origin;
        var scope = node.scope
        var scopeCopy = new Scope(scope.prev, scope.originNode);
        for (var v in scope.props) {
          var local = scopeCopy.defProp(v, scope.props[v].originNode);
          for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length)
            args[i].propagate(local);
        }
        var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;
        while (argNames.length < args.length) argNames.push("?");
        scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull, fn.generator);
        scopeCopy.fnType.originNode = fn.originNode;
        if (fn.arguments) {
          var argset = scopeCopy.fnType.arguments = new AVal;
          scopeCopy.defProp("arguments").addType(new Arr(argset));
          for (var i = 0; i < args.length; ++i) args[i].propagate(argset);
        }
        node.scope = scopeCopy;
        walk.recursive(node.body, scopeCopy, null, scopeGatherer);
        walk.recursive(node.body, scopeCopy, null, inferWrapper);
        cx.curOrigin = oldOrigin;
        return scopeCopy.fnType.retval;
      });
    };
  }

  function maybeTagAsGeneric(fn) {
    var target = fn.retval;
    if (target == ANull) return;
    var targetInner, asArray;
    if (!target.isEmpty() && (targetInner = target.getType()) instanceof Arr)
      target = asArray = targetInner.getProp("<i>");

    function explore(aval, path, depth) {
      if (depth > 3 || !aval.forward) return;
      for (var i = 0; i < aval.forward.length; ++i) {
        var prop = aval.forward[i].propagatesTo();
        if (!prop) continue;
        var newPath = path, dest;
        if (prop instanceof AVal) {
          dest = prop;
        } else if (prop.target instanceof AVal) {
          newPath += prop.pathExt;
          dest = prop.target;
        } else continue;
        if (dest == target) return newPath;
        var found = explore(dest, newPath, depth + 1);
        if (found) return found;
      }
    }

    var foundPath = explore(fn.self, "!this", 0);
    for (var i = 0; !foundPath && i < fn.args.length; ++i)
      foundPath = explore(fn.args[i], "!" + i, 0);

    if (foundPath) {
      if (asArray) foundPath = "[" + foundPath + "]";
      var p = new def.TypeParser(foundPath);
      var parsed = p.parseType(true);
      fn.computeRet = parsed.apply ? parsed : function() { return parsed; };
      fn.computeRetSource = foundPath;
      return true;
    }
  }
  function addVar(scope, nameNode) {
    return scope.defProp(nameNode.name, nameNode);
  }
  function patternName(node) {
    if (node.type == "Identifier") return node.name
    if (node.type == "AssignmentPattern") return patternName(node.left)
    if (node.type == "ObjectPattern") return "{" + node.properties.map(function(e) { return patternName(e.value) }).join(", ") + "}"
    if (node.type == "ArrayPattern") return "[" + node.elements.map(patternName).join(", ") + "]"
    if (node.type == "RestElement") return "..." + patternName(node.argument)
    return "_"
  }

  function isBlockScopedDecl(node) {
    return node.type == "VariableDeclaration" && node.kind != "var" ||
      node.type == "FunctionDeclaration" ||
      node.type == "ClassDeclaration";
  }

  function patternScopes(inner, outer) {
    return {inner: inner, outer: outer || inner}
  }

  var scopeGatherer = exports.scopeGatherer = walk.make({
    VariablePattern: function(node, scopes) {
      if (scopes.inner) addVar(scopes.inner, node)
    },
    AssignmentPattern: function(node, scopes, c) {
      c(node.left, scopes, "Pattern")
      c(node.right, scopes.outer, "Expression")
    },
    AssignmentExpression: function(node, scope, c) {
      if (node.left.type == "MemberExpression")
        c(node.left, scope, "Expression")
      else
        c(node.left, patternScopes(false, scope), "Pattern")
      c(node.right, scope, "Expression")
    },
    Function: function(node, scope, c) {
      if (scope.inner) throw new Error("problem at " + node.start + " " + node.type)
      var inner = node.scope = new Scope(scope, node)
      var argVals = [], argNames = []
      for (var i = 0; i < node.params.length; ++i) {
        var param = node.params[i]
        argNames.push(patternName(param))
        if (param.type == "Identifier") {
          argVals.push(addVar(inner, param))
        } else {
          var arg = new AVal
          argVals.push(arg)
          arg.originNode = param
          c(param, patternScopes(inner), "Pattern")
        }
      }
      inner.fnType = new Fn(node.id && node.id.name, new AVal, argVals, argNames, ANull, node.generator)
      inner.fnType.originNode = node;
      if (node.id) {
        var decl = node.type == "FunctionDeclaration";
        addVar(decl ? scope : inner, node.id);
      }
      c(node.body, inner, node.expression ? "Expression" : "Statement");
    },
    BlockStatement: function(node, scope, c) {
      if (!node.scope && node.body.some(isBlockScopedDecl))
        scope = node.scope = new Scope(scope, node, true)
      walk.base.BlockStatement(node, scope, c)
    },
    TryStatement: function(node, scope, c) {
      c(node.block, scope, "Statement");
      if (node.handler) {
        if (node.handler.param.type == "Identifier") {
          var v = addVar(scope, node.handler.param);
          c(node.handler.body, scope, "Statement");
          var e5 = cx.definitions.ecma5;
          if (e5 && v.isEmpty()) getInstance(e5["Error.prototype"]).propagate(v, WG_CATCH_ERROR);
        } else {
          c(node.handler.param, patternScopes(scope), "Pattern")
        }
      }
      if (node.finalizer) c(node.finalizer, scope, "Statement");
    },
    VariableDeclaration: function(node, scope, c) {
      var targetScope = node.kind == "var" ? functionScope(scope) : scope
      for (var i = 0; i < node.declarations.length; ++i) {
        var decl = node.declarations[i];
        c(decl.id, patternScopes(targetScope, scope), "Pattern")
        if (decl.init) c(decl.init, scope, "Expression");
      }
    },
    ClassDeclaration: function(node, scope, c) {
      addVar(scope, node.id)
      if (node.superClass) c(node.superClass, scope, "Expression")
      for (var i = 0; i < node.body.body.length; i++)
        c(node.body.body[i], scope)
    },
    ForInStatement: function(node, scope, c) {
      if (!node.scope && isBlockScopedDecl(node.left))
        scope = node.scope = new Scope(scope, node, true)
      walk.base.ForInStatement(node, scope, c)
    },
    ForStatement: function(node, scope, c) {
      if (!node.scope && node.init && isBlockScopedDecl(node.init))
        scope = node.scope = new Scope(scope, node, true)
      walk.base.ForStatement(node, scope, c)
    },
    ImportDeclaration: function(node, scope) {
      for (var i = 0; i < node.specifiers.length; i++)
        addVar(scope, node.specifiers[i].local)
    }
  });
  scopeGatherer.ForOfStatement = scopeGatherer.ForInStatement
  var propName = exports.propName = function(node, inferInScope) {
    var key = node.property || node.key;
    if (!node.computed && key.type == "Identifier") return key.name;
    if (key.type == "Literal") {
      if (typeof key.value == "string") return key.value
      if (typeof key.value == "number") return String(key.value)
    }
    if (inferInScope) {
      var symName = symbolName(infer(key, inferInScope))
      if (symName) return node.propName = symName
    } else if (node.propName) {
      return node.propName
    }
    return "<i>";
  }
  function symbolName(val) {
    var sym = val.getSymbolType()
    if (sym) return sym.asPropName()
  }

  function unopResultType(op) {
    switch (op) {
    case "+": case "-": case "~": return cx.num;
    case "!": return cx.bool;
    case "typeof": return cx.str;
    case "void": case "delete": return ANull;
    }
  }
  function binopIsBoolean(op) {
    switch (op) {
    case "==": case "!=": case "===": case "!==": case "<": case ">": case ">=": case "<=":
    case "in": case "instanceof": return true;
    }
  }
  function literalType(node) {
    if (node.regex) return getInstance(cx.protos.RegExp);
    switch (typeof node.value) {
    case "boolean": return cx.bool;
    case "number": return cx.num;
    case "string": return cx.str;
    case "object":
    case "function":
      if (!node.value) return ANull;
      return getInstance(cx.protos.RegExp);
    }
  }

  function join(a, b) {
    if (a == b || b == ANull) return a
    if (a == ANull) return b
    var joined = new AVal
    a.propagate(joined)
    b.propagate(joined)
    return joined
  }

  function connectParams(node, scope) {
    for (var i = 0; i < node.params.length; i++) {
      var param = node.params[i]
      if (param.type == "Identifier") continue
      connectPattern(param, scope, node.scope.fnType.args[i])
    }
  }

  function ensureVar(node, scope) {
    return scope.hasProp(node.name) || cx.topScope.defProp(node.name, node)
  }

  var inferPatternVisitor = exports.inferPatternVisitor = {
    Identifier: function(node, scope, source) {
      source.propagate(ensureVar(node, scope))
    },
    MemberExpression: function(node, scope, source) {
      var obj = infer(node.object, scope)
      var pName = propName(node, scope)
      obj.propagate(new DefProp(pName, source, node.property))
    },
    RestElement: function(node, scope, source) {
      connectPattern(node.argument, scope, new Arr(source))
    },
    ObjectPattern: function(node, scope, source) {
      for (var i = 0; i < node.properties.length; ++i) {
        var prop = node.properties[i]
        connectPattern(prop.value, scope, source.getProp(prop.key.name))
      }
    },
    ArrayPattern: function(node, scope, source) {
      for (var i = 0; i < node.elements.length; i++)
        if (node.elements[i])
          connectPattern(node.elements[i], scope, source.getProp(String(i)))
    },
    AssignmentPattern: function(node, scope, source) {
      connectPattern(node.left, scope, join(source, infer(node.right, scope)))
    }
  }

  function connectPattern(node, scope, source) {
    var connecter = inferPatternVisitor[node.type]
    if (connecter) connecter(node, scope, source)
  }

  function getThis(scope) {
    var fnScope = functionScope(scope)
    return fnScope.fnType ? fnScope.fnType.self : fnScope
  }

  function maybeAddPhantomObj(obj) {
    if (!obj.isEmpty() || !obj.propertyOf) return
    obj.propertyOf.getProp(obj.propertyName).addType(new Obj, WG_PHANTOM_OBJ)
    maybeAddPhantomObj(obj.propertyOf)
  }

  function inferClass(node, scope, name) {
    if (!name && node.id) name = node.id.name

    var sup = cx.protos.Object, supCtor, delayed
    if (node.superClass) {
      if (node.superClass.type == "Literal" && node.superClass.value == null) {
        sup = null
      } else {
        var supVal = infer(node.superClass, scope), supProto
        supCtor = supVal.getFunctionType()
        if (supCtor && (supProto = supCtor.getProp("prototype").getObjType())) {
          sup = supProto
        } else {
          supCtor = supVal
          delayed = supVal.getProp("prototype")
        }
      }
    }
    var proto = new Obj(sup, name && name + ".prototype")
    if (delayed) delayed.propagate(new HasProto(proto))

    return withSuper(supCtor, delayed || sup, function() {
      var ctor, body = node.body.body
      for (var i = 0; i < body.length; i++)
        if (body[i].kind == "constructor") ctor = body[i].value
      var fn = node.objType = ctor ? infer(ctor, scope) : new Fn(name, ANull, [], null, ANull)
      fn.originNode = node.id || ctor || node

      var inst = getInstance(proto, fn)
      fn.self.addType(inst)
      fn.defProp("prototype", node).addType(proto)
      for (var i = 0; i < body.length; i++) {
        var method = body[i], target
        if (method.kind == "constructor") continue
        var pName = propName(method, scope)
        if (pName == "<i>" || method.kind == "set") {
          target = ANull
        } else {
          target = (method.static ? fn : proto).defProp(pName, method.key)
          target.initializer = true
          if (method.kind == "get") target = new IsCallee(inst, [], null, target)
        }
        infer(method.value, scope, target)
        var methodFn = target.getFunctionType()
        if (methodFn) methodFn.self.addType(inst)
      }
      return fn
    })
  }

  function arrayLiteralType(elements, scope, inner) {
    var tuple = elements.length > 1 && elements.length < 6
    if (tuple) {
      var homogenous = true, litType
      for (var i = 0; i < elements.length; i++) {
        var elt = elements[i]
        if (!elt)
          tuple = false
        else if (elt.type != "Literal" || (litType && litType != typeof elt.value))
          homogenous = false
        else
          litType = typeof elt.value
      }
      if (homogenous) tuple = false
    }

    if (tuple) {
      var types = []
      for (var i = 0; i < elements.length; ++i)
        types.push(inner(elements[i], scope))
      return new Arr(types)
    } else if (elements.length < 2) {
      return new Arr(elements[0] && inner(elements[0], scope))
    } else {
      var eltVal = new AVal
      for (var i = 0; i < elements.length; i++)
        if (elements[i]) inner(elements[i], scope).propagate(eltVal)
      return new Arr(eltVal)
    }
  }

  function ret(f) {
    return function(node, scope, out, name) {
      var r = f(node, scope, name);
      if (out) r.propagate(out);
      return r;
    };
  }
  function fill(f) {
    return function(node, scope, out, name) {
      if (!out) out = new AVal;
      f(node, scope, out, name);
      return out;
    };
  }

  var inferExprVisitor = exports.inferExprVisitor = {
    ArrayExpression: ret(function(node, scope) {
      return arrayLiteralType(node.elements, scope, infer)
    }),
    ObjectExpression: ret(function(node, scope, name) {
      var proto = true, waitForProto
      for (var i = 0; i < node.properties.length; ++i) {
        var prop = node.properties[i]
        if (prop.key.name == "__proto__") {
          if (prop.value.type == "Literal" && prop.value.value == null) {
            proto = null
          } else {
            var protoVal = infer(prop.value, scope), known = protoVal.getObjType()
            if (known) proto = known
            else waitForProto = protoVal
          }
        }
      }

      var obj = node.objType = new Obj(proto, name);
      if (waitForProto) waitForProto.propagate(new HasProto(obj))
      obj.originNode = node;

      withSuper(null, waitForProto || proto, function() {
        for (var i = 0; i < node.properties.length; ++i) {
          var prop = node.properties[i], key = prop.key;
          if (prop.value.name == "✖" || prop.key.name == "__proto__") continue;

          var name = propName(prop, scope), target
          if (name == "<i>" || prop.kind == "set") {
            target = ANull;
          } else {
            var val = target = obj.defProp(name, key);
            val.initializer = true;
            if (prop.kind == "get")
              target = new IsCallee(obj, [], null, val);
          }
          infer(prop.value, scope, target, name);
          if (prop.value.type == "FunctionExpression")
            prop.value.scope.fnType.self.addType(obj, WG_SPECULATIVE_THIS);
        }
      })
      return obj;
    }),
    FunctionExpression: ret(function(node, scope, name) {
      var inner = node.scope, fn = inner.fnType;
      if (name && !fn.name) fn.name = name;
      connectParams(node, inner)
      if (node.expression)
        infer(node.body, inner, inner.fnType.retval = new AVal)
      else
        walk.recursive(node.body, inner, null, inferWrapper, "Statement")
      if (node.type == "ArrowFunctionExpression") {
        getThis(scope).propagate(fn.self)
        fn.self = ANull
      }
      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);
      if (node.id) inner.getProp(node.id.name).addType(fn);
      return fn;
    }),
    ClassExpression: ret(inferClass),
    SequenceExpression: ret(function(node, scope) {
      for (var i = 0, l = node.expressions.length - 1; i < l; ++i)
        infer(node.expressions[i], scope, ANull);
      return infer(node.expressions[l], scope);
    }),
    UnaryExpression: ret(function(node, scope) {
      infer(node.argument, scope, ANull);
      return unopResultType(node.operator);
    }),
    SpreadExpression: ret(function(node, scope) {
      return infer(node.argument, scope, ANull); // TODO: fixme
    }),
    SpreadElement: ret(function(node, scope) {
      return infer(node.argument, scope, ANull); // TODO: fixme
    }),
    UpdateExpression: ret(function(node, scope) {
      infer(node.argument, scope, ANull);
      return cx.num;
    }),
    BinaryExpression: ret(function(node, scope) {
      if (node.operator == "+") {
        var lhs = infer(node.left, scope);
        var rhs = infer(node.right, scope);
        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
        if (lhs.hasType(cx.num) && rhs.hasType(cx.num)) return cx.num;
        var result = new AVal;
        lhs.propagate(new IsAdded(rhs, result));
        rhs.propagate(new IsAdded(lhs, result));
        return result;
      } else {
        infer(node.left, scope, ANull);
        infer(node.right, scope, ANull);
        return binopIsBoolean(node.operator) ? cx.bool : cx.num;
      }
    }),
    AssignmentExpression: ret(function(node, scope, name) {
      var rhs, pName;
      if (node.left.type == "MemberExpression") {
        pName = propName(node.left, scope)
        if (!name)
          name = node.left.object.type == "Identifier" ? node.left.object.name + "." + pName : pName
      } else if (!name && node.left.type == "Identifier") {
        name = node.left.name
      }

      if (node.operator && node.operator != "=" && node.operator != "+=") {
        infer(node.right, scope, ANull);
        rhs = cx.num;
      } else {
        rhs = infer(node.right, scope, null, name);
      }

      if (node.left.type == "MemberExpression") {
        var obj = infer(node.left.object, scope);
        if (pName == "prototype") maybeInstantiate(scope, 20);
        if (pName == "<i>") {
          var v = node.left.property.name, local = scope.props[v], over = local && local.iteratesOver;
          if (over) {
            maybeInstantiate(scope, 20);
            var fromRight = node.right.type == "MemberExpression" && node.right.computed && node.right.property.name == v;
            over.forAllProps(function(prop, val, local) {
              if (local && prop != "prototype" && prop != "<i>")
                obj.propagate(new DefProp(prop, fromRight ? val : ANull));
            });
            return rhs;
          }
        }

        obj.propagate(new DefProp(pName, rhs, node.left.property));
        maybeAddPhantomObj(obj)
        if (node.right.type == "FunctionExpression")
          obj.propagate(node.right.scope.fnType.self, WG_SPECULATIVE_THIS);
      } else {
        connectPattern(node.left, scope, rhs)
      }
      return rhs;
    }),
    LogicalExpression: fill(function(node, scope, out) {
      infer(node.left, scope, out);
      infer(node.right, scope, out);
    }),
    ConditionalExpression: fill(function(node, scope, out) {
      infer(node.test, scope, ANull);
      infer(node.consequent, scope, out);
      infer(node.alternate, scope, out);
    }),
    NewExpression: fill(function(node, scope, out, name) {
      if (node.callee.type == "Identifier" && node.callee.name in scope.props)
        maybeInstantiate(scope, 20);

      for (var i = 0, args = []; i < node.arguments.length; ++i)
        args.push(infer(node.arguments[i], scope));
      var callee = infer(node.callee, scope);
      var self = new AVal;
      callee.propagate(new IsCtor(self, name && /\.prototype$/.test(name)));
      self.propagate(out, WG_NEW_INSTANCE);
      callee.propagate(new IsCallee(self, args, node.arguments, new IfObj(out)));
    }),
    CallExpression: fill(function(node, scope, out) {
      for (var i = 0, args = []; i < node.arguments.length; ++i)
        args.push(infer(node.arguments[i], scope));
      var outerFn = functionScope(scope).fnType
      if (node.callee.type == "MemberExpression") {
        var self = infer(node.callee.object, scope);
        var pName = propName(node.callee, scope)
        if (outerFn && (pName == "call" || pName == "apply") &&
            outerFn.args.indexOf(self) > -1)
          maybeInstantiate(scope, 30);
        self.propagate(new HasMethodCall(pName, args, node.arguments, out));
      } else if (node.callee.type == "Super" && cx.curSuperCtor) {
        cx.curSuperCtor.propagate(new IsCallee(getThis(scope), args, node.arguments, out))
      } else {
        var callee = infer(node.callee, scope);
        if (outerFn && outerFn.args.indexOf(callee) > -1)
          maybeInstantiate(scope, 30);
        var knownFn = callee.getFunctionType();
        if (knownFn && knownFn.instantiateScore && outerFn)
          maybeInstantiate(scope, knownFn.instantiateScore / 5);
        callee.propagate(new IsCallee(cx.topScope, args, node.arguments, out));
      }
    }),
    MemberExpression: fill(function(node, scope, out) {
      var name = propName(node), wg;
      if (name == "<i>") {
        var propType = infer(node.property, scope)
        var symName = symbolName(propType)
        if (symName)
          name = node.propName = symName
        else if (!propType.hasType(cx.num))
          wg = WG_MULTI_MEMBER
      }
      infer(node.object, scope).getProp(name).propagate(out, wg)
    }),
    Identifier: ret(function(node, scope) {
      if (node.name == "arguments") {
        var fnScope = functionScope(scope)
        if (fnScope.fnType && !(node.name in fnScope.props))
          scope.defProp(node.name, fnScope.fnType.originNode)
            .addType(new Arr(fnScope.fnType.arguments = new AVal));
      }
      return scope.getProp(node.name);
    }),
    ThisExpression: ret(function(_node, scope) {
      return getThis(scope)
    }),
    Super: ret(function(node) {
      return node.superType = cx.curSuper || ANull
    }),
    Literal: ret(function(node) {
      return literalType(node);
    }),
    TemplateLiteral: ret(function(node, scope) {
      for (var i = 0; i < node.expressions.length; ++i)
        infer(node.expressions[i], scope, ANull)
      return cx.str
    }),
    TaggedTemplateExpression: fill(function(node, scope, out) {
      var args = [new Arr(cx.str)]
      for (var i = 0; i < node.quasi.expressions.length; ++i)
        args.push(infer(node.quasi.expressions[i], scope))
      infer(node.tag, scope, new IsCallee(cx.topScope, args, node.quasi.expressions, out))
    }),
    YieldExpression: ret(function(node, scope) {
      var output = ANull, fn = functionScope(scope).fnType
      if (fn) {
        if (fn.retval == ANull) fn.retval = new AVal
        if (!fn.yieldval) fn.yieldval = new AVal
        output = fn.retval
      }
      if (node.argument) {
        if (node.delegate) {
          infer(node.argument, scope, new HasMethodCall("next", [], null,
                                                        new GetProp("value", output)))
        } else {
          infer(node.argument, scope, output)
        }
      }
      return fn ? fn.yieldval : ANull
    })
  };
  inferExprVisitor.ArrowFunctionExpression = inferExprVisitor.FunctionExpression

  function infer(node, scope, out, name) {
    var handler = inferExprVisitor[node.type];
    return handler ? handler(node, scope, out, name) : ANull;
  }

  function loopPattern(init) {
    return init.type == "VariableDeclaration" ? init.declarations[0].id : init
  }

  var inferWrapper = exports.inferWrapper = walk.make({
    Expression: function(node, scope) {
      infer(node, node.scope || scope, ANull);
    },

    FunctionDeclaration: function(node, scope, c) {
      var inner = node.scope, fn = inner.fnType;
      connectParams(node, inner)
      c(node.body, inner, "Statement");
      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);
      scope.getProp(node.id.name).addType(fn)
    },

    Statement: function(node, scope, c) {
      c(node, node.scope || scope)
    },

    VariableDeclaration: function(node, scope) {
      for (var i = 0; i < node.declarations.length; ++i) {
        var decl = node.declarations[i];
        if (decl.id.type == "Identifier") {
          var prop = scope.getProp(decl.id.name);
          if (decl.init)
            infer(decl.init, scope, prop, decl.id.name);
        } else if (decl.init) {
          connectPattern(decl.id, scope, infer(decl.init, scope))
        }
      }
    },

    ClassDeclaration: function(node, scope) {
      scope.getProp(node.id.name).addType(inferClass(node, scope, node.id.name))
    },

    ReturnStatement: function(node, scope) {
      if (!node.argument) return;
      var output = ANull, fn = functionScope(scope).fnType
      if (fn) {
        if (fn.retval == ANull) fn.retval = new AVal;
        output = fn.retval;
      }
      infer(node.argument, scope, output);
    },

    ForInStatement: function(node, scope, c) {
      var source = infer(node.right, scope);
      if ((node.right.type == "Identifier" && node.right.name in scope.props) ||
          (node.right.type == "MemberExpression" && node.right.property.name == "prototype")) {
        maybeInstantiate(scope, 5);
        var pattern = loopPattern(node.left)
        if (pattern.type == "Identifier") {
          if (pattern.name in scope.props)
            scope.getProp(pattern.name).iteratesOver = source
          source.getProp("<i>").propagate(ensureVar(pattern, scope))
        } else {
          connectPattern(pattern, scope, source.getProp("<i>"))
        }
      }
      c(node.body, scope, "Statement");
    },

    ForOfStatement: function(node, scope, c) {
      var pattern = loopPattern(node.left), target
      if (pattern.type == "Identifier")
        target = ensureVar(pattern, scope)
      else
        connectPattern(pattern, scope, target = new AVal)
      infer(node.right, scope, new HasMethodCall(":Symbol.iterator", [], null,
                                                 new HasMethodCall("next", [], null,
                                                                   new GetProp("value", target))))
      c(node.body, scope, "Statement")
    }
  });
  var parse = exports.parse = function(text, options, thirdArg) {
    if (!options || Array.isArray(options)) options = thirdArg
    var ast;
    try { ast = acorn.parse(text, options); }
    catch(e) { ast = acorn_loose.parse_dammit(text, options); }
    return ast;
  };
  exports.analyze = function(ast, name, scope) {
    if (typeof ast == "string") ast = parse(ast);

    if (!name) name = "file#" + cx.origins.length;
    exports.addOrigin(cx.curOrigin = name);

    if (!scope) scope = cx.topScope;
    cx.startAnalysis();

    walk.recursive(ast, scope, null, scopeGatherer);
    if (cx.parent) cx.parent.signal("preInfer", ast, scope)
    walk.recursive(ast, scope, null, inferWrapper);
    if (cx.parent) cx.parent.signal("postInfer", ast, scope)

    cx.curOrigin = null;
  };
  exports.purge = function(origins, start, end) {
    var test = makePredicate(origins, start, end);
    ++cx.purgeGen;
    cx.topScope.purge(test);
    for (var prop in cx.props) {
      var list = cx.props[prop];
      for (var i = 0; i < list.length; ++i) {
        var obj = list[i], av = obj.props[prop];
        if (!av || test(av, av.originNode)) list.splice(i--, 1);
      }
      if (!list.length) delete cx.props[prop];
    }
  };

  function makePredicate(origins, start, end) {
    var arr = Array.isArray(origins);
    if (arr && origins.length == 1) { origins = origins[0]; arr = false; }
    if (arr) {
      if (end == null) return function(n) { return origins.indexOf(n.origin) > -1; };
      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && origins.indexOf(n.origin) > -1; };
    } else {
      if (end == null) return function(n) { return n.origin == origins; };
      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && n.origin == origins; };
    }
  }

  AVal.prototype.purge = function(test) {
    if (this.purgeGen == cx.purgeGen) return;
    this.purgeGen = cx.purgeGen;
    for (var i = 0; i < this.types.length; ++i) {
      var type = this.types[i];
      if (test(type, type.originNode))
        this.types.splice(i--, 1);
      else
        type.purge(test);
    }
    if (!this.types.length) this.maxWeight = 0;

    if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
      var f = this.forward[i];
      if (test(f)) {
        this.forward.splice(i--, 1);
        if (this.props) this.props = null;
      } else if (f.purge) {
        f.purge(test);
      }
    }
  };
  ANull.purge = function() {};
  Obj.prototype.purge = function(test) {
    if (this.purgeGen == cx.purgeGen) return true;
    this.purgeGen = cx.purgeGen;
    for (var p in this.props) {
      var av = this.props[p];
      if (test(av, av.originNode))
        this.removeProp(p);
      av.purge(test);
    }
  };
  Fn.prototype.purge = function(test) {
    if (Obj.prototype.purge.call(this, test)) return;
    this.self.purge(test);
    this.retval.purge(test);
    for (var i = 0; i < this.args.length; ++i) this.args[i].purge(test);
  };
  function findByPropertyName(name) {
    guessing = true;
    var found = objsWithProp(name);
    if (found) for (var i = 0; i < found.length; ++i) {
      var val = found[i].getProp(name);
      if (!val.isEmpty()) return val;
    }
    return ANull;
  }

  function generatorResult(input, output) {
    var retObj = new Obj(true)
    retObj.defProp("done").addType(cx.bool)
    output.propagate(retObj.defProp("value"))
    var method = new Fn(null, ANull, input ? [input] : [], input ? ["?"] : [], retObj)
    var result = new Obj(cx.definitions.ecma6 && cx.definitions.ecma6.generator_prototype || true)
    result.defProp("next").addType(method)
    return result
  }

  function maybeIterator(fn, output) {
    if (!fn.generator) return output
    if (!fn.computeRet) { // Reuse iterator objects for non-computed return types
      if (fn.generator === true) fn.generator = generatorResult(fn.yieldval, output)
      return fn.generator
    }
    return generatorResult(fn.yieldval, output)
  }

  function computeReturnType(funcNode, argNodes, scope) {
    var fn = findType(funcNode, scope).getFunctionType()
    if (!fn) return ANull
    var result = fn.retval
    if (fn.computeRet) {
      for (var i = 0, args = []; i < argNodes.length; ++i)
        args.push(findType(argNodes[i], scope))
      var self = ANull
      if (funcNode.type == "MemberExpression")
        self = findType(funcNode.object, scope)
      result = fn.computeRet(self, args, argNodes);
    }
    return maybeIterator(fn, result)
  }

  var typeFinder = exports.typeFinder = {
    ArrayExpression: function(node, scope) {
      return arrayLiteralType(node.elements, scope, findType)
    },
    ObjectExpression: function(node) {
      return node.objType;
    },
    ClassExpression: function(node) {
      return node.objType;
    },
    FunctionExpression: function(node) {
      return node.scope.fnType;
    },
    ArrowFunctionExpression: function(node) {
      return node.scope.fnType;
    },
    SequenceExpression: function(node, scope) {
      return findType(node.expressions[node.expressions.length-1], scope);
    },
    UnaryExpression: function(node) {
      return unopResultType(node.operator);
    },
    UpdateExpression: function() {
      return cx.num;
    },
    BinaryExpression: function(node, scope) {
      if (binopIsBoolean(node.operator)) return cx.bool;
      if (node.operator == "+") {
        var lhs = findType(node.left, scope);
        var rhs = findType(node.right, scope);
        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
      }
      return cx.num;
    },
    AssignmentExpression: function(node, scope) {
      return findType(node.right, scope);
    },
    LogicalExpression: function(node, scope) {
      var lhs = findType(node.left, scope);
      return lhs.isEmpty() ? findType(node.right, scope) : lhs;
    },
    ConditionalExpression: function(node, scope) {
      var lhs = findType(node.consequent, scope);
      return lhs.isEmpty() ? findType(node.alternate, scope) : lhs;
    },
    NewExpression: function(node, scope) {
      var f = findType(node.callee, scope).getFunctionType();
      var proto = f && f.getProp("prototype").getObjType();
      if (!proto) return ANull;
      return getInstance(proto, f);
    },
    CallExpression: function(node, scope) {
      return computeReturnType(node.callee, node.arguments, scope)
    },
    MemberExpression: function(node, scope) {
      var propN = propName(node), obj = findType(node.object, scope).getType();
      if (obj) return obj.getProp(propN);
      if (propN == "<i>") return ANull;
      return findByPropertyName(propN);
    },
    Identifier: function(node, scope) {
      return scope.hasProp(node.name) || ANull;
    },
    ThisExpression: function(_node, scope) {
      return getThis(scope)
    },
    Literal: function(node) {
      return literalType(node);
    },
    Super: ret(function(node) {
      return node.superType
    }),
    TemplateLiteral: function() {
      return cx.str
    },
    TaggedTemplateExpression: function(node, scope) {
      return computeReturnType(node.tag, node.quasi.expressions, scope)
    },
    YieldExpression: function(_node, scope) {
      var fn = functionScope(scope).fnType
      return fn ? fn.yieldval : ANull
    }
  };

  function findType(node, scope) {
    var finder = typeFinder[node.type];
    return finder ? finder(node, scope) : ANull;
  }

  var searchVisitor = exports.searchVisitor = walk.make({
    Function: function(node, _st, c) {
      walk.base.Function(node, node.scope, c)
    },
    Property: function(node, st, c) {
      if (node.computed) c(node.key, st, "Expression");
      if (node.key != node.value) c(node.value, st, "Expression");
    },
    Statement: function(node, st, c) {
      c(node, node.scope || st)
    },
    ImportSpecifier: function(node, st, c) {
      c(node.local, st)
    },
    ImportDefaultSpecifier: function(node, st, c) {
      c(node.local, st)
    },
    ImportNamespaceSpecifier: function(node, st, c) {
      c(node.local, st)
    }
  });
  exports.fullVisitor = walk.make({
    MemberExpression: function(node, st, c) {
      c(node.object, st, "Expression");
      c(node.property, st, node.computed ? "Expression" : null);
    },
    ObjectExpression: function(node, st, c) {
      for (var i = 0; i < node.properties.length; ++i) {
        c(node.properties[i].value, st, "Expression");
        c(node.properties[i].key, st);
      }
    }
  }, searchVisitor);

  exports.findExpressionAt = function(ast, start, end, defaultScope, filter) {
    var test = filter || function(_t, node) {
      if (node.type == "Identifier" && node.name == "✖") return false;
      return typeFinder.hasOwnProperty(node.type);
    };
    return walk.findNodeAt(ast, start, end, test, searchVisitor, defaultScope || cx.topScope);
  };

  exports.findExpressionAround = function(ast, start, end, defaultScope, filter) {
    var test = filter || function(_t, node) {
      if (start != null && node.start > start) return false;
      if (node.type == "Identifier" && node.name == "✖") return false;
      return typeFinder.hasOwnProperty(node.type);
    };
    return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);
  };

  exports.expressionType = function(found) {
    return findType(found.node, found.state);
  };
  exports.parentNode = function(child, ast) {
    var stack = [];
    function c(node, st, override) {
      if (node.start <= child.start && node.end >= child.end) {
        var top = stack[stack.length - 1];
        if (node == child) throw {found: top};
        if (top != node) stack.push(node);
        walk.base[override || node.type](node, st, c);
        if (top != node) stack.pop();
      }
    }
    try {
      c(ast, null);
    } catch (e) {
      if (e.found) return e.found;
      throw e;
    }
  };

  var findTypeFromContext = exports.findTypeFromContext = {
    ArrayExpression: function(parent, _, get) { return get(parent, true).getProp("<i>"); },
    ObjectExpression: function(parent, node, get) {
      for (var i = 0; i < parent.properties.length; ++i) {
        var prop = node.properties[i];
        if (prop.value == node)
          return get(parent, true).getProp(prop.key.name);
      }
    },
    UnaryExpression: function(parent) { return unopResultType(parent.operator); },
    UpdateExpression: function() { return cx.num; },
    BinaryExpression: function(parent) { return binopIsBoolean(parent.operator) ? cx.bool : cx.num; },
    AssignmentExpression: function(parent, _, get) { return get(parent.left); },
    LogicalExpression: function(parent, _, get) { return get(parent, true); },
    ConditionalExpression: function(parent, node, get) {
      if (parent.consequent == node || parent.alternate == node) return get(parent, true);
    },
    CallExpression: function(parent, node, get) {
      for (var i = 0; i < parent.arguments.length; i++) {
        var arg = parent.arguments[i];
        if (arg == node) {
          var calleeType = get(parent.callee).getFunctionType();
          if (calleeType instanceof Fn)
            return calleeType.args[i];
          break;
        }
      }
    },
    ReturnStatement: function(_parent, node, get) {
      var fnNode = walk.findNodeAround(node.sourceFile.ast, node.start, "Function");
      if (fnNode) {
        var fnType = fnNode.node.type != "FunctionDeclaration"
          ? get(fnNode.node, true).getFunctionType()
          : fnNode.node.scope.fnType;
        if (fnType) return fnType.retval.getType();
      }
    },
    VariableDeclarator: function(parent, node, get) {
      if (parent.init == node) return get(parent.id)
    }
  };
  findTypeFromContext.NewExpression = findTypeFromContext.CallExpression

  exports.typeFromContext = function(ast, found) {
    var parent = exports.parentNode(found.node, ast);
    var type = null;
    if (findTypeFromContext.hasOwnProperty(parent.type)) {
      var finder = findTypeFromContext[parent.type];
      type = finder && finder(parent, found.node, function(node, fromContext) {
        var obj = {node: node, state: found.state};
        var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);
        return tp || ANull;
      });
    }
    return type || exports.expressionType(found);
  };
  var guessing = false;

  exports.resetGuessing = function(val) { guessing = val; };
  exports.didGuess = function() { return guessing; };

  exports.forAllPropertiesOf = function(type, f) {
    type.gatherProperties(f, 0);
  };

  var refFindWalker = walk.make({}, searchVisitor);

  exports.findRefs = function(ast, baseScope, name, refScope, f) {
    refFindWalker.Identifier = refFindWalker.VariablePattern = function(node, scope) {
      if (node.name != name) return;
      for (var s = scope; s; s = s.prev) {
        if (s == refScope) f(node, scope);
        if (name in s.props) return;
      }
    };
    walk.recursive(ast, baseScope, null, refFindWalker);
  };

  var simpleWalker = walk.make({
    Function: function(node, _scope, c) {
      c(node.body, node.scope, node.expression ? "Expression" : "Statement")
    },
    Statement: function(node, scope, c) {
      c(node, node.scope || scope)
    }
  });

  exports.findPropRefs = function(ast, scope, objType, propName, f) {
    walk.simple(ast, {
      MemberExpression: function(node, scope) {
        if (node.computed || node.property.name != propName) return;
        if (findType(node.object, scope).getType() == objType) f(node.property);
      },
      ObjectExpression: function(node, scope) {
        if (findType(node, scope).getType() != objType) return;
        for (var i = 0; i < node.properties.length; ++i)
          if (node.properties[i].key.name == propName) f(node.properties[i].key);
      }
    }, simpleWalker, scope);
  };
  var scopeAt = exports.scopeAt = function(ast, pos, defaultScope) {
    var found = walk.findNodeAround(ast, pos, function(_, node) {
      return node.scope;
    });
    if (found) return found.node.scope;
    else return defaultScope || cx.topScope;
  };

  exports.forAllLocalsAt = function(ast, pos, defaultScope, f) {
    var scope = scopeAt(ast, pos, defaultScope);
    scope.gatherProperties(f, 0);
  };
  def = exports.def = def.init({}, exports);
});

});

define("tern/lib/tern",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports, require("./infer"), require("./signal"),
               require("acorn"), require("acorn/dist/walk"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports", "./infer", "./signal", "acorn/dist/acorn", "acorn/dist/walk"], mod);
  mod(root.tern || (root.tern = {}), tern, tern.signal, acorn, acorn.walk); // Plain browser env
})(this, function(exports, infer, signal, acorn, walk) {
  "use strict";

  var plugins = Object.create(null);
  exports.registerPlugin = function(name, init) { plugins[name] = init; };

  var defaultOptions = exports.defaultOptions = {
    debug: false,
    async: false,
    getFile: function(_f, c) { if (this.async) c(null, null); },
    normalizeFilename: function(name) { return name },
    defs: [],
    plugins: {},
    fetchTimeout: 1000,
    dependencyBudget: 20000,
    reuseInstances: true,
    stripCRs: false,
    ecmaVersion: 6,
    projectDir: "/",
    parent: null
  };

  var queryTypes = {
    completions: {
      takesFile: true,
      run: findCompletions
    },
    properties: {
      run: findProperties
    },
    type: {
      takesFile: true,
      run: findTypeAt
    },
    documentation: {
      takesFile: true,
      run: findDocs
    },
    definition: {
      takesFile: true,
      run: findDef
    },
    refs: {
      takesFile: true,
      fullFile: true,
      run: findRefs
    },
    rename: {
      takesFile: true,
      fullFile: true,
      run: buildRename
    },
    files: {
      run: listFiles
    }
  };

  exports.defineQueryType = function(name, desc) { queryTypes[name] = desc; };

  function File(name, parent) {
    this.name = name;
    this.parent = parent;
    this.scope = this.text = this.ast = this.lineOffsets = null;
  }
  File.prototype.asLineChar = function(pos) { return asLineChar(this, pos); };
  
  exports.File = File;

  function parseFile(srv, file) {
    var options = {
      directSourceFile: file,
      allowReturnOutsideFunction: true,
      allowImportExportEverywhere: true,
      ecmaVersion: srv.options.ecmaVersion
    }
    var text = srv.signalReturnFirst("preParse", file.text, options) || file.text
    var ast = infer.parse(text, options)
    srv.signal("postParse", ast, text)
    return ast
  }

  function updateText(file, text, srv) {
    file.text = srv.options.stripCRs ? text.replace(/\r\n/g, "\n") : text;
    infer.withContext(srv.cx, function() {
      file.ast = parseFile(srv, file)
    });
    file.lineOffsets = null;
  }

  var Server = exports.Server = function(options) {
    this.cx = null;
    this.options = options || {};
    for (var o in defaultOptions) if (!options.hasOwnProperty(o))
      options[o] = defaultOptions[o];

    this.projectDir = options.projectDir.replace(/\\/g, "/")
    if (!/\/$/.test(this.projectDir)) this.projectDir += "/"

    this.parent = options.parent;
    this.handlers = Object.create(null);
    this.files = [];
    this.fileMap = Object.create(null);
    this.needsPurge = [];
    this.budgets = Object.create(null);
    this.uses = 0;
    this.pending = 0;
    this.asyncError = null;
    this.mod = {}

    this.defs = options.defs.slice(0)
    this.plugins = Object.create(null)
    for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))
      this.loadPlugin(plugin, options.plugins[plugin])

    this.reset();
  };
  Server.prototype = signal.mixin({
    addFile: function(name, /*optional*/ text, parent) {
      if (parent && !(parent in this.fileMap)) parent = null;
      if (!(name in this.fileMap))
        name = this.normalizeFilename(name)
      ensureFile(this, name, parent, text);
    },
    delFile: function(name) {
      var file = this.findFile(name);
      if (file) {
        this.needsPurge.push(file.name);
        this.files.splice(this.files.indexOf(file), 1);
        delete this.fileMap[name];
      }
    },
    reset: function() {
      this.signal("reset");
      this.cx = new infer.Context(this.defs, this);
      this.uses = 0;
      this.budgets = Object.create(null);
      for (var i = 0; i < this.files.length; ++i) {
        var file = this.files[i];
        file.scope = null;
      }
      this.signal("postReset");
    },

    request: function(doc, c) {
      var inv = invalidDoc(doc);
      if (inv) return c(inv);

      var self = this;
      doRequest(this, doc, function(err, data) {
        c(err, data);
        if (self.uses > 40) {
          self.reset();
          analyzeAll(self, null, function(){});
        }
      });
    },

    findFile: function(name) {
      return this.fileMap[name];
    },

    flush: function(c) {
      var cx = this.cx;
      analyzeAll(this, null, function(err) {
        if (err) return c(err);
        infer.withContext(cx, c);
      });
    },

    startAsyncAction: function() {
      ++this.pending;
    },
    finishAsyncAction: function(err) {
      if (err) this.asyncError = err;
      if (--this.pending === 0) this.signal("everythingFetched");
    },

    addDefs: function(defs, toFront) {
      if (toFront) this.defs.unshift(defs)
      else this.defs.push(defs)

      if (this.cx) this.reset()
    },

    deleteDefs: function(name) {
      for (var i = 0; i < this.defs.length; i++) if (this.defs[i]["!name"] == name) {
        this.defs.splice(i, 1);
        if (this.cx) this.reset();
        return;
      }
    },

    loadPlugin: function(name, options) {
      if (arguments.length == 1) options = this.options.plugins[name] || true
      if (name in this.plugins || !(name in plugins) || !options) return
      this.plugins[name] = true
      var init = plugins[name](this, options)
      if (!init) return
      if (init.defs) this.addDefs(init.defs, init.loadFirst)
      if (init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))
        this.on(type, init.passes[type])
    },

    normalizeFilename: function(name) {
      var norm = this.options.normalizeFilename(name).replace(/\\/g, "/")
      if (norm.indexOf(this.projectDir) == 0) norm = norm.slice(this.projectDir.length)
      return norm
    }
  });

  function doRequest(srv, doc, c) {
    if (doc.query && !queryTypes.hasOwnProperty(doc.query.type))
      return c("No query type '" + doc.query.type + "' defined");

    var query = doc.query;
    if (!query) c(null, {});

    var files = doc.files || [];
    if (files.length) ++srv.uses;
    for (var i = 0; i < files.length; ++i) {
      var file = files[i];
      if (file.type == "delete")
        srv.delFile(file.name);
      else
        ensureFile(srv, file.name, null, file.type == "full" ? file.text : null);
    }

    var timeBudget = typeof doc.timeout == "number" ? [doc.timeout] : null;
    if (!query) {
      analyzeAll(srv, timeBudget, function(){});
      return;
    }

    var queryType = queryTypes[query.type];
    if (queryType.takesFile) {
      if (typeof query.file != "string") return c(".query.file must be a string");
      if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);
    }

    analyzeAll(srv, timeBudget, function(err) {
      if (err) return c(err);
      var file = queryType.takesFile && resolveFile(srv, files, query.file);
      if (queryType.fullFile && file.type == "part")
        return c("Can't run a " + query.type + " query on a file fragment");

      function run() {
        var result;
        try {
          result = queryType.run(srv, query, file);
        } catch (e) {
          if (srv.options.debug && e.name != "TernError") console.error(e.stack);
          return c(e);
        }
        c(null, result);
      }
      infer.resetGuessing()
      infer.withContext(srv.cx, timeBudget ? function() { infer.withTimeout(timeBudget[0], run); } : run);
    });
  }

  function analyzeFile(srv, file) {
    infer.withContext(srv.cx, function() {
      file.scope = srv.cx.topScope;
      srv.signal("beforeLoad", file);
      infer.analyze(file.ast, file.name, file.scope);
      srv.signal("afterLoad", file);
    });
    return file;
  }

  function ensureFile(srv, name, parent, text) {
    var known = srv.findFile(name);
    if (known) {
      if (text != null) {
        if (known.scope) {
          srv.needsPurge.push(name);
          known.scope = null;
        }
        updateText(known, text, srv);
      }
      if (parentDepth(srv, known.parent) > parentDepth(srv, parent)) {
        known.parent = parent;
        if (known.excluded) known.excluded = null;
      }
      return;
    }

    var file = new File(name, parent);
    srv.files.push(file);
    srv.fileMap[name] = file;
    if (text != null) {
      updateText(file, text, srv);
    } else if (srv.options.async) {
      srv.startAsyncAction();
      srv.options.getFile(name, function(err, text) {
        updateText(file, text || "", srv);
        srv.finishAsyncAction(err);
      });
    } else {
      updateText(file, srv.options.getFile(name) || "", srv);
    }
  }

  function fetchAll(srv, c) {
    var done = true, returned = false;
    srv.files.forEach(function(file) {
      if (file.text != null) return;
      if (srv.options.async) {
        done = false;
        srv.options.getFile(file.name, function(err, text) {
          if (err && !returned) { returned = true; return c(err); }
          updateText(file, text || "", srv);
          fetchAll(srv, c);
        });
      } else {
        try {
          updateText(file, srv.options.getFile(file.name) || "", srv);
        } catch (e) { return c(e); }
      }
    });
    if (done) c();
  }

  function waitOnFetch(srv, timeBudget, c) {
    var done = function() {
      srv.off("everythingFetched", done);
      clearTimeout(timeout);
      analyzeAll(srv, timeBudget, c);
    };
    srv.on("everythingFetched", done);
    var timeout = setTimeout(done, srv.options.fetchTimeout);
  }

  function analyzeAll(srv, timeBudget, c) {
    if (srv.pending) return waitOnFetch(srv, timeBudget, c);

    var e = srv.fetchError;
    if (e) { srv.fetchError = null; return c(e); }

    if (srv.needsPurge.length > 0) infer.withContext(srv.cx, function() {
      infer.purge(srv.needsPurge);
      srv.needsPurge.length = 0;
    });

    var done = true;
    for (var i = 0; i < srv.files.length;) {
      var toAnalyze = [];
      for (; i < srv.files.length; ++i) {
        var file = srv.files[i];
        if (file.text == null) done = false;
        else if (file.scope == null && !file.excluded) toAnalyze.push(file);
      }
      toAnalyze.sort(function(a, b) {
        return parentDepth(srv, a.parent) - parentDepth(srv, b.parent);
      });
      for (var j = 0; j < toAnalyze.length; j++) {
        var file = toAnalyze[j];
        if (file.parent && !chargeOnBudget(srv, file)) {
          file.excluded = true;
        } else if (timeBudget) {
          var startTime = +new Date;
          infer.withTimeout(timeBudget[0], function() { analyzeFile(srv, file); });
          timeBudget[0] -= +new Date - startTime;
        } else {
          analyzeFile(srv, file);
        }
      }
    }
    if (done) c();
    else waitOnFetch(srv, timeBudget, c);
  }

  function firstLine(str) {
    var end = str.indexOf("\n");
    if (end < 0) return str;
    return str.slice(0, end);
  }

  function findMatchingPosition(line, file, near) {
    var pos = Math.max(0, near - 500), closest = null;
    if (!/^\s*$/.test(line)) for (;;) {
      var found = file.indexOf(line, pos);
      if (found < 0 || found > near + 500) break;
      if (closest == null || Math.abs(closest - near) > Math.abs(found - near))
        closest = found;
      pos = found + line.length;
    }
    return closest;
  }

  function scopeDepth(s) {
    for (var i = 0; s; ++i, s = s.prev) {}
    return i;
  }

  function ternError(msg) {
    var err = new Error(msg);
    err.name = "TernError";
    return err;
  }

  function resolveFile(srv, localFiles, name) {
    var isRef = name.match(/^#(\d+)$/);
    if (!isRef) return srv.findFile(name);

    var file = localFiles[isRef[1]];
    if (!file || file.type == "delete") throw ternError("Reference to unknown file " + name);
    if (file.type == "full") return srv.findFile(file.name);
    var realFile = file.backing = srv.findFile(file.name);
    var offset = file.offset;
    if (file.offsetLines) offset = {line: file.offsetLines, ch: 0};
    file.offset = offset = resolvePos(realFile, file.offsetLines == null ? file.offset : {line: file.offsetLines, ch: 0}, true);
    var line = firstLine(file.text);
    var foundPos = findMatchingPosition(line, realFile.text, offset);
    var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf("\n", offset)) : foundPos;
    var inObject, atFunction;

    infer.withContext(srv.cx, function() {
      infer.purge(file.name, pos, pos + file.text.length);

      var text = file.text, m;
      if (m = text.match(/(?:"([^"]*)"|([\w$]+))\s*:\s*function\b/)) {
        var objNode = walk.findNodeAround(file.backing.ast, pos, "ObjectExpression");
        if (objNode && objNode.node.objType)
          inObject = {type: objNode.node.objType, prop: m[2] || m[1]};
      }
      if (foundPos && (m = line.match(/^(.*?)\bfunction\b/))) {
        var cut = m[1].length, white = "";
        for (var i = 0; i < cut; ++i) white += " ";
        file.text = white + text.slice(cut);
        atFunction = true;
      }

      var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);
      var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);
      var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;
      file.ast = parseFile(srv, file)
      infer.analyze(file.ast, file.name, scope);
      tieTogether: if (inObject || atFunction) {
        var newInner = infer.scopeAt(file.ast, line.length, scopeStart);
        if (!newInner.fnType) break tieTogether;
        if (inObject) {
          var prop = inObject.type.getProp(inObject.prop);
          prop.addType(newInner.fnType);
        } else if (atFunction) {
          var inner = infer.scopeAt(realFile.ast, pos + line.length, realFile.scope);
          if (inner == scopeStart || !inner.fnType) break tieTogether;
          var fOld = inner.fnType, fNew = newInner.fnType;
          if (!fNew || (fNew.name != fOld.name && fOld.name)) break tieTogether;
          for (var i = 0, e = Math.min(fOld.args.length, fNew.args.length); i < e; ++i)
            fOld.args[i].propagate(fNew.args[i]);
          fOld.self.propagate(fNew.self);
          fNew.retval.propagate(fOld.retval);
        }
      }
    });
    return file;
  }
  function astSize(node) {
    var size = 0;
    walk.simple(node, {Expression: function() { ++size; }});
    return size;
  }

  function parentDepth(srv, parent) {
    var depth = 0;
    while (parent) {
      ++depth;
      var file = srv.findFile(parent);
      if (!file)
        return;
      parent = file.parent;
    }
    return depth;
  }

  function budgetName(srv, file) {
    for (;;) {
      var parent = srv.findFile(file.parent);
      if (!parent || !parent.parent) break;
      file = parent;
    }
    return file.name;
  }

  function chargeOnBudget(srv, file) {
    var bName = budgetName(srv, file);
    var size = astSize(file.ast);
    var known = srv.budgets[bName];
    if (known == null)
      known = srv.budgets[bName] = srv.options.dependencyBudget;
    if (known < size) return false;
    srv.budgets[bName] = known - size;
    return true;
  }
  function isPosition(val) {
    return typeof val == "number" || typeof val == "object" &&
      typeof val.line == "number" && typeof val.ch == "number";
  }
  function invalidDoc(doc) {
    if (doc.query) {
      if (typeof doc.query.type != "string") return ".query.type must be a string";
      if (doc.query.start && !isPosition(doc.query.start)) return ".query.start must be a position";
      if (doc.query.end && !isPosition(doc.query.end)) return ".query.end must be a position";
    }
    if (doc.files) {
      if (!Array.isArray(doc.files)) return "Files property must be an array";
      for (var i = 0; i < doc.files.length; ++i) {
        var file = doc.files[i];
        if (typeof file != "object") return ".files[n] must be objects";
        else if (typeof file.name != "string") return ".files[n].name must be a string";
        else if (file.type == "delete") continue;
        else if (typeof file.text != "string") return ".files[n].text must be a string";
        else if (file.type == "part") {
          if (!isPosition(file.offset) && typeof file.offsetLines != "number")
            return ".files[n].offset must be a position";
        } else if (file.type != "full") return ".files[n].type must be \"full\" or \"part\"";
      }
    }
  }

  var offsetSkipLines = 25;

  function findLineStart(file, line) {
    var text = file.text, offsets = file.lineOffsets || (file.lineOffsets = [0]);
    var pos = 0, curLine = 0;
    var storePos = Math.min(Math.floor(line / offsetSkipLines), offsets.length - 1);
    var pos = offsets[storePos], curLine = storePos * offsetSkipLines;

    while (curLine < line) {
      ++curLine;
      pos = text.indexOf("\n", pos) + 1;
      if (pos === 0) return null;
      if (curLine % offsetSkipLines === 0) offsets.push(pos);
    }
    return pos;
  }

  var resolvePos = exports.resolvePos = function(file, pos, tolerant) {
    if (typeof pos != "number") {
      var lineStart = findLineStart(file, pos.line);
      if (lineStart == null) {
        if (tolerant) pos = file.text.length;
        else throw ternError("File doesn't contain a line " + pos.line);
      } else {
        pos = lineStart + pos.ch;
      }
    }
    if (pos > file.text.length) {
      if (tolerant) pos = file.text.length;
      else throw ternError("Position " + pos + " is outside of file.");
    }
    return pos;
  };

  function asLineChar(file, pos) {
    if (!file) return {line: 0, ch: 0};
    var offsets = file.lineOffsets || (file.lineOffsets = [0]);
    var text = file.text, line, lineStart;
    for (var i = offsets.length - 1; i >= 0; --i) if (offsets[i] <= pos) {
      line = i * offsetSkipLines;
      lineStart = offsets[i];
    }
    for (;;) {
      var eol = text.indexOf("\n", lineStart);
      if (eol >= pos || eol < 0) break;
      lineStart = eol + 1;
      ++line;
    }
    return {line: line, ch: pos - lineStart};
  }

  var outputPos = exports.outputPos = function(query, file, pos) {
    if (query.lineCharPositions) {
      var out = asLineChar(file, pos);
      if (file.type == "part")
        out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;
      return out;
    } else {
      return pos + (file.type == "part" ? file.offset : 0);
    }
  };
  function clean(obj) {
    for (var prop in obj) if (obj[prop] == null) delete obj[prop];
    return obj;
  }
  function maybeSet(obj, prop, val) {
    if (val != null) obj[prop] = val;
  }
  function compareCompletions(a, b) {
    if (typeof a != "string") { a = a.name; b = b.name; }
    var aUp = /^[A-Z]/.test(a), bUp = /^[A-Z]/.test(b);
    if (aUp == bUp) return a < b ? -1 : a == b ? 0 : 1;
    else return aUp ? 1 : -1;
  }

  function isStringAround(node, start, end) {
    return node.type == "Literal" && typeof node.value == "string" &&
      node.start == start - 1 && node.end <= end + 1;
  }

  function pointInProp(objNode, point) {
    for (var i = 0; i < objNode.properties.length; i++) {
      var curProp = objNode.properties[i];
      if (curProp.key.start <= point && curProp.key.end >= point)
        return curProp;
    }
  }

  var jsKeywords = ("break do instanceof typeof case else new var " +
    "catch finally return void continue for switch while debugger " +
    "function this with default if throw delete in try").split(" ");

  var addCompletion = exports.addCompletion = function(query, completions, name, aval, depth) {
    var typeInfo = query.types || query.docs || query.urls || query.origins;
    var wrapAsObjs = typeInfo || query.depths;

    for (var i = 0; i < completions.length; ++i) {
      var c = completions[i];
      if ((wrapAsObjs ? c.name : c) == name) return;
    }
    var rec = wrapAsObjs ? {name: name} : name;
    completions.push(rec);

    if (aval && typeInfo) {
      infer.resetGuessing();
      var type = aval.getType(false);
      rec.guess = infer.didGuess();
      if (query.types)
        rec.type = infer.toString(aval);
      if (query.docs)
        maybeSet(rec, "doc", parseDoc(query, aval.doc || type && type.doc));
      if (query.urls)
        maybeSet(rec, "url", aval.url || type && type.url);
      if (query.origins)
        maybeSet(rec, "origin", aval.origin || type && type.origin);
    }
    if (query.depths) rec.depth = depth || 0;
    return rec;
  };

  function findCompletions(srv, query, file) {
    if (query.end == null) throw ternError("missing .query.end field");
    var fromPlugin = srv.signalReturnFirst("completion", file, query)
    if (fromPlugin) return fromPlugin

    var wordStart = resolvePos(file, query.end), wordEnd = wordStart, text = file.text;
    while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;
    if (query.expandWordForward !== false)
      while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;
    var word = text.slice(wordStart, wordEnd), completions = [], ignoreObj;
    if (query.caseInsensitive) word = word.toLowerCase();

    function gather(prop, obj, depth, addInfo) {
      if ((objLit || query.omitObjectPrototype !== false) && obj == srv.cx.protos.Object && !word) return;
      if (query.filter !== false && word &&
          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return;
      if (ignoreObj && ignoreObj.props[prop]) return;
      var result = addCompletion(query, completions, prop, obj && obj.props[prop], depth);
      if (addInfo && result && typeof result != "string") addInfo(result);
    }

    var hookname, prop, objType, isKey;

    var exprAt = infer.findExpressionAround(file.ast, null, wordStart, file.scope);
    var memberExpr, objLit;
    if (exprAt) {
      var exprNode = exprAt.node;
      if (exprNode.type == "MemberExpression" && exprNode.object.end < wordStart) {
        memberExpr = exprAt;
      } else if (isStringAround(exprNode, wordStart, wordEnd)) {
        var parent = infer.parentNode(exprNode, file.ast);
        if (parent.type == "MemberExpression" && parent.property == exprNode)
          memberExpr = {node: parent, state: exprAt.state};
      } else if (exprNode.type == "ObjectExpression") {
        var objProp = pointInProp(exprNode, wordEnd);
        if (objProp) {
          objLit = exprAt;
          prop = isKey = objProp.key.name;
        } else if (!word && !/:\s*$/.test(file.text.slice(0, wordStart))) {
          objLit = exprAt;
          prop = isKey = true;
        }
      }
    }

    if (objLit) {
      objType = infer.typeFromContext(file.ast, objLit);
      ignoreObj = objLit.node.objType;
    } else if (memberExpr) {
      prop = memberExpr.node.property;
      prop = prop.type == "Literal" ? prop.value.slice(1) : prop.name;
      memberExpr.node = memberExpr.node.object;
      objType = infer.expressionType(memberExpr);
    } else if (text.charAt(wordStart - 1) == ".") {
      var pathStart = wordStart - 1;
      while (pathStart && (text.charAt(pathStart - 1) == "." || acorn.isIdentifierChar(text.charCodeAt(pathStart - 1)))) pathStart--;
      var path = text.slice(pathStart, wordStart - 1);
      if (path) {
        objType = infer.def.parsePath(path, file.scope).getObjType();
        prop = word;
      }
    }

    if (prop != null) {
      srv.cx.completingProperty = prop;

      if (objType) infer.forAllPropertiesOf(objType, gather);

      if (!completions.length && query.guess !== false && objType && objType.guessProperties)
        objType.guessProperties(function(p, o, d, a) {if (p != prop && p != "✖") gather(p, o, d, a);});
      if (!completions.length && word.length >= 2 && query.guess !== false)
        for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0, function(rec) { rec.guess = true; });
      hookname = "memberCompletion";
    } else {
      infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);
      if (query.includeKeywords) jsKeywords.forEach(function(kw) {
        gather(kw, null, 0, function(rec) { rec.isKeyword = true; });
      });
      hookname = "variableCompletion";
    }
    srv.signal(hookname, file, wordStart, wordEnd, gather)

    if (query.sort !== false) completions.sort(compareCompletions);
    srv.cx.completingProperty = null;

    return {start: outputPos(query, file, wordStart),
            end: outputPos(query, file, wordEnd),
            isProperty: !!prop,
            isObjectKey: !!isKey,
            completions: completions};
  }

  function findProperties(srv, query) {
    var prefix = query.prefix, found = [];
    for (var prop in srv.cx.props)
      if (prop != "<i>" && (!prefix || prop.indexOf(prefix) === 0)) found.push(prop);
    if (query.sort !== false) found.sort(compareCompletions);
    return {completions: found};
  }

  var findExpr = exports.findQueryExpr = function(file, query, wide) {
    if (query.end == null) throw ternError("missing .query.end field");

    if (query.variable) {
      var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);
      return {node: {type: "Identifier", name: query.variable, start: query.end, end: query.end + 1},
              state: scope};
    } else {
      var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);
      var expr = infer.findExpressionAt(file.ast, start, end, file.scope);
      if (expr) return expr;
      expr = infer.findExpressionAround(file.ast, start, end, file.scope);
      if (expr && (expr.node.type == "ObjectExpression" || wide ||
                   (start == null ? end : start) - expr.node.start < 20 || expr.node.end - end < 20))
        return expr;
      return null;
    }
  };

  function findExprOrThrow(file, query, wide) {
    var expr = findExpr(file, query, wide);
    if (expr) return expr;
    throw ternError("No expression at the given position.");
  }

  function ensureObj(tp) {
    if (!tp || !(tp = tp.getType()) || !(tp instanceof infer.Obj)) return null;
    return tp;
  }

  function findExprType(srv, query, file, expr) {
    var type;
    if (expr) {
      infer.resetGuessing();
      type = infer.expressionType(expr);
    }
    var typeHandlers = srv.hasHandler("typeAt")
    if (typeHandlers) {
      var pos = resolvePos(file, query.end)
      for (var i = 0; i < typeHandlers.length; i++)
        type = typeHandlers[i](file, pos, expr, type)
    }
    if (!type) throw ternError("No type found at the given position.");

    var objProp;
    if (expr.node.type == "ObjectExpression" && query.end != null &&
        (objProp = pointInProp(expr.node, resolvePos(file, query.end)))) {
      var name = objProp.key.name;
      var fromCx = ensureObj(infer.typeFromContext(file.ast, expr));
      if (fromCx && fromCx.hasProp(name)) {
        type = fromCx.hasProp(name);
      } else {
        var fromLocal = ensureObj(type);
        if (fromLocal && fromLocal.hasProp(name))
          type = fromLocal.hasProp(name);
      }
    }
    return type;
  };

  function findTypeAt(srv, query, file) {
    var expr = findExpr(file, query), exprName;
    var type = findExprType(srv, query, file, expr), exprType = type;
    if (query.preferFunction)
      type = type.getFunctionType() || type.getType(query.guess === true);
    else
      type = type.getType(query.guess === true);

    if (expr) {
      if (expr.node.type == "Identifier")
        exprName = expr.node.name;
      else if (expr.node.type == "MemberExpression" && !expr.node.computed)
        exprName = expr.node.property.name;
    }

    if (query.depth != null && typeof query.depth != "number")
      throw ternError(".query.depth must be a number");

    var result = {guess: infer.didGuess(),
                  type: infer.toString(exprType, query.depth),
                  name: type && type.name,
                  exprName: exprName,
                  doc: exprType.doc,
                  url: exprType.url};
    if (type) storeTypeDocs(query, type, result);

    return clean(result);
  }

  function parseDoc(query, doc) {
    if (!doc) return null;
 return doc;
    var parabreak = /.\n[\s@\n]/.exec(doc);
    if (parabreak) doc = doc.slice(0, parabreak.index + 1);
    doc = doc.replace(/\n\s*/g, " ");
    if (doc.length < 100) return doc;
    var sentenceEnd = /[\.!?] [A-Z]/g;
    sentenceEnd.lastIndex = 80;
    var found = sentenceEnd.exec(doc);
    if (found) doc = doc.slice(0, found.index + 1);
    return doc;
  }

  function findDocs(srv, query, file) {
    var expr = findExpr(file, query);
    var type = findExprType(srv, query, file, expr);
    var result = {url: type.url, doc: parseDoc(query, type.doc), type: infer.toString(type)};
    var inner = type.getType();
    if (inner) storeTypeDocs(query, inner, result);
    return clean(result);
  }

  function storeTypeDocs(query, type, out) {
    if (!out.url) out.url = type.url;
    if (!out.doc) out.doc = parseDoc(query, type.doc);
    if (!out.origin) out.origin = type.origin;
    var ctor, boring = infer.cx().protos;
    if (!out.url && !out.doc && type.proto && (ctor = type.proto.hasCtor) &&
        type.proto != boring.Object && type.proto != boring.Function && type.proto != boring.Array) {
      out.url = ctor.url;
      out.doc = parseDoc(query, ctor.doc);
    }
  }

  var getSpan = exports.getSpan = function(obj) {
    if (!obj.origin) return;
    if (obj.originNode) {
      var node = obj.originNode;
      if (/^Function/.test(node.type) && node.id) node = node.id;
      return {origin: obj.origin, node: node};
    }
    if (obj.span) return {origin: obj.origin, span: obj.span};
  };

  var storeSpan = exports.storeSpan = function(srv, query, span, target) {
    target.origin = span.origin;
    if (span.span) {
      var m = /^(\d+)\[(\d+):(\d+)\]-(\d+)\[(\d+):(\d+)\]$/.exec(span.span);
      target.start = query.lineCharPositions ? {line: Number(m[2]), ch: Number(m[3])} : Number(m[1]);
      target.end = query.lineCharPositions ? {line: Number(m[5]), ch: Number(m[6])} : Number(m[4]);
    } else {
      var file = srv.findFile(span.origin);
      target.start = outputPos(query, file, span.node.start);
      target.end = outputPos(query, file, span.node.end);
    }
  };

  function findDef(srv, query, file) {
    var expr = findExpr(file, query);
    var type = findExprType(srv, query, file, expr);
    if (infer.didGuess()) return {};

    var span = getSpan(type);
    var result = {url: type.url, doc: parseDoc(query, type.doc), origin: type.origin};

    if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {
      var tp = type.types[i];
      storeTypeDocs(query, tp, result);
      if (!span) span = getSpan(tp);
    }

    if (span && span.node) { // refers to a loaded file
      var spanFile = span.node.sourceFile || srv.findFile(span.origin);
      var start = outputPos(query, spanFile, span.node.start), end = outputPos(query, spanFile, span.node.end);
      result.start = start; result.end = end;
      result.file = span.origin;
      var cxStart = Math.max(0, span.node.start - 50);
      result.contextOffset = span.node.start - cxStart;
      result.context = spanFile.text.slice(cxStart, cxStart + 50);
    } else if (span) { // external
      result.file = span.origin;
      storeSpan(srv, query, span, result);
    }
    return clean(result);
  }

  function findRefsToVariable(srv, query, file, expr, checkShadowing) {
    var name = expr.node.name;

    for (var scope = expr.state; scope && !(name in scope.props); scope = scope.prev) {}
    if (!scope) throw ternError("Could not find a definition for " + name);

    var type, refs = [];
    function storeRef(file) {
      return function(node, scopeHere) {
        if (checkShadowing) for (var s = scopeHere; s != scope; s = s.prev) {
          var exists = s.hasProp(checkShadowing);
          if (exists)
            throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would make a variable at line " +
                            (asLineChar(file, node.start).line + 1) + " point to the definition at line " +
                            (asLineChar(file, exists.name.start).line + 1));
        }
        refs.push({file: file.name,
                   start: outputPos(query, file, node.start),
                   end: outputPos(query, file, node.end)});
      };
    }

    if (scope.originNode) {
      type = "local";
      if (checkShadowing) {
        for (var prev = scope.prev; prev; prev = prev.prev)
          if (checkShadowing in prev.props) break;
        if (prev) infer.findRefs(scope.originNode, scope, checkShadowing, prev, function(node) {
          throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would shadow the definition used at line " +
                          (asLineChar(file, node.start).line + 1));
        });
      }
      infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));
    } else {
      type = "global";
      for (var i = 0; i < srv.files.length; ++i) {
        var cur = srv.files[i];
        infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));
      }
    }

    return {refs: refs, type: type, name: name};
  }

  function findRefsToProperty(srv, query, expr, prop) {
    var objType = infer.expressionType(expr).getObjType();
    if (!objType) throw ternError("Couldn't determine type of base object.");

    var refs = [];
    function storeRef(file) {
      return function(node) {
        refs.push({file: file.name,
                   start: outputPos(query, file, node.start),
                   end: outputPos(query, file, node.end)});
      };
    }
    for (var i = 0; i < srv.files.length; ++i) {
      var cur = srv.files[i];
      infer.findPropRefs(cur.ast, cur.scope, objType, prop.name, storeRef(cur));
    }

    return {refs: refs, name: prop.name};
  }

  function findRefs(srv, query, file) {
    var expr = findExprOrThrow(file, query, true);
    if (expr && expr.node.type == "Identifier") {
      return findRefsToVariable(srv, query, file, expr);
    } else if (expr && expr.node.type == "MemberExpression" && !expr.node.computed) {
      var p = expr.node.property;
      expr.node = expr.node.object;
      return findRefsToProperty(srv, query, expr, p);
    } else if (expr && expr.node.type == "ObjectExpression") {
      var pos = resolvePos(file, query.end);
      for (var i = 0; i < expr.node.properties.length; ++i) {
        var k = expr.node.properties[i].key;
        if (k.start <= pos && k.end >= pos)
          return findRefsToProperty(srv, query, expr, k);
      }
    }
    throw ternError("Not at a variable or property name.");
  }

  function buildRename(srv, query, file) {
    if (typeof query.newName != "string") throw ternError(".query.newName should be a string");
    var expr = findExprOrThrow(file, query);
    if (!expr || expr.node.type != "Identifier") throw ternError("Not at a variable.");

    var data = findRefsToVariable(srv, query, file, expr, query.newName), refs = data.refs;
    delete data.refs;
    data.files = srv.files.map(function(f){return f.name;});

    var changes = data.changes = [];
    for (var i = 0; i < refs.length; ++i) {
      var use = refs[i];
      use.text = query.newName;
      changes.push(use);
    }

    return data;
  }

  function listFiles(srv) {
    return {files: srv.files.map(function(f){return f.name;})};
  }

  exports.version = "0.16.1";
});

});

define("tern/lib/comment",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports);
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports"], mod);
  mod(tern.comment || (tern.comment = {}));
})(function(exports) {
  function isSpace(ch) {
    return (ch < 14 && ch > 8) || ch === 32 || ch === 160;
  }

  function onOwnLine(text, pos) {
    for (; pos > 0; --pos) {
      var ch = text.charCodeAt(pos - 1);
      if (ch == 10) break;
      if (!isSpace(ch)) return false;
    }
    return true;
  }
  exports.commentsBefore = function(text, pos) {
    var found = null, emptyLines = 0, topIsLineComment;
    out: while (pos > 0) {
      var prev = text.charCodeAt(pos - 1);
      if (prev == 10) {
        for (var scan = --pos, sawNonWS = false; scan > 0; --scan) {
          prev = text.charCodeAt(scan - 1);
          if (prev == 47 && text.charCodeAt(scan - 2) == 47) {
            if (!onOwnLine(text, scan - 2)) break out;
            var content = text.slice(scan, pos);
            if (!emptyLines && topIsLineComment) found[0] = content + "\n" + found[0];
            else (found || (found = [])).unshift(content);
            topIsLineComment = true;
            emptyLines = 0;
            pos = scan - 2;
            break;
          } else if (prev == 10) {
            if (!sawNonWS && ++emptyLines > 1) break out;
            break;
          } else if (!sawNonWS && !isSpace(prev)) {
            sawNonWS = true;
          }
        }
      } else if (prev == 47 && text.charCodeAt(pos - 2) == 42) {
        for (var scan = pos - 2; scan > 1; --scan) {
          if (text.charCodeAt(scan - 1) == 42 && text.charCodeAt(scan - 2) == 47) {
            if (!onOwnLine(text, scan - 2)) break out;
            (found || (found = [])).unshift(text.slice(scan, pos - 2));
            topIsLineComment = false;
            emptyLines = 0;
            break;
          }
        }
        pos = scan - 2;
      } else if (isSpace(prev)) {
        --pos;
      } else {
        break;
      }
    }
    return found;
  };

  exports.commentAfter = function(text, pos) {
    while (pos < text.length) {
      var next = text.charCodeAt(pos);
      if (next == 47) {
        var after = text.charCodeAt(pos + 1), end;
        if (after == 47) // line comment
          end = text.indexOf("\n", pos + 2);
        else if (after == 42) // block comment
          end = text.indexOf("*/", pos + 2);
        else
          return;
        return text.slice(pos + 2, end < 0 ? text.length : end);
      } else if (isSpace(next)) {
        ++pos;
      }
    }
  };

  exports.ensureCommentsBefore = function(text, node) {
    if (node.hasOwnProperty("commentsBefore")) return node.commentsBefore;
    return node.commentsBefore = exports.commentsBefore(text, node.start);
  };
});

});

define("plugins/c9.ide.language.javascript.tern/worker/architect_resolver_tern_plugin",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(
        require("../lib/infer"),
        require("../lib/tern"),
        require("../lib/comment"),
        require("acorn/util/walk"),
        require
    );
  if (typeof define == "function" && define.amd) // AMD
    return define([
        "tern/lib/infer",
        "tern/lib/tern",
        "tern/lib/comment",
        "acorn/dist/walk",
        "require",
        "exports"
    ], mod);
  mod(tern, tern);
})(function(infer, tern, comment, walk, require, exports) {

var architectPlugins;
var warnedPlugins = {};

if (exports)
    exports.setArchitectPlugins = function(value) {
        architectPlugins = value;
    };

tern.registerPlugin("architect_resolver", function(ternWorker, options) {
    ternWorker._architect = {
        modules: Object.create(null)
    };
    ternWorker.on("afterLoad", function(file) {
        var provides;
        walk.simple(file.ast, {
            AssignmentExpression: function(node) {
                if (!isDependencyAssign(node, "provides"))
                    return;
                provides = node.right.elements.map(function(e) {
                    return e.value;
                }).filter(function(e) {
                    return e;
                });
            },
            FunctionDeclaration: function(node) {
                if ((node.id.name !== "main" && node.id.name !== "plugin")
                    || node.params.length !== 3
                    || node.params[1].name !== "imports"
                    || node.params[2].name !== "register")
                    return;
                
                var seen = {};

                walk.simple(node, {
                    CallExpression: function(node) {
                        if (node.callee.name === "register"
                            && node.arguments.length >= 2
                            && node.arguments[1].type === "ObjectExpression") {
                            var arg = node.arguments[1];
                            arg.properties.forEach(function(prop) {
                                var name = prop.key.name;
                                var value = arg.objType.props[name] && arg.objType.props[name].types && arg.objType.props[name].types[0];
                                if (!value || seen["_" + name])
                                    return;
                                ternWorker._architect.modules["_" + name] = value;
                            });
                        }
                        if (node.callee.type === "MemberExpression"
                            && node.callee.property.name === "freezePublicAPI"
                            && node.arguments.length >= 1
                            && node.arguments[0].type === "ObjectExpression") {
                            var name = provides[0];
                            if (provides.length !== 1
                                && !(provides.length === 2 && name === "ext" && !seen["_" + name]))
                                return console.warn("[architect_resolver_worker] exporting multiple client-side plugins with freezePublicAPI() not supported: " + node.sourceFile.name);
                            var type = node.arguments[0].objType;
                            ternWorker._architect.modules["_" + name] = type;
                            seen["_" + name] = true;
                            delete type.props._events;
                            
                            comment.ensureCommentsBefore(node.sourceFile.text, node);
                            if (node.commentsBefore)
                                type.doc = type.doc || node.commentsBefore[node.commentsBefore.length - 1];
                        }
                    }
                });
            }
        });
    });
    function onPostInfer(ast, scope) {
        var path = ternWorker.cx.curOrigin;
        var baseDirMatch = path.match(/(.*\/)?plugins\//);
        if (!architectPlugins)
            return console.error("[architect_resolver_worker] architectPlugins not available");

        var consumes;
        walk.simple(ast, {
            AssignmentExpression: function(node) {
                if (!isDependencyAssign(node, "consumes"))
                    return;
                consumes = node.right.elements.map(function(e) {
                    return e.value;
                }).filter(function(e) {
                    return e;
                });
            },
            FunctionDeclaration: function(node) {
                if (node.id.name !== "main"
                    || node.params.length !== 3
                    || node.params[1].name !== "imports"
                    || node.params[2].name !== "register"
                    || !node.body.scope)
                    return;

                var importsVal = node.body.scope.prev.props.imports;
                var type = new infer.Obj();
                importsVal.addType(type);
                importsVal.gatherProperties = function(f) {
                    consumes.forEach(function(m) {
                        return f(m, importsVal, 0);
                    });
                };

                if (!consumes)
                    return console.warn("[architect_resolver_worker] main.consumes not defined");
                    
                if (!baseDirMatch) {
                    if (!warnedPlugins[path])
                        console.warn("[architect_resolver_worker] expected plugin to be in plugins/ dir: " + path);
                    warnedPlugins[path] = true;
                    return;
                }

                consumes.forEach(function(name) {
                    var path = getPath(name);
                    var def = ternWorker._architect.modules["_" + name];
                    if (!path && !def) {
                        if (!warnedPlugins[name])
                            console.warn("[architect_resolver_worker] could not resolve \"" + name + "\" plugin");
                        warnedPlugins[name] = true;
                        return;
                    }
                    if (path && baseDirMatch)
                        ternWorker.addFile(path, null, ternWorker.cx.curOrigin);
                    if (!def)
                        return;
                    
                    importsVal.getProp(name).addType(def);
                    type.getProp(name).addType(def);
                });
            }
        });

        function getPath(name) {
            var result = architectPlugins["_" + name];
            if (!result)
                return;
            return baseDirMatch[1] + result + ".js";
        }
    }

    function isDependencyAssign(node, kind) {
        return node.left.type === "MemberExpression"
            && (node.left.object.name === "main" || node.left.object.name === "plugin")
            && node.left.property.name === kind
            && node.right.type === "ArrayExpression";
    }

    return {
        passes: {
            postInfer: onPostInfer
        }
    };
});

});
});

define("plugins/c9.ide.language.javascript.tern/worker/architect_resolver_worker",[], function(require, exports, module) {

var plugin = require("./architect_resolver_tern_plugin");
var worker = require("plugins/c9.ide.language.core/worker");
var util = require("plugins/c9.ide.language/worker_util");
var completeUtil = require("plugins/c9.ide.language/complete_util");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var handler = module.exports = Object.create(baseLanguageHandler);

var ready;
var pluginNames;

worker.sender.emit("architectPlugins");
worker.sender.on("architectPluginsResult", function(e) {
    plugin.setArchitectPlugins(e.data);
    pluginNames = Object.keys(e.data).map(function(key) {
        return key.substr(1);
    });
    ready = true;
});

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.onceReady = function(callback) {
    if (ready)
        return callback();
    
    worker.sender.once("architectPluginsResult", function() {
        setTimeout(callback);
    });
};

handler.complete = function(doc, fullAst, pos, options, callback) {
    var node = options.node;
    if (!ready
        || !node
        || node.cons !== "String"
        || !node.parent
        || !node.parent.parent
        || node.parent.parent.cons !== "Array"
        || !node.parent.parent.parent
        || node.parent.parent.parent.cons !== "Assign"
        )
        return callback();
    
    var lhs = node.parent.parent.parent[0];
    if (lhs.cons !== "PropAccess"
        || lhs[1].value !== "consumes")
        return callback();
    
    var line = doc.getLine(pos.row);
    var id = util.getPrecedingIdentifier(line, pos.column);
    var completions = completeUtil.findCompletions(id, pluginNames);

    callback(completions.map(function(c) {
        return {
            name: c,
            icon: "package",
            identifierRegex: /[a-zA-Z_0-9\$\/\.]/,
            replaceText: c,
            priority: 5
        };
    }));
};

});

define("plugins/c9.ide.language.javascript.tern/worker/acorn_helper",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("acorn/acorn"), require("acorn/acorn_loose"), require);
  if (typeof define == "function" && define.amd) // AMD
    return define(["acorn/dist/acorn", "acorn/dist/acorn_loose", "require", "exports"], mod);
  mod(tern, tern);
})(function(acorn, acornLoose, require, exports) {
var File = function() {}; // TODO? use require("tern/lib/tern").File
var parse = acorn.parse;
var parse_dammit = acornLoose.parse_dammit;

var lastInput;
var lastOutput;
var lastInputLoose;
var lastOutputLoose;
var language;

if (exports)
    exports.setLanguage = function(value) {
        language = value;
    };

acorn.parse = function(input, options) {
    return acornLoose.parse_dammit(input, options);
};

acornLoose.parse_dammit = function(input, options) {
    if (language === "jsx") {
        input = input.replace(/\/>|<\//g, " -").replace(/[<>]/g, "-");
    }
    if (input === lastInputLoose) {
        if (options.directSourceFile && lastOutputLoose.sourceFile != options.directSourceFile) {
            for (var i in options.directSourceFile)
                lastOutputLoose.sourceFile[i] = options.directSourceFile[i];
            lastOutputLoose.sourceFile.ast = lastOutputLoose;
        }
        return lastOutputLoose;
    }
    if (!options.directSourceFile) {
        options.directSourceFile = new File();
        options.directSourceFile;
    }
    lastOutputLoose = filterDefine(parse_dammit(input, options));
    lastInputLoose = input;
    return lastOutputLoose;
};

function filterDefine(ast) {
    ast.body.forEach(function(statement) {
        if (statement.type === "ExpressionStatement"
            && statement.expression.type === "CallExpression"
            && statement.expression.callee.name === "define"
            && statement.expression.arguments.length
            && statement.expression.arguments[0].type === "FunctionExpression") {
            var func = statement.expression.arguments[0];
            func.params = func.params.filter(function(p) {
                return ["require", "exports", "module"].indexOf(p.name) === -1;
            });
        }
    });
    return ast;
}

});
});

define("plugins/c9.ide.language.javascript.infer/values",[], function(require, exports, module) {

var PROPER = require('plugins/c9.ide.language.javascript/scope_analyzer').PROPER;
var MAYBE_PROPER = require('plugins/c9.ide.language.javascript/scope_analyzer').MAYBE_PROPER;
var NOT_PROPER = require('plugins/c9.ide.language.javascript/scope_analyzer').NOT_PROPER;
var MAX_VALUES_LENGTH = 15;

var valueRegistry = {};

var contextStack = [];

function Property(values, confidence, path, row) {
    this.values = values;
    this.confidence = confidence;
    this.path = path;
    this.row = row;
}

function Value(name, node) {
    this.init(name, node);
}

Value.enterContext = function(name) {
    contextStack.push([name, 0]);
};

Value.leaveContext = function() {
    contextStack.pop();
};

Value.prototype.init = function(name, node) {
    var guid = '';
    for (var i = 0; i < contextStack.length; i++) {
        guid += contextStack[i][0] + '[' + contextStack[i][1] + ']/';
    }
    var top = contextStack[contextStack.length - 1];
    if (top) {
        top[1]++;
    }
    if (name) {
        guid += name;
    } else {
        guid = guid.substring(0, guid.length - 1);
    }
    this.guid = guid;
    this.properties = {};
    this.doc = null;
    this.docUrl = null;
    if (node) {
        this.pos = node.getPos();
    }
    valueRegistry[guid] = this;
};

Value.prototype.get = function(name) {
    var coll = new ValueCollection();
    if (this.properties['_' + name]) {
        coll.extend(this.properties['_' + name].values);
    }

    if (name !== '__proto__') {
        this.get('__proto__').forEach(function(p) {
            coll.extendPrototype(p.get(name).toArray());
        });
    }
    coll.deref();
    return coll;
};

Value.prototype.getPropertyNames = function() {
    var results = Object.keys(this.properties).map(function(s) {
        return s.substr(1);
    });
    this.get('__proto__').forEach(function(p) {
        return Object.keys(p.properties).forEach(function (s) {
            results.push(s.substr(1));
        });
    });
    return results;
};

Value.prototype.toJSON = function() {
    var fieldJSON = {};
    var properties = this.properties;
    for (var p in properties) {
        if (properties.hasOwnProperty(p)) {
            var prop = properties[p];
            return new Property(prop.values.map(function(v) { return v.guid; }), prop.confidence, prop.path, prop.row);
        }
    }
    return {
        guid: this.guid,
        doc: this.doc,
        properties: fieldJSON,
        pos: this.pos
    };
};

Value.prototype.markProperDeclaration = function(uname, confidence, path, row) {
    if (!this.properties[uname])
        return;    
    if (path)
        this.properties[uname].path = path;
    if (row)
        this.properties[uname].row = row;    
    if (confidence && this.properties[uname].confidence < PROPER)
        this.properties[uname].confidence += confidence;
};

Value.prototype.isProperDeclaration = function(name) {
    if (!this.properties['_' + name])
        return false;
    if (this.properties['_' + name].confidence > MAYBE_PROPER)
        return true;
    var result;
    if (name !== '__proto__') {
        this.get('__proto__').forEach(function(p) {
            if (p.isProperDeclaration(name))
                result = true;
        });
    }
    return result;
};

Value.prototype.hint = function(name, v, declarationConfidence, path, row) {
    if (!v)
        throw Error("Hinting an empty value!");
    if (!this.properties['_' + name]) {
        this.properties['_' + name] = new Property([v], declarationConfidence, path, row);
    }
    else {
        var currentValues = this.properties['_' + name].values;
        this.markProperDeclaration('_' + name, declarationConfidence, row);
        for (var i = 0; i < currentValues.length; i++) {
            if (currentValues[i].guid === v.guid) {
                return;
            }
        }
        currentValues.push(v);
    }
};

Value.prototype.hintMultiple = function(name, valueColl, declarationConfidence, path, row) {
    var _self = this;
    valueColl.forEach(function(v) {
        _self.hint(name, v, NOT_PROPER);
    });
    this.markProperDeclaration('_' + name, declarationConfidence, path, row);
};

function ValueCollection(values, prototypeValues) {
    this.values = values || [];
    this.prototypeValues = prototypeValues || [];
}

ValueCollection.prototype.extend = function(coll) {
    if (coll instanceof ValueCollection) {
        for (var i = 0; i < coll.values.length; i++) {
            this.add(coll.values[i]);
        }
        for (var i = 0; i < coll.prototypeValues.length; i++) {
            this.addFromPrototype(coll.prototypeValues[i]);
        }
    } else {
        for (var i = 0; i < coll.length; i++) {
            this.add(coll[i]);
        }
    }
};

ValueCollection.prototype.extendPrototype = function(coll) {
    this.prototypeValues = this.prototypeValues.concat(coll);
};

ValueCollection.prototype.toArray = function() {
    return this.values.concat(this.prototypeValues);
};

ValueCollection.prototype.add = function(value) {
    if (!value)
        throw Error("Adding empty value!");
    if (this.values.length > MAX_VALUES_LENGTH)
        return;
    this.values.push(value);
};

ValueCollection.prototype.addFromPrototype = function(value) {
    if (this.prototypeValues.length > MAX_VALUES_LENGTH)
        return;
    this.prototypeValues.push(value);
};

ValueCollection.prototype.forEach = function(fn) {
    this.values.forEach(fn);
    this.prototypeValues.forEach(fn);
};

ValueCollection.prototype.deref = function() {
    var values = this.values;
    for (var i = 0; i < values.length; i++)
        if (typeof values[i] === 'string')
            values[i] = valueRegistry[values[i]];
    values = this.prototypeValues;
    for (var i = 0; i < values.length; i++)
        if (typeof values[i] === 'string')
            values[i] = valueRegistry[values[i]];
};

ValueCollection.prototype.isEmpty = function() {
    return this.values.length === 0 && this.prototypeValues.length === 0;
};

function FunctionValue(name, node, callOnly) {
    this.init(name, node);
    this.node = node;
    this.callOnly = callOnly;
    if (name || node) {
        this.hintMultiple('__proto__', lookupValue("es5:Function").get('prototype'));
    }
}

FunctionValue.prototype = new Value('<ignore>');

FunctionValue.prototype.getFargs = function() {
    if (this.fargs)
        return this.fargs;
    else if (this.node) {
        var fargs = [];
        var fargsNode = this.node[1];
        for (var i = 0; i < fargsNode.length; i++) {
            fargs.push(fargsNode[i][0].value);
        }
        this.fargs = fargs;
        return fargs;
    }
    else
        return [];
};

FunctionValue.prototype.toJSON = function() {
    var json = Value.prototype.toJSON.call(this);
    json.fargs = this.getFargs();
    return json;
};

function SerializedFunctionValue(name) {
    this.init(name);
}

SerializedFunctionValue.prototype = new FunctionValue();

function instantiate(fn, initVal, node, name) {
    var value = initVal || new Value(name, node);
    value.hintMultiple('__proto__', fn.get('prototype'));
    value.hint('constructor', fn, PROPER);
    return value;
}

function lookupValue(guid) {
    if (!valueRegistry[guid])
        throw Error("Could not find " + guid);
    return valueRegistry[guid];
}

function fromJSON(json) {
    if (typeof json === "string")
        return json;
    
    var properties = json.properties || {};
    var value;

    if (properties._return !== undefined) {
        value = new SerializedFunctionValue();
        if (json.fargs) {
            value.fargs = json.fargs;
            for (var i = 0; i < value.fargs.length; i++) {
                if (!value.fargs[i].type)
                    value.fargs[i].type = ["es5:Object"];
            }
        }
    }
    else {
        value = new Value();
    }
    
    for (var p in properties) {
        var prop = properties[p];
        if (!prop.forEach) {
            (prop.values || []).forEach(function(v) {
                value.hint(p.substr(1), fromJSON(v), PROPER, v.path || json.path, v.row);
            });
        }
        else {
            prop.forEach(function(v) {
                value.hint(p.substr(1), fromJSON(v), PROPER, v.path || json.path, v.row);
            });
        }
    }

    if (json.guid) {
        valueRegistry[json.guid] = value;
    }
    value.guid = json.guid;
    value.doc = json.doc;
    value.docUrl = json.docUrl;
    value.path = json.path;
    value.row = json.row;
    
    return value;
}
    
exports.Value = Value;
exports.ValueCollection = ValueCollection;
exports.FunctionValue = FunctionValue;
exports.instantiate = instantiate;
exports.fromJSON = fromJSON;
exports.lookupValue = lookupValue;

exports.getRegistry = function() { return valueRegistry; };

exports.reset = function() {
    valueRegistry = {};
    contextStack = [];
};

});

define("plugins/c9.ide.language.javascript.infer/infer",[], function(require, exports, module) {

var values = require("./values");
var Value = values.Value;
var ValueCollection = values.ValueCollection;
var FunctionValue = values.FunctionValue;
var instantiate = values.instantiate;
var valueFromJSON = values.fromJSON;
var lookupValue = values.lookupValue;
var scopeAnalyzer = require("plugins/c9.ide.language.javascript/scope_analyzer");
var Scope = scopeAnalyzer.Scope;
var Variable = scopeAnalyzer.Variable;
var PROPER = scopeAnalyzer.PROPER;
var MAYBE_PROPER = scopeAnalyzer.MAYBE_PROPER;
var NOT_PROPER = scopeAnalyzer.NOT_PROPER;
var KIND_PACKAGE = scopeAnalyzer.KIND_PACKAGE;
var KIND_DEFAULT = scopeAnalyzer.KIND_DEFAULT;
var path = require("./path");
var completeUtil = require("plugins/c9.ide.language/complete_util");
require('treehugger/traverse');

var registeredSummaries = {};

if (typeof window !== "undefined") {
    completeUtil.fetchText("plugins/c9.ide.language.javascript.infer/builtin.jst", function(err, result) {
        if (err) return console.error(err);
        registeredSummaries.$builtin1$ = JSON.parse(result);
    });
}

var filePath;
var basePath;

function registerSummary(guid, summary) {
    if (!summary) {
        if (registeredSummaries[guid])
            delete registeredSummaries[guid];
        return;
    }
    
    registeredSummaries[guid] = summary;
}

Variable.prototype.addValue = function(value) {
    var values = this.values;
    for (var i = 0; i < values.length; i++) {
        if (values[i].guid === value.guid) {
            return;
        }
    }
    values.push(value);
};
Scope.prototype.hint = function(name, v, declarationConfidence, path, row, kind) {
    var variable = this.get(name, kind);
    if (!variable) {
        variable = this.declare(name);
    }
    for (var i = 0; i < variable.values.length; i++) {
        if (variable.values[i].guid === v.guid) {
            return;
        }
    }
    variable.addValue(v);
    return v;
};

Scope.prototype.hintMultiple = function(name, valueColl, declarationConfidence, path, row) {
    var variable = this.get(name);
    if (!variable) {
        variable = this.declare(name);
    }
    valueColl.forEach(function(v) {
        for (var i = 0; i < variable.values.length; i++) {
            if (variable.values[i].guid === v.guid) {
                return;
            }
        }
        variable.addValue(v);
    });
};
function evalFunction(scope, node, thisValues) {
    node.rewrite(
        'Function(name, fargs, body)', function(b, node) {
            var val = new FunctionValue(b.name.value, node);
            if (b.name.value)
                scope.hint(b.name.value, val, PROPER, filePath, tryGetRow(node));
            var proto = new Value("prototype", node);
            val.hint('prototype', proto);
            var localScope = this.getAnnotation("localScope");
            localScope.fn = val;
            localScope.declare("this", undefined, PROPER);
            localScope.hint("this", proto, PROPER, filePath, tryGetRow(node));
            if (thisValues)
                localScope.hintMultiple("this", thisValues, PROPER);
            b.fargs.forEach(function(farg, idx) {
                var fargName = farg[0].value;
                var fargVal;
                if (localScope.fnFargs && localScope.fnFargs[idx] && localScope.fnFargs[idx].type) {
                    fargVal = lookupValue(localScope.fnFargs[idx].type);
                }
                else {
                    fargVal = new Value(fargName);
                }
                val.hint("arg" + idx, fargVal, NOT_PROPER);
                localScope.declare(fargName);
                localScope.hint(fargName, fargVal, PROPER);
            });
            Value.enterContext(b.name.value || 'fn');
            staticEval(localScope, b.body);
            Value.leaveContext();
        }
    );
}

function hintValue(node, asV, declarationConfidence) {
    node.rewrite(
        'Var(x)', function(b) {
            var scope = this.getAnnotation("scope");
            scope.hint(b.x.value, asV, declarationConfidence);
        },
        'PropAccess(e, x)', function(b) {
            var vals = inferValues(b.e);
            vals.forEach(function(v) {
                v.hint(b.x.value, asV, declarationConfidence);
            });
        }
    );
}
function staticEval(scope, node, newFilePath, newBasePath) {
    if (newFilePath || newFilePath === "")
        filePath = newFilePath;
    if (newBasePath || newBasePath === "")
        basePath = newBasePath;
        
    node.traverseTopDown(
        "Function(_, _, _)", function() {
            evalFunction(scope, this);
            return this; // Stop traversal
        },
        "VarDeclInit(name, e)", "ConstDeclInit(name, e)", "LetDeclInit(name, e)", function(b, node) {
            staticEval(scope, b.e);
            scope.hintMultiple(b.name.value, inferValues(b.e), PROPER, filePath, tryGetRow(node));
            return this; // Stop traversal
        }, 
        'Assign(PropAccess(e1, prop), e2)', function(b, node) {
            staticEval(scope, b.e1);
            var vs = inferValues(b.e1);
            var isImportant = false;
            if (b.e2.cons === 'Function') {
                evalFunction(scope, b.e2, vs);
                isImportant = true;
            }
            else if (b.e2.cons === 'ObjectInit') {
                staticEval(scope, this[0]); // PropAccess(e1, prop)
                var vs2 = inferValues(this[0]);
                b.e2[0].filter(
                    'PropertyInit(_, Function(_, _, _))', function(b) {
                        evalFunction(scope, this[1], vs2);
                        return this;
                    },
                    function(b) {
                        staticEval(scope, this);
                    }
                );
                isImportant = true;
            }
            else {
                staticEval(scope, b.e2);
            }
            var vs3 = inferValues(b.e2);
            if (isImportant) {
                vs.values.forEach(function(v) {
                    v.hintMultiple(b.prop.value, vs3, MAYBE_PROPER, filePath, tryGetRow(node));
                });
            }
            else {
                vs.values.forEach(function(v) {
                    v.hintMultiple(b.prop.value, vs3, MAYBE_PROPER);
                });
            }
            return this;
        },
        "Assign(Var(name), e)", function(b) {
            staticEval(scope, this[0]);
            staticEval(scope, b.e);
            scope.hintMultiple(b.name.value, inferValues(b.e), MAYBE_PROPER);
            return this;
        },
        "ObjectInit(inits)", function(b) {
            var v = new Value("objLit");
            var vals = new ValueCollection([v]);
            b.inits.filter(
                'PropertyInit(prop, Function(_, _, _))', function(b) {
                    evalFunction(scope, this[1], vals);
                    v.hintMultiple(b.prop.value, inferValues(this[1]), PROPER, filePath, tryGetRow(this));
                },
                'PropertyInit(prop, e)', function(b) {
                    staticEval(scope, b.e);
                    v.hintMultiple(b.prop.value, inferValues(b.e), PROPER, filePath, tryGetRow(this));
                }
            );
            return this;
        },
        "OpAssign(op, Var(name), e)", function(b) {
            staticEval(scope, this[1]);
            staticEval(scope, b.e);
            scope.hintMultiple(b.name.value, inferValues(b.e), MAYBE_PROPER);
            if (b.op.value === '*' || b.op.value === '/' || b.op.value === '%' || b.op.value === '-') {
                scope.hint(b.name.value, lookupValue('es5:Number/prototype'));
            } else if (b.op.value === '+') {
                scope.hint(b.name.value, lookupValue('es5:Number/prototype'));
                scope.hint(b.name.value, lookupValue('es5:String/prototype'));
            }
            return this;
        },
        "PropAccess(e, prop)", function(b) {
            staticEval(scope, b.e);
            var vs = inferValues(this);
            if (!vs.isEmpty()) {
                return; // property is defined
            }
            vs = inferValues(b.e);
            vs.forEach(function(v) {
                v.hint(b.prop.value, new Value(b.prop.value), MAYBE_PROPER);
            });
            return this;
        },
        'Call(PropAccess(Function(name, fargs, body), "call"), args)', function(b) {
            var fnNode = this[0][0]; // Function(name, ...)
            staticEval(scope, b.args);
            var objectValues = inferValues(b.args[0]);
            var funScope = fnNode.getAnnotation("localScope");
            var fargs = b.fargs;
            evalFunction(scope, fnNode, objectValues);
            for (var i = 0; i < b.args.length - 1; i++) {
                inferValues(b.args[i + 1]).forEach(function(v) {
                    if (i < fargs.length)
                        funScope.hint(fargs[i].value, v, NOT_PROPER);
                    objectValues.forEach(function(objV) {
                        objV.hint('arg' + i, v, NOT_PROPER);
                    });
                });
            }
            return this;
        },
        "Call(Var(name), args)", function(b) {
            var variable = scope.get(b.name.value);
            if (!variable) {
                variable = scope.declare(b.name.value);
                scope.hint(b.name.value, new FunctionValue(b.name.value, null, true), MAYBE_PROPER);
            } 
            else {
                var foundFunction = false;
                variable.values.forEach(function(v) {
                    if (v instanceof FunctionValue)
                        foundFunction = true;
                });
                if (!foundFunction)
                    scope.hint(b.name.value, new FunctionValue(b.name.value, null, true), MAYBE_PROPER);
            }
            staticEval(scope, b.args);
            for (var i = 0; i < b.args.length; i++) {
                inferValues(b.args[i]).forEach(function(v) {
                    variable.values.forEach(function(fn) {
                        if (fn instanceof FunctionValue) {
                            fn.hint('arg' + i, v, NOT_PROPER);
                        }
                    });
                });
            }
            variable.values.forEach(function(fn) {
                if (fn instanceof FunctionValue && fn.get("return").isEmpty())
                    fn.hint('return', new Value("implReturn"), PROPER);
            });
            return this;
        },
        "Call(PropAccess(e, prop), args)", function(b) {
            staticEval(scope, b.e);
            var eValues = inferValues(b.e);
            var fnValues = inferValuesPropAccess(eValues, b.prop.value, new ValueCollection());
            fnValues.forEach(function(fn) {
                if (fn instanceof FunctionValue) {
                    for (var i = 0; i < b.args.length; i++) {
                        var fargFargs = fn.fargs && fn.fargs[i] && fn.fargs[i].fargs;
                        var localScope = b.args[i].getAnnotation("localScope");
                        if (localScope)
                            localScope.fnFargs = fargFargs;
                    }
                }
            });
            staticEval(scope, b.args);
            if (fnValues.isEmpty()) {
                eValues.forEach(function(v) {
                    v.hint(b.prop.value, new FunctionValue(b.prop.value, null, true), MAYBE_PROPER);
                });
            }
            fnValues.forEach(function(fn) {
                if (fn instanceof FunctionValue) {
                    for (var i = 0; i < b.args.length; i++) {
                        var vs = inferValues(b.args[i]);
                        vs.forEach(function(v) {
                            fn.hint('arg' + i, v, NOT_PROPER);
                        });
                    }
                    if (fn.get("return").isEmpty())
                        fn.hint('return', new Value("implReturn"), PROPER);
                }    
            });
            return this;
        },
        "Return(e)", function(b) {
            staticEval(scope, b.e);
            scope.fn && scope.fn.hintMultiple('return', inferValues(b.e), PROPER);
            return this;
        },
        "Var(name)", function(b) {
            var vs = scope.get(b.name.value);
            if (!vs) {
                scope.declare(b.name.value);
                scope.hint(b.name.value, new Value(b.name.value, this), MAYBE_PROPER);
            }
            return this;
        },
        "ForIn(iter, _, _)", function(b) {
            b.iter.rewrite(
                "Var(x)", function(b) {
                    scope.hint(b.x.value, lookupValue("es5:String"));
                },
                "VarDecls([VarDecl(x)])", function(b) {
                    scope.hint(b.x.value, lookupValue("es5:String"));
                }
            );
        },
        "Op(op, e1, e2)", function(b) {
            staticEval(scope, b.e1);
            staticEval(scope, b.e2);
            switch (b.op.value) {
                case '<':
                case '<=':
                case '>':
                case '>=':
                    hintValue(b.e1, lookupValue("es5:Number"), NOT_PROPER);
                    hintValue(b.e1, lookupValue("es5:String"), NOT_PROPER);
                    hintValue(b.e2, lookupValue("es5:Number"), NOT_PROPER);
                    hintValue(b.e2, lookupValue("es5:String"), NOT_PROPER);
                    break;
            }
            return this;
        }
    );
    return scope;
}
function inferValues(e) {
    var values = new ValueCollection();
    e.rewrite(
        "String(_)", function() {
            values.add(lookupValue("es5:String/prototype"));
            return this;
        },
        "RegExp(_,_)", function() {
            values.add(lookupValue("es5:RegExp/prototype"));
            return this;
        },
        "Num(_)", function() {
            values.add(lookupValue("es5:Number/prototype"));
            return this;
        },
        "Var(\"true\")", function() {
            values.add(lookupValue("es5:Boolean/prototype"));
            return this;
        },
        "Var(\"false\")", function() {
            values.add(lookupValue("es5:Boolean/prototype"));
            return this;
        },
        "Array(_)", function() {
            values.add(lookupValue("es5:Array/prototype"));
            return this;
        },
        "Var(nm)", function(b) {
            var scope = this.getAnnotation("scope");
            if (!scope) {
                for (var root = this; root.parent;) root = root.parent;
                console.error("[infer] Cannot find scope of " + b.nm + "; analysis "
                    + (root.getAnnotation("scope") ? "incomplete" : "may not have been performed yet"));
                return;
            }
            var v = scope.get(b.nm.value) || scope.declare(b.nm.value);
            if (v.kind === KIND_DEFAULT)
                values.extend(v.values);
            return this;
        },
        "ObjectInit(inits)", function(b) {
            var v = instantiate(lookupValue("es5:Object"), undefined, this);
            b.inits.filter('PropertyInit(prop, e)', function(b) {
                v.hintMultiple(b.prop.value, inferValues(b.e), PROPER, filePath, tryGetRow(this));
            });
            values.add(v);
            return this;
        },
        "New(e, args)", function(b) {
            var vs = inferValues(b.e);
            vs.forEach(function(fn) {
                var value = instantiate(fn, undefined, undefined, b.e.cons === 'Var' && b.e[0].value);
                values.add(value);
            });
            return this;
        },
        "Call(Var(\"require\"), [String(name)])", function(b) {
            var scope = this[0].getAnnotation("scope");
            if (!scope)
                return;
            var required = b.name.value;
            if (path.isRelativePath(required) || path.isRelativePath(required)) {
                required = path.canonicalizePath(required, basePath).replace(/^\//, "");
                if (!required.match(/\.js$/))
                    required += ".js";
            }
            var result = scope.get(required, KIND_PACKAGE);
            if (!result)
                return;
            values.extend(result.values);
            return this;
        },
        "Call(PropAccess(e, method), args)", function(b) {
            var objectValues = inferValues(b.e);
            objectValues.forEach(function(objectValue) {
                var methods = objectValue.get(b.method.value);
                methods.forEach(function(fn) {
                    if (fn instanceof FunctionValue) {
                        values.extend(fn.get('return'));
                    }
                });
            });
            if (values.isEmpty())
                values.add(new Value("implRet"));
            return this;
        },
        "Call(e, args)", function(b) {
            var vs = inferValues(b.e);
            vs.forEach(function(fn) {
                if (fn instanceof FunctionValue) {
                    values.extend(fn.get('return'));
                }
            });
            if (values.isEmpty())
                values.add(new Value("implRet"));
            return this;
        },
        "PropAccess(e, prop)", function(b) {
            inferValuesPropAccess(inferValues(b.e), b.prop.value, values);
            return this;
        },
        "Function(name, fargs, _)", function(b) {
            values.add(this.getAnnotation("localScope").fn);
            return this;
        },
        'Assign(e1, e2)', function(b) {
            values = inferValues(b.e2);
        },
        'Op(op, e1, e2)', function(b) {
            switch (b.op.value) {
                case '*':
                case '/':
                case '%':
                case '-':
                    values.add(lookupValue('es5:Number/prototype'));
                    break;
                case '+':
                    values.add(lookupValue('es5:String/prototype'));
                    values.add(lookupValue('es5:Number/prototype'));
                    break;
                case '==':
                case '===':
                case '!==':
                case '!=':
                case '>':
                case '>=':
                case '<':
                case '<=':
                    values.add(lookupValue('es5:Boolean/prototype'));
                    break;
                case '||':
                case '&&':
                    values.extend(inferValues(b.e1));
                    values.extend(inferValues(b.e2));
                    break;
                default:
                    return false;
            }
            return this;
        },
        'PrefixOp(op, e)', function(b) {
            switch (b.op.value) {
                case '+':
                case '-':
                case '~':
                    values.add(lookupValue('es5:Number/prototype'));
                    break;
                case '!':
                    values.add(lookupValue('es5:Boolean/prototype'));
                    break;
                default:
                    return false;
            }
            return this;
        }
    );
    return values;
}

function inferValuesPropAccess(values, propName, results) {
    values.forEach(function(val) {
        results.extend(val.get(propName));
    });
    return results;
}

function createRootScope(scope, summaries) {
    if (!summaries)
        summaries = registeredSummaries;
    for (var p in summaries) {
        if (!summaries.hasOwnProperty(p))
            continue;
        var summarySet = summaries[p];
        for (var uri in summarySet) {
            if (!summarySet.hasOwnProperty(uri))
                continue;
            var summary = summarySet[uri];
            var TypeName = uri.split(':')[1];
            if (summary.kind === "default")
                summary.kind = KIND_DEFAULT;
            scope.declare(TypeName, undefined, PROPER, summary.kind);
            var value = valueFromJSON(summary);
            scope.hint(TypeName, value, PROPER, summary.path, summary.row, summary.kind);
    
            for (var j = 0; summary.altGuids && j < summary.altGuids.length; j++) {
                var guid = summary.altGuids[j].split(':')[1];
                scope.declare(guid, undefined, PROPER, summary.kind);
                scope.hint(guid, value, PROPER, summary.path, summary.row, summary.kind);   
            }
            
            if (summary.path) {
                scope.declareAlias(summary.kind, TypeName, summary.path);   
            }
        }
    }
    return scope;
}

function analyze(doc, ast, filePath, basePath, callback) {
    scopeAnalyzer.analyze(doc.getValue(), ast, function() {
        Value.enterContext('es5:unnamed');
        var scope = ast.getAnnotation("scope");
        values.reset();
        createRootScope(scope);
        Value.leaveContext();
        Value.enterContext("local:");
        staticEval(scope, ast, filePath, basePath);
        callback();
    }, true);
}

function tryGetRow(node) {
    var pos = node.getPos();
    return pos ? pos.sl : undefined;
}

exports.registerSummary = registerSummary;
exports.staticEval = staticEval;
exports.inferValues = inferValues;
exports.Scope = Scope;
exports.createRootScope = createRootScope;
exports.analyze = analyze;

});

define("plugins/c9.ide.language.javascript.infer/infer_arguments",[], function(require, exports, module) {

var tree = require("treehugger/tree");
var FunctionValue = require('./values').FunctionValue;
var ValueCollection = require('./values').ValueCollection;
module.exports.getArgIndex = function(node, doc, cursorPos) {
    var cursorTreePos = { line: cursorPos.row, col: cursorPos.column };
    var result = -1;
    node.rewrite(
        'Call(e, args)', function(b) {
            result = -1;
            var line = doc.getLine(cursorPos.row);
            if (line[b.args.getPos().ec + 1] && line[b.args.getPos().ec + 1].match(/[ ,]/))
                b.args.getPos().ec++;

            if (b.args.length === 0 && this.getPos().ec - 1 === cursorPos.column) {
                result = 0;
            }
            else if (b.args.length === 0 && line.substr(cursorPos.column).match(/^\s*\)/)) {
                result = 0;
            }
            else if (!tree.inRange(this.getPos(), cursorTreePos, true)) {
                return this;
            }
            else if (cursorPos.row === this.getPos().sl && line.substr(0, cursorPos.column + 1).match(/,\s*\)$/)) {
                result = b.args.length;
                return this;
            }
            for (var i = 0; i < b.args.length; i++) {
                if (b.args[i].cons === "ERROR" && result === -1) {
                    result = i;
                    break;
                }
                b.args[i].traverseTopDown(function() {
                    var pos = this.getPos();
                    if (this === node) {
                        result = i;
                        return this;
                    }
                    else if (pos && pos.sl <= cursorPos.row && pos.sc <= cursorPos.column) {
                        if (pos.sl === cursorPos.row && pos.ec === cursorPos.column - 1 && line[pos.ec] === ")")
                            return result = -1;
                        result = i;
                    }
                });
            }
            return this;
        }
    );
    return result;
};

module.exports.extractArgumentNames = function(v, showOptionals) {
    var args = [];
    var argsCode = [];
    var inferredArguments = v.callOnly;
    var opt;
    var fargs = v instanceof FunctionValue ? v.getFargs() : [];
    var argColl = extractArgumentValues(v, fargs, 0);
    for (var idx = 0; fargs.length ? idx < fargs.length : !argColl.isEmpty(); idx++) {
        var argName;
        if (fargs[idx]) {
            argName = fargs[idx].id || fargs[idx];
            if (showOptionals && fargs[idx].opt) {
                argName = "[" + argName + "]";
                opt = opt || idx;
            }
        }
        else {
            argName = "arg" + idx;
            inferredArguments = true;
        }
        args.push(argName);
        argsCode.push(fargToClosure(fargs[idx]) || valueCollToClosure(argName, argColl));
        argColl = extractArgumentValues(v, fargs, idx + 1);
    }
    return {
        argNames: args,
        argValueCodes: argsCode,
        inferredNames: inferredArguments,
        opt: opt
    };
};

var extractArgumentValues = function(v, fargs, index) {
    var result;
    if (fargs[index] && fargs[index].id) {
        result = new ValueCollection();
        if (fargs[index].type)
            result.extend(fargs[index].type);
    }
    else {
        result = v.get("arg" + index);
    }
    return result;
};

function fargToClosure(farg) {
    if (!farg || !farg.fargs)
        return null;
    var args = [];
    for (var i = 0; i < farg.fargs.length; i++) {
        args.push(farg.fargs[i].id || farg.fargs[i]);
    }
    return "function(" + args.join(", ") + ") {\n    ^^\n}";
}

function valueCollToClosure(name, coll) {
    var result;
    coll.forEach(function(v) {
        if (result)
            return;
        if (v instanceof FunctionValue) {
            var args = [];
            var fargs = v.getFargs();
            var argColl = extractArgumentValues(v, fargs, idx);
            for (var idx = 0; !argColl.isEmpty() || idx < fargs.length; idx++) {
                var argName;
                if (fargs[idx])
                    argName = fargs[idx].id || fargs[idx];
                else
                    argName = "arg" + idx;
                args.push(argName);
                argColl = extractArgumentValues(v, fargs, idx + 1);
            }
            result = "function(" + args.join(", ") + ") {\n    ^^\n}";
        }
    });
    return result;
}

});

define("plugins/c9.ide.language.javascript.infer/ast_updater",[], function(require, exports, module) {

    var infer = require("./infer");
    var assert = require("c9/assert");
    var tree = require("treehugger/tree");
    var REGEX_SAFE_CHANGE = /^[\(\)\s\.\/\*+;,A-Za-z-0-9_$]*$/;
    
    var lastAST;
    var lastDocValue;
    module.exports.updateOrReanalyze = function(doc, ast, filePath, basePath, pos, callback) {
        var docValue = doc.getValue();
        var updatedAST = tryUpdateAST(doc, docValue, ast);
        if (updatedAST) {
            if (ast.getAnnotation("scope")) {
                lastDocValue = docValue;
                lastAST = updatedAST;
            }
            return callback(updatedAST, findNode(updatedAST, pos));
        }
        var start = new Date().getTime();
        return infer.analyze(doc, ast, filePath, basePath, function() {
            lastDocValue = docValue;
            lastAST = ast;
            callback(ast, findNode(ast, pos));
        }, true);
    };
   
    function tryUpdateAST(doc, docValue, ast) {
        if (lastAST && (!lastAST.annos || !lastAST.annos.scope)) {
            console.error("Warning: Source does not appear to be analyzed yet; restarting analysis");
            return false;
        }
        if (lastDocValue === docValue) {
            return lastAST;
        }
        if (!isUpdateableAST(doc, docValue, ast))
            return null;
        
        if (!copyAnnosTop(lastAST, ast, true))
            return null;
        copyAnnosTop(lastAST, ast);
        assert(ast.annos.scope, "Target is empty");
        return ast;
    }
    function isUpdateableAST(doc, docValue, ast) {
        if (!lastDocValue)
            return false;

        var diff = getDiff(lastDocValue, docValue) || getDiff(docValue, lastDocValue);
        
        return diff && diff.text.match(REGEX_SAFE_CHANGE);
    }
    
    function copyAnnosTop(oldAST, newAST, dryRun) {
        if (!dryRun) copyAnnos(oldAST, newAST);
            
        for (var i = 0, j = 0; j < newAST.length; i++, j++) {
            if (!oldAST[i]) {
                if (newAST[j].cons !== "Var")
                    return false;
                copyAnnos(findScopeNode(oldAST), newAST[j]);
                if (!newAST[j].annos)
                    return false;
                continue;
            }
            if (oldAST[i].cons !== newAST[j].cons) {
                if (oldAST[i].cons === "Var" && newAST[j].isMatch("PropAccess(Var(_),_)")) {
                    copyAnnos(oldAST[i], newAST[j][0]);
                    continue;
                }
                if (newAST[j].cons === "Var" && oldAST[i].isMatch("PropAccess(Var(_),_)")) {
                    copyAnnos(oldAST[i][0], newAST[j]);
                    continue;
                }
                if (oldAST[i].isMatch("PropAccess(Var(_),_)") && newAST[j].isMatch("Call(PropAccess(Var(_),_),_)")) {
                    copyAnnos(oldAST[i][0], newAST[j][0][0]);
                    var oldTemplate = new tree.ListNode([oldAST[i][0]]);
                    oldTemplate.parent = oldAST;
                    copyAnnosTop(oldTemplate, newAST[j][1], dryRun);
                    continue;
                }
                if (newAST[j].isMatch("PropAccess(Var(_),_)") && oldAST[i].isMatch("Call(PropAccess(Var(_),_),_)")) {
                    copyAnnos(oldAST[i][0][0], newAST[j][0]);
                    continue;
                }
                if (newAST[j].cons === "Var" && newAST[j + 1] && newAST[j + 1].cons === oldAST[i].cons) {
                    copyAnnos(findScopeNode(oldAST), newAST[j]);
                    if (!newAST[j].annos)
                        return false;
                    i--;
                    continue;
                }
                if (oldAST[i].cons === "None" && newAST[j].cons === "Var") {
                    copyAnnos(findScopeNode(oldAST), newAST[j]);
                    if (!newAST[j].annos)
                        return false;
                    i--;
                    continue;
                }
                if (oldAST[i].cons === "Var" && oldAST[i + 1] && oldAST[i + 1].cons === newAST[i].cons) {
                    j--;
                    continue;
                }
                if (["If", "Return", "Throw"].indexOf(newAST[j].cons) > -1 && (!newAST[j][1] || newAST[j][1].isMatch("Block([])"))) {
                    var cond = newAST[j][0].toString();
                    if (cond === oldAST[i].toString()) {
                        copyAnnos(oldAST[i], newAST[j][0]);
                        continue;
                    }
                    else if (!oldAST[i + 1]) {
                        continue;
                    }
                    else if (cond === oldAST[i + 1].toString()) {
                        i++;
                        copyAnnos(oldAST[i], newAST[j][0]);
                        continue;
                    }
                }
                if (oldAST.cons === "If" && newAST.cons === "If" && newAST[0].cons === "Var" && oldAST[1].isMatch("Block([])")) {
                    var oldCond = oldAST[0];
                    var newCond = newAST[0];
                    var newBody = newAST[1];
                    if (oldCond.toString() === newBody.toString()) {
                        copyAnnos(findScopeNode(oldAST), newCond);
                        if (!newCond.annos)
                            return false;
                        copyAnnos(oldCond, newBody);
                        continue;
                    }
                }
                return false;
            }
            if (newAST[j].length) {
                if (!copyAnnosTop(oldAST[i], newAST[j], dryRun))
                    return false;
            } else if (!dryRun && newAST[j].$pos) {
                copyAnnos(oldAST[i], newAST[j]);
            }
            
        }
        return true;
    }
    
    function copyAnnos(oldNode, newNode) {
        newNode.oldNode = oldNode.oldNode || oldNode;
        newNode.oldNode.$pos = newNode.$pos;
        
        if (!oldNode.annos)
            return;
        newNode.annos = oldNode.annos;
    }
    
    function findScopeNode(ast) {
        if (!ast)
            return null;
        if (ast.annos && ast.annos.scope)
            return ast;
        return findScopeNode(ast.parent);
    }
    
    function getDiff(oldDoc, newDoc) {
        if (oldDoc.length > newDoc.length)
            return null;
        
        var diffLeft = -1;
        var diffRight = 0;
        
        for (var i = 0; i < newDoc.length; i++) {
            if (oldDoc[i] !== newDoc[i]) {
                diffLeft = i;
                break;
            }
        }
        
        for (var i = newDoc.length, j = oldDoc.length; j >= 0; i--, j--) {
            if (oldDoc[j] !== newDoc[i]) {
                diffRight = i + 1;
                break;
            }
        }
        
        assert(diffLeft != -1, "Inputs can't be equal");
        
        return {
            start: diffLeft,
            end: diffRight,
            text: newDoc.substring(diffLeft, diffRight)
        };
    }
    
    function findNode(ast, pos) {
        var treePos = { line: pos.row, col: pos.column };
        return ast.findNode(treePos);
    }
    
    
});

define("plugins/c9.ide.language.javascript.infer/infer_completer",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var infer = require('./infer');
var path = require('./path');
var KIND_DEFAULT = require('plugins/c9.ide.language.javascript/scope_analyzer').KIND_DEFAULT;
var KIND_PACKAGE = require('plugins/c9.ide.language.javascript/scope_analyzer').KIND_PACKAGE;
var KIND_EVENT = require('plugins/c9.ide.language.javascript/scope_analyzer').KIND_EVENT;
var PROPER = require('plugins/c9.ide.language.javascript/scope_analyzer').PROPER;
var EXPAND_STRING = 1;
var EXPAND_REQUIRE = 2;
var EXPAND_REQUIRE_LIMIT = 5;
var REQUIRE_PROPOSALS_MAX = 80;
var REQUIRE_ID_REGEX = /(?!["'])./;
var FunctionValue = require('./values').FunctionValue;
var completeUtil = require("plugins/c9.ide.language/complete_util");
var traverse = require("treehugger/traverse");
var args = require("./infer_arguments");
var astUpdater = require("./ast_updater");
var PRIORITY_INFER_LOW = 3;
var PRIORITY_INFER = 4;
var PRIORITY_INFER_TERN = 5;
var PRIORITY_INFER_HIGH = 6;

var completer = module.exports = Object.create(baseLanguageHandler);
var extraModuleCompletions;
    
completer.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

completer.getIdentifierRegex = function() {
    return (/[a-zA-Z_0-9\$\/]/);
};

completer.getCompletionRegex = function() {
    return (/^[\.]$/);
};

completer.getCacheCompletionRegex = function() {
    return new RegExp(
        "(\\b(if|while|for|switch)\\s*\\("
        + "|\\b\\w+\\s+"
        + "|(===?|!==?|[-+]=|[-+*%<>?!|&{[])"
        + "|\\s)+"
    );
};

completer.getMaxFileSizeSupported = function() {
    return .25 * 10 * 1000 * 80;
};

completer.setExtraModules = function(extraModules) {
    extraModuleCompletions = extraModules;
};

function valueToMatch(container, v, name, isPackage, isContextual) {
    if (isPackage)
        name = name.replace(/\.js$/, "");
    if ((v instanceof FunctionValue || v.properties._return) && !isPackage) {
        var showArgs = args.extractArgumentNames(v, true);
        var insertArgs = "opt" in showArgs ? args.extractArgumentNames(v, false) : showArgs;
        return {
            id: name,
            guid: v.guid + "[0" + name + "]",
            name: name + "(" + showArgs.argNames.join(", ") + ")",
            replaceText: name + (insertArgs.argNames.length === 0 && v.guid && v.guid.indexOf("es5:") !== 0 ? "()" : "(^^)"),
            icon: "method",
            priority: PRIORITY_INFER,
            inferredNames: showArgs.inferredNames,
            doc: v.doc,
            docUrl: v.docUrl,
            isFunction: true,
            type: v.properties._return && getGuid(v.properties._return.values[0]),
            isContextual: isContextual
        };
    }
    else {
        var isHighConfidence = 
            container && container.properties && container.properties["_" + name]
            && container.properties["_" + name].confidence >= 1;
        return {
            id: name,
            guid: container ? container.guid + "/" + name : v.guid + "[0" + name + "]",
            name: name,
            replaceText: name,
            doc: v.doc,
            docUrl: v.docUrl,
            icon: "property",
            priority: name === "__proto__" ? PRIORITY_INFER_LOW : PRIORITY_INFER,
            type: !isPackage && getGuid(v.properties.___proto__ ? v.properties.___proto__.values[0] : v.guid),
            isContextual: isHighConfidence
        };
    }
}

function getGuid(valueOrGuid) {
    if (!valueOrGuid)
        return;
    var result = valueOrGuid.guid || valueOrGuid;
    return result.substr && result.substr(-11) !== "/implReturn" ? result : undefined;
}

completer.predictNextCompletion = function(doc, fullAst, pos, options, callback) {
    if (!options.matches.length) {
        if (options.line[pos.column - 1] && /(?![{;})\]\s"'\+\-\*])./.test(options.line[pos.column - 1]))
            return callback(null, { predicted: "" });
    }
    var predicted = options.matches.filter(function(m) {
        return m.priority >= PRIORITY_INFER;
    });
    if (predicted.length !== 1 || predicted[0].icon === "method")
        return callback();
    callback(null, {
        predicted: predicted[0].replaceText + ".",
        showEarly: predicted[0].icon === "property" && !/\./.test(options.line)
    });
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    if (!options.node)
        return callback();
    var line = options.line;
    var identifier = options.identifierPrefix;
    var basePath = path.getBasePath(completer.path, completer.workspaceDir);
    var filePath = path.canonicalizePath(completer.path, basePath);
    if (fullAst.parent === undefined) {
        traverse.addParentPointers(fullAst);
        fullAst.parent = null;
    }
    astUpdater.updateOrReanalyze(doc, fullAst, filePath, basePath, pos, function(fullAst, currentNode) {
        var completions = {};
        var duplicates = {};
        currentNode.rewrite(
            'PropAccess(e, x)', function(b) {
                var allIdentifiers = [];
                var values = infer.inferValues(b.e);
                values.forEach(function(v) {
                    var propNames = v.getPropertyNames();
                    for (var i = 0; i < propNames.length; i++) {
                        if (propNames[i] !== b.x.value || v.isProperDeclaration(propNames[i]))
                            allIdentifiers.push(propNames[i]);
                    }
                });
                var matches = completeUtil.findCompletions(identifier, allIdentifiers);
                for (var i = 0; i < matches.length; i++) {
                    values.forEach(function(v) {
                        v.get(matches[i]).forEach(function(propVal) {
                            var match = valueToMatch(v, propVal, matches[i], false, true);
                            var duplicate = duplicates["_" + match.id];
                            if (duplicate && duplicate.inferredNames)
                                delete completions["_" + duplicate.guid];
                            if (duplicate && match.inferredNames)
                                return;
                            duplicates["_" + match.id] = completions["_" + match.guid] = match;
                        });
                    });
                }
                return this;
            },
            'FArg(_)', 'Function(_,_,_)', 'VarDeclInit(_,_)', 'VarDecl(_,_)',
            'ConstDeclInit(_,_)', 'ConstDecl(_,_)', function() { return this; },
            '_', function() {
                var me = this;
                if (this.traverseUp(
                    "Call(Var(\"require\"), args)",
                    function(b) {
                        if (b.args[0] !== me && this !== me)
                            return;
                        var scope = this[0].getAnnotation("scope");
                        var expand = b.args[0] && b.args[0].cons === "String" ? null : EXPAND_STRING;
                        identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, REQUIRE_ID_REGEX);

                        var useBasePath = path.isRelativePath(identifier) || path.isAbsolutePath(identifier) ? basePath : null;
                        completer.proposeRequire(identifier, expand, scope, completions, useBasePath);
                    }))
                    return this;
            },
            'ERROR()', 'PropertyInit(x,e)', 'ObjectInit(ps)', function(b, node) {
                if (b.ps) {
                    completer.proposeObjectProperty(node, identifier, completions);
                }
                else if (!b.x) {
                    if (currentNode.parent.cons !== "PropertyInit")
                        return; // Fallthrough
                    currentNode = currentNode.parent;
                    b.x = currentNode[0];
                    b.e = currentNode[1];
                }
                var objectInit = currentNode.parent.parent;
                if (!objectInit.parent || !objectInit.parent.parent || objectInit.parent.parent.cons !== "Call")
                    return node;
                completer.proposeObjectProperty(objectInit, identifier, completions);
                return node;
            },
            'Call(_, _)', function(b) {
                if ("function".indexOf(identifier) === 0)
                    completer.proposeClosure(this, doc, pos, completions);
            },
            'Var(_)', function(b) {
                if (this.parent.parent && this.parent.parent.isMatch('Call(_, _)') && "function".indexOf(identifier) === 0)
                    completer.proposeClosure(this.parent.parent, doc, pos, completions);
            },
            'Var(_)', function(b) {
                this.parent.rewrite('VarDeclInit(x, _)', 'ConstDeclInit(x, _)', function(b) {
                    if ("require".indexOf(identifier) !== 0)
                        return;
                    var scope = this.getAnnotation("scope");
                    completer.proposeRequire(b.x.value, EXPAND_REQUIRE, scope, completions);
                    completer.proposeRequire(b.x.value, EXPAND_REQUIRE, scope, completions, basePath);
                });
            },
            function() {
                var scope;
                this.traverseUp(function() {
                    if (!scope) scope = this.getAnnotation("scope");
                    if (this.rewrite("String(_)")) return this;
                });
                if (!scope)
                    return;
                var variableNames = scope.getVariableNames();
                if (this.cons === 'Var') { // Delete current var from proposals if not properly declared anywhere
                    var varName = this[0].value;
                    if (variableNames.indexOf(varName) !== -1 && (!scope.get(varName) || !scope.get(varName).isProperDeclaration()))
                        variableNames.splice(variableNames.indexOf(varName), 1);
                }
                var matches = completeUtil.findCompletions(identifier, variableNames);
                for (var i = 0; i < matches.length; i++) {
                    var v = scope.get(matches[i]);
                    if (!v)
                        continue;
                    if (!v.values.length && v.properDeclarationConfidence >= PROPER && currentNode.cons === "Var") {
                        completions[matches[i]] = {
                            id: matches[i],
                            name: matches[i],
                            replaceText: matches[i],
                            icon: "property",
                            priority: PRIORITY_INFER_TERN
                        };
                    }
                    v.values.forEach(function(propVal) {
                        var match = valueToMatch(null, propVal, matches[i]);
                        if (!match.name)
                            return;
                        var duplicate = duplicates["_" + match.id];
                        if (duplicate && duplicate.inferredNames)
                            delete completions["_" + duplicate.guid];
                        if (duplicate && match.inferredNames)
                            return;
                        duplicates["_" + match.id] = completions["_" + match.guid] = match;
                    });
                }
            }
        );
        var completionsArray = [];
        for (var id in completions) {
            completionsArray.push(completions[id]);
        }
        callback(completionsArray);
    });
};
completer.proposeRequire = function(identifier, expand, scope, completions, basePath) {
    var names = scope.getNamesByKind(KIND_PACKAGE);
    
    if (basePath || basePath === "")
        identifier = path.canonicalizePath(identifier, basePath).replace(/^\.$/, "");
    
    if (expand === EXPAND_REQUIRE && extraModuleCompletions)
        names = names.concat(Object.keys(extraModuleCompletions));

    var matches = expand === EXPAND_REQUIRE
        ? filterRequireSubstring(identifier, names)
        : completeUtil.findCompletions(identifier === "/" ? "" : identifier, names);
    
    if (basePath || basePath === "")
        matches = matches.filter(function(v) { return v.match(/\.js$/) && !v.match(/(\/|^)node_modules\//); });
    else
        matches = matches.filter(function(v) { return !v.match(/\.js$/); });
    
    if (expand === EXPAND_REQUIRE && matches.length > EXPAND_REQUIRE_LIMIT)
        return;

    matches = matches.slice(0, REQUIRE_PROPOSALS_MAX);

    for (var i = 0; i < matches.length; i++) {
        var match = matches[i];
        var v = scope.get(match, KIND_PACKAGE);
        if (!v && expand === EXPAND_REQUIRE) {
            return completions["_" + match] = {
                id: match,
                icon: "package",
                name: 'require("' + match + '")',
                replaceText: 'require("' + match + '")',
                doc: "Origin: node<br/>"
                    + (extraModuleCompletions[match].doc || ""),
                priority: PRIORITY_INFER_HIGH
            };
        }
        v.values.forEach(function(propVal) {
            var match = valueToMatch(null, propVal, matches[i], true, expand);
            match.icon = "package";
            if (identifier.match(/^\//))
                match.replaceText = match.name = "/" + match.replaceText;
            else if (basePath || basePath === "")
                match.replaceText = match.name = path.uncanonicalizePath(match.replaceText, basePath);
            completions["_" + match.guid] = match;
            if (expand === EXPAND_REQUIRE) {
                match.replaceText = 'require("' + match.replaceText + '")';
                match.name = 'require("' + match.name + '")';
            }
            if (expand === EXPAND_STRING)
                match.replaceText = '"' + match.replaceText + '"';
            if (expand !== EXPAND_REQUIRE)
                match.identifierRegex = REQUIRE_ID_REGEX;
        });
    }
};

completer.proposeClosure = function(node, doc, pos, completions) {
    node.rewrite('Call(f, args)', function(b) {
        var argIndex = args.getArgIndex(this, doc, pos);
        var id = 0;
        infer.inferValues(b.f).forEach(function(v) {
            var argNames = args.extractArgumentNames(v, false);
            var code = argNames.argValueCodes[argIndex];
            if (!code)
                return;
            var codeName = code.split(/\n/)[0] + "}";
            var guid = v.guid + "-argfun" + (id++);
            completions[guid] = {
                id: codeName,
                guid: guid,
                name: codeName,
                replaceText: code,
                doc: v.fargs && v.fargs.doc,
                docUrl: v.fargs && v.fargs.docUrl,
                icon: "method",
                priority: PRIORITY_INFER_HIGH
            };
        });
    });
};
completer.proposeObjectProperty = function(objectInit, identifier, completions) {
    var listIndex;
    for (var i = 0; i < objectInit.parent.length; i++)
        if (objectInit.parent[i] === objectInit) listIndex = i;
    var call = objectInit.parent.parent;
    infer.inferValues(call[0]).forEach(function(v) {
        if (!v.fargs || !v.fargs[listIndex] || !v.fargs[listIndex].properties)
            return;
        v.fargs[listIndex].properties.forEach(function(property) {
            completions["_$p$" + property.id] = {
                id: property.id,
                name: property.id,
                replaceText: property.id,
                doc: property.doc,
                docUrl: property.docUrl,
                icon: "property",
                priority: PRIORITY_INFER
            };
        });
    });
};

function filterRequireSubstring(name, names) {
    var nameClean = name.replace(/[^A-Za-z0-9_-]/g, ".");
    var nameRegex = new RegExp("^" + nameClean + "\\b|\\b" + nameClean + "$");
    return names.filter(function(n) {
        return nameRegex.test(n);
    });
}

});

define("tern/plugin/doc_comment",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("../lib/comment"),
               require("acorn"), require("acorn/dist/walk"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "../lib/comment", "acorn/dist/acorn", "acorn/dist/walk"], mod);
  mod(tern, tern, tern.comment, acorn, acorn.walk);
})(function(infer, tern, comment, acorn, walk) {
  "use strict";

  var WG_MADEUP = 1, WG_STRONG = 101;

  tern.registerPlugin("doc_comment", function(server, options) {
    server.mod.jsdocTypedefs = Object.create(null);
    server.on("reset", function() {
      server.mod.jsdocTypedefs = Object.create(null);
    });
    server.mod.docComment = {
      weight: options && options.strong ? WG_STRONG : undefined,
      fullDocs: options && options.fullDocs
    };

    server.on("postParse", postParse)
    server.on("postInfer", postInfer)
    server.on("postLoadDef", postLoadDef)
  });

  function postParse(ast, text) {
    function attachComments(node) { comment.ensureCommentsBefore(text, node); }

    walk.simple(ast, {
      VariableDeclaration: attachComments,
      FunctionDeclaration: attachComments,
      MethodDefinition: attachComments,
      Property: attachComments,
      AssignmentExpression: function(node) {
        if (node.operator == "=") attachComments(node);
      },
      CallExpression: function(node) {
        if (isDefinePropertyCall(node)) attachComments(node);
      }
    });
  }

  function isDefinePropertyCall(node) {
    return node.callee.type == "MemberExpression" &&
      node.callee.object.name == "Object" &&
      node.callee.property.name == "defineProperty" &&
      node.arguments.length >= 3 &&
      typeof node.arguments[1].value == "string";
  }

  function postInfer(ast, scope) {
    jsdocParseTypedefs(ast.sourceFile.text, scope);

    walk.simple(ast, {
      VariableDeclaration: function(node, scope) {
        var decl = node.declarations[0].id
        if (node.commentsBefore && decl.type == "Identifier")
          interpretComments(node, node.commentsBefore, scope,
                            scope.getProp(node.declarations[0].id.name));
      },
      FunctionDeclaration: function(node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
                            scope.getProp(node.id.name),
                            node.scope.fnType);
      },
      ClassDeclaration: function(node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
                            scope.getProp(node.id.name),
                            node.objType);
      },
      AssignmentExpression: function(node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
                            infer.expressionType({node: node.left, state: scope}));
      },
      ObjectExpression: function(node, scope) {
        for (var i = 0; i < node.properties.length; ++i) {
          var prop = node.properties[i], name = infer.propName(prop)
          if (name != "<i>" && prop.commentsBefore)
            interpretComments(prop, prop.commentsBefore, scope, node.objType.getProp(name))
        }
      },
      Class: function(node, scope) {
        var proto = node.objType.getProp("prototype").getObjType()
        if (!proto) return
        for (var i = 0; i < node.body.body.length; i++) {
          var method = node.body.body[i], name
          if (!method.commentsBefore) continue
          if (method.kind == "constructor")
            interpretComments(method, method.commentsBefore, scope, node.objType)
          else if ((name = infer.propName(method)) != "<i>")
            interpretComments(method, method.commentsBefore, scope, proto.getProp(name))
        }
      },
      CallExpression: function(node, scope) {
        if (node.commentsBefore && isDefinePropertyCall(node)) {
          var type = infer.expressionType({node: node.arguments[0], state: scope}).getObjType();
          if (type && type instanceof infer.Obj) {
            var prop = type.props[node.arguments[1].value];
            if (prop) interpretComments(node, node.commentsBefore, scope, prop);
          }
        }
      }
    }, infer.searchVisitor, scope);
  }

  function postLoadDef(data) {
    var defs = data["!typedef"];
    var cx = infer.cx(), orig = data["!name"];
    if (defs) for (var name in defs)
      cx.parent.mod.jsdocTypedefs[name] =
        maybeInstance(infer.def.parse(defs[name], orig, name), name);
  }
  function stripLeadingChars(lines) {
    for (var head, i = 1; i < lines.length; i++) {
      var line = lines[i], lineHead = line.match(/^[\s\*]*/)[0];
      if (lineHead != line) {
        if (head == null) {
          head = lineHead;
        } else {
          var same = 0;
          while (same < head.length && head.charCodeAt(same) == lineHead.charCodeAt(same)) ++same;
          if (same < head.length) head = head.slice(0, same)
        }
      }
    }
    lines = lines.map(function(line, i) {
      line = line.replace(/\s+$/, "");
      if (i == 0 && head != null) {
        for (var j = 0; j < head.length; j++) {
          var found = line.indexOf(head.slice(j));
          if (found == 0) return line.slice(head.length - j);
        }
      }
      if (head == null || i == 0) return line.replace(/^[\s\*]*/, "");
      if (line.length < head.length) return "";
      return line.slice(head.length);
    });
    while (lines.length && !lines[lines.length - 1]) lines.pop();
    while (lines.length && !lines[0]) lines.shift();
    return lines;
  }

  function interpretComments(node, comments, scope, aval, type) {
    jsdocInterpretComments(node, scope, aval, comments);
    var cx = infer.cx();

    if (!type && aval instanceof infer.AVal && aval.types.length) {
      type = aval.types[aval.types.length - 1];
      if (!(type instanceof infer.Obj) || type.origin != cx.curOrigin || type.doc)
        type = null;
    }

    for (var i = comments.length - 1; i >= 0; i--) {
      var text = stripLeadingChars(comments[i].split(/\r\n?|\n/)).join("\n");
      if (text) {
        if (aval instanceof infer.AVal) aval.doc = text;
        if (type) type.doc = text;
        break;
      }
    }
  }
  function skipSpace(str, pos) {
    while (/\s/.test(str.charAt(pos))) ++pos;
    return pos;
  }

  function isIdentifier(string) {
    if (!acorn.isIdentifierStart(string.charCodeAt(0))) return false;
    for (var i = 1; i < string.length; i++)
      if (!acorn.isIdentifierChar(string.charCodeAt(i))) return false;
    return true;
  }

  function parseLabelList(scope, str, pos, close) {
    var labels = [], types = [], madeUp = false;
    for (var first = true; ; first = false) {
      pos = skipSpace(str, pos);
      if (first && str.charAt(pos) == close) break;
      var colon = str.indexOf(":", pos);
      if (colon < 0) return null;
      var label = str.slice(pos, colon);
      if (!isIdentifier(label)) return null;
      labels.push(label);
      pos = colon + 1;
      var type = parseType(scope, str, pos);
      if (!type) return null;
      pos = type.end;
      madeUp = madeUp || type.madeUp;
      types.push(type.type);
      pos = skipSpace(str, pos);
      var next = str.charAt(pos);
      ++pos;
      if (next == close) break;
      if (next != ",") return null;
    }
    return {labels: labels, types: types, end: pos, madeUp: madeUp};
  }

  function parseTypeAtom(scope, str, pos) {
    var result = parseTypeInner(scope, str, pos)
    if (!result) return null
    if (str.slice(result.end, result.end + 2) == "[]")
      return {madeUp: result.madeUp, end: result.end + 2, type: new infer.Arr(result.type)}
    else return result
  }

  function parseType(scope, str, pos) {
    var type, union = false, madeUp = false;
    for (;;) {
      var inner = parseTypeAtom(scope, str, pos);
      if (!inner) return null;
      madeUp = madeUp || inner.madeUp;
      if (union) inner.type.propagate(union);
      else type = inner.type;
      pos = skipSpace(str, inner.end);
      if (str.charAt(pos) != "|") break;
      pos++;
      if (!union) {
        union = new infer.AVal;
        type.propagate(union);
        type = union;
      }
    }
    var isOptional = false;
    if (str.charAt(pos) == "=") {
      ++pos;
      isOptional = true;
    }
    return {type: type, end: pos, isOptional: isOptional, madeUp: madeUp};
  }

  function parseTypeInner(scope, str, pos) {
    pos = skipSpace(str, pos);
    var type, madeUp = false;

    if (str.indexOf("function(", pos) == pos) {
      var args = parseLabelList(scope, str, pos + 9, ")"), ret = infer.ANull;
      if (!args) return null;
      pos = skipSpace(str, args.end);
      if (str.charAt(pos) == ":") {
        ++pos;
        var retType = parseType(scope, str, pos + 1);
        if (!retType) return null;
        pos = retType.end;
        ret = retType.type;
        madeUp = retType.madeUp;
      }
      type = new infer.Fn(null, infer.ANull, args.types, args.labels, ret);
    } else if (str.charAt(pos) == "[") {
      var inner = parseType(scope, str, pos + 1);
      if (!inner) return null;
      pos = skipSpace(str, inner.end);
      madeUp = inner.madeUp;
      if (str.charAt(pos) != "]") return null;
      ++pos;
      type = new infer.Arr(inner.type);
    } else if (str.charAt(pos) == "{") {
      var fields = parseLabelList(scope, str, pos + 1, "}");
      if (!fields) return null;
      type = new infer.Obj(true);
      for (var i = 0; i < fields.types.length; ++i) {
        var field = type.defProp(fields.labels[i]);
        field.initializer = true;
        fields.types[i].propagate(field);
      }
      pos = fields.end;
      madeUp = fields.madeUp;
    } else if (str.charAt(pos) == "(") {
      var inner = parseType(scope, str, pos + 1);
      if (!inner) return null;
      pos = skipSpace(str, inner.end);
      if (str.charAt(pos) != ")") return null;
      ++pos;
      type = inner.type;
    } else {
      var start = pos;
      if (!acorn.isIdentifierStart(str.charCodeAt(pos))) return null;
      while (acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;
      if (start == pos) return null;
      var word = str.slice(start, pos);
      if (/^(number|integer)$/i.test(word)) type = infer.cx().num;
      else if (/^bool(ean)?$/i.test(word)) type = infer.cx().bool;
      else if (/^string$/i.test(word)) type = infer.cx().str;
      else if (/^(null|undefined)$/i.test(word)) type = infer.ANull;
      else if (/^array$/i.test(word)) {
        var inner = null;
        if (str.charAt(pos) == "." && str.charAt(pos + 1) == "<") {
          var inAngles = parseType(scope, str, pos + 2);
          if (!inAngles) return null;
          pos = skipSpace(str, inAngles.end);
          madeUp = inAngles.madeUp;
          if (str.charAt(pos++) != ">") return null;
          inner = inAngles.type;
        }
        type = new infer.Arr(inner);
      } else if (/^object$/i.test(word)) {
        type = new infer.Obj(true);
        if (str.charAt(pos) == "." && str.charAt(pos + 1) == "<") {
          var key = parseType(scope, str, pos + 2);
          if (!key) return null;
          pos = skipSpace(str, key.end);
          madeUp = madeUp || key.madeUp;
          if (str.charAt(pos++) != ",") return null;
          var val = parseType(scope, str, pos);
          if (!val) return null;
          pos = skipSpace(str, val.end);
          madeUp = key.madeUp || val.madeUp;
          if (str.charAt(pos++) != ">") return null;
          val.type.propagate(type.defProp("<i>"));
        }
      } else {
        while (str.charCodeAt(pos) == 46 ||
               acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;
        var path = str.slice(start, pos);
        var cx = infer.cx(), defs = cx.parent && cx.parent.mod.jsdocTypedefs, found;
        if (defs && (path in defs)) {
          type = defs[path];
        } else if (found = infer.def.parsePath(path, scope).getObjType()) {
          type = maybeInstance(found, path);
        } else {
          if (!cx.jsdocPlaceholders) cx.jsdocPlaceholders = Object.create(null);
          if (!(path in cx.jsdocPlaceholders))
            type = cx.jsdocPlaceholders[path] = new infer.Obj(null, path);
          else
            type = cx.jsdocPlaceholders[path];
          madeUp = true;
        }
      }
    }

    return {type: type, end: pos, madeUp: madeUp};
  }

  function maybeInstance(type, path) {
    if (type instanceof infer.Fn && /(?:^|\.)[A-Z][^\.]*$/.test(path)) {
      var proto = type.getProp("prototype").getObjType();
      if (proto instanceof infer.Obj) return infer.getInstance(proto);
    }
    return type;
  }

  function parseTypeOuter(scope, str, pos) {
    pos = skipSpace(str, pos || 0);
    if (str.charAt(pos) != "{") return null;
    var result = parseType(scope, str, pos + 1);
    if (!result) return null;
    var end = skipSpace(str, result.end);
    if (str.charAt(end) != "}") return null;
    result.end = end + 1;
    return result;
  }

  function jsdocInterpretComments(node, scope, aval, comments) {
    var type, args, ret, foundOne, self, parsed;

    for (var i = 0; i < comments.length; ++i) {
      var comment = comments[i];
      var decl = /(?:\n|$|\*)\s*@(type|param|arg(?:ument)?|returns?|this|class|constructor)\s+(.*)/g, m;
      while (m = decl.exec(comment)) {
        if (m[1] == "class" || m[1] == "constructor") {
          self = foundOne = true;
          continue;
        }

        if (m[1] == "this" && (parsed = parseType(scope, m[2], 0))) {
          self = parsed;
          foundOne = true;
          continue;
        }

        if (!(parsed = parseTypeOuter(scope, m[2]))) continue;
        foundOne = true;

        switch(m[1]) {
        case "returns": case "return":
          ret = parsed; break;
        case "type":
          type = parsed; break;
        case "param": case "arg": case "argument":
            var name = m[2].slice(parsed.end).match(/^\s*(\[?)\s*([^\]\s=]+)\s*(?:=[^\]]+\s*)?(\]?).*/);
            if (!name) continue;
            var argname = name[2] + (parsed.isOptional || (name[1] === '[' && name[3] === ']') ? "?" : "");
          (args || (args = Object.create(null)))[argname] = parsed;
          break;
        }
      }
    }

    if (foundOne) applyType(type, self, args, ret, node, aval);
  };

  function jsdocParseTypedefs(text, scope) {
    var cx = infer.cx();

    var re = /\s@typedef\s+(.*)/g, m;
    while (m = re.exec(text)) {
      var parsed = parseTypeOuter(scope, m[1]);
      var name = parsed && m[1].slice(parsed.end).match(/^\s*(\S+)/);
      if (name && parsed.type instanceof infer.Obj) {
        var rest = text.slice(m.index + m[0].length)
        while (m = /\s+@prop(?:erty)?\s+(.*)/.exec(rest)) {
          var propType = parseTypeOuter(scope, m[1]), propName
          if (propType && (propName = m[1].slice(propType.end).match(/^\s*(\S+)/)))
            propType.type.propagate(parsed.type.defProp(propName[1]))
          rest = rest.slice(m[0].length)
        }
        cx.parent.mod.jsdocTypedefs[name[1]] = parsed.type;
      }
    }
  }

  function propagateWithWeight(type, target) {
    var weight = infer.cx().parent.mod.docComment.weight;
    type.type.propagate(target, weight || (type.madeUp ? WG_MADEUP : undefined));
  }

  function isFunExpr(node) { return node.type == "FunctionExpression" || node.type == "ArrowFunctionExpression" }

  function applyType(type, self, args, ret, node, aval) {
    var fn;
    if (node.type == "VariableDeclaration") {
      var decl = node.declarations[0];
      if (decl.init && isFunExpr(decl.init)) fn = decl.init.scope.fnType;
    } else if (node.type == "FunctionDeclaration") {
      fn = node.scope.fnType;
    } else if (node.type == "AssignmentExpression") {
      if (isFunExpr(node.right))
        fn = node.right.scope.fnType;
    } else if (node.type == "CallExpression") {
    } else { // An object property
      if (isFunExpr(node.value)) fn = node.value.scope.fnType;
      else if (fn = aval.types && aval.types[0] && aval.types[0].args)
        fn = aval.types[0];
    }

    if (fn && (args || ret || self)) {
      if (args) for (var i = 0; i < fn.argNames.length; ++i) {
        var name = fn.argNames[i], known = args[name];
        if (!known && (known = args[name + "?"]))
          fn.argNames[i] += "?";
        if (known) propagateWithWeight(known, fn.args[i]);
      }
      if (ret) {
        if (fn.retval == infer.ANull) fn.retval = new infer.AVal;
        propagateWithWeight(ret, fn.retval);
      }
      if (self === true) {
        var proto = fn.getProp("prototype").getObjType();
        self = proto && {type: infer.getInstance(proto, fn)};
      }
      if (self) propagateWithWeight(self, fn.self);
    } else if (type) {
      propagateWithWeight(type, aval);
    }
  };
});

});

define("tern/plugin/modules",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("../lib/signal"), require)
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "../lib/signal"], mod)
  mod(tern, tern, tern.signal)
})(function(infer, tern, signal, require) {
  "use strict"

  function Modules(server, options) {
    this.server = server
    this.options = options || {}
    this.modules = Object.create(null)
    this.nonRelative = Object.create(null)
    this.knownModules = Object.create(null)
    this.resolvers = []
    this.modNameTests = []
    this.importTests = []
  }

  Modules.prototype = signal.mixin({
    buildWrappingScope: function(parent, origin, node) {
      var scope = new infer.Scope(parent, node)
      scope.origin = origin
      this.signal("wrapScope", scope)
      return scope
    },

    maybeOverride: function(name) {
      if (!this.options.modules || !this.options.modules.hasOwnProperty(name))
        return false
      if (this.modules[name]) return this.modules[name]

      var override = this.options.modules[name]
      if (typeof(override) == "string" && override.charAt(0) == "=")
        return infer.def.parsePath(override.slice(1))

      var scope = this.buildWrappingScope(infer.cx().topScope, name)
      infer.def.load(override, scope)
      return this.modules[name] = scope.exports
    },

    resolveModule: function(name, parentFile) {
      var over = this.maybeOverride(name)
      if (over) return over
      var known = this.knownModules[name]
      if (known) return known
      if (this.options.dontLoad == true ||
          this.options.dontLoad && new RegExp(this.options.dontLoad).test(name) ||
          this.options.load && !new RegExp(this.options.load).test(name))
        return infer.ANull

      var resolved, relative = isRelative(name)
      for (var i = 0; !resolved && i < this.resolvers.length; i++)
        resolved = this.resolvers[i](name, parentFile)
      if (!resolved) resolved = defaultResolver(name, parentFile)
      if (!resolved) return infer.ANull
      if (typeof resolved != "string") {
        if (!relative) this.nonRelative[name] = true
        return resolved
      }

      var known = this.modules[resolved]
      if (known) return known

      if (/\.js$|(?:^\/)[^\.]+$/.test(resolved))
        this.server.addFile(resolved, null, parentFile)
      if (!relative) this.nonRelative[name] = resolved
      return this.modules[resolved] = new infer.AVal
    },

    findIn: function(array, node) {
      for (var i = 0; i < array.length; i++) {
        var name = array[i](node)
        if (name != null) return name
      }
    },

    isModName: function(node) { return this.findIn(this.modNameTests, node) },
    isImport: function(node) { return this.findIn(this.importTests, node) },

    get: function(name) {
      return this.modules[name] || (this.modules[name] = new infer.AVal)
    },

    completeModuleName: function(completions, query, word) {
      function fromObj(obj, useVal) {
        for (var name in obj)
          if (filter(word, name, query))
            tern.addCompletion(query, completions, name, useVal && obj[name])
      }

      fromObj(this.knownModules, true)
      if (this.options.modules) fromObj(this.options.modules, false)

      var pathsSeen = Object.create(null)
      for (var prop in this.nonRelative) {
        var val = this.nonRelative[prop]
        if (val == true || prop.indexOf("/") == -1) {
          if (filter(word, prop, query)) tern.addCompletion(query, completions, prop)
        } else if (prop.indexOf(word) == 0 && word.indexOf("/") > -1) {
          var afterSlash = /.*?\/(.*)/.exec(prop)[1]
          var found = val.indexOf(afterSlash)
          if (found > -1) {
            var dir = val.slice(0, found) + (/.*?\/(.*\/)?/.exec(word)[1] || "")
            if (dir in pathsSeen) continue
            pathsSeen[dir] = true
            this.completeFileName(completions, query, null, word, dir)
          }
        }
      }
    },

    completeFileName: function(completions, query, parentFile, word, _dir) {
      var path = parentFile ? resolvePath(dirName(parentFile), word) : baseName(word)
      for (var prop in this.modules) {
        if (prop != parentFile && filter(path, prop, query)) {
          if (/\.js$/.test(prop)) prop = prop.slice(0, prop.length - 3)
          var added = prop.slice(path.length)
          tern.addCompletion(query, completions, word + added, this.modules[prop])
        }
      }
    },

    getModType: function(node) {
      var modName = this.isModName(node), imp, prop
      if (modName == null && (imp = this.isImport(node))) {
        modName = imp.name
        prop = imp.prop
      }
      if (modName == null) return

      var modType = this.resolveModule(modName, node.sourceFile.name)
      return (prop ? modType.getProp(prop) : modType).getType()
    }
  })

  function resolvePath(parent, sub) {
    if (/^https?:|^\//.test(sub)) return sub
    if (parent && !/\/$/.test(parent)) parent = parent + "/"
    var m
    while (m = /^\.(\.)?\//.exec(sub)) {
      if (m[1] && parent.length > 1) {
        var lastSlash = parent.lastIndexOf("/", parent.length - 2)
        parent = lastSlash == -1 ? "" : parent.slice(0, lastSlash + 1)
      }
      sub = sub.slice(m[0].length)
    }
    return parent + sub
  }

  function dirName(path) {
    var lastSlash = path.lastIndexOf("/")
    if (lastSlash == -1) return ""
    return path.slice(0, lastSlash + 1)
  }
  function baseName(path) {
    var lastSlash = path.lastIndexOf("/")
    if (lastSlash == -1) return path
    else return path.slice(lastSlash + 1)
  }

  function defaultResolver(name, parentFile) {
    if (!/^\.\.?\//.test(name)) return
    var path = resolvePath(dirName(parentFile), name)
    var server = infer.cx().parent
    if (server.findFile(path)) return path
    if (server.findFile(path + ".js")) return path + ".js"
  }
  if (require) (function() {
    var fs = require("fs"), path = require("path")

    Modules.prototype.completeFileName = function(completions, query, parentFile, word, dir) {
      var pDir = this.server.projectDir
      var endSlash = /\/$/.test(word)
      if (parentFile) {
        var pt = path.resolve(pDir, path.dirname(parentFile), word)
        dir = endSlash ? pt : path.dirname(pt)
      }
      var base = endSlash ? word : path.dirname(word) + "/"
      var filePart = endSlash ? "" : path.basename(word)

      var me = this
      fs.readdirSync(dir).forEach(function(file) {
        if (/^\./.test(file)) return
        if (filter(filePart, file, query)) {
          var projectPath = me.server.normalizeFilename(path.relative(pDir, path.resolve(dir, file)))
          if (projectPath == parentFile) return
          var value = me.modules[projectPath]
          if (/\.js$/.test(file)) file = file.slice(0, file.length - 3)
          tern.addCompletion(query, completions, base + file, value)
        }
      })
    }
  }())

  function isRelative(path) {
    return /^\.\.?\//.test(path)
  }

  function filter(word, string, query) {
    return query.filter === false || !word ||
      (query.caseInsensitive ? string.toLowerCase() : string).indexOf(word) == 0
  }

  function preCondenseReach(state) {
    var mods = infer.cx().parent.mod.modules.modules
    var node = state.roots["!modules"] = new infer.Obj(null)
    for (var name in mods) {
      var mod = mods[name]
      var id = mod.origin || name
      var prop = node.defProp(id.replace(/\./g, "`"))
      prop.origin = mod.origin
      mod.propagate(prop)
    }
  }

  function postLoadDef(data) {
    var cx = infer.cx(), me = cx.parent.mod.modules
    var mods = cx.definitions[data["!name"]]["!modules"]
    if (mods) for (var name in mods.props) {
      var origin = name.replace(/`/g, ".")
      var mod = me.get(origin)
      mod.origin = origin
      mods.props[name].propagate(mod)
    }
    var known = cx.definitions[data["!name"]]["!known_modules"]
    if (known) for (var name in known.props)
      me.knownModules[name.replace(/`/g, ".")] = known.props[name]
  }

  function findTypeAt(_file, _pos, expr, type) {
    if (!expr) return type
    var me = infer.cx().parent.mod.modules
    var modType = me.getModType(expr.node)
    if (!modType) return type
    type = Object.create(type)
    type.origin = modType.origin
    type.originNode = modType.originNode
    if (modType.doc) type.doc = modType.doc
    if (modType.url) type.url = modType.url
    return type
  }
  function findCompletions(file, query) {
    var wordEnd = tern.resolvePos(file, query.end)
    var expr = infer.findExpressionAround(file.ast, null, wordEnd, file.scope)
    if (!expr) return null
    var me = infer.cx().parent.mod.modules

    if (me.isModName(expr.node) != null)
      return findModuleCompletions(me, file, query, expr.node, wordEnd)

    var imp = me.isImport(expr.node)
    if (imp && imp.name && imp.prop != null)
      return findImportCompletions(me, file, query, expr.node, imp, wordEnd)
  }

  function findImportCompletions(me, file, query, node, imp, wordEnd) {
    var completions = []
    var word = node.name.slice(0, wordEnd - node.start)
    if (query.caseInsensitive) word = word.toLowerCase()

    var modType = me.resolveModule(imp.name, node.sourceFile.name).getType()
    if (!modType) return null
    infer.forAllPropertiesOf(modType, function(prop, obj, depth) {
      if (obj == infer.cx().protos.Object) return
      if (query.filter !== false && word &&
          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return
      tern.addCompletion(query, completions, prop, obj && obj.props[prop], depth)
    })
    return {
      start: tern.outputPos(query, file, node.start),
      end: tern.outputPos(query, file, wordEnd),
      completions: completions,
      isSpecifier: true
    }
  }

  function findModuleCompletions(me, file, query, argNode, wordEnd) {
    if (argNode.type != "Literal" || typeof argNode.value != "string" ||
        argNode.start > wordEnd || argNode.end < wordEnd) return

    var word = argNode.raw.slice(1, wordEnd - argNode.start), quote = argNode.raw.charAt(0)
    if (word && word.charAt(word.length - 1) == quote)
      word = word.slice(0, word.length - 1)
    if (query.caseInsensitive) word = word.toLowerCase()

    var completions = []
    if (isRelative(word)) me.completeFileName(completions, query, file.name, word)
    else me.completeModuleName(completions, query, word)

    if (argNode.end == wordEnd + 1 && file.text.charAt(wordEnd) == quote)
      ++wordEnd
    return {
      start: tern.outputPos(query, file, argNode.start),
      end: tern.outputPos(query, file, wordEnd),
      isProperty: false,
      completions: completions.map(function(rec) {
        var name = typeof rec == "string" ? rec : rec.name
        var string = JSON.stringify(name)
        if (quote == "'") string = quote + string.slice(1, string.length -1).replace(/'/g, "\\'") + quote
        if (typeof rec == "string") return string
        rec.displayName = name
        rec.name = string
        return rec
      })
    }
  }

  tern.registerPlugin("modules", function(server, options) {
    server.mod.modules = new Modules(server, options)

    server.on("beforeLoad", function(file) {
      file.scope = this.mod.modules.buildWrappingScope(file.scope, file.name, file.ast)
    })

    server.on("afterLoad", function(file) {
      var mod = this.mod.modules.get(file.name)
      mod.origin = file.name
      this.mod.modules.signal("getExports", file, mod)
    })

    server.on("reset", function() {
      this.mod.modules.modules = Object.create(null)
    })

    server.on("preCondenseReach", preCondenseReach)
    server.on("postLoadDef", postLoadDef)
    server.on("typeAt", findTypeAt)
    server.on("completion", findCompletions)
  })

  tern.defineQueryType("exports", {
    takesFile: true,
    run: function(server, query, file) {
      function describe(aval) {
        var target = {}, type = aval.getType(false)
        target.type = infer.toString(type, 3)
        var doc = aval.doc || (type && type.doc), url = aval.url || (type && type.url)
        if (doc) target.doc = doc
        if (url) target.url = url
        var span = tern.getSpan(aval) || (type && tern.getSpan(type))
        if (span) tern.storeSpan(server, query, span, target)
        return target
      }

      var mod = server.mod.modules, known = mod && mod.modules[file.name]
      if (!known) return {}
      var resp = describe(known);
      var type = known.getType(false)
      if (type instanceof infer.Obj) {
        var props = resp.props = {}
        for (var prop in type.props)
          props[prop] = describe(type.props[prop])
      }
      return resp
    }
  })
})

});

define("tern/plugin/es_modules",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("acorn/dist/walk"), require("./modules"))
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "acorn/dist/walk", "./modules"], mod)
  mod(tern, tern, acorn.walk)
})(function(infer, tern, walk) {
  "use strict"

  var WG_IMPORT_DEFAULT_FALLBACK = 80

  function connectModule(file, out) {
    var modules = infer.cx().parent.mod.modules
    var outObj = null
    function exp(prop, type, originNode) {
      if (!outObj) {
        outObj = new infer.Obj(true)
        outObj.origin = file.name
        outObj.originNode = file.ast
        out.addType(outObj)
      }
      type.propagate(outObj.defProp(prop, originNode))
    }

    walk.simple(file.ast, {
      ImportDeclaration: function(node) {
        var input = modules.resolveModule(node.source.value, file.name)
        for (var i = 0; i < node.specifiers.length; i++) {
          var spec = node.specifiers[i]
          var aval = file.scope.getProp(spec.local.name)
          if (spec.type == "ImportNamespaceSpecifier") {
            input.propagate(aval)
          } else if (spec.type == "ImportDefaultSpecifier") {
            input.getProp("default").propagate(aval)
            input.propagate(aval, WG_IMPORT_DEFAULT_FALLBACK)
          } else {
            input.getProp(spec.imported.name).propagate(aval)
          }
        }
      },
      ExportAllDeclaration: function(node) {
        var input = modules.resolveModule(node.source.value, file.name)
        input.forAllProps(function(prop, val, local) {
          if (local) exp(prop, val, val.originNode)
        })
      },
      ExportDefaultDeclaration: function(node) {
        var decl = node.declaration.id || node.declaration
        exp("default", infer.expressionType({node: decl, state: file.scope}), decl)
      },
      ExportNamedDeclaration: function(node) {
        var decl = node.declaration
        if (decl) {
          if (decl.type == "VariableDeclaration") {
            for (var i = 0; i < decl.declarations.length; ++i) {
              var cur = decl.declarations[i]
              if (cur.id.type == "Identifier")
                exp(cur.id.name, file.scope.getProp(cur.id.name), cur.id)
            }
          } else {
            exp(decl.id.name, file.scope.getProp(decl.id.name), decl.id)
          }
        }
        if (node.specifiers.length) {
          var src = node.source ? modules.resolveModule(node.source.value, file.name) : file.scope
          for (var i = 0; i < node.specifiers.length; i++) {
            var spec = node.specifiers[i]
            exp(spec.exported.name, src.getProp(spec.local.name), spec.local)
          }
        }
      }
    })
  }

  function isModuleName(node) {
    if (node.type != "Literal" || typeof node.value != "string") return

    var decl = infer.findExpressionAround(node.sourceFile.ast, null, node.end, null, function(_, node) {
      return node.type == "ImportDeclaration" || /Export(All|Named)Declaration/.test(node.type)
    })
    if (!decl || decl.node.source != node) return
    return node.value
  }

  function isImport(node) {
    if (node.type != "Identifier") return
    var imp = infer.findExpressionAround(node.sourceFile.ast, null, node.end, null, "ImportDeclaration")
    if (!imp) return
    var specs = imp.node.specifiers
    for (var i = 0; i < specs.length; i++) {
      var spec = specs[i]
      if (spec.local != node) continue
      var result = {name: imp.node.source.value, prop: null}
      if (spec.type == "ImportDefaultSpecifier") result.prop = "default"
      else if (spec.type == "ImportSpecifier") result.prop = spec.imported.name
      return result
    }
  }

  tern.registerPlugin("es_modules", function(server) {
    server.loadPlugin("modules")
    server.mod.modules.on("getExports", connectModule)
    server.mod.modules.modNameTests.push(isModuleName)
    server.mod.modules.importTests.push(isImport)
  })
})

});

define("tern/plugin/commonjs",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("./modules"))
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "./modules"], mod)
  mod(tern, tern)
})(function(infer, tern) {
  "use strict"

  var WG_DEFAULT_EXPORT = 95

  function initScope(scope) {
    var defs = infer.cx().definitions.commonjs
    defs.require.propagate(scope.defProp("require"))
    var module = new infer.Obj(defs.Module.getProp("prototype").getType())
    module.propagate(scope.defProp("module"))
    var exports = new infer.Obj(true)
    module.origin = exports.origin = scope.origin
    module.originNode = exports.originNode = scope.originNode
    exports.propagate(scope.defProp("exports"))
    var moduleExports = scope.exports = module.defProp("exports")
    exports.propagate(moduleExports, WG_DEFAULT_EXPORT)
  }

  infer.registerFunction("require", function(_self, _args, argNodes) {
    if (!argNodes || !argNodes.length || argNodes[0].type != "Literal" || typeof argNodes[0].value != "string")
      return infer.ANull
    var cx = infer.cx(), server = cx.parent
    var currentFile = argNodes[0].sourceFile.name

    var name = argNodes[0].value
    var resolved = server.mod.modules.resolveModule(name, currentFile)
    return resolved
  })

  function isStaticRequire(node) {
    if (node.type != "CallExpression" || node.callee.type != "Identifier" || node.callee.name != "require") return
    var arg = node.arguments[0]
    if (arg && arg.type == "Literal" && typeof arg.value == "string") return arg.value
  }

  function isModuleName(node) {
    if (node.type != "Literal" || typeof node.value != "string") return

    var call = infer.findExpressionAround(node.sourceFile.ast, null, node.end, null,
                                          function(_, n) { return isStaticRequire(n) != null })
    if (call && call.node.arguments[0] == node) return node.value
  }

  function isImport(node) {
    if (node.type != "Identifier") return
    var decl = infer.findExpressionAround(node.sourceFile.ast, null, node.end, null, "VariableDeclarator"), name
    if (!decl || decl.node.id != node) return
    var init = decl.node.init
    if (init && (name = isStaticRequire(init)) != null)
      return {name: name, prop: null}
    if (init && init.type == "MemberExpression" && !init.computed && (name = isStaticRequire(init.object)) != null)
      return {name: name, prop: init.property.name}
  }

  function hasProps(obj) {
    if (obj) for (var _prop in obj) return true
  }

  tern.registerPlugin("commonjs", function(server) {
    server.loadPlugin("modules")
    server.mod.modules.on("wrapScope", initScope)
    server.mod.modules.on("getExports", function(file, mod) {
      var exports = file.scope.exports
      if (exports.types.length > 1 || hasProps(exports.getObjType()))
        exports.propagate(mod)
    })

    server.mod.modules.modNameTests.push(isModuleName)
    server.mod.modules.importTests.push(isImport)

    server.addDefs(defs)
  })

  var defs = {
    "!name": "commonjs",
    "!define": {
      require: {
        "!type": "fn(id: string) -> !custom:require",
        resolve: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/globals.html#globals_require_resolve",
          "!doc": "Use the internal require() machinery to look up the location of a module, but rather than loading the module, just return the resolved filename."
        },
        cache: {
          "!url": "https://nodejs.org/api/globals.html#globals_require_cache",
          "!doc": "Modules are cached in this object when they are required. By deleting a key value from this object, the next require will reload the module."
        },
        extensions: {
          "!url": "https://nodejs.org/api/globals.html#globals_require_extensions",
          "!doc": "Instruct require on how to handle certain file extensions."
        },
        "!url": "https://nodejs.org/api/globals.html#globals_require",
        "!doc": "To require modules."
      },
      Module: {
        "!type": "fn()",
        "!url": "https://nodejs.org/api/modules.html",
        "!doc": "Node has a simple module loading system. In Node, files and modules are in one-to-one correspondence.",
        prototype: {
          exports: {
            "!type": "?",
            "!url": "https://nodejs.org/api/modules.html#modules_module_exports",
            "!doc": "The exports object is created by the Module system. Sometimes this is not acceptable, many want their module to be an instance of some class. To do this assign the desired export object to module.exports. For example suppose we were making a module called a.js"
          },
          require: {
            "!type": "require",
            "!url": "https://nodejs.org/api/modules.html#modules_module_require_id",
            "!doc": "The module.require method provides a way to load a module as if require() was called from the original module."
          },
          id: {
            "!type": "string",
            "!url": "https://nodejs.org/api/modules.html#modules_module_id",
            "!doc": "The identifier for the module. Typically this is the fully resolved filename."
          },
          filename: {
            "!type": "string",
            "!url": "https://nodejs.org/api/modules.html#modules_module_filename",
            "!doc": "The fully resolved filename to the module."
          },
          loaded: {
            "!type": "bool",
            "!url": "https://nodejs.org/api/modules.html#modules_module_loaded",
            "!doc": "Whether or not the module is done loading, or is in the process of loading."
          },
          parent: {
            "!type": "+Module",
            "!url": "https://nodejs.org/api/modules.html#modules_module_parent",
            "!doc": "The module that required this one."
          },
          children: {
            "!type": "[+Module]",
            "!url": "https://nodejs.org/api/modules.html#modules_module_children",
            "!doc": "The module objects required by this one."
          }
        }
      },
      module: {}
    },
    module: {
      "!type": "+Module",
      "!url": "https://nodejs.org/api/globals.html#globals_module",
      "!doc": "A reference to the current module. In particular module.exports is the same as the exports object. module isn't actually a global but rather local to each module."
    }
  }
})

});

define("tern/plugin/node_resolve",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("./commonjs"), require)
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "./commonjs"], mod)
  mod(tern, tern)
})(function(infer, tern, _, require) {
  "use strict"

  function resolve(name, parentFile) {
    var resolved = resolveToFile(name, parentFile)
    return resolved && infer.cx().parent.normalizeFilename(resolved)
  }

  function findDeclaredDeps() {}

  var resolveToFile
  if (require) (function() {
    var module_ = require("module"), path = require("path"), fs = require("fs")

    resolveToFile = function(name, parentFile) {
      var projectDir = infer.cx().parent.projectDir
      var fullParent = path.resolve(projectDir, parentFile)
      var parentDir = path.dirname(fullParent)
      if (/^\.\.?\//.test(name))
        name = path.resolve(projectDir, parentDir, name)

      var parentModule = {
        id: fullParent,
        paths: module_._nodeModulePaths(parentDir)
      }
      try {
        return module_._resolveFilename(name, parentModule)
      } catch(e) {
        return null
      }
    }

    function findPackageFile(dir) {
      for (;;) {
        try {
          return JSON.parse(fs.readFileSync(path.resolve(dir, "package.json")))
        } catch(e) {}
        var shorter = path.dirname(dir)
        if (shorter == dir) return null
        dir = shorter
      }
    }

    findDeclaredDeps = function(path, knownModules) {
      var packageFile = findPackageFile(path)
      if (!packageFile) return null

      function add(obj) {
        for (var name in obj) if (!(name in knownModules)) knownModules[name] = null
      }
      add(packageFile.dependencies)
      add(packageFile.devDependencies)
      add(packageFile.peerDependencies)
    }

  })(); else (function() {
    function resolvePath(base, path) {
      if (path[0] == "/") return path;
      var slash = base.lastIndexOf("/"), m;
      if (slash >= 0) path = base.slice(0, slash + 1) + path;
      while (m = /[^\/]*[^\/\.][^\/]*\/\.\.\//.exec(path))
        path = path.slice(0, m.index) + path.slice(m.index + m[0].length);
      return path.replace(/(^|[^\.])\.\//g, "$1");
    }

    resolveToFile = function(name, parentFile) {
      return /^\.\.?\//.test(name) ? resolvePath(parentFile, name) : name
    }
  })()

  tern.registerPlugin("node_resolve", function(server) {
    server.loadPlugin("commonjs")
    server.mod.modules.resolvers.push(resolve)
    findDeclaredDeps(server.projectDir, server.mod.modules.knownModules)
  })
})

});

define("tern/plugin/node",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/tern"), require("./node_resolve"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/tern", "./node_resolve"], mod);
  mod(tern, tern);
})(function(tern) {
  "use strict"

  tern.registerPlugin("node", function(server) {
    server.loadPlugin("node_resolve")
    server.on("postReset", function() {
      var mods = server.mod.modules, locals = server.cx.definitions.node
      for (var name in locals) if (/^[a-z_]*$/.test(name))
        mods.knownModules[name] = locals[name]
    })
    server.addDefs(defs)
  })

  var defs = {
    "!name": "node",
    "!define": {
      events: {
        "!url": "https://nodejs.org/api/events.html",
        "!doc": "Many objects in Node emit events: a net.Server emits an event each time a peer connects to it, a fs.readStream emits an event when the file is opened. All objects which emit events are instances of events.EventEmitter.",
        EventEmitter: {
          prototype: {
            addListener: {
              "!type": "fn(event: string, listener: fn())",
              "!url": "https://nodejs.org/api/events.html#events_emitter_addlistener_event_listener",
              "!doc": "Adds a listener to the end of the listeners array for the specified event."
            },
            on: {
              "!type": "fn(event: string, listener: fn())",
              "!url": "https://nodejs.org/api/events.html#events_emitter_on_event_listener",
              "!doc": "Adds a listener to the end of the listeners array for the specified event."
            },
            once: {
              "!type": "fn(event: string, listener: fn())",
              "!url": "https://nodejs.org/api/events.html#events_emitter_once_event_listener",
              "!doc": "Adds a one time listener for the event. This listener is invoked only the next time the event is fired, after which it is removed."
            },
            removeListener: {
              "!type": "fn(event: string, listener: fn())",
              "!url": "https://nodejs.org/api/events.html#events_emitter_removelistener_event_listener",
              "!doc": "Remove a listener from the listener array for the specified event. Caution: changes array indices in the listener array behind the listener."
            },
            removeAllListeners: {
              "!type": "fn(event: string)",
              "!url": "https://nodejs.org/api/events.html#events_emitter_removealllisteners_event",
              "!doc": "Removes all listeners, or those of the specified event."
            },
            setMaxListeners: {
              "!type": "fn(n: number)",
              "!url": "https://nodejs.org/api/events.html#events_emitter_setmaxlisteners_n",
              "!doc": "By default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default which helps finding memory leaks. Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited."
            },
            listeners: {
              "!type": "fn(event: string) -> [fn()]",
              "!url": "https://nodejs.org/api/events.html#events_emitter_listeners_event",
              "!doc": "Returns an array of listeners for the specified event."
            },
            emit: {
              "!type": "fn(event: string)",
              "!url": "https://nodejs.org/api/events.html#events_emitter_emit_event_arg1_arg2",
              "!doc": "Execute each of the listeners in order with the supplied arguments."
            }
          },
          "!url": "https://nodejs.org/api/events.html#events_class_events_eventemitter",
          "!doc": "To access the EventEmitter class, require('events').EventEmitter."
        }
      },
      stream: {
        "!type": "fn()",
        prototype: {
          "!proto": "events.EventEmitter.prototype",
          pipe: {
            "!type": "fn(destination: +stream.Writable, options?: ?)",
            "!url": "https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options",
            "!doc": "Connects this readable stream to destination WriteStream. Incoming data on this stream gets written to destination. Properly manages back-pressure so that a slow destination will not be overwhelmed by a fast readable stream."
          }
        },
        Writable: {
          "!type": "fn(options?: ?)",
          prototype: {
            "!proto": "stream.prototype",
            write: {
              "!type": "fn(chunk: string|+Buffer, encoding?: string, callback?: fn()) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback_1",
              "!doc": "Writes chunk to the stream. Returns true if the data has been flushed to the underlying resource. Returns false to indicate that the buffer is full, and the data will be sent out in the future. The 'drain' event will indicate when the buffer is empty again."
            },
            cork: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_cork",
              "!doc": "Forces buffering of all writes. Buffered data will be flushed either at .uncork() or at .end() call."
            },
            uncork: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_uncork",
              "!doc": "Flush all data, buffered since .cork() call."
            },
            setDefaultEncoding: {
              "!type": "fn(encoding: string) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_setdefaultencoding_encoding",
              "!doc": "Sets the default encoding for a writable stream. Returns true if the encoding is valid and is set. Otherwise returns false."
            },
            end: {
              "!type": "fn(chunk?: string|+Buffer, encoding?: string, callback?: fn()) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_end_chunk_encoding_callback",
              "!doc": "Call this method to signal the end of the data being written to the stream."
            }
          },
          "!url": "https://nodejs.org/api/stream.html#stream_class_stream_writable",
          "!doc": "A Writable Stream has the following methods, members, and events."
        },
        Readable: {
          "!type": "fn(options?: ?)",
          prototype: {
            "!proto": "stream.prototype",
            setEncoding: {
              "!type": "fn(encoding: string)",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_setencoding_encoding",
              "!doc": "Makes the 'data' event emit a string instead of a Buffer. encoding can be 'utf8', 'utf16le' ('ucs2'), 'ascii', or 'hex'."
            },
            pause: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_pause",
              "!doc": "Switches the readable stream into \"old mode\", where data is emitted using a 'data' event rather than being buffered for consumption via the read() method."
            },
            resume: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_resume",
              "!doc": "Switches the readable stream into \"old mode\", where data is emitted using a 'data' event rather than being buffered for consumption via the read() method."
            },
            destroy: "fn()",
            unpipe: {
              "!type": "fn(dest?: +stream.Writable)",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_unpipe_destination",
              "!doc": "Undo a previously established pipe(). If no destination is provided, then all previously established pipes are removed."
            },
            push: {
              "!type": "fn(chunk: +Buffer) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_push_chunk",
              "!doc": "Explicitly insert some data into the read queue. If called with null, will signal the end of the data."
            },
            unshift: {
              "!type": "fn(chunk: +Buffer) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_unshift_chunk",
              "!doc": "This is the corollary of readable.push(chunk). Rather than putting the data at the end of the read queue, it puts it at the front of the read queue."
            },
            wrap: {
              "!type": "fn(stream: ?) -> +stream.Readable",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_wrap_stream",
              "!doc": "If you are using an older Node library that emits 'data' events and has a pause() method that is advisory only, then you can use the wrap() method to create a Readable stream that uses the old stream as its data source."
            },
            read: {
              "!type": "fn(size?: number) -> +Buffer",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_read_size_1",
              "!doc": "Call this method to consume data once the 'readable' event is emitted."
            }
          },
          "!url": "https://nodejs.org/api/stream.html#stream_class_stream_readable",
          "!doc": "A Readable Stream has the following methods, members, and events."
        },
        Duplex: {
          "!type": "fn(options?: ?)",
          prototype: {
            "!proto": "stream.Readable.prototype",
            write: "fn(chunk: +Buffer, encoding?: string, callback?: fn()) -> bool",
            end: "fn(chunk: +Buffer, encoding?: string, callback?: fn()) -> bool"
          },
          "!url": "https://nodejs.org/api/stream.html#stream_class_stream_duplex",
          "!doc": "A \"duplex\" stream is one that is both Readable and Writable, such as a TCP socket connection."
        },
        Transform: {
          "!type": "fn(options?: ?)",
          prototype: {
            "!proto": "stream.Duplex.prototype"
          },
          "!url": "https://nodejs.org/api/stream.html#stream_class_stream_transform",
          "!doc": "A \"transform\" stream is a duplex stream where the output is causally connected in some way to the input, such as a zlib stream or a crypto stream."
        },
        PassThrough: "stream.Transform",
        "!url": "https://nodejs.org/api/stream.html#stream_stream",
        "!doc": "A stream is an abstract interface implemented by various objects in Node. For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of EventEmitter"
      },
      querystring: {
        "!url": "https://nodejs.org/api/querystring.html",
        "!doc": "This module provides utilities for dealing with query strings.",
        stringify: {
          "!type": "fn(obj: ?, sep?: string, eq?: string) -> string",
          "!url": "https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq",
          "!doc": "Serialize an object to a query string. Optionally override the default separator ('&') and assignment ('=') characters."
        },
        parse: {
          "!type": "fn(str: string, sep?: string, eq?: string, options?: ?) -> ?",
          "!url": "https://nodejs.org/api/querystring.html#querystring_querystring_parse_str_sep_eq_options",
          "!doc": "Deserialize a query string to an object. Optionally override the default separator ('&') and assignment ('=') characters."
        },
        escape: {
          "!type": "fn(string) -> string",
          "!url": "https://nodejs.org/api/querystring.html#querystring_querystring_escape",
          "!doc": "The escape function used by querystring.stringify, provided so that it could be overridden if necessary."
        },
        unescape: {
          "!type": "fn(string) -> string",
          "!url": "https://nodejs.org/api/querystring.html#querystring_querystring_unescape",
          "!doc": "The unescape function used by querystring.parse, provided so that it could be overridden if necessary."
        }
      },
      http: {
        "!url": "https://nodejs.org/api/http.html",
        "!doc": "The HTTP interfaces in Node are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses--the user is able to stream data.",
        STATUS_CODES: {},
        createServer: {
          "!type": "fn(listener?: fn(request: +http.IncomingMessage, response: +http.ServerResponse)) -> +http.Server",
          "!url": "https://nodejs.org/api/http.html#http_http_createserver_requestlistener",
          "!doc": "Returns a new web server object."
        },
        Server: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            listen: {
              "!type": "fn(port: number, hostname?: string, backlog?: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback",
              "!doc": "Begin accepting connections on the specified port and hostname. If the hostname is omitted, the server will accept connections directed to any IPv4 address (INADDR_ANY)."
            },
            close: {
              "!type": "fn(callback?: ?)",
              "!url": "https://nodejs.org/api/http.html#http_server_close_callback",
              "!doc": "Stops the server from accepting new connections."
            },
            maxHeadersCount: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_server_maxheaderscount",
              "!doc": "Limits maximum incoming headers count, equal to 1000 by default. If set to 0 - no limit will be applied."
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_server_settimeout_msecs_callback",
              "!doc": "Sets the timeout value for sockets, and emits a 'timeout' event on the Server object, passing the socket as an argument, if a timeout occurs."
            },
            timeout: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_server_timeout",
              "!doc": "The number of milliseconds of inactivity before a socket is presumed to have timed out."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_class_http_server",
          "!doc": "Class for HTTP server objects."
        },
        ServerResponse: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Writable.prototype",
            writeContinue: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/http.html#http_response_writecontinue",
              "!doc": "Sends a HTTP/1.1 100 Continue message to the client, indicating that the request body should be sent."
            },
            writeHead: {
              "!type": "fn(statusCode: number, headers?: ?)",
              "!url": "https://nodejs.org/api/http.html#http_response_writehead_statuscode_reasonphrase_headers",
              "!doc": "Sends a response header to the request. The status code is a 3-digit HTTP status code, like 404. The last argument, headers, are the response headers. Optionally one can give a human-readable reasonPhrase as the second argument."
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_response_settimeout_msecs_callback",
              "!doc": "Sets the Socket's timeout value to msecs. If a callback is provided, then it is added as a listener on the 'timeout' event on the response object."
            },
            statusCode: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_response_statuscode",
              "!doc": "When using implicit headers (not calling response.writeHead() explicitly), this property controls the status code that will be sent to the client when the headers get flushed."
            },
            setHeader: {
              "!type": "fn(name: string, value: string)",
              "!url": "https://nodejs.org/api/http.html#http_response_setheader_name_value",
              "!doc": "Sets a single header value for implicit headers. If this header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings here if you need to send multiple headers with the same name."
            },
            headersSent: {
              "!type": "bool",
              "!url": "https://nodejs.org/api/http.html#http_response_headerssent",
              "!doc": "Boolean (read-only). True if headers were sent, false otherwise."
            },
            sendDate: {
              "!type": "bool",
              "!url": "https://nodejs.org/api/http.html#http_response_senddate",
              "!doc": "When true, the Date header will be automatically generated and sent in the response if it is not already present in the headers. Defaults to true."
            },
            getHeader: {
              "!type": "fn(name: string) -> string",
              "!url": "https://nodejs.org/api/http.html#http_response_getheader_name",
              "!doc": "Reads out a header that's already been queued but not sent to the client. Note that the name is case insensitive. This can only be called before headers get implicitly flushed."
            },
            removeHeader: {
              "!type": "fn(name: string)",
              "!url": "https://nodejs.org/api/http.html#http_response_removeheader_name",
              "!doc": "Removes a header that's queued for implicit sending."
            },
            addTrailers: {
              "!type": "fn(headers: ?)",
              "!url": "https://nodejs.org/api/http.html#http_response_addtrailers_headers",
              "!doc": "This method adds HTTP trailing headers (a header but at the end of the message) to the response."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_class_http_serverresponse",
          "!doc": "This object is created internally by a HTTP server--not by the user. It is passed as the second parameter to the 'request' event."
        },
        request: {
          "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
          "!url": "https://nodejs.org/api/http.html#http_http_request_options_callback",
          "!doc": "Node maintains several connections per server to make HTTP requests. This function allows one to transparently issue requests."
        },
        get: {
          "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
          "!url": "https://nodejs.org/api/http.html#http_http_get_options_callback",
          "!doc": "Since most requests are GET requests without bodies, Node provides this convenience method. The only difference between this method and http.request() is that it sets the method to GET and calls req.end() automatically."
        },
        globalAgent: {
          "!type": "+http.Agent",
          "!url": "https://nodejs.org/api/http.html#http_http_globalagent",
          "!doc": "Global instance of Agent which is used as the default for all http client requests."
        },
        Agent: {
          "!type": "fn()",
          prototype: {
            maxSockets: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_agent_maxsockets",
              "!doc": "By default set to 5. Determines how many concurrent sockets the agent can have open per host."
            },
            sockets: {
              "!type": "[+net.Socket]",
              "!url": "https://nodejs.org/api/http.html#http_agent_sockets",
              "!doc": "An object which contains arrays of sockets currently in use by the Agent. Do not modify."
            },
            requests: {
              "!type": "[+http.ClientRequest]",
              "!url": "https://nodejs.org/api/http.html#http_agent_requests",
              "!doc": "An object which contains queues of requests that have not yet been assigned to sockets. Do not modify."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_class_http_agent",
          "!doc": "In node 0.5.3+ there is a new implementation of the HTTP Agent which is used for pooling sockets used in HTTP client requests."
        },
        ClientRequest: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Writable.prototype",
            abort: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/http.html#http_request_abort",
              "!doc": "Aborts a request. (New since v0.3.8.)"
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback",
              "!doc": "Once a socket is assigned to this request and is connected socket.setTimeout() will be called."
            },
            setNoDelay: {
              "!type": "fn(noDelay?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_request_setnodelay_nodelay",
              "!doc": "Once a socket is assigned to this request and is connected socket.setNoDelay() will be called."
            },
            setSocketKeepAlive: {
              "!type": "fn(enable?: bool, initialDelay?: number)",
              "!url": "https://nodejs.org/api/http.html#http_request_setsocketkeepalive_enable_initialdelay",
              "!doc": "Once a socket is assigned to this request and is connected socket.setKeepAlive() will be called."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_class_http_clientrequest",
          "!doc": "This object is created internally and returned from http.request(). It represents an in-progress request whose header has already been queued. The header is still mutable using the setHeader(name, value), getHeader(name), removeHeader(name) API. The actual header will be sent along with the first data chunk or when closing the connection."
        },
        IncomingMessage: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Readable.prototype",
            httpVersion: {
              "!type": "string",
              "!url": "https://nodejs.org/api/http.html#http_message_httpversion",
              "!doc": "In case of server request, the HTTP version sent by the client. In the case of client response, the HTTP version of the connected-to server. Probably either '1.1' or '1.0'."
            },
            headers: {
              "!type": "?",
              "!url": "https://nodejs.org/api/http.html#http_message_headers",
              "!doc": "The request/response headers object."
            },
            trailers: {
              "!type": "?",
              "!url": "https://nodejs.org/api/http.html#http_message_trailers",
              "!doc": "The request/response trailers object. Only populated after the 'end' event."
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_message_settimeout_msecs_callback",
              "!doc": "Calls message.connection.setTimeout(msecs, callback)."
            },
            setEncoding: {
              "!type": "fn(encoding?: string)",
              "!url": "https://nodejs.org/api/http.html#http_message_setencoding_encoding",
              "!doc": "Set the encoding for data emitted by the 'data' event."
            },
            pause: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/http.html#http_message_pause",
              "!doc": "Pauses request/response from emitting events. Useful to throttle back a download."
            },
            resume: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/http.html#http_message_resume",
              "!doc": "Resumes a paused request/response."
            },
            method: {
              "!type": "string",
              "!url": "https://nodejs.org/api/http.html#http_message_method",
              "!doc": "Only valid for request obtained from http.Server."
            },
            url: {
              "!type": "string",
              "!url": "https://nodejs.org/api/http.html#http_message_url",
              "!doc": "Only valid for request obtained from http.Server."
            },
            statusCode: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_message_statuscode",
              "!doc": "Only valid for response obtained from http.ClientRequest."
            },
            socket: {
              "!type": "+net.Socket",
              "!url": "https://nodejs.org/api/http.html#http_message_socket",
              "!doc": "The net.Socket object associated with the connection."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_http_incomingmessage",
          "!doc": "An IncomingMessage object is created by http.Server or http.ClientRequest and passed as the first argument to the 'request' and 'response' event respectively. It may be used to access response status, headers and data."
        }
      },
      https: {
        "!url": "https://nodejs.org/api/http.html",
        "!doc": "HTTPS is the HTTP protocol over TLS/SSL. In Node this is implemented as a separate module.",
        Server: "http.Server",
        createServer: {
          "!type": "fn(listener?: fn(request: +http.IncomingMessage, response: +http.ServerResponse)) -> +https.Server",
          "!url": "https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener",
          "!doc": "Returns a new HTTPS web server object. The options is similar to tls.createServer(). The requestListener is a function which is automatically added to the 'request' event."
        },
        request: {
          "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
          "!url": "https://nodejs.org/api/https.html#https_https_request_options_callback",
          "!doc": "Makes a request to a secure web server."
        },
        get: {
          "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
          "!url": "https://nodejs.org/api/https.html#https_https_get_options_callback",
          "!doc": "Like http.get() but for HTTPS."
        },
        Agent: "http.Agent",
        globalAgent: "http.globalAgent"
      },
      cluster: {
        "!proto": "events.EventEmitter.prototype",
        settings: {
          exec: "string",
          args: "[string]",
          silent: "bool",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_settings",
          "!doc": "All settings set by the .setupMaster is stored in this settings object. This object is not supposed to be changed or set manually, by you."
        },
        Worker: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            id: {
              "!type": "string",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_id",
              "!doc": "Each new worker is given its own unique id, this id is stored in the id."
            },
            process: {
              "!type": "+child_process.ChildProcess",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_process",
              "!doc": "All workers are created using child_process.fork(), the returned object from this function is stored in process."
            },
            suicide: {
              "!type": "bool",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_suicide",
              "!doc": "This property is a boolean. It is set when a worker dies after calling .kill() or immediately after calling the .disconnect() method. Until then it is undefined."
            },
            send: {
              "!type": "fn(message: ?, sendHandle?: ?)",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_send_message_sendhandle",
              "!doc": "This function is equal to the send methods provided by child_process.fork(). In the master you should use this function to send a message to a specific worker. However in a worker you can also use process.send(message), since this is the same function."
            },
            destroy: "fn()",
            disconnect: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_disconnect",
              "!doc": "When calling this function the worker will no longer accept new connections, but they will be handled by any other listening worker. Existing connection will be allowed to exit as usual. When no more connections exist, the IPC channel to the worker will close allowing it to die graceful. When the IPC channel is closed the disconnect event will emit, this is then followed by the exit event, there is emitted when the worker finally die."
            },
            kill: {
              "!type": "fn(signal?: string)",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_kill_signal_sigterm",
              "!doc": "This function will kill the worker, and inform the master to not spawn a new worker. The boolean suicide lets you distinguish between voluntary and accidental exit."
            }
          },
          "!url": "https://nodejs.org/api/cluster.html#cluster_class_worker",
          "!doc": "A Worker object contains all public information and method about a worker. In the master it can be obtained using cluster.workers. In a worker it can be obtained using cluster.worker."
        },
        isMaster: {
          "!type": "bool",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_ismaster",
          "!doc": "True if the process is a master. This is determined by the process.env.NODE_UNIQUE_ID. If process.env.NODE_UNIQUE_ID is undefined, then isMaster is true."
        },
        isWorker: {
          "!type": "bool",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_isworker",
          "!doc": "This boolean flag is true if the process is a worker forked from a master. If the process.env.NODE_UNIQUE_ID is set to a value, then isWorker is true."
        },
        setupMaster: {
          "!type": "fn(settings?: cluster.settings)",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_setupmaster_settings",
          "!doc": "setupMaster is used to change the default 'fork' behavior. The new settings are effective immediately and permanently, they cannot be changed later on."
        },
        fork: {
          "!type": "fn(env?: ?) -> +cluster.Worker",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_fork_env",
          "!doc": "Spawn a new worker process. This can only be called from the master process."
        },
        disconnect: {
          "!type": "fn(callback?: fn())",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_disconnect_callback",
          "!doc": "When calling this method, all workers will commit a graceful suicide. When they are disconnected all internal handlers will be closed, allowing the master process to die graceful if no other event is waiting."
        },
        worker: {
          "!type": "+cluster.Worker",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_worker",
          "!doc": "A reference to the current worker object. Not available in the master process."
        },
        workers: {
          "!type": "[+cluster.Worker]",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_workers",
          "!doc": "A hash that stores the active worker objects, keyed by id field. Makes it easy to loop through all the workers. It is only available in the master process."
        },
        "!url": "https://nodejs.org/api/cluster.html#cluster_cluster",
        "!doc": "A single instance of Node runs in a single thread. To take advantage of multi-core systems the user will sometimes want to launch a cluster of Node processes to handle the load."
      },
      zlib: {
        "!url": "https://nodejs.org/api/zlib.html",
        "!doc": "This provides bindings to Gzip/Gunzip, Deflate/Inflate, and DeflateRaw/InflateRaw classes. Each class takes the same options, and is a readable/writable Stream.",
        Zlib: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            flush: {
              "!type": "fn(callback: fn())",
              "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_flush_callback",
              "!doc": "Flush pending data. Don't call this frivolously, premature flushes negatively impact the effectiveness of the compression algorithm."
            },
            reset: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_reset",
              "!doc": "Reset the compressor/decompressor to factory defaults. Only applicable to the inflate and deflate algorithms."
            }
          },
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_zlib",
          "!doc": "Not exported by the zlib module. It is documented here because it is the base class of the compressor/decompressor classes."
        },
        deflate: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_deflate_buf_callback",
          "!doc": "Compress a string with Deflate."
        },
        deflateRaw: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_deflateraw_buf_callback",
          "!doc": "Compress a string with DeflateRaw."
        },
        gzip: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_gzip_buf_callback",
          "!doc": "Compress a string with Gzip."
        },
        gunzip: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_gunzip_buf_callback",
          "!doc": "Decompress a raw Buffer with Gunzip."
        },
        inflate: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_inflate_buf_callback",
          "!doc": "Decompress a raw Buffer with Inflate."
        },
        inflateRaw: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_inflateraw_buf_callback",
          "!doc": "Decompress a raw Buffer with InflateRaw."
        },
        unzip: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_unzip_buf_callback",
          "!doc": "Decompress a raw Buffer with Unzip."
        },
        Gzip: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_gzip",
          "!doc": "Compress data using gzip.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createGzip: {
          "!type": "fn(options: ?) -> +zlib.Zlib",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_creategzip_options",
          "!doc": "Returns a new Gzip object with an options."
        },
        Gunzip: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_gunzip",
          "!doc": "Decompress a gzip stream.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createGunzip: {
          "!type": "fn(options: ?) -> +zlib.Gunzip",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_creategunzip_options",
          "!doc": "Returns a new Gunzip object with an options."
        },
        Deflate: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_deflate",
          "!doc": "Compress data using deflate.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createDeflate: {
          "!type": "fn(options: ?) -> +zlib.Deflate",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createdeflate_options",
          "!doc": "Returns a new Deflate object with an options."
        },
        Inflate: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_inflate",
          "!doc": "Decompress a deflate stream.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createInflate: {
          "!type": "fn(options: ?) -> +zlib.Inflate",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createinflate_options",
          "!doc": "Returns a new Inflate object with an options."
        },
        InflateRaw: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_inflateraw",
          "!doc": "Decompress a raw deflate stream.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createInflateRaw: {
          "!type": "fn(options: ?) -> +zlib.InflateRaw",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createinflateraw_options",
          "!doc": "Returns a new InflateRaw object with an options."
        },
        DeflateRaw: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_deflateraw",
          "!doc": "Compress data using deflate, and do not append a zlib header.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createDeflateRaw: {
          "!type": "fn(options: ?) -> +zlib.DeflateRaw",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createdeflateraw_options",
          "!doc": "Returns a new DeflateRaw object with an options."
        },
        Unzip: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_unzip",
          "!doc": "Decompress either a Gzip- or Deflate-compressed stream by auto-detecting the header.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createUnzip: {
          "!type": "fn(options: ?) -> +zlib.Unzip",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createunzip_options",
          "!doc": "Returns a new Unzip object with an options."
        },
        Z_NO_FLUSH: "number",
        Z_PARTIAL_FLUSH: "number",
        Z_SYNC_FLUSH: "number",
        Z_FULL_FLUSH: "number",
        Z_FINISH: "number",
        Z_BLOCK: "number",
        Z_TREES: "number",
        Z_OK: "number",
        Z_STREAM_END: "number",
        Z_NEED_DICT: "number",
        Z_ERRNO: "number",
        Z_STREAM_ERROR: "number",
        Z_DATA_ERROR: "number",
        Z_MEM_ERROR: "number",
        Z_BUF_ERROR: "number",
        Z_VERSION_ERROR: "number",
        Z_NO_COMPRESSION: "number",
        Z_BEST_SPEED: "number",
        Z_BEST_COMPRESSION: "number",
        Z_DEFAULT_COMPRESSION: "number",
        Z_FILTERED: "number",
        Z_HUFFMAN_ONLY: "number",
        Z_RLE: "number",
        Z_FIXED: "number",
        Z_DEFAULT_STRATEGY: "number",
        Z_BINARY: "number",
        Z_TEXT: "number",
        Z_ASCII: "number",
        Z_UNKNOWN: "number",
        Z_DEFLATED: "number",
        Z_NULL: "number"
      },
      os: {
        "!url": "https://nodejs.org/api/os.html",
        "!doc": "Provides a few basic operating-system related utility functions.",
        tmpdir: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_tmpdir",
          "!doc": "Returns the operating system's default directory for temp files."
        },
        endianness: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_endianness",
          "!doc": "Returns the endianness of the CPU. Possible values are \"BE\" or \"LE\"."
        },
        hostname: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_hostname",
          "!doc": "Returns the hostname of the operating system."
        },
        type: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_type",
          "!doc": "Returns the operating system name."
        },
        platform: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_platform",
          "!doc": "Returns the operating system platform."
        },
        arch: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_arch",
          "!doc": "Returns the operating system CPU architecture."
        },
        release: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_release",
          "!doc": "Returns the operating system release."
        },
        uptime: {
          "!type": "fn() -> number",
          "!url": "https://nodejs.org/api/os.html#os_os_uptime",
          "!doc": "Returns the system uptime in seconds."
        },
        loadavg: {
          "!type": "fn() -> [number]",
          "!url": "https://nodejs.org/api/os.html#os_os_loadavg",
          "!doc": "Returns an array containing the 1, 5, and 15 minute load averages."
        },
        totalmem: {
          "!type": "fn() -> number",
          "!url": "https://nodejs.org/api/os.html#os_os_totalmem",
          "!doc": "Returns the total amount of system memory in bytes."
        },
        freemem: {
          "!type": "fn() -> number",
          "!url": "https://nodejs.org/api/os.html#os_os_freemem",
          "!doc": "Returns the amount of free system memory in bytes."
        },
        cpus: {
          "!type": "fn() -> [os.cpuSpec]",
          "!url": "https://nodejs.org/api/os.html#os_os_cpus",
          "!doc": "Returns an array of objects containing information about each CPU/core installed: model, speed (in MHz), and times (an object containing the number of milliseconds the CPU/core spent in: user, nice, sys, idle, and irq)."
        },
        networkInterfaces: {
          "!type": "fn() -> ?",
          "!url": "https://nodejs.org/api/os.html#os_os_networkinterfaces",
          "!doc": "Get a list of network interfaces."
        },
        EOL: {
          "!type": "string",
          "!url": "https://nodejs.org/api/os.html#os_os_eol",
          "!doc": "A constant defining the appropriate End-of-line marker for the operating system."
        }
      },
      punycode: {
        "!url": "https://nodejs.org/api/punycode.html",
        "!doc": "Punycode.js is bundled with Node.js v0.6.2+. Use require('punycode') to access it. (To use it with other Node.js versions, use npm to install the punycode module first.)",
        decode: {
          "!type": "fn(string: string) -> string",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_decode_string",
          "!doc": "Converts a Punycode string of ASCII code points to a string of Unicode code points."
        },
        encode: {
          "!type": "fn(string: string) -> string",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_encode_string",
          "!doc": "Converts a string of Unicode code points to a Punycode string of ASCII code points."
        },
        toUnicode: {
          "!type": "fn(domain: string) -> string",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_tounicode_domain",
          "!doc": "Converts a Punycode string representing a domain name to Unicode. Only the Punycoded parts of the domain name will be converted, i.e. it doesn't matter if you call it on a string that has already been converted to Unicode."
        },
        toASCII: {
          "!type": "fn(domain: string) -> string",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_toascii_domain",
          "!doc": "Converts a Unicode string representing a domain name to Punycode. Only the non-ASCII parts of the domain name will be converted, i.e. it doesn't matter if you call it with a domain that's already in ASCII."
        },
        ucs2: {
          decode: {
            "!type": "fn(string: string) -> string",
            "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_ucs2_decode_string",
            "!doc": "Creates an array containing the decimal code points of each Unicode character in the string. While JavaScript uses UCS-2 internally, this function will convert a pair of surrogate halves (each of which UCS-2 exposes as separate characters) into a single code point, matching UTF-16."
          },
          encode: {
            "!type": "fn(codePoints: [number]) -> string",
            "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_ucs2_encode_codepoints",
            "!doc": "Creates a string based on an array of decimal code points."
          }
        },
        version: {
          "!type": "?",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_version",
          "!doc": "A string representing the current Punycode.js version number."
        }
      },
      repl: {
        "!url": "https://nodejs.org/api/repl.html",
        "!doc": "A Read-Eval-Print-Loop (REPL) is available both as a standalone program and easily includable in other programs. The REPL provides a way to interactively run JavaScript and see the results. It can be used for debugging, testing, or just trying things out.",
        start: {
          "!type": "fn(options: ?) -> +events.EventEmitter",
          "!url": "https://nodejs.org/api/repl.html#repl_repl_start_options",
          "!doc": "Returns and starts a REPLServer instance."
        }
      },
      readline: {
        "!url": "https://nodejs.org/api/readline.html",
        "!doc": "Readline allows reading of a stream (such as process.stdin) on a line-by-line basis.",
        createInterface: {
          "!type": "fn(options: ?) -> +readline.Interface",
          "!url": "https://nodejs.org/api/readline.html#readline_readline_createinterface_options",
          "!doc": "Creates a readline Interface instance."
        },
        Interface: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            setPrompt: {
              "!type": "fn(prompt: string, length: number)",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_setprompt_prompt_length",
              "!doc": "Sets the prompt, for example when you run node on the command line, you see > , which is node's prompt."
            },
            prompt: {
              "!type": "fn(preserveCursor?: bool)",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_prompt_preservecursor",
              "!doc": "Readies readline for input from the user, putting the current setPrompt options on a new line, giving the user a new spot to write. Set preserveCursor to true to prevent the cursor placement being reset to 0."
            },
            question: {
              "!type": "fn(query: string, callback: fn())",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_question_query_callback",
              "!doc": "Prepends the prompt with query and invokes callback with the user's response. Displays the query to the user, and then invokes callback with the user's response after it has been typed."
            },
            pause: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_pause",
              "!doc": "Pauses the readline input stream, allowing it to be resumed later if needed."
            },
            resume: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_resume",
              "!doc": "Resumes the readline input stream."
            },
            close: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_close",
              "!doc": "Closes the Interface instance, relinquishing control on the input and output streams. The \"close\" event will also be emitted."
            },
            write: {
              "!type": "fn(data: ?, key?: ?)",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_write_data_key",
              "!doc": "Writes data to output stream. key is an object literal to represent a key sequence; available if the terminal is a TTY."
            }
          },
          "!url": "https://nodejs.org/api/readline.html#readline_class_interface",
          "!doc": "The class that represents a readline interface with an input and output stream."
        }
      },
      vm: {
        "!url": "https://nodejs.org/api/vm.html",
        "!doc": "JavaScript code can be compiled and run immediately or compiled, saved, and run later.",
        createContext: {
          "!type": "fn(initSandbox?: ?) -> ?",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_createcontext_initsandbox",
          "!doc": "vm.createContext creates a new context which is suitable for use as the 2nd argument of a subsequent call to vm.runInContext. A (V8) context comprises a global object together with a set of build-in objects and functions. The optional argument initSandbox will be shallow-copied to seed the initial contents of the global object used by the context."
        },
        Script: {
          "!type": "fn()",
          prototype: {
            runInThisContext: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/vm.html#vm_script_runinthiscontext",
              "!doc": "Similar to vm.runInThisContext but a method of a precompiled Script object. script.runInThisContext runs the code of script and returns the result. Running code does not have access to local scope, but does have access to the global object (v8: in actual context)."
            },
            runInNewContext: {
              "!type": "fn(sandbox?: ?)",
              "!url": "https://nodejs.org/api/vm.html#vm_script_runinnewcontext_sandbox",
              "!doc": "Similar to vm.runInNewContext a method of a precompiled Script object. script.runInNewContext runs the code of script with sandbox as the global object and returns the result. Running code does not have access to local scope. sandbox is optional."
            }
          },
          "!url": "https://nodejs.org/api/vm.html#vm_class_script",
          "!doc": "A class for running scripts. Returned by vm.createScript."
        },
        runInThisContext: {
          "!type": "fn(code: string, filename?: string)",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_runinthiscontext_code_filename",
          "!doc": "vm.runInThisContext() compiles code, runs it and returns the result. Running code does not have access to local scope. filename is optional, it's used only in stack traces."
        },
        runInNewContext: {
          "!type": "fn(code: string, sandbox?: ?, filename?: string)",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_runinnewcontext_code_sandbox_filename",
          "!doc": "vm.runInNewContext compiles code, then runs it in sandbox and returns the result. Running code does not have access to local scope. The object sandbox will be used as the global object for code. sandbox and filename are optional, filename is only used in stack traces."
        },
        runInContext: {
          "!type": "fn(code: string, context: ?, filename?: string)",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_runincontext_code_context_filename",
          "!doc": "vm.runInContext compiles code, then runs it in context and returns the result. A (V8) context comprises a global object, together with a set of built-in objects and functions. Running code does not have access to local scope and the global object held within context will be used as the global object for code. filename is optional, it's used only in stack traces."
        },
        createScript: {
          "!type": "fn(code: string, filename?: string) -> +vm.Script",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_createscript_code_filename",
          "!doc": "createScript compiles code but does not run it. Instead, it returns a vm.Script object representing this compiled code. This script can be run later many times using methods below. The returned script is not bound to any global object. It is bound before each run, just for that run. filename is optional, it's only used in stack traces."
        }
      },
      child_process: {
        "!url": "https://nodejs.org/api/child_process.html",
        "!doc": "Node provides a tri-directional popen(3) facility through the child_process module.",
        ChildProcess: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            stdin: {
              "!type": "+stream.Writable",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_stdin",
              "!doc": "A Writable Stream that represents the child process's stdin. Closing this stream via end() often causes the child process to terminate."
            },
            stdout: {
              "!type": "+stream.Readable",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_stdout",
              "!doc": "A Readable Stream that represents the child process's stdout."
            },
            stderr: {
              "!type": "+stream.Readable",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_stderr",
              "!doc": "A Readable Stream that represents the child process's stderr."
            },
            pid: {
              "!type": "number",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_pid",
              "!doc": "The PID of the child process."
            },
            kill: {
              "!type": "fn(signal?: string)",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_kill_signal",
              "!doc": "Send a signal to the child process. If no argument is given, the process will be sent 'SIGTERM'."
            },
            send: {
              "!type": "fn(message: ?, sendHandle?: ?)",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_send_message_sendhandle",
              "!doc": "When using child_process.fork() you can write to the child using child.send(message, [sendHandle]) and messages are received by a 'message' event on the child."
            },
            disconnect: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_disconnect",
              "!doc": "To close the IPC connection between parent and child use the child.disconnect() method. This allows the child to exit gracefully since there is no IPC channel keeping it alive. When calling this method the disconnect event will be emitted in both parent and child, and the connected flag will be set to false. Please note that you can also call process.disconnect() in the child process."
            }
          },
          "!url": "https://nodejs.org/api/child_process.html#child_process_class_childprocess",
          "!doc": "ChildProcess is an EventEmitter."
        },
        spawn: {
          "!type": "fn(command: string, args?: [string], options?: ?) -> +child_process.ChildProcess",
          "!url": "https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options",
          "!doc": "Launches a new process with the given command, with command line arguments in args. If omitted, args defaults to an empty Array."
        },
        exec: {
          "!type": "fn(command: string, callback: fn(error: ?, stdout: +Buffer, stderr: +Buffer)) -> +child_process.ChildProcess",
          "!url": "https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback",
          "!doc": "Runs a command in a shell and buffers the output."
        },
        execFile: {
          "!type": "fn(file: string, args: [string], options: ?, callback: fn(error: ?, stdout: +Buffer, stderr: +Buffer)) -> +child_process.ChildProcess",
          "!url": "https://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback",
          "!doc": "This is similar to child_process.exec() except it does not execute a subshell but rather the specified file directly. This makes it slightly leaner than child_process.exec. It has the same options."
        },
        fork: {
          "!type": "fn(modulePath: string, args?: [string], options?: ?) -> +child_process.ChildProcess",
          "!url": "https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options",
          "!doc": "This is a special case of the spawn() functionality for spawning Node processes. In addition to having all the methods in a normal ChildProcess instance, the returned object has a communication channel built-in."
        }
      },
      url: {
        "!url": "https://nodejs.org/api/url.html",
        "!doc": "This module has utilities for URL resolution and parsing. ",
        parse: {
          "!type": "fn(urlStr: string, parseQueryString?: bool, slashesDenoteHost?: bool) -> url.type",
          "!url": "https://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost",
          "!doc": "Take a URL string, and return an object."
        },
        format: {
          "!type": "fn(url: url.type) -> string",
          "!url": "https://nodejs.org/api/url.html#url_url_format_urlobj",
          "!doc": "Take a parsed URL object, and return a formatted URL string."
        },
        resolve: {
          "!type": "fn(from: string, to: string) -> string",
          "!url": "https://nodejs.org/api/url.html#url_url_resolve_from_to",
          "!doc": "Take a base URL, and a href URL, and resolve them as a browser would for an anchor tag."
        }
      },
      dns: {
        "!url": "https://nodejs.org/api/dns.html",
        "!doc": "This module contains functions that belong to two different categories:\n1) Functions that use the underlying operating system facilities to perform name resolution, and that do not necessarily do any network communication.\n2) Functions that connect to an actual DNS server to perform name resolution, and that always use the network to perform DNS queries.",
        lookup: {
          "!type": "fn(domain: string, callback: fn(err: +Error, address: string, family: number)) -> string",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_lookup_domain_family_callback",
          "!doc": "Resolves a domain (e.g. 'google.com') into the first found A (IPv4) or AAAA (IPv6) record. The family can be the integer 4 or 6. Defaults to null that indicates both Ip v4 and v6 address family."
        },
        resolve: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolve_domain_rrtype_callback",
          "!doc": "Resolves a domain (e.g. 'google.com') into an array of the record types specified by rrtype. Valid rrtypes are 'A' (IPV4 addresses, default), 'AAAA' (IPV6 addresses), 'MX' (mail exchange records), 'TXT' (text records), 'SRV' (SRV records), 'PTR' (used for reverse IP lookups), 'NS' (name server records) and 'CNAME' (canonical name records)."
        },
        resolve4: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolve4_domain_callback",
          "!doc": "The same as dns.resolve(), but only for IPv4 queries (A records). addresses is an array of IPv4 addresses (e.g. ['74.125.79.104', '74.125.79.105', '74.125.79.106'])."
        },
        resolve6: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolve6_domain_callback",
          "!doc": "The same as dns.resolve4() except for IPv6 queries (an AAAA query)."
        },
        resolveMx: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvemx_domain_callback",
          "!doc": "The same as dns.resolve(), but only for mail exchange queries (MX records)."
        },
        resolveTxt: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvetxt_domain_callback",
          "!doc": "The same as dns.resolve(), but only for text queries (TXT records). addresses is an array of the text records available for domain (e.g., ['v=spf1 ip4:0.0.0.0 ~all'])."
        },
        resolveSrv: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvesrv_domain_callback",
          "!doc": "The same as dns.resolve(), but only for service records (SRV records). addresses is an array of the SRV records available for domain. Properties of SRV records are priority, weight, port, and name (e.g., [{'priority': 10, {'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...])."
        },
        resolveNs: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvens_domain_callback",
          "!doc": "The same as dns.resolve(), but only for name server records (NS records). addresses is an array of the name server records available for domain (e.g., ['ns1.example.com', 'ns2.example.com'])."
        },
        resolveCname: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvecname_domain_callback",
          "!doc": "The same as dns.resolve(), but only for canonical name records (CNAME records). addresses is an array of the canonical name records available for domain (e.g., ['bar.example.com'])."
        },
        reverse: {
          "!type": "fn(ip: string, callback: fn(err: +Error, domains: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_reverse_ip_callback",
          "!doc": "Reverse resolves an ip address to an array of domain names."
        }
      },
      net: {
        "!url": "https://nodejs.org/api/net.html",
        "!doc": "The net module provides you with an asynchronous network wrapper. It contains methods for creating both servers and clients (called streams).",
        createServer: {
          "!type": "fn(options?: ?, connectionListener?: fn(socket: +net.Socket)) -> +net.Server",
          "!url": "https://nodejs.org/api/net.html#net_net_createserver_options_connectionlistener",
          "!doc": "Creates a new TCP server. The connectionListener argument is automatically set as a listener for the 'connection' event."
        },
        Server: {
          "!type": "fn()",
          prototype: {
            "!proto": "net.Socket.prototype",
            listen: {
              "!type": "fn(port: number, hostname?: string, backlog?: number, callback?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_server_listen_port_host_backlog_callback",
              "!doc": "Begin accepting connections on the specified port and host. If the host is omitted, the server will accept connections directed to any IPv4 address (INADDR_ANY). A port value of zero will assign a random port."
            },
            close: {
              "!type": "fn(callback?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_server_close_callback",
              "!doc": "Stops the server from accepting new connections and keeps existing connections. This function is asynchronous, the server is finally closed when all connections are ended and the server emits a 'close' event. Optionally, you can pass a callback to listen for the 'close' event."
            },
            maxConnections: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_server_maxconnections",
              "!doc": "Set this property to reject connections when the server's connection count gets high."
            },
            getConnections: {
              "!type": "fn(callback: fn(err: +Error, count: number))",
              "!url": "https://nodejs.org/api/net.html#net_server_getconnections_callback",
              "!doc": "Asynchronously get the number of concurrent connections on the server. Works when sockets were sent to forks."
            }
          },
          "!url": "https://nodejs.org/api/net.html#net_class_net_server",
          "!doc": "This class is used to create a TCP or UNIX server. A server is a net.Socket that can listen for new incoming connections."
        },
        Socket: {
          "!type": "fn(options: ?)",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            connect: {
              "!type": "fn(port: number, host?: string, connectionListener?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_socket_connect_port_host_connectlistener",
              "!doc": "Opens the connection for a given socket. If port and host are given, then the socket will be opened as a TCP socket, if host is omitted, localhost will be assumed. If a path is given, the socket will be opened as a unix socket to that path."
            },
            bufferSize: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_buffersize",
              "!doc": "net.Socket has the property that socket.write() always works. This is to help users get up and running quickly. The computer cannot always keep up with the amount of data that is written to a socket - the network connection simply might be too slow. Node will internally queue up the data written to a socket and send it out over the wire when it is possible. (Internally it is polling on the socket's file descriptor for being writable)."
            },
            setEncoding: {
              "!type": "fn(encoding?: string)",
              "!url": "https://nodejs.org/api/net.html#net_socket_setencoding_encoding",
              "!doc": "Set the encoding for the socket as a Readable Stream."
            },
            write: {
              "!type": "fn(data: +Buffer, encoding?: string, callback?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_socket_write_data_encoding_callback",
              "!doc": "Sends data on the socket. The second parameter specifies the encoding in the case of a string--it defaults to UTF8 encoding."
            },
            end: {
              "!type": "fn(data?: +Buffer, encoding?: string)",
              "!url": "https://nodejs.org/api/net.html#net_socket_end_data_encoding",
              "!doc": "Half-closes the socket. i.e., it sends a FIN packet. It is possible the server will still send some data."
            },
            destroy: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_destroy",
              "!doc": "Ensures that no more I/O activity happens on this socket. Only necessary in case of errors (parse error or so)."
            },
            pause: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_pause",
              "!doc": "Pauses the reading of data. That is, 'data' events will not be emitted. Useful to throttle back an upload."
            },
            resume: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_resume",
              "!doc": "Resumes reading after a call to pause()."
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback",
              "!doc": "Sets the socket to timeout after timeout milliseconds of inactivity on the socket. By default net.Socket do not have a timeout."
            },
            setKeepAlive: {
              "!type": "fn(enable?: bool, initialDelay?: number)",
              "!url": "https://nodejs.org/api/net.html#net_socket_setkeepalive_enable_initialdelay",
              "!doc": "Enable/disable keep-alive functionality, and optionally set the initial delay before the first keepalive probe is sent on an idle socket. enable defaults to false."
            },
            address: {
              "!type": "fn() -> net.address",
              "!url": "https://nodejs.org/api/net.html#net_socket_address",
              "!doc": "Returns the bound address, the address family name and port of the socket as reported by the operating system. Returns an object with three properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }"
            },
            unref: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_unref",
              "!doc": "Calling unref on a socket will allow the program to exit if this is the only active socket in the event system. If the socket is already unrefd calling unref again will have no effect."
            },
            ref: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_ref",
              "!doc": "Opposite of unref, calling ref on a previously unrefd socket will not let the program exit if it's the only socket left (the default behavior). If the socket is refd calling ref again will have no effect."
            },
            remoteAddress: {
              "!type": "string",
              "!url": "https://nodejs.org/api/net.html#net_socket_remoteaddress",
              "!doc": "The string representation of the remote IP address. For example, '74.125.127.100' or '2001:4860:a005::68'."
            },
            remotePort: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_remoteport",
              "!doc": "The numeric representation of the remote port. For example, 80 or 21."
            },
            localPort: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_localport",
              "!doc": "The numeric representation of the local port. For example, 80 or 21."
            },
            bytesRead: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_bytesread",
              "!doc": "The amount of received bytes."
            },
            bytesWritten: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_byteswritten",
              "!doc": "The amount of bytes sent."
            },
            setNoDelay: {
              "!type": "fn(noDelay?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_socket_setnodelay_nodelay",
              "!doc": "Disables the Nagle algorithm. By default TCP connections use the Nagle algorithm, they buffer data before sending it off. Setting true for noDelay will immediately fire off data each time socket.write() is called. noDelay defaults to true."
            },
            localAddress: {
              "!type": "string",
              "!url": "https://nodejs.org/api/net.html#net_socket_localaddress",
              "!doc": "The string representation of the local IP address the remote client is connecting on. For example, if you are listening on '0.0.0.0' and the client connects on '192.168.1.1', the value would be '192.168.1.1'."
            }
          },
          "!url": "https://nodejs.org/api/net.html#net_class_net_socket",
          "!doc": "This object is an abstraction of a TCP or UNIX socket. net.Socket instances implement a duplex Stream interface. They can be created by the user and used as a client (with connect()) or they can be created by Node and passed to the user through the 'connection' event of a server."
        },
        connect: {
          "!type": "fn(options: ?, connectionListener?: fn()) -> +net.Socket",
          "!url": "https://nodejs.org/api/net.html#net_net_connect_options_connectionlistener",
          "!doc": "Constructs a new socket object and opens the socket to the given location. When the socket is established, the 'connect' event will be emitted."
        },
        createConnection: {
          "!type": "fn(options: ?, connectionListener?: fn()) -> +net.Socket",
          "!url": "https://nodejs.org/api/net.html#net_net_createconnection_options_connectionlistener",
          "!doc": "Constructs a new socket object and opens the socket to the given location. When the socket is established, the 'connect' event will be emitted."
        },
        isIP: {
          "!type": "fn(input: string) -> number",
          "!url": "https://nodejs.org/api/net.html#net_net_isip_input",
          "!doc": "Tests if input is an IP address. Returns 0 for invalid strings, returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses."
        },
        isIPv4: {
          "!type": "fn(input: string) -> bool",
          "!url": "https://nodejs.org/api/net.html#net_net_isipv4_input",
          "!doc": "Returns true if input is a version 4 IP address, otherwise returns false."
        },
        isIPv6: {
          "!type": "fn(input: string) -> bool",
          "!url": "https://nodejs.org/api/net.html#net_net_isipv6_input",
          "!doc": "Returns true if input is a version 6 IP address, otherwise returns false."
        }
      },
      dgram: {
        "!url": "https://nodejs.org/api/dgram.html",
        "!doc": "UDP / Datagram Sockets",
        createSocket: {
          "!type": "fn(type: string, callback?: fn()) -> +dgram.Socket",
          "!url": "https://nodejs.org/api/dgram.html#dgram_dgram_createsocket_type_callback",
          "!doc": "Creates a datagram Socket of the specified types. Valid types are udp4 and udp6."
        },
        Socket: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            send: {
              "!type": "fn(buf: +Buffer, offset: number, length: number, port: number, address: string, callback?: fn())",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_send_buf_offset_length_port_address_callback",
              "!doc": "For UDP sockets, the destination port and IP address must be specified. A string may be supplied for the address parameter, and it will be resolved with DNS. An optional callback may be specified to detect any DNS errors and when buf may be re-used. Note that DNS lookups will delay the time that a send takes place, at least until the next tick. The only way to know for sure that a send has taken place is to use the callback."
            },
            bind: {
              "!type": "fn(port: number, address?: string)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_bind_port_address_callback",
              "!doc": "For UDP sockets, listen for datagrams on a named port and optional address. If address is not specified, the OS will try to listen on all addresses."
            },
            close: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_close",
              "!doc": "Close the underlying socket and stop listening for data on it."
            },
            address: {
              address: "string",
              family: "string",
              port: "number",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_address",
              "!doc": "Returns an object containing the address information for a socket. For UDP sockets, this object will contain address , family and port."
            },
            setBroadcast: {
              "!type": "fn(flag: bool)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_setbroadcast_flag",
              "!doc": "Sets or clears the SO_BROADCAST socket option. When this option is set, UDP packets may be sent to a local interface's broadcast address."
            },
            setTTL: {
              "!type": "fn(ttl: number)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_setttl_ttl",
              "!doc": "Sets the IP_TTL socket option. TTL stands for \"Time to Live,\" but in this context it specifies the number of IP hops that a packet is allowed to go through. Each router or gateway that forwards a packet decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded. Changing TTL values is typically done for network probes or when multicasting."
            },
            setMulticastTTL: {
              "!type": "fn(ttl: number)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_setmulticastttl_ttl",
              "!doc": "Sets the IP_MULTICAST_TTL socket option. TTL stands for \"Time to Live,\" but in this context it specifies the number of IP hops that a packet is allowed to go through, specifically for multicast traffic. Each router or gateway that forwards a packet decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded."
            },
            setMulticastLoopback: {
              "!type": "fn(flag: bool)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_setmulticastloopback_flag",
              "!doc": "Sets or clears the IP_MULTICAST_LOOP socket option. When this option is set, multicast packets will also be received on the local interface."
            },
            addMembership: {
              "!type": "fn(multicastAddress: string, multicastInterface?: string)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_addmembership_multicastaddress_multicastinterface",
              "!doc": "Tells the kernel to join a multicast group with IP_ADD_MEMBERSHIP socket option."
            },
            dropMembership: {
              "!type": "fn(multicastAddress: string, multicastInterface?: string)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_dropmembership_multicastaddress_multicastinterface",
              "!doc": "Opposite of addMembership - tells the kernel to leave a multicast group with IP_DROP_MEMBERSHIP socket option. This is automatically called by the kernel when the socket is closed or process terminates, so most apps will never need to call this."
            }
          },
          "!url": "https://nodejs.org/api/dgram.html#dgram_class_dgram_socket",
          "!doc": "The dgram Socket class encapsulates the datagram functionality. It should be created via dgram.createSocket(type, [callback])."
        }
      },
      fs: {
        "!url": "https://nodejs.org/api/fs.html",
        "!doc": "File I/O is provided by simple wrappers around standard POSIX functions. To use this module do require('fs').\nAll the methods have asynchronous and synchronous forms.",
        rename: {
          "!type": "fn(oldPath: string, newPath: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_rename_oldpath_newpath_callback",
          "!doc": "Asynchronous rename(2). No arguments other than a possible exception are given to the completion callback."
        },
        renameSync: {
          "!type": "fn(oldPath: string, newPath: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_renamesync_oldpath_newpath",
          "!doc": "Synchronous rename(2)."
        },
        ftruncate: {
          "!type": "fn(fd: number, len: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_ftruncate_fd_len_callback",
          "!doc": "Asynchronous ftruncate(2). No arguments other than a possible exception are given to the completion callback."
        },
        ftruncateSync: {
          "!type": "fn(fd: number, len: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_ftruncatesync_fd_len",
          "!doc": "Synchronous ftruncate(2)."
        },
        truncate: {
          "!type": "fn(path: string, len: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_truncate_path_len_callback",
          "!doc": "Asynchronous truncate(2). No arguments other than a possible exception are given to the completion callback."
        },
        truncateSync: {
          "!type": "fn(path: string, len: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_truncatesync_path_len",
          "!doc": "Synchronous truncate(2)."
        },
        chown: {
          "!type": "fn(path: string, uid: number, gid: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_chown_path_uid_gid_callback",
          "!doc": "Asynchronous chown(2). No arguments other than a possible exception are given to the completion callback."
        },
        chownSync: {
          "!type": "fn(path: string, uid: number, gid: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_chownsync_path_uid_gid",
          "!doc": "Synchronous chown(2)."
        },
        fchown: {
          "!type": "fn(fd: number, uid: number, gid: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fchown_fd_uid_gid_callback",
          "!doc": "Asynchronous fchown(2). No arguments other than a possible exception are given to the completion callback."
        },
        fchownSync: {
          "!type": "fn(fd: number, uid: number, gid: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fchownsync_fd_uid_gid",
          "!doc": "Synchronous fchown(2)."
        },
        lchown: {
          "!type": "fn(path: string, uid: number, gid: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lchown_path_uid_gid_callback",
          "!doc": "Asynchronous lchown(2). No arguments other than a possible exception are given to the completion callback."
        },
        lchownSync: {
          "!type": "fn(path: string, uid: number, gid: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lchownsync_path_uid_gid",
          "!doc": "Synchronous lchown(2)."
        },
        chmod: {
          "!type": "fn(path: string, mode: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_chmod_path_mode_callback",
          "!doc": "Asynchronous chmod(2). No arguments other than a possible exception are given to the completion callback."
        },
        chmodSync: {
          "!type": "fn(path: string, mode: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_chmodsync_path_mode",
          "!doc": "Synchronous chmod(2)."
        },
        fchmod: {
          "!type": "fn(fd: number, mode: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fchmod_fd_mode_callback",
          "!doc": "Asynchronous fchmod(2). No arguments other than a possible exception are given to the completion callback."
        },
        fchmodSync: {
          "!type": "fn(fd: number, mode: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fchmodsync_fd_mode",
          "!doc": "Synchronous fchmod(2)."
        },
        lchmod: {
          "!type": "fn(path: string, mode: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lchmod_path_mode_callback",
          "!doc": "Asynchronous lchmod(2). No arguments other than a possible exception are given to the completion callback."
        },
        lchmodSync: {
          "!type": "fn(path: string, mode: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lchmodsync_path_mode",
          "!doc": "Synchronous lchmod(2)."
        },
        stat: {
          "!type": "fn(path: string, callback?: fn(err: +Error, stats: +fs.Stats) -> ?) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_stat_path_callback",
          "!doc": "Asynchronous stat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object."
        },
        lstat: {
          "!type": "fn(path: string, callback?: fn(err: +Error, stats: +fs.Stats) -> ?) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lstat_path_callback",
          "!doc": "Asynchronous lstat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object. lstat() is identical to stat(), except that if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to."
        },
        fstat: {
          "!type": "fn(fd: number, callback?: fn(err: +Error, stats: +fs.Stats) -> ?) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fstat_fd_callback",
          "!doc": "Asynchronous fstat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object. fstat() is identical to stat(), except that the file to be stat-ed is specified by the file descriptor fd."
        },
        statSync: {
          "!type": "fn(path: string) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_statsync_path",
          "!doc": "Synchronous stat(2). Returns an instance of fs.Stats."
        },
        lstatSync: {
          "!type": "fn(path: string) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lstatsync_path",
          "!doc": "Synchronous lstat(2). Returns an instance of fs.Stats."
        },
        fstatSync: {
          "!type": "fn(fd: number) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fstatsync_fd",
          "!doc": "Synchronous fstat(2). Returns an instance of fs.Stats."
        },
        link: {
          "!type": "fn(srcpath: string, dstpath: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_link_srcpath_dstpath_callback",
          "!doc": "Asynchronous link(2). No arguments other than a possible exception are given to the completion callback."
        },
        linkSync: {
          "!type": "fn(srcpath: string, dstpath: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_linksync_srcpath_dstpath",
          "!doc": "Synchronous link(2)."
        },
        symlink: {
          "!type": "fn(srcpath: string, dstpath: string, type?: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_symlink_srcpath_dstpath_type_callback",
          "!doc": "Asynchronous symlink(2). No arguments other than a possible exception are given to the completion callback. type argument can be either 'dir', 'file', or 'junction' (default is 'file'). It is only used on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute. When using 'junction', the destination argument will automatically be normalized to absolute path."
        },
        symlinkSync: {
          "!type": "fn(srcpath: string, dstpath: string, type?: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_symlinksync_srcpath_dstpath_type",
          "!doc": "Synchronous symlink(2)."
        },
        readlink: {
          "!type": "fn(path: string, callback?: fn(err: +Error, linkString: string))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readlink_path_callback",
          "!doc": "Asynchronous readlink(2). The callback gets two arguments (err, linkString)."
        },
        readlinkSync: {
          "!type": "fn(path: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readlinksync_path",
          "!doc": "Synchronous readlink(2). Returns the symbolic link's string value."
        },
        realpath: {
          "!type": "fn(path: string, cache: bool, callback: fn(err: +Error, resolvedPath: string))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_realpath_path_cache_callback",
          "!doc": "Asynchronous realpath(2). The callback gets two arguments (err, resolvedPath). May use process.cwd to resolve relative paths. cache is an object literal of mapped paths that can be used to force a specific path resolution or avoid additional fs.stat calls for known real paths."
        },
        realpathSync: {
          "!type": "fn(path: string, cache?: bool) -> string",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_cache",
          "!doc": "Synchronous realpath(2). Returns the resolved path."
        },
        unlink: {
          "!type": "fn(path: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_unlink_path_callback",
          "!doc": "Asynchronous unlink(2). No arguments other than a possible exception are given to the completion callback."
        },
        unlinkSync: {
          "!type": "fn(path: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_unlinksync_path",
          "!doc": "Synchronous unlink(2)."
        },
        rmdir: {
          "!type": "fn(path: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_rmdir_path_callback",
          "!doc": "Asynchronous rmdir(2). No arguments other than a possible exception are given to the completion callback."
        },
        rmdirSync: {
          "!type": "fn(path: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_rmdirsync_path",
          "!doc": "Synchronous rmdir(2)."
        },
        mkdir: {
          "!type": "fn(path: string, mode?: ?, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_mkdir_path_mode_callback",
          "!doc": "Asynchronous mkdir(2). No arguments other than a possible exception are given to the completion callback. mode defaults to 0777."
        },
        mkdirSync: {
          "!type": "fn(path: string, mode?: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_mkdirsync_path_mode",
          "!doc": "Synchronous mkdir(2)."
        },
        readdir: {
          "!type": "fn(path: string, callback?: fn(err: +Error, files: [string]))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readdir_path_callback",
          "!doc": "Asynchronous readdir(3). Reads the contents of a directory. The callback gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'."
        },
        readdirSync: {
          "!type": "fn(path: string) -> [string]",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readdirsync_path",
          "!doc": "Synchronous readdir(3). Returns an array of filenames excluding '.' and '..'."
        },
        close: {
          "!type": "fn(fd: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_close_fd_callback",
          "!doc": "Asynchronous close(2). No arguments other than a possible exception are given to the completion callback."
        },
        closeSync: {
          "!type": "fn(fd: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_closesync_fd",
          "!doc": "Synchronous close(2)."
        },
        open: {
          "!type": "fn(path: string, flags: string, mode?: string, callback?: fn(err: +Error, fd: number))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback",
          "!doc": "Asynchronous file open."
        },
        openSync: {
          "!type": "fn(path: string, flags: string, mode?: string) -> number",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_opensync_path_flags_mode",
          "!doc": "Synchronous open(2)."
        },
        utimes: {
          "!type": "fn(path: string, atime: number, mtime: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_utimes_path_atime_mtime_callback",
          "!doc": "Change file timestamps of the file referenced by the supplied path."
        },
        utimesSync: {
          "!type": "fn(path: string, atime: number, mtime: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_utimessync_path_atime_mtime",
          "!doc": "Change file timestamps of the file referenced by the supplied path."
        },
        futimes: {
          "!type": "fn(fd: number, atime: number, mtime: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_futimes_fd_atime_mtime_callback",
          "!doc": "Change the file timestamps of a file referenced by the supplied file descriptor."
        },
        futimesSync: {
          "!type": "fn(fd: number, atime: number, mtime: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_futimessync_fd_atime_mtime",
          "!doc": "Change the file timestamps of a file referenced by the supplied file descriptor."
        },
        fsync: {
          "!type": "fn(fd: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fsync_fd_callback",
          "!doc": "Asynchronous fsync(2). No arguments other than a possible exception are given to the completion callback."
        },
        fsyncSync: {
          "!type": "fn(fd: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fsyncsync_fd",
          "!doc": "Synchronous fsync(2)."
        },
        write: {
          "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number, callback?: fn(err: +Error, written: number, buffer: +Buffer))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_write_fd_buffer_offset_length_position_callback",
          "!doc": "Write buffer to the file specified by fd."
        },
        writeSync: {
          "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number) -> number",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_writesync_fd_buffer_offset_length_position",
          "!doc": "Synchronous version of fs.write(). Returns the number of bytes written."
        },
        read: {
          "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number, callback?: fn(err: +Error, bytesRead: number, buffer: +Buffer))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback",
          "!doc": "Read data from the file specified by fd."
        },
        readSync: {
          "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number) -> number",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readsync_fd_buffer_offset_length_position",
          "!doc": "Synchronous version of fs.read. Returns the number of bytesRead."
        },
        readFile: {
          "!type": "fn(filename: string, callback: fn(err: +Error, data: +Buffer))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readfile_filename_options_callback",
          "!doc": "Asynchronously reads the entire contents of a file."
        },
        readFileSync: {
          "!type": "fn(filename: string, encoding: string) -> +Buffer",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readfilesync_filename_options",
          "!doc": "Synchronous version of fs.readFile. Returns the contents of the filename."
        },
        writeFile: {
          "!type": "fn(filename: string, data: string|+Buffer, encoding?: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_writefile_filename_data_options_callback",
          "!doc": "Asynchronously writes data to a file, replacing the file if it already exists. data can be a string or a buffer."
        },
        writeFileSync: {
          "!type": "fn(filename: string, data: string|+Buffer, encoding?: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_writefilesync_filename_data_options",
          "!doc": "The synchronous version of fs.writeFile."
        },
        appendFile: {
          "!type": "fn(filename: string, data: string|+Buffer, encoding?: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_appendfile_filename_data_options_callback",
          "!doc": "Asynchronously append data to a file, creating the file if it not yet exists. data can be a string or a buffer."
        },
        appendFileSync: {
          "!type": "fn(filename: string, data: string|+Buffer, encoding?: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_appendfilesync_filename_data_options",
          "!doc": "The synchronous version of fs.appendFile."
        },
        watchFile: {
          "!type": "fn(filename: string, options: ?, listener: fn(current: +fs.Stats, prev: +fs.Stats))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_watchfile_filename_options_listener",
          "!doc": "Watch for changes on filename. The callback listener will be called each time the file is accessed."
        },
        unwatchFile: {
          "!type": "fn(filename: string, listener?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_unwatchfile_filename_listener",
          "!doc": "Stop watching for changes on filename. If listener is specified, only that particular listener is removed. Otherwise, all listeners are removed and you have effectively stopped watching filename."
        },
        watch: {
          "!type": "fn(filename: string, options?: ?, listener?: fn(event: string, filename: string)) -> +fs.FSWatcher",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_watch_filename_options_listener",
          "!doc": "Watch for changes on filename, where filename is either a file or a directory. The returned object is a fs.FSWatcher."
        },
        exists: {
          "!type": "fn(path: string, callback?: fn(exists: bool))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_exists_path_callback",
          "!doc": "Test whether or not the given path exists by checking with the file system. Then call the callback argument with either true or false."
        },
        existsSync: {
          "!type": "fn(path: string) -> bool",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_existssync_path",
          "!doc": "Synchronous version of fs.exists."
        },
        Stats: {
          "!type": "fn()",
          prototype: {
            isFile: "fn() -> bool",
            isDirectory: "fn() -> bool",
            isBlockDevice: "fn() -> bool",
            isCharacterDevice: "fn() -> bool",
            isSymbolicLink: "fn() -> bool",
            isFIFO: "fn() -> bool",
            isSocket: "fn() -> bool",
            dev: "number",
            ino: "number",
            mode: "number",
            nlink: "number",
            uid: "number",
            gid: "number",
            rdev: "number",
            size: "number",
            blksize: "number",
            blocks: "number",
            atime: "+Date",
            mtime: "+Date",
            ctime: "+Date"
          },
          "!url": "https://nodejs.org/api/fs.html#fs_class_fs_stats",
          "!doc": "Objects returned from fs.stat(), fs.lstat() and fs.fstat() and their synchronous counterparts are of this type."
        },
        createReadStream: {
          "!type": "fn(path: string, options?: ?) -> +stream.Readable",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options",
          "!doc": "Returns a new ReadStream object."
        },
        createWriteStream: {
          "!type": "fn(path: string, options?: ?) -> +stream.Writable",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options",
          "!doc": "Returns a new WriteStream object."
        },
        FSWatcher: {
          "!type": "fn()",
          prototype: {
            close: "fn()"
          },
          "!url": "https://nodejs.org/api/fs.html#fs_class_fs_fswatcher",
          "!doc": "Objects returned from fs.watch() are of this type."
        }
      },
      path: {
        "!url": "https://nodejs.org/api/path.html",
        "!doc": "This module contains utilities for handling and transforming file paths. Almost all these methods perform only string transformations. The file system is not consulted to check whether paths are valid.",
        normalize: {
          "!type": "fn(p: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_normalize_p",
          "!doc": "Normalize a string path, taking care of '..' and '.' parts."
        },
        join: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_join_path1_path2",
          "!doc": "Join all arguments together and normalize the resulting path."
        },
        resolve: {
          "!type": "fn(from: string, from2: string, from3: string, from4: string, from5: string, to: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_resolve_from_to",
          "!doc": "Resolves to to an absolute path."
        },
        relative: {
          "!type": "fn(from: string, to: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_relative_from_to",
          "!doc": "Solve the relative path from from to to."
        },
        dirname: {
          "!type": "fn(p: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_dirname_p",
          "!doc": "Return the directory name of a path. Similar to the Unix dirname command."
        },
        basename: {
          "!type": "fn(p: string, ext?: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_basename_p_ext",
          "!doc": "Return the last portion of a path. Similar to the Unix basename command."
        },
        extname: {
          "!type": "fn(p: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_extname_p",
          "!doc": "Return the extension of the path, from the last '.' to end of string in the last portion of the path. If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string."
        },
        sep: {
          "!type": "string",
          "!url": "https://nodejs.org/api/path.html#path_path_sep",
          "!doc": "The platform-specific file separator. '\\\\' or '/'."
        },
        delimiter: {
          "!type": "string",
          "!url": "https://nodejs.org/api/path.html#path_path_delimiter",
          "!doc": "The platform-specific path delimiter, ; or ':'."
        }
      },
      string_decoder: {
        "!url": "https://nodejs.org/api/string_decoder.html",
        "!doc": "StringDecoder decodes a buffer to a string. It is a simple interface to buffer.toString() but provides additional support for utf8.",
        StringDecoder: {
          "!type": "fn(encoding?: string)",
          prototype: {
            write: {
              "!type": "fn(buffer: +Buffer) -> string",
              "!url": "https://nodejs.org/api/string_decoder.html#string_decoder_decoder_write_buffer",
              "!doc": "Returns a decoded string."
            },
            end: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/string_decoder.html#string_decoder_decoder_end",
              "!doc": "Returns any trailing bytes that were left in the buffer."
            }
          },
          "!url": "https://nodejs.org/api/string_decoder.html#string_decoder_class_stringdecoder",
          "!doc": "Accepts a single argument, encoding which defaults to utf8."
        }
      },
      tls: {
        "!url": "https://nodejs.org/api/tls.html",
        "!doc": "The tls module uses OpenSSL to provide Transport Layer Security and/or Secure Socket Layer: encrypted stream communication.",
        CLIENT_RENEG_LIMIT: "number",
        CLIENT_RENEG_WINDOW: "number",
        SLAB_BUFFER_SIZE: "number",
        getCiphers: {
          "!type": "fn() -> [string]",
          "!url": "https://nodejs.org/api/tls.html#tls_tls_getciphers",
          "!doc": "Returns an array with the names of the supported SSL ciphers."
        },
        Server: {
          "!type": "fn()",
          prototype: {
            "!proto": "net.Server.prototype",
            listen: {
              "!type": "fn(port: number, host?: string, callback?: fn())",
              "!url": "https://nodejs.org/api/tls.html#tls_server_listen_port_host_callback",
              "!doc": "Begin accepting connections on the specified port and host. If the host is omitted, the server will accept connections directed to any IPv4 address (INADDR_ANY)."
            },
            close: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/tls.html#tls_server_close",
              "!doc": "Stops the server from accepting new connections. This function is asynchronous, the server is finally closed when the server emits a 'close' event."
            },
            addContext: {
              "!type": "fn(hostName: string, credentials: tls.Server.credentials)",
              "!url": "https://nodejs.org/api/tls.html#tls_server_addcontext_hostname_credentials",
              "!doc": "Add secure context that will be used if client request's SNI hostname is matching passed hostname (wildcards can be used). credentials can contain key, cert and ca."
            }
          },
          "!url": "https://nodejs.org/api/tls.html#tls_class_tls_server",
          "!doc": "This class is a subclass of net.Server and has the same methods on it. Instead of accepting just raw TCP connections, this accepts encrypted connections using TLS or SSL."
        },
        createServer: {
          "!type": "fn(options?: ?, connectionListener?: fn(stream: +tls.CleartextStream)) -> +tls.Server",
          "!url": "https://nodejs.org/api/tls.html#tls_tls_createserver_options_secureconnectionlistener",
          "!doc": "Creates a new tls.Server. The connectionListener argument is automatically set as a listener for the secureConnection event."
        },
        CleartextStream: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            authorized: {
              "!type": "bool",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_authorized",
              "!doc": "A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false"
            },
            authorizationError: {
              "!type": "+Error",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_authorizationerror",
              "!doc": "The reason why the peer's certificate has not been verified. This property becomes available only when cleartextStream.authorized === false."
            },
            getPeerCertificate: {
              "!type": "fn() -> ?",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_getpeercertificate",
              "!doc": "Returns an object representing the peer's certificate. The returned object has some properties corresponding to the field of the certificate."
            },
            getCipher: {
              "!type": "fn() -> tls.cipher",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_getcipher",
              "!doc": "Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection."
            },
            address: {
              "!type": "net.address",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_address",
              "!doc": "Returns the bound address, the address family name and port of the underlying socket as reported by the operating system. Returns an object with three properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }"
            },
            remoteAddress: {
              "!type": "string",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_remoteaddress",
              "!doc": "The string representation of the remote IP address. For example, '74.125.127.100' or '2001:4860:a005::68'."
            },
            remotePort: {
              "!type": "number",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_remoteport",
              "!doc": "The numeric representation of the remote port. For example, 443."
            }
          },
          "!url": "https://nodejs.org/api/tls.html#tls_class_tls_cleartextstream",
          "!doc": "This is a stream on top of the Encrypted stream that makes it possible to read/write an encrypted data as a cleartext data."
        },
        connect: {
          "!type": "fn(port: number, host?: string, options: ?, listener: fn()) -> +tls.CleartextStream",
          "!url": "https://nodejs.org/api/tls.html#tls_tls_connect_options_callback",
          "!doc": "Creates a new client connection to the given port and host (old API) or options.port and options.host. (If host is omitted, it defaults to localhost.)"
        },
        createSecurePair: {
          "!type": "fn(credentials?: crypto.credentials, isServer?: bool, requestCert?: bool, rejectUnauthorized?: bool) -> +tls.SecurePair",
          "!url": "https://nodejs.org/api/tls.html#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized",
          "!doc": "Creates a new secure pair object with two streams, one of which reads/writes encrypted data, and one reads/writes cleartext data. Generally the encrypted one is piped to/from an incoming encrypted data stream, and the cleartext one is used as a replacement for the initial encrypted stream."
        },
        SecurePair: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            cleartext: {
              "!type": "+tls.CleartextStream",
              "!url": "https://nodejs.org/api/tls.html#tls_class_securepair",
              "!doc": "Returned by tls.createSecurePair."
            },
            encrypted: {
              "!type": "+stream.Duplex",
              "!url": "https://nodejs.org/api/tls.html#tls_class_securepair",
              "!doc": "Returned by tls.createSecurePair."
            }
          },
          "!url": "https://nodejs.org/api/tls.html#tls_class_securepair",
          "!doc": "Returned by tls.createSecurePair."
        }
      },
      crypto: {
        "!url": "https://nodejs.org/api/crypto.html",
        "!doc": "The crypto module offers a way of encapsulating secure credentials to be used as part of a secure HTTPS net or http connection.\nIt also offers a set of wrappers for OpenSSL's hash, hmac, cipher, decipher, sign and verify methods.",
        getCiphers: {
          "!type": "fn() -> [string]",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_getciphers",
          "!doc": "Returns an array with the names of the supported ciphers."
        },
        getHashes: {
          "!type": "fn() -> [string]",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_gethashes",
          "!doc": "Returns an array with the names of the supported hash algorithms."
        },
        createCredentials: {
          "!type": "fn(details?: ?) -> crypto.credentials",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createcredentials_details",
          "!doc": "Creates a credentials object."
        },
        createHash: {
          "!type": "fn(algorithm: string) -> +crypto.Hash",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm",
          "!doc": "Creates and returns a hash object, a cryptographic hash with the given algorithm which can be used to generate hash digests."
        },
        Hash: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            update: {
              "!type": "fn(data: +Buffer, encoding?: string)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_hash_update_data_input_encoding",
              "!doc": "Updates the hash content with the given data, the encoding of which is given in input_encoding and can be 'utf8', 'ascii' or 'binary'. If no encoding is provided, then a buffer is expected."
            },
            digest: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding",
              "!doc": "Calculates the digest of all of the passed data to be hashed. The encoding can be 'hex', 'binary' or 'base64'. If no encoding is provided, then a buffer is returned."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_hash",
          "!doc": "The class for creating hash digests of data."
        },
        createHmac: {
          "!type": "fn(algorithm: string, key: string) -> +crypto.Hmac",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createhmac_algorithm_key",
          "!doc": "Creates and returns a hmac object, a cryptographic hmac with the given algorithm and key."
        },
        Hmac: {
          "!type": "fn()",
          prototype: {
            update: {
              "!type": "fn(data: +Buffer)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_hmac_update_data",
              "!doc": "Update the hmac content with the given data. This can be called many times with new data as it is streamed."
            },
            digest: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_hmac_digest_encoding",
              "!doc": "Calculates the digest of all of the passed data to the hmac. The encoding can be 'hex', 'binary' or 'base64'. If no encoding is provided, then a buffer is returned."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_hmac",
          "!doc": "Class for creating cryptographic hmac content."
        },
        createCipher: {
          "!type": "fn(algorithm: string, password: string) -> +crypto.Cipher",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createcipher_algorithm_password",
          "!doc": "Creates and returns a cipher object, with the given algorithm and password."
        },
        createCipheriv: {
          "!type": "fn(algorithm: string, password: string, iv: string) -> +crypto.Cipher",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv",
          "!doc": "Creates and returns a cipher object, with the given algorithm, key and iv."
        },
        Cipher: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            update: {
              "!type": "fn(data: +Buffer, input_encoding?: string, output_encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_cipher_update_data_input_encoding_output_encoding",
              "!doc": "Updates the cipher with data, the encoding of which is given in input_encoding and can be 'utf8', 'ascii' or 'binary'. If no encoding is provided, then a buffer is expected."
            },
            "final": {
              "!type": "fn(output_encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_cipher_final_output_encoding",
              "!doc": "Returns any remaining enciphered contents, with output_encoding being one of: 'binary', 'base64' or 'hex'. If no encoding is provided, then a buffer is returned."
            },
            setAutoPadding: {
              "!type": "fn(auto_padding: bool)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_cipher_setautopadding_auto_padding_true",
              "!doc": "You can disable automatic padding of the input data to block size. If auto_padding is false, the length of the entire input data must be a multiple of the cipher's block size or final will fail. Useful for non-standard padding, e.g. using 0x0 instead of PKCS padding. You must call this before cipher.final."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_cipher",
          "!doc": "Class for encrypting data."
        },
        createDecipher: {
          "!type": "fn(algorithm: string, password: string) -> +crypto.Decipher",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createdecipher_algorithm_password",
          "!doc": "Creates and returns a decipher object, with the given algorithm and key. This is the mirror of the createCipher() above."
        },
        createDecipheriv: {
          "!type": "fn(algorithm: string, key: string, iv: string) -> +crypto.Decipher",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv",
          "!doc": "Creates and returns a decipher object, with the given algorithm, key and iv. This is the mirror of the createCipheriv() above."
        },
        Decipher: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            update: {
              "!type": "fn(data: +Buffer, input_encoding?: string, output_encoding?: string)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_decipher_update_data_input_encoding_output_encoding",
              "!doc": "Updates the decipher with data, which is encoded in 'binary', 'base64' or 'hex'. If no encoding is provided, then a buffer is expected."
            },
            "final": {
              "!type": "fn(output_encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_decipher_final_output_encoding",
              "!doc": "Returns any remaining plaintext which is deciphered, with output_encoding being one of: 'binary', 'ascii' or 'utf8'. If no encoding is provided, then a buffer is returned."
            },
            setAutoPadding: {
              "!type": "fn(auto_padding: bool)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_decipher_setautopadding_auto_padding_true",
              "!doc": "You can disable auto padding if the data has been encrypted without standard block padding to prevent decipher.final from checking and removing it. Can only work if the input data's length is a multiple of the ciphers block size. You must call this before streaming data to decipher.update."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_decipher",
          "!doc": "Class for decrypting data."
        },
        createSign: {
          "!type": "fn(algorithm: string) -> +crypto.Sign",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createsign_algorithm",
          "!doc": "Creates and returns a signing object, with the given algorithm. On recent OpenSSL releases, openssl list-public-key-algorithms will display the available signing algorithms. Examples are 'RSA-SHA256'."
        },
        Sign: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Writable.prototype",
            update: {
              "!type": "fn(data: +Buffer)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_sign_update_data",
              "!doc": "Updates the sign object with data. This can be called many times with new data as it is streamed."
            },
            sign: {
              "!type": "fn(private_key: string, output_format: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format",
              "!doc": "Calculates the signature on all the updated data passed through the sign. private_key is a string containing the PEM encoded private key for signing."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_sign",
          "!doc": "Class for generating signatures."
        },
        createVerify: {
          "!type": "fn(algorith: string) -> +crypto.Verify",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createverify_algorithm",
          "!doc": "Creates and returns a verification object, with the given algorithm. This is the mirror of the signing object above."
        },
        Verify: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Writable.prototype",
            update: {
              "!type": "fn(data: +Buffer)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_verifier_update_data",
              "!doc": "Updates the verifier object with data. This can be called many times with new data as it is streamed."
            },
            verify: {
              "!type": "fn(object: string, signature: string, signature_format?: string) -> bool",
              "!url": "https://nodejs.org/api/crypto.html#crypto_verifier_verify_object_signature_signature_format",
              "!doc": "Verifies the signed data by using the object and signature. object is a string containing a PEM encoded object, which can be one of RSA public key, DSA public key, or X.509 certificate. signature is the previously calculated signature for the data, in the signature_format which can be 'binary', 'hex' or 'base64'. If no encoding is specified, then a buffer is expected."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_verify",
          "!doc": "Class for verifying signatures."
        },
        createDiffieHellman: {
          "!type": "fn(prime: number, encoding?: string) -> +crypto.DiffieHellman",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_creatediffiehellman_prime_length",
          "!doc": "Creates a Diffie-Hellman key exchange object and generates a prime of the given bit length. The generator used is 2."
        },
        DiffieHellman: {
          "!type": "fn()",
          prototype: {
            generateKeys: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_generatekeys_encoding",
              "!doc": "Generates private and public Diffie-Hellman key values, and returns the public key in the specified encoding. This key should be transferred to the other party. Encoding can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            computeSecret: {
              "!type": "fn(other_public_key: +Buffer, input_encoding?: string, output_encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding",
              "!doc": "Computes the shared secret using other_public_key as the other party's public key and returns the computed shared secret. Supplied key is interpreted using specified input_encoding, and secret is encoded using specified output_encoding. Encodings can be 'binary', 'hex', or 'base64'. If the input encoding is not provided, then a buffer is expected."
            },
            getPrime: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_getprime_encoding",
              "!doc": "Returns the Diffie-Hellman prime in the specified encoding, which can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            getGenerator: {
              "!type": "fn(encoding: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_getgenerator_encoding",
              "!doc": "Returns the Diffie-Hellman prime in the specified encoding, which can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            getPublicKey: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_getpublickey_encoding",
              "!doc": "Returns the Diffie-Hellman public key in the specified encoding, which can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            getPrivateKey: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_getprivatekey_encoding",
              "!doc": "Returns the Diffie-Hellman private key in the specified encoding, which can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            setPublicKey: {
              "!type": "fn(public_key: +Buffer, encoding?: string)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_setpublickey_public_key_encoding",
              "!doc": "Sets the Diffie-Hellman public key. Key encoding can be 'binary', 'hex' or 'base64'. If no encoding is provided, then a buffer is expected."
            },
            setPrivateKey: {
              "!type": "fn(public_key: +Buffer, encoding?: string)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_setprivatekey_private_key_encoding",
              "!doc": "Sets the Diffie-Hellman private key. Key encoding can be 'binary', 'hex' or 'base64'. If no encoding is provided, then a buffer is expected."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_diffiehellman",
          "!doc": "The class for creating Diffie-Hellman key exchanges."
        },
        getDiffieHellman: {
          "!type": "fn(group_name: string) -> +crypto.DiffieHellman",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_getdiffiehellman_group_name",
          "!doc": "Creates a predefined Diffie-Hellman key exchange object. The supported groups are: 'modp1', 'modp2', 'modp5' (defined in RFC 2412) and 'modp14', 'modp15', 'modp16', 'modp17', 'modp18' (defined in RFC 3526). The returned object mimics the interface of objects created by crypto.createDiffieHellman() above, but will not allow to change the keys (with diffieHellman.setPublicKey() for example). The advantage of using this routine is that the parties don't have to generate nor exchange group modulus beforehand, saving both processor and communication time."
        },
        pbkdf2: {
          "!type": "fn(password: string, salt: string, iterations: number, keylen: number, callback: fn(err: +Error, derivedKey: string))",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2_password_salt_iterations_keylen_callback",
          "!doc": "Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive a key of given length from the given password, salt and iterations. The callback gets two arguments (err, derivedKey)."
        },
        pbkdf2Sync: {
          "!type": "fn(password: string, salt: string, iterations: number, keylen: number) -> string",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen",
          "!doc": "Synchronous PBKDF2 function. Returns derivedKey or throws error."
        },
        randomBytes: {
          "!type": "fn(size: number, callback?: fn(err: +Error, buf: +Buffer))",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback",
          "!doc": "Generates cryptographically strong pseudo-random data."
        },
        pseudoRandomBytes: {
          "!type": "fn(size: number, callback?: fn(err: +Error, buf: +Buffer))",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_pseudorandombytes_size_callback",
          "!doc": "Generates non-cryptographically strong pseudo-random data. The data returned will be unique if it is sufficiently long, but is not necessarily unpredictable. For this reason, the output of this function should never be used where unpredictability is important, such as in the generation of encryption keys."
        },
        DEFAULT_ENCODING: "string"
      },
      util: {
        "!url": "https://nodejs.org/api/util.html",
        "!doc": "The util module is primarily designed to support the needs of Node's internal APIs. Many of these utilities are useful for your own programs. If you find that these functions are lacking for your purposes, however, you are encouraged to write your own utilities. We are not interested in any future additions to the util module that are unnecessary for Node's internal functionality.",
        format: {
          "!type": "fn(format: string) -> string",
          "!url": "https://nodejs.org/api/util.html#util_util_format_format",
          "!doc": "Returns a formatted string using the first argument as a printf-like format."
        },
        debug: {
          "!type": "fn(msg: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_debug_string",
          "!doc": "A synchronous output function. Will block the process and output string immediately to stderr."
        },
        error: {
          "!type": "fn(msg: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_error",
          "!doc": "Same as util.debug() except this will output all arguments immediately to stderr."
        },
        puts: {
          "!type": "fn(data: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_puts",
          "!doc": "A synchronous output function. Will block the process and output all arguments to stdout with newlines after each argument."
        },
        print: {
          "!type": "fn(data: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_print",
          "!doc": "A synchronous output function. Will block the process, cast each argument to a string then output to stdout. Does not place newlines after each argument."
        },
        log: {
          "!type": "fn(string: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_log_string",
          "!doc": "Output with timestamp on stdout."
        },
        inspect: {
          "!type": "fn(object: ?, options: ?) -> string",
          "!url": "https://nodejs.org/api/util.html#util_util_inspect_object_options",
          "!doc": "Return a string representation of object, which is useful for debugging."
        },
        isArray: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isarray_object",
          "!doc": "Returns true if the given \"object\" is an Array. false otherwise."
        },
        isRegExp: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isregexp_object",
          "!doc": "Returns true if the given \"object\" is a RegExp. false otherwise."
        },
        isDate: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isdate_object",
          "!doc": "Returns true if the given \"object\" is a Date. false otherwise."
        },
        isError: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_iserror_object",
          "!doc": "Returns true if the given \"object\" is an Error. false otherwise."
        },
        isBoolean: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isboolean_object",
          "!doc": "Returns true if the given \"object\" is a Boolean. false otherwise."
        },
        isNull: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isnull_object",
          "!doc": "Returns true if the given \"object\" is strictly null. false otherwise."
        },
        isNullOrUndefined: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isnullorundefined_object",
          "!doc": "Returns true if the given \"object\" is null or undefined. false otherwise."
        },
        isNumber: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isnumber_object",
          "!doc": "Returns true if the given \"object\" is a Number. false otherwise."
        },
        isString: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isstring_object",
          "!doc": "Returns true if the given \"object\" is a String. false otherwise."
        },
        isSymbol: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_issymbol_object",
          "!doc": "Returns true if the given \"object\" is a Symbol. false otherwise."
        },
        isUndefined: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isundefined_object",
          "!doc": "Returns true if the given \"object\" is undefined. false otherwise."
        },
        isObject: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isobject_object",
          "!doc": "Returns true if the given \"object\" is strictly an Object and not a Function. false otherwise."
        },
        isFunction: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isfunction_object",
          "!doc": "Returns true if the given \"object\" is a Function. false otherwise."
        },
        isPrimitive: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isprimitive_object",
          "!doc": "Returns true if the given \"object\" is a primitive type. false otherwise."
        },
        isBuffer: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isbuffer_object",
          "!doc": "Returns true if the given \"object\" is a Buffer. false otherwise."
        },
        inherits: {
          "!type": "fn(constructor: ?, superConstructor: ?)",
          "!url": "https://nodejs.org/api/util.html#util_util_inherits_constructor_superconstructor",
          "!doc": "Inherit the prototype methods from one constructor into another. The prototype of constructor will be set to a new object created from superConstructor."
        }
      },
      assert: {
        "!type": "fn(value: ?, message?: string)",
        fail: {
          "!type": "fn(actual: ?, expected: ?, message: string, operator: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_fail_actual_expected_message_operator",
          "!doc": "Throws an exception that displays the values for actual and expected separated by the provided operator."
        },
        ok: {
          "!type": "fn(value: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert",
          "!doc": "This module is used for writing unit tests for your applications, you can access it with require('assert')."
        },
        equal: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_equal_actual_expected_message",
          "!doc": "Tests shallow, coercive equality with the equal comparison operator ( == )."
        },
        notEqual: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_notequal_actual_expected_message",
          "!doc": "Tests shallow, coercive non-equality with the not equal comparison operator ( != )."
        },
        deepEqual: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_deepequal_actual_expected_message",
          "!doc": "Tests for deep equality."
        },
        notDeepEqual: {
          "!type": "fn(acutal: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_notdeepequal_actual_expected_message",
          "!doc": "Tests for any deep inequality."
        },
        strictEqual: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_strictequal_actual_expected_message",
          "!doc": "Tests strict equality, as determined by the strict equality operator ( === )"
        },
        notStrictEqual: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_notstrictequal_actual_expected_message",
          "!doc": "Tests strict non-equality, as determined by the strict not equal operator ( !== )"
        },
        "throws": {
          "!type": "fn(block: fn(), error?: ?, messsage?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_throws_block_error_message",
          "!doc": "Expects block to throw an error. error can be constructor, regexp or validation function."
        },
        doesNotThrow: {
          "!type": "fn(block: fn(), error?: ?, messsage?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_doesnotthrow_block_message",
          "!doc": "Expects block not to throw an error."
        },
        ifError: {
          "!type": "fn(value: ?)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_iferror_value",
          "!doc": "Tests if value is not a false value, throws if it is a true value. Useful when testing the first argument, error in callbacks."
        },
        "!url": "https://nodejs.org/api/assert.html#assert_assert",
        "!doc": "This module is used for writing unit tests for your applications, you can access it with require('assert')."
      },
      tty: {
        "!url": "https://nodejs.org/api/tty.html",
        "!doc": "The tty module houses the tty.ReadStream and tty.WriteStream classes. In most cases, you will not need to use this module directly.",
        isatty: {
          "!type": "fn(fd: number) -> bool",
          "!url": "https://nodejs.org/api/tty.html#tty_tty_isatty_fd",
          "!doc": "Returns true or false depending on if the fd is associated with a terminal."
        }
      },
      domain: {
        "!url": "https://nodejs.org/api/domain.html",
        "!doc": "Domains provide a way to handle multiple different IO operations as a single group. If any of the event emitters or callbacks registered to a domain emit an error event, or throw an error, then the domain object will be notified, rather than losing the context of the error in the process.on('uncaughtException') handler, or causing the program to exit immediately with an error code.",
        create: {
          "!type": "fn() -> +events.EventEmitter",
          "!url": "https://nodejs.org/api/domain.html#domain_domain_create",
          "!doc": "Returns a new Domain object."
        },
        Domain: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            run: {
              "!type": "fn(fn: fn())",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_run_fn",
              "!doc": "Run the supplied function in the context of the domain, implicitly binding all event emitters, timers, and lowlevel requests that are created in that context."
            },
            members: {
              "!type": "[+events.EventEmitter]",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_members",
              "!doc": "An array of timers and event emitters that have been explicitly added to the domain."
            },
            add: {
              "!type": "fn(emitter: +events.EventEmitter)",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_add_emitter",
              "!doc": "Explicitly adds an emitter to the domain. If any event handlers called by the emitter throw an error, or if the emitter emits an error event, it will be routed to the domain's error event, just like with implicit binding."
            },
            remove: {
              "!type": "fn(emitter: +events.EventEmitter)",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_remove_emitter",
              "!doc": "The opposite of domain.add(emitter). Removes domain handling from the specified emitter."
            },
            bind: {
              "!type": "fn(callback: fn(err: +Error, data: ?)) -> !0",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_bind_callback",
              "!doc": "The returned function will be a wrapper around the supplied callback function. When the returned function is called, any errors that are thrown will be routed to the domain's error event."
            },
            intercept: {
              "!type": "fn(cb: fn(data: ?)) -> !0",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_intercept_callback",
              "!doc": "This method is almost identical to domain.bind(callback). However, in addition to catching thrown errors, it will also intercept Error objects sent as the first argument to the function."
            },
            dispose: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_dispose",
              "!doc": "The dispose method destroys a domain, and makes a best effort attempt to clean up any and all IO that is associated with the domain. Streams are aborted, ended, closed, and/or destroyed. Timers are cleared. Explicitly bound callbacks are no longer called. Any error events that are raised as a result of this are ignored."
            }
          },
          "!url": "https://nodejs.org/api/domain.html#domain_class_domain",
          "!doc": "The Domain class encapsulates the functionality of routing errors and uncaught exceptions to the active Domain object."
        }
      },
      "os.cpuSpec": {
        model: "string",
        speed: "number",
        times: {
          user: "number",
          nice: "number",
          sys: "number",
          idle: "number",
          irq: "number"
        }
      },
      "process.memoryUsage.type": {
        rss: "number",
        heapTotal: "?",
        number: "?",
        heapUsed: "number"
      },
      "net.address": {
        port: "number",
        family: "string",
        address: "string"
      },
      "url.type": {
        href: "string",
        protocol: "string",
        auth: "string",
        hostname: "string",
        port: "string",
        host: "string",
        pathname: "string",
        search: "string",
        query: "string",
        slashes: "bool",
        hash: "string"
      },
      "tls.Server.credentials": {
        key: "string",
        cert: "string",
        ca: "string"
      },
      "tls.cipher": {
        name: "string",
        version: "string"
      },
      "crypto.credentials": {
        pfx: "string",
        key: "string",
        passphrase: "string",
        cert: "string",
        ca: "string",
        crl: "string",
        ciphers: "string"
      },
      buffer: {
        Buffer: "Buffer",
        INSPECT_MAX_BYTES: "number",
        SlowBuffer: "Buffer"
      },
      module: {},
      timers: {
        setTimeout: {
          "!type": "fn(callback: fn(), ms: number) -> timers.Timer",
          "!url": "https://nodejs.org/api/globals.html#globals_settimeout_cb_ms",
          "!doc": "Run callback cb after at least ms milliseconds. The actual delay depends on external factors like OS timer granularity and system load."
        },
        clearTimeout: {
          "!type": "fn(id: timers.Timer)",
          "!url": "https://nodejs.org/api/globals.html#globals_cleartimeout_t",
          "!doc": "Stop a timer that was previously created with setTimeout(). The callback will not execute."
        },
        setInterval: {
          "!type": "fn(callback: fn(), ms: number) -> timers.Timer",
          "!url": "https://nodejs.org/api/globals.html#globals_setinterval_cb_ms",
          "!doc": "Run callback cb repeatedly every ms milliseconds. Note that the actual interval may vary, depending on external factors like OS timer granularity and system load. It's never less than ms but it may be longer."
        },
        clearInterval: {
          "!type": "fn(id: timers.Timer)",
          "!url": "https://nodejs.org/api/globals.html#globals_clearinterval_t",
          "!doc": "Stop a timer that was previously created with setInterval(). The callback will not execute."
        },
        setImmediate: {
          "!type": "fn(callback: fn()) -> timers.Timer",
          "!url": "https://nodejs.org/api/timers.html#timers_setimmediate_callback_arg",
          "!doc": "Schedule the 'immediate' execution of callback after I/O events callbacks."
        },
        clearImmediate: {
          "!type": "fn(id: timers.Timer)",
          "!url": "https://nodejs.org/api/timers.html#timers_clearimmediate_immediateid",
          "!doc": "Stops an immediate from triggering."
        },
        Timer: {
          unref: {
            "!type": "fn()",
            "!url": "https://nodejs.org/api/timers.html#timers_unref",
            "!doc": "Create a timer that is active but if it is the only item left in the event loop won't keep the program running."
          },
          ref: {
            "!type": "fn()",
            "!url": "https://nodejs.org/api/timers.html#timers_unref",
            "!doc": "Explicitly request the timer hold the program open (cancel the effect of 'unref')."
          }
        }
      }
    },
    process: {
      stdout: {
        "!type": "+stream.Writable",
        "!url": "https://nodejs.org/api/process.html#process_process_stdout",
        "!doc": "A Writable Stream to stdout."
      },
      stderr: {
        "!type": "+stream.Writable",
        "!url": "https://nodejs.org/api/process.html#process_process_stderr",
        "!doc": "A writable stream to stderr."
      },
      stdin: {
        "!type": "+stream.Readable",
        "!url": "https://nodejs.org/api/process.html#process_process_stdin",
        "!doc": "A Readable Stream for stdin. The stdin stream is paused by default, so one must call process.stdin.resume() to read from it."
      },
      argv: {
        "!type": "[string]",
        "!url": "https://nodejs.org/api/process.html#process_process_argv",
        "!doc": "An array containing the command line arguments. The first element will be 'node', the second element will be the name of the JavaScript file. The next elements will be any additional command line arguments."
      },
      execPath: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_execpath",
        "!doc": "This is the absolute pathname of the executable that started the process."
      },
      abort: {
        "!type": "fn()",
        "!url": "https://nodejs.org/api/process.html#process_process_abort",
        "!doc": "This causes node to emit an abort. This will cause node to exit and generate a core file."
      },
      chdir: {
        "!type": "fn(directory: string)",
        "!url": "https://nodejs.org/api/process.html#process_process_chdir_directory",
        "!doc": "Changes the current working directory of the process or throws an exception if that fails."
      },
      cwd: {
        "!type": "fn()",
        "!url": "https://nodejs.org/api/process.html#process_process_cwd",
        "!doc": "Returns the current working directory of the process."
      },
      env: {
        "!url": "https://nodejs.org/api/process.html#process_process_env",
        "!doc": "An object containing the user environment."
      },
      exit: {
        "!type": "fn(code?: number)",
        "!url": "https://nodejs.org/api/process.html#process_process_exit_code",
        "!doc": "Ends the process with the specified code. If omitted, exit uses the 'success' code 0."
      },
      getgid: {
        "!type": "fn() -> number",
        "!url": "https://nodejs.org/api/process.html#process_process_getgid",
        "!doc": "Gets the group identity of the process. This is the numerical group id, not the group name."
      },
      setgid: {
        "!type": "fn(id: number)",
        "!url": "https://nodejs.org/api/process.html#process_process_setgid_id",
        "!doc": "Sets the group identity of the process. This accepts either a numerical ID or a groupname string. If a groupname is specified, this method blocks while resolving it to a numerical ID."
      },
      getuid: {
        "!type": "fn() -> number",
        "!url": "https://nodejs.org/api/process.html#process_process_getuid",
        "!doc": "Gets the user identity of the process. This is the numerical userid, not the username."
      },
      setuid: {
        "!type": "fn(id: number)",
        "!url": "https://nodejs.org/api/process.html#process_process_setuid_id",
        "!doc": "Sets the user identity of the process. This accepts either a numerical ID or a username string. If a username is specified, this method blocks while resolving it to a numerical ID."
      },
      version: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_version",
        "!doc": "A compiled-in property that exposes NODE_VERSION."
      },
      versions: {
        http_parser: "string",
        node: "string",
        v8: "string",
        ares: "string",
        uv: "string",
        zlib: "string",
        openssl: "string",
        "!url": "https://nodejs.org/api/process.html#process_process_versions",
        "!doc": "A property exposing version strings of node and its dependencies."
      },
      config: {
        target_defaults: {
          cflags: "[?]",
          default_configuration: "string",
          defines: "[string]",
          include_dirs: "[string]",
          libraries: "[string]"
        },
        variables: {
          clang: "number",
          host_arch: "string",
          node_install_npm: "bool",
          node_install_waf: "bool",
          node_prefix: "string",
          node_shared_openssl: "bool",
          node_shared_v8: "bool",
          node_shared_zlib: "bool",
          node_use_dtrace: "bool",
          node_use_etw: "bool",
          node_use_openssl: "bool",
          target_arch: "string",
          v8_no_strict_aliasing: "number",
          v8_use_snapshot: "bool",
          visibility: "string"
        },
        "!url": "https://nodejs.org/api/process.html#process_process_config",
        "!doc": "An Object containing the JavaScript representation of the configure options that were used to compile the current node executable. This is the same as the \"config.gypi\" file that was produced when running the ./configure script."
      },
      kill: {
        "!type": "fn(pid: number, signal?: string)",
        "!url": "https://nodejs.org/api/process.html#process_process_kill_pid_signal",
        "!doc": "Send a signal to a process. pid is the process id and signal is the string describing the signal to send. Signal names are strings like 'SIGINT' or 'SIGUSR1'. If omitted, the signal will be 'SIGTERM'."
      },
      pid: {
        "!type": "number",
        "!url": "https://nodejs.org/api/process.html#process_process_pid",
        "!doc": "The PID of the process."
      },
      title: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_title",
        "!doc": "Getter/setter to set what is displayed in 'ps'."
      },
      arch: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_arch",
        "!doc": "What processor architecture you're running on: 'arm', 'ia32', or 'x64'."
      },
      platform: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_platform",
        "!doc": "What platform you're running on: 'darwin', 'freebsd', 'linux', 'sunos' or 'win32'"
      },
      memoryUsage: {
        "!type": "fn() -> process.memoryUsage.type",
        "!url": "https://nodejs.org/api/process.html#process_process_memoryusage",
        "!doc": "Returns an object describing the memory usage of the Node process measured in bytes."
      },
      nextTick: {
        "!type": "fn(callback: fn())",
        "!url": "https://nodejs.org/api/process.html#process_process_nexttick_callback",
        "!doc": "On the next loop around the event loop call this callback. This is not a simple alias to setTimeout(fn, 0), it's much more efficient. It typically runs before any other I/O events fire, but there are some exceptions."
      },
      maxTickDepth: {
        "!type": "number",
        "!url": "https://nodejs.org/api/process.html#process_process_maxtickdepth",
        "!doc": "The maximum depth of nextTick-calling nextTick-callbacks that will be evaluated before allowing other forms of I/O to occur."
      },
      umask: {
        "!type": "fn(mask?: number) -> number",
        "!url": "https://nodejs.org/api/process.html#process_process_umask_mask",
        "!doc": "Sets or reads the process's file mode creation mask. Child processes inherit the mask from the parent process. Returns the old mask if mask argument is given, otherwise returns the current mask."
      },
      uptime: {
        "!type": "fn() -> number",
        "!url": "https://nodejs.org/api/process.html#process_process_uptime",
        "!doc": "Number of seconds Node has been running."
      },
      hrtime: {
        "!type": "fn() -> [number]",
        "!url": "https://nodejs.org/api/process.html#process_process_hrtime",
        "!doc": "Returns the current high-resolution real time in a [seconds, nanoseconds] tuple Array. It is relative to an arbitrary time in the past. It is not related to the time of day and therefore not subject to clock drift. The primary use is for measuring performance between intervals."
      },
      "!url": "https://nodejs.org/api/globals.html#globals_process",
      "!doc": "The process object."
    },
    global: {
      "!type": "<top>",
      "!url": "https://nodejs.org/api/globals.html#globals_global",
      "!doc": "In browsers, the top-level scope is the global scope. That means that in browsers if you're in the global scope var something will define a global variable. In Node this is different. The top-level scope is not the global scope; var something inside a Node module will be local to that module."
    },
    console: {
      log: {
        "!type": "fn(text: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_log_data",
        "!doc": "Prints to stdout with newline. This function can take multiple arguments in a printf()-like way."
      },
      info: {
        "!type": "fn(text: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_info_data",
        "!doc": "Same as console.log."
      },
      error: {
        "!type": "fn(text: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_error_data",
        "!doc": "Same as console.log but prints to stderr."
      },
      warn: {
        "!type": "fn(text: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_warn_data",
        "!doc": "Same as console.error."
      },
      dir: {
        "!type": "fn(obj: ?)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_dir_obj",
        "!doc": "Uses util.inspect on obj and prints resulting string to stdout."
      },
      time: {
        "!type": "fn(label: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_time_label",
        "!doc": "Mark a time."
      },
      timeEnd: {
        "!type": "fn(label: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_timeend_label",
        "!doc": "Finish timer, record output."
      },
      trace: {
        "!type": "fn(label: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_trace_label",
        "!doc": "Print a stack trace to stderr of the current position."
      },
      assert: {
        "!type": "fn(expression: bool)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_assert_expression_message",
        "!doc": "Same as assert.ok() where if the expression evaluates as false throw an AssertionError with message."
      },
      "!url": "https://nodejs.org/api/globals.html#globals_console",
      "!doc": "Used to print to stdout and stderr."
    },
    __filename: {
      "!type": "string",
      "!url": "https://nodejs.org/api/globals.html#globals_filename",
      "!doc": "The filename of the code being executed. This is the resolved absolute path of this code file. For a main program this is not necessarily the same filename used in the command line. The value inside a module is the path to that module file."
    },
    __dirname: {
      "!type": "string",
      "!url": "https://nodejs.org/api/globals.html#globals_dirname",
      "!doc": "The name of the directory that the currently executing script resides in."
    },
    setTimeout: "timers.setTimeout",
    clearTimeout: "timers.clearTimeout",
    setInterval: "timers.setInterval",
    clearInterval: "timers.clearInterval",
    Buffer: {
      "!type": "fn(str: string, encoding?: string) -> +Buffer",
      prototype: {
        "!proto": "String.prototype",
        write: "fn(string: string, offset?: number, length?: number, encoding?: string) -> number",
        toString: "fn(encoding?: string, start?: number, end?: number) -> string",
        length: "number",
        copy: "fn(targetBuffer: +Buffer, targetStart?: number, sourceStart?: number, sourceEnd?: number)",
        slice: "fn(start?: number, end?: number) -> +Buffer",
        readUInt8: "fn(offset: number, noAssert?: bool) -> number",
        readUInt16LE: "fn(offset: number, noAssert?: bool) -> number",
        readUInt16BE: "fn(offset: number, noAssert?: bool) -> number",
        readUInt32LE: "fn(offset: number, noAssert?: bool) -> number",
        readUInt32BE: "fn(offset: number, noAssert?: bool) -> number",
        readInt8: "fn(offset: number, noAssert?: bool) -> number",
        readInt16LE: "fn(offset: number, noAssert?: bool) -> number",
        readInt16BE: "fn(offset: number, noAssert?: bool) -> number",
        readInt32LE: "fn(offset: number, noAssert?: bool) -> number",
        readInt32BE: "fn(offset: number, noAssert?: bool) -> number",
        readFloatLE: "fn(offset: number, noAssert?: bool) -> number",
        readFloatBE: "fn(offset: number, noAssert?: bool) -> number",
        readDoubleLE: "fn(offset: number, noAssert?: bool) -> number",
        readDoubleBE: "fn(offset: number, noAssert?: bool) -> number",
        writeUInt8: "fn(value: number, offset: number, noAssert?: bool)",
        writeUInt16LE: "fn(value: number, offset: number, noAssert?: bool)",
        writeUInt16BE: "fn(value: number, offset: number, noAssert?: bool)",
        writeUInt32LE: "fn(value: number, offset: number, noAssert?: bool)",
        writeUInt32BE: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt8: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt16LE: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt16BE: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt32LE: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt32BE: "fn(value: number, offset: number, noAssert?: bool)",
        writeFloatLE: "fn(value: number, offset: number, noAssert?: bool)",
        writeFloatBE: "fn(value: number, offset: number, noAssert?: bool)",
        writeDoubleLE: "fn(value: number, offset: number, noAssert?: bool)",
        writeDoubleBE: "fn(value: number, offset: number, noAssert?: bool)",
        fill: "fn(value: ?, offset?: number, end?: number)"
      },
      isBuffer: "fn(obj: ?) -> bool",
      byteLength: "fn(string: string, encoding?: string) -> number",
      concat: "fn(list: [+Buffer], totalLength?: number) -> +Buffer",
      "!url": "https://nodejs.org/api/globals.html#globals_class_buffer",
      "!doc": "Used to handle binary data."
    }
  };
});

});

define("tern/plugin/requirejs",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern"], mod);
  mod(tern, tern);
})(function(infer, tern) {
  "use strict";

  function flattenPath(path) {
    if (!/(^|\/)(\.\/|[^\/]+\/\.\.\/)/.test(path)) return path;
    var parts = path.split("/");
    for (var i = 0; i < parts.length; ++i) {
      if (parts[i] == "." || !parts[i]) parts.splice(i--, 1);
      else if (i && parts[i] == "..") parts.splice(i-- - 1, 2);
    }
    return parts.join("/");
  }

  function resolveName(name, data) {
    var excl = name.indexOf("!");
    if (excl > -1) name = name.slice(0, excl);

    var opts = data.options;
    var hasExt = /\.js$/.test(name);
    if (hasExt || /^(?:\w+:|\/)/.test(name))
      return name + (hasExt ? "" : ".js");

    var base = opts.baseURL || "";
    if (base && base.charAt(base.length - 1) != "/") base += "/";
    if (opts.paths) {
      var known = opts.paths[name];
      if (known) return flattenPath(base + known + ".js");
      var dir = name.match(/^([^\/]+)(\/.*)$/);
      if (dir) {
        var known = opts.paths[dir[1]];
        if (known) return flattenPath(base + known + dir[2] + ".js");
      }
    }
    return flattenPath(base + name + ".js");
  }

  function getRequire(data) {
    if (!data.require) {
      data.require = new infer.Fn("require", infer.ANull, [infer.cx().str], ["module"], new infer.AVal);
      data.require.computeRet = function(_self, _args, argNodes) {
        if (argNodes.length && argNodes[0].type == "Literal" && typeof argNodes[0].value == "string")
          return getInterface(path.join(path.dirname(data.currentFile), argNodes[0].value), data);
        return infer.ANull;
      };
    }
    return data.require;
  }

  function getModuleInterface(data, exports) {
    var mod = new infer.Obj(infer.cx().definitions.requirejs.module, "module");
    var expProp = mod.defProp("exports");
    expProp.propagate(getModule(data.currentFile, data));
    exports.propagate(expProp, EXPORT_OBJ_WEIGHT);
    return mod;
  }

  function getExports(data) {
    var exports = new infer.Obj(true, "exports");
    getModule(data.currentFile, data).addType(exports, EXPORT_OBJ_WEIGHT);
    return exports;
  }

  function getInterface(name, data) {
    if (data.options.override && Object.prototype.hasOwnProperty.call(data.options.override, name)) {
      var over = data.options.override[name];
      if (typeof over == "string" && over.charAt(0) == "=") return infer.def.parsePath(over.slice(1));
      if (typeof over == "object") {
        var known = getKnownModule(name, data);
        if (known) return known;
        var scope = data.interfaces[stripJSExt(name)] = new infer.Obj(null, stripJSExt(name));
        infer.def.load(over, scope);
        return scope;
      }
      name = over;
    }

    if (!/^(https?:|\/)|\.js$/.test(name))
      name = resolveName(name, data);
    name = flattenPath(name);

    var known = getKnownModule(name, data);

    if (!known) {
      known = getModule(name, data);
      data.server.addFile(name, null, data.currentFile);
    }
    return known;
  }

  function getKnownModule(name, data) {
    return data.interfaces[stripJSExt(name)];
  }

  function getModule(name, data) {
    var known = getKnownModule(name, data);
    if (!known) {
      known = data.interfaces[stripJSExt(name)] = new infer.AVal;
      known.origin = name;
    }
    return known;
  }

  var EXPORT_OBJ_WEIGHT = 50;

  function stripJSExt(f) {
    return f.replace(/\.js$/, '');
  }

  var path = {
    dirname: function(path) {
      var lastSep = path.lastIndexOf("/");
      return lastSep == -1 ? "" : path.slice(0, lastSep);
    },
    relative: function(from, to) {
      if (to.indexOf(from) == 0) return to.slice(from.length);
      else return to;
    },
    join: function(a, b) {
      if (b && b.charAt(0) != ".") return b;
      if (a && b) return a + "/" + b;
      else return (a || "") + (b || "");
    }
  };

  function runModule(server, args, argNodes, out) {
    var data = server.mod.requireJS;
    var deps = [], fn, exports, mod;

    function interf(name) {
      if (name == "require") return getRequire(data);
      if (name == "exports") return exports || (exports = getExports(data));
      if (name == "module") return mod || (mod = getModuleInterface(data, exports || (exports = getExports(data))));
      return getInterface(name, data);
    }

    if (argNodes && args.length > 1) {
      var node = argNodes[args.length == 2 ? 0 : 1];
      var base = path.relative(server.projectDir, path.dirname(node.sourceFile.name));
      if (node.type == "Literal" && typeof node.value == "string") {
        node.required = interf(path.join(base, node.value), data);
        deps.push(node.required);
      } else if (node.type == "ArrayExpression") for (var i = 0; i < node.elements.length; ++i) {
        var elt = node.elements[i];
        if (elt.type == "Literal" && typeof elt.value == "string") {
          elt.required = interf(path.join(base, elt.value), data);
          deps.push(elt.required);
        }
      }
    } else if (argNodes && args.length == 1 &&
               /FunctionExpression/.test(argNodes[0].type) &&
               argNodes[0].params.length) {
      deps.push(interf("require", data), interf("exports", data), interf("module", data));
      fn = args[0];
    }

    if (!fn) {
      fn = args[Math.min(args.length - 1, 2)];
      if (!fn.isEmpty() && !fn.getFunctionType()) fn = null;
    }

    if (fn) {
      fn.propagate(new infer.IsCallee(infer.ANull, deps, null, out || infer.ANull));
      if (out) out.originNode = fn.originNode;
    } else if (out) {
      args[0].propagate(out)
    }

    return infer.ANull;
  }

  infer.registerFunction("requirejs_define", function(_self, args, argNodes) {
    if (!args.length) return infer.ANull

    var server = infer.cx().parent, data = server.mod.requireJS
    return runModule(server, args, argNodes, getModule(data.currentFile, data))
  });

  infer.registerFunction("requirejs_require", function(_self, args, argNodes) {
    if (!args.length) return infer.ANull
    return runModule(infer.cx().parent, args, argNodes)
  });
  function parseExprNode(node) {
    switch (node.type) {
    case "ArrayExpression":
      return node.elements.map(parseExprNode);
    case "Literal":
      return node.value;
    case "ObjectExpression":
      var obj = {};
      node.properties.forEach(function(prop) {
        var key = prop.key.name || prop.key.value;
        obj[key] = parseExprNode(prop.value);
      });
      return obj;
    }
  }

  infer.registerFunction("requirejs_config", function(_self, _args, argNodes) {
    var server = infer.cx().parent, data = server && server.mod.requireJS;
    if (data && argNodes && argNodes.length && argNodes[0].type == "ObjectExpression") {
      var config = parseExprNode(argNodes[0]);
      for (var key in config) if (config.hasOwnProperty(key)) {
        var value = config[key], exists = data.options[key];
        if (!exists) {
          data.options[key] = value;
        } else if (key == "paths") {
          for (var path in value) if (value.hasOwnProperty(path) && !data.options.paths[path])
            data.options.paths[path] = value[path];
        }
      }
    }
    return infer.ANull;
  });

  function preCondenseReach(state) {
    var interfaces = infer.cx().parent.mod.requireJS.interfaces;
    var rjs = state.roots["!requirejs"] = new infer.Obj(null);
    for (var name in interfaces) {
      var prop = rjs.defProp(name.replace(/\./g, "`"));
      interfaces[name].propagate(prop);
      prop.origin = interfaces[name].origin;
    }
  }

  function postLoadDef(data) {
    var cx = infer.cx(), interfaces = cx.definitions[data["!name"]]["!requirejs"];
    var data = cx.parent.mod.requireJS;
    if (interfaces) for (var name in interfaces.props) {
      interfaces.props[name].propagate(getInterface(name, data));
    }
  }

  tern.registerPlugin("requirejs", function(server, options) {
    server.mod.requireJS = {
      interfaces: Object.create(null),
      options: options || {},
      currentFile: null,
      server: server
    };

    server.on("beforeLoad", function(file) {
      this.mod.requireJS.currentFile = file.name;
    });
    server.on("reset", function() {
      this.mod.requireJS.interfaces = Object.create(null);
      this.mod.requireJS.require = null;
    });

    server.on("preCondenseReach", preCondenseReach)
    server.on("postLoadDef", postLoadDef)
    server.on("typeAt", findTypeAt)
    server.on("completion", findCompletions)

    server.addDefs(defs)
  });

  function findTypeAt(_file, _pos, expr, type) {
    if (!expr || expr.node.type != "Literal" ||
        typeof expr.node.value != "string" || !expr.node.required)
      return type;
    type = Object.create(type);
    var exportedType = expr.node.required;
    type.origin = exportedType.origin;
    type.originNode = exportedType.originNode;
    if (exportedType.doc) type.doc = exportedType.doc
    if (exportedType.url) type.url = exportedType.url
    return type;
  }

  function findCompletions(file, query) {
    var wordEnd = tern.resolvePos(file, query.end);
    var callExpr = infer.findExpressionAround(file.ast, null, wordEnd, file.scope, "CallExpression");
    if (!callExpr) return;
    var callNode = callExpr.node;
    if (callNode.callee.type != "Identifier" ||
        !(callNode.callee.name == "define" || callNode.callee.name == "require" || callNode.callee.name == "requirejs")||
        callNode.arguments.length < 1 || callNode.arguments[0].type != "ArrayExpression") return;
    var argNode = findRequireModule(callNode.arguments[0].elements, wordEnd);
    if (!argNode) return;
    var word = argNode.raw.slice(1, wordEnd - argNode.start), quote = argNode.raw.charAt(0);
    if (word && word.charAt(word.length - 1) == quote)
      word = word.slice(0, word.length - 1);
    var completions = completeModuleName(query, word, file.name);
    if (argNode.end == wordEnd + 1 && file.text.charAt(wordEnd) == quote)
      ++wordEnd;
    return {
      start: tern.outputPos(query, file, argNode.start),
      end: tern.outputPos(query, file, wordEnd),
      isProperty: false,
      isObjectKey: false,
      completions: completions.map(function(rec) {
        var name = typeof rec == "string" ? rec : rec.name;
        var string = JSON.stringify(name);
        if (quote == "'") string = quote + string.slice(1, string.length -1).replace(/'/g, "\\'") + quote;
        if (typeof rec == "string") return string;
        rec.displayName = name;
        rec.name = string;
        return rec;
      })
    };
  }

  function findRequireModule(argsNode, wordEnd) {
    for (var i = 0; i < argsNode.length; i++) {
      var argNode = argsNode[i];
      if (argNode.type == "Literal" && typeof argNode.value == "string" &&
          argNode.start < wordEnd && argNode.end > wordEnd) return argNode;
    }
  }

  function completeModuleName(query, word, parentFile) {
    var cx = infer.cx(), server = cx.parent, data = server.mod.requireJS;
    var currentName = stripJSExt(parentFile);
    var base = data.options.baseURL || "";
    if (base && base.charAt(base.length - 1) != "/") base += "/";

    if (query.caseInsensitive) word = word.toLowerCase();

    var completions = [], modules = data.interfaces;
    for (var name in modules) {
      if (name == currentName || !modules[name].getType()) continue;

      var moduleName = name.substring(base.length, name.length);
      if (moduleName &&
          !(query.filter !== false && word &&
            (query.caseInsensitive ? moduleName.toLowerCase() : moduleName).indexOf(word) !== 0))
        tern.addCompletion(query, completions, moduleName, modules[name]);
    }
    return completions;
  }

  var defs = {
    "!name": "requirejs",
    "!define": {
      module: {
        id: "string",
        uri: "string",
        config: "fn() -> ?"
      },
      config: {
        "!url": "http://requirejs.org/docs/api.html#config",
        baseUrl: {
          "!type": "string",
          "!doc": "the root path to use for all module lookups",
          "!url": "http://requirejs.org/docs/api.html#config-baseUrl"
        },
        paths: {
          "!type": "?",
          "!doc": "path mappings for module names not found directly under baseUrl. The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a '/' or has a URL protocol in it ('like http:').",
          "!url": "http://requirejs.org/docs/api.html#config-paths"
        },
        shim: {
          "!type": "?",
          "!doc": "Configure the dependencies, exports, and custom initialization for older, traditional 'browser globals' scripts that do not use define() to declare the dependencies and set a module value.",
          "!url": "http://requirejs.org/docs/api.html#config-shim"
        },
        map: {
          "!type": "?",
          "!doc": "For the given module prefix, instead of loading the module with the given ID, substitute a different module ID.",
          "!url": "http://requirejs.org/docs/api.html#config-map"
        },
        config: {
          "!type": "?",
          "!doc": "There is a common need to pass configuration info to a module. That configuration info is usually known as part of the application, and there needs to be a way to pass that down to a module. In RequireJS, that is done with the config option for requirejs.config(). Modules can then read that info by asking for the special dependency 'module' and calling module.config().",
          "!url": "http://requirejs.org/docs/api.html#config-moduleconfig"
        },
        packages: {
          "!type": "?",
          "!doc": "configures loading modules from CommonJS packages. See the packages topic for more information.",
          "!url": "http://requirejs.org/docs/api.html#config-packages"
        },
        nodeIdCompat: {
          "!type": "?",
          "!doc": "Node treats module ID example.js and example the same. By default these are two different IDs in RequireJS. If you end up using modules installed from npm, then you may need to set this config value to true to avoid resolution issues.",
          "!url": "http://requirejs.org/docs/api.html#config-nodeIdCompat"
        },
        waitSeconds: {
          "!type": "number",
          "!doc": "The number of seconds to wait before giving up on loading a script. Setting it to 0 disables the timeout. The default is 7 seconds.",
          "!url": "http://requirejs.org/docs/api.html#config-waitSeconds"
        },
        context: {
          "!type": "number",
          "!doc": "A name to give to a loading context. This allows require.js to load multiple versions of modules in a page, as long as each top-level require call specifies a unique context string. To use it correctly, see the Multiversion Support section.",
          "!url": "http://requirejs.org/docs/api.html#config-context"
        },
        deps: {
          "!type": "?",
          "!doc": "An array of dependencies to load. Useful when require is defined as a config object before require.js is loaded, and you want to specify dependencies to load as soon as require() is defined. Using deps is just like doing a require([]) call, but done as soon as the loader has processed the configuration. It does not block any other require() calls from starting their requests for modules, it is just a way to specify some modules to load asynchronously as part of a config block.",
          "!url": "http://requirejs.org/docs/api.html#config-deps"
        },
        callback: {
          "!type": "fn()",
          "!doc": "A function to execute after deps have been loaded. Useful when require is defined as a config object before require.js is loaded, and you want to specify a function to require after the configuration's deps array has been loaded.",
          "!url": "http://requirejs.org/docs/api.html#config-callback"
        },
        enforceDefine: {
          "!type": "bool",
          "!doc": "If set to true, an error will be thrown if a script loads that does not call define() or have a shim exports string value that can be checked. See Catching load failures in IE for more information.",
          "!url": "http://requirejs.org/docs/api.html#config-enforceDefine"
        },
        xhtml: {
          "!type": "bool",
          "!doc": "If set to true, document.createElementNS() will be used to create script elements.",
          "!url": "http://requirejs.org/docs/api.html#config-xhtml"
        },
        urlArgs: {
          "!type": "string",
          "!doc": "Extra query string arguments appended to URLs that RequireJS uses to fetch resources. Most useful to cache bust when the browser or server is not configured correctly.",
          "!url": "http://requirejs.org/docs/api.html#config-urlArgs"
        },
        scriptType: {
          "!type": "string",
          "!doc": "Specify the value for the type='' attribute used for script tags inserted into the document by RequireJS. Default is 'text/javascript'. To use Firefox's JavaScript 1.8 features, use 'text/javascript;version=1.8'.",
          "!url": "http://requirejs.org/docs/api.html#config-scriptType"
        },
        skipDataMain: {
          "!type": "bool",
          "!doc": "Introduced in RequireJS 2.1.9: If set to true, skips the data-main attribute scanning done to start module loading. Useful if RequireJS is embedded in a utility library that may interact with other RequireJS library on the page, and the embedded version should not do data-main loading.",
          "!url": "http://requirejs.org/docs/api.html#config-skipDataMain"
        }
      },
      RequireJSError: {
        "prototype" : {
          "!proto": "Error.prototype",
          "requireType": {
            "!type": "string",
            "!doc": "A string value with a general classification, like 'timeout', 'nodefine', 'scripterror'.",
            "!url": "http://requirejs.org/docs/api.html#errors"
          },
          "requireModules": {
            "!type": "[string]",
            "!doc": "An array of module names/URLs that timed out.",
            "!url": "http://requirejs.org/docs/api.html#errors"
          }
        }
      }
    },
    requirejs: {
      "!type": "fn(deps: [string], callback: fn(), errback?: fn(err: +RequireJSError)) -> !custom:requirejs_require",
      onError: {
        "!type": "fn(err: +RequireJSError)",
        "!doc": "To detect errors that are not caught by local errbacks, you can override requirejs.onError()",
        "!url": "http://requirejs.org/docs/api.html#requirejsonerror"
      },
      load: {
        "!type": "fn(context: ?, moduleName: string, url: string)"
      },
      config: "fn(config: config) -> !custom:requirejs_config",
      version: "string",
      isBrowser: "bool"
    },
    require: "requirejs",
    define: {
      "!type": "fn(deps: [string], callback: fn()) -> !custom:requirejs_define",
      amd: {
        jQuery: "bool"
      }
    }
  };
});

});

define("plugins/c9.ide.language.javascript.tern/worker/tern_worker",[], function(require, exports, module) {
var acornHelper = require("./acorn_helper");
var tern = require("tern/lib/tern");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var handler = module.exports = Object.create(baseLanguageHandler);
var tree = require("treehugger/tree");
var util = require("plugins/c9.ide.language/worker_util");
var completeUtil = require("plugins/c9.ide.language/complete_util");
var filterDocumentation = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util").filterDocumentation;
var getParameterDocs = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util").getParameterDocs;
var architectResolver = null;
var inferCompleter = require("plugins/c9.ide.language.javascript.infer/infer_completer");

var TERN_DEFS = [];
var BUILTIN_PLUGINS = {
    doc_comment: require("tern/plugin/doc_comment"),
    es_modules: require("tern/plugin/es_modules"),
    modules: require("tern/plugin/modules"),
    node: require("tern/plugin/node"),
    node_resolve: require("tern/plugin/node_resolve"),
    requirejs: require("tern/plugin/requirejs"),
    architect_resolver: architectResolver,
};

var ternWorker;
var ternServerOptions = {};
var ternRequestOptions = {};
var fileCache = {};
var dirCache = {};
var firstClassDefs = [];
var lastAddPath;
var lastAddValue;
var lastCacheRead = 0;
var MAX_CACHE_AGE = 60 * 1000 * 10;
var MAX_FILE_SIZE = 200 * 1024;
var PRIORITY_DEFAULT = 5;
var PRIORITY_LIBRARY_GLOBAL = 0;
function mix() {
    var arg, prop, child = {};
    for (arg = 0; arg < arguments.length; arg += 1) {
        if (!arguments[arg]) {
            continue;
        }
        for (prop in arguments[arg]) {
            if (arguments[arg].hasOwnProperty(prop)) {
                child[prop] = arguments[arg][prop];
            }
        }
    }
    return child;
}


handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.getCompletionRegex = function() {
    return (/^[\.]$/);
};

handler.getMaxFileSizeSupported = function() {
    return .25 * 10 * 1000 * 80;
};

handler.$recacheCompletionLength = 3;

handler.init = function(callback) {
    initTern();
    inferCompleter.setExtraModules(ternWorker.cx.definitions.node);

    ternWorker.on("beforeLoad", function(e) {
        var file = e.name;
        var dir = dirname(e.name);

        if (dir[0] != "/")
            return;

        if (!dirCache[dir])
            util.$watchDir(dir, handler);

        fileCache[file] = fileCache[file] || {};
        dirCache[dir] = dirCache[dir] || {};
        dirCache[dir].used = Date.now();
        dirCache[dir][file] = true;
        lastCacheRead = Date.now();
    });

    handler.sender.on("tern_set_def_enabled", function(e) {
        setDefEnabled(e.data.name, e.data.def, e.data.enabled, e.data.options);
    });

    handler.sender.on("tern_set_server_options", function(e) {
        setOptions(e.data);
    });

    handler.sender.on("tern_set_request_options", function(e) {
        if (e.data) {
            ternRequestOptions = e.data;
        }
    });

    handler.sender.on("tern_get_plugins", function(e) {
        var pluginName;
        var plugins = [];
        var pluginToList;
        for (pluginName in ternWorker.options.plugins) {
            pluginToList = {
                name: pluginName,
                enabled: ternWorker.options.plugins[pluginName]
            };
            plugins.push(pluginToList);
        }
        handler.sender.emit("tern_read_plugins", plugins);
    });

    handler.sender.on("tern_update_plugins", function(e) {
        updatePlugins(e.data);
    });

    util.$onWatchDirChange(onWatchDirChange);
    setInterval(garbageCollect, 60000);
    callback();
};

function initTern() {
    ternWorker = new tern.Server({
        async: ternServerOptions.async !== undefined ? ternServerOptions.async : true,
        defs: ternServerOptions.defs !== undefined ? ternServerOptions.defs : TERN_DEFS,
        plugins: ternServerOptions.plugins !== undefined ? ternServerOptions.plugins : {},
        dependencyBudget: ternServerOptions.dependencyBudget !== undefined ? ternServerOptions.dependencyBudget : MAX_FILE_SIZE,
        reuseInstances: ternServerOptions.reuseInstances !== undefined ? ternServerOptions.reuseInstances : true,
        normalizeFilename: function(file) {
            if (file[0] != "/")
                file = "/" + file;
            if (!file.match(/[\/\\][^/\\]*\.[^/\\]*$/))
                file += ".js";
            return file;
        },
        getFile: ternServerOptions.getFile !== undefined ? ternServerOptions.getFile : function(file, callback) {
            if (file == handler.path)
                return done(null, handler.doc.getValue());

            util.stat(file, function(err, stat) {
                if (stat && stat.size > MAX_FILE_SIZE) {
                    err = new Error("File is too large to include");
                    err.code = "ESIZE";
                }

                if (err)
                    return done(err);

                fileCache[file] = fileCache[file] || {};
                fileCache[file].mtime = stat.mtime;

                util.readFile(file, { allowUnsaved: true }, function(err, data) {
                    if (err) return done(err);

                    lastAddPath = null; // invalidate cache
                    done(null, data);
                });
            });

            function done(err, result) {
                try {
                    callback(err, result);
                }
                catch (err) {
                    console.error(err.stack);
                }
            }
        }
    });
}

var setOptions = module.exports.setOptions = function(options) {
    for (var o in options) {
        ternWorker.options[o] = ternServerOptions[o] = options[o];
    }
};
var updatePlugins = module.exports.updatePlugins = function(plugins) {
    var requiresReset = false;
    for (var p in plugins) {
        var targetPlugin = plugins[p];
        var plugin = ternWorker.options.plugins[targetPlugin.name];
        if (targetPlugin.name == "angular")
            continue;
        if (targetPlugin.firstClass)
            firstClassDefs.push(targetPlugin.name);
        if (typeof plugin === "undefined" && typeof targetPlugin.path === "string") {
            var loaded = require(targetPlugin.path);
            if (!loaded) {
                console.error("Could not load", targetPlugin.path);
                continue;
            }
            
            ternServerOptions.plugins = ternServerOptions.plugins || {};
            ternServerOptions.plugins[targetPlugin.name] = targetPlugin.enabled;

            if (targetPlugin.name === "architect_resolver")
                architectResolver = loaded;

            requiresReset = true;
        }
        else {
            if (plugin !== targetPlugin.enabled) {
                ternServerOptions.plugins = ternServerOptions.plugins || {};
                ternServerOptions.plugins[targetPlugin.name] = targetPlugin.enabled;
                requiresReset = true;
            }
        }
    }
    if (requiresReset)
        initTern();
    ternWorker.defs.forEach(function(d) {
        if (d["!name"] === "node")
            delete d.console;
    });
};

function onWatchDirChange(e) {
    var dir = e.data.path.replace(/\/?$/, "/");
    e.data.files.forEach(function(stat) {
        var file = dir + stat.name;
        if (!fileCache[file] || fileCache[file].mtime >= stat.mtime)
            return;
        ternWorker.delFile(file);
        delete fileCache[file];
        lastAddPath = null; // invalidate local file cache
    });
}

function garbageCollect() {
    var minAge = lastCacheRead - MAX_CACHE_AGE;

    for (var file in fileCache) {
        if (fileCache[file].used < minAge) {
            ternWorker.delFile(file);
            delete fileCache[file];
            if (lastAddPath === file)
                lastAddPath = null;
        }
    }

    for (var dir in dirCache) {
        if (dirCache[dir].used < minAge) {
            handler.sender.emit("unwatchDir", { path: dir });
            delete dirCache[file];
        }
    }
}

handler.onDocumentOpen = function(path, doc, oldPath, callback) {
    setJSXMode(path);
    callback();
};

handler.analyze = function(value, ast, options, callback) {
    if (fileCache[this.path])
        return callback();
    fileCache[this.path] = {
        mtime: 0, // prefer reloading since we may be unsaved
        used: Date.now()
    };
    addTernFile(this.path, value);

    if (!architectResolver)
        return callback();

    architectResolver.onceReady(function() {
        handler.$flush(function(err) {
            if (err) console.error(err.stack || err);
            callback();
        });
    });
};

handler.complete = function(doc, fullAst, pos, options, callback) {
    var node = options.node;
    if (!node ||
        ["FArg", "Function", "Arrow", "VarDecl", "VarDeclInit", "ConstDecl", "ConstDeclInit",
        "LetDecl", "LetDeclInit", "PropertyInit", "Label", "String"].indexOf(node.cons) > -1)
        return callback();

    addTernFile(this.path, doc.getValue());

    var line = doc.getLine(pos.row);
    var prefix = util.getPrecedingIdentifier(line, pos.column);
    var defaultOptions = {
        type: "completions",
        pos: pos,
        types: true,
        origins: true,
        docs: true,
        urls: true,
        guess: true,
        caseInsensitive: false,
    };
    var ternOptions = mix(defaultOptions, ternRequestOptions[defaultOptions.type]);
    handler.$request(ternOptions, function(err, result) {
        if (err) {
            console.error(err.stack || err);
            return callback();
        }

        callback(result.completions.map(function(match) {
            if (match.guess && match.type && match.type !== "fn()?)")
               return;
            if (match.type === "?")
                delete match.type;

            var isContextual = node.cons === "PropAccess" && !match.guess;

            if (!isContextual && match.origin === "browser" && prefix.length < 3)
                return; // skip completions like onchange (from window.onchange)

            var isFromLibrary = match.origin && match.origin[0] !== "/" && firstClassDefs.indexOf(match.origin) === -1;
            var priority = PRIORITY_DEFAULT;
            var icon = getIcon(match, priority);
            if (match.name[0] === '"') {
                if (match.origin !== "node")
                    return;
                match.name = match.name.replace(/"(.*)"/, "$1");
                icon = "package";
            }

            var isFunction = match.type && match.type.match(/^fn\(/);
            var isAnonymous = match.type && match.type.match(/^{/);
            var fullName;
            var fullNameTyped;
            if (isFunction) {
                var sig = getSignature(match);
                var parameters = sig.parameters;
                fullName = match.name + "(" + parameters.map(function(p) {
                    return p.name;
                }).join(", ") + ")";
                fullNameTyped = match.name + "(" + parameters.map(function(p) {
                    return p.name + (p.type ? " : " + p.type : "");
                }).join(", ") + ")";
                if (sig.returnType)
                    fullNameTyped = fullNameTyped + " : " + sig.returnType;
            }
            else {
                fullName = fullNameTyped = match.name;
                if (match.type)
                    fullNameTyped = fullNameTyped + " : " + match.type;
            }

            var doc = (match.type && !isFunction && !isAnonymous ? "Type: " + match.type + "<p>" : "")
                    + (match.doc ? filterDocumentation(match.doc) : "");
            if (match.doc === "Every function in JavaScript is actually a Function object.")
                doc = "";
            return {
                id: match.name,
                name: fullName,
                replaceText: match.name + (isFunction ? "(^^)" : ""),
                icon: icon,
                priority: priority,
                isContextual: isContextual,
                docHead: fullNameTyped,
                doc: (match.origin && isFromLibrary ? "Origin: " + match.origin + "<p>" : "") + doc,
                docUrl: match.url,
                isFunction: isFunction,
                url: match.url
            };
        }).filter(function(c) {
            return c;
        }));
    });
};

handler.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    addTernFile(this.path, doc.getValue());
    var defaultOptions = {
        type: "definition",
        pos: pos,
        types: true,
        origins: true,
        docs: true,
        urls: true,
        caseInsensitive: false,
    };
    var ternOptions = mix(defaultOptions, ternRequestOptions[defaultOptions.type]);
    this.$request(ternOptions, function(err, result) {
        if (err) {
            console.error(err.stack || err);
            return callback();
        }
        if (!result.file)
            return callback();
        if (!result.file.match(/[\/\\][^/\\]*\.[^/\\]*$/))
            result.file += ".js";
        callback({
            path: result.file,
            row: result.start.line,
            column: result.start.ch,
            icon: getIcon(result, PRIORITY_DEFAULT)
        });
    });
};

handler.tooltip = function(doc, fullAst, cursorPos, options, callback) {
    var node = options.node;
    if (!node)
        return callback();
    var argIndex = -1;

    var callNode = getCallNode(node, cursorPos);
    var displayPos;

    if (callNode) {
        var argPos = { row: callNode[1].getPos().sl, column: callNode[1].getPos().sc };
        if (argPos.row >= 9999999999)
            argPos = cursorPos;

        var endLine = callNode.getPos().el;
        if (callNode[1].length && callNode[1].getPos().el !== callNode.getPos().el)
            endLine--; // put tooltip near end of arguments, not end of call
        displayPos = { row: endLine, column: callNode[1].getPos().sc };
        argIndex = this.getArgIndex(callNode, doc, cursorPos);
    }
    else if (node.isMatch('Var(_)')) {
        displayPos = { row: node.getPos().sl, column: node.getPos().sc };
        argIndex = -1;
        if (cursorPos.column === node.getPos().ec)
            return callback();
    }
    else {
        return callback();
    }

    if (argIndex === -1 && callNode)
        return callback();

    if (!callNode)
        return callback(); // TODO: support this case??

    addTernFile(this.path, doc.getValue());
    var defaultOptions = {
        type: "type",
        pos: { row: callNode[0].getPos().el, column: callNode[0].getPos().ec },
        types: true,
        origins: true,
        docs: true,
        urls: true,
        caseInsensitive: false,
        preferFunction: true,
    };
    var ternOptions = mix(defaultOptions, ternRequestOptions[defaultOptions.type]);
    this.$request(ternOptions, function(err, result) {
        if (err) {
            console.error(err.stack || err);
            return callback();
        }
        if (!result.type || !result.name || !result.type.match(/^fn\(/))
            return callback();

        var rangeNode = callNode && callNode.getPos().sc < 99999 ? callNode : node;
        var sig = getSignature(result);
        if (sig.parameters[argIndex])
            sig.parameters[argIndex].active = true;

        var parameterDocs = getParameterDocs(result.doc);
        sig.parameters.forEach(function(p) {
            if (p.type === "?")
                delete p.type;
            if (parameterDocs["_" + p.name])
                p.docHtml = parameterDocs["_" + p.name];
        });
        if (sig.returnType === "?")
            delete sig.returnType;
        if (sig.returnType === "[]")
            sig.returnType = "Array";

        callback({
            hint: {
                signatures: [{
                    name: result.name.replace(/.*\./, ""),
                    docHtml: result.doc && result.doc.replace(/^\* /g, ""),
                    parameters: sig.parameters,
                    returnType: sig.returnType
                }],
            },
            displayPos: displayPos,
            pos: rangeNode.getPos()
        });
    });
};
handler.getArgIndex = function(node, doc, cursorPos) {
    var cursorTreePos = { line: cursorPos.row, col: cursorPos.column };
    var result = -1;
    node.rewrite(
        'Call(e, args)', "New(e, args)", function(b) {
            result = -1;
            var line = doc.getLine(cursorPos.row);
            if (line[b.args.getPos().ec + 1] && line[b.args.getPos().ec + 1].match(/[ ,]/))
                b.args.getPos().ec++;

            if (b.args.length === 0 && this.getPos().ec - 1 === cursorPos.column) {
                result = 0;
            }
            else if (b.args.length === 0 && line.substr(cursorPos.column).match(/^\s*\)/)) {
                result = 0;
            }
            else if (!tree.inRange(this.getPos(), cursorTreePos, true)) {
                return this;
            }
            else if (cursorPos.row === this.getPos().sl && line.substr(0, cursorPos.column + 1).match(/,\s*\)$/)) {
                result = b.args.length;
                return this;
            }
            for (var i = 0; i < b.args.length; i++) {
                if (b.args[i].cons === "ERROR" && result === -1) {
                    result = i;
                    break;
                }
                b.args[i].traverseTopDown(function() {
                    var pos = this.getPos();
                    if (this === node) {
                        result = i;
                        return this;
                    }
                    else if (pos && pos.sl <= cursorPos.row && pos.sc <= cursorPos.column) {
                        if (pos.sl === cursorPos.row && pos.ec === cursorPos.column - 1 && line[pos.ec] === ")")
                            return result = -1;
                        result = i;
                    }
                });
            }
            return this;
        }
    );
    return result;
};

function getCallNode(currentNode, cursorPos) {
    var result;
    var previous;
    currentNode.traverseUp(
        'Call(e, args)', 'New(e, args)', function(b, node) {
            if (b.e === previous)
                return;
            result = node;
            return node;
        },
        'Function(x, args, body)', 'Arrow(args, body)', function(b, node) {
            if (node !== currentNode)
                return node;
            previous = node;
        },
        'PropertyInit(x, _)', 'Method(x, body)', function(b, node) {
            return node;
        },
        function(node) {
            previous = node;
        }
    );
    return result;
}

function getIcon(property, priority) {
    if (property.guess || !property.type || property.type === "fn()?") {
        return property.type ? "method2" : "property2";
    }
    else if (property.type.match(/^fn\(/)) {
        return priority ? "method" : "method2";
    }
    else {
        return priority ? "property" : "property2";
    }
}

function addTernFile(path, value) {
    if (lastAddPath === path && lastAddValue === value)
        return;
    lastAddPath = path;
    lastAddValue = value;
    setJSXMode(path);
    ternWorker.addFile(path, value);
}

function dirname(path) {
    return path.replace(/[\/\\][^\/\\]*$/, "");
}
function getSignature(property) {
    if (!property.type || !property.type.match(/^fn\(/))
        return { parameters: []};
    var sig = property.type;
    var parameters = [{ name: "", type: "" }];
    var parameterIndex = 0;
    var returnType = "";
    var depth = 0;
    var inType = false;
    var inReturn = false;
    for (var i = "fn(".length; i < sig.length; i++) {
        switch (sig[i]) {
            case "(": case "{":
                depth++; break;
            case ")": case "}":
                depth--; break;
            case ":":
                inType = true; break;
            case ",":
                if (depth)
                    break;
                inType = false;
                parameters.push({ name: "", type: "" });
                parameterIndex++;
                break;
            case " ":
                break;
            case "-": // ->
                if (depth >= 0)
                    break;
                i++;
                depth++;
                inType = false;
                inReturn = true;
                break;
            case "?":
                if (!depth && inType && parameters[parameterIndex].type)
                    parameters[parameterIndex].name = "[" + parameters[parameterIndex].name + "]";
                break;
            default:
                if (sig[i] === "]")
                    depth--;
                if (!depth && inReturn)
                    returnType += sig[i];
                else if (!depth && !inType)
                    parameters[parameterIndex].name += sig[i];
                else if (!depth && inType)
                    parameters[parameterIndex].type += sig[i];
                if (sig[i] === "[")
                    depth++;
        }
    }

    parameters.forEach(function(p) {
        if (p.type === "?")
            delete p.type;
        if (p.type === "[]")
            p.type = "Array";
        if (p.type)
            p.type = p.type.replace(/\.prototype$/, "").replace(/.*\./, "");
    });


    if (parameters[0].name === "")
        parameters.shift();

    return {
        parameters: parameters,
        returnType: returnType && returnType.replace(/\.prototype$/, "").replace(/.*\./, "")
    };
}

handler.$request = function(query, callback) {
    query.file = this.path;
    setJSXMode(this.path);

    if (query.pos)
        query.end = query.start = {
            line: query.pos.row || query.pos.sl || 0,
            ch: query.pos.column || query.pos.sc || 0
        };
    query.lineCharPositions = true;

    try {
        ternWorker.request(
            {
                query: query,
            },
            done
        );
    }
    catch (err) {
        if (isDone) throw err;
        return done(err);
    }

    var isDone;
    function done(err, result) {
        isDone = true;
        callback(err, result);
    }
};

handler.$flush = function(callback) {
    try {
        ternWorker.flush(done);
    }
    catch (err) {
        if (isDone) throw err;
        return done(err);
    }

    var isDone;
    function done(err, result) {
        isDone = true;
        callback(err, result);
    }
};
function setDefEnabled(name, def, enabled, options) {
    if (options && options.firstClass)
        firstClassDefs.push(name);
    
    var i;
    if (!enabled) {
        ternWorker.defs = ternWorker.defs.filter(function(d) {
            return d["!name"] !== name;
        });
        ternWorker.reset();
        ternServerOptions.defs = ternWorker.defs;
        return;
    }

    var defs = def instanceof Array ? def : [def];
    var downloaded = 0;
    defs.forEach(function(def) {
        if (typeof def !== "string") {
            ternWorker.defs.push(def);
            return checkDone();
        }
            
        completeUtil.fetchText(def, function(err, result) {
            if (err) console.error(err);
            try {
                result = JSON.parse(result);
            }
            catch (err) {
                console.error(err);
                result = null;
            }

            ternWorker.defs.push(result);
            checkDone();
        });
    });
    function checkDone() {
        if (++downloaded < defs.length)
            return;
        ternServerOptions.defs = ternWorker.defs;
        ternWorker.reset();
    }
}

function setJSXMode(path) {
    acornHelper.setLanguage(/\.jsx$/.test(path) ? "jsx" : null);
}

});

define("ace/mode/css/csslint",[], function(require, exports, module) {
var parserlib = {};
(function(){
function EventTarget(){
    this._listeners = {};
}

EventTarget.prototype = {
    constructor: EventTarget,
    addListener: function(type, listener){
        if (!this._listeners[type]){
            this._listeners[type] = [];
        }

        this._listeners[type].push(listener);
    },
    fire: function(event){
        if (typeof event == "string"){
            event = { type: event };
        }
        if (typeof event.target != "undefined"){
            event.target = this;
        }

        if (typeof event.type == "undefined"){
            throw new Error("Event object missing 'type' property.");
        }

        if (this._listeners[event.type]){
            var listeners = this._listeners[event.type].concat();
            for (var i=0, len=listeners.length; i < len; i++){
                listeners[i].call(this, event);
            }
        }
    },
    removeListener: function(type, listener){
        if (this._listeners[type]){
            var listeners = this._listeners[type];
            for (var i=0, len=listeners.length; i < len; i++){
                if (listeners[i] === listener){
                    listeners.splice(i, 1);
                    break;
                }
            }


        }
    }
};
function StringReader(text){
    this._input = text.replace(/\n\r?/g, "\n");
    this._line = 1;
    this._col = 1;
    this._cursor = 0;
}

StringReader.prototype = {
    constructor: StringReader,
    getCol: function(){
        return this._col;
    },
    getLine: function(){
        return this._line ;
    },
    eof: function(){
        return (this._cursor == this._input.length);
    },
    peek: function(count){
        var c = null;
        count = (typeof count == "undefined" ? 1 : count);
        if (this._cursor < this._input.length){
            c = this._input.charAt(this._cursor + count - 1);
        }

        return c;
    },
    read: function(){
        var c = null;
        if (this._cursor < this._input.length){
            if (this._input.charAt(this._cursor) == "\n"){
                this._line++;
                this._col=1;
            } else {
                this._col++;
            }
            c = this._input.charAt(this._cursor++);
        }

        return c;
    },
    mark: function(){
        this._bookmark = {
            cursor: this._cursor,
            line:   this._line,
            col:    this._col
        };
    },

    reset: function(){
        if (this._bookmark){
            this._cursor = this._bookmark.cursor;
            this._line = this._bookmark.line;
            this._col = this._bookmark.col;
            delete this._bookmark;
        }
    },
    readTo: function(pattern){

        var buffer = "",
            c;
        while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) != buffer.length - pattern.length){
            c = this.read();
            if (c){
                buffer += c;
            } else {
                throw new Error("Expected \"" + pattern + "\" at line " + this._line  + ", col " + this._col + ".");
            }
        }

        return buffer;

    },
    readWhile: function(filter){

        var buffer = "",
            c = this.read();

        while(c !== null && filter(c)){
            buffer += c;
            c = this.read();
        }

        return buffer;

    },
    readMatch: function(matcher){

        var source = this._input.substring(this._cursor),
            value = null;
        if (typeof matcher == "string"){
            if (source.indexOf(matcher) === 0){
                value = this.readCount(matcher.length);
            }
        } else if (matcher instanceof RegExp){
            if (matcher.test(source)){
                value = this.readCount(RegExp.lastMatch.length);
            }
        }

        return value;
    },
    readCount: function(count){
        var buffer = "";

        while(count--){
            buffer += this.read();
        }

        return buffer;
    }

};
function SyntaxError(message, line, col){
    this.col = col;
    this.line = line;
    this.message = message;

}
SyntaxError.prototype = new Error();
function SyntaxUnit(text, line, col, type){
    this.col = col;
    this.line = line;
    this.text = text;
    this.type = type;
}
SyntaxUnit.fromToken = function(token){
    return new SyntaxUnit(token.value, token.startLine, token.startCol);
};

SyntaxUnit.prototype = {
    constructor: SyntaxUnit,
    valueOf: function(){
        return this.text;
    },
    toString: function(){
        return this.text;
    }

};
function TokenStreamBase(input, tokenData){
    this._reader = input ? new StringReader(input.toString()) : null;
    this._token = null;
    this._tokenData = tokenData;
    this._lt = [];
    this._ltIndex = 0;

    this._ltIndexCache = [];
}
TokenStreamBase.createTokenData = function(tokens){

    var nameMap     = [],
        typeMap     = {},
        tokenData     = tokens.concat([]),
        i            = 0,
        len            = tokenData.length+1;

    tokenData.UNKNOWN = -1;
    tokenData.unshift({name:"EOF"});

    for (; i < len; i++){
        nameMap.push(tokenData[i].name);
        tokenData[tokenData[i].name] = i;
        if (tokenData[i].text){
            typeMap[tokenData[i].text] = i;
        }
    }

    tokenData.name = function(tt){
        return nameMap[tt];
    };

    tokenData.type = function(c){
        return typeMap[c];
    };

    return tokenData;
};

TokenStreamBase.prototype = {
    constructor: TokenStreamBase,
    match: function(tokenTypes, channel){
        if (!(tokenTypes instanceof Array)){
            tokenTypes = [tokenTypes];
        }

        var tt  = this.get(channel),
            i   = 0,
            len = tokenTypes.length;

        while(i < len){
            if (tt == tokenTypes[i++]){
                return true;
            }
        }
        this.unget();
        return false;
    },
    mustMatch: function(tokenTypes, channel){

        var token;
        if (!(tokenTypes instanceof Array)){
            tokenTypes = [tokenTypes];
        }

        if (!this.match.apply(this, arguments)){
            token = this.LT(1);
            throw new SyntaxError("Expected " + this._tokenData[tokenTypes[0]].name +
                " at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
        }
    },
    advance: function(tokenTypes, channel){

        while(this.LA(0) !== 0 && !this.match(tokenTypes, channel)){
            this.get();
        }

        return this.LA(0);
    },
    get: function(channel){

        var tokenInfo   = this._tokenData,
            reader      = this._reader,
            value,
            i           =0,
            len         = tokenInfo.length,
            found       = false,
            token,
            info;
        if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length){

            i++;
            this._token = this._lt[this._ltIndex++];
            info = tokenInfo[this._token.type];
            while((info.channel !== undefined && channel !== info.channel) &&
                    this._ltIndex < this._lt.length){
                this._token = this._lt[this._ltIndex++];
                info = tokenInfo[this._token.type];
                i++;
            }
            if ((info.channel === undefined || channel === info.channel) &&
                    this._ltIndex <= this._lt.length){
                this._ltIndexCache.push(i);
                return this._token.type;
            }
        }
        token = this._getToken();
        if (token.type > -1 && !tokenInfo[token.type].hide){
            token.channel = tokenInfo[token.type].channel;
            this._token = token;
            this._lt.push(token);
            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);
            if (this._lt.length > 5){
                this._lt.shift();
            }
            if (this._ltIndexCache.length > 5){
                this._ltIndexCache.shift();
            }
            this._ltIndex = this._lt.length;
        }
        info = tokenInfo[token.type];
        if (info &&
                (info.hide ||
                (info.channel !== undefined && channel !== info.channel))){
            return this.get(channel);
        } else {
            return token.type;
        }
    },
    LA: function(index){
        var total = index,
            tt;
        if (index > 0){
            if (index > 5){
                throw new Error("Too much lookahead.");
            }
            while(total){
                tt = this.get();
                total--;
            }
            while(total < index){
                this.unget();
                total++;
            }
        } else if (index < 0){

            if(this._lt[this._ltIndex+index]){
                tt = this._lt[this._ltIndex+index].type;
            } else {
                throw new Error("Too much lookbehind.");
            }

        } else {
            tt = this._token.type;
        }

        return tt;

    },
    LT: function(index){
        this.LA(index);
        return this._lt[this._ltIndex+index-1];
    },
    peek: function(){
        return this.LA(1);
    },
    token: function(){
        return this._token;
    },
    tokenName: function(tokenType){
        if (tokenType < 0 || tokenType > this._tokenData.length){
            return "UNKNOWN_TOKEN";
        } else {
            return this._tokenData[tokenType].name;
        }
    },
    tokenType: function(tokenName){
        return this._tokenData[tokenName] || -1;
    },
    unget: function(){
        if (this._ltIndexCache.length){
            this._ltIndex -= this._ltIndexCache.pop();//--;
            this._token = this._lt[this._ltIndex - 1];
        } else {
            throw new Error("Too much lookahead.");
        }
    }

};


parserlib.util = {
StringReader: StringReader,
SyntaxError : SyntaxError,
SyntaxUnit  : SyntaxUnit,
EventTarget : EventTarget,
TokenStreamBase : TokenStreamBase
};
})();
(function(){
var EventTarget = parserlib.util.EventTarget,
TokenStreamBase = parserlib.util.TokenStreamBase,
StringReader = parserlib.util.StringReader,
SyntaxError = parserlib.util.SyntaxError,
SyntaxUnit  = parserlib.util.SyntaxUnit;

var Colors = {
    aliceblue       :"#f0f8ff",
    antiquewhite    :"#faebd7",
    aqua            :"#00ffff",
    aquamarine      :"#7fffd4",
    azure           :"#f0ffff",
    beige           :"#f5f5dc",
    bisque          :"#ffe4c4",
    black           :"#000000",
    blanchedalmond  :"#ffebcd",
    blue            :"#0000ff",
    blueviolet      :"#8a2be2",
    brown           :"#a52a2a",
    burlywood       :"#deb887",
    cadetblue       :"#5f9ea0",
    chartreuse      :"#7fff00",
    chocolate       :"#d2691e",
    coral           :"#ff7f50",
    cornflowerblue  :"#6495ed",
    cornsilk        :"#fff8dc",
    crimson         :"#dc143c",
    cyan            :"#00ffff",
    darkblue        :"#00008b",
    darkcyan        :"#008b8b",
    darkgoldenrod   :"#b8860b",
    darkgray        :"#a9a9a9",
    darkgrey        :"#a9a9a9",
    darkgreen       :"#006400",
    darkkhaki       :"#bdb76b",
    darkmagenta     :"#8b008b",
    darkolivegreen  :"#556b2f",
    darkorange      :"#ff8c00",
    darkorchid      :"#9932cc",
    darkred         :"#8b0000",
    darksalmon      :"#e9967a",
    darkseagreen    :"#8fbc8f",
    darkslateblue   :"#483d8b",
    darkslategray   :"#2f4f4f",
    darkslategrey   :"#2f4f4f",
    darkturquoise   :"#00ced1",
    darkviolet      :"#9400d3",
    deeppink        :"#ff1493",
    deepskyblue     :"#00bfff",
    dimgray         :"#696969",
    dimgrey         :"#696969",
    dodgerblue      :"#1e90ff",
    firebrick       :"#b22222",
    floralwhite     :"#fffaf0",
    forestgreen     :"#228b22",
    fuchsia         :"#ff00ff",
    gainsboro       :"#dcdcdc",
    ghostwhite      :"#f8f8ff",
    gold            :"#ffd700",
    goldenrod       :"#daa520",
    gray            :"#808080",
    grey            :"#808080",
    green           :"#008000",
    greenyellow     :"#adff2f",
    honeydew        :"#f0fff0",
    hotpink         :"#ff69b4",
    indianred       :"#cd5c5c",
    indigo          :"#4b0082",
    ivory           :"#fffff0",
    khaki           :"#f0e68c",
    lavender        :"#e6e6fa",
    lavenderblush   :"#fff0f5",
    lawngreen       :"#7cfc00",
    lemonchiffon    :"#fffacd",
    lightblue       :"#add8e6",
    lightcoral      :"#f08080",
    lightcyan       :"#e0ffff",
    lightgoldenrodyellow  :"#fafad2",
    lightgray       :"#d3d3d3",
    lightgrey       :"#d3d3d3",
    lightgreen      :"#90ee90",
    lightpink       :"#ffb6c1",
    lightsalmon     :"#ffa07a",
    lightseagreen   :"#20b2aa",
    lightskyblue    :"#87cefa",
    lightslategray  :"#778899",
    lightslategrey  :"#778899",
    lightsteelblue  :"#b0c4de",
    lightyellow     :"#ffffe0",
    lime            :"#00ff00",
    limegreen       :"#32cd32",
    linen           :"#faf0e6",
    magenta         :"#ff00ff",
    maroon          :"#800000",
    mediumaquamarine:"#66cdaa",
    mediumblue      :"#0000cd",
    mediumorchid    :"#ba55d3",
    mediumpurple    :"#9370d8",
    mediumseagreen  :"#3cb371",
    mediumslateblue :"#7b68ee",
    mediumspringgreen   :"#00fa9a",
    mediumturquoise :"#48d1cc",
    mediumvioletred :"#c71585",
    midnightblue    :"#191970",
    mintcream       :"#f5fffa",
    mistyrose       :"#ffe4e1",
    moccasin        :"#ffe4b5",
    navajowhite     :"#ffdead",
    navy            :"#000080",
    oldlace         :"#fdf5e6",
    olive           :"#808000",
    olivedrab       :"#6b8e23",
    orange          :"#ffa500",
    orangered       :"#ff4500",
    orchid          :"#da70d6",
    palegoldenrod   :"#eee8aa",
    palegreen       :"#98fb98",
    paleturquoise   :"#afeeee",
    palevioletred   :"#d87093",
    papayawhip      :"#ffefd5",
    peachpuff       :"#ffdab9",
    peru            :"#cd853f",
    pink            :"#ffc0cb",
    plum            :"#dda0dd",
    powderblue      :"#b0e0e6",
    purple          :"#800080",
    red             :"#ff0000",
    rosybrown       :"#bc8f8f",
    royalblue       :"#4169e1",
    saddlebrown     :"#8b4513",
    salmon          :"#fa8072",
    sandybrown      :"#f4a460",
    seagreen        :"#2e8b57",
    seashell        :"#fff5ee",
    sienna          :"#a0522d",
    silver          :"#c0c0c0",
    skyblue         :"#87ceeb",
    slateblue       :"#6a5acd",
    slategray       :"#708090",
    slategrey       :"#708090",
    snow            :"#fffafa",
    springgreen     :"#00ff7f",
    steelblue       :"#4682b4",
    tan             :"#d2b48c",
    teal            :"#008080",
    thistle         :"#d8bfd8",
    tomato          :"#ff6347",
    turquoise       :"#40e0d0",
    violet          :"#ee82ee",
    wheat           :"#f5deb3",
    white           :"#ffffff",
    whitesmoke      :"#f5f5f5",
    yellow          :"#ffff00",
    yellowgreen     :"#9acd32",
    activeBorder        :"Active window border.",
    activecaption       :"Active window caption.",
    appworkspace        :"Background color of multiple document interface.",
    background          :"Desktop background.",
    buttonface          :"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonhighlight     :"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonshadow        :"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttontext          :"Text on push buttons.",
    captiontext         :"Text in caption, size box, and scrollbar arrow box.",
    graytext            :"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.",
    greytext            :"Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.",
    highlight           :"Item(s) selected in a control.",
    highlighttext       :"Text of item(s) selected in a control.",
    inactiveborder      :"Inactive window border.",
    inactivecaption     :"Inactive window caption.",
    inactivecaptiontext :"Color of text in an inactive caption.",
    infobackground      :"Background color for tooltip controls.",
    infotext            :"Text color for tooltip controls.",
    menu                :"Menu background.",
    menutext            :"Text in menus.",
    scrollbar           :"Scroll bar gray area.",
    threeddarkshadow    :"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedface          :"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedhighlight     :"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedlightshadow   :"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedshadow        :"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    window              :"Window background.",
    windowframe         :"Window frame.",
    windowtext          :"Text in windows."
};
function Combinator(text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);
    this.type = "unknown";
    if (/^\s+$/.test(text)){
        this.type = "descendant";
    } else if (text == ">"){
        this.type = "child";
    } else if (text == "+"){
        this.type = "adjacent-sibling";
    } else if (text == "~"){
        this.type = "sibling";
    }

}

Combinator.prototype = new SyntaxUnit();
Combinator.prototype.constructor = Combinator;
function MediaFeature(name, value){

    SyntaxUnit.call(this, "(" + name + (value !== null ? ":" + value : "") + ")", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);
    this.name = name;
    this.value = value;
}

MediaFeature.prototype = new SyntaxUnit();
MediaFeature.prototype.constructor = MediaFeature;
function MediaQuery(modifier, mediaType, features, line, col){

    SyntaxUnit.call(this, (modifier ? modifier + " ": "") + (mediaType ? mediaType : "") + (mediaType && features.length > 0 ? " and " : "") + features.join(" and "), line, col, Parser.MEDIA_QUERY_TYPE);
    this.modifier = modifier;
    this.mediaType = mediaType;
    this.features = features;

}

MediaQuery.prototype = new SyntaxUnit();
MediaQuery.prototype.constructor = MediaQuery;
function Parser(options){
    EventTarget.call(this);


    this.options = options || {};

    this._tokenStream = null;
}
Parser.DEFAULT_TYPE = 0;
Parser.COMBINATOR_TYPE = 1;
Parser.MEDIA_FEATURE_TYPE = 2;
Parser.MEDIA_QUERY_TYPE = 3;
Parser.PROPERTY_NAME_TYPE = 4;
Parser.PROPERTY_VALUE_TYPE = 5;
Parser.PROPERTY_VALUE_PART_TYPE = 6;
Parser.SELECTOR_TYPE = 7;
Parser.SELECTOR_PART_TYPE = 8;
Parser.SELECTOR_SUB_PART_TYPE = 9;

Parser.prototype = function(){

    var proto = new EventTarget(),  //new prototype
        prop,
        additions =  {
            constructor: Parser,
            DEFAULT_TYPE : 0,
            COMBINATOR_TYPE : 1,
            MEDIA_FEATURE_TYPE : 2,
            MEDIA_QUERY_TYPE : 3,
            PROPERTY_NAME_TYPE : 4,
            PROPERTY_VALUE_TYPE : 5,
            PROPERTY_VALUE_PART_TYPE : 6,
            SELECTOR_TYPE : 7,
            SELECTOR_PART_TYPE : 8,
            SELECTOR_SUB_PART_TYPE : 9,
            _stylesheet: function(){

                var tokenStream = this._tokenStream,
                    charset     = null,
                    count,
                    token,
                    tt;

                this.fire("startstylesheet");
                this._charset();

                this._skipCruft();
                while (tokenStream.peek() == Tokens.IMPORT_SYM){
                    this._import();
                    this._skipCruft();
                }
                while (tokenStream.peek() == Tokens.NAMESPACE_SYM){
                    this._namespace();
                    this._skipCruft();
                }
                tt = tokenStream.peek();
                while(tt > Tokens.EOF){

                    try {

                        switch(tt){
                            case Tokens.MEDIA_SYM:
                                this._media();
                                this._skipCruft();
                                break;
                            case Tokens.PAGE_SYM:
                                this._page();
                                this._skipCruft();
                                break;
                            case Tokens.FONT_FACE_SYM:
                                this._font_face();
                                this._skipCruft();
                                break;
                            case Tokens.KEYFRAMES_SYM:
                                this._keyframes();
                                this._skipCruft();
                                break;
                            case Tokens.VIEWPORT_SYM:
                                this._viewport();
                                this._skipCruft();
                                break;
                            case Tokens.UNKNOWN_SYM:  //unknown @ rule
                                tokenStream.get();
                                if (!this.options.strict){
                                    this.fire({
                                        type:       "error",
                                        error:      null,
                                        message:    "Unknown @ rule: " + tokenStream.LT(0).value + ".",
                                        line:       tokenStream.LT(0).startLine,
                                        col:        tokenStream.LT(0).startCol
                                    });
                                    count=0;
                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) == Tokens.LBRACE){
                                        count++;    //keep track of nesting depth
                                    }

                                    while(count){
                                        tokenStream.advance([Tokens.RBRACE]);
                                        count--;
                                    }

                                } else {
                                    throw new SyntaxError("Unknown @ rule.", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                                }
                                break;
                            case Tokens.S:
                                this._readWhitespace();
                                break;
                            default:
                                if(!this._ruleset()){
                                    switch(tt){
                                        case Tokens.CHARSET_SYM:
                                            token = tokenStream.LT(1);
                                            this._charset(false);
                                            throw new SyntaxError("@charset not allowed here.", token.startLine, token.startCol);
                                        case Tokens.IMPORT_SYM:
                                            token = tokenStream.LT(1);
                                            this._import(false);
                                            throw new SyntaxError("@import not allowed here.", token.startLine, token.startCol);
                                        case Tokens.NAMESPACE_SYM:
                                            token = tokenStream.LT(1);
                                            this._namespace(false);
                                            throw new SyntaxError("@namespace not allowed here.", token.startLine, token.startCol);
                                        default:
                                            tokenStream.get();  //get the last token
                                            this._unexpectedToken(tokenStream.token());
                                    }

                                }
                        }
                    } catch(ex) {
                        if (ex instanceof SyntaxError && !this.options.strict){
                            this.fire({
                                type:       "error",
                                error:      ex,
                                message:    ex.message,
                                line:       ex.line,
                                col:        ex.col
                            });
                        } else {
                            throw ex;
                        }
                    }

                    tt = tokenStream.peek();
                }

                if (tt != Tokens.EOF){
                    this._unexpectedToken(tokenStream.token());
                }

                this.fire("endstylesheet");
            },

            _charset: function(emit){
                var tokenStream = this._tokenStream,
                    charset,
                    token,
                    line,
                    col;

                if (tokenStream.match(Tokens.CHARSET_SYM)){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.STRING);

                    token = tokenStream.token();
                    charset = token.value;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.SEMICOLON);

                    if (emit !== false){
                        this.fire({
                            type:   "charset",
                            charset:charset,
                            line:   line,
                            col:    col
                        });
                    }
                }
            },

            _import: function(emit){

                var tokenStream = this._tokenStream,
                    tt,
                    uri,
                    importToken,
                    mediaList   = [];
                tokenStream.mustMatch(Tokens.IMPORT_SYM);
                importToken = tokenStream.token();
                this._readWhitespace();

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                uri = tokenStream.token().value.replace(/^(?:url\()?["']?([^"']+?)["']?\)?$/, "$1");

                this._readWhitespace();

                mediaList = this._media_query_list();
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false){
                    this.fire({
                        type:   "import",
                        uri:    uri,
                        media:  mediaList,
                        line:   importToken.startLine,
                        col:    importToken.startCol
                    });
                }

            },

            _namespace: function(emit){

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    prefix,
                    uri;
                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();
                if (tokenStream.match(Tokens.IDENT)){
                    prefix = tokenStream.token().value;
                    this._readWhitespace();
                }

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                uri = tokenStream.token().value.replace(/(?:url\()?["']([^"']+)["']\)?/, "$1");

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false){
                    this.fire({
                        type:   "namespace",
                        prefix: prefix,
                        uri:    uri,
                        line:   line,
                        col:    col
                    });
                }

            },

            _media: function(){
                var tokenStream     = this._tokenStream,
                    line,
                    col,
                    mediaList;//       = [];
                tokenStream.mustMatch(Tokens.MEDIA_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                mediaList = this._media_query_list();

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type:   "startmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });

                while(true) {
                    if (tokenStream.peek() == Tokens.PAGE_SYM){
                        this._page();
                    } else if (tokenStream.peek() == Tokens.FONT_FACE_SYM){
                        this._font_face();
                    } else if (tokenStream.peek() == Tokens.VIEWPORT_SYM){
                        this._viewport();
                    } else if (!this._ruleset()){
                        break;
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

                this.fire({
                    type:   "endmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });
            },
            _media_query_list: function(){
                var tokenStream = this._tokenStream,
                    mediaList   = [];


                this._readWhitespace();

                if (tokenStream.peek() == Tokens.IDENT || tokenStream.peek() == Tokens.LPAREN){
                    mediaList.push(this._media_query());
                }

                while(tokenStream.match(Tokens.COMMA)){
                    this._readWhitespace();
                    mediaList.push(this._media_query());
                }

                return mediaList;
            },
            _media_query: function(){
                var tokenStream = this._tokenStream,
                    type        = null,
                    ident       = null,
                    token       = null,
                    expressions = [];

                if (tokenStream.match(Tokens.IDENT)){
                    ident = tokenStream.token().value.toLowerCase();
                    if (ident != "only" && ident != "not"){
                        tokenStream.unget();
                        ident = null;
                    } else {
                        token = tokenStream.token();
                    }
                }

                this._readWhitespace();

                if (tokenStream.peek() == Tokens.IDENT){
                    type = this._media_type();
                    if (token === null){
                        token = tokenStream.token();
                    }
                } else if (tokenStream.peek() == Tokens.LPAREN){
                    if (token === null){
                        token = tokenStream.LT(1);
                    }
                    expressions.push(this._media_expression());
                }

                if (type === null && expressions.length === 0){
                    return null;
                } else {
                    this._readWhitespace();
                    while (tokenStream.match(Tokens.IDENT)){
                        if (tokenStream.token().value.toLowerCase() != "and"){
                            this._unexpectedToken(tokenStream.token());
                        }

                        this._readWhitespace();
                        expressions.push(this._media_expression());
                    }
                }

                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
            },
            _media_type: function(){
                return this._media_feature();
            },
            _media_expression: function(){
                var tokenStream = this._tokenStream,
                    feature     = null,
                    token,
                    expression  = null;

                tokenStream.mustMatch(Tokens.LPAREN);

                feature = this._media_feature();
                this._readWhitespace();

                if (tokenStream.match(Tokens.COLON)){
                    this._readWhitespace();
                    token = tokenStream.LT(1);
                    expression = this._expression();
                }

                tokenStream.mustMatch(Tokens.RPAREN);
                this._readWhitespace();

                return new MediaFeature(feature, (expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null));
            },
            _media_feature: function(){
                var tokenStream = this._tokenStream;

                tokenStream.mustMatch(Tokens.IDENT);

                return SyntaxUnit.fromToken(tokenStream.token());
            },
            _page: function(){
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    identifier  = null,
                    pseudoPage  = null;
                tokenStream.mustMatch(Tokens.PAGE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                if (tokenStream.match(Tokens.IDENT)){
                    identifier = tokenStream.token().value;
                    if (identifier.toLowerCase() === "auto"){
                        this._unexpectedToken(tokenStream.token());
                    }
                }
                if (tokenStream.peek() == Tokens.COLON){
                    pseudoPage = this._pseudo_page();
                }

                this._readWhitespace();

                this.fire({
                    type:   "startpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true, true);

                this.fire({
                    type:   "endpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

            },
            _margin: function(){
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    marginSym   = this._margin_sym();

                if (marginSym){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this.fire({
                        type: "startpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type: "endpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });
                    return true;
                } else {
                    return false;
                }
            },
            _margin_sym: function(){

                var tokenStream = this._tokenStream;

                if(tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,
                        Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,
                        Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,
                        Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,
                        Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,
                        Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,
                        Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM]))
                {
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else {
                    return null;
                }

            },

            _pseudo_page: function(){

                var tokenStream = this._tokenStream;

                tokenStream.mustMatch(Tokens.COLON);
                tokenStream.mustMatch(Tokens.IDENT);
                return tokenStream.token().value;
            },

            _font_face: function(){
                var tokenStream = this._tokenStream,
                    line,
                    col;
                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                this.fire({
                    type:   "startfontface",
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endfontface",
                    line:   line,
                    col:    col
                });
            },

            _viewport: function(){
                 var tokenStream = this._tokenStream,
                    line,
                    col;

                    tokenStream.mustMatch(Tokens.VIEWPORT_SYM);
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();

                    this.fire({
                        type:   "startviewport",
                        line:   line,
                        col:    col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type:   "endviewport",
                        line:   line,
                        col:    col
                    });

            },

            _operator: function(inFunction){

                var tokenStream = this._tokenStream,
                    token       = null;

                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||
                    (inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))){
                    token =  tokenStream.token();
                    this._readWhitespace();
                }
                return token ? PropertyValuePart.fromToken(token) : null;

            },

            _combinator: function(){

                var tokenStream = this._tokenStream,
                    value       = null,
                    token;

                if(tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])){
                    token = tokenStream.token();
                    value = new Combinator(token.value, token.startLine, token.startCol);
                    this._readWhitespace();
                }

                return value;
            },

            _unary_operator: function(){

                var tokenStream = this._tokenStream;

                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])){
                    return tokenStream.token().value;
                } else {
                    return null;
                }
            },

            _property: function(){

                var tokenStream = this._tokenStream,
                    value       = null,
                    hack        = null,
                    tokenValue,
                    token,
                    line,
                    col;
                if (tokenStream.peek() == Tokens.STAR && this.options.starHack){
                    tokenStream.get();
                    token = tokenStream.token();
                    hack = token.value;
                    line = token.startLine;
                    col = token.startCol;
                }

                if(tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();
                    tokenValue = token.value;
                    if (tokenValue.charAt(0) == "_" && this.options.underscoreHack){
                        hack = "_";
                        tokenValue = tokenValue.substring(1);
                    }

                    value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));
                    this._readWhitespace();
                }

                return value;
            },
            _ruleset: function(){

                var tokenStream = this._tokenStream,
                    tt,
                    selectors;
                try {
                    selectors = this._selectors_group();
                } catch (ex){
                    if (ex instanceof SyntaxError && !this.options.strict){
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });
                        tt = tokenStream.advance([Tokens.RBRACE]);
                        if (tt == Tokens.RBRACE){
                        } else {
                            throw ex;
                        }

                    } else {
                        throw ex;
                    }
                    return true;
                }
                if (selectors){

                    this.fire({
                        type:       "startrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type:       "endrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                }

                return selectors;

            },
            _selectors_group: function(){
                var tokenStream = this._tokenStream,
                    selectors   = [],
                    selector;

                selector = this._selector();
                if (selector !== null){

                    selectors.push(selector);
                    while(tokenStream.match(Tokens.COMMA)){
                        this._readWhitespace();
                        selector = this._selector();
                        if (selector !== null){
                            selectors.push(selector);
                        } else {
                            this._unexpectedToken(tokenStream.LT(1));
                        }
                    }
                }

                return selectors.length ? selectors : null;
            },
            _selector: function(){

                var tokenStream = this._tokenStream,
                    selector    = [],
                    nextSelector = null,
                    combinator  = null,
                    ws          = null;
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null){
                    return null;
                }

                selector.push(nextSelector);

                do {
                    combinator = this._combinator();

                    if (combinator !== null){
                        selector.push(combinator);
                        nextSelector = this._simple_selector_sequence();
                        if (nextSelector === null){
                            this._unexpectedToken(tokenStream.LT(1));
                        } else {
                            selector.push(nextSelector);
                        }
                    } else {
                        if (this._readWhitespace()){
                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);
                            combinator = this._combinator();
                            nextSelector = this._simple_selector_sequence();
                            if (nextSelector === null){
                                if (combinator !== null){
                                    this._unexpectedToken(tokenStream.LT(1));
                                }
                            } else {

                                if (combinator !== null){
                                    selector.push(combinator);
                                } else {
                                    selector.push(ws);
                                }

                                selector.push(nextSelector);
                            }
                        } else {
                            break;
                        }

                    }
                } while(true);

                return new Selector(selector, selector[0].line, selector[0].col);
            },
            _simple_selector_sequence: function(){

                var tokenStream = this._tokenStream,
                    elementName = null,
                    modifiers   = [],
                    selectorText= "",
                    components  = [
                        function(){
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo,
                        this._negation
                    ],
                    i           = 0,
                    len         = components.length,
                    component   = null,
                    found       = false,
                    line,
                    col;
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                elementName = this._type_selector();
                if (!elementName){
                    elementName = this._universal();
                }

                if (elementName !== null){
                    selectorText += elementName;
                }

                while(true){
                    if (tokenStream.peek() === Tokens.S){
                        break;
                    }
                    while(i < len && component === null){
                        component = components[i++].call(this);
                    }

                    if (component === null){
                        if (selectorText === ""){
                            return null;
                        } else {
                            break;
                        }
                    } else {
                        i = 0;
                        modifiers.push(component);
                        selectorText += component.toString();
                        component = null;
                    }
                }


                return selectorText !== "" ?
                        new SelectorPart(elementName, modifiers, selectorText, line, col) :
                        null;
            },
            _type_selector: function(){

                var tokenStream = this._tokenStream,
                    ns          = this._namespace_prefix(),
                    elementName = this._element_name();

                if (!elementName){
                    if (ns){
                        tokenStream.unget();
                        if (ns.length > 1){
                            tokenStream.unget();
                        }
                    }

                    return null;
                } else {
                    if (ns){
                        elementName.text = ns + elementName.text;
                        elementName.col -= ns.length;
                    }
                    return elementName;
                }
            },
            _class: function(){

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.DOT)){
                    tokenStream.mustMatch(Tokens.IDENT);
                    token = tokenStream.token();
                    return new SelectorSubPart("." + token.value, "class", token.startLine, token.startCol - 1);
                } else {
                    return null;
                }

            },
            _element_name: function(){

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();
                    return new SelectorSubPart(token.value, "elementName", token.startLine, token.startCol);

                } else {
                    return null;
                }
            },
            _namespace_prefix: function(){
                var tokenStream = this._tokenStream,
                    value       = "";
                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE){

                    if(tokenStream.match([Tokens.IDENT, Tokens.STAR])){
                        value += tokenStream.token().value;
                    }

                    tokenStream.mustMatch(Tokens.PIPE);
                    value += "|";

                }

                return value.length ? value : null;
            },
            _universal: function(){
                var tokenStream = this._tokenStream,
                    value       = "",
                    ns;

                ns = this._namespace_prefix();
                if(ns){
                    value += ns;
                }

                if(tokenStream.match(Tokens.STAR)){
                    value += "*";
                }

                return value.length ? value : null;

           },
            _attrib: function(){

                var tokenStream = this._tokenStream,
                    value       = null,
                    ns,
                    token;

                if (tokenStream.match(Tokens.LBRACKET)){
                    token = tokenStream.token();
                    value = token.value;
                    value += this._readWhitespace();

                    ns = this._namespace_prefix();

                    if (ns){
                        value += ns;
                    }

                    tokenStream.mustMatch(Tokens.IDENT);
                    value += tokenStream.token().value;
                    value += this._readWhitespace();

                    if(tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,
                            Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])){

                        value += tokenStream.token().value;
                        value += this._readWhitespace();

                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                        value += tokenStream.token().value;
                        value += this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACKET);

                    return new SelectorSubPart(value + "]", "attribute", token.startLine, token.startCol);
                } else {
                    return null;
                }
            },
            _pseudo: function(){

                var tokenStream = this._tokenStream,
                    pseudo      = null,
                    colons      = ":",
                    line,
                    col;

                if (tokenStream.match(Tokens.COLON)){

                    if (tokenStream.match(Tokens.COLON)){
                        colons += ":";
                    }

                    if (tokenStream.match(Tokens.IDENT)){
                        pseudo = tokenStream.token().value;
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol - colons.length;
                    } else if (tokenStream.peek() == Tokens.FUNCTION){
                        line = tokenStream.LT(1).startLine;
                        col = tokenStream.LT(1).startCol - colons.length;
                        pseudo = this._functional_pseudo();
                    }

                    if (pseudo){
                        pseudo = new SelectorSubPart(colons + pseudo, "pseudo", line, col);
                    }
                }

                return pseudo;
            },
            _functional_pseudo: function(){

                var tokenStream = this._tokenStream,
                    value = null;

                if(tokenStream.match(Tokens.FUNCTION)){
                    value = tokenStream.token().value;
                    value += this._readWhitespace();
                    value += this._expression();
                    tokenStream.mustMatch(Tokens.RPAREN);
                    value += ")";
                }

                return value;
            },
            _expression: function(){

                var tokenStream = this._tokenStream,
                    value       = "";

                while(tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,
                        Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,
                        Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,
                        Tokens.RESOLUTION, Tokens.SLASH])){

                    value += tokenStream.token().value;
                    value += this._readWhitespace();
                }

                return value.length ? value : null;

            },
            _negation: function(){

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    value       = "",
                    arg,
                    subpart     = null;

                if (tokenStream.match(Tokens.NOT)){
                    value = tokenStream.token().value;
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                    value += this._readWhitespace();
                    arg = this._negation_arg();
                    value += arg;
                    value += this._readWhitespace();
                    tokenStream.match(Tokens.RPAREN);
                    value += tokenStream.token().value;

                    subpart = new SelectorSubPart(value, "not", line, col);
                    subpart.args.push(arg);
                }

                return subpart;
            },
            _negation_arg: function(){

                var tokenStream = this._tokenStream,
                    args        = [
                        this._type_selector,
                        this._universal,
                        function(){
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo
                    ],
                    arg         = null,
                    i           = 0,
                    len         = args.length,
                    elementName,
                    line,
                    col,
                    part;

                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                while(i < len && arg === null){

                    arg = args[i].call(this);
                    i++;
                }
                if (arg === null){
                    this._unexpectedToken(tokenStream.LT(1));
                }
                if (arg.type == "elementName"){
                    part = new SelectorPart(arg, [], arg.toString(), line, col);
                } else {
                    part = new SelectorPart(null, [arg], arg.toString(), line, col);
                }

                return part;
            },

            _declaration: function(){

                var tokenStream = this._tokenStream,
                    property    = null,
                    expr        = null,
                    prio        = null,
                    error       = null,
                    invalid     = null,
                    propertyName= "";

                property = this._property();
                if (property !== null){

                    tokenStream.mustMatch(Tokens.COLON);
                    this._readWhitespace();

                    expr = this._expr();
                    if (!expr || expr.length === 0){
                        this._unexpectedToken(tokenStream.LT(1));
                    }

                    prio = this._prio();
                    propertyName = property.toString();
                    if (this.options.starHack && property.hack == "*" ||
                            this.options.underscoreHack && property.hack == "_") {

                        propertyName = property.text;
                    }

                    try {
                        this._validateProperty(propertyName, expr);
                    } catch (ex) {
                        invalid = ex;
                    }

                    this.fire({
                        type:       "property",
                        property:   property,
                        value:      expr,
                        important:  prio,
                        line:       property.line,
                        col:        property.col,
                        invalid:    invalid
                    });

                    return true;
                } else {
                    return false;
                }
            },

            _prio: function(){

                var tokenStream = this._tokenStream,
                    result      = tokenStream.match(Tokens.IMPORTANT_SYM);

                this._readWhitespace();
                return result;
            },

            _expr: function(inFunction){

                var tokenStream = this._tokenStream,
                    values      = [],
                    value       = null,
                    operator    = null;

                value = this._term(inFunction);
                if (value !== null){

                    values.push(value);

                    do {
                        operator = this._operator(inFunction);
                        if (operator){
                            values.push(operator);
                        } /*else {
                            values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                            valueParts = [];
                        }*/

                        value = this._term(inFunction);

                        if (value === null){
                            break;
                        } else {
                            values.push(value);
                        }
                    } while(true);
                }

                return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
            },

            _term: function(inFunction){

                var tokenStream = this._tokenStream,
                    unary       = null,
                    value       = null,
                    endChar     = null,
                    token,
                    line,
                    col;
                unary = this._unary_operator();
                if (unary !== null){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                }
                if (tokenStream.peek() == Tokens.IE_FUNCTION && this.options.ieFilters){

                    value = this._ie_function();
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])){

                    token = tokenStream.token();
                    endChar = token.endChar;
                    value = token.value + this._expr(inFunction).text;
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    tokenStream.mustMatch(Tokens.type(endChar));
                    value += endChar;
                    this._readWhitespace();
                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,
                        Tokens.ANGLE, Tokens.TIME,
                        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])){

                    value = tokenStream.token().value;
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    this._readWhitespace();
                } else {
                    token = this._hexcolor();
                    if (token === null){
                        if (unary === null){
                            line = tokenStream.LT(1).startLine;
                            col = tokenStream.LT(1).startCol;
                        }
                        if (value === null){
                            if (tokenStream.LA(3) == Tokens.EQUALS && this.options.ieFilters){
                                value = this._ie_function();
                            } else {
                                value = this._function();
                            }
                        }

                    } else {
                        value = token.value;
                        if (unary === null){
                            line = token.startLine;
                            col = token.startCol;
                        }
                    }

                }

                return value !== null ?
                        new PropertyValuePart(unary !== null ? unary + value : value, line, col) :
                        null;

            },

            _function: function(){

                var tokenStream = this._tokenStream,
                    functionText = null,
                    expr        = null,
                    lt;

                if (tokenStream.match(Tokens.FUNCTION)){
                    functionText = tokenStream.token().value;
                    this._readWhitespace();
                    expr = this._expr(true);
                    functionText += expr;
                    if (this.options.ieFilters && tokenStream.peek() == Tokens.EQUALS){
                        do {

                            if (this._readWhitespace()){
                                functionText += tokenStream.token().value;
                            }
                            if (tokenStream.LA(0) == Tokens.COMMA){
                                functionText += tokenStream.token().value;
                            }

                            tokenStream.match(Tokens.IDENT);
                            functionText += tokenStream.token().value;

                            tokenStream.match(Tokens.EQUALS);
                            functionText += tokenStream.token().value;
                            lt = tokenStream.peek();
                            while(lt != Tokens.COMMA && lt != Tokens.S && lt != Tokens.RPAREN){
                                tokenStream.get();
                                functionText += tokenStream.token().value;
                                lt = tokenStream.peek();
                            }
                        } while(tokenStream.match([Tokens.COMMA, Tokens.S]));
                    }
                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _ie_function: function(){

                var tokenStream = this._tokenStream,
                    functionText = null,
                    expr        = null,
                    lt;
                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])){
                    functionText = tokenStream.token().value;

                    do {

                        if (this._readWhitespace()){
                            functionText += tokenStream.token().value;
                        }
                        if (tokenStream.LA(0) == Tokens.COMMA){
                            functionText += tokenStream.token().value;
                        }

                        tokenStream.match(Tokens.IDENT);
                        functionText += tokenStream.token().value;

                        tokenStream.match(Tokens.EQUALS);
                        functionText += tokenStream.token().value;
                        lt = tokenStream.peek();
                        while(lt != Tokens.COMMA && lt != Tokens.S && lt != Tokens.RPAREN){
                            tokenStream.get();
                            functionText += tokenStream.token().value;
                            lt = tokenStream.peek();
                        }
                    } while(tokenStream.match([Tokens.COMMA, Tokens.S]));

                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _hexcolor: function(){

                var tokenStream = this._tokenStream,
                    token = null,
                    color;

                if(tokenStream.match(Tokens.HASH)){
                    token = tokenStream.token();
                    color = token.value;
                    if (!/#[a-f0-9]{3,6}/i.test(color)){
                        throw new SyntaxError("Expected a hex color but found '" + color + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
                    }
                    this._readWhitespace();
                }

                return token;
            },
            _keyframes: function(){
                var tokenStream = this._tokenStream,
                    token,
                    tt,
                    name,
                    prefix = "";

                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                name = this._keyframe_name();

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.LBRACE);

                this.fire({
                    type:   "startkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tt = tokenStream.peek();
                while(tt == Tokens.IDENT || tt == Tokens.PERCENTAGE) {
                    this._keyframe_rule();
                    this._readWhitespace();
                    tt = tokenStream.peek();
                }

                this.fire({
                    type:   "endkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.RBRACE);

            },

            _keyframe_name: function(){
                var tokenStream = this._tokenStream,
                    token;

                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                return SyntaxUnit.fromToken(tokenStream.token());
            },

            _keyframe_rule: function(){
                var tokenStream = this._tokenStream,
                    token,
                    keyList = this._key_list();

                this.fire({
                    type:   "startkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

            },

            _key_list: function(){
                var tokenStream = this._tokenStream,
                    token,
                    key,
                    keyList = [];
                keyList.push(this._key());

                this._readWhitespace();

                while(tokenStream.match(Tokens.COMMA)){
                    this._readWhitespace();
                    keyList.push(this._key());
                    this._readWhitespace();
                }

                return keyList;
            },

            _key: function(){

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.PERCENTAGE)){
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else if (tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();

                    if (/from|to/i.test(token.value)){
                        return SyntaxUnit.fromToken(token);
                    }

                    tokenStream.unget();
                }
                this._unexpectedToken(tokenStream.LT(1));
            },
            _skipCruft: function(){
                while(this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])){
                }
            },
            _readDeclarations: function(checkStart, readMargins){
                var tokenStream = this._tokenStream,
                    tt;


                this._readWhitespace();

                if (checkStart){
                    tokenStream.mustMatch(Tokens.LBRACE);
                }

                this._readWhitespace();

                try {

                    while(true){

                        if (tokenStream.match(Tokens.SEMICOLON) || (readMargins && this._margin())){
                        } else if (this._declaration()){
                            if (!tokenStream.match(Tokens.SEMICOLON)){
                                break;
                            }
                        } else {
                            break;
                        }
                        this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACE);
                    this._readWhitespace();

                } catch (ex) {
                    if (ex instanceof SyntaxError && !this.options.strict){
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });
                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
                        if (tt == Tokens.SEMICOLON){
                            this._readDeclarations(false, readMargins);
                        } else if (tt != Tokens.RBRACE){
                            throw ex;
                        }

                    } else {
                        throw ex;
                    }
                }

            },
            _readWhitespace: function(){

                var tokenStream = this._tokenStream,
                    ws = "";

                while(tokenStream.match(Tokens.S)){
                    ws += tokenStream.token().value;
                }

                return ws;
            },
            _unexpectedToken: function(token){
                throw new SyntaxError("Unexpected token '" + token.value + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
            },
            _verifyEnd: function(){
                if (this._tokenStream.LA(1) != Tokens.EOF){
                    this._unexpectedToken(this._tokenStream.LT(1));
                }
            },
            _validateProperty: function(property, value){
                Validation.validate(property, value);
            },
            parse: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                this._stylesheet();
            },

            parseStyleSheet: function(input){
                return this.parse(input);
            },

            parseMediaQuery: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                var result = this._media_query();
                this._verifyEnd();
                return result;
            },
            parsePropertyValue: function(input){

                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._expr();
                this._readWhitespace();
                this._verifyEnd();
                return result;
            },
            parseRule: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._ruleset();
                this._readWhitespace();
                this._verifyEnd();
                return result;
            },
            parseSelector: function(input){

                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._selector();
                this._readWhitespace();
                this._verifyEnd();
                return result;
            },
            parseStyleAttribute: function(input){
                input += "}"; // for error recovery in _readDeclarations()
                this._tokenStream = new TokenStream(input, Tokens);
                this._readDeclarations();
            }
        };
    for (prop in additions){
        if (additions.hasOwnProperty(prop)){
            proto[prop] = additions[prop];
        }
    }

    return proto;
}();
var Properties = {
    "align-items"                   : "flex-start | flex-end | center | baseline | stretch",
    "align-content"                 : "flex-start | flex-end | center | space-between | space-around | stretch",
    "align-self"                    : "auto | flex-start | flex-end | center | baseline | stretch",
    "-webkit-align-items"           : "flex-start | flex-end | center | baseline | stretch",
    "-webkit-align-content"         : "flex-start | flex-end | center | space-between | space-around | stretch",
    "-webkit-align-self"            : "auto | flex-start | flex-end | center | baseline | stretch",
    "alignment-adjust"              : "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>",
    "alignment-baseline"            : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "animation"                     : 1,
    "animation-delay"               : { multi: "<time>", comma: true },
    "animation-direction"           : { multi: "normal | reverse | alternate | alternate-reverse", comma: true },
    "animation-duration"            : { multi: "<time>", comma: true },
    "animation-fill-mode"           : { multi: "none | forwards | backwards | both", comma: true },
    "animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "animation-name"                : { multi: "none | <ident>", comma: true },
    "animation-play-state"          : { multi: "running | paused", comma: true },
    "animation-timing-function"     : 1,
    "-moz-animation-delay"               : { multi: "<time>", comma: true },
    "-moz-animation-direction"           : { multi: "normal | reverse | alternate | alternate-reverse", comma: true },
    "-moz-animation-duration"            : { multi: "<time>", comma: true },
    "-moz-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-moz-animation-name"                : { multi: "none | <ident>", comma: true },
    "-moz-animation-play-state"          : { multi: "running | paused", comma: true },

    "-ms-animation-delay"               : { multi: "<time>", comma: true },
    "-ms-animation-direction"           : { multi: "normal | reverse | alternate | alternate-reverse", comma: true },
    "-ms-animation-duration"            : { multi: "<time>", comma: true },
    "-ms-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-ms-animation-name"                : { multi: "none | <ident>", comma: true },
    "-ms-animation-play-state"          : { multi: "running | paused", comma: true },

    "-webkit-animation-delay"               : { multi: "<time>", comma: true },
    "-webkit-animation-direction"           : { multi: "normal | reverse | alternate | alternate-reverse", comma: true },
    "-webkit-animation-duration"            : { multi: "<time>", comma: true },
    "-webkit-animation-fill-mode"           : { multi: "none | forwards | backwards | both", comma: true },
    "-webkit-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-webkit-animation-name"                : { multi: "none | <ident>", comma: true },
    "-webkit-animation-play-state"          : { multi: "running | paused", comma: true },

    "-o-animation-delay"               : { multi: "<time>", comma: true },
    "-o-animation-direction"           : { multi: "normal | reverse | alternate | alternate-reverse", comma: true },
    "-o-animation-duration"            : { multi: "<time>", comma: true },
    "-o-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-o-animation-name"                : { multi: "none | <ident>", comma: true },
    "-o-animation-play-state"          : { multi: "running | paused", comma: true },

    "appearance"                    : "icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit",
    "azimuth"                       : function (expression) {
        var simple      = "<angle> | leftwards | rightwards | inherit",
            direction   = "left-side | far-left | left | center-left | center | center-right | right | far-right | right-side",
            behind      = false,
            valid       = false,
            part;

        if (!ValidationTypes.isAny(expression, simple)) {
            if (ValidationTypes.isAny(expression, "behind")) {
                behind = true;
                valid = true;
            }

            if (ValidationTypes.isAny(expression, direction)) {
                valid = true;
                if (!behind) {
                    ValidationTypes.isAny(expression, "behind");
                }
            }
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (<'azimuth'>) but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "backface-visibility"           : "visible | hidden",
    "background"                    : 1,
    "background-attachment"         : { multi: "<attachment>", comma: true },
    "background-clip"               : { multi: "<box>", comma: true },
    "background-color"              : "<color> | inherit",
    "background-image"              : { multi: "<bg-image>", comma: true },
    "background-origin"             : { multi: "<box>", comma: true },
    "background-position"           : { multi: "<bg-position>", comma: true },
    "background-repeat"             : { multi: "<repeat-style>" },
    "background-size"               : { multi: "<bg-size>", comma: true },
    "baseline-shift"                : "baseline | sub | super | <percentage> | <length>",
    "behavior"                      : 1,
    "binding"                       : 1,
    "bleed"                         : "<length>",
    "bookmark-label"                : "<content> | <attr> | <string>",
    "bookmark-level"                : "none | <integer>",
    "bookmark-state"                : "open | closed",
    "bookmark-target"               : "none | <uri> | <attr>",
    "border"                        : "<border-width> || <border-style> || <color>",
    "border-bottom"                 : "<border-width> || <border-style> || <color>",
    "border-bottom-color"           : "<color> | inherit",
    "border-bottom-left-radius"     :  "<x-one-radius>",
    "border-bottom-right-radius"    :  "<x-one-radius>",
    "border-bottom-style"           : "<border-style>",
    "border-bottom-width"           : "<border-width>",
    "border-collapse"               : "collapse | separate | inherit",
    "border-color"                  : { multi: "<color> | inherit", max: 4 },
    "border-image"                  : 1,
    "border-image-outset"           : { multi: "<length> | <number>", max: 4 },
    "border-image-repeat"           : { multi: "stretch | repeat | round", max: 2 },
    "border-image-slice"            : function(expression) {

        var valid   = false,
            numeric = "<number> | <percentage>",
            fill    = false,
            count   = 0,
            max     = 4,
            part;

        if (ValidationTypes.isAny(expression, "fill")) {
            fill = true;
            valid = true;
        }

        while (expression.hasNext() && count < max) {
            valid = ValidationTypes.isAny(expression, numeric);
            if (!valid) {
                break;
            }
            count++;
        }


        if (!fill) {
            ValidationTypes.isAny(expression, "fill");
        } else {
            valid = true;
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected ([<number> | <percentage>]{1,4} && fill?) but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "border-image-source"           : "<image> | none",
    "border-image-width"            : { multi: "<length> | <percentage> | <number> | auto", max: 4 },
    "border-left"                   : "<border-width> || <border-style> || <color>",
    "border-left-color"             : "<color> | inherit",
    "border-left-style"             : "<border-style>",
    "border-left-width"             : "<border-width>",
    "border-radius"                 : function(expression) {

        var valid   = false,
            simple = "<length> | <percentage> | inherit",
            slash   = false,
            fill    = false,
            count   = 0,
            max     = 8,
            part;

        while (expression.hasNext() && count < max) {
            valid = ValidationTypes.isAny(expression, simple);
            if (!valid) {

                if (expression.peek() == "/" && count > 0 && !slash) {
                    slash = true;
                    max = count + 5;
                    expression.next();
                } else {
                    break;
                }
            }
            count++;
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (<'border-radius'>) but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "border-right"                  : "<border-width> || <border-style> || <color>",
    "border-right-color"            : "<color> | inherit",
    "border-right-style"            : "<border-style>",
    "border-right-width"            : "<border-width>",
    "border-spacing"                : { multi: "<length> | inherit", max: 2 },
    "border-style"                  : { multi: "<border-style>", max: 4 },
    "border-top"                    : "<border-width> || <border-style> || <color>",
    "border-top-color"              : "<color> | inherit",
    "border-top-left-radius"        : "<x-one-radius>",
    "border-top-right-radius"       : "<x-one-radius>",
    "border-top-style"              : "<border-style>",
    "border-top-width"              : "<border-width>",
    "border-width"                  : { multi: "<border-width>", max: 4 },
    "bottom"                        : "<margin-width> | inherit",
    "-moz-box-align"                : "start | end | center | baseline | stretch",
    "-moz-box-decoration-break"     : "slice |clone",
    "-moz-box-direction"            : "normal | reverse | inherit",
    "-moz-box-flex"                 : "<number>",
    "-moz-box-flex-group"           : "<integer>",
    "-moz-box-lines"                : "single | multiple",
    "-moz-box-ordinal-group"        : "<integer>",
    "-moz-box-orient"               : "horizontal | vertical | inline-axis | block-axis | inherit",
    "-moz-box-pack"                 : "start | end | center | justify",
    "-webkit-box-align"             : "start | end | center | baseline | stretch",
    "-webkit-box-decoration-break"  : "slice |clone",
    "-webkit-box-direction"         : "normal | reverse | inherit",
    "-webkit-box-flex"              : "<number>",
    "-webkit-box-flex-group"        : "<integer>",
    "-webkit-box-lines"             : "single | multiple",
    "-webkit-box-ordinal-group"     : "<integer>",
    "-webkit-box-orient"            : "horizontal | vertical | inline-axis | block-axis | inherit",
    "-webkit-box-pack"              : "start | end | center | justify",
    "box-shadow"                    : function (expression) {
        var result      = false,
            part;

        if (!ValidationTypes.isAny(expression, "none")) {
            Validation.multiProperty("<shadow>", expression, true, Infinity);
        } else {
            if (expression.hasNext()) {
                part = expression.next();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "box-sizing"                    : "content-box | border-box | inherit",
    "break-after"                   : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-before"                  : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-inside"                  : "auto | avoid | avoid-page | avoid-column",
    "caption-side"                  : "top | bottom | inherit",
    "clear"                         : "none | right | left | both | inherit",
    "clip"                          : 1,
    "color"                         : "<color> | inherit",
    "color-profile"                 : 1,
    "column-count"                  : "<integer> | auto",                      //http://www.w3.org/TR/css3-multicol/
    "column-fill"                   : "auto | balance",
    "column-gap"                    : "<length> | normal",
    "column-rule"                   : "<border-width> || <border-style> || <color>",
    "column-rule-color"             : "<color>",
    "column-rule-style"             : "<border-style>",
    "column-rule-width"             : "<border-width>",
    "column-span"                   : "none | all",
    "column-width"                  : "<length> | auto",
    "columns"                       : 1,
    "content"                       : 1,
    "counter-increment"             : 1,
    "counter-reset"                 : 1,
    "crop"                          : "<shape> | auto",
    "cue"                           : "cue-after | cue-before | inherit",
    "cue-after"                     : 1,
    "cue-before"                    : 1,
    "cursor"                        : 1,
    "direction"                     : "ltr | rtl | inherit",
    "display"                       : "inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex",
    "dominant-baseline"             : 1,
    "drop-initial-after-adjust"     : "central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>",
    "drop-initial-after-align"      : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-before-adjust"    : "before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>",
    "drop-initial-before-align"     : "caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-size"             : "auto | line | <length> | <percentage>",
    "drop-initial-value"            : "initial | <integer>",
    "elevation"                     : "<angle> | below | level | above | higher | lower | inherit",
    "empty-cells"                   : "show | hide | inherit",
    "filter"                        : 1,
    "fit"                           : "fill | hidden | meet | slice",
    "fit-position"                  : 1,
    "flex"                          : "<flex>",
    "flex-basis"                    : "<width>",
    "flex-direction"                : "row | row-reverse | column | column-reverse",
    "flex-flow"                     : "<flex-direction> || <flex-wrap>",
    "flex-grow"                     : "<number>",
    "flex-shrink"                   : "<number>",
    "flex-wrap"                     : "nowrap | wrap | wrap-reverse",
    "-webkit-flex"                  : "<flex>",
    "-webkit-flex-basis"            : "<width>",
    "-webkit-flex-direction"        : "row | row-reverse | column | column-reverse",
    "-webkit-flex-flow"             : "<flex-direction> || <flex-wrap>",
    "-webkit-flex-grow"             : "<number>",
    "-webkit-flex-shrink"           : "<number>",
    "-webkit-flex-wrap"             : "nowrap | wrap | wrap-reverse",
    "-ms-flex"                      : "<flex>",
    "-ms-flex-align"                : "start | end | center | stretch | baseline",
    "-ms-flex-direction"            : "row | row-reverse | column | column-reverse | inherit",
    "-ms-flex-order"                : "<number>",
    "-ms-flex-pack"                 : "start | end | center | justify",
    "-ms-flex-wrap"                 : "nowrap | wrap | wrap-reverse",
    "float"                         : "left | right | none | inherit",
    "float-offset"                  : 1,
    "font"                          : 1,
    "font-family"                   : 1,
    "font-size"                     : "<absolute-size> | <relative-size> | <length> | <percentage> | inherit",
    "font-size-adjust"              : "<number> | none | inherit",
    "font-stretch"                  : "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit",
    "font-style"                    : "normal | italic | oblique | inherit",
    "font-variant"                  : "normal | small-caps | inherit",
    "font-weight"                   : "normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit",
    "grid-cell-stacking"            : "columns | rows | layer",
    "grid-column"                   : 1,
    "grid-columns"                  : 1,
    "grid-column-align"             : "start | end | center | stretch",
    "grid-column-sizing"            : 1,
    "grid-column-span"              : "<integer>",
    "grid-flow"                     : "none | rows | columns",
    "grid-layer"                    : "<integer>",
    "grid-row"                      : 1,
    "grid-rows"                     : 1,
    "grid-row-align"                : "start | end | center | stretch",
    "grid-row-span"                 : "<integer>",
    "grid-row-sizing"               : 1,
    "hanging-punctuation"           : 1,
    "height"                        : "<margin-width> | <content-sizing> | inherit",
    "hyphenate-after"               : "<integer> | auto",
    "hyphenate-before"              : "<integer> | auto",
    "hyphenate-character"           : "<string> | auto",
    "hyphenate-lines"               : "no-limit | <integer>",
    "hyphenate-resource"            : 1,
    "hyphens"                       : "none | manual | auto",
    "icon"                          : 1,
    "image-orientation"             : "angle | auto",
    "image-rendering"               : 1,
    "image-resolution"              : 1,
    "inline-box-align"              : "initial | last | <integer>",
    "justify-content"               : "flex-start | flex-end | center | space-between | space-around",
    "-webkit-justify-content"       : "flex-start | flex-end | center | space-between | space-around",
    "left"                          : "<margin-width> | inherit",
    "letter-spacing"                : "<length> | normal | inherit",
    "line-height"                   : "<number> | <length> | <percentage> | normal | inherit",
    "line-break"                    : "auto | loose | normal | strict",
    "line-stacking"                 : 1,
    "line-stacking-ruby"            : "exclude-ruby | include-ruby",
    "line-stacking-shift"           : "consider-shifts | disregard-shifts",
    "line-stacking-strategy"        : "inline-line-height | block-line-height | max-height | grid-height",
    "list-style"                    : 1,
    "list-style-image"              : "<uri> | none | inherit",
    "list-style-position"           : "inside | outside | inherit",
    "list-style-type"               : "disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit",
    "margin"                        : { multi: "<margin-width> | inherit", max: 4 },
    "margin-bottom"                 : "<margin-width> | inherit",
    "margin-left"                   : "<margin-width> | inherit",
    "margin-right"                  : "<margin-width> | inherit",
    "margin-top"                    : "<margin-width> | inherit",
    "mark"                          : 1,
    "mark-after"                    : 1,
    "mark-before"                   : 1,
    "marks"                         : 1,
    "marquee-direction"             : 1,
    "marquee-play-count"            : 1,
    "marquee-speed"                 : 1,
    "marquee-style"                 : 1,
    "max-height"                    : "<length> | <percentage> | <content-sizing> | none | inherit",
    "max-width"                     : "<length> | <percentage> | <content-sizing> | none | inherit",
    "min-height"                    : "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
    "min-width"                     : "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
    "move-to"                       : 1,
    "nav-down"                      : 1,
    "nav-index"                     : 1,
    "nav-left"                      : 1,
    "nav-right"                     : 1,
    "nav-up"                        : 1,
    "opacity"                       : "<number> | inherit",
    "order"                         : "<integer>",
    "-webkit-order"                 : "<integer>",
    "orphans"                       : "<integer> | inherit",
    "outline"                       : 1,
    "outline-color"                 : "<color> | invert | inherit",
    "outline-offset"                : 1,
    "outline-style"                 : "<border-style> | inherit",
    "outline-width"                 : "<border-width> | inherit",
    "overflow"                      : "visible | hidden | scroll | auto | inherit",
    "overflow-style"                : 1,
    "overflow-wrap"                 : "normal | break-word",
    "overflow-x"                    : 1,
    "overflow-y"                    : 1,
    "padding"                       : { multi: "<padding-width> | inherit", max: 4 },
    "padding-bottom"                : "<padding-width> | inherit",
    "padding-left"                  : "<padding-width> | inherit",
    "padding-right"                 : "<padding-width> | inherit",
    "padding-top"                   : "<padding-width> | inherit",
    "page"                          : 1,
    "page-break-after"              : "auto | always | avoid | left | right | inherit",
    "page-break-before"             : "auto | always | avoid | left | right | inherit",
    "page-break-inside"             : "auto | avoid | inherit",
    "page-policy"                   : 1,
    "pause"                         : 1,
    "pause-after"                   : 1,
    "pause-before"                  : 1,
    "perspective"                   : 1,
    "perspective-origin"            : 1,
    "phonemes"                      : 1,
    "pitch"                         : 1,
    "pitch-range"                   : 1,
    "play-during"                   : 1,
    "pointer-events"                : "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
    "position"                      : "static | relative | absolute | fixed | inherit",
    "presentation-level"            : 1,
    "punctuation-trim"              : 1,
    "quotes"                        : 1,
    "rendering-intent"              : 1,
    "resize"                        : 1,
    "rest"                          : 1,
    "rest-after"                    : 1,
    "rest-before"                   : 1,
    "richness"                      : 1,
    "right"                         : "<margin-width> | inherit",
    "rotation"                      : 1,
    "rotation-point"                : 1,
    "ruby-align"                    : 1,
    "ruby-overhang"                 : 1,
    "ruby-position"                 : 1,
    "ruby-span"                     : 1,
    "size"                          : 1,
    "speak"                         : "normal | none | spell-out | inherit",
    "speak-header"                  : "once | always | inherit",
    "speak-numeral"                 : "digits | continuous | inherit",
    "speak-punctuation"             : "code | none | inherit",
    "speech-rate"                   : 1,
    "src"                           : 1,
    "stress"                        : 1,
    "string-set"                    : 1,

    "table-layout"                  : "auto | fixed | inherit",
    "tab-size"                      : "<integer> | <length>",
    "target"                        : 1,
    "target-name"                   : 1,
    "target-new"                    : 1,
    "target-position"               : 1,
    "text-align"                    : "left | right | center | justify | inherit" ,
    "text-align-last"               : 1,
    "text-decoration"               : 1,
    "text-emphasis"                 : 1,
    "text-height"                   : 1,
    "text-indent"                   : "<length> | <percentage> | inherit",
    "text-justify"                  : "auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida",
    "text-outline"                  : 1,
    "text-overflow"                 : 1,
    "text-rendering"                : "auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit",
    "text-shadow"                   : 1,
    "text-transform"                : "capitalize | uppercase | lowercase | none | inherit",
    "text-wrap"                     : "normal | none | avoid",
    "top"                           : "<margin-width> | inherit",
    "-ms-touch-action"              : "auto | none | pan-x | pan-y",
    "touch-action"                  : "auto | none | pan-x | pan-y",
    "transform"                     : 1,
    "transform-origin"              : 1,
    "transform-style"               : 1,
    "transition"                    : 1,
    "transition-delay"              : 1,
    "transition-duration"           : 1,
    "transition-property"           : 1,
    "transition-timing-function"    : 1,
    "unicode-bidi"                  : "normal | embed | isolate | bidi-override | isolate-override | plaintext | inherit",
    "user-modify"                   : "read-only | read-write | write-only | inherit",
    "user-select"                   : "none | text | toggle | element | elements | all | inherit",
    "vertical-align"                : "auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length>",
    "visibility"                    : "visible | hidden | collapse | inherit",
    "voice-balance"                 : 1,
    "voice-duration"                : 1,
    "voice-family"                  : 1,
    "voice-pitch"                   : 1,
    "voice-pitch-range"             : 1,
    "voice-rate"                    : 1,
    "voice-stress"                  : 1,
    "voice-volume"                  : 1,
    "volume"                        : 1,
    "white-space"                   : "normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap", //http://perishablepress.com/wrapping-content/
    "white-space-collapse"          : 1,
    "widows"                        : "<integer> | inherit",
    "width"                         : "<length> | <percentage> | <content-sizing> | auto | inherit",
    "word-break"                    : "normal | keep-all | break-all",
    "word-spacing"                  : "<length> | normal | inherit",
    "word-wrap"                     : "normal | break-word",
    "writing-mode"                  : "horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb | inherit",
    "z-index"                       : "<integer> | auto | inherit",
    "zoom"                          : "<number> | <percentage> | normal"
};
function PropertyName(text, hack, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);
    this.hack = hack;

}

PropertyName.prototype = new SyntaxUnit();
PropertyName.prototype.constructor = PropertyName;
PropertyName.prototype.toString = function(){
    return (this.hack ? this.hack : "") + this.text;
};
function PropertyValue(parts, line, col){

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.PROPERTY_VALUE_TYPE);
    this.parts = parts;

}

PropertyValue.prototype = new SyntaxUnit();
PropertyValue.prototype.constructor = PropertyValue;
function PropertyValueIterator(value){
    this._i = 0;
    this._parts = value.parts;
    this._marks = [];
    this.value = value;

}
PropertyValueIterator.prototype.count = function(){
    return this._parts.length;
};
PropertyValueIterator.prototype.isFirst = function(){
    return this._i === 0;
};
PropertyValueIterator.prototype.hasNext = function(){
    return (this._i < this._parts.length);
};
PropertyValueIterator.prototype.mark = function(){
    this._marks.push(this._i);
};
PropertyValueIterator.prototype.peek = function(count){
    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;
};
PropertyValueIterator.prototype.next = function(){
    return this.hasNext() ? this._parts[this._i++] : null;
};
PropertyValueIterator.prototype.previous = function(){
    return this._i > 0 ? this._parts[--this._i] : null;
};
PropertyValueIterator.prototype.restore = function(){
    if (this._marks.length){
        this._i = this._marks.pop();
    }
};
function PropertyValuePart(text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);
    this.type = "unknown";
    var temp;
    if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)){  //dimension
        this.type = "dimension";
        this.value = +RegExp.$1;
        this.units = RegExp.$2;
        switch(this.units.toLowerCase()){

            case "em":
            case "rem":
            case "ex":
            case "px":
            case "cm":
            case "mm":
            case "in":
            case "pt":
            case "pc":
            case "ch":
            case "vh":
            case "vw":
            case "vmax":
            case "vmin":
                this.type = "length";
                break;

            case "deg":
            case "rad":
            case "grad":
                this.type = "angle";
                break;

            case "ms":
            case "s":
                this.type = "time";
                break;

            case "hz":
            case "khz":
                this.type = "frequency";
                break;

            case "dpi":
            case "dpcm":
                this.type = "resolution";
                break;
        }

    } else if (/^([+\-]?[\d\.]+)%$/i.test(text)){  //percentage
        this.type = "percentage";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?\d+)$/i.test(text)){  //integer
        this.type = "integer";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?[\d\.]+)$/i.test(text)){  //number
        this.type = "number";
        this.value = +RegExp.$1;

    } else if (/^#([a-f0-9]{3,6})/i.test(text)){  //hexcolor
        this.type = "color";
        temp = RegExp.$1;
        if (temp.length == 3){
            this.red    = parseInt(temp.charAt(0)+temp.charAt(0),16);
            this.green  = parseInt(temp.charAt(1)+temp.charAt(1),16);
            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2),16);
        } else {
            this.red    = parseInt(temp.substring(0,2),16);
            this.green  = parseInt(temp.substring(2,4),16);
            this.blue   = parseInt(temp.substring(4,6),16);
        }
    } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)){ //rgb() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
    } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)){ //rgb() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
    } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //rgba() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
        this.alpha  = +RegExp.$4;
    } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //rgba() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)){ //hsl()
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
    } else if (/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //hsla() color with percentages
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^url\(["']?([^\)"']+)["']?\)/i.test(text)){ //URI
        this.type   = "uri";
        this.uri    = RegExp.$1;
    } else if (/^([^\(]+)\(/i.test(text)){
        this.type   = "function";
        this.name   = RegExp.$1;
        this.value  = text;
    } else if (/^["'][^"']*["']/.test(text)){    //string
        this.type   = "string";
        this.value  = eval(text);
    } else if (Colors[text.toLowerCase()]){  //named color
        this.type   = "color";
        temp        = Colors[text.toLowerCase()].substring(1);
        this.red    = parseInt(temp.substring(0,2),16);
        this.green  = parseInt(temp.substring(2,4),16);
        this.blue   = parseInt(temp.substring(4,6),16);
    } else if (/^[\,\/]$/.test(text)){
        this.type   = "operator";
        this.value  = text;
    } else if (/^[a-z\-_\u0080-\uFFFF][a-z0-9\-_\u0080-\uFFFF]*$/i.test(text)){
        this.type   = "identifier";
        this.value  = text;
    }

}

PropertyValuePart.prototype = new SyntaxUnit();
PropertyValuePart.prototype.constructor = PropertyValuePart;
PropertyValuePart.fromToken = function(token){
    return new PropertyValuePart(token.value, token.startLine, token.startCol);
};
var Pseudos = {
    ":first-letter": 1,
    ":first-line":   1,
    ":before":       1,
    ":after":        1
};

Pseudos.ELEMENT = 1;
Pseudos.CLASS = 2;

Pseudos.isElement = function(pseudo){
    return pseudo.indexOf("::") === 0 || Pseudos[pseudo.toLowerCase()] == Pseudos.ELEMENT;
};
function Selector(parts, line, col){

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.SELECTOR_TYPE);
    this.parts = parts;
    this.specificity = Specificity.calculate(this);

}

Selector.prototype = new SyntaxUnit();
Selector.prototype.constructor = Selector;
function SelectorPart(elementName, modifiers, text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);
    this.elementName = elementName;
    this.modifiers = modifiers;

}

SelectorPart.prototype = new SyntaxUnit();
SelectorPart.prototype.constructor = SelectorPart;
function SelectorSubPart(text, type, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);
    this.type = type;
    this.args = [];

}

SelectorSubPart.prototype = new SyntaxUnit();
SelectorSubPart.prototype.constructor = SelectorSubPart;
function Specificity(a, b, c, d){
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}

Specificity.prototype = {
    constructor: Specificity,
    compare: function(other){
        var comps = ["a", "b", "c", "d"],
            i, len;

        for (i=0, len=comps.length; i < len; i++){
            if (this[comps[i]] < other[comps[i]]){
                return -1;
            } else if (this[comps[i]] > other[comps[i]]){
                return 1;
            }
        }

        return 0;
    },
    valueOf: function(){
        return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;
    },
    toString: function(){
        return this.a + "," + this.b + "," + this.c + "," + this.d;
    }

};
Specificity.calculate = function(selector){

    var i, len,
        part,
        b=0, c=0, d=0;

    function updateValues(part){

        var i, j, len, num,
            elementName = part.elementName ? part.elementName.text : "",
            modifier;

        if (elementName && elementName.charAt(elementName.length-1) != "*") {
            d++;
        }

        for (i=0, len=part.modifiers.length; i < len; i++){
            modifier = part.modifiers[i];
            switch(modifier.type){
                case "class":
                case "attribute":
                    c++;
                    break;

                case "id":
                    b++;
                    break;

                case "pseudo":
                    if (Pseudos.isElement(modifier.text)){
                        d++;
                    } else {
                        c++;
                    }
                    break;

                case "not":
                    for (j=0, num=modifier.args.length; j < num; j++){
                        updateValues(modifier.args[j]);
                    }
            }
         }
    }

    for (i=0, len=selector.parts.length; i < len; i++){
        part = selector.parts[i];

        if (part instanceof SelectorPart){
            updateValues(part);
        }
    }

    return new Specificity(0, b, c, d);
};

var h = /^[0-9a-fA-F]$/,
    nonascii = /^[\u0080-\uFFFF]$/,
    nl = /\n|\r\n|\r|\f/;

function isHexDigit(c){
    return c !== null && h.test(c);
}

function isDigit(c){
    return c !== null && /\d/.test(c);
}

function isWhitespace(c){
    return c !== null && /\s/.test(c);
}

function isNewLine(c){
    return c !== null && nl.test(c);
}

function isNameStart(c){
    return c !== null && (/[a-z_\u0080-\uFFFF\\]/i.test(c));
}

function isNameChar(c){
    return c !== null && (isNameStart(c) || /[0-9\-\\]/.test(c));
}

function isIdentStart(c){
    return c !== null && (isNameStart(c) || /\-\\/.test(c));
}

function mix(receiver, supplier){
    for (var prop in supplier){
        if (supplier.hasOwnProperty(prop)){
            receiver[prop] = supplier[prop];
        }
    }
    return receiver;
}
function TokenStream(input){
    TokenStreamBase.call(this, input, Tokens);
}

TokenStream.prototype = mix(new TokenStreamBase(), {
    _getToken: function(channel){

        var c,
            reader = this._reader,
            token   = null,
            startLine   = reader.getLine(),
            startCol    = reader.getCol();

        c = reader.read();


        while(c){
            switch(c){
                case "/":

                    if(reader.peek() == "*"){
                        token = this.commentToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case "|":
                case "~":
                case "^":
                case "$":
                case "*":
                    if(reader.peek() == "="){
                        token = this.comparisonToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case "\"":
                case "'":
                    token = this.stringToken(c, startLine, startCol);
                    break;
                case "#":
                    if (isNameChar(reader.peek())){
                        token = this.hashToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case ".":
                    if (isDigit(reader.peek())){
                        token = this.numberToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case "-":
                    if (reader.peek() == "-"){  //could be closing HTML-style comment
                        token = this.htmlCommentEndToken(c, startLine, startCol);
                    } else if (isNameStart(reader.peek())){
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case "!":
                    token = this.importantToken(c, startLine, startCol);
                    break;
                case "@":
                    token = this.atRuleToken(c, startLine, startCol);
                    break;
                case ":":
                    token = this.notToken(c, startLine, startCol);
                    break;
                case "<":
                    token = this.htmlCommentStartToken(c, startLine, startCol);
                    break;
                case "U":
                case "u":
                    if (reader.peek() == "+"){
                        token = this.unicodeRangeToken(c, startLine, startCol);
                        break;
                    }
                default:
                    if (isDigit(c)){
                        token = this.numberToken(c, startLine, startCol);
                    } else
                    if (isWhitespace(c)){
                        token = this.whitespaceToken(c, startLine, startCol);
                    } else
                    if (isIdentStart(c)){
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else
                    {
                        token = this.charToken(c, startLine, startCol);
                    }






            }
            break;
        }

        if (!token && c === null){
            token = this.createToken(Tokens.EOF,null,startLine,startCol);
        }

        return token;
    },
    createToken: function(tt, value, startLine, startCol, options){
        var reader = this._reader;
        options = options || {};

        return {
            value:      value,
            type:       tt,
            channel:    options.channel,
            endChar:    options.endChar,
            hide:       options.hide || false,
            startLine:  startLine,
            startCol:   startCol,
            endLine:    reader.getLine(),
            endCol:     reader.getCol()
        };
    },
    atRuleToken: function(first, startLine, startCol){
        var rule    = first,
            reader  = this._reader,
            tt      = Tokens.CHAR,
            valid   = false,
            ident,
            c;
        reader.mark();
        ident = this.readName();
        rule = first + ident;
        tt = Tokens.type(rule.toLowerCase());
        if (tt == Tokens.CHAR || tt == Tokens.UNKNOWN){
            if (rule.length > 1){
                tt = Tokens.UNKNOWN_SYM;
            } else {
                tt = Tokens.CHAR;
                rule = first;
                reader.reset();
            }
        }

        return this.createToken(tt, rule, startLine, startCol);
    },
    charToken: function(c, startLine, startCol){
        var tt = Tokens.type(c);
        var opts = {};

        if (tt == -1){
            tt = Tokens.CHAR;
        } else {
            opts.endChar = Tokens[tt].endChar;
        }

        return this.createToken(tt, c, startLine, startCol, opts);
    },
    commentToken: function(first, startLine, startCol){
        var reader  = this._reader,
            comment = this.readComment(first);

        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
    },
    comparisonToken: function(c, startLine, startCol){
        var reader  = this._reader,
            comparison  = c + reader.read(),
            tt      = Tokens.type(comparison) || Tokens.CHAR;

        return this.createToken(tt, comparison, startLine, startCol);
    },
    hashToken: function(first, startLine, startCol){
        var reader  = this._reader,
            name    = this.readName(first);

        return this.createToken(Tokens.HASH, name, startLine, startCol);
    },
    htmlCommentStartToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(3);

        if (text == "<!--"){
            return this.createToken(Tokens.CDO, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },
    htmlCommentEndToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(2);

        if (text == "-->"){
            return this.createToken(Tokens.CDC, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },
    identOrFunctionToken: function(first, startLine, startCol){
        var reader  = this._reader,
            ident   = this.readName(first),
            tt      = Tokens.IDENT;
        if (reader.peek() == "("){
            ident += reader.read();
            if (ident.toLowerCase() == "url("){
                tt = Tokens.URI;
                ident = this.readURI(ident);
                if (ident.toLowerCase() == "url("){
                    tt = Tokens.FUNCTION;
                }
            } else {
                tt = Tokens.FUNCTION;
            }
        } else if (reader.peek() == ":"){  //might be an IE function
            if (ident.toLowerCase() == "progid"){
                ident += reader.readTo("(");
                tt = Tokens.IE_FUNCTION;
            }
        }

        return this.createToken(tt, ident, startLine, startCol);
    },
    importantToken: function(first, startLine, startCol){
        var reader      = this._reader,
            important   = first,
            tt          = Tokens.CHAR,
            temp,
            c;

        reader.mark();
        c = reader.read();

        while(c){
            if (c == "/"){
                if (reader.peek() != "*"){
                    break;
                } else {
                    temp = this.readComment(c);
                    if (temp === ""){    //broken!
                        break;
                    }
                }
            } else if (isWhitespace(c)){
                important += c + this.readWhitespace();
            } else if (/i/i.test(c)){
                temp = reader.readCount(8);
                if (/mportant/i.test(temp)){
                    important += c + temp;
                    tt = Tokens.IMPORTANT_SYM;

                }
                break;  //we're done
            } else {
                break;
            }

            c = reader.read();
        }

        if (tt == Tokens.CHAR){
            reader.reset();
            return this.charToken(first, startLine, startCol);
        } else {
            return this.createToken(tt, important, startLine, startCol);
        }


    },
    notToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(4);

        if (text.toLowerCase() == ":not("){
            return this.createToken(Tokens.NOT, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },
    numberToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = this.readNumber(first),
            ident,
            tt      = Tokens.NUMBER,
            c       = reader.peek();

        if (isIdentStart(c)){
            ident = this.readName(reader.read());
            value += ident;

            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)){
                tt = Tokens.LENGTH;
            } else if (/^deg|^rad$|^grad$/i.test(ident)){
                tt = Tokens.ANGLE;
            } else if (/^ms$|^s$/i.test(ident)){
                tt = Tokens.TIME;
            } else if (/^hz$|^khz$/i.test(ident)){
                tt = Tokens.FREQ;
            } else if (/^dpi$|^dpcm$/i.test(ident)){
                tt = Tokens.RESOLUTION;
            } else {
                tt = Tokens.DIMENSION;
            }

        } else if (c == "%"){
            value += reader.read();
            tt = Tokens.PERCENTAGE;
        }

        return this.createToken(tt, value, startLine, startCol);
    },
    stringToken: function(first, startLine, startCol){
        var delim   = first,
            string  = first,
            reader  = this._reader,
            prev    = first,
            tt      = Tokens.STRING,
            c       = reader.read();

        while(c){
            string += c;
            if (c == delim && prev != "\\"){
                break;
            }
            if (isNewLine(reader.peek()) && c != "\\"){
                tt = Tokens.INVALID;
                break;
            }
            prev = c;
            c = reader.read();
        }
        if (c === null){
            tt = Tokens.INVALID;
        }

        return this.createToken(tt, string, startLine, startCol);
    },

    unicodeRangeToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = first,
            temp,
            tt      = Tokens.CHAR;
        if (reader.peek() == "+"){
            reader.mark();
            value += reader.read();
            value += this.readUnicodeRangePart(true);
            if (value.length == 2){
                reader.reset();
            } else {

                tt = Tokens.UNICODE_RANGE;
                if (value.indexOf("?") == -1){

                    if (reader.peek() == "-"){
                        reader.mark();
                        temp = reader.read();
                        temp += this.readUnicodeRangePart(false);
                        if (temp.length == 1){
                            reader.reset();
                        } else {
                            value += temp;
                        }
                    }

                }
            }
        }

        return this.createToken(tt, value, startLine, startCol);
    },
    whitespaceToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = first + this.readWhitespace();
        return this.createToken(Tokens.S, value, startLine, startCol);
    },
    readUnicodeRangePart: function(allowQuestionMark){
        var reader  = this._reader,
            part = "",
            c       = reader.peek();
        while(isHexDigit(c) && part.length < 6){
            reader.read();
            part += c;
            c = reader.peek();
        }
        if (allowQuestionMark){
            while(c == "?" && part.length < 6){
                reader.read();
                part += c;
                c = reader.peek();
            }
        }
        return part;
    },

    readWhitespace: function(){
        var reader  = this._reader,
            whitespace = "",
            c       = reader.peek();

        while(isWhitespace(c)){
            reader.read();
            whitespace += c;
            c = reader.peek();
        }

        return whitespace;
    },
    readNumber: function(first){
        var reader  = this._reader,
            number  = first,
            hasDot  = (first == "."),
            c       = reader.peek();


        while(c){
            if (isDigit(c)){
                number += reader.read();
            } else if (c == "."){
                if (hasDot){
                    break;
                } else {
                    hasDot = true;
                    number += reader.read();
                }
            } else {
                break;
            }

            c = reader.peek();
        }

        return number;
    },
    readString: function(){
        var reader  = this._reader,
            delim   = reader.read(),
            string  = delim,
            prev    = delim,
            c       = reader.peek();

        while(c){
            c = reader.read();
            string += c;
            if (c == delim && prev != "\\"){
                break;
            }
            if (isNewLine(reader.peek()) && c != "\\"){
                string = "";
                break;
            }
            prev = c;
            c = reader.peek();
        }
        if (c === null){
            string = "";
        }

        return string;
    },
    readURI: function(first){
        var reader  = this._reader,
            uri     = first,
            inner   = "",
            c       = reader.peek();

        reader.mark();
        while(c && isWhitespace(c)){
            reader.read();
            c = reader.peek();
        }
        if (c == "'" || c == "\""){
            inner = this.readString();
        } else {
            inner = this.readURL();
        }

        c = reader.peek();
        while(c && isWhitespace(c)){
            reader.read();
            c = reader.peek();
        }
        if (inner === "" || c != ")"){
            uri = first;
            reader.reset();
        } else {
            uri += inner + reader.read();
        }

        return uri;
    },
    readURL: function(){
        var reader  = this._reader,
            url     = "",
            c       = reader.peek();
        while (/^[!#$%&\\*-~]$/.test(c)){
            url += reader.read();
            c = reader.peek();
        }

        return url;

    },
    readName: function(first){
        var reader  = this._reader,
            ident   = first || "",
            c       = reader.peek();

        while(true){
            if (c == "\\"){
                ident += this.readEscape(reader.read());
                c = reader.peek();
            } else if(c && isNameChar(c)){
                ident += reader.read();
                c = reader.peek();
            } else {
                break;
            }
        }

        return ident;
    },

    readEscape: function(first){
        var reader  = this._reader,
            cssEscape = first || "",
            i       = 0,
            c       = reader.peek();

        if (isHexDigit(c)){
            do {
                cssEscape += reader.read();
                c = reader.peek();
            } while(c && isHexDigit(c) && ++i < 6);
        }

        if (cssEscape.length == 3 && /\s/.test(c) ||
            cssEscape.length == 7 || cssEscape.length == 1){
                reader.read();
        } else {
            c = "";
        }

        return cssEscape + c;
    },

    readComment: function(first){
        var reader  = this._reader,
            comment = first || "",
            c       = reader.read();

        if (c == "*"){
            while(c){
                comment += c;
                if (comment.length > 2 && c == "*" && reader.peek() == "/"){
                    comment += reader.read();
                    break;
                }

                c = reader.read();
            }

            return comment;
        } else {
            return "";
        }

    }
});

var Tokens  = [
    { name: "CDO"},
    { name: "CDC"},
    { name: "S", whitespace: true/*, channel: "ws"*/},
    { name: "COMMENT", comment: true, hide: true, channel: "comment" },
    { name: "INCLUDES", text: "~="},
    { name: "DASHMATCH", text: "|="},
    { name: "PREFIXMATCH", text: "^="},
    { name: "SUFFIXMATCH", text: "$="},
    { name: "SUBSTRINGMATCH", text: "*="},
    { name: "STRING"},
    { name: "IDENT"},
    { name: "HASH"},
    { name: "IMPORT_SYM", text: "@import"},
    { name: "PAGE_SYM", text: "@page"},
    { name: "MEDIA_SYM", text: "@media"},
    { name: "FONT_FACE_SYM", text: "@font-face"},
    { name: "CHARSET_SYM", text: "@charset"},
    { name: "NAMESPACE_SYM", text: "@namespace"},
    { name: "VIEWPORT_SYM", text: ["@viewport", "@-ms-viewport"]},
    { name: "UNKNOWN_SYM" },
    { name: "KEYFRAMES_SYM", text: [ "@keyframes", "@-webkit-keyframes", "@-moz-keyframes", "@-o-keyframes" ] },
    { name: "IMPORTANT_SYM"},
    { name: "LENGTH"},
    { name: "ANGLE"},
    { name: "TIME"},
    { name: "FREQ"},
    { name: "DIMENSION"},
    { name: "PERCENTAGE"},
    { name: "NUMBER"},
    { name: "URI"},
    { name: "FUNCTION"},
    { name: "UNICODE_RANGE"},
    { name: "INVALID"},
    { name: "PLUS", text: "+" },
    { name: "GREATER", text: ">"},
    { name: "COMMA", text: ","},
    { name: "TILDE", text: "~"},
    { name: "NOT"},
    { name: "TOPLEFTCORNER_SYM", text: "@top-left-corner"},
    { name: "TOPLEFT_SYM", text: "@top-left"},
    { name: "TOPCENTER_SYM", text: "@top-center"},
    { name: "TOPRIGHT_SYM", text: "@top-right"},
    { name: "TOPRIGHTCORNER_SYM", text: "@top-right-corner"},
    { name: "BOTTOMLEFTCORNER_SYM", text: "@bottom-left-corner"},
    { name: "BOTTOMLEFT_SYM", text: "@bottom-left"},
    { name: "BOTTOMCENTER_SYM", text: "@bottom-center"},
    { name: "BOTTOMRIGHT_SYM", text: "@bottom-right"},
    { name: "BOTTOMRIGHTCORNER_SYM", text: "@bottom-right-corner"},
    { name: "LEFTTOP_SYM", text: "@left-top"},
    { name: "LEFTMIDDLE_SYM", text: "@left-middle"},
    { name: "LEFTBOTTOM_SYM", text: "@left-bottom"},
    { name: "RIGHTTOP_SYM", text: "@right-top"},
    { name: "RIGHTMIDDLE_SYM", text: "@right-middle"},
    { name: "RIGHTBOTTOM_SYM", text: "@right-bottom"},
    { name: "RESOLUTION", state: "media"},
    { name: "IE_FUNCTION" },
    { name: "CHAR" },
    {
        name: "PIPE",
        text: "|"
    },
    {
        name: "SLASH",
        text: "/"
    },
    {
        name: "MINUS",
        text: "-"
    },
    {
        name: "STAR",
        text: "*"
    },

    {
        name: "LBRACE",
        endChar: "}",
        text: "{"
    },
    {
        name: "RBRACE",
        text: "}"
    },
    {
        name: "LBRACKET",
        endChar: "]",
        text: "["
    },
    {
        name: "RBRACKET",
        text: "]"
    },
    {
        name: "EQUALS",
        text: "="
    },
    {
        name: "COLON",
        text: ":"
    },
    {
        name: "SEMICOLON",
        text: ";"
    },

    {
        name: "LPAREN",
        endChar: ")",
        text: "("
    },
    {
        name: "RPAREN",
        text: ")"
    },
    {
        name: "DOT",
        text: "."
    }
];

(function(){

    var nameMap = [],
        typeMap = {};

    Tokens.UNKNOWN = -1;
    Tokens.unshift({name:"EOF"});
    for (var i=0, len = Tokens.length; i < len; i++){
        nameMap.push(Tokens[i].name);
        Tokens[Tokens[i].name] = i;
        if (Tokens[i].text){
            if (Tokens[i].text instanceof Array){
                for (var j=0; j < Tokens[i].text.length; j++){
                    typeMap[Tokens[i].text[j]] = i;
                }
            } else {
                typeMap[Tokens[i].text] = i;
            }
        }
    }

    Tokens.name = function(tt){
        return nameMap[tt];
    };

    Tokens.type = function(c){
        return typeMap[c] || -1;
    };

})();
var Validation = {

    validate: function(property, value){
        var name        = property.toString().toLowerCase(),
            parts       = value.parts,
            expression  = new PropertyValueIterator(value),
            spec        = Properties[name],
            part,
            valid,
            j, count,
            msg,
            types,
            last,
            literals,
            max, multi, group;

        if (!spec) {
            if (name.indexOf("-") !== 0){    //vendor prefixed are ok
                throw new ValidationError("Unknown property '" + property + "'.", property.line, property.col);
            }
        } else if (typeof spec != "number"){
            if (typeof spec == "string"){
                if (spec.indexOf("||") > -1) {
                    this.groupProperty(spec, expression);
                } else {
                    this.singleProperty(spec, expression, 1);
                }

            } else if (spec.multi) {
                this.multiProperty(spec.multi, expression, spec.comma, spec.max || Infinity);
            } else if (typeof spec == "function") {
                spec(expression);
            }

        }

    },

    singleProperty: function(types, expression, max, partial) {

        var result      = false,
            value       = expression.value,
            count       = 0,
            part;

        while (expression.hasNext() && count < max) {
            result = ValidationTypes.isAny(expression, types);
            if (!result) {
                break;
            }
            count++;
        }

        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                 throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }

    },

    multiProperty: function (types, expression, comma, max) {

        var result      = false,
            value       = expression.value,
            count       = 0,
            sep         = false,
            part;

        while(expression.hasNext() && !result && count < max) {
            if (ValidationTypes.isAny(expression, types)) {
                count++;
                if (!expression.hasNext()) {
                    result = true;

                } else if (comma) {
                    if (expression.peek() == ",") {
                        part = expression.next();
                    } else {
                        break;
                    }
                }
            } else {
                break;

            }
        }

        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                part = expression.previous();
                if (comma && part == ",") {
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                } else {
                    throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
                }
            }

        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }

    },

    groupProperty: function (types, expression, comma) {

        var result      = false,
            value       = expression.value,
            typeCount   = types.split("||").length,
            groups      = { count: 0 },
            partial     = false,
            name,
            part;

        while(expression.hasNext() && !result) {
            name = ValidationTypes.isAnyOfGroup(expression, types);
            if (name) {
                if (groups[name]) {
                    break;
                } else {
                    groups[name] = 1;
                    groups.count++;
                    partial = true;

                    if (groups.count == typeCount || !expression.hasNext()) {
                        result = true;
                    }
                }
            } else {
                break;
            }
        }

        if (!result) {
            if (partial && expression.hasNext()) {
                    part = expression.peek();
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }
    }



};
function ValidationError(message, line, col){
    this.col = col;
    this.line = line;
    this.message = message;

}
ValidationError.prototype = new Error();
var ValidationTypes = {

    isLiteral: function (part, literals) {
        var text = part.text.toString().toLowerCase(),
            args = literals.split(" | "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found; i++){
            if (text == args[i].toLowerCase()){
                found = true;
            }
        }

        return found;
    },

    isSimple: function(type) {
        return !!this.simple[type];
    },

    isComplex: function(type) {
        return !!this.complex[type];
    },
    isAny: function (expression, types) {
        var args = types.split(" | "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found && expression.hasNext(); i++){
            found = this.isType(expression, args[i]);
        }

        return found;
    },
    isAnyOfGroup: function(expression, types) {
        var args = types.split(" || "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found; i++){
            found = this.isType(expression, args[i]);
        }

        return found ? args[i-1] : false;
    },
    isType: function (expression, type) {
        var part = expression.peek(),
            result = false;

        if (type.charAt(0) != "<") {
            result = this.isLiteral(part, type);
            if (result) {
                expression.next();
            }
        } else if (this.simple[type]) {
            result = this.simple[type](part);
            if (result) {
                expression.next();
            }
        } else {
            result = this.complex[type](expression);
        }

        return result;
    },



    simple: {

        "<absolute-size>": function(part){
            return ValidationTypes.isLiteral(part, "xx-small | x-small | small | medium | large | x-large | xx-large");
        },

        "<attachment>": function(part){
            return ValidationTypes.isLiteral(part, "scroll | fixed | local");
        },

        "<attr>": function(part){
            return part.type == "function" && part.name == "attr";
        },

        "<bg-image>": function(part){
            return this["<image>"](part) || this["<gradient>"](part) ||  part == "none";
        },

        "<gradient>": function(part) {
            return part.type == "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?(?:repeating\-)?(?:radial\-|linear\-)?gradient/i.test(part);
        },

        "<box>": function(part){
            return ValidationTypes.isLiteral(part, "padding-box | border-box | content-box");
        },

        "<content>": function(part){
            return part.type == "function" && part.name == "content";
        },

        "<relative-size>": function(part){
            return ValidationTypes.isLiteral(part, "smaller | larger");
        },
        "<ident>": function(part){
            return part.type == "identifier";
        },

        "<length>": function(part){
            if (part.type == "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?calc/i.test(part)){
                return true;
            }else{
                return part.type == "length" || part.type == "number" || part.type == "integer" || part == "0";
            }
        },

        "<color>": function(part){
            return part.type == "color" || part == "transparent";
        },

        "<number>": function(part){
            return part.type == "number" || this["<integer>"](part);
        },

        "<integer>": function(part){
            return part.type == "integer";
        },

        "<line>": function(part){
            return part.type == "integer";
        },

        "<angle>": function(part){
            return part.type == "angle";
        },

        "<uri>": function(part){
            return part.type == "uri";
        },

        "<image>": function(part){
            return this["<uri>"](part);
        },

        "<percentage>": function(part){
            return part.type == "percentage" || part == "0";
        },

        "<border-width>": function(part){
            return this["<length>"](part) || ValidationTypes.isLiteral(part, "thin | medium | thick");
        },

        "<border-style>": function(part){
            return ValidationTypes.isLiteral(part, "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset");
        },

        "<content-sizing>": function(part){ // http://www.w3.org/TR/css3-sizing/#width-height-keywords
            return ValidationTypes.isLiteral(part, "fill-available | -moz-available | -webkit-fill-available | max-content | -moz-max-content | -webkit-max-content | min-content | -moz-min-content | -webkit-min-content | fit-content | -moz-fit-content | -webkit-fit-content");
        },

        "<margin-width>": function(part){
            return this["<length>"](part) || this["<percentage>"](part) || ValidationTypes.isLiteral(part, "auto");
        },

        "<padding-width>": function(part){
            return this["<length>"](part) || this["<percentage>"](part);
        },

        "<shape>": function(part){
            return part.type == "function" && (part.name == "rect" || part.name == "inset-rect");
        },

        "<time>": function(part) {
            return part.type == "time";
        },

        "<flex-grow>": function(part){
            return this["<number>"](part);
        },

        "<flex-shrink>": function(part){
            return this["<number>"](part);
        },

        "<width>": function(part){
            return this["<margin-width>"](part);
        },

        "<flex-basis>": function(part){
            return this["<width>"](part);
        },

        "<flex-direction>": function(part){
            return ValidationTypes.isLiteral(part, "row | row-reverse | column | column-reverse");
        },

        "<flex-wrap>": function(part){
            return ValidationTypes.isLiteral(part, "nowrap | wrap | wrap-reverse");
        }
    },

    complex: {

        "<bg-position>": function(expression){
            var types   = this,
                result  = false,
                numeric = "<percentage> | <length>",
                xDir    = "left | right",
                yDir    = "top | bottom",
                count = 0,
                hasNext = function() {
                    return expression.hasNext() && expression.peek() != ",";
                };

            while (expression.peek(count) && expression.peek(count) != ",") {
                count++;
            }

            if (count < 3) {
                if (ValidationTypes.isAny(expression, xDir + " | center | " + numeric)) {
                        result = true;
                        ValidationTypes.isAny(expression, yDir + " | center | " + numeric);
                } else if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, xDir + " | center");
                }
            } else {
                if (ValidationTypes.isAny(expression, xDir)) {
                    if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    } else if (ValidationTypes.isAny(expression, numeric)) {
                        if (ValidationTypes.isAny(expression, yDir)) {
                            result = true;
                            ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, "center")) {
                            result = true;
                        }
                    }
                } else if (ValidationTypes.isAny(expression, yDir)) {
                    if (ValidationTypes.isAny(expression, xDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    } else if (ValidationTypes.isAny(expression, numeric)) {
                        if (ValidationTypes.isAny(expression, xDir)) {
                                result = true;
                                ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, "center")) {
                            result = true;
                        }
                    }
                } else if (ValidationTypes.isAny(expression, "center")) {
                    if (ValidationTypes.isAny(expression, xDir + " | " + yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    }
                }
            }

            return result;
        },

        "<bg-size>": function(expression){
            var types   = this,
                result  = false,
                numeric = "<percentage> | <length> | auto",
                part,
                i, len;

            if (ValidationTypes.isAny(expression, "cover | contain")) {
                result = true;
            } else if (ValidationTypes.isAny(expression, numeric)) {
                result = true;
                ValidationTypes.isAny(expression, numeric);
            }

            return result;
        },

        "<repeat-style>": function(expression){
            var result  = false,
                values  = "repeat | space | round | no-repeat",
                part;

            if (expression.hasNext()){
                part = expression.next();

                if (ValidationTypes.isLiteral(part, "repeat-x | repeat-y")) {
                    result = true;
                } else if (ValidationTypes.isLiteral(part, values)) {
                    result = true;

                    if (expression.hasNext() && ValidationTypes.isLiteral(expression.peek(), values)) {
                        expression.next();
                    }
                }
            }

            return result;

        },

        "<shadow>": function(expression) {
            var result  = false,
                count   = 0,
                inset   = false,
                color   = false,
                part;

            if (expression.hasNext()) {

                if (ValidationTypes.isAny(expression, "inset")){
                    inset = true;
                }

                if (ValidationTypes.isAny(expression, "<color>")) {
                    color = true;
                }

                while (ValidationTypes.isAny(expression, "<length>") && count < 4) {
                    count++;
                }


                if (expression.hasNext()) {
                    if (!color) {
                        ValidationTypes.isAny(expression, "<color>");
                    }

                    if (!inset) {
                        ValidationTypes.isAny(expression, "inset");
                    }

                }

                result = (count >= 2 && count <= 4);

            }

            return result;
        },

        "<x-one-radius>": function(expression) {
            var result  = false,
                simple = "<length> | <percentage> | inherit";

            if (ValidationTypes.isAny(expression, simple)){
                result = true;
                ValidationTypes.isAny(expression, simple);
            }

            return result;
        },

        "<flex>": function(expression) {
            var part,
                result = false;
            if (ValidationTypes.isAny(expression, "none | inherit")) {
                result = true;
            } else {
                if (ValidationTypes.isType(expression, "<flex-grow>")) {
                    if (expression.peek()) {
                        if (ValidationTypes.isType(expression, "<flex-shrink>")) {
                            if (expression.peek()) {
                                result = ValidationTypes.isType(expression, "<flex-basis>");
                            } else {
                                result = true;
                            }
                        } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                            result = expression.peek() === null;
                        }
                    } else {
                        result = true;
                    }
                } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                    result = true;
                }
            }

            if (!result) {
                part = expression.peek();
                throw new ValidationError("Expected (none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]) but found '" + expression.value.text + "'.", part.line, part.col);
            }

            return result;
        }
    }
};

parserlib.css = {
Colors              :Colors,
Combinator          :Combinator,
Parser              :Parser,
PropertyName        :PropertyName,
PropertyValue       :PropertyValue,
PropertyValuePart   :PropertyValuePart,
MediaFeature        :MediaFeature,
MediaQuery          :MediaQuery,
Selector            :Selector,
SelectorPart        :SelectorPart,
SelectorSubPart     :SelectorSubPart,
Specificity         :Specificity,
TokenStream         :TokenStream,
Tokens              :Tokens,
ValidationError     :ValidationError
};
})();

(function(){
for(var prop in parserlib){
exports[prop] = parserlib[prop];
}
})();


function objectToString(o) {
  return Object.prototype.toString.call(o);
}
var util = {
  isArray: function (ar) {
    return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');
  },
  isDate: function (d) {
    return typeof d === 'object' && objectToString(d) === '[object Date]';
  },
  isRegExp: function (re) {
    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
  },
  getRegExpFlags: function (re) {
    var flags = '';
    re.global && (flags += 'g');
    re.ignoreCase && (flags += 'i');
    re.multiline && (flags += 'm');
    return flags;
  }
};


if (typeof module === 'object')
  module.exports = clone;

function clone(parent, circular, depth, prototype) {
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;
  function _clone(parent, depth) {
    if (parent === null)
      return null;

    if (depth == 0)
      return parent;

    var child;
    if (typeof parent != 'object') {
      return parent;
    }

    if (util.isArray(parent)) {
      child = [];
    } else if (util.isRegExp(parent)) {
      child = new RegExp(parent.source, util.getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (util.isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      child = new Buffer(parent.length);
      parent.copy(child);
      return child;
    } else {
      if (typeof prototype == 'undefined') child = Object.create(Object.getPrototypeOf(parent));
      else child = Object.create(prototype);
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    for (var i in parent) {
      child[i] = _clone(parent[i], depth - 1);
    }

    return child;
  }

  return _clone(parent, depth);
}
clone.clonePrototype = function(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

var CSSLint = (function(){

    var rules           = [],
        formatters      = [],
        embeddedRuleset = /\/\*csslint([^\*]*)\*\//,
        api             = new parserlib.util.EventTarget();

    api.version = "@VERSION@";
    api.addRule = function(rule){
        rules.push(rule);
        rules[rule.id] = rule;
    };
    api.clearRules = function(){
        rules = [];
    };
    api.getRules = function(){
        return [].concat(rules).sort(function(a,b){
            return a.id > b.id ? 1 : 0;
        });
    };
    api.getRuleset = function() {
        var ruleset = {},
            i = 0,
            len = rules.length;

        while (i < len){
            ruleset[rules[i++].id] = 1;    //by default, everything is a warning
        }

        return ruleset;
    };
    function applyEmbeddedRuleset(text, ruleset){
        var valueMap,
            embedded = text && text.match(embeddedRuleset),
            rules = embedded && embedded[1];

        if (rules) {
            valueMap = {
                "true": 2,  // true is error
                "": 1,      // blank is warning
                "false": 0, // false is ignore

                "2": 2,     // explicit error
                "1": 1,     // explicit warning
                "0": 0      // explicit ignore
            };

            rules.toLowerCase().split(",").forEach(function(rule){
                var pair = rule.split(":"),
                    property = pair[0] || "",
                    value = pair[1] || "";

                ruleset[property.trim()] = valueMap[value.trim()];
            });
        }

        return ruleset;
    }
    api.addFormatter = function(formatter) {
        formatters[formatter.id] = formatter;
    };
    api.getFormatter = function(formatId){
        return formatters[formatId];
    };
    api.format = function(results, filename, formatId, options) {
        var formatter = this.getFormatter(formatId),
            result = null;

        if (formatter){
            result = formatter.startFormat();
            result += formatter.formatResults(results, filename, options || {});
            result += formatter.endFormat();
        }

        return result;
    };
    api.hasFormat = function(formatId){
        return formatters.hasOwnProperty(formatId);
    };
    api.verify = function(text, ruleset){

        var i = 0,
            reporter,
            lines,
            report,
            parser = new parserlib.css.Parser({ starHack: true, ieFilters: true,
                                                underscoreHack: true, strict: false });
        lines = text.replace(/\n\r?/g, "$split$").split("$split$");

        if (!ruleset){
            ruleset = this.getRuleset();
        }

        if (embeddedRuleset.test(text)){
            ruleset = clone(ruleset);
            ruleset = applyEmbeddedRuleset(text, ruleset);
        }

        reporter = new Reporter(lines, ruleset);

        ruleset.errors = 2;       //always report parsing errors as errors
        for (i in ruleset){
            if(ruleset.hasOwnProperty(i) && ruleset[i]){
                if (rules[i]){
                    rules[i].init(parser, reporter);
                }
            }
        }
        try {
            parser.parse(text);
        } catch (ex) {
            reporter.error("Fatal error, cannot continue: " + ex.message, ex.line, ex.col, {});
        }

        report = {
            messages    : reporter.messages,
            stats       : reporter.stats,
            ruleset     : reporter.ruleset
        };
        report.messages.sort(function (a, b){
            if (a.rollup && !b.rollup){
                return 1;
            } else if (!a.rollup && b.rollup){
                return -1;
            } else {
                return a.line - b.line;
            }
        });

        return report;
    };
    return api;

})();
function Reporter(lines, ruleset){
    this.messages = [];
    this.stats = [];
    this.lines = lines;
    this.ruleset = ruleset;
}

Reporter.prototype = {
    constructor: Reporter,
    error: function(message, line, col, rule){
        this.messages.push({
            type    : "error",
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule || {}
        });
    },
    warn: function(message, line, col, rule){
        this.report(message, line, col, rule);
    },
    report: function(message, line, col, rule){
        this.messages.push({
            type    : this.ruleset[rule.id] === 2 ? "error" : "warning",
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule
        });
    },
    info: function(message, line, col, rule){
        this.messages.push({
            type    : "info",
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule
        });
    },
    rollupError: function(message, rule){
        this.messages.push({
            type    : "error",
            rollup  : true,
            message : message,
            rule    : rule
        });
    },
    rollupWarn: function(message, rule){
        this.messages.push({
            type    : "warning",
            rollup  : true,
            message : message,
            rule    : rule
        });
    },
    stat: function(name, value){
        this.stats[name] = value;
    }
};
CSSLint._Reporter = Reporter;
CSSLint.Util = {
    mix: function(receiver, supplier){
        var prop;

        for (prop in supplier){
            if (supplier.hasOwnProperty(prop)){
                receiver[prop] = supplier[prop];
            }
        }

        return prop;
    },
    indexOf: function(values, value){
        if (values.indexOf){
            return values.indexOf(value);
        } else {
            for (var i=0, len=values.length; i < len; i++){
                if (values[i] === value){
                    return i;
                }
            }
            return -1;
        }
    },
    forEach: function(values, func) {
        if (values.forEach){
            return values.forEach(func);
        } else {
            for (var i=0, len=values.length; i < len; i++){
                func(values[i], i, values);
            }
        }
    }
};

CSSLint.addRule({
    id: "adjoining-classes",
    name: "Disallow adjoining classes",
    desc: "Don't use adjoining classes.",
    browsers: "IE6",
    init: function(parser, reporter){
        var rule = this;
        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                classCount,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE){
                        classCount = 0;
                        for (k=0; k < part.modifiers.length; k++){
                            modifier = part.modifiers[k];
                            if (modifier.type === "class"){
                                classCount++;
                            }
                            if (classCount > 1){
                                reporter.report("Don't use adjoining classes.", part.line, part.col, rule);
                            }
                        }
                    }
                }
            }
        });
    }

});
CSSLint.addRule({
    id: "box-model",
    name: "Beware of broken box size",
    desc: "Don't use width or height when using padding or border.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            widthProperties = {
                border: 1,
                "border-left": 1,
                "border-right": 1,
                padding: 1,
                "padding-left": 1,
                "padding-right": 1
            },
            heightProperties = {
                border: 1,
                "border-bottom": 1,
                "border-top": 1,
                padding: 1,
                "padding-bottom": 1,
                "padding-top": 1
            },
            properties,
            boxSizing = false;

        function startRule(){
            properties = {};
            boxSizing = false;
        }

        function endRule(){
            var prop, value;

            if (!boxSizing) {
                if (properties.height){
                    for (prop in heightProperties){
                        if (heightProperties.hasOwnProperty(prop) && properties[prop]){
                            value = properties[prop].value;
                            if (!(prop === "padding" && value.parts.length === 2 && value.parts[0].value === 0)){
                                reporter.report("Using height with " + prop + " can sometimes make elements larger than you expect.", properties[prop].line, properties[prop].col, rule);
                            }
                        }
                    }
                }

                if (properties.width){
                    for (prop in widthProperties){
                        if (widthProperties.hasOwnProperty(prop) && properties[prop]){
                            value = properties[prop].value;

                            if (!(prop === "padding" && value.parts.length === 2 && value.parts[1].value === 0)){
                                reporter.report("Using width with " + prop + " can sometimes make elements larger than you expect.", properties[prop].line, properties[prop].col, rule);
                            }
                        }
                    }
                }
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();

            if (heightProperties[name] || widthProperties[name]){
                if (!/^0\S*$/.test(event.value) && !(name === "border" && event.value.toString() === "none")){
                    properties[name] = { line: event.property.line, col: event.property.col, value: event.value };
                }
            } else {
                if (/^(width|height)/i.test(name) && /^(length|percentage)/.test(event.value.parts[0].type)){
                    properties[name] = 1;
                } else if (name === "box-sizing") {
                    boxSizing = true;
                }
            }

        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule);
    }

});

CSSLint.addRule({
    id: "box-sizing",
    name: "Disallow use of box-sizing",
    desc: "The box-sizing properties isn't supported in IE6 and IE7.",
    browsers: "IE6, IE7",
    tags: ["Compatibility"],
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();

            if (name === "box-sizing"){
                reporter.report("The box-sizing property isn't supported in IE6 and IE7.", event.line, event.col, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "bulletproof-font-face",
    name: "Use the bulletproof @font-face syntax",
    desc: "Use the bulletproof @font-face syntax to avoid 404's in old IE (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax).",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            fontFaceRule = false,
            firstSrc     = true,
            ruleFailed    = false,
            line, col;
        parser.addListener("startfontface", function(){
            fontFaceRule = true;
        });

        parser.addListener("property", function(event){
            if (!fontFaceRule) {
                return;
            }

            var propertyName = event.property.toString().toLowerCase(),
                value        = event.value.toString();
            line = event.line;
            col  = event.col;
            if (propertyName === "src") {
                var regex = /^\s?url\(['"].+\.eot\?.*['"]\)\s*format\(['"]embedded-opentype['"]\).*$/i;
                if (!value.match(regex) && firstSrc) {
                    ruleFailed = true;
                    firstSrc = false;
                } else if (value.match(regex) && !firstSrc) {
                    ruleFailed = false;
                }
            }


        });
        parser.addListener("endfontface", function(){
            fontFaceRule = false;

            if (ruleFailed) {
                reporter.report("@font-face declaration doesn't follow the fontspring bulletproof syntax.", line, col, rule);
            }
        });
    }
});

CSSLint.addRule({
    id: "compatible-vendor-prefixes",
    name: "Require compatible vendor prefixes",
    desc: "Include all compatible vendor prefixes to reach a wider range of users.",
    browsers: "All",
    init: function (parser, reporter) {
        var rule = this,
            compatiblePrefixes,
            properties,
            prop,
            variations,
            prefixed,
            i,
            len,
            inKeyFrame = false,
            arrayPush = Array.prototype.push,
            applyTo = [];
        compatiblePrefixes = {
            "animation"                  : "webkit moz",
            "animation-delay"            : "webkit moz",
            "animation-direction"        : "webkit moz",
            "animation-duration"         : "webkit moz",
            "animation-fill-mode"        : "webkit moz",
            "animation-iteration-count"  : "webkit moz",
            "animation-name"             : "webkit moz",
            "animation-play-state"       : "webkit moz",
            "animation-timing-function"  : "webkit moz",
            "appearance"                 : "webkit moz",
            "border-end"                 : "webkit moz",
            "border-end-color"           : "webkit moz",
            "border-end-style"           : "webkit moz",
            "border-end-width"           : "webkit moz",
            "border-image"               : "webkit moz o",
            "border-radius"              : "webkit",
            "border-start"               : "webkit moz",
            "border-start-color"         : "webkit moz",
            "border-start-style"         : "webkit moz",
            "border-start-width"         : "webkit moz",
            "box-align"                  : "webkit moz ms",
            "box-direction"              : "webkit moz ms",
            "box-flex"                   : "webkit moz ms",
            "box-lines"                  : "webkit ms",
            "box-ordinal-group"          : "webkit moz ms",
            "box-orient"                 : "webkit moz ms",
            "box-pack"                   : "webkit moz ms",
            "box-sizing"                 : "webkit moz",
            "box-shadow"                 : "webkit moz",
            "column-count"               : "webkit moz ms",
            "column-gap"                 : "webkit moz ms",
            "column-rule"                : "webkit moz ms",
            "column-rule-color"          : "webkit moz ms",
            "column-rule-style"          : "webkit moz ms",
            "column-rule-width"          : "webkit moz ms",
            "column-width"               : "webkit moz ms",
            "hyphens"                    : "epub moz",
            "line-break"                 : "webkit ms",
            "margin-end"                 : "webkit moz",
            "margin-start"               : "webkit moz",
            "marquee-speed"              : "webkit wap",
            "marquee-style"              : "webkit wap",
            "padding-end"                : "webkit moz",
            "padding-start"              : "webkit moz",
            "tab-size"                   : "moz o",
            "text-size-adjust"           : "webkit ms",
            "transform"                  : "webkit moz ms o",
            "transform-origin"           : "webkit moz ms o",
            "transition"                 : "webkit moz o",
            "transition-delay"           : "webkit moz o",
            "transition-duration"        : "webkit moz o",
            "transition-property"        : "webkit moz o",
            "transition-timing-function" : "webkit moz o",
            "user-modify"                : "webkit moz",
            "user-select"                : "webkit moz ms",
            "word-break"                 : "epub ms",
            "writing-mode"               : "epub ms"
        };


        for (prop in compatiblePrefixes) {
            if (compatiblePrefixes.hasOwnProperty(prop)) {
                variations = [];
                prefixed = compatiblePrefixes[prop].split(" ");
                for (i = 0, len = prefixed.length; i < len; i++) {
                    variations.push("-" + prefixed[i] + "-" + prop);
                }
                compatiblePrefixes[prop] = variations;
                arrayPush.apply(applyTo, variations);
            }
        }

        parser.addListener("startrule", function () {
            properties = [];
        });

        parser.addListener("startkeyframes", function (event) {
            inKeyFrame = event.prefix || true;
        });

        parser.addListener("endkeyframes", function () {
            inKeyFrame = false;
        });

        parser.addListener("property", function (event) {
            var name = event.property;
            if (CSSLint.Util.indexOf(applyTo, name.text) > -1) {
                if (!inKeyFrame || typeof inKeyFrame !== "string" ||
                        name.text.indexOf("-" + inKeyFrame + "-") !== 0) {
                    properties.push(name);
                }
            }
        });

        parser.addListener("endrule", function () {
            if (!properties.length) {
                return;
            }

            var propertyGroups = {},
                i,
                len,
                name,
                prop,
                variations,
                value,
                full,
                actual,
                item,
                propertiesSpecified;

            for (i = 0, len = properties.length; i < len; i++) {
                name = properties[i];

                for (prop in compatiblePrefixes) {
                    if (compatiblePrefixes.hasOwnProperty(prop)) {
                        variations = compatiblePrefixes[prop];
                        if (CSSLint.Util.indexOf(variations, name.text) > -1) {
                            if (!propertyGroups[prop]) {
                                propertyGroups[prop] = {
                                    full : variations.slice(0),
                                    actual : [],
                                    actualNodes: []
                                };
                            }
                            if (CSSLint.Util.indexOf(propertyGroups[prop].actual, name.text) === -1) {
                                propertyGroups[prop].actual.push(name.text);
                                propertyGroups[prop].actualNodes.push(name);
                            }
                        }
                    }
                }
            }

            for (prop in propertyGroups) {
                if (propertyGroups.hasOwnProperty(prop)) {
                    value = propertyGroups[prop];
                    full = value.full;
                    actual = value.actual;

                    if (full.length > actual.length) {
                        for (i = 0, len = full.length; i < len; i++) {
                            item = full[i];
                            if (CSSLint.Util.indexOf(actual, item) === -1) {
                                propertiesSpecified = (actual.length === 1) ? actual[0] : (actual.length === 2) ? actual.join(" and ") : actual.join(", ");
                                reporter.report("The property " + item + " is compatible with " + propertiesSpecified + " and should be included as well.", value.actualNodes[0].line, value.actualNodes[0].col, rule);
                            }
                        }

                    }
                }
            }
        });
    }
});

CSSLint.addRule({
    id: "display-property-grouping",
    name: "Require properties appropriate for display",
    desc: "Certain properties shouldn't be used with certain display property values.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        var propertiesToCheck = {
                display: 1,
                "float": "none",
                height: 1,
                width: 1,
                margin: 1,
                "margin-left": 1,
                "margin-right": 1,
                "margin-bottom": 1,
                "margin-top": 1,
                padding: 1,
                "padding-left": 1,
                "padding-right": 1,
                "padding-bottom": 1,
                "padding-top": 1,
                "vertical-align": 1
            },
            properties;

        function reportProperty(name, display, msg){
            if (properties[name]){
                if (typeof propertiesToCheck[name] !== "string" || properties[name].value.toLowerCase() !== propertiesToCheck[name]){
                    reporter.report(msg || name + " can't be used with display: " + display + ".", properties[name].line, properties[name].col, rule);
                }
            }
        }

        function startRule(){
            properties = {};
        }

        function endRule(){

            var display = properties.display ? properties.display.value : null;
            if (display){
                switch(display){

                    case "inline":
                        reportProperty("height", display);
                        reportProperty("width", display);
                        reportProperty("margin", display);
                        reportProperty("margin-top", display);
                        reportProperty("margin-bottom", display);
                        reportProperty("float", display, "display:inline has no effect on floated elements (but may be used to fix the IE6 double-margin bug).");
                        break;

                    case "block":
                        reportProperty("vertical-align", display);
                        break;

                    case "inline-block":
                        reportProperty("float", display);
                        break;

                    default:
                        if (display.indexOf("table-") === 0){
                            reportProperty("margin", display);
                            reportProperty("margin-left", display);
                            reportProperty("margin-right", display);
                            reportProperty("margin-top", display);
                            reportProperty("margin-bottom", display);
                            reportProperty("float", display);
                        }
                }
            }

        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startkeyframerule", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startpage", startRule);

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();

            if (propertiesToCheck[name]){
                properties[name] = { value: event.value.text, line: event.property.line, col: event.property.col };
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endkeyframerule", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endpage", endRule);

    }

});

CSSLint.addRule({
    id: "duplicate-background-images",
    name: "Disallow duplicate background images",
    desc: "Every background-image should be unique. Use a common class for e.g. sprites.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            stack = {};

        parser.addListener("property", function(event){
            var name = event.property.text,
                value = event.value,
                i, len;

            if (name.match(/background/i)) {
                for (i=0, len=value.parts.length; i < len; i++) {
                    if (value.parts[i].type === "uri") {
                        if (typeof stack[value.parts[i].uri] === "undefined") {
                            stack[value.parts[i].uri] = event;
                        }
                        else {
                            reporter.report("Background image '" + value.parts[i].uri + "' was used multiple times, first declared at line " + stack[value.parts[i].uri].line + ", col " + stack[value.parts[i].uri].col + ".", event.line, event.col, rule);
                        }
                    }
                }
            }
        });
    }
});

CSSLint.addRule({
    id: "duplicate-properties",
    name: "Disallow duplicate properties",
    desc: "Duplicate properties must appear one after the other.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            properties,
            lastProperty;

        function startRule(){
            properties = {};
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);

        parser.addListener("property", function(event){
            var property = event.property,
                name = property.text.toLowerCase();

            if (properties[name] && (lastProperty !== name || properties[name] === event.value.text)){
                reporter.report("Duplicate property '" + event.property + "' found.", event.line, event.col, rule);
            }

            properties[name] = event.value.text;
            lastProperty = name;

        });


    }

});

CSSLint.addRule({
    id: "empty-rules",
    name: "Disallow empty rules",
    desc: "Rules without any properties specified should be removed.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            count = 0;

        parser.addListener("startrule", function(){
            count=0;
        });

        parser.addListener("property", function(){
            count++;
        });

        parser.addListener("endrule", function(event){
            var selectors = event.selectors;
            if (count === 0){
                reporter.report("Rule is empty.", selectors[0].line, selectors[0].col, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "errors",
    name: "Parsing Errors",
    desc: "This rule looks for recoverable syntax errors.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("error", function(event){
            reporter.error(event.message, event.line, event.col, rule);
        });

    }

});

CSSLint.addRule({
    id: "fallback-colors",
    name: "Require fallback colors",
    desc: "For older browsers that don't support RGBA, HSL, or HSLA, provide a fallback color.",
    browsers: "IE6,IE7,IE8",
    init: function(parser, reporter){
        var rule = this,
            lastProperty,
            propertiesToCheck = {
                color: 1,
                background: 1,
                "border-color": 1,
                "border-top-color": 1,
                "border-right-color": 1,
                "border-bottom-color": 1,
                "border-left-color": 1,
                border: 1,
                "border-top": 1,
                "border-right": 1,
                "border-bottom": 1,
                "border-left": 1,
                "background-color": 1
            },
            properties;

        function startRule(){
            properties = {};
            lastProperty = null;
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);

        parser.addListener("property", function(event){
            var property = event.property,
                name = property.text.toLowerCase(),
                parts = event.value.parts,
                i = 0,
                colorType = "",
                len = parts.length;

            if(propertiesToCheck[name]){
                while(i < len){
                    if (parts[i].type === "color"){
                        if ("alpha" in parts[i] || "hue" in parts[i]){

                            if (/([^\)]+)\(/.test(parts[i])){
                                colorType = RegExp.$1.toUpperCase();
                            }

                            if (!lastProperty || (lastProperty.property.text.toLowerCase() !== name || lastProperty.colorType !== "compat")){
                                reporter.report("Fallback " + name + " (hex or RGB) should precede " + colorType + " " + name + ".", event.line, event.col, rule);
                            }
                        } else {
                            event.colorType = "compat";
                        }
                    }

                    i++;
                }
            }

            lastProperty = event;
        });

    }

});

CSSLint.addRule({
    id: "floats",
    name: "Disallow too many floats",
    desc: "This rule tests if the float property is used too many times",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;
        var count = 0;
        parser.addListener("property", function(event){
            if (event.property.text.toLowerCase() === "float" &&
                    event.value.text.toLowerCase() !== "none"){
                count++;
            }
        });
        parser.addListener("endstylesheet", function(){
            reporter.stat("floats", count);
            if (count >= 10){
                reporter.rollupWarn("Too many floats (" + count + "), you're probably using them for layout. Consider using a grid system instead.", rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "font-faces",
    name: "Don't use too many web fonts",
    desc: "Too many different web fonts in the same stylesheet.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            count = 0;


        parser.addListener("startfontface", function(){
            count++;
        });

        parser.addListener("endstylesheet", function(){
            if (count > 5){
                reporter.rollupWarn("Too many @font-face declarations (" + count + ").", rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "font-sizes",
    name: "Disallow too many font sizes",
    desc: "Checks the number of font-size declarations.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            count = 0;
        parser.addListener("property", function(event){
            if (event.property.toString() === "font-size"){
                count++;
            }
        });
        parser.addListener("endstylesheet", function(){
            reporter.stat("font-sizes", count);
            if (count >= 10){
                reporter.rollupWarn("Too many font-size declarations (" + count + "), abstraction needed.", rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "gradients",
    name: "Require all gradient definitions",
    desc: "When using a vendor-prefixed gradient, make sure to use them all.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            gradients;

        parser.addListener("startrule", function(){
            gradients = {
                moz: 0,
                webkit: 0,
                oldWebkit: 0,
                o: 0
            };
        });

        parser.addListener("property", function(event){

            if (/\-(moz|o|webkit)(?:\-(?:linear|radial))\-gradient/i.test(event.value)){
                gradients[RegExp.$1] = 1;
            } else if (/\-webkit\-gradient/i.test(event.value)){
                gradients.oldWebkit = 1;
            }

        });

        parser.addListener("endrule", function(event){
            var missing = [];

            if (!gradients.moz){
                missing.push("Firefox 3.6+");
            }

            if (!gradients.webkit){
                missing.push("Webkit (Safari 5+, Chrome)");
            }

            if (!gradients.oldWebkit){
                missing.push("Old Webkit (Safari 4+, Chrome)");
            }

            if (!gradients.o){
                missing.push("Opera 11.1+");
            }

            if (missing.length && missing.length < 4){
                reporter.report("Missing vendor-prefixed CSS gradients for " + missing.join(", ") + ".", event.selectors[0].line, event.selectors[0].col, rule);
            }

        });

    }

});

CSSLint.addRule({
    id: "ids",
    name: "Disallow IDs in selectors",
    desc: "Selectors should not contain IDs.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;
        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                idCount,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                idCount = 0;

                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE){
                        for (k=0; k < part.modifiers.length; k++){
                            modifier = part.modifiers[k];
                            if (modifier.type === "id"){
                                idCount++;
                            }
                        }
                    }
                }

                if (idCount === 1){
                    reporter.report("Don't use IDs in selectors.", selector.line, selector.col, rule);
                } else if (idCount > 1){
                    reporter.report(idCount + " IDs in the selector, really?", selector.line, selector.col, rule);
                }
            }

        });
    }

});

CSSLint.addRule({
    id: "import",
    name: "Disallow @import",
    desc: "Don't use @import, use <link> instead.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("import", function(event){
            reporter.report("@import prevents parallel downloads, use <link> instead.", event.line, event.col, rule);
        });

    }

});

CSSLint.addRule({
    id: "important",
    name: "Disallow !important",
    desc: "Be careful when using !important declaration",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            count = 0;
        parser.addListener("property", function(event){
            if (event.important === true){
                count++;
                reporter.report("Use of !important", event.line, event.col, rule);
            }
        });
        parser.addListener("endstylesheet", function(){
            reporter.stat("important", count);
            if (count >= 10){
                reporter.rollupWarn("Too many !important declarations (" + count + "), try to use less than 10 to avoid specificity issues.", rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "known-properties",
    name: "Require use of known properties",
    desc: "Properties should be known (listed in CSS3 specification) or be a vendor-prefixed property.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("property", function(event){
            if (event.invalid) {
                reporter.report(event.invalid.message, event.line, event.col, rule);
            }

        });
    }

});
CSSLint.addRule({
    id: "order-alphabetical",
    name: "Alphabetical order",
    desc: "Assure properties are in alphabetical order",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            properties;

        var startRule = function () {
            properties = [];
        };

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);

        parser.addListener("property", function(event){
            var name = event.property.text,
                lowerCasePrefixLessName = name.toLowerCase().replace(/^-.*?-/, "");

            properties.push(lowerCasePrefixLessName);
        });

        parser.addListener("endrule", function(event){
            var currentProperties = properties.join(","),
                expectedProperties = properties.sort().join(",");

            if (currentProperties !== expectedProperties){
                reporter.report("Rule doesn't have all its properties in alphabetical ordered.", event.line, event.col, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "outline-none",
    name: "Disallow outline: none",
    desc: "Use of outline: none or outline: 0 should be limited to :focus rules.",
    browsers: "All",
    tags: ["Accessibility"],
    init: function(parser, reporter){
        var rule = this,
            lastRule;

        function startRule(event){
            if (event.selectors){
                lastRule = {
                    line: event.line,
                    col: event.col,
                    selectors: event.selectors,
                    propCount: 0,
                    outline: false
                };
            } else {
                lastRule = null;
            }
        }

        function endRule(){
            if (lastRule){
                if (lastRule.outline){
                    if (lastRule.selectors.toString().toLowerCase().indexOf(":focus") === -1){
                        reporter.report("Outlines should only be modified using :focus.", lastRule.line, lastRule.col, rule);
                    } else if (lastRule.propCount === 1) {
                        reporter.report("Outlines shouldn't be hidden unless other visual changes are made.", lastRule.line, lastRule.col, rule);
                    }
                }
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase(),
                value = event.value;

            if (lastRule){
                lastRule.propCount++;
                if (name === "outline" && (value.toString() === "none" || value.toString() === "0")){
                    lastRule.outline = true;
                }
            }

        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule);

    }

});

CSSLint.addRule({
    id: "overqualified-elements",
    name: "Disallow overqualified elements",
    desc: "Don't use classes or IDs with elements (a.foo or a#foo).",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            classes = {};

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];

                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE){
                        for (k=0; k < part.modifiers.length; k++){
                            modifier = part.modifiers[k];
                            if (part.elementName && modifier.type === "id"){
                                reporter.report("Element (" + part + ") is overqualified, just use " + modifier + " without element name.", part.line, part.col, rule);
                            } else if (modifier.type === "class"){

                                if (!classes[modifier]){
                                    classes[modifier] = [];
                                }
                                classes[modifier].push({ modifier: modifier, part: part });
                            }
                        }
                    }
                }
            }
        });

        parser.addListener("endstylesheet", function(){

            var prop;
            for (prop in classes){
                if (classes.hasOwnProperty(prop)){
                    if (classes[prop].length === 1 && classes[prop][0].part.elementName){
                        reporter.report("Element (" + classes[prop][0].part + ") is overqualified, just use " + classes[prop][0].modifier + " without element name.", classes[prop][0].part.line, classes[prop][0].part.col, rule);
                    }
                }
            }
        });
    }

});

CSSLint.addRule({
    id: "qualified-headings",
    name: "Disallow qualified headings",
    desc: "Headings should not be qualified (namespaced).",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                i, j;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];

                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE){
                        if (part.elementName && /h[1-6]/.test(part.elementName.toString()) && j > 0){
                            reporter.report("Heading (" + part.elementName + ") should not be qualified.", part.line, part.col, rule);
                        }
                    }
                }
            }
        });
    }

});

CSSLint.addRule({
    id: "regex-selectors",
    name: "Disallow selectors that look like regexs",
    desc: "Selectors that look like regular expressions are slow and should be avoided.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE){
                        for (k=0; k < part.modifiers.length; k++){
                            modifier = part.modifiers[k];
                            if (modifier.type === "attribute"){
                                if (/([\~\|\^\$\*]=)/.test(modifier)){
                                    reporter.report("Attribute selectors with " + RegExp.$1 + " are slow!", modifier.line, modifier.col, rule);
                                }
                            }

                        }
                    }
                }
            }
        });
    }

});

CSSLint.addRule({
    id: "rules-count",
    name: "Rules Count",
    desc: "Track how many rules there are.",
    browsers: "All",
    init: function(parser, reporter){
        var count = 0;
        parser.addListener("startrule", function(){
            count++;
        });

        parser.addListener("endstylesheet", function(){
            reporter.stat("rule-count", count);
        });
    }

});

CSSLint.addRule({
    id: "selector-max-approaching",
    name: "Warn when approaching the 4095 selector limit for IE",
    desc: "Will warn when selector count is >= 3800 selectors.",
    browsers: "IE",
    init: function(parser, reporter) {
        var rule = this, count = 0;

        parser.addListener("startrule", function(event) {
            count += event.selectors.length;
        });

        parser.addListener("endstylesheet", function() {
            if (count >= 3800) {
                reporter.report("You have " + count + " selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.",0,0,rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "selector-max",
    name: "Error when past the 4095 selector limit for IE",
    desc: "Will error when selector count is > 4095.",
    browsers: "IE",
    init: function(parser, reporter){
        var rule = this, count = 0;

        parser.addListener("startrule", function(event) {
            count += event.selectors.length;
        });

        parser.addListener("endstylesheet", function() {
            if (count > 4095) {
                reporter.report("You have " + count + " selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.",0,0,rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "selector-newline",
    name: "Disallow new-line characters in selectors",
    desc: "New-line characters in selectors are usually a forgotten comma and not a descendant combinator.",
    browsers: "All",
    init: function(parser, reporter) {
        var rule = this;

        function startRule(event) {
            var i, len, selector, p, n, pLen, part, part2, type, currentLine, nextLine,
                selectors = event.selectors;

            for (i = 0, len = selectors.length; i < len; i++) {
                selector = selectors[i];
                for (p = 0, pLen = selector.parts.length; p < pLen; p++) {
                    for (n = p + 1; n < pLen; n++) {
                        part = selector.parts[p];
                        part2 = selector.parts[n];
                        type = part.type;
                        currentLine = part.line;
                        nextLine = part2.line;

                        if (type === "descendant" && nextLine > currentLine) {
                            reporter.report("newline character found in selector (forgot a comma?)", currentLine, selectors[i].parts[0].col, rule);
                        }
                    }
                }

            }
        }

        parser.addListener("startrule", startRule);

    }
});

CSSLint.addRule({
    id: "shorthand",
    name: "Require shorthand properties",
    desc: "Use shorthand properties where possible.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            prop, i, len,
            propertiesToCheck = {},
            properties,
            mapping = {
                "margin": [
                    "margin-top",
                    "margin-bottom",
                    "margin-left",
                    "margin-right"
                ],
                "padding": [
                    "padding-top",
                    "padding-bottom",
                    "padding-left",
                    "padding-right"
                ]
            };
        for (prop in mapping){
            if (mapping.hasOwnProperty(prop)){
                for (i=0, len=mapping[prop].length; i < len; i++){
                    propertiesToCheck[mapping[prop][i]] = prop;
                }
            }
        }

        function startRule(){
            properties = {};
        }
        function endRule(event){

            var prop, i, len, total;
            for (prop in mapping){
                if (mapping.hasOwnProperty(prop)){
                    total=0;

                    for (i=0, len=mapping[prop].length; i < len; i++){
                        total += properties[mapping[prop][i]] ? 1 : 0;
                    }

                    if (total === mapping[prop].length){
                        reporter.report("The properties " + mapping[prop].join(", ") + " can be replaced by " + prop + ".", event.line, event.col, rule);
                    }
                }
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("property", function(event){
            var name = event.property.toString().toLowerCase();

            if (propertiesToCheck[name]){
                properties[name] = 1;
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);

    }

});

CSSLint.addRule({
    id: "star-property-hack",
    name: "Disallow properties with a star prefix",
    desc: "Checks for the star property hack (targets IE6/7)",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;
        parser.addListener("property", function(event){
            var property = event.property;

            if (property.hack === "*") {
                reporter.report("Property with star prefix found.", event.property.line, event.property.col, rule);
            }
        });
    }
});

CSSLint.addRule({
    id: "text-indent",
    name: "Disallow negative text-indent",
    desc: "Checks for text indent less than -99px",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            textIndent,
            direction;


        function startRule(){
            textIndent = false;
            direction = "inherit";
        }
        function endRule(){
            if (textIndent && direction !== "ltr"){
                reporter.report("Negative text-indent doesn't work well with RTL. If you use text-indent for image replacement explicitly set direction for that item to ltr.", textIndent.line, textIndent.col, rule);
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("property", function(event){
            var name = event.property.toString().toLowerCase(),
                value = event.value;

            if (name === "text-indent" && value.parts[0].value < -99){
                textIndent = event.property;
            } else if (name === "direction" && value.toString() === "ltr"){
                direction = "ltr";
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);

    }

});

CSSLint.addRule({
    id: "underscore-property-hack",
    name: "Disallow properties with an underscore prefix",
    desc: "Checks for the underscore property hack (targets IE6)",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;
        parser.addListener("property", function(event){
            var property = event.property;

            if (property.hack === "_") {
                reporter.report("Property with underscore prefix found.", event.property.line, event.property.col, rule);
            }
        });
    }
});

CSSLint.addRule({
    id: "unique-headings",
    name: "Headings should only be defined once",
    desc: "Headings should be defined only once.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        var headings = {
                h1: 0,
                h2: 0,
                h3: 0,
                h4: 0,
                h5: 0,
                h6: 0
            };

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                pseudo,
                i, j;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                part = selector.parts[selector.parts.length-1];

                if (part.elementName && /(h[1-6])/i.test(part.elementName.toString())){

                    for (j=0; j < part.modifiers.length; j++){
                        if (part.modifiers[j].type === "pseudo"){
                            pseudo = true;
                            break;
                        }
                    }

                    if (!pseudo){
                        headings[RegExp.$1]++;
                        if (headings[RegExp.$1] > 1) {
                            reporter.report("Heading (" + part.elementName + ") has already been defined.", part.line, part.col, rule);
                        }
                    }
                }
            }
        });

        parser.addListener("endstylesheet", function(){
            var prop,
                messages = [];

            for (prop in headings){
                if (headings.hasOwnProperty(prop)){
                    if (headings[prop] > 1){
                        messages.push(headings[prop] + " " + prop + "s");
                    }
                }
            }

            if (messages.length){
                reporter.rollupWarn("You have " + messages.join(", ") + " defined in this stylesheet.", rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "universal-selector",
    name: "Disallow universal selector",
    desc: "The universal selector (*) is known to be slow.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                i;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];

                part = selector.parts[selector.parts.length-1];
                if (part.elementName === "*"){
                    reporter.report(rule.desc, part.line, part.col, rule);
                }
            }
        });
    }

});

CSSLint.addRule({
    id: "unqualified-attributes",
    name: "Disallow unqualified attribute selectors",
    desc: "Unqualified attribute selectors are known to be slow.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("startrule", function(event){

            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];

                part = selector.parts[selector.parts.length-1];
                if (part.type === parser.SELECTOR_PART_TYPE){
                    for (k=0; k < part.modifiers.length; k++){
                        modifier = part.modifiers[k];
                        if (modifier.type === "attribute" && (!part.elementName || part.elementName === "*")){
                            reporter.report(rule.desc, part.line, part.col, rule);
                        }
                    }
                }

            }
        });
    }

});

CSSLint.addRule({
    id: "vendor-prefix",
    name: "Require standard property with vendor prefix",
    desc: "When using a vendor-prefixed property, make sure to include the standard one.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            properties,
            num,
            propertiesToCheck = {
                "-webkit-border-radius": "border-radius",
                "-webkit-border-top-left-radius": "border-top-left-radius",
                "-webkit-border-top-right-radius": "border-top-right-radius",
                "-webkit-border-bottom-left-radius": "border-bottom-left-radius",
                "-webkit-border-bottom-right-radius": "border-bottom-right-radius",

                "-o-border-radius": "border-radius",
                "-o-border-top-left-radius": "border-top-left-radius",
                "-o-border-top-right-radius": "border-top-right-radius",
                "-o-border-bottom-left-radius": "border-bottom-left-radius",
                "-o-border-bottom-right-radius": "border-bottom-right-radius",

                "-moz-border-radius": "border-radius",
                "-moz-border-radius-topleft": "border-top-left-radius",
                "-moz-border-radius-topright": "border-top-right-radius",
                "-moz-border-radius-bottomleft": "border-bottom-left-radius",
                "-moz-border-radius-bottomright": "border-bottom-right-radius",

                "-moz-column-count": "column-count",
                "-webkit-column-count": "column-count",

                "-moz-column-gap": "column-gap",
                "-webkit-column-gap": "column-gap",

                "-moz-column-rule": "column-rule",
                "-webkit-column-rule": "column-rule",

                "-moz-column-rule-style": "column-rule-style",
                "-webkit-column-rule-style": "column-rule-style",

                "-moz-column-rule-color": "column-rule-color",
                "-webkit-column-rule-color": "column-rule-color",

                "-moz-column-rule-width": "column-rule-width",
                "-webkit-column-rule-width": "column-rule-width",

                "-moz-column-width": "column-width",
                "-webkit-column-width": "column-width",

                "-webkit-column-span": "column-span",
                "-webkit-columns": "columns",

                "-moz-box-shadow": "box-shadow",
                "-webkit-box-shadow": "box-shadow",

                "-moz-transform" : "transform",
                "-webkit-transform" : "transform",
                "-o-transform" : "transform",
                "-ms-transform" : "transform",

                "-moz-transform-origin" : "transform-origin",
                "-webkit-transform-origin" : "transform-origin",
                "-o-transform-origin" : "transform-origin",
                "-ms-transform-origin" : "transform-origin",

                "-moz-box-sizing" : "box-sizing",
                "-webkit-box-sizing" : "box-sizing"
            };
        function startRule(){
            properties = {};
            num = 1;
        }
        function endRule(){
            var prop,
                i,
                len,
                needed,
                actual,
                needsStandard = [];

            for (prop in properties){
                if (propertiesToCheck[prop]){
                    needsStandard.push({ actual: prop, needed: propertiesToCheck[prop]});
                }
            }

            for (i=0, len=needsStandard.length; i < len; i++){
                needed = needsStandard[i].needed;
                actual = needsStandard[i].actual;

                if (!properties[needed]){
                    reporter.report("Missing standard property '" + needed + "' to go along with '" + actual + "'.", properties[actual][0].name.line, properties[actual][0].name.col, rule);
                } else {
                    if (properties[needed][0].pos < properties[actual][0].pos){
                        reporter.report("Standard property '" + needed + "' should come after vendor-prefixed property '" + actual + "'.", properties[actual][0].name.line, properties[actual][0].name.col, rule);
                    }
                }
            }

        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();

            if (!properties[name]){
                properties[name] = [];
            }

            properties[name].push({ name: event.property, value : event.value, pos:num++ });
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule);
    }

});

CSSLint.addRule({
    id: "zero-units",
    name: "Disallow units for 0 values",
    desc: "You don't need to specify units when a value is 0.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;
        parser.addListener("property", function(event){
            var parts = event.value.parts,
                i = 0,
                len = parts.length;

            while(i < len){
                if ((parts[i].units || parts[i].type === "percentage") && parts[i].value === 0 && parts[i].type !== "time"){
                    reporter.report("Values of 0 shouldn't have units specified.", parts[i].line, parts[i].col, rule);
                }
                i++;
            }

        });

    }

});

(function() {
    var xmlEscape = function(str) {
        if (!str || str.constructor !== String) {
            return "";
        }

        return str.replace(/[\"&><]/g, function(match) {
            switch (match) {
                case "\"":
                    return "&quot;";
                case "&":
                    return "&amp;";
                case "<":
                    return "&lt;";
                case ">":
                    return "&gt;";
            }
        });
    };

    CSSLint.addFormatter({
        id: "checkstyle-xml",
        name: "Checkstyle XML format",
        startFormat: function(){
            return "<?xml version=\"1.0\" encoding=\"utf-8\"?><checkstyle>";
        },
        endFormat: function(){
            return "</checkstyle>";
        },
        readError: function(filename, message) {
            return "<file name=\"" + xmlEscape(filename) + "\"><error line=\"0\" column=\"0\" severty=\"error\" message=\"" + xmlEscape(message) + "\"></error></file>";
        },
        formatResults: function(results, filename/*, options*/) {
            var messages = results.messages,
                output = [];
            var generateSource = function(rule) {
                if (!rule || !("name" in rule)) {
                    return "";
                }
                return "net.csslint." + rule.name.replace(/\s/g,"");
            };



            if (messages.length > 0) {
                output.push("<file name=\""+filename+"\">");
                CSSLint.Util.forEach(messages, function (message) {
                    if (!message.rollup) {
                        output.push("<error line=\"" + message.line + "\" column=\"" + message.col + "\" severity=\"" + message.type + "\"" +
                          " message=\"" + xmlEscape(message.message) + "\" source=\"" + generateSource(message.rule) +"\"/>");
                    }
                });
                output.push("</file>");
            }

            return output.join("");
        }
    });

}());

CSSLint.addFormatter({
    id: "compact",
    name: "Compact, 'porcelain' format",
    startFormat: function() {
        return "";
    },
    endFormat: function() {
        return "";
    },
    formatResults: function(results, filename, options) {
        var messages = results.messages,
            output = "";
        options = options || {};
        var capitalize = function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        };

        if (messages.length === 0) {
              return options.quiet ? "" : filename + ": Lint Free!";
        }

        CSSLint.Util.forEach(messages, function(message) {
            if (message.rollup) {
                output += filename + ": " + capitalize(message.type) + " - " + message.message + "\n";
            } else {
                output += filename + ": " + "line " + message.line +
                    ", col " + message.col + ", " + capitalize(message.type) + " - " + message.message + " (" + message.rule.id + ")\n";
            }
        });

        return output;
    }
});

CSSLint.addFormatter({
    id: "csslint-xml",
    name: "CSSLint XML format",
    startFormat: function(){
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><csslint>";
    },
    endFormat: function(){
        return "</csslint>";
    },
    formatResults: function(results, filename/*, options*/) {
        var messages = results.messages,
            output = [];
        var escapeSpecialCharacters = function(str) {
            if (!str || str.constructor !== String) {
                return "";
            }
            return str.replace(/\"/g, "'").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        };

        if (messages.length > 0) {
            output.push("<file name=\""+filename+"\">");
            CSSLint.Util.forEach(messages, function (message) {
                if (message.rollup) {
                    output.push("<issue severity=\"" + message.type + "\" reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                } else {
                    output.push("<issue line=\"" + message.line + "\" char=\"" + message.col + "\" severity=\"" + message.type + "\"" +
                        " reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                }
            });
            output.push("</file>");
        }

        return output.join("");
    }
});

CSSLint.addFormatter({
    id: "junit-xml",
    name: "JUNIT XML format",
    startFormat: function(){
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><testsuites>";
    },
    endFormat: function() {
        return "</testsuites>";
    },
    formatResults: function(results, filename/*, options*/) {

        var messages = results.messages,
            output = [],
            tests = {
                "error": 0,
                "failure": 0
            };
        var generateSource = function(rule) {
            if (!rule || !("name" in rule)) {
                return "";
            }
            return "net.csslint." + rule.name.replace(/\s/g,"");
        };
        var escapeSpecialCharacters = function(str) {

            if (!str || str.constructor !== String) {
                return "";
            }

            return str.replace(/\"/g, "'").replace(/</g, "&lt;").replace(/>/g, "&gt;");

        };

        if (messages.length > 0) {

            messages.forEach(function (message) {
                var type = message.type === "warning" ? "error" : message.type;
                if (!message.rollup) {
                    output.push("<testcase time=\"0\" name=\"" + generateSource(message.rule) + "\">");
                    output.push("<" + type + " message=\"" + escapeSpecialCharacters(message.message) + "\"><![CDATA[" + message.line + ":" + message.col + ":" + escapeSpecialCharacters(message.evidence)  + "]]></" + type + ">");
                    output.push("</testcase>");

                    tests[type] += 1;

                }

            });

            output.unshift("<testsuite time=\"0\" tests=\"" + messages.length + "\" skipped=\"0\" errors=\"" + tests.error + "\" failures=\"" + tests.failure + "\" package=\"net.csslint\" name=\"" + filename + "\">");
            output.push("</testsuite>");

        }

        return output.join("");

    }
});

CSSLint.addFormatter({
    id: "lint-xml",
    name: "Lint XML format",
    startFormat: function(){
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><lint>";
    },
    endFormat: function(){
        return "</lint>";
    },
    formatResults: function(results, filename/*, options*/) {
        var messages = results.messages,
            output = [];
        var escapeSpecialCharacters = function(str) {
            if (!str || str.constructor !== String) {
                return "";
            }
            return str.replace(/\"/g, "'").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        };

        if (messages.length > 0) {

            output.push("<file name=\""+filename+"\">");
            CSSLint.Util.forEach(messages, function (message) {
                if (message.rollup) {
                    output.push("<issue severity=\"" + message.type + "\" reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                } else {
                    output.push("<issue line=\"" + message.line + "\" char=\"" + message.col + "\" severity=\"" + message.type + "\"" +
                        " reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                }
            });
            output.push("</file>");
        }

        return output.join("");
    }
});

CSSLint.addFormatter({
    id: "text",
    name: "Plain Text",
    startFormat: function() {
        return "";
    },
    endFormat: function() {
        return "";
    },
    formatResults: function(results, filename, options) {
        var messages = results.messages,
            output = "";
        options = options || {};

        if (messages.length === 0) {
            return options.quiet ? "" : "\n\ncsslint: No errors in " + filename + ".";
        }

        output = "\n\ncsslint: There ";
        if (messages.length === 1) {
            output += "is 1 problem";
        } else {
            output += "are " + messages.length  +  " problems";
        }
        output += " in " + filename + ".";

        var pos = filename.lastIndexOf("/"),
            shortFilename = filename;

        if (pos === -1){
            pos = filename.lastIndexOf("\\");
        }
        if (pos > -1){
            shortFilename = filename.substring(pos+1);
        }

        CSSLint.Util.forEach(messages, function (message, i) {
            output = output + "\n\n" + shortFilename;
            if (message.rollup) {
                output += "\n" + (i+1) + ": " + message.type;
                output += "\n" + message.message;
            } else {
                output += "\n" + (i+1) + ": " + message.type + " at line " + message.line + ", col " + message.col;
                output += "\n" + message.message;
                output += "\n" + message.evidence;
            }
        });

        return output;
    }
});

module.exports.CSSLint = CSSLint;

});

define("plugins/c9.ide.language.css/css_handler",[], function(require, exports, module) {

var baseLanguageHandler = require("plugins/c9.ide.language/base_handler");
var CSSLint = require("ace/mode/css/csslint");
var handler = module.exports = Object.create(baseLanguageHandler);

handler.handlesLanguage = function(language) {
    return language === "css" || language === "less";
};

handler.analyze = function(value, ast, options, callback) {
    if (this.language === "less")
        return callback();
    
    callback(handler.analyzeSync(value, ast));
};
var CSSLint_RULESET = {
    "adjoining-classes": 0,
    "box-model": 1,
    "box-sizing": 1,
    "compatible-vendor-prefixes": 3,
    "display-property-grouping": 1,
    "duplicate-background-images": 1,
    "duplicate-properties": 1,
    "empty-rules": 1,
    "errors": 2,
    "fallback-colors": 3,
    "floats": 1,
    "font-faces": 1,
    "font-sizes": 1,
    "gradients": 3,
    "ids": 0,
    "import": 0,
    "important": 3,
    "known-properties": 1,
    "outline-none": 3,
    "overqualified-elements": 1,
    "qualified-headings": 3,
    "regex-selectors": 1,
    "rules-count": 1,
    "shorthand": 1,
    "star-property-hack": 1,
    "text-indent": 1,
    "underscore-property-hack": 1,
    "unique-headings": 1,
    "universal-selector": 1,
    "unqualified-attributes": 1,
    "vendor-prefix": 3,
    "zero-units": 0
};

handler.analyzeSync = function(value, ast) {
    value = value.replace(/^(#!.*\n)/, "//$1");

    var results = value && CSSLint.CSSLint.verify(value, CSSLint_RULESET);
    var warnings = results ? results.messages : [];

    return warnings.map(function(warning) {
        if (CSSLint_RULESET[warning.rule.id] === 3)
            warning.type = "info";
        return {
            pos: {
                sl: warning.line - 1,
                sc: warning.col - 1
            },
            type: warning.type,
            level: warning.type,
            message: warning.message
        };
    });
};

handler.getIdentifierRegex = function() {
    return (/[_a-zA-Z0-9-]/);
};

});

define("plugins/c9.ide.language.html/snippets",[], function(require, exports, module) {

module.exports = {
    "script": "<script type=\"text/javascript\" src=\"^^\"></script>",
    "csslink": "<link rel=\"stylesheet\" href=\"^^\" type=\"text/css\" />",
    "link": "<link rel=\"stylesheet\" href=\"^^\" type=\"text/css\" />",
    "style": "<style type=\"text/css\">\n\t^^\n</style>",
    "amailto": "<a href=\"mailto:^^\"></a>",
    "html": "<!DOCTYPE html>\n<html>\n\t^^\n</html>",
    "body": "<body>\n\t^^\n</body>",
    "head": "<head>\n\t^^\n</head>",
    "table": "<table>\n\t<tr>\n\t\t<td>^^</td>\n\t</tr>\n</table>",
    "th": "<th>\n\t^^\n</th>",
    "tr": "<tr>\n\t^^\n</tr>",
    "td": "<td>^^</td>",
    "divc": "<div class=\"^^\"></div>",
    "div": "<div>^^</div>",
    "spanc": "<span class=\"^^\"></span>",
    "span": "<span>^^</span>",
    "form": "<form>\n\t<input type=\"text\" name=\"^^\"/>\n\t<input type=\"submit\" value=\"Submit\"/>\n</form>",
    "input": "<input type=\"text\" name=\"^^\"/>",
    "password": "<input type=\"password\" name=\"^^\"/>",
    "textarea": "<input type=\"textarea\" name=\"^^\"/>",
    "img": "<img src=\"^^\"></img>",
    "label": "<label for=\"\">^^</label>",
    "lorem": "Lorem ipsum dolor sit amet, consectetuer adipiscing elit,\nsed diam nonummy nibh euismod tincidunt ut laoreet dolore\nmagna aliquam erat volutpat. Ut wisi enim ad minim veniam,\nquis nostrud exerci tation ullamcorper suscipit lobortis nisl\nut aliquip ex ea commodo consequat. Duis autem vel eum iriure\ndolor in hendrerit in vulputate velit esse molestie consequat,\nvel illum dolore eu feugiat nulla facilisis at vero eros et\naccumsan et iusto odio dignissim qui blandit praesent luptatum\nzzril delenit augue duis dolore te feugait nulla facilisi.\nNam liber tempor cum soluta nobis eleifend option congue\nnihil imperdiet doming id quod mazim placerat facer possim\nassum. Typi non habent claritatem insitam; est usus legentis\nin iis qui facit eorum claritatem. Investigationes\ndemonstraverunt lectores legere me lius quod ii legunt saepius.\nClaritas est etiam processus dynamicus, qui sequitur mutationem\nconsuetudium lectorum. Mirum est notare quam littera gothica,\nquam nunc putamus parum claram, anteposuerit litterarum formas\nhumanitatis per seacula quarta decima et quinta decima. Eodem\nmodo typi, qui nunc nobis videntur parum clari, fiant sollemnes\nin futurum.^^"
};

});

define("plugins/c9.ide.language.html/html_completer",[], function(require, exports, module) {

var completeUtil = require("plugins/c9.ide.language/complete_util");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var htmlSnippets = require("./snippets");

var completer = module.exports = Object.create(baseLanguageHandler);

completer.handlesLanguage = function(language) {
    return language === "html";
};

var JADE_REGEX = /.*?([a-zA-Z]*)([.#])([\w]+)/;
var JADE_ID_REGEX = /[a-zA-Z_0-9\$\_.#]/;

completer.getCompletionRegex = function() {
    return /[<=A-Za-z:_$\-]/;
};

completer.getIdentifierRegex = function() {
    return JADE_ID_REGEX;
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    var line = doc.getLine(pos.row);
    var match = JADE_REGEX.exec(line.substring(0, pos.column));
    if (match) {
        var replaceText;
        var snippet = htmlSnippets[match[1]];
        if (snippet) {
            replaceText = snippet.replace("<" + match[1] + ">",
                ["<", match[1], match[2] === "." ? " class=\"" : " id=\"",
                    match[3], "\">"].join(""));
        }
        else {
            replaceText = ["<", match[1] || "div",
                match[2] === "." ? " class=\"" : " id=\"", match[3],
                "\">^^", "</", match[1] || "div", ">"].join("");
        }
        callback([{
              name: match[1] + match[2] + match[3],
              replaceText: replaceText,
              doc: "<pre>" + replaceText.replace("\^\^", "&#9251;").replace(/</g, "&lt;") + "</pre>",
              icon: null,
              meta: "Jade-Haml",
              identifierRegex: JADE_ID_REGEX,
              priority: 100
        }]);
    }
    else {
        var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column);
        var allIdentifiers = Object.keys(htmlSnippets);
        var matches = completeUtil.findCompletions(identifier, allIdentifiers);
        callback(matches.map(function(m) {
            return {
              name: m,
              replaceText: htmlSnippets[m],
              doc: "<pre>" + htmlSnippets[m].replace("\^\^", "&#9251;").replace(/</g, "&lt;") + "</pre>",
              icon: null,
              meta: "snippet",
              priority: 2
            };
        }));
    }
};


});

define("plugins/c9.ide.language.codeintel/worker/codeintel_worker",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var workerUtil = require("plugins/c9.ide.language/worker_util");

var DAEMON_PORT = 10881;
var ERROR_PORT_IN_USE = 98;
var ERROR_NO_SERVER = 7;
var LANGUAGES = {
    c_cpp: "C++",
    css: "CSS",
    django: "Django",
    perl: "Perl",
    php: "PHP",
    ruby: "Ruby",
    tcl: "Tcl",
    html4: "HTML",
    html: "HTML5",
    rhtml: "RHTML",
    templatetoolkit: "TemplateToolkit",
    smarty: "Smarty",
    twig: "Twig",
    xslt: "XSLT",
    xul: "XUL",
    python: "Python",
    python3: "Python3",
    golang: "Go",
    javascript: "JavaScript",
    less: "Less",
    mason: "Mason",
    mustache: "Mustache",
    mxml: "MXML",
    nodejs: "Node.js",
    xbl: "XBL",
    xml: "XML",
};

var handler = module.exports = Object.create(baseHandler);
var languages = [];
var paths = {};
var server;
var launchCommand;
var enabled;
var daemon;
var lastInfoTimer;
var lastInfoPopup;

handler.handlesLanguage = function(language) {
    return languages.indexOf(language) > -1;
};

handler.addLanguage = function(language) {
    languages.push(language);
};

handler.$disableZeroLengthCompletion = true;

handler.init = function(callback) {
    var emitter = handler.getEmitter();
    emitter.on("setup", function(e) {
        server = e.server;
        launchCommand = e.launchCommand;
        paths = e.paths;
        enabled = e.enabled;
    });
    callback();
};

handler.onDocumentOpen = function(path, doc, oldPath, callback) {
    if (!launchCommand) return callback();
    
    ensureDaemon(callback);
};
handler.complete = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    if (options.language === "PHP" && !options.identifierPrefix && (!options.line[pos.column - 1] || " " === options.line[pos.column - 1]))
        return callback(new Error("Warning: codeintel doesn't support empty-prefix completions"));
    
    callDaemon("completions", handler.path, doc, pos, options, function(err, results, meta) {
        if (err) return callback(err);
        
        results && results.forEach(function beautifyCompletion(r) {
            r.isContextual = true;
            r.guessTooltip = true;
            r.nodoc = "always";
            r.replaceText = r.replaceText || r.name;
            r.priority = r.name[0] === "_" || r.replaceText === r.replaceText.toUpperCase() ? 3 : 4;
            r.icon = r.name[0] === "_" ? r.icon.replace(/2?$/, "2") : r.icon;
        });
        callback(null, results);
    });
};
handler.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    callDaemon("definitions", handler.path, doc, pos, options, callback);
};
function callDaemon(command, path, doc, pos, options, callback) {
    ensureDaemon(function(err, dontRetry) {
        if (daemon && daemon.notInstalled)
            handler.getEmitter().emit("not_installed", { language: options.language });
        if (err) return callback(err);
        
        var start = Date.now();
        workerUtil.execAnalysis(
            "curl",
            {
                mode: "stdin",
                json: true,
                args: [
                    "-H", "Expect:", // don't wait for "100-Continue"
                    "-s", "--data-binary", "@-", // get input from stdin
                    "localhost:" + DAEMON_PORT + "?mode=" + command
                    + "&row=" + pos.row + "&column=" + pos.column
                    + "&language=" + LANGUAGES[options.language]
                    + "&path=" + encodeURIComponent(path.replace(/^\//, ""))
                    + "&dirs=" + (paths[options.language] || "").replace(/:/g, ",")
                    + (options.noDoc ? "&nodoc=1" : ""),
                ],
            },
            function onResult(err, stdout, stderr, meta) {
                if (err) {
                    if (err.code === ERROR_NO_SERVER && !dontRetry)
                        return callDaemon(command, path, doc, pos, options, callback);
                        
                    return callback(new Error("codeintel_server failed, not responding, or not installed yet"));
                }
                
                if (typeof stdout !== "object")
                    return callback(new Error("Couldn't parse codeintel output: " + stdout));
                
                console.log("[codeintel_worker] " + command + " in " + (Date.now() - start)
                    + "ms (ci: " + meta.serverTime + "ms): "
                    + doc.getLine(pos.row).substr(0, pos.column));

                callback(null, stdout, meta);
            }
        );
    });
}
function ensureDaemon(callback) {
    if (daemon)
        return done(daemon.err, true);

    daemon = {
        err: new Error("Still starting daemon, enhance your calm"),
        kill: function() {
            this.killed = true;
        },
        notInstalled: false,
    };
    
    workerUtil.spawn(
        "bash",
        {
            args: [
                "-c", launchCommand,
                "--", "$PYTHON -c '" + server + "' daemon --port " + DAEMON_PORT
            ],
        },
        function(err, child) {
            var output = "";
            if (err) {
                daemon.err = err;
                return workerUtil.showError("Could not start python completion daemon. Please reload to try again.");
            }
            daemon = child;
            daemon.err = null;
            
            if (daemon.killed)
                daemon.kill();
            var killTimer = setTimeout(daemon.kill.bind(daemon), 30 * 60 * 1000);
            
            child.stderr.on("data", function(data) {
                output += data;
                if (/!!Daemon listening/.test(data)) {
                    done();
                }
                else if (/^!!(Updating .*|Installing .*)/.test(data)) {
                    var message = RegExp.$1;
                    clearTimeout(lastInfoTimer);
                    lastInfoTimer = setTimeout(function() {
                        lastInfoPopup = workerUtil.showInfo(message, 5000);
                    }, 3000);
                }
                else if (/^!!Done(.*)/.test(data)) {
                    if (lastInfoPopup)
                        workerUtil.showInfo(RegExp.$1, 3000);
                    lastInfoPopup = null;
                }
                else if (/^!!Not installed/.test(data)) {
                    daemon.notInstalled = true;
                }
                else if (/^!!/.test(data)) {
                    workerUtil.showError(data);
                }
                else {
                    console.log("[codeintel_worker] " + data);
                }
            });
            child.on("exit", function(code) {
                clearInfoPopup();
                if (code === ERROR_PORT_IN_USE) // someone else running daemon?
                    return done(null, true);
                if (!code || /Daemon listening/.test(output)) // everything ok, try again later
                    daemon = null;
                clearTimeout(killTimer);
                done(code && new Error("[codeintel_worker] Daemon failed: " + output), true);
            });
        }
    );
    
    function clearInfoPopup() {
        clearTimeout(lastInfoTimer);
        lastInfoPopup && lastInfoPopup.hide();
    }
    
    function done(err, dontRetry) {
        callback && callback(err, dontRetry);
        callback = null;
        handler.sender.emit("codeintel_ready", { err: err && err.stack });
    }
}

});

define("plugins/c9.ide.language.codeintel/worker/ruby_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var codeintel = require("plugins/c9.ide.language.codeintel/worker/codeintel_worker");

var handler = module.exports = Object.create(baseHandler);
codeintel.addLanguage("ruby");

handler.handlesLanguage = function(language) {
    return language === "ruby";
};

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z0-9_\x7f-\xff]/);
};

handler.getCompletionRegex = function() {
    return /[\.]/;
};

handler.getCacheCompletionRegex = function() {
    return new RegExp(
        "(\\b(if|while|for|switch)\\s*\\("
        + "|\\b\\w+\\s+"
        + "|(===?|!==?|[-+]=|[-+*%>?!|&{[])"
        + "|\\s)+"
    );
};

});

define("plugins/c9.ide.language.codeintel/worker/css_less_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var codeintel = require("plugins/c9.ide.language.codeintel/worker/codeintel_worker");

var handler = module.exports = Object.create(baseHandler);
codeintel.addLanguage("css");
codeintel.addLanguage("less");

handler.handlesLanguage = function(language) {
    return language === "css" || language === "less";
};

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z0-9_\x7f-\xff\-]/);
};

handler.getCompletionRegex = function() {
    return /: $/;
};

handler.predictNextCompletion = function(doc, ast, pos, options, callback) {
    if (options.line[pos.column - 1] === ":")
        return callback({ predicted: " " });
    callback();
};

handler.getCacheCompletionRegex = function() {
    return new RegExp(
        "(\\b[\\.@\\w]+\\s+"
        + "|\\s)+"
    );
};

});

define("plugins/c9.ide.language.codeintel/worker/php_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var codeintel = require("plugins/c9.ide.language.codeintel/worker/codeintel_worker");

var handler = module.exports = Object.create(baseHandler);
codeintel.addLanguage("php");

handler.handlesLanguage = function(language) {
    return language === "php";
};

handler.$recacheCompletionLength = 3;

handler.getIdentifierRegex = function() {
    return (/[$$a-zA-Z0-9_\x7f-\xff]/);
};

handler.getCompletionRegex = function() {
    return (/(\$|->|::)$/);
};

handler.getCacheCompletionRegex = function() {
    return new RegExp(
        "(\\b(if|while|for|switch)\\s*\\("
        + "|\\b\\w+\\s+"
        + "|(===?|!==?|[-+]=|[-+*%>?!|&{[])"
        + "|\\s)+"
    );
};

handler.predictNextCompletion = function(doc, ast, pos, options, callback) {
    if (/\$[a-zA-Z0-9_\x7f-\xff]+-/.test(options.line.substr(0, pos.colomn)))
        return callback({ predicted: ">" });
    if (/\$[a-zA-Z0-9_\x7f-\xff]+:/.test(options.line.substr(0, pos.colomn)))
        return callback({ predicted: ":" });
    callback();
};

});

define("plugins/c9.ide.language.go/worker/go_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var workerUtil = require("plugins/c9.ide.language/worker_util");

var handler = module.exports = Object.create(baseHandler);
var daemon;
var enabled = true;

handler.handlesLanguage = function(language) {
    return language === "golang";
};

handler.init = function(callback) {
    var emitter = handler.getEmitter();
    emitter.on("set_go_config", function(e) {
        enabled = e.enabled;
    });
    callback();
};

handler.onDocumentOpen = function(path, doc, oldPath, callback) {
    ensureDaemon(callback);
};
handler.getCompletionRegex = function() {
    return (/^[\.]$/);
};
handler.getExpressionPrefixRegex = function() {
    return new RegExp(
        "(\\b(if|while|for|switch)\\s*\\("
        + "|\\b\\w+\\s+"
        + "|(==|!=|[-+]=|[-+*%<>?!|&{[])\\s*)+"
    );
};
handler.complete = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    ensureDaemon(function(err) {
        if (err) return callback(err);
        
        var start = Date.now();
        workerUtil.execAnalysis(
            "bash", // TODO: don't use bash here, better GOPATH handling
            {
                args: [
                    "-c",
                    "GOPATH=$HOME/.c9/gocode:$GOPATH ~/.c9/gocode/bin/gocode -f=json autocomplete " + getOffset(doc, pos)
                ],
                mode: "stdin",
                json: true,
            },
            function(err, response, responseErr, meta) {
                if (err) return callback(err);
                
                var results = response && response[1] && response[1].map(
                    function beautifyCompletion(r) {
                        r.isContextual = true;
                        r.guessTooltip = true;
                        if (/func\(/.test(r.type)) {
                            r.replaceText = r.name + "(^^)";
                            r.name += "()";
                            r.icon = "method";
                        }
                        else if (r.class === "package") {
                            r.icon = "package";
                        }
                        else {
                            r.icon = "property";
                        }
                        r.docHead = r.type;
                        r.priority = 4;
                        return r;
                    }
                );
                
                console.log("[go_completer] completed in " + (Date.now() - start)
                    + "ms (gocode: " + meta.serverTime + "ms): "
                    + doc.getLine(pos.row).substr(0, pos.column));
                callback(null, results);
            }
        );
    });
};

function getOffset(doc, pos) {
    var result = 0;
    var lines = doc.getAllLines();
    for (var i = 0; i < lines.length; i++) {
        if (i === pos.row)
            return result + pos.column;
        
        result += lines[i].length + 1;
    }
}

handler.predictNextCompletion = function(doc, fullAst, pos, options, callback) {
    if (!options.matches.length) {
        if (options.line[pos.column - 1] && /(?![{;})\]\s"'\+\-\*])./.test(options.line[pos.column - 1]))
            return callback(null, { predicted: "" });
    }
    var predicted = options.matches.filter(function(m) {
        return m.isContextual;
    });
    if (predicted.length !== 1 || predicted[0].icon === "method")
        return callback();
    console.log("[go_completer] Predicted our next completion will be for " + predicted[0].replaceText + ".");
    callback(null, {
        predicted: predicted[0].replaceText + ".",
        showEarly: predicted[0].class === "package"
    });
};
function ensureDaemon(callback) {
    if (daemon)
        return done(daemon.err);

    var loadingErr = new Error("Still starting daemon, enhance your calm");
    loadingErr.code = "ELOADING";
    daemon = {
        err: loadingErr,
        kill: function() {
            this.killed = true;
        }
    };
    
    workerUtil.spawn(
        "bash",
        {
            args: [
                "-c", "mkdir -p ~/.c9/gocode; GOPATH=$HOME/.c9/gocode go get -u github.com/nsf/gocode && ~/.c9/gocode/bin/gocode"
            ]
        },
        function(err, child) {
            if (err) return done(err);
            
            daemon = child;
            daemon.err = null;
            
            if (daemon.killed)
                daemon.kill();
            
            child.stderr.on("data", function(data) {
                console.log("[stderr]", data);
            });
            child.on("exit", function(code) {
                var tip = code === 127 ? " Please make sure go is on your PATH for bash." : "";
                done(code && "Error " + code + " starting daemon. " + tip);
            });
        }
    );
    
    function done(err) {
        if (err) {
            daemon.err = err;
            if (err.code !== "ELOADING")
                workerUtil.showError("Could not setup or start Go completion daemon. Please reload to try again.");
            return callback(err);
        }
        callback();
    }
}

});

define("plugins/c9.ide.language.python/worker/python_jsonalyzer",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*class\s+([^ \(:]+)/g, kind: "unknown2" },
    { regex: /(?:^|\n)\s*def\s+(?!_)([^ \(:]+)/g, kind: "method2", indent: 1 },
    { regex: /(?:^|\n)\s*def\s+(?!__[^ \(:]+__)(_[^ \(]*)/g, kind: "method2", indent: 1 },
    { regex: /(?:^|\n)\s*def\s+(__[^ \(:]+__)/g, kind: "property2", indent: 1 },
    {
        regex: new RegExp(
            "(?:^|\\n)\\s*import\\s+([^ \\(]+)"
        ),
        kind: "import"
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["py"];

handler.extensions = ["py"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    return callback(null, { properties: results });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};

});

define("plugins/c9.ide.language.python/worker/python_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var workerUtil = require("plugins/c9.ide.language/worker_util");

var KEYWORD_REGEX = new RegExp(
    "^(and|as|assert|break|class|continue|def|del|elif|else|except|exec|"
    + "finally|for|from|global|if|import|in|is|lambda|not|or|pass|print|"
    + "raise|return|try|while|with|yield)$"
);
var DAEMON_PORT = 10880;
var ERROR_PORT_IN_USE = 98;
var ERROR_NO_SERVER = 7;

var handler = module.exports = Object.create(baseHandler);
var pythonVersion = "python2";
var enabled;
var pythonPath = "";
var jediServer;
var launchCommand;
var showedJediError;
var daemon;

handler.handlesLanguage = function(language) {
    return language === "python";
};

handler.init = function(callback) {
    var emitter = handler.getEmitter();
    emitter.on("set_python_config", function(e) {
        pythonVersion = e.pythonVersion;
        pythonPath = e.pythonPath;
        enabled = e.completion;
        if (daemon) {
            daemon.kill();
            daemon = null;
        }
    });
    emitter.on("set_python_scripts", function(e) {
        jediServer = e.jediServer;
        launchCommand = e.launchCommand;
    });
    callback();
};

handler.getIdentifierRegex = function() {
    return /\w/;
};

handler.getCompletionRegex = function() {
    return (/(\.|\b(import|from|if|while|from|raise|return) |% )$/); 
};

handler.getCacheCompletionRegex = function() {
    return / ?(\b\w+\s+|\b(if|while|for|print)\s*\(|([{[\-+*%<>!|&/,%]|==|!=)\s*)*/;
};

handler.onDocumentOpen = function(path, doc, oldPath, callback) {
    if (!enabled) return callback();
    ensureDaemon(callback);
};
handler.complete = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    callDaemon("completions", handler.path, doc, pos, options, function(err, results, meta) {
        if (err) return callback(err);
        
        results && results.forEach(function beautifyCompletion(r) {
            r.isContextual = true;
            r.guessTooltip = true;
            r.replaceText = r.replaceText || r.name;
            r.priority = r.name[0] === "_" || r.replaceText === r.replaceText.toUpperCase() ? 3 : 4;
            r.icon = r.icon || "property";
            r.icon = r.name[0] === "_" ? r.icon.replace(/2?$/, "2") : r.icon;
            r.noDoc = options.noDoc;
            if (!r.doc)
                return;
            if (r.replaceText === "print(^^)" && pythonVersion === "python2" && !/\.[^ ]*$/.test(options.line.substr(pos.column)))
                r.replaceText = "print";
            var docLines = r.doc.split(/\r\n|\n|\r/);
            var docBody = docLines.slice(2).join("\n");
            r.docHeadHtml = workerUtil.filterDocumentation(docLines[0]).replace(/^([A-Za-z0-9$_]+\()self, /, "$1");
            r.doc = workerUtil.filterDocumentation(docBody.replace(/``/g, "'"));
        });
        callback(null, results);
    });
};
handler.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    callDaemon("goto_definitions", handler.path, doc, pos, options, callback);
};
handler.predictNextCompletion = function(doc, fullAst, pos, options, callback) {
    var line = options.line;
    if (!options.matches.length) {
        if (line[pos.column - 1] && /(?![:)}\]\s"'\+\-\*])./.test(line[pos.column - 1]))
            return callback(null, { predicted: "" });
    }
    var predicted = options.matches.filter(function(m) {
        return m.isContextual
            && !m.replaceText.match(KEYWORD_REGEX);
    });
    if (predicted.length > 0 && "import".substr(0, line.length) === line)
        return callback(null, { predicted: "import " });
    if (predicted.length !== 1 || predicted[0].icon === "method")
        return callback();
    if (/^\s+import /.test(line))
        return callback();
    console.log("[python_completer] Predicted our next completion will be for " + predicted[0].replaceText + ".");
    callback(null, {
        predicted: predicted[0].replaceText + ".",
        showEarly: predicted[0].replaceText === "self" || predicted[0].icon === "package"
    });
};
function callDaemon(command, path, doc, pos, options, callback) {
    ensureDaemon(function(err, dontRetry) {
        if (err) return callback(err);
        
        var start = Date.now();
        workerUtil.execAnalysis(
            "curl",
            {
                mode: "stdin",
                json: true,
                args: [
                    "-s", "--data-binary", "@-", // get input from stdin
                    "-H", "Expect:", // don't wait for "100-Continue"
                    "localhost:" + DAEMON_PORT + "?mode=" + command
                    + "&row=" + (pos.row + 1) + "&column=" + pos.column
                    + "&path=" + encodeURIComponent(path.replace(/^\//, ""))
                    + (options.noDoc ? "&nodoc=1" : ""),
                ],
            },
            function onResult(err, stdout, stderr, meta) {
                if (err) {
                    if (err.code === ERROR_NO_SERVER && !dontRetry)
                        return callDaemon(command, path, doc, pos, options, callback);
                    return callback(new Error("jedi_server failed or not responding"));
                }
                
                if (typeof stdout !== "object")
                    return callback(new Error("Couldn't parse python-jedi output: " + stdout));
                
                console.log("[python_completer] " + command + " in " + (Date.now() - start)
                    + "ms (jedi: " + meta.serverTime + "ms): "
                    + doc.getLine(pos.row).substr(0, pos.column));

                callback(null, stdout, meta);
            }
        );
    });
}
function ensureDaemon(callback) {
    if (daemon)
        return done(daemon.err, true);

    daemon = {
        err: new Error("Still starting daemon, enhance your calm"),
        kill: function() {
            this.killed = true;
        }
    };
    
    workerUtil.spawn(
        "bash",
        {
            args: [
                "-c", launchCommand, "--", pythonVersion,
                "$PYTHON -c '" + jediServer + "' daemon --port " + DAEMON_PORT
            ],
            env: { PYTHONPATH: pythonPath },
        },
        function(err, child) {
            var output = "";
            if (err) {
                daemon.err = err;
                return workerUtil.showError("Could not start python completion daemon. Please reload to try again.");
            }
            daemon = child;
            daemon.err = null;
            
            if (daemon.killed)
                daemon.kill();
            var killTimer = setTimeout(daemon.kill.bind(daemon), 30 * 60 * 1000);
            
            child.stderr.on("data", function(data) {
                output += data;
                if (/Daemon listening/.test(data))
                    done();
            });
            child.on("exit", function(code) {
                if (code === ERROR_PORT_IN_USE) // someone else running daemon?
                    return done(null, true);
                if (!code || /Daemon listening/.test(output)) // everything ok, try again later
                    daemon = null;
                clearTimeout(killTimer);
                done(code && new Error("[python_completer] Daemon failed: " + output), true);
            });
        }
    );
    
    function done(err, dontRetry) {
        if (err && /No module named jedi/.test(err.message) && !showedJediError) {
            workerUtil.showError("Jedi not found. Please run 'pip install jedi' or 'sudo pip install jedi' to enable Python code completion.");
            showedJediError = true;
        }
        callback && callback(err, dontRetry);
        handler.sender.emit("python_completer_ready");
        callback = null;
    }
}

});

define("plugins/c9.ide.language.python/worker/python_linter",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var workerUtil = require("plugins/c9.ide.language/worker_util");

var handler = module.exports = Object.create(baseHandler);
var pythonVersion = "python2";
var pythonPath = "";
var pylintFlags = "";
var launchCommand;
var hosted;
var PYLINT_DEFAULTS = [
    "-d", "all",
    "-e", "E", 
    "-e", "F", 
    "-e", "W0101", // Unreachable code
    "-e", "W0109", // Duplicate key in dictionary
    "-e", "W0199", // Assert called on a 2-tuple. Did you mean \'assert x,y\'?
    "-e", "W0612", // Unused variable
    "-e", "W0602", // Used global without assignment
];
var PYLINT_CONFIG = [
    "-r", "n", 
    "--msg-template={line}:{column}:\\ [{msg_id}]\\ {msg}",
    "--load-plugins", "pylint_flask,pylint_django",
];

handler.handlesLanguage = function(language) {
    return language === "python";
};

handler.init = function(callback) {
    var emitter = handler.getEmitter();
    emitter.on("set_python_config", function(e) {
        pythonVersion = e.pythonVersion;
        pythonPath = e.pythonPath;
        pylintFlags = e.pylintFlags;
    });
    emitter.on("set_python_scripts", function(e) {
        launchCommand = e.launchCommand;
        hosted = e.hosted;
    });
    callback();
};

handler.analyze = function(docValue, fullAst, options, callback) {
    var commands = hosted
        ? ["-c", pythonVersion === "python2" ? "pylint2" : "pylint3"]
        : ["-c", launchCommand, "--", pythonVersion, "$ENV/bin/pylint"];
    commands[commands.length - 1] += " " + (pylintFlags || PYLINT_DEFAULTS.join(" "))
        + " " + PYLINT_CONFIG.join(" ")
        + " '$FILE'";
    if (!launchCommand)
        return callback(new Error("Warning: python_linter not initialized yet"));

    var hasStarImports = /from\s+[^\s]+\s+import\s+\*/.test(docValue);
    var markers = [];
    workerUtil.execAnalysis(
        "bash",
        {
            mode: "local-tempfile",
            args: commands,
            maxCallInterval: 800,
            env: {
                PYTHONPATH: pythonPath,
                PYLINTHOME: "/tmp/.pylint.d",
            }
        },
        function(err, stdout, stderr) {
            if (err && !stdout) return callback(err);

            stdout.split("\n").forEach(function(line) {
                var marker = parseLine(line, hasStarImports);
                marker && markers.push(marker);
            });
            
            callback(null, markers);
        }
    );
};

function parseLine(line, hasStarImports) {
    var match = line.match(/(\d+):(\d+): \[([^\]]+)\] (.*)/);
    if (!match)
        return;
    var row = match[1];
    var column = match[2];
    var code = match[3];
    var message = match[4];
    var level = getLevel(code);
    
    if (/print statement used/.test(message))
        return;
    if (hasStarImports && /undefined variable/i.test(message)) {
        level = "info";
        message += "?";
    }
    if (/E0632/.test(code))
        level = "info";
    if (/E1128|E0633/.test(code))
        level = "warning";
    if (/E0401/.test(code))
        return;
    if (/Django is not available on/.test(message))
        return;
        
    return {
        pos: {
            sl: parseInt(row, 10) - 1,
            sc: parseInt(column, 10)
        },
        message: message,
        code: code,
        level: level
    };
}

function getLevel(code) {
    if (code[0] === "E" || code[0] === "F")
        return "error";
    if (code === "W0612") // unused variable
        return "info";
    if (code === "W0602") // global without assignment
        return "info";
    return "warning";
}

});

define("plugins/c9.ide.language.javascript.infer/infer_jumptodef",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var handler = module.exports = Object.create(baseLanguageHandler);
var infer = require("./infer");
var path = require("./path");
var astUpdater = require("./ast_updater");

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    if (!fullAst || !options.node)
        return callback();
    
    var results = [];
    var basePath = path.getBasePath(handler.path, handler.workspaceDir);
    var filePath = path.canonicalizePath(handler.path, basePath);
    
    astUpdater.updateOrReanalyze(doc, fullAst, filePath, basePath, pos, function(fullAst, currentNode) {
        if (!currentNode)
            return callback();
        
        currentNode.rewrite(
            'PropAccess(o, p)', function(b, node) {
                var values = infer.inferValues(b.o);
                values.forEach(function(v) {
                    jumpToProperty(v, b.p.value, results);
                });
            },
            'Var(v)', function(b, node) {
                jumpToVar(node, results);
            },
            'Call(Var("require"), [String(_)])', function(b, node) {
                jumpToRequire(node, results);
            },
            'Var("require")', function(b, node) {
                if (node.parent &&
                    node.parent.isMatch('Call(Var("require"), [_])'))
                jumpToRequire(node.parent, results);
            },
            'String(_)', function(b, node) {
                if (node.parent && node.parent.parent &&
                    node.parent.parent.isMatch('Call(Var("require"), [_])'))
                jumpToRequire(node.parent.parent, results);
            }
        );
    });
        
    callback(results);
};

var jumpToRequire = function(node, results) {
    var values = infer.inferValues(node);
    values.forEach(function(v) {
        if (v.path)
            results.push({
                path: v.path,
                row: v.row,
                icon: "package"
            });
    });
};

var jumpToProperty = module.exports.jumpToProperty = function(value, property, results) {
    var prop = value.properties && value.properties["_" + property];
    if (prop && prop[0])
        prop = prop[0];
    if (!prop || (!value.path && !prop.path && !prop.row))
        return;
    results.push({
        row: prop.row,
        column: prop.column,
        path: prop.path || value.path,
        icon: "property"
    });
};

var jumpToVar = function(node, results) {
    var values = infer.inferValues(node);
    values.forEach(function(v) {
        if (!v.path && !v.row)
            return;
        results.push({
            row: v.row,
            path: v.path,
            icon: "property"
        });
    });
};

});

define("plugins/c9.ide.language.javascript.immediate/immediate_complete_static",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);

var scopeAnalyzer = require("plugins/c9.ide.language.javascript/scope_analyzer");
var inferCompleter = require("plugins/c9.ide.language.javascript.infer/infer_completer");
    
handler.handlesLanguage = function(language) {
    return language === "javascript";
};

handler.handlesEditor = function() {
    return this.HANDLES_IMMEDIATE;
};

handler.complete = function(doc, fullAst, pos, options, callback) {
    return scopeAnalyzer.complete(doc, fullAst, pos, options, function(results) {
        var allResults = results || [];
        inferCompleter.complete(doc, fullAst, pos, options, function(results) {
            callback(allResults.concat(results || []));
        });
    });
};

});

define("plugins/c9.ide.language.javascript.immediate/immediate_complete",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);
    
handler.handlesLanguage = function(language) {
    return language === "javascript";
};

handler.handlesEditor = function() {
    return this.HANDLES_IMMEDIATE;
};

var requestId = 0;
handler.complete = function(doc, fullAst, pos, options, callback) {
    var currentNode = options.node;
    if (!currentNode || !currentNode.getPos())
        return callback();
    
    if (!isSafe(currentNode))
        return callback();
    
    var expr = getExpression(doc, currentNode.getPos());
    var myRequestId = ++requestId;
    
    this.sender.once("js_immediate_complete_results", function(e) {
        if (myRequestId !== e.data.id)
            return;
        callback(e.data.results);
    });
    this.sender.emit(
        "js_immediate_complete",
        {
            immediateWindow: this.immediateWindow,
            expr: expr,
            id: myRequestId
        }
    );
};

function isSafe(node) {
    var badNodes = node.collectTopDown(
        "Call(x, _)", function(b) {
            return !b.x.rewrite('Var("require")');
        }
    );
    return !badNodes.length && ["Call", "PropAccess", "Var"].indexOf(node.cons) > -1;
}

function getExpression(doc, pos) {
    if (pos.sl === pos.el) {
        return doc.getLine(pos.sl).substring(pos.sc, pos.ec);
    }
    var result = doc.getLine(pos.sl).substr(pos.sc);
    for (var i = pos.sl + 1; i < pos.el; i++) {
        result += doc.getLine(i);
    }
    result += doc.getLine(pos.el).substr(0, pos.ec);
    return result;
}


});

define("plugins/c9.ide.language.javascript/jumptodef",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var handler = module.exports = Object.create(baseLanguageHandler);
var scopes = require("plugins/c9.ide.language.javascript/scope_analyzer");

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.jumpToDefinition = function(doc, ast, pos, options, callback) {
    if (!ast || !options.node)
        return callback();
    scopes.analyze(doc.getValue(), ast, function() {
        scopes.getRenamePositions(doc, ast, pos, options, function (data) {
            if (!data || !data.declarations || data.declarations.length === 0) {
                return callback(null);
            }
            
            callback(data.declarations);
        });
    }, true);
};

});

define("plugins/c9.ide.language.javascript/outline",[], function(require, exports, module) {

require("treehugger/traverse"); // add traversal functions to trees

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var outlineHandler = module.exports = Object.create(baseLanguageHandler);

var ID_REGEX = /[a-zA-Z_0-9\$\_]/;
var EVENT_REGEX = /[a-zA-Z_0-9\$\_\ \(\)\[\]\/@]/;

var NOT_EVENT_HANDLERS = {
    addMarker: true,
    traverseUp: true,
    traverse: true,
    topdown: true,
    traverseTopDown: true,
    rewrite: true,
    traverseAll: true
};

outlineHandler.handlesLanguage = function(language) {
    return language === "javascript";
};
    
outlineHandler.outline = function(doc, ast, callback) {
    if (!ast)
        return callback();
    callback({ items: outlineSync(doc, ast) });
};
    
function fargsToString(fargs) {
    var str = '(';
    for (var i = 0; i < fargs.length; i++) {
        str += fargs[i][0].value + ', ';
    }
    if (fargs.length > 0)
        str = str.substring(0, str.length - 2);
    str += ')';
    return str;
}

function expressionToName(node) {
    var name;
    node.rewrite(
        'Var(x)', function(b) { name = b.x.value; },
        'PropAccess(e, x)', function(b) { name = (b.e.cons === "Var" ? b.e[0].value + "." : "") + b.x.value; },
        'Index(e, x)', function(b) {
            var parent = (b.e[1] || b.e[0]).value || "";
            if (b.x[0])
                name = parent + "[" + b.x[0].value + "]";
        }
    );
    return name;
}
var outlineSync = outlineHandler.outlineSync = function(doc, node, includeProps) {
    var results = [];
    node.traverseTopDown(
        'Assign(e, Function(name, fargs, body))', function(b) {
            var name = expressionToName(b.e);
            if (!name) return false;
            results.push({
                icon: 'method',
                name: name + fargsToString(b.fargs),
                pos: this[1].getPos(),
                displayPos: (b.e[1] || b.e[0] || b.e).getPos(),
                items: outlineSync(doc, b.body, includeProps)
            });
            return this;
        },
        'VarDeclInit(x, Function(name, fargs, body))', 'ConstDeclInit(x, Function(name, fargs, body))',
        function(b) {
            results.push({
                icon: 'method',
                name: b.x.value + fargsToString(b.fargs),
                pos: this[1].getPos(),
                displayPos: b.x.getPos(),
                items: outlineSync(doc, b.body, includeProps)
            });
            return this;
        },
        'PropertyInit(x, Function(name, fargs, body))', 'Method(x, Function(name, fargs, body))', function(b) {
            results.push({
                icon: 'method',
                name: b.x.value + fargsToString(b.fargs),
                pos: this[1].getPos(),
                displayPos: b.x.getPos(),
                items: outlineSync(doc, b.body, includeProps)
            });
            return this;
        },
        'VarDeclInit(x, e)', 'ConstDeclInit(x, e)', function(b) {
            var items = outlineSync(doc, b.e, includeProps);
            if (items.length === 0)
                return this;
            results.push({
                icon: 'property',
                name: b.x.value,
                pos: this[1].getPos(),
                displayPos: b.x.getPos(),
                items: items
            });
            return this;
        },
        'PropertyInit(x, e)', function(b) {
            var items = outlineSync(doc, b.e, includeProps);
            if (items.length === 0 && !includeProps)
                return this;
            results.push({
                icon: 'property',
                name: b.x.value,
                pos: items.length ? this[1].getPos() : this.getPos(),
                displayPos: b.x.getPos(),
                items: items
            });
            return this;
        },
        'Assign(x, e)', function(b) {
            var name = expressionToName(b.x);
            if (!name)
                return false;
            var items = outlineSync(doc, b.e, includeProps);
            if (items.length === 0)
                return this;
            results.push({
                icon: 'property',
                name: name,
                pos: this[1].getPos(),
                displayPos: (b.x[1] || b.x[0] || b.x).getPos(),
                items: items
            });
            return this;
        },
        'Call(e, args)', function(b) {
            var eventHandler = tryExtractEventHandler(this);
            if (!eventHandler)
                return false;
            var object = b.e.rewrite("PropAccess(Var(x), _)", function(b) { return b.x.value; });
            results.push({
                icon: 'event',
                name: (object ? object + "." : "") + eventHandler.s[0].value,
                pos: this.getPos(),
                displayPos: eventHandler.s.getPos(),
                items: eventHandler.body && outlineSync(doc, eventHandler.body, includeProps)
            });
            return this;
        },
        'Class(x, y, body)', function(b) {
            results.push({
                icon: 'event',
                name: b.x.value + (b.y.value ? " extends " + b.y.value : ""),
                pos: this.getPos(),
                displayPos: b.x.getPos(),
                items: b.body && outlineSync(doc, b.body, includeProps)
            });
            return this;
        },
        'Function(name, fargs, body)', function(b) {
            if (!b.name.value)
                return false;
            results.push({
                icon: 'method',
                name: b.name.value + fargsToString(b.fargs),
                pos: this.getPos(),
                displayPos: b.name.getPos(),
                items: outlineSync(doc, b.body, includeProps)
            });
            return this;
        }
    );
    return results;
};

var tryExtractEventHandler = outlineHandler.tryExtractEventHandler = function(node, ignoreBind) {
    var result;
    node.rewrite('Call(e, args)', function(b) {
        var name = expressionToName(b.e);
        if (!name || b.args.length < 2 || NOT_EVENT_HANDLERS[name])
            return false;
        var s;
        var fun;
        if (b.args[0] && b.args[0].cons === 'String' && isCallbackArg(b.args[1], ignoreBind)) {
            s = b.args[0];
            fun = b.args[1];
        }
        else if (b.args[1] && b.args[1].cons === 'String' && isCallbackArg(b.args[2], ignoreBind)) {
            s = b.args[1];
            fun = b.args[2];
        }
        else {
            return false;
        }
        if (!s[0].value.match(EVENT_REGEX))
            return false;
        if (b.args.length >= 4 && b.args[2].cons === 'String' && b.args[3].cons === 'Function')
            return false;
        result = {
            s: s,
            fargs: fun[1],
            body: fun[2]
        };
    });
    return result;
};

var isCallbackArg = function(node, ignoreBind) {
    if (!node)
        return false;
    var result;
    node.rewrite(
        'Function(_, _, _)', function() { result = true; },
        'Call(PropAccess(_, "bind"), [_])', function() { result = !ignoreBind; }
    );
    return result;
};

});

define("plugins/c9.ide.language.javascript/debugger",[], function(require, exports, module) {

    var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
    
    var expressionBuilder = module.exports = Object.create(baseLanguageHandler);
    
    expressionBuilder.handlesLanguage = function(language) {
        return language === "javascript" || language === "jsx";
    };
    expressionBuilder.getInspectExpression = function(doc, fullAst, pos, options, callback) {
        if (!options.node) return callback();
        
        callback(getExpression(options.node));
    };
    var getExpression = function(node) {
        if (node.value)
            return { value: node.value, pos: node.getPos() };
        
        var result;
        node.rewrite(
            'VarDeclInit(x, _)', 'ConstDeclInit(x, _)', function(b) {
                node = b.x;
                result = b.x.value;
            },
            'VarDecl(x)', 'ConstDecl(x)', function(b) {
                node = b.x;
                result = b.x.value;
            },
            'PropAccess(e, x)', function(b) {
                result = getExpression(b.e) + "." + b.x.value;
            },
            'Var(x)', function(b) {
                result = b.x.value;
            },
            'Num(n)', function(b) {
                result = b.n.value;
            },
            'Index(e, idx)', function(b) {
                result = getExpression(b.e) + "[" + getExpression(b.idx) + "]";
            },
            'New(e, args)', function(b) {
                var method = getExpression(b.e);
                var args = b.args.toArray().map(getExpression).join(", ");
                result = "new " + method + "(" + args + ")";
            },
            'FArg(x)', function(b) {
                result = b.x.value;
            },
            'Op(op, e1, e2)', function(b) {
                result = getExpression(b.e1) + " " + b.op.value + " " + getExpression(b.e2);
            },
            function() {
                if (!result)
                    result = "";
            }
        );
        
        if (result === "")
            return;
        
        return { value: result, pos: node.getPos() };
    };

});

define("plugins/c9.ide.language.javascript/parse",[], function(require, exports, module) {

var parser = require("treehugger/js/parse");
var traverse = require("treehugger/traverse");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.handlesEditor = function() {
    return this.HANDLES_ANY;
};

handler.parse = function(code, callback) {
    var result;
    try {
        code = code.replace(/^(#!.*\n)/, "//$1");
        result = parser.parse(code);
        traverse.addParentPointers(result);
    } catch (e) {
        result = null;
    }
    
    callback(result);
};

handler.getMaxFileSizeSupported = function() {
    return .25 * 10 * 1000 * 80;
};

handler.findNode = function(ast, pos, callback) {
    var treePos = { line: pos.row, col: pos.column };
    callback(ast.findNode(treePos));
};

handler.getPos = function(node, callback) {
    callback(node.getPos());
};

handler.getMaxFileSizeSupported = function() {
    return 1000 * 1000;
};

});

define("plugins/c9.ide.language.generic/simple/shell",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);
    
handler.handlesLanguage = function(language) {
    return language === "sh";
};

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z_0-9\.\-\~]/);
};

handler.getCompletionRegex = function() {
    return (/\$/);
};


});

define("plugins/c9.ide.language.generic/simple/make",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);
    
handler.handlesLanguage = function(language) {
    return language === "makefile";
};

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z_0-9\/\.\-\~]/);
};


});

define("plugins/c9.ide.language.generic/mode_completer",[], function(require, exports, module) {

var completeUtil = require("plugins/c9.ide.language/complete_util");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var completer = module.exports = Object.create(baseLanguageHandler);

var modeCache = {}; // extension -> static data
var iconLanglist = ["php", "css"];

completer.handlesLanguage = function(language) {
    return ["css"/*, "php"*/].indexOf(language) !== -1;
};

completer.getMaxFileSizeSupported = function() {
    return Infinity;
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    var language = this.language;
    var line = doc.getLine(pos.row);
    var idRegex = workerUtil.getIdentifierRegex(pos);
    var identifier = options.identifierPrefix;
    if (line[pos.column - 1] === ".")
        return callback([]);

    var mode = modeCache[language];

    if (mode === undefined) {
        var text;
        if (language)
            text = completeUtil.fetchTextSync('plugins/c9.ide.language.generic/modes/' + this.language + '.json');
        try {
            mode = text ? JSON.parse(text) : {};
        } catch (e) {
            console.error(e);
            mode = {};
        }
        modeCache[language] = mode;
    }

    function getIcon(type) {
        if (iconLanglist.indexOf(language) === -1)
            return null;
        var iconMap = {
            "variable": "property",
            "type": "property2",
            "constant": "method2",
            "color": "method2",
            "font": "method2",
            "function": "method2",
            "pseudo.element": "event",
            "pseudo.class": "event"
        };
        var subs = Object.keys(iconMap);
        for (var i = 0; i < subs.length; i++)
            if (type.indexOf(subs[i]) !== -1)
                return iconMap[subs[i]];
        return null;
    }
    var types = Object.keys(mode);
    var matches = [];
    types.forEach(function (type) {
        var icon = getIcon(type);
        var nameAppend = "", replaceAppend = "";
        if (type.indexOf("function") !== -1) {
            nameAppend = "()";
            replaceAppend = "(^^)";
        }
        var deprecated = type.indexOf("deprecated") === -1 ? 0 : 1;
        var compls = completeUtil.findCompletions(identifier, mode[type]);
        matches.push.apply(matches, compls.map(function(m) {
            return {
                name: m + nameAppend,
                replaceText: m + replaceAppend,
                doc: deprecated ? ("Deprecated: <del>" + m + nameAppend + "</del>") : null,
                icon: icon,
                meta: type,
                identifierRegex: idRegex,
                priority: 2 - deprecated
            };
        }));
    });
    
    callback(matches);
};


});

define("plugins/c9.ide.language.generic/snippet_completer",[], function(require, exports, module) {

var completeUtil = require("plugins/c9.ide.language/complete_util");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var completer = module.exports = Object.create(baseLanguageHandler);

var snippetCache = {}; // extension -> snippets
    
completer.handlesLanguage = function(language) {
    language = language && language.slice(language.lastIndexOf("/") + 1);
    return snippetCache[language] || snippetCache._;
};

completer.getMaxFileSizeSupported = function() {
    return Infinity;
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    var line = doc.getLine(pos.row);
    var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, completer.$getIdentifierRegex());
    if (line[pos.column - identifier.length - 1] === '.') // No snippet completion after "."
        return callback([]);
    
    var language = this.language && this.language.slice(this.language.lastIndexOf("/") + 1);
    var snippets = snippetCache[language];
    
    var allIdentifiers = Object.keys(snippets || {});
    
    var matches = completeUtil.findCompletions(identifier, allIdentifiers);
    callback(matches.map(function(m) {
        var snippet = snippets[m];
        return {
            name: snippet.name,
            snippet: snippet.content,
            replaceText: snippet.name,
            doc: "<pre>" + snippet.content + "</pre>",
            icon: "package",
            meta: "snippet",
            isGeneric: true,
            priority: 0 // todo change this back to 2 once snippets are cleaned up
        };
    }));
};

completer.init = function(callback) {
    this.sender.on("loadSnippets", function(e) {
        snippetCache[e.data.language] = e.data.snippets;
    });
    callback();
};

});
