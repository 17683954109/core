"no use strict";
!(function(window) {
if (typeof window.window != "undefined" && window.document)
    return;
if (window.require && window.define)
    return;

if (!window.console) {
    window.console = function() {
        var msgs = Array.prototype.slice.call(arguments, 0);
        postMessage({type: "log", data: msgs});
    };
    window.console.error =
    window.console.warn = 
    window.console.log =
    window.console.trace = window.console;
}
window.window = window;
window.ace = window;

window.onerror = function(message, file, line, col, err) {
    postMessage({type: "error", data: {
        message: message,
        data: err.data,
        file: file,
        line: line, 
        col: col,
        stack: err.stack
    }});
};

window.normalizeModule = function(parentId, moduleName) {
    if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return window.normalizeModule(parentId, chunks[0]) + "!" + window.normalizeModule(parentId, chunks[1]);
    }
    if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        moduleName = (base ? base + "/" : "") + moduleName;
        
        while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/^\.\//, "").replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
    }
    
    return moduleName;
};

window.require = function require(parentId, id) {
    if (!id) {
        id = parentId;
        parentId = null;
    }
    if (!id.charAt)
        throw new Error("worker.js require() accepts only (parentId, id) as arguments");

    id = window.normalizeModule(parentId, id);

    var module = window.require.modules[id];
    if (module) {
        if (!module.initialized) {
            module.initialized = true;
            module.exports = module.factory().exports;
        }
        return module.exports;
    }
   
    if (!window.require.tlns)
        return console.log("unable to load " + id);
    
    var path = resolveModuleId(id, window.require.tlns);
    if (path.slice(-3) != ".js") path += ".js";
    
    window.require.id = id;
    window.require.modules[id] = {}; // prevent infinite loop on broken modules
    importScripts(path);
    return window.require(parentId, id);
};
function resolveModuleId(id, paths) {
    var testPath = id, tail = "";
    while (testPath) {
        var alias = paths[testPath];
        if (typeof alias == "string") {
            return alias + tail;
        } else if (alias) {
            return  alias.location.replace(/\/*$/, "/") + (tail || alias.main || alias.name);
        } else if (alias === false) {
            return "";
        }
        var i = testPath.lastIndexOf("/");
        if (i === -1) break;
        tail = testPath.substr(i) + tail;
        testPath = testPath.slice(0, i);
    }
    return id;
}
window.require.modules = {};
window.require.tlns = {};

window.define = function(id, deps, factory) {
    if (arguments.length == 2) {
        factory = deps;
        if (typeof id != "string") {
            deps = id;
            id = window.require.id;
        }
    } else if (arguments.length == 1) {
        factory = id;
        deps = [];
        id = window.require.id;
    }
    
    if (typeof factory != "function") {
        window.require.modules[id] = {
            exports: factory,
            initialized: true
        };
        return;
    }

    if (!deps.length)
        deps = ["require", "exports", "module"];

    var req = function(childId) {
        return window.require(id, childId);
    };

    window.require.modules[id] = {
        exports: {},
        factory: function() {
            var module = this;
            var returnExports = factory.apply(this, deps.map(function(dep) {
                switch (dep) {
                    case "require": return req;
                    case "exports": return module.exports;
                    case "module":  return module;
                    default:        return req(dep);
                }
            }));
            if (returnExports)
                module.exports = returnExports;
            return module;
        }
    };
};
window.define.amd = {};
require.tlns = {};
window.initBaseUrls  = function initBaseUrls(topLevelNamespaces) {
    for (var i in topLevelNamespaces)
        require.tlns[i] = topLevelNamespaces[i];
};

window.initSender = function initSender() {

    var EventEmitter = window.require("ace/lib/event_emitter").EventEmitter;
    var oop = window.require("ace/lib/oop");
    
    var Sender = function() {};
    
    (function() {
        
        oop.implement(this, EventEmitter);
                
        this.callback = function(data, callbackId) {
            postMessage({
                type: "call",
                id: callbackId,
                data: data
            });
        };
    
        this.emit = function(name, data) {
            postMessage({
                type: "event",
                name: name,
                data: data
            });
        };
        
    }).call(Sender.prototype);
    
    return new Sender();
};

var main = window.main = null;
var sender = window.sender = null;

window.onmessage = function(e) {
    var msg = e.data;
    if (msg.event && sender) {
        sender._signal(msg.event, msg.data);
    }
    else if (msg.command) {
        if (main && main[msg.command])
            main[msg.command].apply(main, msg.args);
        else if (window[msg.command])
            window[msg.command].apply(window, msg.args);
        else
            throw new Error("Unknown command:" + msg.command);
    }
    else if (msg.init) {
        window.initBaseUrls(msg.tlns);
        require("ace/lib/es6-shim");
        sender = window.sender = window.initSender();
        var clazz = require(msg.module)[msg.classname];
        main = window.main = new clazz(sender);
    }
};
})(this);

define("require",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;

var requirejs, require, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.1.4',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        ap = Array.prototype,
        apsp = ap.splice,
        isBrowser = !!(typeof window !== 'undefined' && navigator && document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value !== 'string') {
                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }
    if (typeof require !== 'undefined' && !isFunction(require)) {
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                pkgs: {},
                shim: {},
                map: {},
                config: {}
            },
            registry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            requireCounter = 1,
            unnormalizedCounter = 1;
        function trimDots(ary) {
            var i, part;
            for (i = 0; ary[i]; i += 1) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }
        function normalize(name, baseName, applyMap) {
            var pkgName, pkgConfig, mapValue, nameParts, i, j, nameSegment,
                foundMap, foundI, foundStarMap, starI,
                baseParts = baseName && baseName.split('/'),
                normalizedBaseParts = baseParts,
                map = config.map,
                starMap = map && map['*'];
            if (name && name.charAt(0) === '.') {
                if (baseName) {
                    if (getOwn(config.pkgs, baseName)) {
                        normalizedBaseParts = baseParts = [baseName];
                    } else {
                        normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    }

                    name = normalizedBaseParts.concat(name.split('/'));
                    trimDots(name);
                    pkgConfig = getOwn(config.pkgs, (pkgName = name[0]));
                    name = name.join('/');
                    if (pkgConfig && name === pkgName + '/' + pkgConfig.main) {
                        name = pkgName;
                    }
                } else if (name.indexOf('./') === 0) {
                    name = name.substring(2);
                }
            }
            if (applyMap && (baseParts || starMap) && map) {
                nameParts = name.split('/');

                for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    foundMap = mapValue;
                                    foundI = i;
                                    break;
                                }
                            }
                        }
                    }

                    if (foundMap) {
                        break;
                    }
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            return name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                removeScript(id);
                pathConfig.shift();
                context.require.undef(id);
                context.require([id]);
                return true;
            }
        }
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        normalizedName = normalize(name, parentName, applyMap);
                    }
                } else {
                    normalizedName = normalize(name, parentName, applyMap);
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                getModule(depMap).on(name, fn);
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }
        function takeGlobalQueue() {
            if (globalDefQueue.length) {
                apsp.apply(defQueue,
                           [defQueue.length - 1, 0].concat(globalDefQueue));
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return mod.exports;
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return (config.config && getOwn(config.config, mod.map.id)) || {};
                        },
                        exports: defined[mod.map.id]
                    });
                }
            }
        };

        function cleanRegistry(id) {
            delete registry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var map, modId, err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;
            eachProp(registry, function (mod) {
                map = mod.map;
                modId = map.id;
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }
            if ((!expired || usingPathFallback) && stillLoading) {
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    this.on('error', errback);
                } else if (this.events.error) {
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;
                this.inited = true;

                this.ignore = options.ignore;
                if (options.enabled || this.enabled) {
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    this.fetch();
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            if (this.events.error) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            if (this.map.isDefine) {
                                cjsModule = this.module;
                                if (cjsModule &&
                                        cjsModule.exports !== undefined &&
                                        cjsModule.exports !== this.exports) {
                                    exports = cjsModule.exports;
                                } else if (exports === undefined && this.usingExports) {
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = [this.map.id];
                                err.requireType = 'define';
                                return onError((this.error = err));
                            }

                        } else {
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }
                        delete registry[id];

                        this.defined = true;
                    }
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    pluginMap = makeModuleMap(map.prefix);
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });
                    if (this.map.unnormalized) {
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });
                    load.fromText = bind(this, function (text, textAlt) {
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;
                        if (textAlt) {
                            text = textAlt;
                        }
                        if (hasInteractive) {
                            useInteractive = false;
                        }
                        getModule(moduleMap);
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }
                        this.depMaps.push(moduleMap);
                        context.completeLoad(moduleName);
                        localRequire([moduleName], load);
                    });
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                this.enabled = true;
                this.enabling = true;
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', this.errback);
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            if (node.detachEvent && !isOpera) {
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }
        function getScriptData(evt) {
            var node = evt.currentTarget || evt.srcElement;
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;
            takeGlobalQueue();
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                } else {
                    callGetModule(args);
                }
            }
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            configure: function (cfg) {
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }
                var pkgs = config.pkgs,
                    shim = config.shim,
                    objs = {
                        paths: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (prop === 'map') {
                            mixin(config[prop], value, true, true);
                        } else {
                            mixin(config[prop], value, true);
                        }
                    } else {
                        config[prop] = value;
                    }
                });
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;
                        location = pkgObj.location;
                        pkgs[pkgObj.name] = {
                            name: pkgObj.name,
                            location: location || pkgObj.name,
                            main: (pkgObj.main || 'main')
                                  .replace(currDirRegExp, '')
                                  .replace(jsSuffixRegExp, '')
                        };
                    });
                    config.pkgs = pkgs;
                }
                eachProp(registry, function (mod, id) {
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id);
                    }
                });
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }
                        if (req.get) {
                            return req.get(context, deps, relMap);
                        }
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }
                    intakeDefines();
                    context.nextTick(function () {
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,
                    toUrl: function (moduleNamePlusExt) {
                        var ext, url,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        url = context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext || '.fake');
                        return ext ? url : url.substring(0, url.length - 5);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });
                if (!relMap) {
                    localRequire.undef = function (id) {
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        if (mod) {
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        found = true;
                    }

                    callGetModule(args);
                }
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },
            nameToUrl: function (moduleName, ext) {
                var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url,
                    parentPath;
                if (req.jsExtRegExp.test(moduleName)) {
                    url = moduleName + (ext || '');
                } else {
                    paths = config.paths;
                    pkgs = config.pkgs;

                    syms = moduleName.split('/');
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');
                        pkg = getOwn(pkgs, parentModule);
                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        } else if (pkg) {
                            if (moduleName === pkg.name) {
                                pkgPath = pkg.location + '/' + pkg.main;
                            } else {
                                pkgPath = pkg.location;
                            }
                            syms.splice(0, i, pkgPath);
                            break;
                        }
                    }
                    url = syms.join('/');
                    url += (ext || (/\?/.test(url) ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                                        ((url.indexOf('?') === -1 ? '?' : '&') +
                                         config.urlArgs) : url;
            },
            load: function (id, url) {
                req.load(context, id, url);
            },
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },
            onScriptLoad: function (evt) {
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    interactiveScript = null;
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error', evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }
    req = requirejs = function (deps, callback, errback, optional) {
        var context, config,
            contextName = defContextName;
        if (!isArray(deps) && typeof deps !== 'string') {
            config = deps;
            if (isArray(callback)) {
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };
    req.config = function (config) {
        return req(config);
    };
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };
    if (!require) {
        require = req;
    }

    req.version = version;
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };
    req({});
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }
    req.onError = function (err) {
        throw err;
    };
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            node = config.xhtml ?
                    document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                    document.createElement('script');
            node.type = config.scriptType || 'text/javascript';
            node.charset = 'utf-8';
            node.async = true;

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);
            if (node.attachEvent &&
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            importScripts(url);
            context.completeLoad(moduleName);
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }
    if (isBrowser) {
        eachReverse(scripts(), function (script) {
            if (!head) {
                head = script.parentNode;
            }
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                if (!cfg.baseUrl) {
                    src = dataMain.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/') + '/' : './';

                    cfg.baseUrl = subPath;
                    dataMain = mainScript;
                }
                dataMain = dataMain.replace(jsSuffixRegExp, '');
                cfg.deps = cfg.deps ? cfg.deps.concat(dataMain) : [dataMain];

                return true;
            }
        });
    }
    define = function (name, deps, callback) {
        var node, context;
        if (typeof name !== 'string') {
            callback = deps;
            deps = name;
            name = null;
        }
        if (!isArray(deps)) {
            callback = deps;
            deps = [];
        }
        if (!deps.length && isFunction(callback)) {
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }
        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
    };

    define.amd = {
        jQuery: true
    };
    req.exec = function (text) {
        return eval(text);
    };
    req(cfg);
}(this));

});

define("acorn/dist/acorn",["require", "exports", "module"], function(require, exports, module) {

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/src\\expression.js":[function(_dereq_,module,exports){
//
//
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var pp = _state.Parser.prototype;
pp.checkPropClash = function (prop, propHash) {
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
  var key = prop.key;var name = undefined;
  switch (key.type) {
    case "Identifier":
      name = key.name;break;
    case "Literal":
      name = String(key.value);break;
    default:
      return;
  }
  var kind = prop.kind;

  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var isGetSet = kind !== "init";
    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raiseRecoverable(key.start, "Redefinition of property");
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp.parseExpression = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === _tokentype.types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) return this.parseYield();

  var validateDestructuring = false;
  if (!refDestructuringErrors) {
    refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
    validateDestructuring = true;
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.type.isAssign) {
    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true);
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
    refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return left;
};
pp.parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  if (this.eat(_tokentype.types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(_tokentype.types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp.parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
};
pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
    if (prec > minPrec) {
      var logical = this.type === _tokentype.types.logicalOR || this.type === _tokentype.types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start,
          startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }
  return left;
};

pp.buildBinary = function (startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
  var startPos = this.start,
      startLoc = this.startLoc,
      expr = undefined;
  if (this.type.prefix) {
    var node = this.startNode(),
        update = this.type === _tokentype.types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raiseRecoverable(node.start, "Deleting local variable in strict mode");else sawUnary = true;
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.prefix = false;
      node.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(_tokentype.types.starstar)) return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);else return expr;
};
pp.parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
  return this.parseSubscripts(expr, startPos, startLoc);
};

pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  for (;;) {
    if (this.eat(_tokentype.types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseIdent(true);
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.eat(_tokentype.types.bracketL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.expect(_tokentype.types.bracketR);
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      node.arguments = this.parseExprList(_tokentype.types.parenR, false);
      base = this.finishNode(node, "CallExpression");
    } else if (this.type === _tokentype.types.backQuote) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate();
      base = this.finishNode(node, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};
pp.parseExprAtom = function (refDestructuringErrors) {
  var node = undefined,
      canBeArrow = this.potentialArrowAt == this.start;
  switch (this.type) {
    case _tokentype.types._super:
      if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");

    case _tokentype.types._this:
      var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case _tokentype.types.name:
      if (this.value == "async" && /^[ \t]*(function\b|\(|\w+[ \t]*=>)/.test(this.input.slice(this.end))) {
        node = this.startNode();
        this.next();
        this.potentialArrowAt = this.start;
        return this.parseExprAtom(refDestructuringErrors);
      }
      if (this.value == "await" && /^[ \t]+[\w\x1f-\uffff]/.test(this.input.slice(this.end))) {
        node = this.startNode();
        this.next();
        return this.parseExprAtom(refDestructuringErrors);
      }

      var startPos = this.start,
          startLoc = this.startLoc;
      var id = this.parseIdent(this.type !== _tokentype.types.name);
      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
      return id;

    case _tokentype.types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;

    case _tokentype.types.num:case _tokentype.types.string:
      return this.parseLiteral(this.value);

    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
      node = this.startNode();
      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case _tokentype.types.parenL:
      return this.parseParenAndDistinguishExpression(canBeArrow);

    case _tokentype.types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");

    case _tokentype.types.braceL:
      return this.parseObj(false, refDestructuringErrors);

    case _tokentype.types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case _tokentype.types._class:
      return this.parseClass(this.startNode(), false);

    case _tokentype.types._new:
      return this.parseNew();

    case _tokentype.types.backQuote:
      return this.parseTemplate();

    default:
      this.unexpected();
  }
};

pp.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal");
};

pp.parseParenExpression = function () {
  this.expect(_tokentype.types.parenL);
  var val = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  return val;
};

pp.parseParenAndDistinguishExpression = function (canBeArrow) {
  var startPos = this.start,
      startLoc = this.startLoc,
      val = undefined;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start,
        innerStartLoc = this.startLoc;
    var exprList = [],
        first = true;
    var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 },
        spreadStart = undefined,
        innerParenStart = undefined;
    while (this.type !== _tokentype.types.parenR) {
      first ? first = false : this.expect(_tokentype.types.comma);
      if (this.type === _tokentype.types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRest()));
        break;
      } else {
        if (this.type === _tokentype.types.parenL && !innerParenStart) {
          innerParenStart = this.start;
        }
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start,
        innerEndLoc = this.startLoc;
    this.expect(_tokentype.types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, true);
      if (innerParenStart) this.unexpected(innerParenStart);
      return this.parseParenArrowList(startPos, startLoc, exprList);
    }

    if (!exprList.length) this.unexpected(this.lastTokStart);
    if (spreadStart) this.unexpected(spreadStart);
    this.checkExpressionErrors(refDestructuringErrors, true);

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};

pp.parseParenItem = function (item) {
  return item;
};

pp.parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
};
var empty = [];

pp.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
    if (!this.inFunction) this.raiseRecoverable(node.start, "new.target can only be used in functions");
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;
  return this.finishNode(node, "NewExpression");
};
pp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
    cooked: this.value
  };
  this.next();
  elem.tail = this.type === _tokentype.types.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(_tokentype.types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(_tokentype.types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement());
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp.parseObj = function (isPattern, refDestructuringErrors) {
  var node = this.startNode(),
      first = true,
      propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var prop = this.startNode(),
        isGenerator = undefined,
        startPos = undefined,
        startLoc = undefined;
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
    }
    this.parsePropertyName(prop);
    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
    this.checkPropClash(prop, propHash);
    node.properties.push(this.finishNode(prop, "Property"));
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
  if (this.eat(_tokentype.types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
    if (isPattern) this.unexpected();
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator);
  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {
    if (isGenerator || isPattern) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
    }
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    prop.kind = "init";
    if (isPattern) {
      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) || this.inGenerator && prop.key.name == "yield") this.raiseRecoverable(prop.key.start, "Binding " + prop.key.name);
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === _tokentype.types.eq && refDestructuringErrors) {
      if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else this.unexpected();
};

pp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(_tokentype.types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(_tokentype.types.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
};
pp.initFunction = function (node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
};
pp.parseMethod = function (isGenerator) {
  var node = this.startNode(),
      oldInGen = this.inGenerator;
  this.inGenerator = isGenerator;
  this.initFunction(node);
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
  if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
  this.parseFunctionBody(node, false);
  this.inGenerator = oldInGen;
  return this.finishNode(node, "FunctionExpression");
};
pp.parseArrowExpression = function (node, params) {
  var oldInGen = this.inGenerator;
  this.inGenerator = false;
  this.initFunction(node);
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);
  this.inGenerator = oldInGen;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp.parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    var oldInFunc = this.inFunction,
        oldLabels = this.labels;
    this.inFunction = true;this.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.inFunction = oldInFunc;this.labels = oldLabels;
  }
  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
    var oldStrict = this.strict;
    this.strict = true;
    if (node.id) this.checkLVal(node.id, true);
    this.checkParams(node);
    this.strict = oldStrict;
  } else if (isArrowFunction) {
    this.checkParams(node);
  }
};
pp.checkParams = function (node) {
  var nameHash = {};
  for (var i = 0; i < node.params.length; i++) {
    this.checkLVal(node.params[i], true, nameHash);
  }
};
pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
        refDestructuringErrors.trailingComma = this.lastTokStart;
      }
      if (allowTrailingComma && this.afterTrailingComma(close)) break;
    } else first = false;

    var elt = undefined;
    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refDestructuringErrors);else elt = this.parseMaybeAssign(false, refDestructuringErrors);
    elts.push(elt);
  }
  return elts;
};
pp.parseIdent = function (liberal) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved == "never") liberal = false;
  if (this.type === _tokentype.types.name) {
    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved");
    if (!liberal && this.inGenerator && this.value === "yield") this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator");
    node.name = this.value;
  } else if (liberal && this.type.keyword) {
    node.name = this.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "Identifier");
};
pp.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(_tokentype.types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js"}],"/src\\identifier.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierChar = isIdentifierChar;
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  7: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

exports.reservedWords = reservedWords;
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};

exports.keywords = keywords;
function isIdentifierStart(code, astral) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  return code >= 0xaa;
}
function isIdentifierChar(code, astral) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  return code >= 0xaa;
}

},{}],"/src\\index.js":[function(_dereq_,module,exports){
//
//
//
//
//
//
//
"use strict";

exports.__esModule = true;
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;

var _state = _dereq_("./state");

_dereq_("./parseutil");

_dereq_("./statement");

_dereq_("./lval");

_dereq_("./expression");

_dereq_("./location");

exports.Parser = _state.Parser;
exports.plugins = _state.plugins;

var _options = _dereq_("./options");

exports.defaultOptions = _options.defaultOptions;

var _locutil = _dereq_("./locutil");

exports.Position = _locutil.Position;
exports.SourceLocation = _locutil.SourceLocation;
exports.getLineInfo = _locutil.getLineInfo;

var _node = _dereq_("./node");

exports.Node = _node.Node;

var _tokentype = _dereq_("./tokentype");

exports.TokenType = _tokentype.TokenType;
exports.tokTypes = _tokentype.types;

var _tokencontext = _dereq_("./tokencontext");

exports.TokContext = _tokencontext.TokContext;
exports.tokContexts = _tokencontext.types;

var _identifier = _dereq_("./identifier");

exports.isIdentifierChar = _identifier.isIdentifierChar;
exports.isIdentifierStart = _identifier.isIdentifierStart;

var _tokenize = _dereq_("./tokenize");

exports.Token = _tokenize.Token;

var _whitespace = _dereq_("./whitespace");

exports.isNewLine = _whitespace.isNewLine;
exports.lineBreak = _whitespace.lineBreak;
exports.lineBreakG = _whitespace.lineBreakG;
var version = "3.0.2";

exports.version = version;
//
function parse(input, options) {
  return new _state.Parser(options, input).parse();
}
function parseExpressionAt(input, pos, options) {
  var p = new _state.Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression();
}
function tokenizer(input, options) {
  return new _state.Parser(options, input);
}

},{"./expression":"/src\\expression.js","./identifier":"/src\\identifier.js","./location":"/src\\location.js","./locutil":"/src\\locutil.js","./lval":"/src\\lval.js","./node":"/src\\node.js","./options":"/src\\options.js","./parseutil":"/src\\parseutil.js","./state":"/src\\state.js","./statement":"/src\\statement.js","./tokencontext":"/src\\tokencontext.js","./tokenize":"/src\\tokenize.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\location.js":[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var pp = _state.Parser.prototype;
pp.raise = function (pos, message) {
  var loc = _locutil.getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
  throw err;
};

pp.raiseRecoverable = pp.raise;

pp.curPosition = function () {
  if (this.options.locations) {
    return new _locutil.Position(this.curLine, this.pos - this.lineStart);
  }
};

},{"./locutil":"/src\\locutil.js","./state":"/src\\state.js"}],"/src\\locutil.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getLineInfo = getLineInfo;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _whitespace = _dereq_("./whitespace");
var Position = (function () {
  function Position(line, col) {


    this.line = line;
    this.column = col;
  }

  Position.prototype.offset = function offset(n) {
    return new Position(this.line, this.column + n);
  };

  return Position;
})();

exports.Position = Position;

var SourceLocation = function SourceLocation(p, start, end) {


  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) this.source = p.sourceFile;
};

exports.SourceLocation = SourceLocation;
function getLineInfo(input, offset) {
  for (var line = 0, cur = 0;;) {
    _whitespace.lineBreakG.lastIndex = cur;
    var match = _whitespace.lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
}

},{"./whitespace":"/src\\whitespace.js"}],"/src\\lval.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _util = _dereq_("./util");

var pp = _state.Parser.prototype;
pp.toAssignable = function (node, isBinding) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var i = 0; i < node.properties.length; i++) {
          var prop = node.properties[i];
          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
          this.toAssignable(prop.value, isBinding);
        }
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator
          ;
        } else {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
          break;
        }

      case "AssignmentPattern":
        if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value");
        break;

      case "ParenthesizedExpression":
        node.expression = this.toAssignable(node.expression, isBinding);
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  }
  return node;
};
pp.toAssignableList = function (exprList, isBinding) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type == "RestElement") {
      --end;
    } else if (last && last.type == "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
      --end;
    }

    if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this.toAssignable(elt, isBinding);
  }
  return exprList;
};
pp.parseSpread = function (refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};

pp.parseRest = function (allowNonIdent) {
  var node = this.startNode();
  this.next();
  if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();

  return this.finishNode(node, "RestElement");
};
pp.parseBindingAtom = function () {
  if (this.options.ecmaVersion < 6) return this.parseIdent();
  switch (this.type) {
    case _tokentype.types.name:
      return this.parseIdent();

    case _tokentype.types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern");

    case _tokentype.types.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

pp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (first) first = false;else this.expect(_tokentype.types.comma);
    if (allowEmpty && this.type === _tokentype.types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === _tokentype.types.ellipsis) {
      var rest = this.parseRest(allowNonIdent);
      this.parseBindingListItem(rest);
      elts.push(rest);
      this.expect(close);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};

pp.parseBindingListItem = function (param) {
  return param;
};
pp.parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp.checkLVal = function (expr, isBinding, checkClashes) {
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      if (checkClashes) {
        if (_util.has(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
        checkClashes[expr.name] = true;
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var i = 0; i < expr.properties.length; i++) {
        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
      }break;

    case "ArrayPattern":
      for (var i = 0; i < expr.elements.length; i++) {
        var elem = expr.elements[i];
        if (elem) this.checkLVal(elem, isBinding, checkClashes);
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes);
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes);
      break;

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, isBinding, checkClashes);
      break;

    default:
      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
  }
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./util":"/src\\util.js"}],"/src\\node.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var Node = function Node(parser, pos, loc) {


  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
  if (parser.options.ranges) this.range = [pos, 0];
};

exports.Node = Node;
var pp = _state.Parser.prototype;

pp.startNode = function () {
  return new Node(this, this.start, this.startLoc);
};

pp.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) node.loc.end = loc;
  if (this.options.ranges) node.range[1] = pos;
  return node;
}

pp.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};

},{"./locutil":"/src\\locutil.js","./state":"/src\\state.js"}],"/src\\options.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getOptions = getOptions;

var _util = _dereq_("./util");

var _locutil = _dereq_("./locutil");
var defaultOptions = {
  ecmaVersion: 6,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowHashBang: false,
  locations: true,
  onToken: null,
  onComment: null,
  //
  ranges: false,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: false,
  plugins: {}
};

exports.defaultOptions = defaultOptions;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;

  if (_util.isArray(options.onToken)) {
    (function () {
      var tokens = options.onToken;
      options.onToken = function (token) {
        return tokens.push(token);
      };
    })();
  }
  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
    if (options.ranges) comment.range = [start, end];
    array.push(comment);
  };
}

},{"./locutil":"/src\\locutil.js","./util":"/src\\util.js"}],"/src\\parseutil.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var pp = _state.Parser.prototype;
pp.isUseStrict = function (stmt) {
  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
};
pp.eat = function (type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp.isContextual = function (name) {
  return this.type === _tokentype.types.name && this.value === name;
};
pp.eatContextual = function (name) {
  return this.value === name && this.eat(_tokentype.types.name);
};
pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) this.unexpected();
};
pp.canInsertSemicolon = function () {
  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    return true;
  }
};
pp.semicolon = function () {
  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
};

pp.afterTrailingComma = function (tokType) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    this.next();
    return true;
  }
};
pp.expect = function (type) {
  this.eat(type) || this.unexpected();
};
pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

pp.checkPatternErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.trailingComma;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Trailing comma is not permitted in destructuring patterns");
};

pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\state.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var _options = _dereq_("./options");
var plugins = {};

exports.plugins = plugins;
function keywordRegexp(words) {
  return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
}

var Parser = (function () {
  function Parser(options, input, startPos) {


    this.options = options = _options.getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
    var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
    this.reservedWords = keywordRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
    this.reservedWordsStrict = keywordRegexp(reservedStrict);
    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
    this.input = String(input);
    this.containsEsc = false;
    this.loadPlugins(options.plugins);
    if (startPos) {
      this.pos = startPos;
      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 0;
    }
    this.type = _tokentype.types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;
    this.context = this.initialContext();
    this.exprAllowed = true;
    this.strict = this.inModule = options.sourceType === "module";
    this.potentialArrowAt = -1;
    this.inFunction = this.inGenerator = false;
    this.labels = [];
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
  }
  Parser.prototype.isKeyword = function isKeyword(word) {
    return this.keywords.test(word);
  };

  Parser.prototype.isReservedWord = function isReservedWord(word) {
    return this.reservedWords.test(word);
  };

  Parser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
    for (var _name in pluginConfigs) {
      var plugin = plugins[_name];
      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
      plugin(this, pluginConfigs[_name]);
    }
  };

  Parser.prototype.parse = function parse() {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node);
  };

  return Parser;
})();

exports.Parser = Parser;

},{"./identifier":"/src\\identifier.js","./options":"/src\\options.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\statement.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var _identifier = _dereq_("./identifier");

var pp = _state.Parser.prototype;
pp.parseTopLevel = function (node) {
  var first = true;
  if (!node.body) node.body = [];
  while (this.type !== _tokentype.types.eof) {
    var stmt = this.parseStatement(true, true);
    node.body.push(stmt);
    if (first) {
      if (this.isUseStrict(stmt)) this.setStrict(true);
      first = false;
    }
  }
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

var loopLabel = { kind: "loop" },
    switchLabel = { kind: "switch" };

pp.isLet = function () {
  if (this.type !== _tokentype.types.name || this.options.ecmaVersion < 6 || this.value != "let") return false;
  _whitespace.skipWhiteSpace.lastIndex = this.pos;
  var skip = _whitespace.skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length,
      nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh == 123) return true; // '{' and '['
  if (_identifier.isIdentifierStart(nextCh, true)) {
    for (var pos = next + 1; _identifier.isIdentifierChar(this.input.charCodeAt(pos, true)); ++pos) {}
    var ident = this.input.slice(next, pos);
    if (!this.isKeyword(ident)) return true;
  }
  return false;
};
//
pp.parseStatement = function (declaration, topLevel) {
  var starttype = this.type,
      node = this.startNode(),
      kind = undefined;

  if (this.isLet()) {
    starttype = _tokentype.types._var;
    kind = "let";
  }
  switch (starttype) {
    case _tokentype.types._break:case _tokentype.types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case _tokentype.types._debugger:
      return this.parseDebuggerStatement(node);
    case _tokentype.types._do:
      return this.parseDoStatement(node);
    case _tokentype.types._for:
      return this.parseForStatement(node);
    case _tokentype.types._function:
      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
      return this.parseFunctionStatement(node);
    case _tokentype.types._class:
      if (!declaration) this.unexpected();
      return this.parseClass(node, true);
    case _tokentype.types._if:
      return this.parseIfStatement(node);
    case _tokentype.types._return:
      return this.parseReturnStatement(node);
    case _tokentype.types._switch:
      return this.parseSwitchStatement(node);
    case _tokentype.types._throw:
      return this.parseThrowStatement(node);
    case _tokentype.types._try:
      return this.parseTryStatement(node);
    case _tokentype.types._const:case _tokentype.types._var:
      kind = kind || this.value;
      if (!declaration && kind != "var") this.unexpected();
      return this.parseVarStatement(node, kind);
    case _tokentype.types._while:
      return this.parseWhileStatement(node);
    case _tokentype.types._with:
      return this.parseWithStatement(node);
    case _tokentype.types.braceL:
      return this.parseBlock();
    case _tokentype.types.semi:
      return this.parseEmptyStatement(node);
    case _tokentype.types._export:
    case _tokentype.types._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
        if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
      }
      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);
    case _tokentype.types.at:
      this.next();
      return this.parseExpression();
    default:
      var maybeName = this.value,
          expr = this.parseExpression();
      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
  }
};

pp.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword == "break";
  this.next();
  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  for (var i = 0; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(_tokentype.types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
  return this.finishNode(node, "DoWhileStatement");
};
pp.parseForStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  this.expect(_tokentype.types.parenL);
  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
  var isLet = this.isLet();
  if (this.type === _tokentype.types._var || this.type === _tokentype.types._const || isLet) {
    var _init = this.startNode(),
        kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(_init, true, kind);
    this.finishNode(_init, "VariableDeclaration");
    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(kind !== "var" && _init.declarations[0].init)) return this.parseForIn(node, _init);
    return this.parseFor(node, _init);
  }
  var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
    this.checkPatternErrors(refDestructuringErrors, true);
    this.toAssignable(init);
    this.checkLVal(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return this.parseFor(node, init);
};

pp.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

pp.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
  this.next();
  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
    node.argument = this.parseExpression();this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};

pp.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(_tokentype.types.braceL);
  this.labels.push(switchLabel);
  for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {
    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
      var isCase = this.type === _tokentype.types._case;
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(_tokentype.types.colon);
    } else {
      if (!cur) this.unexpected();
      cur.consequent.push(this.parseStatement(true));
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp.parseThrowStatement = function (node) {
  this.next();
  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty = [];

pp.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === _tokentype.types._catch) {
    var clause = this.startNode();
    this.next();
    this.expect(_tokentype.types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true);
    this.expect(_tokentype.types.parenR);
    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
  return this.finishNode(node, "TryStatement");
};

pp.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp.parseWithStatement = function (node) {
  if (this.strict) this.raise(this.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp.parseLabeledStatement = function (node, maybeName, expr) {
  for (var i = 0; i < this.labels.length; ++i) {
    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label = this.labels[i];
    if (label.statementStart == node.start) {
      label.statementStart = this.start;
      label.kind = kind;
    } else break;
  }
  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
  node.body = this.parseStatement(true);
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp.parseBlock = function (allowStrict) {
  var node = this.startNode(),
      first = true,
      oldStrict = undefined;
  node.body = [];
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    var stmt = this.parseStatement(true);
    node.body.push(stmt);
    if (first && allowStrict && this.isUseStrict(stmt)) {
      oldStrict = this.strict;
      this.setStrict(this.strict = true);
    }
    first = false;
  }
  if (oldStrict === false) this.setStrict(false);
  return this.finishNode(node, "BlockStatement");
};
pp.parseFor = function (node, init) {
  node.init = init;
  this.expect(_tokentype.types.semi);
  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
  this.expect(_tokentype.types.semi);
  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp.parseForIn = function (node, init) {
  var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type);
};
pp.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl);
    if (this.eat(_tokentype.types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(_tokentype.types.comma)) break;
  }
  return node;
};

pp.parseVarId = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true);
};
pp.parseFunction = function (node, isStatement, allowExpressionBody) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
  var oldInGen = this.inGenerator;
  this.inGenerator = node.generator;
  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);
  this.inGenerator = oldInGen;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp.parseFunctionParams = function (node) {
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true);
};
pp.parseClass = function (node, isStatement) {
  this.next();
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(_tokentype.types.braceL);
  var decorators = [];
  while (!this.eat(_tokentype.types.braceR)) {
    if (this.eat(_tokentype.types.semi)) continue;
    if (this.type == _tokentype.types.at) {
      this.next();
      var expr = this.parseMaybeAssign(true);
      decorators.push(expr);
      continue;
    }
    var method = this.startNode();
    var isGenerator = this.eat(_tokentype.types.star);
    var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
    this.parsePropertyName(method);
    method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
    if (method["static"]) {
      if (isGenerator) this.unexpected();
      isGenerator = this.eat(_tokentype.types.star);
      this.parsePropertyName(method);
    }
    method.kind = "method";
    var isGetSet = false;
    if (!method.computed) {
      var key = method.key;

      if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) {
        isGetSet = true;
        method.kind = key.name;
        key = this.parsePropertyName(method);
      }
      if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
        method.kind = "constructor";
        hadConstructor = true;
      }
    }
    this.parseClassMethod(classBody, method, isGenerator);
    if (decorators.length) {
      var body = method.value.body.body;
      if (body) body.unshift.apply(body, decorators);
      decorators = [];
    }
    if (isGetSet) {
      var paramCount = method.kind === "get" ? 0 : 1;
      if (method.value.params.length !== paramCount) {
        var start = method.value.start;
        if (method.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
      }
      if (method.kind === "set" && method.value.params[0].type === "RestElement") this.raise(method.value.params[0].start, "Setter cannot use rest params");
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp.parseClassMethod = function (classBody, method, isGenerator) {
  method.value = this.parseMethod(isGenerator);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp.parseClassId = function (node, isStatement) {
  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
};

pp.parseClassSuper = function (node) {
  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
};
pp.parseExport = function (node) {
  this.next();
  if (this.eat(_tokentype.types.star)) {
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(_tokentype.types._default)) {
    var parens = this.type == _tokentype.types.parenL;
    var expr = this.parseMaybeAssign();
    var needsSemi = true;
    if (!parens && (expr.type == "FunctionExpression" || expr.type == "ClassExpression")) {
      needsSemi = false;
      if (expr.id) {
        expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
      }
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    if (this.eatContextual("from")) {
      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    } else {
      for (var i = 0; i < node.specifiers.length; i++) {
        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
          this.unexpected(node.specifiers[i].local.start);
        }
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp.shouldParseExportStatement = function () {
  return this.type.keyword || this.isLet();
};
pp.parseExportSpecifiers = function () {
  var nodes = [],
      first = true;
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.local = this.parseIdent(this.type === _tokentype.types._default);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes;
};
pp.parseImport = function (node) {
  this.next();
  if (this.type === _tokentype.types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp.parseImportSpecifiers = function () {
  var nodes = [],
      first = true;
  if (this.type === _tokentype.types.name) {
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(_tokentype.types.comma)) return nodes;
  }
  if (this.type === _tokentype.types.star) {
    var node = this.startNode();
    this.next();
    this.expectContextual("as");
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.imported = this.parseIdent(true);
    if (this.eatContextual("as")) {
      node.local = this.parseIdent();
    } else {
      node.local = node.imported;
      if (this.isKeyword(node.local.name)) this.unexpected(node.local.start);
      if (this.reservedWordsStrict.test(node.local.name)) this.raise(node.local.start, "The keyword '" + node.local.name + "' is reserved");
    }
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportSpecifier"));
  }
  return nodes;
};

},{"./identifier":"/src\\identifier.js","./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokencontext.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {


  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

exports.TokContext = TokContext;
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", true),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  f_expr: new TokContext("function", true)
};

exports.types = types;
var pp = _state.Parser.prototype;

pp.initialContext = function () {
  return [types.b_stat];
};

pp.braceIsBlock = function (prevType) {
  if (prevType === _tokentype.types.colon) {
    var _parent = this.curContext();
    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
  }
  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
  return !this.exprAllowed;
};

pp.updateContext = function (prevType) {
  var update = undefined,
      type = this.type;
  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
};
_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
  if (this.context.length == 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext() === types.f_expr) {
    this.context.pop();
    this.exprAllowed = false;
  } else if (out === types.b_tmpl) {
    this.exprAllowed = true;
  } else {
    this.exprAllowed = !out.isExpr;
  }
};

_tokentype.types.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

_tokentype.types.dollarBraceL.updateContext = function () {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

_tokentype.types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

_tokentype.types.incDec.updateContext = function () {};

_tokentype.types._function.updateContext = function () {
  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
  this.exprAllowed = false;
};

_tokentype.types.backQuote.updateContext = function () {
  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
  this.exprAllowed = false;
};
},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokenize.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var _whitespace = _dereq_("./whitespace");
var Token = function Token(p) {


  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
  if (p.options.ranges) this.range = [p.start, p.end];
};

exports.Token = Token;
var pp = _state.Parser.prototype;
var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";
pp.next = function () {
  if (this.options.onToken) this.options.onToken(new Token(this));

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp.getToken = function () {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
  var self = this;
  return { next: function next() {
      var token = self.getToken();
      return {
        done: token.type === _tokentype.types.eof,
        value: token
      };
    } };
};
pp.setStrict = function (strict) {
  this.strict = strict;
  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
  this.pos = this.start;
  if (this.options.locations) {
    while (this.pos < this.lineStart) {
      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
      --this.curLine;
    }
  }
  this.nextToken();
};

pp.curContext = function () {
  return this.context[this.context.length - 1];
};
pp.nextToken = function () {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) this.skipSpace();

  this.start = this.pos;
  if (this.options.locations) this.startLoc = this.curPosition();
  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);

  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
};

pp.readToken = function (code) {
  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

  return this.getTokenFromCode(code);
};

pp.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) return code;
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00;
};

pp.skipBlockComment = function () {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos,
      end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
  this.pos = end + 2;
  if (this.options.locations) {
    _whitespace.lineBreakG.lastIndex = start;
    var match = undefined;
    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};

pp.skipLineComment = function (startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
    ++this.pos;
    ch = this.input.charCodeAt(this.pos);
  }
  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};
pp.skipSpace = function () {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:case 8232:case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function (type, val) {
  this.end = this.pos;
  if (this.options.locations) this.endLoc = this.curPosition();
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};
//
//
pp.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) return this.readNumber(true);
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(_tokentype.types.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(_tokentype.types.dot);
  }
};

pp.readToken_slash = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;return this.readRegexp();
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.slash, 1);
};

pp.readToken_mult_modulo_exp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? _tokentype.types.star : _tokentype.types.modulo;
  if (this.options.ecmaVersion >= 7 && next === 42) {
    ++size;
    tokentype = _tokentype.types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) return this.finishOp(_tokentype.types.assign, size + 1);
  return this.finishOp(tokentype, size);
};

pp.readToken_pipe_amp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
};

pp.readToken_caret = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.bitwiseXOR, 1);
};

pp.readToken_plus_min = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(_tokentype.types.incDec, 2);
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.plusMin, 1);
};

pp.readToken_lt_gt = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
    return this.finishOp(_tokentype.types.bitShift, size);
  }
  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
    if (this.inModule) this.unexpected();
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) size = 2;
  return this.finishOp(_tokentype.types.relational, size);
};

pp.readToken_eq_excl = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(_tokentype.types.arrow);
  }
  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
};

pp.getTokenFromCode = function (code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;return this.finishToken(_tokentype.types.parenL);
    case 41:
      ++this.pos;return this.finishToken(_tokentype.types.parenR);
    case 59:
      ++this.pos;return this.finishToken(_tokentype.types.semi);
    case 44:
      ++this.pos;return this.finishToken(_tokentype.types.comma);
    case 91:
      ++this.pos;return this.finishToken(_tokentype.types.bracketL);
    case 93:
      ++this.pos;return this.finishToken(_tokentype.types.bracketR);
    case 123:
      ++this.pos;return this.finishToken(_tokentype.types.braceL);
    case 125:
      ++this.pos;return this.finishToken(_tokentype.types.braceR);
    case 58:
      ++this.pos;return this.finishToken(_tokentype.types.colon);
    case 63:
      ++this.pos;return this.finishToken(_tokentype.types.question);

    case 96:
      if (this.options.ecmaVersion < 6) break;
      ++this.pos;
      return this.finishToken(_tokentype.types.backQuote);

    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number
        ;
      }
    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
      return this.readNumber(false);
    case 34:case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();

    case 37:case 42:
      return this.readToken_mult_modulo_exp(code);

    case 124:case 38:
      return this.readToken_pipe_amp(code);

    case 94:
      return this.readToken_caret();

    case 43:case 45:
      return this.readToken_plus_min(code);

    case 60:case 62:
      return this.readToken_lt_gt(code);

    case 61:case 33:
      return this.readToken_eq_excl(code);

    case 126:
      return this.finishOp(_tokentype.types.prefix, 1);
    case 64:
      ++this.pos;return this.finishToken(_tokentype.types.at);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
function tryCreateRegexp(src, flags, throwErrorAt, parser) {
  try {
    return new RegExp(src, flags);
  } catch (e) {
    if (throwErrorAt !== undefined) {
      if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
      throw e;
    }
  }
}

var regexpUnicodeSupport = false; // !!tryCreateRegexp("\uffff", "u");

pp.readRegexp = function () {
  var _this = this;

  var escaped = undefined,
      inClass = undefined,
      start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
    var ch = this.input.charAt(this.pos);
    if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
    if (!escaped) {
      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
      escaped = ch === "\\";
    } else escaped = false;
    ++this.pos;
  }
  var content = this.input.slice(start, this.pos);
  ++this.pos;
  var mods = this.readWord1();
  var tmp = content;
  if (mods) {
    var validFlags = /^[gim]*$/;
    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;
    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    if (mods.indexOf("u") >= 0 && !regexpUnicodeSupport) {
      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
        code = Number("0x" + code);
        if (code > 0x10FFFF) _this.raise(start + offset + 3, "Code point out of bounds");
        return "x";
      });
      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
    }
  }
  var value = null;
  if (!isRhino) {
    tryCreateRegexp(tmp, undefined, start, this);
    value = tryCreateRegexp(content, mods);
  }
  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });
};
pp.readInt = function (radix, len) {
  var start = this.pos,
      total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos),
        val = undefined;
    if (code >= 97) val = code - 97 + 10 // a
    ;else if (code >= 65) val = code - 65 + 10 // A
    ;else if (code >= 48 && code <= 57) val = code - 48 // 0-9
    ;else val = Infinity;
    if (val >= radix) break;
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) return null;

  return total;
};

pp.readRadixNumber = function (radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
  return this.finishToken(_tokentype.types.num, val);
};
pp.readNumber = function (startsWithDot) {
  var start = this.pos,
      isFloat = false,
      octal = this.input.charCodeAt(this.pos) === 48;
  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
  var next = this.input.charCodeAt(this.pos);
  if (next === 46) {
    ++this.pos;
    this.readInt(10);
    isFloat = true;
    next = this.input.charCodeAt(this.pos);
  }
  if (next === 69 || next === 101) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) ++this.pos; // '+-'
    if (this.readInt(10) === null) this.raise(start, "Invalid number");
    isFloat = true;
  }
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

  var str = this.input.slice(start, this.pos),
      val = undefined;
  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
  return this.finishToken(_tokentype.types.num, val);
};
pp.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
      code = undefined;

  if (ch === 123) {
    if (this.options.ecmaVersion < 6) this.unexpected();
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
  } else {
    code = this.readHexChar(4);
  }
  return code;
};

function codePointToString(code) {
  if (code <= 0xFFFF) return String.fromCharCode(code);
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}

pp.readString = function (quote) {
  var out = "",
      chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) break;
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(_tokentype.types.string, out);
};
pp.readTmplToken = function () {
  var out = "",
      chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && this.type === _tokentype.types.template) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(_tokentype.types.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(_tokentype.types.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(_tokentype.types.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (_whitespace.isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n"; // 'n' -> '\n'
    case 114:
      return "\r"; // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2)); // 'x'
    case 117:
      return codePointToString(this.readCodePoint()); // 'u'
    case 116:
      return "\t"; // 't' -> '\t'
    case 98:
      return "\b"; // 'b' -> '\b'
    case 118:
      return "\u000b"; // 'v' -> '\u000b'
    case 102:
      return "\f"; // 'f' -> '\f'
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;++this.curLine;
      }
      return "";
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        if (octalStr !== "0" && (this.strict || inTemplate)) {
          this.raise(this.pos - 2, "Octal literal in strict mode");
        }
        this.pos += octalStr.length - 1;
        return String.fromCharCode(octal);
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function (len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) this.raise(codePos, "Bad character escape sequence");
  return n;
};
//
pp.readWord1 = function () {
  this.containsEsc = false;
  var word = "",
      first = true,
      chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (_identifier.isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) != 117) // "u"
        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function () {
  var word = this.readWord1();
  var type = _tokentype.types.name;
  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];
  return this.finishToken(type, word);
};

},{"./identifier":"/src\\identifier.js","./locutil":"/src\\locutil.js","./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokentype.js":[function(_dereq_,module,exports){
//
//
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TokenType = function TokenType(label) {
  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

exports.TokenType = TokenType;

function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true },
    startsExpr = { startsExpr: true };

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

  at: new TokenType("@", { beforeExpr: true, startsExpr: true }),
  //
  //
  //
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=", 6),
  relational: binop("</>", 7),
  bitShift: binop("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true })
};

exports.types = types;
var keywords = {};

exports.keywords = keywords;
function kw(name) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  options.keyword = name;
  keywords[name] = types["_" + name] = new TokenType(name, options);
}

kw("break");
kw("case", beforeExpr);
kw("catch");
kw("continue");
kw("debugger");
kw("default", beforeExpr);
kw("do", { isLoop: true, beforeExpr: true });
kw("else", beforeExpr);
kw("finally");
kw("for", { isLoop: true });
kw("function", startsExpr);
kw("if");
kw("return", beforeExpr);
kw("switch");
kw("throw", beforeExpr);
kw("try");
kw("var");
kw("const");
kw("while", { isLoop: true });
kw("with");
kw("new", { beforeExpr: true, startsExpr: true });
kw("this", startsExpr);
kw("super", startsExpr);
kw("class");
kw("extends", beforeExpr);
kw("export");
kw("import");
kw("null", startsExpr);
kw("true", startsExpr);
kw("false", startsExpr);
kw("in", { beforeExpr: true, binop: 7 });
kw("instanceof", { beforeExpr: true, binop: 7 });
kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

},{}],"/src\\util.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isArray = isArray;
exports.has = has;

function isArray(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
}
function has(obj, propName) {
  return Object.prototype.hasOwnProperty.call(obj, propName);
}

},{}],"/src\\whitespace.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isNewLine = isNewLine;
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
exports.lineBreak = lineBreak;
var lineBreakG = new RegExp(lineBreak.source, "g");

exports.lineBreakG = lineBreakG;

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

exports.nonASCIIwhitespace = nonASCIIwhitespace;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
exports.skipWhiteSpace = skipWhiteSpace;

},{}]},{},["/src\\index.js"])("/src\\index.js")
});
});

define("acorn/dist/acorn_loose",["require", "exports", "module", "./acorn"], function(require, exports, module) {

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).loose = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/src\\index.js":[function(_dereq_,module,exports){
"use strict";

module.exports = typeof acorn != 'undefined' ? acorn : require("./acorn");

},{}],"/src\\loose\\expression.js":[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _parseutil = _dereq_("./parseutil");

var _ = _dereq_("..");

var lp = _state.LooseParser.prototype;

lp.checkLVal = function (expr) {
  if (!expr) return expr;
  switch (expr.type) {
    case "Identifier":
    case "MemberExpression":
      return expr;

    case "ParenthesizedExpression":
      expr.expression = this.checkLVal(expr.expression);
      return expr;

    default:
      return this.dummyIdent();
  }
};

lp.parseExpression = function (noIn) {
  var start = this.storeCurrentPos();
  var expr = this.parseMaybeAssign(noIn);
  if (this.tok.type === _.tokTypes.comma) {
    var node = this.startNodeAt(start);
    node.expressions = [expr];
    while (this.eat(_.tokTypes.comma)) node.expressions.push(this.parseMaybeAssign(noIn));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

lp.parseParenExpression = function () {
  this.pushCx();
  this.expect(_.tokTypes.parenL);
  var val = this.parseExpression();
  this.popCx();
  this.expect(_.tokTypes.parenR);
  return val;
};

lp.parseMaybeAssign = function (noIn) {
  if (this.toks.isContextual("yield")) {
    var node = this.startNode();
    this.next();
    if (this.semicolon() || this.canInsertSemicolon() || this.tok.type != _.tokTypes.star && !this.tok.type.startsExpr) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(_.tokTypes.star);
      node.argument = this.parseMaybeAssign();
    }
    return this.finishNode(node, "YieldExpression");
  }

  var start = this.storeCurrentPos();
  var left = this.parseMaybeConditional(noIn);
  if (this.tok.type.isAssign) {
    var node = this.startNodeAt(start);
    node.operator = this.tok.value;
    node.left = this.tok.type === _.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  }
  return left;
};

lp.parseMaybeConditional = function (noIn) {
  var start = this.storeCurrentPos();
  var expr = this.parseExprOps(noIn);
  if (this.eat(_.tokTypes.question)) {
    var node = this.startNodeAt(start);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    node.alternate = this.expect(_.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

lp.parseExprOps = function (noIn) {
  var start = this.storeCurrentPos();
  var indent = this.curIndent,
      line = this.curLineStart;
  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line);
};

lp.parseExprOp = function (left, start, minPrec, noIn, indent, line) {
  if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) return left;
  var prec = this.tok.type.binop;
  if (prec != null && (!noIn || this.tok.type !== _.tokTypes._in)) {
    if (prec > minPrec) {
      var node = this.startNodeAt(start);
      node.left = left;
      node.operator = this.tok.value;
      this.next();
      if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
        node.right = this.dummyIdent();
      } else {
        var rightStart = this.storeCurrentPos();
        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);
      }
      this.finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, start, minPrec, noIn, indent, line);
    }
  }
  return left;
};

lp.parseMaybeUnary = function (sawUnary) {
  var start = this.storeCurrentPos(),
      expr = undefined;
  if (this.tok.type.prefix) {
    var node = this.startNode(),
        update = this.tok.type === _.tokTypes.incDec;
    if (!update) sawUnary = true;
    node.operator = this.tok.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(true);
    if (update) node.argument = this.checkLVal(node.argument);
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (this.tok.type === _.tokTypes.ellipsis) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(sawUnary);
    expr = this.finishNode(node, "SpreadElement");
  } else {
    expr = this.parseExprSubscripts();
    while (this.tok.type.postfix && !this.canInsertSemicolon()) {
      var node = this.startNodeAt(start);
      node.operator = this.tok.value;
      node.prefix = false;
      node.argument = this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(_.tokTypes.starstar)) {
    var node = this.startNodeAt(start);
    node.operator = "**";
    node.left = expr;
    node.right = this.parseMaybeUnary(false);
    return this.finishNode(node, "BinaryExpression");
  }

  return expr;
};

lp.parseExprSubscripts = function () {
  var start = this.storeCurrentPos();
  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);
};

lp.parseSubscripts = function (base, start, noCalls, startIndent, line) {
  for (;;) {
    if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) {
      if (this.tok.type == _.tokTypes.dot && this.curIndent == startIndent) --startIndent;else return base;
    }

    if (this.eat(_.tokTypes.dot)) {
      var node = this.startNodeAt(start);
      node.object = base;
      if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) node.property = this.dummyIdent();else node.property = this.parsePropertyAccessor() || this.dummyIdent();
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.tok.type == _.tokTypes.bracketL) {
      this.pushCx();
      this.next();
      var node = this.startNodeAt(start);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.popCx();
      this.expect(_.tokTypes.bracketR);
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.tok.type == _.tokTypes.parenL) {
      var node = this.startNodeAt(start);
      node.callee = base;
      node.arguments = this.parseExprList(_.tokTypes.parenR);
      base = this.finishNode(node, "CallExpression");
    } else if (this.tok.type == _.tokTypes.backQuote) {
      var node = this.startNodeAt(start);
      node.tag = base;
      node.quasi = this.parseTemplate();
      base = this.finishNode(node, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

lp.parseExprAtom = function () {
  var node = undefined;
  switch (this.tok.type) {
    case _.tokTypes._this:
    case _.tokTypes._super:
      var type = this.tok.type === _.tokTypes._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case _.tokTypes.name:
      if (this.tok.value == "async" && /^[ \t]*(function\b|\(|\w+[ \t]*=>)/.test(this.input.slice(this.tok.end))) {
        node = this.startNode();
        this.next();
        return this.parseExprAtom();
      }
      if (this.tok.value == "await" && /^[ \t]+[\w\x1f-\uffff]/.test(this.input.slice(this.tok.end))) {
        node = this.startNode();
        this.next();
        return this.parseExprAtom();
      }
      var start = this.storeCurrentPos();
      var id = this.parseIdent();
      return this.eat(_.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id]) : id;

    case _.tokTypes.regexp:
      node = this.startNode();
      var val = this.tok.value;
      node.regex = { pattern: val.pattern, flags: val.flags };
      node.value = val.value;
      node.raw = this.input.slice(this.tok.start, this.tok.end);
      this.next();
      return this.finishNode(node, "Literal");

    case _.tokTypes.num:case _.tokTypes.string:
      node = this.startNode();
      node.value = this.tok.value;
      node.raw = this.input.slice(this.tok.start, this.tok.end);
      this.next();
      return this.finishNode(node, "Literal");

    case _.tokTypes._null:case _.tokTypes._true:case _.tokTypes._false:
      node = this.startNode();
      node.value = this.tok.type === _.tokTypes._null ? null : this.tok.type === _.tokTypes._true;
      node.raw = this.tok.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case _.tokTypes.parenL:
      var parenStart = this.storeCurrentPos();
      this.next();
      var inner = this.parseExpression();
      this.expect(_.tokTypes.parenR);
      if (this.eat(_.tokTypes.arrow)) {
        return this.parseArrowExpression(this.startNodeAt(parenStart), inner.expressions || (_parseutil.isDummy(inner) ? [] : [inner]));
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(parenStart);
        par.expression = inner;
        inner = this.finishNode(par, "ParenthesizedExpression");
      }
      return inner;

    case _.tokTypes.bracketL:
      node = this.startNode();
      node.elements = this.parseExprList(_.tokTypes.bracketR, true);
      return this.finishNode(node, "ArrayExpression");

    case _.tokTypes.braceL:
      return this.parseObj();

    case _.tokTypes._class:
      return this.parseClass();

    case _.tokTypes._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case _.tokTypes._new:
      return this.parseNew();

    case _.tokTypes.backQuote:
      return this.parseTemplate();

    default:
      return this.dummyIdent();
  }
};

lp.parseNew = function () {
  var node = this.startNode(),
      startIndent = this.curIndent,
      line = this.curLineStart;
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(_.tokTypes.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    return this.finishNode(node, "MetaProperty");
  }
  var start = this.storeCurrentPos();
  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);
  if (this.tok.type == _.tokTypes.parenL) {
    node.arguments = this.parseExprList(_.tokTypes.parenR);
  } else {
    node.arguments = [];
  }
  return this.finishNode(node, "NewExpression");
};

lp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.tok.start, this.tok.end).replace(/\r\n?/g, "\n"),
    cooked: this.tok.value
  };
  this.next();
  elem.tail = this.tok.type === _.tokTypes.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

lp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.next();
    node.expressions.push(this.parseExpression());
    if (this.expect(_.tokTypes.braceR)) {
      curElt = this.parseTemplateElement();
    } else {
      curElt = this.startNode();
      curElt.value = { cooked: "", raw: "" };
      curElt.tail = true;
    }
    node.quasis.push(curElt);
  }
  this.expect(_.tokTypes.backQuote);
  return this.finishNode(node, "TemplateLiteral");
};

lp.parseObj = function () {
  var node = this.startNode();
  node.properties = [];
  this.pushCx();
  var indent = this.curIndent + 1,
      line = this.curLineStart;
  this.eat(_.tokTypes.braceL);
  if (this.curIndent + 1 < indent) {
    indent = this.curIndent;line = this.curLineStart;
  }
  while (!this.closes(_.tokTypes.braceR, indent, line)) {
    var prop = this.startNode(),
        isGenerator = undefined,
        start = undefined;
    if (this.options.ecmaVersion >= 6) {
      start = this.storeCurrentPos();
      prop.method = false;
      prop.shorthand = false;
      isGenerator = this.eat(_.tokTypes.star);
    }
    this.parsePropertyName(prop);
    if (_parseutil.isDummy(prop.key)) {
      if (_parseutil.isDummy(this.parseMaybeAssign())) this.next();this.eat(_.tokTypes.comma);continue;
    }
    if (this.eat(_.tokTypes.colon)) {
      prop.kind = "init";
      prop.value = this.parseMaybeAssign();
    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === _.tokTypes.parenL || this.tok.type === _.tokTypes.braceL)) {
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator);
    } else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" && !prop.computed && (prop.key.name === "get" || prop.key.name === "set") && (this.tok.type != _.tokTypes.comma && this.tok.type != _.tokTypes.braceR)) {
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
    } else {
      prop.kind = "init";
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(_.tokTypes.eq)) {
          var assign = this.startNodeAt(start);
          assign.operator = "=";
          assign.left = prop.key;
          assign.right = this.parseMaybeAssign();
          prop.value = this.finishNode(assign, "AssignmentExpression");
        } else {
          prop.value = prop.key;
        }
      } else {
        prop.value = this.dummyIdent();
      }
      prop.shorthand = true;
    }
    node.properties.push(this.finishNode(prop, "Property"));
    this.eat(_.tokTypes.comma);
  }
  this.popCx();
  if (!this.eat(_.tokTypes.braceR)) {
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }
  return this.finishNode(node, "ObjectExpression");
};

lp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(_.tokTypes.bracketL)) {
      prop.computed = true;
      prop.key = this.parseExpression();
      this.expect(_.tokTypes.bracketR);
      return;
    } else {
      prop.computed = false;
    }
  }
  var key = this.tok.type === _.tokTypes.num || this.tok.type === _.tokTypes.string ? this.parseExprAtom() : this.parseIdent();
  prop.key = key || this.dummyIdent();
};

lp.parsePropertyAccessor = function () {
  if (this.tok.type === _.tokTypes.name || this.tok.type.keyword) return this.parseIdent();
};

lp.parseIdent = function () {
  var name = this.tok.type === _.tokTypes.name ? this.tok.value : this.tok.type.keyword;
  if (!name) return this.dummyIdent();
  var node = this.startNode();
  this.next();
  node.name = name;
  return this.finishNode(node, "Identifier");
};

lp.initFunction = function (node) {
  node.id = null;
  node.params = [];
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
};
lp.toAssignable = function (node, binding) {
  if (!node || node.type == "Identifier" || node.type == "MemberExpression" && !binding) {} else if (node.type == "ParenthesizedExpression") {
    node.expression = this.toAssignable(node.expression, binding);
  } else if (this.options.ecmaVersion < 6) {
    return this.dummyIdent();
  } else if (node.type == "ObjectExpression") {
    node.type = "ObjectPattern";
    var props = node.properties;
    for (var i = 0; i < props.length; i++) {
      props[i].value = this.toAssignable(props[i].value, binding);
    }
  } else if (node.type == "ArrayExpression") {
    node.type = "ArrayPattern";
    this.toAssignableList(node.elements, binding);
  } else if (node.type == "SpreadElement") {
    node.type = "RestElement";
    node.argument = this.toAssignable(node.argument, binding);
  } else if (node.type == "AssignmentExpression") {
    node.type = "AssignmentPattern";
    delete node.operator;
  } else {
    return this.dummyIdent();
  }
  return node;
};

lp.toAssignableList = function (exprList, binding) {
  for (var i = 0; i < exprList.length; i++) {
    exprList[i] = this.toAssignable(exprList[i], binding);
  }return exprList;
};

lp.parseFunctionParams = function (params) {
  params = this.parseExprList(_.tokTypes.parenR);
  return this.toAssignableList(params, true);
};

lp.parseMethod = function (isGenerator) {
  var node = this.startNode();
  this.initFunction(node);
  node.params = this.parseFunctionParams();
  node.generator = isGenerator || false;
  node.expression = this.options.ecmaVersion >= 6 && this.tok.type !== _.tokTypes.braceL;
  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
  return this.finishNode(node, "FunctionExpression");
};

lp.parseArrowExpression = function (node, params) {
  this.initFunction(node);
  node.params = this.toAssignableList(params, true);
  node.expression = this.tok.type !== _.tokTypes.braceL;
  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
  return this.finishNode(node, "ArrowFunctionExpression");
};

lp.parseExprList = function (close, allowEmpty) {
  this.pushCx();
  var indent = this.curIndent,
      line = this.curLineStart,
      elts = [];
  this.next(); // Opening bracket
  while (!this.closes(close, indent + 1, line)) {
    if (this.eat(_.tokTypes.comma)) {
      elts.push(allowEmpty ? null : this.dummyIdent());
      continue;
    }
    var elt = this.parseMaybeAssign();
    if (_parseutil.isDummy(elt)) {
      if (this.closes(close, indent, line)) break;
      this.next();
    } else {
      elts.push(elt);
    }
    this.eat(_.tokTypes.comma);
  }
  this.popCx();
  if (!this.eat(close)) {
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }
  return elts;
};
},{"..":"/src\\index.js","./parseutil":"/src\\loose\\parseutil.js","./state":"/src\\loose\\state.js"}],"/src\\loose\\index.js":[function(_dereq_,module,exports){
//
//
//
//
//
//
//
"use strict";

exports.__esModule = true;
exports.parse_dammit = parse_dammit;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _ = _dereq_("..");

var acorn = _interopRequireWildcard(_);

var _state = _dereq_("./state");

_dereq_("./tokenize");

_dereq_("./statement");

_dereq_("./expression");

exports.LooseParser = _state.LooseParser;
exports.pluginsLoose = _state.pluginsLoose;

acorn.defaultOptions.tabSize = 4;

function parse_dammit(input, options) {
  var p = new _state.LooseParser(input, options);
  p.next();
  return p.parseTopLevel();
}

acorn.parse_dammit = parse_dammit;
acorn.LooseParser = _state.LooseParser;
acorn.pluginsLoose = _state.pluginsLoose;

},{"..":"/src\\index.js","./expression":"/src\\loose\\expression.js","./state":"/src\\loose\\state.js","./statement":"/src\\loose\\statement.js","./tokenize":"/src\\loose\\tokenize.js"}],"/src\\loose\\parseutil.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isDummy = isDummy;

function isDummy(node) {
  return node.name == "✖";
}

},{}],"/src\\loose\\state.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = _dereq_("..");
var pluginsLoose = {};

exports.pluginsLoose = pluginsLoose;

var LooseParser = (function () {
  function LooseParser(input, options) {


    this.toks = _.tokenizer(input, options);
    this.options = this.toks.options;
    this.input = this.toks.input;
    this.tok = this.last = { type: _.tokTypes.eof, start: 0, end: 0 };
    if (this.options.locations) {
      var here = this.toks.curPosition();
      this.tok.loc = new _.SourceLocation(this.toks, here, here);
    }
    this.ahead = []; // Tokens ahead
    this.context = []; // Indentation contexted
    this.curIndent = 0;
    this.curLineStart = 0;
    this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
    this.options.pluginsLoose = options.pluginsLoose || {};
    this.loadPlugins(this.options.pluginsLoose);
  }

  LooseParser.prototype.startNode = function startNode() {
    return new _.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);
  };

  LooseParser.prototype.storeCurrentPos = function storeCurrentPos() {
    return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;
  };

  LooseParser.prototype.startNodeAt = function startNodeAt(pos) {
    if (this.options.locations) {
      return new _.Node(this.toks, pos[0], pos[1]);
    } else {
      return new _.Node(this.toks, pos);
    }
  };

  LooseParser.prototype.finishNode = function finishNode(node, type) {
    node.type = type;
    node.end = this.last.end;
    if (this.options.locations) node.loc.end = this.last.loc.end;
    if (this.options.ranges) node.range[1] = this.last.end;
    return node;
  };

  LooseParser.prototype.dummyNode = function dummyNode(type) {
    var dummy = this.startNode();
    dummy.type = type;
    dummy.end = dummy.start;
    if (this.options.locations) dummy.loc.end = dummy.loc.start;
    if (this.options.ranges) dummy.range[1] = dummy.start;
    this.last = { type: _.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc };
    return dummy;
  };

  LooseParser.prototype.dummyIdent = function dummyIdent() {
    var dummy = this.dummyNode("Identifier");
    dummy.name = "✖";
    return dummy;
  };

  LooseParser.prototype.dummyString = function dummyString() {
    var dummy = this.dummyNode("Literal");
    dummy.value = dummy.raw = "✖";
    return dummy;
  };

  LooseParser.prototype.eat = function eat(type) {
    if (this.tok.type === type) {
      this.next();
      return true;
    } else {
      return false;
    }
  };

  LooseParser.prototype.isContextual = function isContextual(name) {
    return this.tok.type === _.tokTypes.name && this.tok.value === name;
  };

  LooseParser.prototype.eatContextual = function eatContextual(name) {
    return this.tok.value === name && this.eat(_.tokTypes.name);
  };

  LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon() {
    return this.tok.type === _.tokTypes.eof || this.tok.type === _.tokTypes.braceR || _.lineBreak.test(this.input.slice(this.last.end, this.tok.start));
  };

  LooseParser.prototype.semicolon = function semicolon() {
    return this.eat(_.tokTypes.semi);
  };

  LooseParser.prototype.expect = function expect(type) {
    if (this.eat(type)) return true;
    for (var i = 1; i <= 2; i++) {
      if (this.lookAhead(i).type == type) {
        for (var j = 0; j < i; j++) {
          this.next();
        }return true;
      }
    }
  };

  LooseParser.prototype.pushCx = function pushCx() {
    this.context.push(this.curIndent);
  };

  LooseParser.prototype.popCx = function popCx() {
    this.curIndent = this.context.pop();
  };

  LooseParser.prototype.lineEnd = function lineEnd(pos) {
    while (pos < this.input.length && !_.isNewLine(this.input.charCodeAt(pos))) ++pos;
    return pos;
  };

  LooseParser.prototype.indentationAfter = function indentationAfter(pos) {
    for (var count = 0;; ++pos) {
      var ch = this.input.charCodeAt(pos);
      if (ch === 32) ++count;else if (ch === 9) count += this.options.tabSize;else return count;
    }
  };

  LooseParser.prototype.closes = function closes(closeTok, indent, line, blockHeuristic) {
    if (this.tok.type === closeTok || this.tok.type === _.tokTypes.eof) return true
    ;
  };

  LooseParser.prototype.tokenStartsLine = function tokenStartsLine() {
    for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {
      var ch = this.input.charCodeAt(p);
      if (ch !== 9 && ch !== 32) return false;
    }
    return true;
  };

  LooseParser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  LooseParser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
    for (var _name in pluginConfigs) {
      var plugin = pluginsLoose[_name];
      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
      plugin(this, pluginConfigs[_name]);
    }
  };

  return LooseParser;
})();

exports.LooseParser = LooseParser;

},{"..":"/src\\index.js"}],"/src\\loose\\statement.js":[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _parseutil = _dereq_("./parseutil");

var _ = _dereq_("..");

var lp = _state.LooseParser.prototype;

lp.parseTopLevel = function () {
  var node = this.startNodeAt(this.options.locations ? [0, _.getLineInfo(this.input, 0)] : 0);
  node.body = [];
  while (this.tok.type !== _.tokTypes.eof) node.body.push(this.parseStatement());
  this.last = this.tok;
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

lp.parseStatement = function () {
  var starttype = this.tok.type,
      node = this.startNode(),
      kind = undefined;

  if (this.toks.isLet()) {
    starttype = _.tokTypes._var;
    kind = "let";
  }

  switch (starttype) {
    case _.tokTypes._break:case _.tokTypes._continue:
      this.next();
      var isBreak = starttype === _.tokTypes._break;
      if (this.semicolon() || this.canInsertSemicolon()) {
        node.label = null;
      } else {
        node.label = this.tok.type === _.tokTypes.name ? this.parseIdent() : null;
        this.semicolon();
      }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

    case _.tokTypes._debugger:
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");

    case _.tokTypes._do:
      this.next();
      node.body = this.parseStatement();
      node.test = this.eat(_.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();
      this.semicolon();
      return this.finishNode(node, "DoWhileStatement");

    case _.tokTypes._for:
      this.next();
      this.pushCx();
      this.expect(_.tokTypes.parenL);
      if (this.tok.type === _.tokTypes.semi) return this.parseFor(node, null);
      var isLet = this.toks.isLet();
      if (isLet || this.tok.type === _.tokTypes._var || this.tok.type === _.tokTypes._const) {
        var _init = this.parseVar(true, isLet ? "let" : this.tok.value);
        if (_init.declarations.length === 1 && (this.tok.type === _.tokTypes._in || this.isContextual("of"))) {
          return this.parseForIn(node, _init);
        }
        return this.parseFor(node, _init);
      }
      var init = this.parseExpression(true);
      if (this.tok.type === _.tokTypes._in || this.isContextual("of")) return this.parseForIn(node, this.toAssignable(init));
      return this.parseFor(node, init);

    case _.tokTypes._function:
      this.next();
      return this.parseFunction(node, true);

    case _.tokTypes._if:
      this.next();
      node.test = this.parseParenExpression();
      node.consequent = this.parseStatement();
      node.alternate = this.eat(_.tokTypes._else) ? this.parseStatement() : null;
      return this.finishNode(node, "IfStatement");

    case _.tokTypes._return:
      this.next();
      if (this.eat(_.tokTypes.semi) || this.canInsertSemicolon()) node.argument = null;else {
        node.argument = this.parseExpression();this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");

    case _.tokTypes._switch:
      var blockIndent = this.curIndent,
          line = this.curLineStart;
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.pushCx();
      this.expect(_.tokTypes.braceL);

      var cur = undefined;
      while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) {
        if (this.tok.type === _.tokTypes._case || this.tok.type === _.tokTypes._default) {
          var isCase = this.tok.type === _.tokTypes._case;
          if (cur) this.finishNode(cur, "SwitchCase");
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) cur.test = this.parseExpression();else cur.test = null;
          this.expect(_.tokTypes.colon);
        } else {
          if (!cur) {
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            cur.test = null;
          }
          cur.consequent.push(this.parseStatement());
        }
      }
      if (cur) this.finishNode(cur, "SwitchCase");
      this.popCx();
      this.eat(_.tokTypes.braceR);
      return this.finishNode(node, "SwitchStatement");

    case _.tokTypes._throw:
      this.next();
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");

    case _.tokTypes._try:
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.tok.type === _.tokTypes._catch) {
        var clause = this.startNode();
        this.next();
        this.expect(_.tokTypes.parenL);
        clause.param = this.toAssignable(this.parseExprAtom(), true);
        this.expect(_.tokTypes.parenR);
        clause.body = this.parseBlock();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(_.tokTypes._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) return node.block;
      return this.finishNode(node, "TryStatement");

    case _.tokTypes._var:
    case _.tokTypes._const:
      return this.parseVar(false, kind || this.tok.value);

    case _.tokTypes._while:
      this.next();
      node.test = this.parseParenExpression();
      node.body = this.parseStatement();
      return this.finishNode(node, "WhileStatement");

    case _.tokTypes._with:
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement();
      return this.finishNode(node, "WithStatement");

    case _.tokTypes.braceL:
      return this.parseBlock();

    case _.tokTypes.semi:
      this.next();
      return this.finishNode(node, "EmptyStatement");

    case _.tokTypes._class:
      return this.parseClass(true);

    case _.tokTypes._import:
      return this.parseImport();

    case _.tokTypes._export:
      return this.parseExport();
    case _.tokTypes.at:
      this.next();
      return this.parseExpression();

    default:
      var expr = this.parseExpression();
      if (_parseutil.isDummy(expr)) {
        this.next();
        if (this.tok.type === _.tokTypes.eof) return this.finishNode(node, "EmptyStatement");
        return this.parseStatement();
      } else if (starttype === _.tokTypes.name && expr.type === "Identifier" && this.eat(_.tokTypes.colon)) {
        node.body = this.parseStatement();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      } else {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
  }
};

lp.parseBlock = function () {
  var node = this.startNode();
  this.pushCx();
  this.expect(_.tokTypes.braceL);
  var blockIndent = this.curIndent,
      line = this.curLineStart;
  node.body = [];
  while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) node.body.push(this.parseStatement());
  this.popCx();
  this.eat(_.tokTypes.braceR);
  return this.finishNode(node, "BlockStatement");
};

lp.parseFor = function (node, init) {
  node.init = init;
  node.test = node.update = null;
  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.semi) node.test = this.parseExpression();
  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.parenR) node.update = this.parseExpression();
  this.popCx();
  this.expect(_.tokTypes.parenR);
  node.body = this.parseStatement();
  return this.finishNode(node, "ForStatement");
};

lp.parseForIn = function (node, init) {
  var type = this.tok.type === _.tokTypes._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.popCx();
  this.expect(_.tokTypes.parenR);
  node.body = this.parseStatement();
  return this.finishNode(node, type);
};

lp.parseVar = function (noIn, kind) {
  var node = this.startNode();
  node.kind = kind;
  this.next();
  node.declarations = [];
  do {
    var decl = this.startNode();
    decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();
    decl.init = this.eat(_.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
  } while (this.eat(_.tokTypes.comma));
  if (!node.declarations.length) {
    var decl = this.startNode();
    decl.id = this.dummyIdent();
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
  }
  if (!noIn) this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

lp.parseClass = function (isStatement) {
  var node = this.startNode();
  this.next();
  if (this.tok.type === _.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();else node.id = null;
  node.superClass = this.eat(_.tokTypes._extends) ? this.parseExpression() : null;
  node.body = this.startNode();
  node.body.body = [];
  this.pushCx();
  var indent = this.curIndent + 1,
      line = this.curLineStart;
  this.eat(_.tokTypes.braceL);
  var decorators = [];
  if (this.curIndent + 1 < indent) {
    indent = this.curIndent;line = this.curLineStart;
  }
  while (!this.closes(_.tokTypes.braceR, indent, line)) {
    if (this.semicolon()) continue;
    if (this.tok.type == _.tokTypes.at) {
      this.next();
      var expr = this.parseMaybeAssign(true);
      decorators.push(expr);
      continue;
    }
    var method = this.startNode(),
        isGenerator = undefined;
    if (this.options.ecmaVersion >= 6) {
      method["static"] = false;
      isGenerator = this.eat(_.tokTypes.star);
    }
    this.parsePropertyName(method);
    if (_parseutil.isDummy(method.key)) {
      if (_parseutil.isDummy(this.parseMaybeAssign())) this.next();this.eat(_.tokTypes.comma);continue;
    }
    if (method.key.type === "Identifier" && !method.computed && method.key.name === "static" && (this.tok.type != _.tokTypes.parenL && this.tok.type != _.tokTypes.braceL)) {
      method["static"] = true;
      isGenerator = this.eat(_.tokTypes.star);
      this.parsePropertyName(method);
    } else {
      method["static"] = false;
    }
    if (this.options.ecmaVersion >= 5 && method.key.type === "Identifier" && !method.computed && (method.key.name === "get" || method.key.name === "set") && this.tok.type !== _.tokTypes.parenL && this.tok.type !== _.tokTypes.braceL) {
      method.kind = method.key.name;
      this.parsePropertyName(method);
      method.value = this.parseMethod(false);
    } else {
      if (!method.computed && !method["static"] && !isGenerator && (method.key.type === "Identifier" && method.key.name === "constructor" || method.key.type === "Literal" && method.key.value === "constructor")) {
        method.kind = "constructor";
      } else {
        method.kind = "method";
      }
      method.value = this.parseMethod(isGenerator);
    }

    if (decorators.length) {
      var body = method.value.body.body;
      if (body) body.unshift.apply(body, decorators);
      decorators = [];
    }
    node.body.body.push(this.finishNode(method, "MethodDefinition"));
  }
  this.popCx();
  if (!this.eat(_.tokTypes.braceR)) {
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }
  this.semicolon();
  this.finishNode(node.body, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

lp.parseFunction = function (node, isStatement) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = this.eat(_.tokTypes.star);
  }
  if (this.tok.type === _.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();
  node.params = this.parseFunctionParams();
  node.body = this.parseBlock();
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

lp.parseExport = function () {
  var node = this.startNode();
  this.next();
  if (this.eat(_.tokTypes.star)) {
    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(_.tokTypes._default)) {
    var expr = this.parseMaybeAssign();
    if (expr.id) {
      switch (expr.type) {
        case "FunctionExpression":
          expr.type = "FunctionDeclaration";break;
        case "ClassExpression":
          expr.type = "ClassDeclaration";break;
      }
    }
    node.declaration = expr;
    this.semicolon();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.tok.type.keyword || this.toks.isLet()) {
    node.declaration = this.parseStatement();
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifierList();
    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

lp.parseImport = function () {
  var node = this.startNode();
  this.next();
  if (this.tok.type === _.tokTypes.string) {
    node.specifiers = [];
    node.source = this.parseExprAtom();
    node.kind = "";
  } else {
    var elt = undefined;
    if (this.tok.type === _.tokTypes.name && this.tok.value !== "from") {
      elt = this.startNode();
      elt.local = this.parseIdent();
      this.finishNode(elt, "ImportDefaultSpecifier");
      this.eat(_.tokTypes.comma);
    }
    node.specifiers = this.parseImportSpecifierList();
    node.source = this.eatContextual("from") && this.tok.type == _.tokTypes.string ? this.parseExprAtom() : this.dummyString();
    if (elt) node.specifiers.unshift(elt);
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

lp.parseImportSpecifierList = function () {
  var elts = [];
  if (this.tok.type === _.tokTypes.star) {
    var elt = this.startNode();
    this.next();
    if (this.eatContextual("as")) elt.local = this.parseIdent();
    elts.push(this.finishNode(elt, "ImportNamespaceSpecifier"));
  } else {
    var indent = this.curIndent,
        line = this.curLineStart,
        continuedLine = this.nextLineStart;
    this.pushCx();
    this.eat(_.tokTypes.braceL);
    if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
    while (!this.closes(_.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
      var elt = this.startNode();
      if (this.eat(_.tokTypes.star)) {
        elt.local = this.eatContextual("as") ? this.parseIdent() : this.dummyIdent();
        this.finishNode(elt, "ImportNamespaceSpecifier");
      } else {
        if (this.isContextual("from")) break;
        elt.imported = this.parseIdent();
        if (_parseutil.isDummy(elt.imported)) break;
        elt.local = this.eatContextual("as") ? this.parseIdent() : elt.imported;
        this.finishNode(elt, "ImportSpecifier");
      }
      elts.push(elt);
      this.eat(_.tokTypes.comma);
    }
    this.eat(_.tokTypes.braceR);
    this.popCx();
  }
  return elts;
};

lp.parseExportSpecifierList = function () {
  var elts = [];
  var indent = this.curIndent,
      line = this.curLineStart,
      continuedLine = this.nextLineStart;
  this.pushCx();
  this.eat(_.tokTypes.braceL);
  if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
  while (!this.closes(_.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
    if (this.isContextual("from")) break;
    var elt = this.startNode();
    elt.local = this.parseIdent();
    if (_parseutil.isDummy(elt.local)) break;
    elt.exported = this.eatContextual("as") ? this.parseIdent() : elt.local;
    this.finishNode(elt, "ExportSpecifier");
    elts.push(elt);
    this.eat(_.tokTypes.comma);
  }
  this.eat(_.tokTypes.braceR);
  this.popCx();
  return elts;
};

},{"..":"/src\\index.js","./parseutil":"/src\\loose\\parseutil.js","./state":"/src\\loose\\state.js"}],"/src\\loose\\tokenize.js":[function(_dereq_,module,exports){
"use strict";

var _ = _dereq_("..");

var _state = _dereq_("./state");

var lp = _state.LooseParser.prototype;

function isSpace(ch) {
  return ch < 14 && ch > 8 || ch === 32 || ch === 160 || _.isNewLine(ch);
}

lp.next = function () {
  this.last = this.tok;
  if (this.ahead.length) this.tok = this.ahead.shift();else this.tok = this.readToken();

  if (this.tok.start >= this.nextLineStart) {
    while (this.tok.start >= this.nextLineStart) {
      this.curLineStart = this.nextLineStart;
      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
    }
    this.curIndent = this.indentationAfter(this.curLineStart);
  }
};

lp.readToken = function () {
  for (;;) {
    try {
      this.toks.next();
      if (this.toks.type === _.tokTypes.dot && this.input.substr(this.toks.end, 1) === "." && this.options.ecmaVersion >= 6) {
        this.toks.end++;
        this.toks.type = _.tokTypes.ellipsis;
      }
      return new _.Token(this.toks);
    } catch (e) {
      if (!(e instanceof SyntaxError)) throw e;
      var msg = e.message,
          pos = e.raisedAt,
          replace = true;
      if (/unterminated/i.test(msg)) {
        pos = this.lineEnd(e.pos + 1);
        if (/string/.test(msg)) {
          replace = { start: e.pos, end: pos, type: _.tokTypes.string, value: this.input.slice(e.pos + 1, pos) };
        } else if (/regular expr/i.test(msg)) {
          var re = this.input.slice(e.pos, pos);
          try {
            re = new RegExp(re);
          } catch (e) {}
          replace = { start: e.pos, end: pos, type: _.tokTypes.regexp, value: re };
        } else if (/template/.test(msg)) {
          replace = { start: e.pos, end: pos,
            type: _.tokTypes.template,
            value: this.input.slice(e.pos, pos) };
        } else {
          replace = false;
        }
      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {
        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos;
      } else if (/character escape|expected hexadecimal/i.test(msg)) {
        while (pos < this.input.length) {
          var ch = this.input.charCodeAt(pos++);
          if (ch === 34 || ch === 39 || _.isNewLine(ch)) break;
        }
      } else if (/unexpected character/i.test(msg)) {
        pos++;
        replace = false;
      } else if (/regular expression/i.test(msg)) {
        replace = true;
      } else {
        throw e;
      }
      this.resetTo(pos);
      if (replace === true) replace = { start: pos, end: pos, type: _.tokTypes.name, value: "✖" };
      if (replace) {
        if (this.options.locations) replace.loc = new _.SourceLocation(this.toks, _.getLineInfo(this.input, replace.start), _.getLineInfo(this.input, replace.end));
        return replace;
      }
    }
  }
};

lp.resetTo = function (pos) {
  this.toks.pos = pos;
  var ch = this.input.charAt(pos - 1);
  this.toks.exprAllowed = !ch || /[\[\{\(,;:?\/*=+\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(pos - 10, pos));

  if (this.options.locations) {
    this.toks.curLine = 1;
    this.toks.lineStart = _.lineBreakG.lastIndex = 0;
    var match = undefined;
    while ((match = _.lineBreakG.exec(this.input)) && match.index < pos) {
      ++this.toks.curLine;
      this.toks.lineStart = match.index + match[0].length;
    }
  }
};

lp.lookAhead = function (n) {
  while (n > this.ahead.length) this.ahead.push(this.readToken());
  return this.ahead[n - 1];
};

},{"..":"/src\\index.js","./state":"/src\\loose\\state.js"}]},{},["/src\\loose\\index.js"])("/src\\loose\\index.js")
});
});

define("treehugger/tree",[], function(require, exports, module) {

function inRange(p, pos, exclusive) {
    if(p && p.sl <= pos.line && pos.line <= p.el) {
        if(p.sl < pos.line && pos.line < p.el)
            return true;
        else if(p.sl == pos.line && pos.line < p.el)
            return p.sc <= pos.col;
        else if(p.sl == pos.line && p.el === pos.line)
            return p.sc <= pos.col && pos.col <= p.ec + (exclusive ? 1 : 0);
        else if(p.sl < pos.line && p.el === pos.line)
            return pos.col <= p.ec + (exclusive ? 1 : 0);
    }
}
function Node() {
}

Node.prototype.toPrettyString = function(prefix) {
    prefix = prefix || "";
    return prefix + this.toString();
};

Node.prototype.setAnnotation = function(name, value) {
    this.annos = this.annos || {};
    this.annos[name] = value;
};

Node.prototype.getAnnotation = function(name) {
    return this.annos ? this.annos[name] : undefined;
};

Node.prototype.$pos = null;
Node.prototype.getPos = function() {
    if(this.annos && this.annos.pos) {
        return this.annos.pos;
    } else {
        var p = this.$pos;
        return p && {
            sl : p.start.line, sc : p.start.column,
            el : p.end.line, ec : p.end.column
        };
    }
};

Node.prototype.findNode = function(pos) {
    var p = this.getPos();
    if(inRange(p, pos)) {
        return this;
    } else {
        return null;
    }
};
function ConsNode(cons, children) {
    this.cons = cons;
    for(var i = 0; i < children.length; i++) {
        this[i] = children[i];
    }
    this.length = children.length;
}

ConsNode.prototype = new Node();
ConsNode.prototype.toString = function(prefix) {
    try {
        var s = this.cons + "(";
        for ( var i = 0; i < this.length; i++) {
            s += this[i].toString() + ",";
        }
        if (this.length > 0) {
            s = s.substring(0, s.length - 1);
        }
        return s + ")";
    } catch(e) {
        console.error("Something went wrong: ", this, e);
    }
};
ConsNode.prototype.toPrettyString = function(prefix) {
    prefix = prefix || "";
    try {
        if(this.length === 0) {
            return prefix + this.cons + "()";
        }
        if(this.length === 1 && (this[0] instanceof StringNode || this[0] instanceof NumNode)) {
            return prefix + this.cons + "(" + this[0].toString() + ")";
        }
        var s = prefix + this.cons + "(\n";
        for ( var i = 0; i < this.length; i++) {
            s += this[i].toPrettyString(prefix + "    ") + ",\n";
        }
        s = s.substring(0, s.length - 2);
        s += "\n";
        return s + prefix + ")";
    } catch(e) {
        console.error("Something went wrong: ", this, e);
    }
};
ConsNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof ConsNode) {
        if (this.cons === t.cons) {
            if (this.length === t.length) {
                for ( var i = 0; i < this.length; i++) {
                    if (!this[i].match(t[i], matches)) {
                        return false;
                    }
                }
                return matches;
            }
        }
    }
    return false;
};
ConsNode.prototype.build = function(values) {
    var children = [];
    for ( var i = 0; i < this.length; i++) {
        children.push(this[i].build(values));
    }
    return new ConsNode(this.cons, children);
};
ConsNode.prototype.toJSON = function() {
    var l = [];
    for(var i = 0; i < this.length; i++) {
        l.push(this[i]);
    }
    return {cons: this.cons, children: l};
};

ConsNode.prototype.getPos = function() {
    if (this.$pos && this.$pos.start && this.$pos.end) {
        var p = this.$pos;
        return {sl : p.start.line, sc : p.start.column,
                el : p.end.line, ec : p.end.column};
    }

    var nodePos = this.getAnnotation("pos");
    var result = nodePos
        ? {sl : nodePos.sl, sc : nodePos.sc, el : nodePos.el, ec : nodePos.ec}
        : {sl : Number.MAX_VALUE, sc : Number.MAX_VALUE, el : 0, ec : 0};
    
    var hasSl = false;
    var hasSc = false;
    
    for (var i = 0; i < this.length; i++) {
        var p = this[i].getPos();

        if (p) {
            if (p.sl < Number.MAX_VALUE && !hasSl) {
                result.sl = p.sl;
                hasSl = true;
            }
            if (p.sc < Number.MAX_VALUE && !hasSc) {
                result.sc = p.sc;
                hasSc = true;
            }
            result.el = p.el || result.el;
            result.ec = p.ec || result.ec;
        }
    }
    
    return result;
};

ConsNode.prototype.$pos = null;

ConsNode.prototype.findNode = function(pos) {
    var p = this.getPos();

    if(inRange(p, pos)) {
        for(var i = 0; i < this.length; i++) {
            var p2 = this[i].getPos();
            if(inRange(p2, pos)) {
                var node = this[i].findNode(pos);
                if(node)
                    return node instanceof StringNode ? this : node;
                else
                    return this[i];
            }
        }
    } else {
        return null;
    }
};
exports.cons = function(name, children) {
    return new ConsNode(name, children);
};
function ListNode (children) {
    for(var i = 0; i < children.length; i++)
        this[i] = children[i];
    this.length = children.length;
}

ListNode.prototype = new Node();

ListNode.prototype.toString = function() {
    var s = "[";
    for (var i = 0; i < this.length; i++)
        s += this[i].toString() + ",";
    if (this.length > 0)
        s = s.substring(0, s.length - 1);
    return s + "]";
};

ListNode.prototype.toPrettyString = function(prefix) {
    prefix = prefix || "";
    try {
        if(this.length === 0)
            return prefix + "[]";
        var s = prefix + "[\n";
        for ( var i = 0; i < this.length; i++)
            s += this[i].toPrettyString(prefix + "  ") + ",\n";
        s = s.substring(0, s.length - 2);
        s += "\n";
        return s + prefix + "]";
    } catch(e) {
        console.error("Something went wrong: ", this);
    }
};

ListNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof ListNode) {
        if (this.length === t.length) {
            for ( var i = 0; i < this.length; i++)
                if (!this[i].match(t[i], matches))
                    return false;
            return matches;
        }
        else
            return false;
    }
    else
        return false;
};

ListNode.prototype.build = function(values) {
    var children = [];
    for (var i = 0; i < this.length; i++)
        children.push(this[i].build(values));
    return new ListNode(children);
};

ListNode.prototype.getPos = ConsNode.prototype.getPos;
ListNode.prototype.findNode = ConsNode.prototype.findNode;
ListNode.prototype.forEach = function(fn) {
    for(var i = 0; i < this.length; i++) {
        fn.call(this[i], this[i], i);
    }
};
ListNode.prototype.isEmpty = function() {
    return this.length === 0;
};
ListNode.prototype.contains = function(el) {
    for(var i = 0; i < this.length; i++)
        if(el.match(this[i]))
            return true;
    return false;
};
ListNode.prototype.concat = function(l) {
    var ar = [];
    for(var i = 0; i < this.length; i++)
        ar.push(this[i]);
    for(i = 0; i < l.length; i++)
        ar.push(l[i]);
    return exports.list(ar);
};

ListNode.prototype.toJSON = function() {
    var l = [];
    for(var i = 0; i < this.length; i++)
        l.push(this[i]);
    return l;
};
ListNode.prototype.removeDuplicates = function() {
    var newList = [];
    lbl: for(var i = 0; i < this.length; i++) {
        for(var j = 0; j < newList.length; j++)
            if(newList[j].match(this[i]))
                continue lbl;
        newList.push(this[i]);
    }
    return new exports.list(newList);
};

ListNode.prototype.toArray = ListNode.prototype.toJSON;
exports.list = function(elements) {
    return new ListNode(elements);
};

function NumNode (value) {
    this.value = value;
}

NumNode.prototype = new Node();

NumNode.prototype.toString = function() {
    return ""+this.value;
};

NumNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof NumNode)
        return this.value === t.value ? matches : false;
    else
        return false;
};

NumNode.prototype.build = function(values) {
    return this;
};

exports.num = function(value) {
    return new NumNode(value);
};

function StringNode (value) {
    this.value = value;
}

StringNode.prototype = new Node();

StringNode.prototype.toString = function() {
    return '"' + this.value + '"';
};

StringNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof StringNode)
        return this.value === t.value ? matches : false;
    else
        return false;
};

StringNode.prototype.build = function(values) {
    return this;
};

exports.string = function(value) {
    return new StringNode(value);
};

function PlaceholderNode(id) {
    this.id = id;
}

PlaceholderNode.prototype = new Node();

PlaceholderNode.prototype.toString = function() {
    return this.id;
};

PlaceholderNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if(this.id === '_')
        return matches;
    if(matches[this.id]) // already bound
        return matches[this.id].match(t);
    else {
        matches[this.id] = t;
        return matches;
    }
};

PlaceholderNode.prototype.build = function(values) {
    return values[this.id];
};

exports.placeholder = function(n) {
    return new PlaceholderNode(n);
};


function parse (s) {
    var idx = 0;
    function accept (str) {
        for ( var i = 0; i < str.length && idx + i < s.length; i++) {
            if (str[i] != s[idx + i]) {
                return false;
            }
        }
        return i == str.length;
    }
    function lookAheadLetter() {
        return s[idx] >= 'a' && s[idx] <= 'z' || s[idx] >= 'A' && s[idx] <= 'Z' || s[idx] === '_' || s[idx] >= '0' && s[idx] <= '9';
    }
    function skipWhitespace () {
        while (idx < s.length && (s[idx] === " " || s[idx] === "\n" || s[idx] === "\r" || s[idx] === "\t")) {
            idx++;
        }
    }
    function parseInt () {
        var pos = idx;
        if (s[idx] >= '0' && s[idx] <= '9') {
            var ns = s[idx];
            idx++;
            while (idx < s.length && s[idx] >= '0' && s[idx] <= '9') {
                ns += s[idx];
                idx++;
            }
            skipWhitespace();
            return new NumNode(+ns, pos);
        } else {
            return null;
        }
    }
    function parseString () {
        var pos = idx;
        if (accept('"')) {
            var ns = "";
            idx++;
            while (!accept('"') || (accept('"') && s[idx - 1] == '\\')) {
                ns += s[idx];
                idx++;
            }
            var ns2 = '';
            for ( var i = 0; i < ns.length; i++) {
                if (ns[i] == "\\") {
                    i++;
                    switch (ns[i]) {
                        case 'n':
                            ns2 += "\n";
                            break;
                        case 't':
                            ns2 += "\t";
                            break;
                        default:
                            ns2 += ns[i];
                    }
                } else {
                    ns2 += ns[i];
                }
            }
            idx++;
            skipWhitespace();
            return new StringNode(ns2, pos);
        } else {
          return null;
        }
    }
    function parsePlaceholder() {
        var pos = idx;
        if (lookAheadLetter() && s[idx].toLowerCase() === s[idx]) {
            var ns = "";
            while (lookAheadLetter() && idx < s.length) {
                ns += s[idx];
                idx++;
            }
            skipWhitespace();
            return new PlaceholderNode(ns, pos);
        }
        else {
            return null;
        }
    }
    function parseList() {
        var pos = idx;
        if (accept('[')) {
            var items = [];
            idx++;
            skipWhitespace();
            while (!accept(']') && idx < s.length) {
                items.push(parseExp());
                if (accept(',')) {
                    idx++; // skip comma
                    skipWhitespace();
                }
            }
            idx++;
            skipWhitespace();
            return new ListNode(items, pos);
        }
        else {
            return null;
        }
    }
    function parseCons () {
        var pos = idx;
        var ns = "";
        while (!accept('(')) {
            ns += s[idx];
            idx++;
        }
        idx++; // skip (
        var items = [];
        while (!accept(')') && idx < s.length) {
            items.push(parseExp());
            if (accept(',')) {
                idx++; // skip comma
                skipWhitespace();
            }
        }
        idx++;
        skipWhitespace();
        return new ConsNode(ns, items, pos);
    }

    function parseExp() {
        var r = parseInt();
        if (r) return r;
        r = parseString();
        if (r) return r;
        r = parseList();
        if (r) return r;
        r = parsePlaceholder();
        if (r) return r;
        return parseCons();
    }
    return parseExp();
}

var parseCache = {};
function parseCached (s) {
    if(typeof s !== 'string') {
        return null;
    }
    if(s.length > 200) {
        return parse();
    }
    return parseCache[s] || (parseCache[s] = parse(s));
}

exports.Node = Node;
exports.ConsNode = ConsNode;
exports.ListNode = ListNode;
exports.NumNode = NumNode;
exports.StringNode = StringNode;
exports.PlaceholderNode = PlaceholderNode;
exports.parse = parseCached;
exports.inRange = inRange;

});

define("treehugger/js/parse",[], function(require, exports, module) {

var parser = require("acorn/dist/acorn_loose");
var tree = require('treehugger/tree');
exports.parse = function(s) {
    var result = parser.parse_dammit(
        s,
        {
            locations: true,
            ecmaVersion: 6,
            allowReturnOutsideFunction: true
        }
    );
    var node = exports.transform(result);
    if(result.error)
        node.setAnnotation("error", result.error);
    return node;
};


function setIdPos(n, resultNode) {
    if(n.loc) {        
        resultNode.setAnnotation("pos", {
            sl: n.loc.start.line, sc: n.loc.start.column,
            el: n.loc.end.line, ec: n.loc.end.column
        }); 
    }
    return resultNode;
}
function id(n, val) {
    var s = tree.string(val || (n && n.name) || "");
    s.$pos = n && n.loc;
    return s;
}

exports.transform = function transform(n) {
    if (!n) {
        return tree.cons("None", []);
    }
    if (Array.isArray(n)) {
        return tree.list(n.map(transform));
    }
    var nodeName = n.type;
    
    var resultNode;
    
    switch(nodeName) {
        case "Program":
            resultNode = tree.list(n.body.map(transform));
            break;
        case "VariableDeclaration":
            if (n.kind === "var") {
                var VarDecls = "VarDecls", VarDeclInit = "VarDeclInit", VarDecl = "VarDecl";
            } else if (n.kind === "let") {
                var VarDecls = "LetDecls", VarDeclInit = "LetDeclInit", VarDecl = "LetDecl";
            } else if (n.kind === "const") {
                var VarDecls = "ConstDecls", VarDeclInit = "ConstDeclInit", VarDecl = "ConstDecl";
            }
            resultNode = tree.cons(VarDecls, [tree.list(n.declarations.map(function(varNode) {
                var idNode = id(varNode.id);
                if(varNode.init)
                    return tree.cons(VarDeclInit, [idNode, transform(varNode.init)]);
                else
                    return tree.cons(VarDecl, [idNode]);
            }))]);
            break;
        case "ExpressionStatement":
            return transform(n.expression);
        case "CallExpression":
            resultNode = tree.cons("Call", [transform(n.callee), tree.list(n.arguments.map(transform))]);
            break;
        case "ReturnStatement":
            resultNode = tree.cons("Return", [transform(n.argument)]);
            break;
        case "NewExpression":
            resultNode = tree.cons("New", [transform(n.callee), tree.list(n.arguments.map(transform))]);
            break;
        case "ObjectExpression":
            resultNode = tree.cons("ObjectInit", [tree.list(n.properties.map(function(propInit) {
                var key = propInit.key;
                var result = tree.cons("PropertyInit", [id(key, key.name || key.value), transform(propInit.value)]);
                result.kind = propInit.kind;
                return result;
            }))]);
            break;
        case "ArrayExpression":
            resultNode = tree.cons("Array", [tree.list(n.elements.map(transform))]);
            break;
        case "ConditionalExpression":
            resultNode = tree.cons("TernaryIf", [transform(n.test), transform(n.consequent), transform(n.alternate)]);
            break;
        case "LabeledStatement":
            resultNode = tree.cons("Label", [id(n.label), transform(n.body)]);
            break;
        case "AssignmentExpression":
            if(n.operator != "=") {
                resultNode = tree.cons("OpAssign", [tree.string(n.operator[0]), transform(n.left), transform(n.right)]);
            } else {
                resultNode = tree.cons("Assign", [transform(n.left), transform(n.right)]);
            }
            break;
        case "MemberExpression":
            resultNode = n.computed
                ? tree.cons("Index", [transform(n.object), transform(n.property)])
                : tree.cons("PropAccess", [transform(n.object), id(n.property)]);
            break;
        case "Identifier":
            resultNode = tree.cons("Var", [id(n)]);
            break;
        case "ThisExpression":
            resultNode = tree.cons("Var", [tree.string("this")]);
            break;
        case "FunctionDeclaration":
            resultNode = tree.cons("Function", [id(n.id), tree.list(n.params.map(function(arg) {
                return setIdPos(arg, tree.cons("FArg", [id(arg)]));
            })), tree.list(n.body.body.map(transform))]);
            break;
        case "FunctionExpression":
            var funName = id(n.id);
            var fargs = tree.list(n.params.map(function(arg) {
                return setIdPos(arg, tree.cons("FArg", [id(arg)]));
            }));
            resultNode = tree.cons("Function", [funName, fargs, tree.list((n.body.body||[]).map(transform))]);
            break;
        case "LogicalExpression":
        case "BinaryExpression":
            resultNode = tree.cons("Op", [tree.string(n.operator), transform(n.left), transform(n.right)]);
            break;
        case "UpdateExpression":
        case "UnaryExpression":
            resultNode = tree.cons(n.prefix ? "PrefixOp" : "PostfixOp", [tree.string(n.operator), transform(n.argument)]);
            break;
        case "sub":
            resultNode = tree.cons("Index", [transform(n[1]), transform(n[2])]);
            break;
        case "ForStatement":
            resultNode = tree.cons("For", [transform(n.init), transform(n.test), transform(n.update), transform(n.body)]);
            break;
        case "ForInStatement":
            resultNode = tree.cons("ForIn", [transform(n.left), transform(n.right), transform(n.body)]);
            break;
        case "ForOfStatement":
            resultNode = tree.cons("ForOf", [transform(n.left), transform(n.right), transform(n.body)]);
            break;
        case "WhileStatement":
            resultNode = tree.cons("While", [transform(n.test), transform(n.body)]);
            break;
        case "DoWhileStatement": 
            resultNode = tree.cons("Do", [transform(n.body), transform(n.test)]);
            break;
        case "SwitchStatement":
            resultNode = tree.cons("Switch", [transform(n.discriminant), tree.list(n.cases.map(function(opt) {
                return tree.cons("Case", [transform(opt.test), tree.list(opt.consequent.map(transform))]);
            }))]);
            break;
        case "ContinueStatement":
            resultNode = tree.cons("Continue", [id(n.label)]);
            break;
        case "BreakStatement":
            resultNode = tree.cons("Break", [id(n.label)]);
            break;
        case "SequenceExpression":  // todo can we get rid of nesting?
            resultNode = n.expressions.reduceRight(function(a, b) {                
                return a ? tree.cons("Seq", [transform(b), a]) : transform(b);
            }, "");
            break;
        case "IfStatement":
            resultNode = tree.cons("If", [transform(n.test), transform(n.consequent), transform(n.alternate)]);
            break;
        case "EmptyStatement":
        case "BlockStatement":
            resultNode = tree.cons("Block", [tree.list(n.body ? n.body.map(transform) : [])]);
            break;
        case "ThrowStatement":
            resultNode = tree.cons("Throw", [transform(n.argument)]);
            break;
        case "DebuggerStatement":
            resultNode = tree.cons("Debugger", [transform(n.argument)]);
            break;
        case "TryStatement":
            resultNode = tree.cons("Try", [tree.list(n.block.body.map(transform)),
                tree.list(n.handler ? [tree.cons("Catch", [
                    id(n.handler.param), tree.list(n.handler.body.body.map(transform))
                ])] : []),
                n.finalizer ? tree.list(n.finalizer.body.map(transform)) : tree.cons("None", [])
            ]);
            break;
        case "WithStatement":
            resultNode = tree.cons("With", [transform(n.object), tree.list((n.body.body||[]).map(transform))]);
            break;
        case "Literal":
            var litType = typeof n.value;
            if (litType == "number") {
                resultNode = tree.cons("Num", [id(n, n.raw)]);
            } else if (litType == "string") {
                resultNode = tree.cons("String", [id(n, n.value)]);
            } else {
                var val = n.raw;
                if (val[0] == "/") {
                    var i = val.lastIndexOf("/");
                    resultNode = tree.cons("RegExp", [tree.string(val.slice(1, i)), tree.string(val.substr(i + 1))]);
                } else {
                    resultNode = tree.cons("Var", [tree.string(n.value + "")]);
                }
            }
            break;
        case "ERROR":
            resultNode = tree.cons("ERROR", []);
            break;
        case "ArrowFunctionExpression":
            resultNode = tree.cons("Arrow", [tree.list(n.params.map(function(arg) {
                return setIdPos(arg, tree.cons("FArg", [id(arg)]));
            })), tree.list(n.body.body ? n.body.body.map(transform) : transform(n.body))]);
            break;
        case "YieldExpression":
            resultNode = tree.cons("Yield", [transform(n.argument)]);
            break; 
        case "ImportDeclaration":
            resultNode = tree.cons("ImportDecls", [
                tree.list(n.specifiers.map(transform)),
                transform(n.source)
            ]);
            break;
        case "ImportSpecifier":
            resultNode = tree.cons("ImportDecl", [transform(n.id), transform(n.name)]);
            break;
        case "ExportSpecifier":
            resultNode = tree.cons("ExporDecl", [transform(n.id), transform(n.name)]);
            break;
        case "ImportBatchSpecifier":
            resultNode = tree.cons("ImportBatchDecl", [transform(n.name)]);
            break;
        case "ExportDeclaration":
            resultNode = tree.cons("ExportDecl", [
                n.default ? tree.list([tree.cons("Default", [])]) : tree.list([]),
                n.declaration ? transform(n.declaration) : transform(n.specifiers),
                transform(n.source)
            ]);
            break;
        case "SpreadElement":
            resultNode = tree.cons("Spread", [transform(n.argument)]);
            break;
        case "ArrayPattern":
            resultNode = tree.cons("ArrayPattern", transform(n.elements));
            break;
        case "ClassDeclaration":
            resultNode = tree.cons("Class", [id(n.id), id(n.superClass), transform(n.body)]);
            break;
        case "ClassBody":
            resultNode = tree.list(transform(n.body));
            break;
        case "MethodDefinition":
            resultNode = tree.cons("Method", [id(n.key), transform(n.value)]);
            break;
        case "ComprehensionBlock":
        case "ComprehensionExpression":
        default:
            resultNode = tree.cons(tree.string(nodeName), [tree.string(JSON.stringify(n, function(key, val) {
                if (key !== "loc") 
                    return val;
            }, 4))]);
    }

    resultNode.setAnnotation("origin", n);
    resultNode.$pos = n.loc;
    return resultNode;
};
});

define("treehugger/traverse",[], function(require, exports, module) {

var tree = require('treehugger/tree');

if (!Function.prototype.curry) {
    Function.prototype.curry = function() {
        var fn = this,
            args = Array.prototype.slice.call(arguments);
        return function() {
            return fn.apply(this, args.concat(Array.prototype.slice.call(arguments)));
        };
    };
}

function normalizeArgs(args) {
    if (args.length === 1 && args[0].apply) { // basic, one function, shortcut!
        return args[0];
    }
    args = Array.prototype.slice.call(args, 0);
    if (args[0] && Object.prototype.toString.call(args[0]) === '[object Array]') {
        args = args[0];
    }
    return function normalizeArgsHelper() {
        var result;
        for (var i = 0; i < args.length; i++) {
            if (typeof args[i] === 'string') {
                var parsedPattern = tree.parse(args[i]);
                var bindings = parsedPattern.match(this);
                if (bindings) {
                    while (args[i + 1]) {
                        if (args[i + 1].apply)
                            break;
                        i++;
                    }
                    if (args[i + 1] && args[i + 1].apply) {
                        result = args[i + 1].call(this, bindings, this);
                        i++;
                    }
                    else
                        result = this;
                    if (result)
                        return result;
                }
                else if (args[i + 1] && args[i + 1].apply)
                    i++;
            }
            else if (args[i].apply) {
                result = args[i].call(this, this);
                if (result)
                    return result;
            }
            else
                throw Error("Invalid argument: ", args[i]);
        }
        return false;
    };
}

exports.traverseAll = function(fn) {
    var result, i;
    fn = normalizeArgs(arguments);
    if (this instanceof tree.ConsNode || this instanceof tree.ListNode) {
        for (i = 0; i < this.length; i++) {
            result = fn.call(this[i]);
            if (!result)
                return false;
        }
    }
    return this;
};
function seq() {
    var fn;
    var t = this;
    for (var i = 0; i < arguments.length; i++) {
        fn = arguments[i];
        t = fn.call(t);
        if (!t)
            return false;
    }
    return this;
}
exports.attempt = function(fn) {
    fn = normalizeArgs(arguments);
    var result = fn.call(this);
    return !result ? this : result;
};

exports.debug = function(pretty) {
    console.log(pretty ? this.toPrettyString("") : this.toString());
    return this;
};
function traverseTopDown(fn) {
    var result, i;
    result = fn.call(this);
    if(result)
        return result;
    if (this instanceof tree.ConsNode || this instanceof tree.ListNode) {
        for (i = 0; i < this.length; i++) {
            traverseTopDown.call(this[i], fn);
        }
    }
    return this;
}

exports.traverseTopDown = function(fn) {
    fn = normalizeArgs(arguments);
    return traverseTopDown.call(this, fn);
};
exports.traverseUp = function(fn) {
    fn = normalizeArgs(arguments);
    var result = fn.call(this);
    if(result)
        return result;
    if (!this.parent)
        return false;
    return this.parent.traverseUp(fn);
};

exports.collectTopDown = function(fn) {
    fn = normalizeArgs(arguments);
    var results = [];
    this.traverseTopDown(function() {
        var r = fn.call(this);
        if (r) {
            results.push(r);
        }
        return r;
    });
    return tree.list(results);
};

exports.map = function(fn) {
    fn = normalizeArgs(arguments);
    var result, results = [];
    for (var i = 0; i < this.length; i++) {
        result = fn.call(this[i], this[i]);
        if (result) {
            results.push(result);
        }
        else {
            throw Error("Mapping failed: ", this[i]);
        }
    }
    return tree.list(results);
};

exports.each = function(fn) {
    fn = normalizeArgs(arguments);
    for (var i = 0; i < this.length; i++) {
        fn.call(this[i], this[i]);
    }
};
exports.filter = function(fn) {
    fn = normalizeArgs(arguments);
    var matching = [];
    this.forEach(function(el) {
        var result = fn.call(el);
        if (result) {
            matching.push(result);
        }
    });
    return tree.list(matching);
};

exports.rewrite = function(fn) {
    fn = normalizeArgs(arguments);
    return fn.call(this);
};

exports.isMatch = function(pattern) {
    return !!this.rewrite(pattern);
};
for (var p in exports) {
    if (exports.hasOwnProperty(p)) {
        tree.Node.prototype[p] = exports[p];
    }
}

exports.addParentPointers = function(node) {
    return node.traverseTopDown(function() {
        var that = this;
        this.traverseAll(function() {
            this.parent = that;
            return this;
        });
    });
};

});

define("plugins/c9.ide.language/base_handler",[], function(require, exports, module) {

module.exports = {
    HANDLES_ANY: 0,
    HANDLES_EDITOR: 1,
    HANDLES_IMMEDIATE: 2,
    HANDLES_EDITOR_AND_IMMEDIATE: 3,
    language: null,
    path: null,
    workspaceDir: null,
    doc: null,
    $disableZeroLengthCompletion: false,
    $recacheCompletionLength: null,
    isFeatureEnabled: function(name) {
        return !disabledFeatures[name];
    },
    $getIdentifierRegex: function() {
        return null;
    },
    getEmitter: function(overridePath) {
        throw new Error("getEmitter() is not available yet, please call after init()");
    },
    handlesLanguage: function(language) {
        throw new Error("base_handler.handlesLanguage() is not overridden");
    },
    handlesEditor: function() {
        return this.HANDLES_EDITOR;
    },
    getMaxFileSizeSupported: function() {
        return 10 * 1000 * 80;
    },
    getIdentifierRegex: function() {
        return null;
    },
    getCompletionRegex: function() {
        return null;
    },
    getTooltipRegex: function() {
        return null;
    },
    getCacheCompletionRegex: function() {
        return null;
    },
    parse: function(docValue, options, callback) {
        callback();
    },
    findNode: function(ast, pos, callback) {
        callback();
    },
    getPos: function(node, callback) {
        callback();
    },
    init: function(callback) {
        callback();
    },
    onUpdate: function(doc, callback) {
        callback();
    },
    onDocumentOpen: function(path, doc, oldPath, callback) {
        callback();
    },
    onDocumentClose: function(path, callback) {
        callback();
    },
    onCursorMove: function(doc, ast, cursorPos, options, callback) {
        callback();
    },
    tooltip: function(doc, ast, cursorPos, options, callback) {
        callback();
    },
    highlightOccurrences: function(doc, ast, cursorPos, options, callback) {
        callback();
    },
    getRefactorings: function(doc, ast, cursorPos, options, callback) {
        callback();
    },
    outline: function(doc, ast, callback) {
        callback();
    },
    hierarchy: function(doc, cursorPos, callback) {
        callback();
    },
    complete: function(doc, ast, pos, options, callback) {
        callback();
    },
    predictNextCompletion: function(doc, ast, pos, options, callback) {
        callback();
    },
    analyze: function(doc, ast, options, callback) {
        callback();
    },
    getRenamePositions: function(doc, ast, pos, options, callback) {
        callback();
    },
    onRenameBegin: function(doc, callback) {
        callback();
    },
    commitRename: function(doc, oldName, newName, isGeneric, callback) {
        callback();
    },
    onRenameCancel: function(callback) {
        callback();
    },
    codeFormat: function(doc, callback) {
        callback();
    },
    jumpToDefinition: function(doc, ast, pos, options, callback) {
        callback();
    },
    getQuickfixes: function(doc, ast, pos, options, callback) {
        callback();
    },
    getInspectExpression: function(doc, ast, pos, options, callback) {
        callback();
    }
};
for (var f in module.exports) {
    if (typeof module.exports[f] === "function")
        module.exports[f].base_handler = true;
}

});

define("plugins/c9.ide.test.mocha/mocha_outline_worker",[], function(require, exports, module) {

var parser = require("treehugger/js/parse");
var traverse = require("treehugger/traverse");
var baseLanguageHandler = require("plugins/c9.ide.language/base_handler");

var handler = module.exports = Object.create(baseLanguageHandler);

handler.init = function() {
    handler.sender.on("mocha_outline", function(e) {
        var code = e.data.code.replace(/^(#!.*\n)/, "//$1");
        var ast = parser.parse(code);
        
        handler.sender.emit("mocha_outline_result", {
            id: e.data.id, // Some unique id for this request
            result: getTestCases(ast)
        });
    });
};

handler.handlesLanguage = function() {
    return false;
};
function parseBDD(ast, items) {
    ast.traverseTopDown( 
        'Call(Var("before"), _)', function(b, node) {
            items.push({
                label: "before all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("beforeEach"), _)', function(b, node) {
            items.push({
                label: "before each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("after"), _)', function(b, node) {
            items.push({
                label: "after all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("afterEach"), _)', function(b, node) {
            items.push({
                label: "before each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("it"), [String(description), _])', function(b, node) {
            items.push({
                label: b.description.value,
                kind: "it",
                type: "test",
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return true;
        },
        'Call(PropAccess(Var("it"), "only"), [String(description), _])', function(b, node) {
            items.push({
                label: b.description.value,
                kind: "it",
                type: "test",
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("describe"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseBDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        },
        'Call(PropAccess(Var("describe"), "only"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseBDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        },
        'Call(Var("context"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseBDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        },
        'Call(PropAccess(Var("context"), "only"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseBDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        }
    );
    
    return items;
}

function parseTDD(ast, items) {
    ast.traverseTopDown( 
        'Call(Var("setup"), _)', function(b, node) {
            items.push({
                label: "setup",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("teardown"), _)', function(b, node) {
            items.push({
                label: "teardown",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("suiteSetup"), _)', function(b, node) {
            items.push({
                label: "suite setup",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("suiteTeardown"), _)', function(b, node) {
            items.push({
                label: "suite teardown",
                type: "prepare",
                pos: node.getPos()
            });
        },
        'Call(Var("test"), [String(description), _])', function(b, node) {
            items.push({
                label: b.description.value,
                type: "test",
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("suite"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseTDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        }
    );
    
    return items;
}

function parseExports(ast, items) {
    ast.traverseTopDown(
        'Assign(PropAccess(Var("module"), "exports"), body)', function(b) {
            parseExports(b.body, items); 
            return true;
        },
        'PropertyInit("before", _)', function(b, node) {
            items.push({
                label: "before all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'PropertyInit("after", _)', function(b, node) {
            items.push({
                label: "after all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'PropertyInit("beforeEach", _)', function(b, node) {
            items.push({
                label: "before each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'PropertyInit("afterEach", _)', function(b, node) {
            items.push({
                label: "after each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'PropertyInit(name, ObjectInit(body))', function(b, node) {
           items.push({
                label: b.name.value,
                items: parseExports(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.name.getPos(),
                pos: node.getPos()
            });
           return true;
        },
        'PropertyInit(name, Function(_))', function(b, node) {
           items.push({
                label: b.name.value,
                type: "test",
                selpos: b.name.getPos(),
                pos: node.getPos()
            });
            return true;
        }
    );
    
    return items;
}

function parseQUnit(ast, items) {
    var context = items;
    
    ast.traverseTopDown( 
        'Call(Var("before"), _)', function(b, node) {
            context.push({
                label: "before all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("after"), _)', function(b, node) {
            context.push({
                label: "after all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("beforeEach"), _)', function(b, node) {
            context.push({
                label: "before each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("afterEach"), _)', function(b, node) {
            context.push({
                label: "after each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("test"), [String(description), _])', function(b, node) {
            context.push({
                label: b.description.value,
                type: "test",
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("suite"), [String(description)])', function(b, node) {
            context.push({
                label: b.description.value,
                items: context = [],
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        }
    );
}

function getTestCases(ast) {
    var items = [];
    ast.traverseTopDown(
        'Call(Var("describe"), [_, body])', function(b, node) {
            parseBDD(ast, items);
            return true;
        },
        'Call(Var("suite"), [_, body])', function(b, node) {
            parseTDD(ast, items);
            return true;
        },
        'Assign(PropAccess(Var("module"), "exports"), body)', function(b) {
            parseExports(b.body, items);
            return true;
        },
        'Call(Var("suite"), [_])', function(b, node) {
            parseQUnit(ast, items);
            return true;
        }
    );
    
    return items;
}

});

define("ace/lib/es6-shim",[], function(require, exports, module) {
    function defineProp(obj, name, val) {
        Object.defineProperty(obj, name, {
            value: val,
            enumerable: false,
            writable: true,
            configurable: true,
        });
    }
    if (!String.prototype.startsWith) {
        defineProp(String.prototype, "startsWith", function(searchString, position) {
            position = position || 0;
            return this.lastIndexOf(searchString, position) === position;
        });
    }
    if (!String.prototype.endsWith) {
        defineProp(String.prototype, "endsWith", function(searchString, position) {
            var subjectString = this;
            if (position === undefined || position > subjectString.length) {
                position = subjectString.length;
            }
            position -= searchString.length;
            var lastIndex = subjectString.indexOf(searchString, position);
            return lastIndex !== -1 && lastIndex === position;
        });
    }
    if (!String.prototype.repeat) {
        defineProp(String.prototype, "repeat", function(count) {
            var result = "";
            var string = this;
            while (count > 0) {
                if (count & 1)
                    result += string;
        
                if (count >>= 1)
                    string += string;
            }
            return result;
        });
    }
    if (!String.prototype.includes) {
        defineProp(String.prototype, "includes", function(str, position) {
            return this.indexOf(str, position != -1);
        });
    }
    if (!Object.assign) {
        Object.assign = function (target) {
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && source !== null) {
                    Object.keys(source).forEach(function(key) {
                        output[key] = source[key];
                    });
                }
            }
            return output;
        };
    }

});

define("ace/lib/oop",[], function(require, exports, module) {
"use strict";

exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};

exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};

});

define("ace/range",[], function(require, exports, module) {
"use strict";
var comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
var Range = function(startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };

    this.end = {
        row: endRow,
        column: endColumn
    };
};

(function() {
    this.isEqual = function(range) {
        return this.start.row === range.start.row &&
            this.end.row === range.end.row &&
            this.start.column === range.start.column &&
            this.end.column === range.end.column;
    };
    this.toString = function() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    };

    this.contains = function(row, column) {
        return this.compare(row, column) == 0;
    };
    this.compareRange = function(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    };
    this.comparePoint = function(p) {
        return this.compare(p.row, p.column);
    };
    this.containsRange = function(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };
    this.intersects = function(range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function(row, column) {
        return this.end.row == row && this.end.column == column;
    };
    this.isStart = function(row, column) {
        return this.start.row == row && this.start.column == column;
    };
    this.setStart = function(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    this.setEnd = function(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    this.inside = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideStart = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideEnd = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.compare = function(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            }
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    };
    this.compareStart = function(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareEnd = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareInside = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.clipRows = function(firstRow, lastRow) {
        if (this.end.row > lastRow)
            var end = {row: lastRow + 1, column: 0};
        else if (this.end.row < firstRow)
            var end = {row: firstRow, column: 0};

        if (this.start.row > lastRow)
            var start = {row: lastRow + 1, column: 0};
        else if (this.start.row < firstRow)
            var start = {row: firstRow, column: 0};

        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.isEmpty = function() {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
    };
    this.isMultiLine = function() {
        return (this.start.row !== this.end.row);
    };
    this.clone = function() {
        return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);
        else
            return new Range(this.start.row, 0, this.end.row, 0);
    };
    this.toScreenRange = function(session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    };
    this.moveBy = function(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };

}).call(Range.prototype);
Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;

Range.comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};


exports.Range = Range;
});

define("ace/apply_delta",[], function(require, exports, module) {
"use strict";

function throwDeltaError(delta, errorText){
    console.log("Invalid Delta:", delta);
    throw "Invalid Delta: " + errorText;
}

function positionInDocument(docLines, position) {
    return position.row    >= 0 && position.row    <  docLines.length &&
           position.column >= 0 && position.column <= docLines[position.row].length;
}

function validateDelta(docLines, delta) {
    if (delta.action != "insert" && delta.action != "remove")
        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, "delta.lines must be an Array");
    if (!delta.start || !delta.end)
       throwDeltaError(delta, "delta.start/end must be an present");
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, "delta.start must be contained in document");
    var end = delta.end;
    if (delta.action == "remove" && !positionInDocument(docLines, end))
        throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, "delta.range must match delta lines");
}

exports.applyDelta = function(docLines, delta, doNotValidate) {
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || "";
    switch (delta.action) {
        case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
                docLines.splice(
                    row, endRow - row + 1,
                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
                );
            }
            break;
    }
};
});

define("ace/lib/event_emitter",[], function(require, exports, module) {
"use strict";

var EventEmitter = {};
var stopPropagation = function() { this.propagationStopped = true; };
var preventDefault = function() { this.defaultPrevented = true; };

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    if (typeof e != "object" || !e)
        e = {};

    if (!e.type)
        e.type = eventName;
    if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
    if (!e.preventDefault)
        e.preventDefault = preventDefault;

    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
            break;
    }
    
    if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
};


EventEmitter._signal = function(eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++)
        listeners[i](e, this);
};

EventEmitter.once = function(eventName, callback) {
    var _self = this;
    callback && this.addEventListener(eventName, function newCallback() {
        _self.removeEventListener(eventName, newCallback);
        callback.apply(null, arguments);
    });
};


EventEmitter.setDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        handlers = this._defaultHandlers = {_disabled_: {}};
    
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1) 
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    
    if (handlers[eventName] == callback) {
        var old = handlers[eventName];
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
    return callback;
};

EventEmitter.off =
EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};

EventEmitter.removeAllListeners = function(eventName) {
    if (this._eventRegistry) this._eventRegistry[eventName] = [];
};

exports.EventEmitter = EventEmitter;

});

define("ace/anchor",[], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var Anchor = exports.Anchor = function(doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    
    if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};

(function() {

    oop.implement(this, EventEmitter);
    this.getPosition = function() {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function() {
        return this.document;
    };
    this.$insertRight = false;
    this.onChange = function(delta) {
        if (delta.start.row == delta.end.row && delta.start.row != this.row)
            return;

        if (delta.start.row > this.row)
            return;
            
        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    };
    
    function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
    }
            
    function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
                row: point.row,
                column: point.column
            };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
                row: point.row + deltaRowShift,
                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
        }
        return {
            row: deltaStart.row,
            column: deltaStart.column
        };
    }
    this.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        } else {
            pos = this.$clipPositionToDocument(row, column);
        }

        if (this.row == pos.row && this.column == pos.column)
            return;

        var old = {
            row: this.row,
            column: this.column
        };

        this.row = pos.row;
        this.column = pos.column;
        this._signal("change", {
            old: old,
            value: pos
        });
    };
    this.detach = function() {
        this.document.removeEventListener("change", this.$onChange);
    };
    this.attach = function(doc) {
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
    };
    this.$clipPositionToDocument = function(row, column) {
        var pos = {};

        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }

        if (column < 0)
            pos.column = 0;

        return pos;
    };

}).call(Anchor.prototype);

});

define("ace/document",[], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var applyDelta = require("./apply_delta").applyDelta;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Anchor = require("./anchor").Anchor;

var Document = function(textOrLines) {
    this.$lines = [""];
    if (textOrLines.length === 0) {
        this.$lines = [""];
    } else if (Array.isArray(textOrLines)) {
        this.insertMergedLines({row: 0, column: 0}, textOrLines);
    } else {
        this.insert({row: 0, column:0}, textOrLines);
    }
};

(function() {

    oop.implement(this, EventEmitter);
    this.setValue = function(text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({row: 0, column: 0}, text);
    };
    this.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function(row, column) {
        return new Anchor(this, row, column);
    };
    if ("aaa".split(/a/).length === 0) {
        this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
        };
    } else {
        this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
        };
    }


    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
        this._signal("changeNewLineMode");
    };
    this.getNewLineCharacter = function() {
        switch (this.$newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this.$autoNewLine || "\n";
        }
    };

    this.$autoNewLine = "";
    this.$newLineMode = "auto";
    this.setNewLineMode = function(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
        this._signal("changeNewLineMode");
    };
    this.getNewLineMode = function() {
        return this.$newLineMode;
    };
    this.isNewLine = function(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    };
    this.getLine = function(row) {
        return this.$lines[row] || "";
    };
    this.getLines = function(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function() {
        return this.getLines(0, this.getLength());
    };
    this.getLength = function() {
        return this.$lines.length;
    };
    this.getTextRange = function(range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    this.getLinesForRange = function(range) {
        var lines;
        if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        } else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    };
    this.insertLines = function(row, lines) {
        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
        return this.insertFullLines(row, lines);
    };
    this.removeLines = function(firstRow, lastRow) {
        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
        return this.removeFullLines(firstRow, lastRow);
    };
    this.insertNewLine = function(position) {
        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
        return this.insertMergedLines(position, ["", ""]);
    };
    this.insert = function(position, text) {
        if (this.getLength() <= 1)
            this.$detectNewLine(text);
        
        return this.insertMergedLines(position, this.$split(text));
    };
    this.insertInLine = function(position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
        }, true);
        
        return this.clonePos(end);
    };
    
    this.clippedPos = function(row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        } else if (row < 0) {
            row = 0;
        } else if (row >= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return {row: row, column: column};
    };
    
    this.clonePos = function(pos) {
        return {row: pos.row, column: pos.column};
    };
    
    this.pos = function(row, column) {
        return {row: row, column: column};
    };
    
    this.$clipPosition = function(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    };
    this.insertFullLines = function(row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row < this.getLength()) {
            lines = lines.concat([""]);
            column = 0;
        } else {
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        this.insertMergedLines({row: row, column: column}, lines);
    };
    this.insertMergedLines = function(position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
        });
        
        return this.clonePos(end);
    };
    this.remove = function(range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        });
        return this.clonePos(start);
    };
    this.removeInLine = function(row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        }, true);
        
        return this.clonePos(start);
    };
    this.removeFullLines = function(firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
        var deleteLastNewLine  = lastRow  < this.getLength() - 1;
        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
        var range = new Range(startRow, startCol, endRow, endCol);
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
        });
        return deletedLines;
    };
    this.removeNewLine = function(row) {
        if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
            });
        }
    };
    this.replace = function(range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 && range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        
        return end;
    };
    this.applyDeltas = function(deltas) {
        for (var i=0; i<deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    };
    this.revertDeltas = function(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            this.revertDelta(deltas[i]);
        }
    };
    this.applyDelta = function(delta, doNotValidate) {
        var isInsert = delta.action == "insert";
        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        
        if (isInsert && delta.lines.length > 20000) {
            this.$splitAndapplyLargeDelta(delta, 20000);
        }
        else {
            applyDelta(this.$lines, delta, doNotValidate);
            this._signal("change", delta);
        }
    };
    
    this.$splitAndapplyLargeDelta = function(delta, MAX) {
        var lines = delta.lines;
        var l = lines.length - MAX + 1;
        var row = delta.start.row; 
        var column = delta.start.column;
        for (var from = 0, to = 0; from < l; from = to) {
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            chunk.push("");
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        }
        delta.lines = lines.slice(from);
        delta.start.row = row + from;
        delta.start.column = column;
        this.applyDelta(delta, true);
    };
    this.revertDelta = function(delta) {
        this.applyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == "insert" ? "remove" : "insert"),
            lines: delta.lines.slice()
        });
    };
    this.indexToPosition = function(index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
                return {row: i, column: index + lines[i].length + newlineLength};
        }
        return {row: l-1, column: index + lines[l-1].length + newlineLength};
    };
    this.positionToIndex = function(pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;

        return index + pos.column;
    };

}).call(Document.prototype);

exports.Document = Document;
});

define("ace/lib/lang",[], function(require, exports, module) {
"use strict";

exports.last = function(a) {
    return a[a.length - 1];
};

exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
        if (count & 1)
            result += string;

        if (count >>= 1)
            string += string;
    }
    return result;
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};

exports.copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
        else 
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== "[object Object]")
        return obj;
    
    copy = {};
    for (var key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

exports.createMap = function(props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.escapeHTML = function(str) {
    return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
};

exports.getMatchOffsets = function(string, regExp) {
    var matches = [];

    string.replace(regExp, function(str) {
        matches.push({
            offset: arguments[arguments.length-2],
            length: str.length
        });
    });

    return matches;
};
exports.deferredCall = function(fcn) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    
    deferred.isPending = function() {
        return timer;
    };

    return deferred;
};


exports.delayedCall = function(fcn, defaultTimeout) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var _self = function(timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };

    _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;

    _self.call = function() {
        this.cancel();
        fcn();
    };

    _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
    };

    _self.isPending = function() {
        return timer;
    };

    return _self;
};
});

define("ace/worker/mirror",[], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var Document = require("../document").Document;
var lang = require("../lib/lang");
    
var Mirror = exports.Mirror = function(sender) {
    this.sender = sender;
    var doc = this.doc = new Document("");
    
    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));
    
    var _self = this;
    sender.on("change", function(e) {
        var data = e.data;
        if (data[0].start) {
            doc.applyDeltas(data);
        } else {
            for (var i = 0; i < data.length; i += 2) {
                var d, err; 
                if (Array.isArray(data[i+1])) {
                    d = {action: "insert", start: data[i], lines: data[i+1]};
                } else {
                    d = {action: "remove", start: data[i], end: data[i+1]};
                }
                
                if ((d.action == "insert" ? d.start : d.end).row >= doc.$lines.length) {
                    err = new Error("Invalid delta");
                    err.data = {
                        path: _self.$path,
                        linesLength: doc.$lines.length,
                        start: d.start,
                        end: d.end
                    };
                    throw err;
                }

                doc.applyDelta(d, true);
            }
        }
        if (_self.$timeout)
            return deferredUpdate.schedule(_self.$timeout);
        _self.onUpdate();
    });
};

(function() {
    
    this.$timeout = 500;
    
    this.setTimeout = function(timeout) {
        this.$timeout = timeout;
    };
    
    this.setValue = function(value) {
        this.doc.setValue(value);
        this.deferredUpdate.schedule(this.$timeout);
    };
    
    this.getValue = function(callbackId) {
        this.sender.callback(this.doc.getValue(), callbackId);
    };
    
    this.onUpdate = function() {
    };
    
    this.isPending = function() {
        return this.deferredUpdate.isPending();
    };
    
}).call(Mirror.prototype);

});

define("plugins/c9.ide.language.core/syntax_detector",[], function(require, exports, module) {

var mixedLanguages = {
    php: {
        "default": "html",
        "php-start": /<\?(?:php|\=)?/,
        "php-end": /\?>/,
        "css-start": /<style[^>]*>/,
        "css-end": /<\/style>/,
        "javascript-start": /<script(?:\"[^\"]*\"|'[^']*'|[^'">])*>/,
        "javascript-end": /<\/script>/
    },
    html: {
        "css-start": /<style[^>]*>/,
        "css-end": /<\/style>/,
        "javascript-start": /<script(?:\"[^\"]*\"|'[^']*'|[^'">])*>/,
        "javascript-end": /<\/script>/
    }
};
mixedLanguages.handlebars = mixedLanguages.html;
var scriptTypeTests = {
    javascript: function(v) {
        var m = /type\s*=\s*("[^"]+"|'[^']+'|[^\s'">]+)/.exec(v);
        if (m && !/javascript|ecmascript/i.test(m[1]))
            return false;
        return true;
    }
};
function getSyntaxRegions(doc, originalSyntax) {
     if (!mixedLanguages[originalSyntax])
        return [{
            syntax: originalSyntax,
            sl: 0,
            sc: 0,
            el: doc.getLength() - 1,
            ec: doc.getLine(doc.getLength() - 1).length
        }];

    var lines = doc.getAllLines();
    var type = mixedLanguages[originalSyntax];
    var defaultSyntax = type["default"] || originalSyntax;
    var starters = Object.keys(type).filter(function (m) {
        return m.indexOf("-start") === m.length - 6;
    });
    var syntax = defaultSyntax;
    var regions = [{ syntax: syntax, sl: 0, sc: 0 }];
    var starter, endLang;
    var tempS, tempM;
    var i, m, cut, inLine = 0;

    for (var row = 0; row < lines.length; row++) {
        var line = lines[row];
        m = null;
        if (endLang) {
            m = endLang.exec(line);
            if (m) {
                endLang = null;
                syntax = defaultSyntax;
                regions[regions.length - 1].el = row;
                regions[regions.length - 1].ec = m.index + inLine;
                regions.push({
                    syntax: syntax,
                    sl: row,
                    sc: m.index + inLine
                });
                cut = m.index + m[0].length;
                lines[row] = line.substring(cut);
                inLine += cut;
                row--; // continue processing of the line
            }
            else {
                inLine = 0;
            }
        }
        else {
            for (i = 0; i < starters.length; i++) {
                tempS = starters[i];
                tempM = type[tempS].exec(line);
                if (tempM && (!m || m.index > tempM.index)) {
                    m = tempM;
                    starter = tempS;
                }
            }
            if (m) {
                syntax = starter.replace("-start", "");
                if (scriptTypeTests[syntax] && !scriptTypeTests[syntax](m[0]))
                    syntax = defaultSyntax;
                endLang = type[syntax + "-end"];
                regions[regions.length - 1].el = row;
                regions[regions.length - 1].ec = inLine + m.index + m[0].length;
                regions.push({
                    syntax: syntax,
                    sl: row,
                    sc: inLine + m.index + m[0].length
                });
                cut = m.index + m[0].length;
                lines[row] = line.substring(m.index + m[0].length);
                row--; // continue processing of the line
                inLine += cut;
            }
            else {
                inLine = 0;
            }
        }
    }
    regions[regions.length - 1].el = lines.length;
    regions[regions.length - 1].ec = lines[lines.length - 1].length;
    return regions;
}

function getContextSyntaxPart(doc, pos, originalSyntax) {
     if (!mixedLanguages[originalSyntax]) {
        var value;
        var result = {
            language: originalSyntax,
            region: getSyntaxRegions(doc, originalSyntax)[0],
            index: 0,
            getLine: function(l) {
                return doc.getLine(l);
            },
            getLines: function(firstRow, lastRow) {
                return doc.getLines(firstRow, lastRow);
            },
            getAllLines: function() {
                return doc.getAllLines();
            },
            getValue: function() {
                if (!value)
                    value = doc.getValue();
                return value;
            },
            getLength: function() {
                return doc.getLength();
            }
        };
        result.__defineGetter__("value", function() {
            console.error("part.value is deprecated: use getValue() instead");
            return this.getValue();
        });
        return result;
    }
    var regions = getSyntaxRegions(doc, originalSyntax);
    for (var i = 0; i < regions.length; i++) {
        var region = regions[i];
        if ((pos.row > region.sl && pos.row < region.el) ||
            (pos.row === region.sl && pos.column >= region.sc && pos.column <= region.ec))
            return regionToCodePart(doc, region, i);
    }
    return null; // should never happen
}

function getContextSyntax(doc, pos, originalSyntax) {
    var part = getContextSyntaxPart(doc, pos, originalSyntax);
    return part && part.language; // should never happen
}

function regionToCodePart(doc, region, index) {
    var lines = doc.getLines(region.sl, region.el);
    if (!lines.length) {
        console.error("region and document state are not consistent!!!");
        lines = [""];
    }
    var allLines;
    var value;
    var result = {
        language: region.syntax,
        region: region,
        index: index,
        getLines: function(firstRow, lastRow) {
            return this.getAllLines().slice(firstRow, lastRow + 1);
        },
        getLine: function(l) {
            if (region.sl === region.el)
                return lines[0].substring(region.sc, region.ec);
            if (l === 0)
                return lines[0].substring(region.sc);
            if (l === lines.length - 1)
                return lines[lines.length - 1].substring(0, region.ec);
            return lines[l];
        },
        getAllLines: function() {
            if (!allLines)
                allLines = region.sl === region.el
                    ? [lines[0].substring(region.sc, region.ec)]
                    : [lines[0].substring(region.sc)].concat(lines.slice(1, lines.length - 1)).concat([lines[lines.length - 1].substring(0, region.ec)]);
            return allLines;
        },
        getValue: function() {
            if (!value)
                value = this.getAllLines().join(doc.getNewLineCharacter());
            return value;
        },
        getLength: function() {
            return region.el - region.sl + 1;
        }
    };
    result.__defineGetter__("value", function() {
        console.error("part.value is deprecated: use getValue() instead");
        return this.getValue();
    });
    return result;
}

function getCodeParts(doc, originalSyntax) {
    var regions = getSyntaxRegions(doc, originalSyntax);
    return regions.map(function (region, i) {
        return regionToCodePart(doc, region, i);
    });
}

function posToRegion(region, pos) {
    if ("row" in pos)
        return {
            row: pos.row - region.sl,
            column: pos.column,
            path: pos.path
        };
    return {
        sl: pos.sl - region.sl,
        column: pos.sc,
        el: pos.el - region.sl,
        ec: pos.ec,
        path: pos.path
    };
}

function posFromRegion(region, pos) {
    if ("row" in pos)
        return {
            row: pos.row + region.sl,
            column: pos.column,
            path: pos.path
        };
    return {
        sl: pos.sl + region.sl,
        sc: pos.sc,
        el: pos.el + region.sl,
        ec: pos.ec,
        path: pos.path
    };
}

exports.getContextSyntax = getContextSyntax;
exports.getContextSyntaxPart = getContextSyntaxPart;
exports.getSyntaxRegions = getSyntaxRegions;
exports.getCodeParts = getCodeParts;
exports.posToRegion = posToRegion;
exports.posFromRegion = posFromRegion;

});

define("plugins/c9.ide.language/complete_util",[], function(require, exports, module) {

var ID_REGEX = /[a-zA-Z_0-9\$]/;
var REQUIRE_ID_REGEX = /(?!["'])./;
var staticPrefix = "";

function retrievePrecedingIdentifier(line, offset, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = offset - 1; i >= 0 && line; i--) {
        if (regex.test(line[i]))
            buf.push(line[i]);
        else
            break;
    }
    return buf.reverse().join("");
}

function retrieveFollowingIdentifier(line, offset, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = offset; line && i < line.length; i++) {
        if (regex.test(line[i]))
            buf.push(line[i]);
        else
            break;
    }
    return buf.join("");
}

function prefixBinarySearch(items, prefix) {
    var startIndex = 0;
    var stopIndex = items.length - 1;
    var middle = Math.floor((stopIndex + startIndex) / 2);
    
    while (stopIndex > startIndex && middle >= 0 && items[middle].indexOf(prefix) !== 0) {
        if (prefix < items[middle]) {
            stopIndex = middle - 1;
        }
        else if (prefix > items[middle]) {
            startIndex = middle + 1;
        }
        middle = Math.floor((stopIndex + startIndex) / 2);
    }
    while (middle > 0 && items[middle - 1].indexOf(prefix) === 0)
        middle--;
    return middle >= 0 ? middle : 0; // ensure we're not returning a negative index
}

function findCompletions(prefix, allIdentifiers) {
    allIdentifiers.sort();
    var startIdx = prefixBinarySearch(allIdentifiers, prefix);
    var matches = [];
    for (var i = startIdx; i < allIdentifiers.length && allIdentifiers[i].indexOf(prefix) === 0; i++)
        matches.push(allIdentifiers[i]);
    return matches;
}

function fetchTextSync(path) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', staticPrefix + "/" + path, false);
    try {
        xhr.send();
    }
    catch (e) {
        return false;
    }
    if (xhr.status === 200 || xhr.responseText) // when loading from file:// status is always 0
        return xhr.responseText;
    else
        return false;
}

function fetchText(path, callback) {
    var xhr = new XMLHttpRequest();
    try {
        xhr.open('GET', staticPrefix + "/" + path, true);
    } catch (e) {
        return done(e);
    }
    xhr.onload = function (e) {
        if (xhr.readyState !== 4)
            return;
        if (xhr.status !== 200 && xhr.status !== 0)
            return done(new Error(xhr.statusText));
        done(null, xhr.responseText);
    };
    xhr.onerror = done;
    xhr.send(null);
    
    function done(err, result) {
        callback && callback(err, result);
        callback = null;
        if (err) {
            err.data = { path: path };
            setTimeout(function() { throw err; });
        }
    }
}

function setStaticPrefix(url) {
    staticPrefix = url;
}
function canCompleteForChangedLine(oldLine, newLine, oldPos, newPos, identifierRegex) {
    if (newLine.indexOf(oldLine.substr(0, oldPos.column)) !== 0)
        return false;
    
    for (var i = oldPos.column; i < newPos.column; i++) {
        if (!identifierRegex.test(newLine[i]))
            return false;
    }
    return true;
}

function precededByIdentifier(line, column, postfix, ace) {
    var id = retrievePrecedingIdentifier(line, column);
    if (postfix) id += postfix;
    return id !== "" && !(id[0] >= '0' && id[0] <= '9') 
        && (inCompletableCodeContext(line, column, id, ace) 
        || isRequireJSCall(line, column, id, ace));
}

function isRequireJSCall(line, column, identifier, ace, noQuote) {
    if (["javascript", "jsx"].indexOf(ace.getSession().syntax) === -1)
        return false;
    var id = identifier == null ? retrievePrecedingIdentifier(line, column, REQUIRE_ID_REGEX) : identifier;
    var LENGTH = 'require("'.length - (noQuote ? 1 : 0);
    var start = column - id.length - LENGTH;
    var substr = line.substr(start, LENGTH) + (noQuote ? '"' : '');

    return start >= 0 && substr.match(/require\(["']/)
        || line.substr(start + 1, LENGTH).match(/require\(["']/);
}
function inCompletableCodeContext(line, column, id, ace) {
    if (["javascript", "jsx"].indexOf(ace.getSession().syntax) === -1)
        return true;
    var isJavaScript = true;
    var inMode = null;
    for (var i = 0; i < column; i++) {
        if (line[i] === '"' && !inMode)
            inMode = '"';
        else if (line[i] === '"' && inMode === '"' && line[i - 1] !== "\\")
            inMode = null;
        else if (line[i] === "'" && !inMode)
            inMode = "'";
        else if (line[i] === "'" && inMode === "'" && line[i - 1] !== "\\")
            inMode = null;
        else if (line[i] === "/" && line[i + 1] === "/") {
            inMode = '//';
            i++;
        }
        else if (line[i] === "/" && line[i + 1] === "*" && !inMode) {
            if (line.substr(i + 2, 6) === "global")
                continue;
            inMode = '/*';
            i++;
        }
        else if (line[i] === "*" && line[i + 1] === "/" && inMode === "/*") {
            inMode = null;
            i++;
        }
        else if (line[i] === "/" && !inMode && isJavaScript)
            inMode = "/";
        else if (line[i] === "/" && inMode === "/" && line[i - 1] !== "\\")
            inMode = null;
    }
    return inMode != "/";
}
exports.precededByIdentifier = precededByIdentifier;
exports.isRequireJSCall = isRequireJSCall;
exports.retrievePrecedingIdentifier = retrievePrecedingIdentifier;
exports.retrieveFollowingIdentifier = retrieveFollowingIdentifier;
exports.findCompletions = findCompletions;
exports.fetchText = fetchText;
exports.fetchTextSync = fetchTextSync;
exports.setStaticPrefix = setStaticPrefix;
exports.DEFAULT_ID_REGEX = ID_REGEX;
exports.canCompleteForChangedLine = canCompleteForChangedLine;
});

define("plugins/c9.ide.language.generic/local_completer",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var completeUtil = require("plugins/c9.ide.language/complete_util");

var MAX_SIZE_BYTES = 5 * 1000 * 1000;
var DEFAULT_SPLIT_REGEX = /[^a-zA-Z_0-9\$]+/;
var MAX_SCORE = 1000000;
var TRUNCATE_LINES = 10000;

var completer = module.exports = Object.create(baseLanguageHandler);
    
completer.handlesLanguage = function(language) {
    return true;
};

completer.handlesEditor = function() {
    return this.HANDLES_ANY;
};

completer.getMaxFileSizeSupported = function() {
    return MAX_SIZE_BYTES;
};
function wordDistanceAnalyzer(doc, pos, prefix, suffix) {
    var splitRegex = getSplitRegex(pos);
    var linesBefore = doc.getLines(Math.max(0, pos.row - TRUNCATE_LINES / 2), pos.row - 1);
    var linesAfter = doc.getLines(pos.row + 1, Math.min(doc.getLength(), pos.row + TRUNCATE_LINES / 2));
    var textBefore = linesBefore.join("\n");
    var textAfter = linesAfter.join("\n");
    var line = getFilteredLine(doc.getLine(pos.row), pos.column, prefix, suffix);
    var identifiers = textBefore.split(splitRegex);
    var prefixPosition = identifiers.length;
    identifiers = identifiers.concat(line.split(splitRegex), textAfter.split(splitRegex));
    var identDict = Object.create(null);
    for (var i = 0; i < identifiers.length; i++) {
        var ident = identifiers[i];
        if (ident.length === 0)
            continue;
        var distance = Math.max(prefixPosition, i) - Math.min(prefixPosition, i);
        if (identDict[ident])
            identDict[ident] = Math.max(MAX_SCORE - distance, identDict[ident]);
        else
            identDict[ident] = MAX_SCORE - distance;
        
    }
    return identDict;
}

function getSplitRegex(pos) {
    var idRegex = completer.$getIdentifierRegex(pos);
    if (!idRegex || !idRegex.source.match(/\[[^^][^\]]*\]/))
        return DEFAULT_SPLIT_REGEX;
    return new RegExp("[^" + idRegex.source.substr(1, idRegex.source.length - 2) + "]+");
}

function getFilteredLine(line, column, prefix, suffix) {
    return line.substr(0, column - prefix.length)
        + line.substr(column + suffix.length);
}

function analyze(doc, pos) {
    var line = doc.getLine(pos.row);
    var prefix = completeUtil.retrievePrecedingIdentifier(line, pos.column, completer.$getIdentifierRegex());
    var suffix = completeUtil.retrieveFollowingIdentifier(line, pos.column, completer.$getIdentifierRegex());
    return wordDistanceAnalyzer(doc, pos, prefix, suffix);
}
    
completer.complete = function(doc, fullAst, pos, options, callback) {
    var identDict = analyze(doc, pos);
    var line = doc.getLine(pos.row);
    var regex = this.$getIdentifierRegex(pos);
    var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, regex);
    var fullIdentifier = identifier + completeUtil.retrieveFollowingIdentifier(line, pos.column, regex);
         
    var allIdentifiers = [];
    for (var ident in identDict) {
        allIdentifiers.push(ident);
    }
    var matches = completeUtil.findCompletions(identifier, allIdentifiers);
    
    matches = matches.slice(0, 100); // limits results for performance

    var allowSlashes = regex && regex.source.match(/^\[.*\/.*]/);
    var allowDollars = regex && regex.source.match(/\$\$/);
    
    callback(null, matches.filter(function(m) {
        if (allowDollars) {
            return !m.match(allowSlashes ? /^([0-9_\/]|\/[^\/])/ : /^[0-9_\/]/);
        }  
        else {
            return !m.match(allowSlashes ? /^([0-9$_\/]|\/[^\/])/ : /^[0-9$_\/]/);
        }
    }).map(function(m) {
        return {
          name: m,
          replaceText: m,
          icon: null,
          score: m === fullIdentifier ? MAX_SCORE : identDict[m],
          isGeneric: true,
          priority: 0,
          $source: "local"
        };
    }));
};

});

define("plugins/c9.ide.language.generic/open_files_local_completer",[], function(require, exports, module) {

var completeUtil = require("plugins/c9.ide.language/complete_util");

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var analysisCache = {}; // path => {identifier: 3, ...}
var globalWordIndex = {}; // word => frequency
var globalWordFiles = {}; // word => [path]
var precachedPath;
var precachedDoc;

var completer = module.exports = Object.create(baseLanguageHandler);

completer.handlesLanguage = function(language) {
    return true;
};

completer.handlesEditor = function() {
    return this.HANDLES_ANY;
};

completer.getMaxFileSizeSupported = function() {
    return 1000 * 1000;
};

function frequencyAnalyzer(path, text, identDict, fileDict) {
    var identifiers = text.split(/[^a-zA-Z_0-9\$]+/);
    for (var i = 0; i < identifiers.length; i++) {
        var ident = identifiers[i];
        if (!ident)
            continue;
            
        if (Object.prototype.hasOwnProperty.call(identDict, ident)) {
            identDict[ident]++;
            fileDict[ident][path] = true;
        }
        else {
            identDict[ident] = 1;
            fileDict[ident] = {};
            fileDict[ident][path] = true;
        }
    }
    return identDict;
}

function removeDocumentFromCache(path) {
    var analysis = analysisCache[path];
    if (!analysis) return;

    for (var id in analysis) {
        globalWordIndex[id] -= analysis[id];
        delete globalWordFiles[id][path];
        if (globalWordIndex[id] === 0) {
            delete globalWordIndex[id];
            delete globalWordFiles[id];
        }
    }
    delete analysisCache[path];
}

function analyzeDocument(path, allCode) {
    if (!analysisCache[path]) {
        if (allCode.size > 80 * 10000) {
            delete analysisCache[path];
            return;
        }
        analysisCache[path] = frequencyAnalyzer(path, allCode, {}, {});
        frequencyAnalyzer(path, allCode, globalWordIndex, globalWordFiles);
    }
}

completer.onDocumentOpen = function(path, doc, oldPath, callback) {
    if (!analysisCache[path]) {
        analyzeDocument(path, doc.getValue());
    }
    callback();
};
    
completer.onDocumentClose = function(path, callback) {
    removeDocumentFromCache(path);
    if (path == precachedPath)
        precachedDoc = null;
    callback();
};

completer.analyze = function(doc, ast, callback) {
    if (precachedDoc && this.path !== precachedPath) {
        removeDocumentFromCache(precachedPath);
        analyzeDocument(precachedPath, precachedDoc);
        precachedDoc = null;
    }
    precachedPath = this.path;
    precachedDoc = doc;
    callback();
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    var line = doc.getLine(pos.row);
    var regex = this.$getIdentifierRegex(pos);
    var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, regex);
    var identDict = globalWordIndex;
    
    var allIdentifiers = [];
    for (var ident in identDict) {
        allIdentifiers.push(ident);
    }
    var matches = completeUtil.findCompletions(identifier, allIdentifiers);
    
    var currentPath = options.path;
    matches = matches.filter(function(m) {
        return !globalWordFiles[m][currentPath];
    });
    
    matches = matches.slice(0, 100); // limits results for performance

    callback(null, matches.filter(function(m) {
        return !m.match(/^[0-9$_\/]/);
    }).map(function(m) {
        var path = Object.keys(globalWordFiles[m])[0] || "[unknown]";
        var pathParts = path.split("/");
        var foundInFile = pathParts[pathParts.length - 1];
        return {
          name: m,
          replaceText: m,
          icon: null,
          score: identDict[m],
          meta: foundInFile,
          priority: 0,
          isGeneric: true,
          $source: "open_files",
        };
    }));
};

});

//
//
//
define("util",[], function(require, exports, module) {

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    exports._extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      value.inspect !== exports.inspect &&
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return false;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

});

//
//
//
//
//
define("assert",[], function(require, exports, module) {
var util = require('util');
var pSlice = Array.prototype.slice;
var assert = module.exports = ok;
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this);
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err = new Error();
    this.stack = err.stack;
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}
assert.fail = fail;
function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;
assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};
assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  if (a.prototype !== b.prototype) return false;
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = Object.keys(a),
        kb = Object.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  if (ka.length != kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}
assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

});

define("c9/assert",[], function(require, exports, module) {
        
    var assert = function(value, message) {
        if (!value)
            throw new Error("Assertion failed: " + (message || value));
    };
    
    var assertEqual = function(value1, value2, message) {
        if (value1 != value2)
            throw new Error("Assertion failed. " + (message || "") + " got\n  " + value1 + "expected\n  " + value2);
    };
    
    module.exports = function(value, message) {
        assert(value, message);
    };
    
    module.exports.equal = function(value1, value2, message) {
        assertEqual(value1, value2, message);
    };
    
    if (typeof process === "undefined")
        return;
        
    if (process.versions && process.versions['node-webkit'])
        return;
    require(["assert"], function(nodeAssert) {
        assert = nodeAssert;
        assertEqual = nodeAssert.equal;
    });
    if (Error.captureStackTrace) {
        assert = require("assert");
        assertEqual = assert.equal;
    }
});

define("plugins/c9.ide.language.core/worker",[], function(require, exports, module) {
require("ace/lib/es6-shim");

var oop = require("ace/lib/oop");
var Mirror = require("ace/worker/mirror").Mirror;
var tree = require('treehugger/tree');
var EventEmitter = require("ace/lib/event_emitter").EventEmitter;
var syntaxDetector = require("plugins/c9.ide.language.core/syntax_detector");
var completeUtil = require("plugins/c9.ide.language/complete_util");
var localCompleter = require("plugins/c9.ide.language.generic/local_completer");
var openFilesCompleter = require("plugins/c9.ide.language.generic/open_files_local_completer");
var base_handler = require("plugins/c9.ide.language/base_handler");
var assert = require("c9/assert");

var isInWebWorker = typeof window == "undefined" || !window.location || !window.document;

var WARNING_LEVELS = {
    error: 3,
    warning: 2,
    info: 1
};

var UPDATE_TIMEOUT_MIN = !isInWebWorker && window.c9Test ? 5 : 200;
var UPDATE_TIMEOUT_MAX = 15000;
var DEBUG = !isInWebWorker; // set to true by setDebug() for c9.dev/cloud9beta.com
var STATS = false;
disabledFeatures = {};

var ServerProxy = function(sender) {

  this.emitter = Object.create(EventEmitter);
  this.emitter.emit = this.emitter._dispatchEvent;

  this.send = function(data) {
      sender.emit("serverProxy", data);
  };

  this.once = function(messageType, messageSubtype, callback) {
    var channel = messageType;
    if (messageSubtype)
       channel += (":" + messageSubtype);
    this.emitter.once(channel, callback);
  };

  this.subscribe = function(messageType, messageSubtype, callback) {
    var channel = messageType;
    if (messageSubtype)
       channel += (":" + messageSubtype);
    this.emitter.addEventListener(channel, callback);
  };

  this.unsubscribe = function(messageType, messageSubtype, f) {
    var channel = messageType;
    if (messageSubtype)
       channel += (":" + messageSubtype);
    this.emitter.removeEventListener(channel, f);
  };

  this.onMessage = function(msg) {
    var channel = msg.type;
    if (msg.subtype)
      channel += (":" + msg.subtype);
    this.emitter.emit(channel, msg.body);
  };
};

exports.createUIWorkerClient = function() {
    var emitter = Object.create(require("ace/lib/event_emitter").EventEmitter);
    var result = new LanguageWorker(emitter);
    result.on = function(name, f) {
        emitter.on.call(result, name, f);
    };
    result.once = function(name, f) {
        emitter.once.call(result, name, f);
    };
    result.removeEventListener = function(f) {
        emitter.removeEventListener.call(result, f);
    };
    result.call = function(cmd, args, callback) {
        if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
        }
        this.send(cmd, args);
    };
    result.send = function(cmd, args) {
        setTimeout(function() { result[cmd].apply(result, args); }, 0);
    };
    result.emit = function(event, data) {
        emitter._dispatchEvent.call(emitter, event, data);
    };
    emitter.emit = function(event, data) {
        emitter._dispatchEvent.call(result, event, { data: data });
    };
    result.changeListener = function(e) {
        this.emit("change", { data: [e.data]});
    }; 
    return result;
};

var LanguageWorker = exports.LanguageWorker = function(sender) {
    var _self = this;
    this.$keys = {};
    this.handlers = [];
    this.$warningLevel = "info";
    this.$openDocuments = {};
    this.$initedRegexes = {};
    this.lastUpdateTime = 0;
    sender.once = EventEmitter.once;
    this.serverProxy = new ServerProxy(sender);

    Mirror.call(this, sender);
    this.setTimeout(0);
    exports.sender = sender;
    exports.$lastWorker = this;

    sender.on("hierarchy", function(event) {
        _self.hierarchy(event);
    });
    sender.on("code_format", function(event) {
        _self.codeFormat();
    });
    sender.on("outline", applyEventOnce(function(event) {
        _self.outline(event);
    }));
    sender.on("complete", applyEventOnce(function(data) {
        _self.complete(data);
    }), true);
    sender.on("documentClose", function(event) {
        _self.documentClose(event);
    });
    sender.on("analyze", applyEventOnce(function(event) {
        _self.analyze(false, function() {});
    }));
    sender.on("cursormove", function(event) {
        _self.onCursorMove(event);
    });
    sender.on("inspect", applyEventOnce(function(event) {
        _self.inspect(event);
    }));
    sender.on("jumpToDefinition", applyEventOnce(function(event) {
        _self.jumpToDefinition(event);
    }));
    sender.on("quickfixes", applyEventOnce(function(event) {
        _self.quickfix(event);
    }));
    sender.on("isJumpToDefinitionAvailable", applyEventOnce(function(event) {
        _self.isJumpToDefinitionAvailable(event);
    }));
    sender.on("refactorings", function(event) {
        _self.getRefactorings(event);
    });
    sender.on("renamePositions", function(event) {
        _self.getRenamePositions(event);
    });
    sender.on("onRenameBegin", function(event) {
        _self.onRenameBegin(event);
    });
    sender.on("commitRename", function(event) {
        _self.commitRename(event);
    });
    sender.on("onRenameCancel", function(event) {
        _self.onRenameCancel(event);
    });
    sender.on("serverProxy", function(event) {
        _self.serverProxy.onMessage(event.data);
    });
    sender.on("quickfix_key", function(e) {
        _self.$keys.quickfix = e.data;
    });
};
function applyEventOnce(eventHandler, waitForMirror) {
    var timer;
    var mirror = this;
    return function(e) {
        var _arguments = [].slice.apply(arguments);
        if (timer && !(e && e.data.predictOnly))
            clearTimeout(timer);
        timer = setTimeout(function() {
            if (waitForMirror && mirror.isPending())
                return setTimeout(function() { applyEventOnce(eventHandler, true); }, 0);
            eventHandler.apply(eventHandler, _arguments);
        }, 0);
    };
}

oop.inherits(LanguageWorker, Mirror);

var asyncForEach = module.exports.asyncForEach = function(array, fn, test, callback) {
    if (!callback) {
        callback = test;
        test = null;
    }

    array = array.slice(); // copy before use
    
    var nested = false, callNext = true;
    loop();
    
    function loop() {
        while (callNext && !nested) {
            callNext = false;
            while (array.length > 0 && test && !test(array[0]))
                array.shift();

            var item = array.shift();
            if (!item)
                return callback && callback();

            nested = true;
            fn(item, loop);
            nested = false;
        }
        callNext = true;
    }
};

function startTime() {
    if (!STATS)
        return;
    
    return Date.now();
}

function endTime(t, message, indent) {
    if (!STATS)
        return;

    var spaces = indent ? indent * 2 : 0;
    var time = String(Date.now() - t);
    spaces += Math.max(4 - time.length, 0);
    var prefix = "";
    for (var i = 0; i < spaces; i++)
        prefix += " ";

    console.log(prefix + time, message);
}

(function() {
    
    var identifierRegexes = {};
    var cacheCompletionRegexes = {};
    
    this.enableFeature = function(name, value) {
        disabledFeatures[name] = !value;
    };

    this.setWarningLevel = function(level) {
        this.$warningLevel = level;
    };
    
    this.setStaticPrefix = completeUtil.setStaticPrefix;

    this.setDebug = function(value) {
        DEBUG = value;
    };
    this.register = function(path, contents, callback) {
        var _self = this;
        function onRegistered(handler) {
            handler.$source = path;
            handler.proxy = _self.serverProxy;
            handler.sender = _self.sender;
            handler.$isInited = false;
            handler.getEmitter = function(overridePath) {
                return _self.$createEmitter(overridePath || path);
            };
            _self.completionCache = _self.completionPrediction = null;
            _self.handlers.push(handler);
            _self.$initHandler(handler, null, true, function() {
                _self.sender.emit("registered", { path: path });
                callback && callback();
            });
        }
        if (contents) {
            try {
                eval.call(null, contents);
            } catch (e) {
                console.error("Could not load language handler " + path + ": " + e);
                _self.sender.emit("registered", { path: path, err: e });
                callback && callback(e);
                throw e;
            }
        }
        var handler;
        try {
            handler = require(path);
            if (!handler)
                throw new Error("Unable to load required module: " + path);
        } catch (e) {
            if (isInWebWorker) {
                console.error("Could not load language handler " + path + ": " + e);
                _self.sender.emit("registered", { path: path, err: e.message });
                callback && callback(e);
                throw e;
            }
            require([path], function(handler) {
                if (!handler) {
                    _self.sender.emit("registered", { path: path, err: "Could not load" });
                    callback && callback("Could not load");
                    throw new Error("Could not load language handler " + path);
                }
                onRegistered(handler);
            });
            return;
        }
        onRegistered(handler);
    };
    
    this.$createEmitter = function(path) {
        var sender = this.sender;
        return {
            on: function(event, listener) {
                sender.on(path + "/" + event, function(e) {
                    listener(e.data);
                });
            },
            once: function(event, listener) {
                sender.once(path + "/" + event, function(e) {
                    listener(e.data);
                });
            },
            off: function(event, listener) {
                sender.off(path + "/" + event, listener);
            },
            emit: function(event, data) {
                sender.emit(path + "/" + event, data);
            }
        };
    };
    
    this.unregister = function(modulePath, callback) {
        if (window.require)
            window.require.modules[modulePath] = null;
        this.handlers = this.handlers.filter(function(h) {
            return h.$source !== modulePath;
        });
        callback && callback();
    };

    this.asyncForEachHandler = function(options, fn, callback) {
        var that = this;
        var part = options.part;
        var method = options.method;
        var ignoreSize = options.ignoreSize;
        asyncForEach(
            this.handlers,
            fn,
            function(handler) {
                return that.isHandlerMatch(handler, part, method, ignoreSize);
            },
            callback
        );
    };
    
    this.isHandlerMatch = function(handler, part, method, ignoreSize) {
        if (!handler[method]) {
            reportError(new Error("Handler " + handler.$source + " does not have method " + method), {
                keys: Object.keys(handler),
                protoKeys: handler.__proto__ && Object.keys(handler.__proto__)
            });
            return false;
        }
        if (handler[method].base_handler)
            return;
        switch (handler.handlesEditor()) {
            case base_handler.HANDLES_EDITOR: 
                if (this.immediateWindow)
                    return;
                break; 
            case base_handler.HANDLES_IMMEDIATE:
                if (!this.immediateWindow)
                    return;
        }
        if (!handler.handlesLanguage(part ? part.language : this.$language, part))
            return;
        var docLength = ignoreSize ? null : part
            ? part.getValue().length
            : this.doc.$lines.reduce(function(t, l) { return t + l.length; }, 0);
        return ignoreSize || docLength < handler.getMaxFileSizeSupported();
    };

    this.parse = function(part, callback, allowCached, forceCached) {
        var value = (part || this.doc).getValue();
        var language = part ? part.language : this.$language;

        if (allowCached && this.cachedAsts) {
            var cached = this.cachedAsts[part.index];
            if (cached && cached.ast && cached.part.language === language)
                return callback(cached.ast);
        }
        if (forceCached)
            return callback(null);

        var resultAst = null;
        this.asyncForEachHandler(
            { part: part, method: "parse" },
            function parseNext(handler, next) {
                if (handler.parse.length === 2) // legacy signature
                    return handler.parse(value, handleCallbackError(function onParse(ast) {
                        if (ast) resultAst = ast;
                        next();
                    }));

                handler.parse(value, {}, handleCallbackError(function onParse(ast) {
                    if (ast)
                        resultAst = ast;
                    next();
                }));
            },
            function() {
                callback(resultAst);
            }
        );
    };
    this.findNode = function(ast, pos, callback) {
        if (!ast)
            return callback();
        assert(!pos.line, "Internal error: providing line/col instead of row/column");
        
        var _self = this;
        var part = syntaxDetector.getContextSyntaxPart(_self.doc, pos, _self.$language);
        if (!part)
            return; // cursor position no longer current
        var posInPart = syntaxDetector.posToRegion(part.region, pos);
        var result;
        this.asyncForEachHandler(
            { part: part, method: "findNode" },
            function(handler, next) {
                handler.findNode(ast, posInPart, handleCallbackError(function(node) {
                    if (node)
                        result = node;
                    next();
                }));
            },
            function() { callback(result); }
        );
    };

    this.outline = function(event) {
        var _self = this;
        this.getOutline(function(result, isUnordered) {
            _self.sender.emit(
                "outline",
                {
                    body: result && (result.body || result.items) || [],
                    path: _self.$path,
                    isUnordered: isUnordered
                }
            );
        });
    };
    
    this.getOutline = function(callback) {
        var _self = this;
        var result;
        var isUnordered = false;
        var applySort = false;
        this.parse(null, function(ast) {
            _self.asyncForEachHandler({ method: "outline" }, function(handler, next) {
                if (handler.outline.length === 3) // legacy signature
                    return handler.outline(_self.doc, ast, handleCallbackError(processResult));
                handler.outline(_self.doc, ast, {}, handleCallbackError(processResult));
                    
                function processResult(outline) {
                    if (!outline)
                        return next();
                    if (!result || (!outline.isGeneric && result.isGeneric)) {
                        result = outline;
                        isUnordered = outline.isUnordered;
                        return next();
                    }
                    if (result && outline.isGeneric && !result.isGeneric) {
                        return next();
                    }
                    applySort = true;
                    [].push.apply(result.items, outline.items);
                    result.isGeneric = outline.isGeneric;
                    next();
                }
            }, function() {
                if (applySort && result)
                    result.items = result.items.sort(function(a, b) {
                        return a.pos.sl - b.pos.sl;
                    });
                
                callback(result, isUnordered);
            });
        });
    };

    this.hierarchy = function(event) {
        var data = event.data;
        var _self = this;
        asyncForEach(this.handlers, function(handler, next) {
            if (_self.isHandlerMatch(handler, null, "hierarchy")) {
                handler.hierarchy(_self.doc, data.pos, handleCallbackError(function(hierarchy) {
                    if (hierarchy)
                        return _self.sender.emit("hierarchy", hierarchy);
                    else
                        next();
                }));
            }
            else
                next();
        });
    };

    this.codeFormat = function() {
        var _self = this;
        asyncForEach(_self.handlers, function(handler, next) {
            if (_self.isHandlerMatch(handler, null, "codeFormat", true)) {
                handler.codeFormat(_self.doc, function(optionalErr, newSource) {
                    if (typeof optionalErr === "string")
                        newSource = optionalErr;
                    else if (optionalErr)
                        console.error(optionalErr.stack || optionalErr);
                    if (newSource)
                        return _self.sender.emit("code_format", newSource);
                    else
                        next();
                });
            }
            else
                next();
        });
    };

    this.scheduleEmit = function(messageType, data) {
        data.path = this.$path;
        this.sender.emit(messageType, data);
    };
    function filterMarkersAroundError(ast, markers) {
        if (!ast || !ast.getAnnotation)
            return;
        var error = ast.getAnnotation("error");
        if (!error)
            return;
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i];
            if (marker.type !== 'error' && marker.pos.sl >= error.line && marker.pos.el <= error.line + 2) {
                markers.splice(i, 1);
                i--;
            }
        }
    }

    this.analyze = function(minimalAnalysis, callback) {
        var _self = this;
        var parts = syntaxDetector.getCodeParts(this.doc, this.$language);
        var markers = [];
        var cachedAsts = {};
        var t0 = startTime();
        asyncForEach(parts, function analyzePart(part, nextPart) {
            var partMarkers = [];
            _self.part = part;
            _self.$lastAnalyzer = "parse()";
            _self.parse(part, function analyzeParsed(ast) {
                cachedAsts[part.index] = { part: part, ast: ast };

                _self.asyncForEachHandler(
                    { part: part, method: "analyze" },
                    function(handler, next) {
                        handler.language = part.language;
                        var t = startTime();
                        _self.$lastAnalyzer = handler.$source + ".analyze()";
                        
                        if (handler.analyze.length === 3 || /^[^)]+minimalAnalysis/.test(handler.analyze.toString())) {
                            return handler.analyze(part.getValue(), ast, handleCallbackError(doNext), minimalAnalysis);
                        }
                        
                        handler.analyze(part.getValue(), ast, { path: _self.$path, minimalAnalysis: minimalAnalysis }, handleCallbackError(doNext));
                        
                        function doNext(result) {
                            endTime(t, "Analyze: " + handler.$source.replace("plugins/", ""));
                            if (result)
                                partMarkers = partMarkers.concat(result);
                            next();
                        }
                    },
                    function() {
                        filterMarkersAroundError(ast, partMarkers);
                        var region = part.region;
                        partMarkers.forEach(function(marker) {
                            if (marker.skipMixed)
                                return;
                            var pos = marker.pos;
                            if (!pos)
                                return console.error("Invalid marker, no position:", marker);
                            pos.sl = pos.el = pos.sl + region.sl;
                            if (pos.sl === region.sl) {
                                pos.sc += region.sc;
                                pos.ec += region.sc;
                            }
                        });
                        markers = markers.concat(partMarkers);
                        nextPart();
                    }
                );
            });
        }, function() {
            endTime(t0, "Analyzed all");
            _self.cachedAsts = cachedAsts;
            if (!minimalAnalysis) {
                _self.scheduleEmit("markers", _self.filterMarkersBasedOnLevel(markers));
            }
            callback();
        });
    };

    this.filterMarkersBasedOnLevel = function(markers) {
        if (disabledFeatures.hints)
            return [];
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i];
            if (marker.level && WARNING_LEVELS[marker.level] < WARNING_LEVELS[this.$warningLevel]) {
                markers.splice(i, 1);
                i--;
            }
        }
        return markers;
    };

    this.getPart = function (pos) {
        return syntaxDetector.getContextSyntaxPart(this.doc, pos, this.$language);
    };
    this.inspect = function (event) {
        var _self = this;
        var pos = { row: event.data.row, column: event.data.column };
        var part = this.getPart({ row: event.data.row, column: event.data.col });
        if (!part)
            return; // cursor position no longer current
        var partPos = syntaxDetector.posToRegion(part.region, pos);
        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(node) {
                _self.getPos(node, function(fullPos) {
                    if (!fullPos) {
                        var postfix = completeUtil.retrieveFollowingIdentifier(_self.doc.getLine(pos.row), pos.column);
                        var prefix = completeUtil.retrievePrecedingIdentifier(_self.doc.getLine(pos.row), pos.column);
                        fullPos = { sl: partPos.row, sc: partPos.column - prefix.length, el: partPos.row, ec: partPos.column + postfix.length };
                    }
                    _self.nodeToString(node, function(result) {
                        var lastResult = {
                            pos: fullPos,
                            value: result
                        };
                        var rejected;
                        asyncForEach(_self.handlers, function(handler, next) {
                            if (_self.isHandlerMatch(handler, part, "getInspectExpression")) {
                                handler.language = part.language;
                                handler.getInspectExpression(part, ast, partPos, { node: node, path: _self.$path }, handleCallbackError(function(result) {
                                    if (result) {
                                        result.pos = syntaxDetector.posFromRegion(part.region, result.pos);
                                        lastResult = result || lastResult;
                                    }
                                    else if (!rejected) {
                                        lastResult = {};
                                        rejected = true;
                                    }
                                    next();
                                }));
                            }
                            else {
                                next();
                            }
                        }, function () {
                            if (!lastResult.pos && !lastResult.value)
                                return _self.scheduleEmit("inspect", lastResult);
                            var pos = lastResult.pos;
                            var text = _self.doc.getTextRange({ start: { column: pos.sc, row: pos.sl }, end: { column: pos.ec, row: pos.el }});
                            if (text != lastResult.value) {
                                console.warn("inspect expected ", text, " got ", lastResult.value);
                                lastResult.value = text;
                            }
                            _self.scheduleEmit("inspect", lastResult);
                        });
                    });
                });
            });
        }, true);
    };
    
    this.nodeToString = function(node, callback) {
        if (!node)
            return callback();
        var _self = this;
        this.getPos(node, function(pos) {
            if (!pos)
                return callback();
            var doc = _self.doc;
            if (pos.sl === pos.el)
                return callback(doc.getLine(pos.sl).substring(pos.sc, pos.ec));
            
            var result = doc.getLine(pos.sl).substr(pos.sc);
            for (var i = pos.sl + 1; i < pos.el; i++) {
                result += doc.getLine(i);
            }
            result += doc.getLine(pos.el).substr(0, pos.ec);
            callback(result);
        });
    };
    
    this.getPos = function(node, callback) {
        if (!node)
            return callback();
        var done = false;
        var _self = this;
        this.handlers.forEach(function (h) {
            if (!done && _self.isHandlerMatch(h, null, "getPos", true)) {
                h.getPos(node, function(result) {
                    if (!result)
                        return;
                    done = true;
                    callback(result);
                });
            }
        });
        if (!done)
            callback();
    };
    
    this.getIdentifierRegex = function(pos) {
        var part = pos && this.getPart(pos);
        return identifierRegexes[part ? part.language : this.$language] || completeUtil.DEFAULT_ID_REGEX;
    };
    
    this.getCacheCompletionRegex = function(pos) {
        var part = pos && this.getPart(pos);
        return cacheCompletionRegexes[part ? part.language : this.$language] || completeUtil.DEFAULT_ID_REGEX;
    };
    this.onCursorMove = function(event) {
        var _self = this;
        var pos = event.data.pos;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var line = this.doc.getLine(pos.row);
        
        if (line != event.data.line) {
            return this.scheduleEmit("hint", { line: null });
        }

        var result = {
            markers: [],
            hint: null,
            displayPos: null
        };
        
        this.initAllRegexes(part.language);
        
        var posInPart = syntaxDetector.posToRegion(part.region, pos);
        this.parse(part, function(ast) {
            if (!ast)
                return callHandlers(ast, null);
            _self.findNode(ast, pos, function(currentNode) {
                callHandlers(ast, currentNode);
            });
        }, true, true);
        
        function callHandlers(ast, currentNode) {
            asyncForEach(_self.handlers,
                function(handler, next) {
                    if ((pos != _self.lastCurrentPosUnparsed || pos.force) && _self.isHandlerMatch(handler, part, "onCursorMove")) {
                        handler.onCursorMove(part, ast, posInPart, { node: currentNode, path: _self.$path }, handleCallbackError(function(response) {
                            processCursorMoveResponse(response, part, result);
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                },
                function() {
                    _self.lastCurrentPosUnparsed = pos;
                    if (result.markers.length) {
                        _self.scheduleEmit("highlightMarkers", disabledFeatures.instanceHighlight
                            ? []
                            : result.markers
                        );
                        event.data.addedMarkers = result.markers;
                    }
                    if (result.hint !== null) {
                        _self.scheduleEmit("hint", {
                            pos: result.pos,
                            displayPos: result.displayPos,
                            message: result.hint,
                            line: line
                        });
                    }
                    _self.onCursorMoveAnalyzed(event);
                }
            );
        }
    };
    this.onCursorMoveAnalyzed = function(event) {
        var _self = this;
        var pos = event.data.pos;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var line = this.doc.getLine(pos.row);
        
        if (line != event.data.line) {
            return this.scheduleEmit("hint", { line: null });
        }
        if (this.updateScheduled) {
            this.postponedCursorMove = event;
            if (event.data.now)
                this.onUpdate(true);
            return;
        }

        var result = {
            markers: event.data.addedMarkers || [],
            hint: null,
            displayPos: null
        };

        var posInPart = syntaxDetector.posToRegion(part.region, pos);
        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                if (pos != _self.lastCurrentPos || currentNode !== _self.lastCurrentNode || pos.force) {
                    callHandlers(ast, currentNode);
                }
            });
        }, true);
        
        function callHandlers(ast, currentNode) {
            asyncForEach(_self.handlers, function(handler, next) {
                if (_self.updateScheduled) {
                    _self.postponedCursorMove = event;
                    return;
                }
                if (_self.isHandlerMatch(handler, part, "tooltip") || _self.isHandlerMatch(handler, part, "highlightOccurrences")) {
                    assert(!handler.onCursorMovedNode, "handler implements onCursorMovedNode; no longer exists");
                    asyncForEach(["tooltip", "highlightOccurrences"], function(method, nextMethod) {
                        handler[method](part, ast, posInPart, { node: currentNode, path: _self.$path }, function(response) {
                            result = processCursorMoveResponse(response, part, result);
                            nextMethod();
                        });
                    }, next);
                }
                else {
                    next();
                }
            }, function() {
                _self.scheduleEmit("highlightMarkers", disabledFeatures.instanceHighlight
                    ? []
                    : result.markers
                );
                _self.lastCurrentNode = currentNode;
                _self.lastCurrentPos = pos;
                _self.scheduleEmit("hint", {
                    pos: result.pos,
                    displayPos: result.displayPos,
                    message: result.hint,
                    line: line
                });
            });
        }
    };
        
    function processCursorMoveResponse(response, part, result) {
        if (!response)
            return result;
        if (response.markers && (!result.markers.found || !response.isGeneric)) {
            if (result.markers.isGeneric)
                result.markers = [];
            result.markers = result.markers.concat(response.markers.map(function (m) {
                var start = syntaxDetector.posFromRegion(part.region, { row: m.pos.sl, column: m.pos.sc });
                var end = syntaxDetector.posFromRegion(part.region, { row: m.pos.el, column: m.pos.ec });
                m.pos = {
                    sl: start.row,
                    sc: start.column,
                    el: end.row,
                    ec: end.column
                };
                return m;
            }));
            result.markers.found = true;
            result.markers.isGeneric = response.isGeneric;
        }
        if (response.hint) {
            if (result.hint)
                result.hint += "\n" + response.hint;
            else
                result.hint = response.hint;
        }
        if (response.pos)
            result.pos = response.pos;
        if (response.displayPos)
            result.displayPos = response.displayPos;
        
        return result;
    }

    this.$getDefinitionDeclarations = function (row, col, callback) {
        var pos = { row: row, column: col };
        var allResults = [];

        var _self = this;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var posInPart = syntaxDetector.posToRegion(part.region, pos);

        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                asyncForEach(_self.handlers, function jumptodefNext(handler, next) {
                    if (_self.isHandlerMatch(handler, part, "jumpToDefinition")) {
                        handler.jumpToDefinition(part, ast, posInPart, { node: currentNode, path: _self.$path, language: _self.$language }, handleCallbackError(function(results) {
                            handler.path = _self.$path;
                            if (results)
                                allResults = allResults.concat(results);
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                }, function () {
                    callback(allResults.map(function (pos) {
                        var globalPos = syntaxDetector.posFromRegion(part.region, pos);
                        pos.row = globalPos.row;
                        pos.column = globalPos.column;
                        return pos;
                    }));
                });
            });
        }, true);
    };

    this.jumpToDefinition = function(event) {
        var _self = this;
        var pos = event.data;
        var line = this.doc.getLine(pos.row);
        var regex = this.getIdentifierRegex(pos);
        var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, regex)
            + completeUtil.retrieveFollowingIdentifier(line, pos.column, regex);

        _self.$getDefinitionDeclarations(pos.row, pos.column, function(results) {
            _self.sender.emit(
                "definition",
                {
                    pos: pos,
                    results: results || [],
                    path: _self.$path,
                    identifier: identifier
                }
            );
        });
    };
    
    this.quickfix = function(event) {
        var _self = this;
        var pos = event.data;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var partPos = syntaxDetector.posToRegion(part.region, pos);
        var allResults = [];
        
        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                asyncForEach(_self.handlers, function(handler, next) {
                    if (_self.isHandlerMatch(handler, part, "getQuickfixes")) {
                        handler.getQuickfixes(part, ast, partPos, { node: currentNode, path: _self.$path }, handleCallbackError(function(results) {
                            if (results)
                                allResults = allResults.concat(results);
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                }, function() {
                    _self.sender.emit("quickfixes_result", {
                        path: _self.$path,
                        results: allResults
                    });
                });
            });
        });
    };

    this.isJumpToDefinitionAvailable = function(event) {
        var _self = this;
        var pos = event.data;

        _self.$getDefinitionDeclarations(pos.row, pos.column, function(results) {
            _self.sender.emit(
                "isJumpToDefinitionAvailableResult",
                { value: !!(results && results.length), path: _self.$path, pos: pos }
            );
        });
    };
    
    this.getRefactorings = function(event) {
        var _self = this;
        var pos = event.data;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var partPos = syntaxDetector.posToRegion(part.region, pos);
        
        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                var result;
                asyncForEach(_self.handlers, function(handler, next) {
                    if (_self.isHandlerMatch(handler, part, "getRefactorings")) {
                        handler.getRefactorings(part, ast, partPos, { node: currentNode, path: _self.$path }, handleCallbackError(function(response) {
                            if (response) {
                                assert(!response.enableRefactorings, "Use refactorings instead of enableRefactorings");
                                if (!result || result.isGeneric)
                                    result = response;
                            }
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                }, function() {
                    _self.sender.emit("refactoringsResult", result && result.refactorings || []);
                });
            });
        });
    };

    this.getRenamePositions = function(event) {
        var _self = this;
        var pos = event.data;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var partPos = syntaxDetector.posToRegion(part.region, pos);

        function posFromRegion(pos) {
            return syntaxDetector.posFromRegion(part.region, pos);
        }

        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                var result;
                asyncForEach(_self.handlers, function(handler, next) {
                    if (_self.isHandlerMatch(handler, part, "getRenamePositions")) {
                        assert(!handler.getVariablePositions, "handler implements getVariablePositions, should implement getRenamePositions instead");
                        handler.getRenamePositions(part, ast, partPos, { node: currentNode, path: _self.$path }, handleCallbackError(function(response) {
                            if (response) {
                                if (!result || result.isGeneric)
                                    result = response;
                            }
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                }, function() {
                    if (!result)
                        return _self.sender.emit("renamePositionsResult");
                    result.uses = (result.uses || []).map(posFromRegion);
                    result.declarations = (result.declarations || []).map(posFromRegion);
                    result.others = (result.others || []).map(posFromRegion);
                    result.pos = posFromRegion(result.pos);
                    _self.sender.emit("renamePositionsResult", result);
                });
            });
        }, true);
    };

    this.onRenameBegin = function(event) {
        var _self = this;
        this.handlers.forEach(function(handler) {
            if (_self.isHandlerMatch(handler, null, "onRenameBegin"))
                handler.onRenameBegin(_self.doc, function() {});
        });
    };

    this.commitRename = function(event) {
        var _self = this;
        var oldId = event.data.oldId;
        var newName = event.data.newName;
        var isGeneric = event.data.isGeneric;
        var commited = false;
        
        if (oldId.value === newName)
          return this.sender.emit("commitRenameResult", {});

        asyncForEach(this.handlers, function(handler, next) {
            if (_self.isHandlerMatch(handler, null, "commitRename")) {
                handler.commitRename(_self.doc, oldId, newName, isGeneric, handleCallbackError(function(response) {
                    if (response) {
                        commited = true;
                        _self.sender.emit("commitRenameResult", { err: response, oldName: oldId.value, newName: newName });
                    } else {
                        next();
                    }
                }));
            }
            else
                next();
            },
            function() {
                if (!commited)
                    _self.sender.emit("commitRenameResult", {});
            }
        );
    };

    this.onRenameCancel = function(event) {
        var _self = this;
        asyncForEach(this.handlers, function(handler, next) {
            if (_self.isHandlerMatch(handler, null, "onRenameCancel")) {
                handler.onRenameCancel(handleCallbackError(function() {
                    next();
                }));
            }
            else {
                next();
            }
        });
    };

    var updateRunning;
    var updateWatchDog;
    this.onUpdate = function(now) {
        var _self = this;
        
        if (updateRunning) {
            this.updateAgain = { now: now || this.updateAgain && this.updateAgain.now };
            return;
        }
        
        if (this.updateScheduled && !now) {
            return;
        }
        this.updateAgain = null;
        clearTimeout(updateWatchDog);
        clearTimeout(this.updateScheduled);
        this.updateScheduled = null;

        updateWatchDog = setTimeout(function() {
            if (DEBUG)
                return console.error("Warning: worker analysis taking too long or failed to call back (" + _self.$lastAnalyzer + ")");
            _self.updateScheduled = updateRunning = null;
            console.error("Warning: worker analysis taking too long or failed to call back (" + _self.$lastAnalyzer + "), rescheduling");
        }, UPDATE_TIMEOUT_MAX + this.lastUpdateTime);
        
        if (now) {
            doUpdate(function() {
                _self.onUpdate();
            });
            return;
        }
        
        this.updateScheduled = setTimeout(function() {
            _self.updateScheduled = null;
            doUpdate(function() {
                if (_self.updateAgain)
                    _self.onUpdate(_self.updateAgain.now);
            });
        }, UPDATE_TIMEOUT_MIN + Math.min(this.lastUpdateTime, UPDATE_TIMEOUT_MAX));
        
        function doUpdate(done) {
            updateRunning = true;
            var beginUpdate = new Date().getTime();
            _self.asyncForEachHandler(
                { method: "onUpdate" },
                function(handler, next) {
                    var t = startTime();
                    handler.onUpdate(_self.doc, handleCallbackError(function() {
                        endTime(t, "Update: " + handler.$source);
                        next();
                    }));
                },
                function() {
                    _self.analyze(now, function() {
                        if (_self.postponedCursorMove) {
                            _self.onCursorMoveAnalyzed(_self.postponedCursorMove);
                            _self.postponedCursorMove = null;
                        }
                        _self.lastUpdateTime = DEBUG ? 0 : new Date().getTime() - beginUpdate;
                        clearTimeout(updateWatchDog);
                        updateRunning = false;
                        done && done();
                    });
                }
            );
        }
    };
    
    this.$documentToString = function(document) {
        if (!document)
            return "";
        if (Array.isArray(document))
            return document.join("\n");
        if (typeof document == "string")
            return document;
        var array = [];
        for (var i = 0; i < document.byteLength; i++) {
            array.push(document[i]);
        }
        return array.join("\n");
    };

    this.switchFile = function(path, immediateWindow, language, document, pos, workspaceDir) {
        var _self = this;
        var oldPath = this.$path;
        var code = this.$documentToString(document);
        this.$workspaceDir = workspaceDir === "" ? "/" : workspaceDir;
        this.$path = path;
        this.$language = language;
        this.doc.$language = language;
        this.immediateWindow = immediateWindow;
        this.lastCurrentNode = null;
        this.lastCurrentPos = null;
        this.lastCurrentPosUnparsed = null;
        this.cachedAsts = null;
        this.setValue(code);
        this.lastUpdateTime = 0;
        asyncForEach(this.handlers, function(handler, next) {
            _self.$initHandler(handler, oldPath, false, next);
        }, function() {
            _self.onUpdate(true);
        });
    };

    this.$initHandler = function(handler, oldPath, onDocumentOpen, callback) {
        var _self = this;
        handler.path = this.$path;
        handler.language = this.$language;
        handler.workspaceDir = this.$workspaceDir;
        handler.doc = this.doc;
        handler.sender = this.sender;
        handler.completeUpdate = this.completeUpdate.bind(this);
        handler.immediateWindow = this.immediateWindow;
        handler.$getIdentifierRegex = this.getIdentifierRegex.bind(this);
        this.initRegexes(handler, this.$language);
        if (!handler.$isInited) {
            handler.$isInited = true;
            handler.init(handleCallbackError(function() {
                if (handler.handlesLanguage(_self.$language))
                    handler.onDocumentOpen(_self.$path, _self.doc, oldPath, function() {});
                handler.$isInitCompleted = true;
                callback();
            }));
        }
        else if (onDocumentOpen) {
            if (handler.handlesLanguage(_self.$language))
                handler.onDocumentOpen(_self.$path, _self.doc, oldPath, function() {});
            callback();
        }
        else {
            callback();
        }
    };
    
    this.initAllRegexes = function(language) {
        if (this.$initedRegexes[language])
            return;
        this.$initedRegexes[language] = true;
        var that = this;
        this.handlers.forEach(function(h) {
            that.initRegexes(h, language);
        });
    };
    
    this.initRegexes = function(handler, language) {
        if (!handler.handlesLanguage(language))
            return;
        if (handler.getIdentifierRegex()) {
            this.sender.emit("setIdentifierRegex", { language: language, identifierRegex: handler.getIdentifierRegex() });
            identifierRegexes[language] = handler.getIdentifierRegex();
        }
        if (handler.getCacheCompletionRegex()) {
            var regex = handler.getCacheCompletionRegex();
            if (!/\$$/.test(regex.source))
                regex = new RegExp(regex.source + "$");
            this.sender.emit("setCacheCompletionRegex", { language: language, cacheCompletionRegex: regex });
            cacheCompletionRegexes[language] = regex;
        }
        if (handler.getCompletionRegex())
            this.sender.emit("setCompletionRegex", { language: language, completionRegex: handler.getCompletionRegex() });
        if (handler.getTooltipRegex())
            this.sender.emit("setTooltipRegex", { language: language, tooltipRegex: handler.getTooltipRegex() });
    };

    this.documentOpen = function(path, immediateWindow, language, document) {
        this.$openDocuments["_" + path] = path;
        var _self = this;
        var code = this.$documentToString(document);
        var doc = { getValue: function() { return code; } };
        asyncForEach(_self.handlers, function(handler, next) {
            if (!handler.handlesLanguage(language))
                return next();
            handler.onDocumentOpen(path, doc, _self.path, next);
        });
    };
    
    this.documentClose = function(event) {
        var path = event.data;
        delete this.$openDocuments["_" + path];
        this.asyncForEachHandler({ method: "onDocumentClose" }, function(handler, next) {
            handler.onDocumentClose(path, next);
        }, function() {});
    };
    function removeDuplicateMatches(matches) {
        matches.sort(function(a, b) {
            if (a.name < b.name)
                return -1;
            else if (a.name > b.name)
                return 1;
            else
                return 0;
        });
        for (var i = 0; i < matches.length - 1; i++) {
            var a = matches[i];
            var b = matches[i + 1];
            
            if (a.name === b.name || (a.id || a.name) === (b.id || b.name)) {
                if (a.isContextual && !b.isContextual)
                    matches.splice(i + 1, 1);
                else if (!a.isContextual && b.isContextual)
                    matches.splice(i, 1);
                else if (a.isGeneric && !b.isGeneric)
                    matches.splice(i, 1);
                else if (!a.isGeneric && b.isGeneric)
                    matches.splice(i + 1, 1);
                else if (a.priority < b.priority)
                    matches.splice(i, 1);
                else if (a.priority > b.priority)
                    matches.splice(i + 1, 1);
                else if (a.score < b.score)
                    matches.splice(i, 1);
                else if (a.score > b.score)
                    matches.splice(i + 1, 1);
                else
                    matches.splice(i, 1);
                i--;
            }
        }
    }

    this.complete = function(event) {
        var _self = this;
        var options = event.data;
        var pos = options.pos;
        
        _self.waitForCompletionSync(options, function doComplete(identifierRegex) {
            var cacheCompletionRegex = _self.getCacheCompletionRegex(pos);
            var overrideLine = cacheCompletionRegex && _self.tryShortenCompletionPrefix(_self.doc.getLine(pos.row), pos.column, identifierRegex);
            var overridePos = overrideLine != null && { row: pos.row, column: pos.column - 1 };
        
            var newCache = _self.tryCachedCompletion(overridePos || pos, overrideLine, identifierRegex, cacheCompletionRegex, options);
            if (!newCache || options.predictOnly) {
                if (options.predictOnly || _self.completionCache.result)
                    _self.predictNextCompletion(_self.completionCache, pos, identifierRegex, cacheCompletionRegex, options);
                return;
            }
            
            _self.completionCache = newCache;
            _self.getCompleteHandlerResult(overridePos || pos, overrideLine, identifierRegex, options, function(result) {
                if (!result) return;
                _self.sender.emit("complete", result);
                newCache.setResult(result);
                _self.predictNextCompletion(newCache, pos, identifierRegex, cacheCompletionRegex, options);
            });
        });
    };
    
    this.tryShortenCompletionPrefix = function(line, offset, identifierRegex) {
        for (var i = 0; i < this.handlers.length; i++) {
            if (this.handlers[i].$disableZeroLengthCompletion && this.handlers[i].handlesLanguage(this.$language))
                return;
        }
        if (identifierRegex.test(line[offset - 1] || "") && !identifierRegex.test(line[offset - 2] || ""))
            return line.substr(0, offset - 1) + line.substr(offset);
    };
    this.getCompleteHandlerResult = function(pos, overrideLine, identifierRegex, options, callback) {
        var _self = this;
        var matches = [];
        var hadError = false;
        var originalLine = _self.doc.getLine(pos.row);
        var line = overrideLine != null ? overrideLine : originalLine;
        var part = syntaxDetector.getContextSyntaxPart(_self.doc, pos, _self.$language);
        if (!part)
            return callback(); // cursor position not current
        var partPos = syntaxDetector.posToRegion(part.region, pos);
        var tStart = startTime();
        
        startOverrideLine();
        _self.parse(part, function(ast) {
            endTime(tStart, "Complete: parser");
            _self.findNode(ast, pos, function(currentNode) {
                var handlerOptions = {
                    noDoc: options.noDoc,
                    node: currentNode,
                    language: _self.$language,
                    path: _self.$path,
                    line: line,
                    get identifierPrefix() {
                        return completeUtil.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
                    },
                };
                _self.asyncForEachHandler(
                    { part: part, method: "complete" },
                    function(handler, next) {
                        handler.language = part.language;
                        handler.workspaceDir = _self.$workspaceDir;
                        handler.path = _self.$path;
                        var t = startTime();

                        var originalLine2 = _self.doc.getLine(pos.row);
                        startOverrideLine();
                        handler.complete(part, ast, partPos, handlerOptions, handleCallbackError(function(completions, handledErr) {
                            endTime(t, "Complete: " + handler.$source.replace("plugins/", ""), 1);
                            if (completions && completions.length)
                                matches = matches.concat(completions);
                            hadError = !!(hadError || handledErr);
                            next();
                        }));
                        endOverrideLine(originalLine2);
                    },
                    function() {
                        removeDuplicateMatches(matches);
                        matches.sort(function(a, b) {
                            if (a.priority < b.priority)
                                return 1;
                            else if (a.priority > b.priority)
                                return -1;
                            else if (a.score < b.score)
                                return 1;
                            else if (a.score > b.score)
                                return -1;
                            else if (a.id && a.id === b.id) {
                                if (a.isFunction)
                                    return -1;
                                else if (b.isFunction)
                                    return 1;
                            }
                            if (a.name < b.name)
                                return -1;
                            else if (a.name > b.name)
                                return 1;
                            else
                                return 0;
                        });
                        endTime(tStart, "COMPLETED!");
                        callback({
                            pos: pos,
                            matches: matches,
                            isUpdate: options.isUpdate,
                            noDoc: options.noDoc,
                            hadError: hadError,
                            line: line,
                            path: _self.$path,
                            forceBox: options.forceBox,
                            deleteSuffix: options.deleteSuffix
                        }
                    );
                });
            });
        });
        endOverrideLine(originalLine);
        function startOverrideLine() {
            if (overrideLine != null)
                _self.doc.$lines[pos.row] = overrideLine;
            
            _self.$overrideLine = overrideLine;
            _self.$lastCompleteRow = pos.row;
        }
        
        function endOverrideLine(line) {
            _self.$overrideLine = null;
            _self.doc.$lines[pos.row] = line;
        }
    };
    this.tryCachedCompletion = function(pos, overrideLine, identifierRegex, cacheCompletionRegex, options) {
        var that = this;
        var cacheKey = this.getCompleteCacheKey(pos, overrideLine, identifierRegex, cacheCompletionRegex, options);
        
        if (options.isUpdate) {
            if (cacheKey.isCompatible(this.completionCache))
                return this.completionCache;
            if (cacheKey.isCompatible(this.completionPrediction))
                return this.completionPrediction;
        }
    
        if (cacheKey.isCompatible(this.completionCache) && !isRecompletionRequired(this.completionCache)) {
            if (this.completionCache.result)
                cacheHit(this.completionCache);
            else
                this.completionCache.resultCallbacks.push(cacheHit);
            return;
        }
    
        if (cacheKey.isCompatible(this.completionPrediction) && !isRecompletionRequired(this.completionPrediction)) {
            this.completionCache = this.completionPrediction;
            if (this.completionCache.result)
                cacheHit(this.completionCache);
            else
                this.completionCache.resultCallbacks.push(cacheHit);
            return;
        }
        
        return cacheKey;
            
        function cacheHit(cache) {
            if (options.predictOnly)
                return;
                
            updateLocalCompletions(that.doc, that.$path, pos, cache.result.matches, function sendCached(err, matches) {
                if (err) {
                    console.error(err);
                    matches = cache.result.matches;
                }
                that.sender.emit("complete", {
                    line: overrideLine != null ? overrideLine : that.doc.getLine(pos.row),
                    forceBox: options.forceBox,
                    isUpdate: options.isUpdate,
                    matches: matches,
                    path: that.$path,
                    pos: pos,
                    noDoc: cache.result.noDoc,
                    deleteSuffix: options.deleteSuffix,
                });
            });
        }
        
        function isRecompletionRequired(cache) {
            var recomputeLength = -1;
            var recomputeAtOffset1 = false;
            for (var i = 0; i < that.handlers.length; i++) {
                if (that.handlers[i].$recacheCompletionLength && that.handlers[i].handlesLanguage(that.$language))
                    recomputeLength = that.handlers[i].$recacheCompletionLength;
                if (that.handlers[i].$disableZeroLengthCompletion && that.handlers[i].handlesLanguage(that.$language))
                    recomputeAtOffset1 = true;
            }
            
            if (recomputeAtOffset1 && cacheKey.prefix.length >= 1 && cache.prefix.length === 0)
                return true;
            
            return cacheKey.prefix.length >= recomputeLength && cache.prefix.length < recomputeLength;
        }
    };
    this.predictNextCompletion = function(cacheKey, pos, identifierRegex, cacheCompletionRegex, options) {
        if (options.isUpdate)
            return;
        
        var _self = this;
        var predictedString;
        var showEarly;
        var line = _self.doc.getLine(pos.row);
        var prefix = completeUtil.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
        
        this.asyncForEachHandler(
            { method: "predictNextCompletion" },
            function preparePredictionInput(handler, next) {
                var handlerOptions = {
                    matches: options.predictOnly ? [] : getFilteredMatches(),
                    path: _self.$path,
                    language: _self.$language,
                    line: line,
                    identifierPrefix: prefix,
                };
                handler.predictNextCompletion(_self.doc, null, pos, handlerOptions, handleCallbackError(function(result) {
                    if (result != null) {
                        predictedString = result.predicted;
                        showEarly = result.showEarly;
                    }
                    next();
                }));
            },
            function computePrediction() {
                if (predictedString == null)
                    return;
                
                var predictedLine = line.substr(0, pos.column - prefix.length)
                    + predictedString
                    + line.substr(pos.column);
                var predictedPos = { row: pos.row, column: pos.column - prefix.length + predictedString.length };
                
                var predictionKey = _self.getCompleteCacheKey(predictedPos, predictedLine, identifierRegex, cacheCompletionRegex, options);
                if (_self.completionPrediction && _self.completionPrediction.isCompatible(predictionKey))
                    return;
                if (_self.completionCache && _self.completionCache.isCompatible(predictionKey))
                    return;
                _self.completionPrediction = predictionKey;

                _self.getCompleteHandlerResult(predictedPos, predictedLine, identifierRegex, options, function(result) {
                    predictionKey.setResult(result);
                    if (showEarly && cacheKey.isCompatible(_self.completionCache))
                        showPredictionsEarly(result);
                });
            }
        );
        
        var filteredMatches;
        function getFilteredMatches() {
            if (filteredMatches)
                return filteredMatches;
            var prefix = completeUtil.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
            filteredMatches = cacheKey.result.matches.filter(function(m) {
                m.replaceText = m.replaceText || m.name;
                return m.replaceText.indexOf(prefix) === 0;
            });
            return filteredMatches;
        }
        
        function showPredictionsEarly(prediction) {
            var newMatches = prediction.matches.filter(function(m) { return m.isContextual; });
            if (!newMatches.length)
                return;
            [].push.apply(_self.completionCache.result.matches, newMatches.map(function(m) {
                m = Object.assign({}, m);
                m.replaceText = predictedString + m.replaceText;
                m.name = predictedString + m.name;
                return m;
            }));
            _self.sender.emit("complete", _self.completionCache.result);
        }
    };
    this.getCompleteCacheKey = function(pos, overrideLine, identifierRegex, cacheCompletionRegex, options) {
        var worker = this;
        var doc = this.doc;
        var path = this.$path;
        var originalLine = doc.getLine(pos.row);
        var line = overrideLine != null ? overrideLine : originalLine;
        var prefix = completeUtil.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
        var suffix = completeUtil.retrieveFollowingIdentifier(line, pos.column, identifierRegex);
        var completeLine = removeCacheCompletionPrefix(
            line.substr(0, pos.column - prefix.length) + line.substr(pos.column + suffix.length));
        
        var completeLines = doc.$lines.slice();
        completeLines[pos.row] = null;
        
        var completePos = { row: pos.row, column: pos.column - prefix.length };
        return {
            result: null,
            resultCallbacks: [],
            line: completeLine,
            lines: completeLines,
            pos: completePos,
            prefix: prefix,
            path: path,
            noDoc: options.noDoc,
            setResult: function(result) {
                var cacheKey = this;
                this.result = result;
                this.resultCallbacks.forEach(function(c) {
                    c(cacheKey);
                });
                if (result.hadError && worker.completionCache === this)
                    worker.completionCache = null;
                if (result.hadError && worker.completionPrediction === this)
                    worker.completionPrediction = null;
            },
            isCompatible: function(other) {
                return other
                    && other.path === this.path
                    && other.pos.row === this.pos.row
                    && other.pos.column === this.pos.column
                    && other.line === this.line
                    && (!other.noDoc || this.noDoc)
                    && this.prefix.indexOf(other.prefix) === 0 // match if they're like foo and we're fooo
                    && other.lines.length === completeLines.length
                    && other.lines[this.pos.row - 1] === completeLines[this.pos.row - 1]
                    && other.lines[this.pos.row + 1] === completeLines[this.pos.row + 1]
                    && other.lines.every(function(l, i) {
                        return l === completeLines[i];
                    });
            }
        };
        
        function removeCacheCompletionPrefix(line) {
            if (!cacheCompletionRegex)
                return line;
            var match = cacheCompletionRegex.exec(line.substr(0, pos.column - prefix.length));
            if (!match)
                return line;
            pos = { row: pos.row, column: pos.column - match[0].length };
            return line.substr(0, line.length - match[0].length);
        }
    };
    this.waitForCompletionSync = function(options, runCompletion) {
        var _self = this;
        var pos = options.pos;
        var line = _self.doc.getLine(pos.row);
        this.waitForCompletionSyncThread = this.waitForCompletionSyncThread || 0;
        var threadId = ++this.waitForCompletionSyncThread;
        var identifierRegex = this.getIdentifierRegex(pos);
        if (!completeUtil.canCompleteForChangedLine(line, options.line, pos, pos, identifierRegex)) {
            setTimeout(function() {
                if (threadId !== _self.waitForCompletionSyncThread)
                    return;
                line = _self.doc.getLine(pos.row);
                if (!completeUtil.canCompleteForChangedLine(line, options.line, pos, pos, identifierRegex)) {
                    setTimeout(function() {
                        if (threadId !== _self.waitForCompletionSyncThread)
                            return;
                        line = _self.doc.getLine(pos.row);
                        if (!completeUtil.canCompleteForChangedLine(line, options.line, pos, pos, identifierRegex)) {
                            if (!line) { // sanity check
                                console.log("worker: seeing an empty line in my copy of the document, won't complete");
                            }
                            return console.log("worker: dropped completion request as my copy of the document said: " + line); // ugh give up already
                        }
                        runCompletion(identifierRegex);
                    }, 20);
                    return;
                }
                runCompletion(identifierRegex);
            }, 5);
            return;
        }
        runCompletion(identifierRegex);
    };
    this.completeUpdate = function(pos, line) {
        assert(line !== undefined);
        this.completionCache = null;
        if (!isInWebWorker) { // Avoid making the stack too deep in ?noworker=1 mode
            var _self = this;
            setTimeout(function onCompleteUpdate() {
                _self.complete({ data: { pos: pos, line: line, isUpdate: true }});
            }, 0);
        }
        else {
            this.complete({ data: { pos: pos, line: line, isUpdate: true, forceBox: true }});
        }
    };
    function updateLocalCompletions(doc, path, pos, matches, callback) {
        if (matches.some(function(m) {
            return m.isContextual;
        }))
            return callback(null, matches);

        localCompleter.complete(doc, null, pos, null, function(err, results1) {
            if (err) return callback(err);
            openFilesCompleter.complete(doc, null, pos, { path: path }, function(err, results2) {
                if (err) console.error(err);

                callback(null, matches.filter(function(m) {
                    return m.$source !== "local" && m.$source !== "open_files";
                }).concat(results1, results2));
            });
        });
    }
    
    function reportError(exception, data) {
        if (data)
            exception.data = data;
        setTimeout(function() {
            throw exception; // throw bare exception so it gets reported
        });
    }
    
    function handleCallbackError(callback) {
        return function(optionalErr, result) {
            if (optionalErr &&
                (optionalErr instanceof Error || typeof optionalErr === "string" || optionalErr.stack || optionalErr.code)) {
                if (optionalErr.code !== "ESUPERSEDED")
                    console.error(optionalErr.stack || optionalErr);
                return callback(null, optionalErr);
            }
            callback(optionalErr || result);
        };
    }

}).call(LanguageWorker.prototype);

});

define("plugins/c9.ide.language.javascript/JSResolver",[], function(require, exports, module) {
  "use strict";

  var Range = require("ace/range").Range;

  var JSResolver = function(value, ast) {
    this.addResolutions = function(markers) {
      var _self = this;
      markers.forEach(function(curMarker) {
        curMarker.resolutions = _self.getResolutions(curMarker);
      });
    };
    
    this.getResolutions = function(marker) {
      var type = this.getType(marker);
      if (type) {
        if (typeof this[type] === 'function') {
          return this[type](marker);
        }
      }
      return [];
    }; 

    this.getType = function(marker) {
        var msg = marker.message;
        if (msg.indexOf("Missing semicolon") !== -1) {
            return "missingSemicolon";
        }
        else if (msg.indexOf("Unnecessary semicolon") !== -1) {
            return "unnecessarySemicolon";
        }
    }; 
    
    this.missingSemicolon = function(marker) {
        var message = "Add semicolon";
        var image = "";
        var row = marker.pos.sl;
        var column = marker.pos.sc;
        
        var lines = value.split("\n");
        var before = lines[row].substring(0, column);
        var after = lines[row].substring(column);
        var preview = "<b>Add semicolon</b><p>" + before + "<b>; </b>" + after + "</p>";
        
        var insert = ";";
        if (after.length) {
            insert += " ";
        }

        var delta = {
            action: "insert",
            range: new Range(row, column, row, column + insert.length),
            text: insert
        };
        
        return [{
            message: message,
            image: image,
            previewHtml: preview,
            deltas: [delta]
        }];
    };
    
    this.unnecessarySemicolon = function(marker) {
        var message = "Remove semicolon";
        var image = "";
        var row = marker.pos.sl;
        var column = marker.pos.sc;
        
        var lines = value.split("\n");
        var before = lines[row].substring(0, column);
        var after = lines[row].substring(column + 1);
        var preview = "<b>Remove semicolon</b><p>" + before + "<del>;</del>" + after + "</p>";

        var delta = {
            action: "removeText",
            range: new Range(row, column, row, column + 1)
        };
        
        return [{
            message: message,
            image: image,
            preview: preview,
            deltas: [delta]
        }];
    };

  };

  exports.JSResolver = JSResolver;

});

define("plugins/c9.ide.language.javascript/scope_analyzer",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var completeUtil = require("plugins/c9.ide.language/complete_util");
var handler = module.exports = Object.create(baseLanguageHandler);
var JSResolver = require('plugins/c9.ide.language.javascript/JSResolver').JSResolver;
require("treehugger/traverse"); // add traversal functions to trees

var CALLBACK_METHODS = ["forEach", "map", "reduce", "filter", "every", "some",
    "__defineGetter__", , "__defineSetter__"];
var CALLBACK_FUNCTIONS = ["require", "setTimeout", "setInterval"];
var PROPER = module.exports.PROPER = 80;
var MAYBE_PROPER = module.exports.MAYBE_PROPER = 1;
var NOT_PROPER = module.exports.NOT_PROPER = 0;
var KIND_EVENT = module.exports.KIND_EVENT = "event";
var KIND_PACKAGE = module.exports.KIND_PACKAGE = "package";
var KIND_HIDDEN = module.exports.KIND_HIDDEN = "hidden";
var KIND_DEFAULT = module.exports.KIND_DEFAULT = undefined;
var IN_CALLBACK_DEF = 1;
var IN_CALLBACK_BODY = 2;
var IN_CALLBACK_BODY_MAYBE = 3;

var lastValue;
var lastAST;
var GLOBALS = {
    "true": true,
    "false": true,
    "undefined": true,
    "null": true,
    "arguments": true,
    "Infinity": true,
    onmessage: true,
    postMessage: true,
    importScripts: true,
    "continue": true,
    "return": true,
    "else": true,
    ArrayBuffer: true,
    Attr: true,
    Audio: true,
    addEventListener: true,
    applicationCache: true,
    blur: true,
    clearInterval: true,
    clearTimeout: true,
    close: true,
    closed: true,
    DataView: true,
    defaultStatus: true,
    document: true,
    event: true,
    FileReader: true,
    Float32Array: true,
    Float64Array: true,
    FormData: true,
    getComputedStyle: true,
    Int16Array: true,
    Int32Array: true,
    Int8Array: true,
    parent: true,
    print: true,
    removeEventListener: true,
    resizeBy: true,
    resizeTo: true,
    self: true,
    screen: true,
    scroll: true,
    scrollBy: true,
    scrollTo: true,
    sessionStorage: true,
    setInterval: true,
    setTimeout: true,
    SharedWorker: true,
    Uint16Array: true,
    Uint32Array: true,
    Uint8Array: true,
    WebSocket: true,
    window: true,
    Worker: true,
    XMLHttpRequest: true,
    alert: true,
    confirm: true,
    console: true,
    prompt: true,
    define: true,
    __filename: true,
    __dirname: true,
    Buffer: true,
    exports: true,
    GLOBAL: true,
    global: true,
    module: true,
    process: true,
    require: true,
    Array: true,
    Boolean: true,
    Date: true,
    decodeURI: true,
    decodeURIComponent: true,
    encodeURI: true,
    encodeURIComponent: true,
    Error: true,
    'eval': true,
    EvalError: true,
    Function: true,
    hasOwnProperty: true,
    isFinite: true,
    isNaN: true,
    JSON: true,
    Math: true,
    Number: true,
    Object: true,
    parseInt: true,
    parseFloat: true,
    RangeError: true,
    ReferenceError: true,
    RegExp: true,
    String: true,
    requestAnimationFrame: true,
    SyntaxError: true,
    TypeError: true,
    URIError: true,
    escape: true,
    unescape: true,
    Match: true,
    MeteorSubscribeHandle: true,
    Accounts: true,
    Blaze: true,
    DDP: true,
    EJSON: true,
    Meteor: true,
    Mongo: true,
    Tracker: true,
    Assets: true,
    App: true,
    Plugin: true,
    Package: true,
    Npm: true,
    Cordova: true,
    currentUser: true,
    loggingIn: true,
    Template: true,
    MethodInvocation: true,
    Subscription: true,
    CompileStep: true,
    check: true,
    Email: true,
    HTTP: true,
    ReactiveVar: true,
    Session: true,
    PackageAPI: true,
};

var KEYWORDS = [
    "break",
    "const",
    "continue",
    "delete",
    "do",
    "while",
    "export",
    "for",
    "in",
    "function",
    "if",
    "else",
    "import",
    "instanceof",
    "new",
    "return",
    "switch",
    "this",
    "throw",
    "try",
    "catch",
    "typeof",
    "void",
    "with",
    "debugger"
];
handler.GLOBALS = GLOBALS;

handler.addGlobals = function(globals) {
    globals.forEach(function(g) {
        GLOBALS[g] = true;
    });
};

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};
 
handler.getResolutions = function(value, ast, markers, callback) {
    var resolver = new JSResolver(value, ast);
    resolver.addResolutions(markers);
    callback(markers);
};

handler.getMaxFileSizeSupported = function() {
    return .25 * 10 * 1000 * 80;
};

var scopeId = 0;

var Variable = module.exports.Variable = function Variable(declaration) {
    this.declarations = [];
    if (declaration)
        this.declarations.push(declaration);
    this.uses = [];
    this.values = [];
};

Variable.prototype.addUse = function(node) {
    this.uses.push(node);
};

Variable.prototype.addDeclaration = function(node) {
    this.declarations.push(node);
};

Variable.prototype.markProperDeclaration = function(confidence) {
    if (!confidence)
        return;
    else if (!this.properDeclarationConfidence)
        this.properDeclarationConfidence = confidence;
    else if (this.properDeclarationConfidence < PROPER)
        this.properDeclarationConfidence += confidence;
};

Variable.prototype.isProperDeclaration = function() {
    return this.properDeclarationConfidence > MAYBE_PROPER;
};
var Scope = module.exports.Scope = function Scope(parent) {
    this.id = scopeId++;
    this.parent = parent;
    this.vars = {};
};
Scope.prototype.declare = function(name, resolveNode, properDeclarationConfidence, kind) {
    var result;
    var vars = this.getVars(kind);
    if (!vars['_' + name]) {
        result = vars['_' + name] = new Variable(resolveNode);
    }
    else if (resolveNode) {
        result = vars['_' + name];
        result.addDeclaration(resolveNode);
    }
    if (result) {
        result.markProperDeclaration(properDeclarationConfidence);
        result.kind = kind;
    }
    return result;
};

Scope.prototype.declareAlias = function(kind, originalName, newName) {
    var vars = this.getVars(kind);
    vars["_" + newName] = vars["_" + originalName];
};

Scope.prototype.getVars = function(kind) {
    if (kind)
        return this.vars[kind] = this.vars[kind] || {};
    else
        return this.vars;
};

Scope.prototype.isDeclared = function(name) {
    return !!this.get(name);
};
Scope.prototype.get = function(name, kind) {
    var vars = this.getVars(kind);
    if (vars['_' + name])
        return vars['_' + name];
    else if (this.parent)
        return this.parent.get(name, kind);
};

Scope.prototype.getVariableNames = function() {
    return this.getNamesByKind(KIND_DEFAULT);
};

Scope.prototype.getNamesByKind = function(kind) {
    var results = [];
    var vars = this.getVars(kind);
    for (var v in vars) {
        if (vars.hasOwnProperty(v) && v !== KIND_HIDDEN && v !== KIND_PACKAGE)
            results.push(v.slice(1));
    }
    if (this.parent) {
        var namesFromParent = this.parent.getNamesByKind(kind);
        for (var i = 0; i < namesFromParent.length; i++) {
            results.push(namesFromParent[i]);
        }
    }
    return results;
};

var SCOPE_ARRAY = Object.keys(GLOBALS).concat(KEYWORDS);

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z_0-9\$\/]/);
};

handler.complete = function(doc, ast, pos, options, callback) {
    if (!options.node || options.node.cons === "Var" || options.line[pos.column] === ".")
        return callback();

    var identifier = options.identifierPrefix;
    
    var matches = completeUtil.findCompletions(identifier, SCOPE_ARRAY);
    callback(matches.map(function(m) {
        return {
          name: m,
          replaceText: m,
          icon: null,
          meta: "EcmaScript",
          priority: 0,
          isGeneric: true
        };
    }));
};
handler.analyze = function(value, ast, callback, minimalAnalysis) {
    var handler = this;
    var markers = [];
    
    if (minimalAnalysis && value === lastValue && lastAST == ast)
        return callback();
    lastValue = value;
    lastAST = ast;
    function preDeclareHoisted(scope, node) {
        node.traverseTopDown(
            'VarDecl(x)', 'ConstDecl(x)', 'LetDecl(x)', function(b, node) {
                node.setAnnotation("scope", scope);
                scope.declare(b.x.value, b.x, PROPER);
                return node;
            },
            'VarDeclInit(x, e)', 'ConstDeclInit(x, e)', 'LetDeclInit(x, e)', function(b, node) {
                node.setAnnotation("scope", scope);
                scope.declare(b.x.value, b.x, PROPER);
            },
            'Function(x, _, _)', function(b, node) {
                node.setAnnotation("scope", scope);
                if (b.x.value) {
                    scope.declare(b.x.value, b.x, PROPER);
                }
                return node;
            },
            'ImportDecl(_, x)', 'ImportBatchDecl(x)', function(b, node) {
                if (b.x.cons !== "Var")
                    return node;
                scope.declare(b.x[0].value, b.x[0], PROPER);
                return node;
            }
        );
    }
    
    function scopeAnalyzer(scope, node, parentLocalVars, inCallback) {
        preDeclareHoisted(scope, node);
        node.setAnnotation("scope", scope);
        function analyze(scope, node, inCallback) {
            node.traverseTopDown(
                'Assign(Var(x), e)', function(b, node) {		
                    if (scope.isDeclared(b.x.value)) {
                        node[0].setAnnotation("scope", scope);		
                        scope.get(b.x.value).addUse(node[0]);		
                    }		
                    analyze(scope, b.e, inCallback);		
                    return node;		
                },
                'ImportDecl(_, x)', 'ImportBatchDecl(x)', function(b, node) {
                    return node;
                },
                'Var(x)', function(b, node) {
                    node.setAnnotation("scope", scope);
                    if (scope.isDeclared(b.x.value)) {
                        scope.get(b.x.value).addUse(node);
                    }
                    else if (b.x.value === "self"
                        && !scope.isDeclared(b.x.value)
                        && handler.isFeatureEnabled("undeclaredVars")) {
                        markers.push({
                            pos: this.getPos(),
                            level: 'warning',
                            type: 'warning',
                            message: "Use 'window.self' to refer to the 'self' global."
                        });
                        return;
                    }
                    return node;
                },
                'Function(x, fargs, body)', function(b, node) {
                    var newScope = new Scope(scope);
                    node.setAnnotation("localScope", newScope);
                    newScope.declare("this");
                    b.fargs.forEach(function(farg) {
                        farg.setAnnotation("scope", newScope);
                        newScope.declare(farg[0].value, farg);
                    });
                    var inBody = inCallback === IN_CALLBACK_DEF ? IN_CALLBACK_BODY : isCallback(node);
                    scopeAnalyzer(newScope, b.body, null, inBody);
                    return node;
                },
                'Arrow(fargs, body)', function(b, node) {
                    var newScope = new Scope(scope);
                    node.setAnnotation("localScope", newScope);
                    newScope.declare("this");
                    b.fargs.forEach(function(farg) {
                        farg.setAnnotation("scope", newScope);
                        newScope.declare(farg[0].value, farg);
                    });
                    scopeAnalyzer(newScope, b.body, null, inCallback);
                    return node;
                },
                'Catch(x, body)', function(b, node) {
                    var oldVar = scope.get(b.x.value);
                    scope.vars["_" + b.x.value] = new Variable(b.x);
                    scopeAnalyzer(scope, b.body, parentLocalVars, inCallback);
                    scope.vars["_" + b.x.value] = oldVar;
                    return node;
                },
                'If(Var("err"), Call(fn, args), None())', function(b, node) {
                    if (b.args.collectTopDown('Var("err")').length > 0 &&
                        !b.fn.isMatch('PropAccess(Var("console"), _)') &&
                        !b.fn.isMatch('PropAccess(_, "log")'))
                        markers.push({
                            pos: b.fn.getPos(),
                            type: 'warning',
                            level: 'warning',
                            message: "Did you forget a 'return' here?"
                        });
                },
                'PropAccess(_, "lenght")', function(b, node) {
                    markers.push({
                        pos: node.getPos(),
                        type: 'warning',
                        level: 'warning',
                        message: "Did you mean 'length'?"
                    });
                },
                'Call(PropAccess(e1, "bind"), e2)', function(b) {
                    analyze(scope, b.e1, 0);
                    analyze(scope, b.e2, inCallback);
                    return this;
                },
                'Call(e, args)', function(b, node) {
                    analyze(scope, b.e, inCallback);
                    var newInCallback = inCallback || (isCallbackCall(node) ? IN_CALLBACK_DEF : 0);
                    analyze(scope, b.args, newInCallback);
                    return node;
                },
                'Block(_)', function(b, node) {
                    node.setAnnotation("scope", scope);
                },
                'For(e1, e2, e3, body)', function(b) {
                    analyze(scope, b.e1, inCallback);
                    analyze(scope, b.e2, inCallback);
                    analyze(scope, b.body, inCallback);
                    analyze(scope, b.e3, inCallback);
                    return node;
                },
                'ForIn(e1, e2, body)', 'ForOf(e1, e2, body)', function(b) {
                    analyze(scope, b.e2, inCallback);
                    analyze(scope, b.e1, inCallback);
                    analyze(scope, b.body, inCallback);
                    return node;
                }
            );
        }
        analyze(scope, node, inCallback);
    }
    
    if (ast) {
        var rootScope = new Scope();
        scopeAnalyzer(rootScope, ast);
        addDefineWarnings(ast, markers);
    }
    return callback(markers);
};

function addDefineWarnings(ast, markers) {
    var isArchitect;
    var outerStrictNode;
    ast.forEach(function(node) {
        node.rewrite(
            'String("use strict")', function(b, node) {
                outerStrictNode = node;
            },
            'Call(Var("define"), [Function(_, _, body)])', function(b, node) {
                b.body.forEach(function(node) {
                    if (outerStrictNode) {
                        markers.push({
                            pos: outerStrictNode.getPos(),
                            type: 'warning',
                            level: 'warning',
                            message: '"use strict" outside define()'
                        });
                    }

                    node.rewrite(
                        'Assign(PropAccess(Var("main"), "provides"),_)', function(b, node) {
                            isArchitect = true;
                        },
                        'Function("main", _, body)', function(b, node) {
                            if (!isArchitect)
                                return;
                            addCloud9PluginWarnings(b.body, markers);
                        }
                    );
                });
            }
        );
    });
}

function addCloud9PluginWarnings(body, markers) {
    var isCoreSource = /plugins\/c9\./.test(handler.path);
    var pluginVars = {};
    var unloadFunction;
    var unloadReference;
    var maybeUnloadFunction;

    body.forEach(function(node) {
        node.rewrite(
            'VarDecls(vars)', function(b, node) {
                b.vars.forEach(function(v) {
                    v.rewrite(
                        'VarDecl(x)', 'LetDecl(x)',
                        'VarDeclInit(x, _)', 'LetDeclInit(x, _)',
                        function(b, node) {
                            pluginVars[b.x.value] = node;
                        }
                    );
                });
            },
            'Call(PropAccess(Var("plugin"), "on"), [String("unload"), Function(_, _, fn)])', function(b, node) {
                unloadFunction = b.fn;
            },
            'Call(PropAccess(Var("plugin"), "on"), [String("unload"), ref])', function(b, node) {
                unloadReference = b.ref;
            },
            'Function("unload", _, fn)', function(b, node) {
                maybeUnloadFunction = b.fn;
            }
        );
    });

    if (!unloadFunction && unloadReference && maybeUnloadFunction
        && unloadReference[0] && unloadReference[0].value === "unload")
        unloadFunction = maybeUnloadFunction;

    if (!unloadFunction) {
        if (pluginVars.plugin && !unloadReference) {
            markers.push({
                pos: pluginVars.plugin.getPos(),
                type: isCoreSource ? "info" : "warning",
                message:
                    isCoreSource
                        ? "No plugin.on(\"load\", function() {}) and/or plugin.on(\"unload\", function() {}) found"
                        : "Missing plugin.on(\"load\", function() {}) or plugin.on(\"unload\", function() {})"
            });
        }
        return;
    }

    var mustUninitVars = {};
    body.traverseTopDown(
        'Assign(Var(x), _)', 'Call(Var(x), "push", _)', function(b, node) {
            if (pluginVars[b.x.value])
                mustUninitVars[b.x.value] = pluginVars[b.x.value];
        }
    );
    
    unloadFunction.traverseTopDown(
        'Var(x)', function(b, node) {
            delete mustUninitVars[b.x.value];
        }
    );

    for (var v in mustUninitVars) {
        if (v === v.toUpperCase())
            continue;
        markers.push({
            pos: mustUninitVars[v].getPos(),
            type: isCoreSource ? "info" : "warning",
            message: "Plugin state; please uninit/reset '" + v + "' in plugin unload function"
        });
    }
}
var isCallbackCall = function(node) {
    var result;
    node.rewrite(
        'Call(PropAccess(_, p), args)', function(b) {
            if (b.args.length === 1 && CALLBACK_METHODS.indexOf(b.p.value) !== -1)
                result = true;
        },
        'Call(Var(f), _)', function(b) {
            if (CALLBACK_FUNCTIONS.indexOf(b.f.value) !== -1)
                result = true;
        }
    );
    return result;
};
var isCallback = function(node) {
    var parent = node.parent;
    var parentParent = parent && parent.parent;
    if (!parentParent)
        return false;
    try {
        if (!parentParent.isMatch)
            console.log("isCallback debug:", JSON.stringify(parentParent));
    } catch (e) {
    }
    if (parent.isMatch('PropAccess(_, "call")')
        || parent.isMatch('PropAccess(_, "apply")')
        || parent.isMatch('PropAccess(_, "bind")')
        || !parentParent.isMatch('Call(_, _)')
        || (parentParent.cons === "Call" &&
            parentParent[0].cons === "PropAccess" &&
            parentParent[1].length > 1 &&
            CALLBACK_METHODS.indexOf(parentParent[0][1].value) > -1)
        )
        return false;
    var result = 0;
    node.rewrite(
        'Function(_, fargs, _)', function(b) {
            if (b.fargs.length === 0 || b.fargs[0].cons !== 'FArg')
                return result = IN_CALLBACK_BODY_MAYBE;
            var name = b.fargs[0][0].value;
            result = name === 'err' || name === 'error' || name === 'exc'
                ? IN_CALLBACK_BODY
                : IN_CALLBACK_BODY_MAYBE;
        }
    );
    return result;
};

handler.getRefactorings =
handler.highlightOccurrences = function(doc, fullAst, cursorPos, options, callback) {
    if (!options.node)
        return callback();
    
    if (!fullAst.annos.scope) {
        return handler.analyze(doc.getValue(), fullAst, function() {
            handler.highlightOccurrences(doc, fullAst, cursorPos, options, callback);
        }, true);
    }

    var markers = [];
    var enableRefactorings = [];
    
    function highlightVariable(v) {
        if (!v)
            return;
        v.declarations.forEach(function(decl) {
            if (decl.getPos())
                markers.push({
                    pos: decl.getPos(),
                    type: 'occurrence_main'
                });
        });
        v.uses.forEach(function(node) {
            markers.push({
                pos: node.getPos(),
                type: 'occurrence_other'
            });
        });
    }
    options.node.rewrite(
        'Var(x)', function(b, node) {
            var scope = node.getAnnotation("scope");
            if (!scope)
                return;
            var v = scope.get(b.x.value);
            highlightVariable(v);
            if (b.x.value !== "this" && v)
                enableRefactorings.push("rename");
        },
        'VarDeclInit(x, _)', 'ConstDeclInit(x, _)', 'LetDeclInit(x, _)', function(b) {
            highlightVariable(this.getAnnotation("scope").get(b.x.value));
            enableRefactorings.push("rename");
        },
        'VarDecl(x)', 'ConstDecl(x)', 'LetDecl(x)', function(b) {
            highlightVariable(this.getAnnotation("scope").get(b.x.value));
            enableRefactorings.push("rename");
        },
        'FArg(x)', function(b) {
            highlightVariable(this.getAnnotation("scope").get(b.x.value));
            enableRefactorings.push("rename");
        },
        'Function(x, _, _)', function(b, node) {
            if (!b.x.value || !node.getAnnotation("scope"))
                return;
            highlightVariable(node.getAnnotation("scope").get(b.x.value));
            enableRefactorings.push("rename");
        }
    );

    callback({
        markers: markers,
        refactorings: enableRefactorings
    });
};

handler.getRenamePositions = function(doc, fullAst, cursorPos, options, callback) {
    var currentNode = options.node;
    if (!fullAst || !currentNode)
        return callback();
    
    if (!fullAst.annos.scope) {
        return handler.analyze(doc.getValue(), fullAst, function() {
            handler.getRenamePositions(doc, fullAst, cursorPos, options, callback);
        }, true);
    }

    var v;
    var mainNode;
    currentNode.rewrite(
        'VarDeclInit(x, _)', 'ConstDeclInit(x, _)', 'LetDeclInit(x, _)', function(b, node) {
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = b.x;
        },
        'VarDecl(x)', 'ConstDecl(x)', 'LetDecl(x)', function(b, node) {
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = b.x;
        },
        'FArg(x)', function(b, node) {
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = node;
        },
        'Function(x, _, _)', function(b, node) {
            if (!b.x.value)
                return;
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = b.x;
        },
        'Var(x)', function(b, node) {
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = node;
        }
    );
    if (!mainNode) {
        return callback();
    }
    
    var pos = mainNode.getPos();
    var declarations = [];
    var uses = [];

    var length = pos.ec - pos.sc;
    v && v.declarations.forEach(function(node) {
         if (node !== currentNode[0]) {
            var pos = node.getPos();
            declarations.push({ column: pos.sc, row: pos.sl });
        }
    });
    
    v && v.uses.forEach(function(node) {
        if (node !== currentNode) {
            var pos = node.getPos();
            uses.push({ column: pos.sc, row: pos.sl });
        }
    });
    callback({
        length: length,
        pos: {
            row: pos.sl,
            column: pos.sc
        },
        others: declarations.concat(uses),
        declarations: declarations,
        uses: uses
    });
};

});

define("plugins/c9.ide.language/worker_util",[], function(require, exports, module) {

var worker = require("plugins/c9.ide.language.core/worker");
var completeUtil = require("./complete_util");

var MAX_MEMO_DICT_SIZE = 3000;
var msgId = 0;
var docCache = { row: null, entries: {}};

module.exports = {
    isFeatureEnabled: function(name) {
        return !disabledFeatures[name];
    },
    getIdentifierRegex: function(offset) {
        return worker.$lastWorker.getIdentifierRegex(offset);
    },
    completeUpdate: function(pos, line) {
        return worker.$lastWorker.completeUpdate(pos, line);
    },
    execFile: function(path, options, callback) {
        if (typeof options === "function")
            return this.execFile(path, {}, arguments[1]);
        
        var id = msgId++;
        worker.sender.emit("execFile", { path: path, options: options, id: id });
        worker.sender.on("execFileResult", function onExecFileResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("execFileResult", onExecFileResult);
            callback && callback(event.data.err, event.data.stdout, event.data.stderr);
        });
    },
    spawn: function(path, options, callback) {
        if (typeof options === "function")
            return this.execFile(path, {}, arguments[1]);
        
        var id = msgId++;
        worker.sender.emit("spawn", { path: path, options: options, id: id });
        worker.sender.on("spawnResult", function onSpawnResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("spawnResult", onSpawnResult);
            callback && callback(event.data.err, {
                stdout: { on: listen.bind(null, "stdout") },
                stderr: { on: listen.bind(null, "stderr") },
                on: listen.bind(null, "child"),
                kill: function(signal) {
                    worker.sender.emit("spawn_kill$" + id, { signal: signal });
                }
            });
            
            function listen(sourceName, event, listener) {
                worker.sender.on("spawnEvent$" + id + sourceName + event, function(e) {
                    listener(e.data);
                });
                worker.sender.on("spawnEvent$" + id + "childexit", function gc() {
                    setTimeout(function() {
                        worker.sender.off("spawnEvent$" + id + sourceName + event, listener);
                        worker.sender.off("spawnEvent$" + id + "childexit", gc);
                    });
                });
            }
        });
    },
    execAnalysis: function(command, options, callback) {
        if (typeof options === "function")
            return this.execAnalysis(command, {}, arguments[1]);
        
        var myWorker = worker.$lastWorker;
        options.command = command;
        options.path = options.path || (myWorker.$path && myWorker.$path[0] === "/" ? myWorker.$path.substr(1) : myWorker.$path);
        options.cwd = options.cwd || getRelativeDirname(options.path);
        options.maxBuffer = options.maxBuffer || 200 * 1024;
        var maxCallInterval = options.maxCallInterval || 50;
        if (myWorker.$overrideLine) {
            maxCallInterval = 0;
            options.overrideLineRow = myWorker.$lastCompleteRow;
            options.overrideLine = options.overrideLine || myWorker.$overrideLine;
        }
        else {
            options.overrideLineRow = myWorker.$lastCompleteRow;
            options.overrideLine = options.overrideLine || myWorker.doc.getLine(options.overrideLineRow);
        }
        if (options.path && options.path[0] === "/")
            return callback(new Error("Only workspace-relative paths are supported"));
        var id = msgId++;
        worker.sender.emit("jsonalyzerCallServer", {
            id: id,
            handlerPath: "plugins/c9.ide.language.jsonalyzer/server/invoke_helper",
            method: "invoke",
            filePath: options.path && (options.path[0] === "~" ? options.path : "/" + options.path),
            maxCallInterval: maxCallInterval,
            timeout: options.timeout || 30000,
            semaphore: "semaphore" in options
                ? options.semaphore
                : command + "|" + myWorker.$language,
            args: [options.path, null, null, options]
        });
        worker.sender.on("jsonalyzerCallServerResult", function onResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("jsonalyzerCallServerResult", onResult);
            var stdout = tryParseJSON(event.data.result[1]);
            var stderr = tryParseJSON(event.data.result[2]);
            callback(event.data.result[0], stdout, stderr, {
                serverTime: event.data.result[3],
            });
        });
        
        function getRelativeDirname(file) {
            return file && file.replace(/([\/\\]|^)[^\/\\]+$/, "").replace(/^\//, "");
        }
        
        function tryParseJSON(string) {
            try {
                return options.json ? JSON.parse(string) : string;
            }
            catch (e) {
                return string;
            }
        }
    },
    readFile: function(path, options, callback) {
        if (!callback) { // fix arguments
            callback = options;
            options = null;
        }
        
        if (worker.$lastWorker.$path === path) {
            callback && setTimeout(callback.bind(null, null, worker.$lastWorker.doc.getValue()), 0);
            return;
        }
        
        if (path.match(/\/$/) || path === ".") { // fail fast
            var err = new Error("File is a directory");
            err.code = "EISDIR";
            return callback(err);
        }
        
        var id = msgId++;
        worker.sender.on("readFileResult", function onReadFileResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("readFileResult", onReadFileResult);
            callback && callback(event.data.err && JSON.parse(event.data.err), event.data.data);
        });
        worker.sender.emit("readFile", { path: path, options: options, id: id });
    },
   stat: function(path, callback) {
        var id = msgId++;
        worker.sender.on("statResult", function onReadFileResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("statResult", onReadFileResult);
            callback && callback(event.data.err && JSON.parse(event.data.err), event.data.data);
        });
        worker.sender.emit("stat", { path: path, id: id });
    },
    filterDocumentation: function(doc) {
        if (docCache.entries["_" + doc])
            return docCache.entries["_" + doc];
        var lastRow = worker.$lastWorker.$lastCompleteRow;
        if (docCache.row !== lastRow)
            docCache.entries = {};
        docCache.row = lastRow;
        
        var result = escapeHtml(doc)
            .replace(/(\n|^)[ \t]*\*+[ \t]*/g, "\n")
            .trim()
            .replace(/@(param|public|private|platform|event|method|function|class|constructor|fires?|throws?|returns?|internal|ignore)/, "<br/>@$1")
            .replace(/\n\n(?!@)/g, "<br/><br/>")
            .replace(/@(param|public|private|platform|event|method|function|class|constructor|fires?|throws?|returns?|internal|ignore) ({[\w\.]+} )?(\[?[\w\.]+\]?)/g, "<br><b>@$1</b> <i>$2$3</i>&nbsp;")
            .replace(/\n@(\w+)/g, "<br/>\n<b>@$1</b>")
            .replace(/&lt;(\/?)code&gt;/g, "<$1tt>")
            .replace(/&lt;(\/?)(b|i|em|br|a) ?\/?&gt;/g, "<$1$2>")
            .replace(/&lt;(a\s+(target=('|&quot;)[^"'&]*('|&quot;)\s+)?href=('|&quot;)(https?:\/\/|#)[^"'&]*('|&quot;)\s*(target=('|&quot;)[^"'&]*('|&quot;)\s*)?)&gt;/g, '<$1 target="_docs">');
        docCache.entries["_" + doc] = result;
        return result;

        function escapeHtml(str) {
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;");
        }
    },
    showError: function(message, timeout, info) {
        if (message.stack) {
            console.error(message.stack);
            message = message.message;
        }
        var id = msgId++;
        var token;
        worker.sender.once("showErrorResult", function onResult(e) {
            token = e.token;
        });
        worker.sender.emit("showError", { message: message, timeout: timeout, id: id, info: info });
        return {
            hide: function hide() {
                if (token)
                    return worker.sender.emit("showError", { token: token });
                setTimeout(hide, 50);
            }
        };
    },
    showInfo: function(message, timeout) {
        return this.showError(message, timeout, true);
    },
    asyncForEach: function(array, fn, callback) {
        worker.asyncForEach(array, fn, callback);
    },
    getOpenFiles: function() {
        var results = [];
        var set = worker.$lastWorker.$openDocuments;
        Object.keys(set).forEach(function(e) {
            results.push(set[e]);
        });
        return results;
    },
    refreshAllMarkers: function() {
        worker.sender.emit("refreshAllMarkers");
    },
    getPrecedingIdentifier: function(line, offset, regex) {
        regex = regex || this.getIdentifierRegex(offset);
        return completeUtil.retrievePrecedingIdentifier(line, offset, regex);
    },
    getFollowingIdentifier: function(line, offset, regex) {
        regex = regex || this.getIdentifierRegex(offset);
        return completeUtil.retrieveFollowingIdentifier(line, offset, regex);
    },
    getIdentifier: function(line, offset, regex) {
        regex = regex || this.getIdentifierRegex(offset);
        return this.getPrecedingIdentifier(line, offset, regex)
            + this.getFollowingIdentifier(line, offset, regex);
    },
    getTokens: function(doc, identifiers, callback) {
        var id = msgId++;
        worker.sender.emit("getTokens", {
            path: worker.$lastWorker.$path,
            identifiers: identifiers,
            id: id,
            region: doc.region
        });
        worker.sender.on("getTokensResult", function onResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("getTokensResult", onResult);
            callback(event.data.err, event.data.results);
        });
    },
    
    getQuickfixKey: function() {
        return worker.$lastWorker.$keys.quickfix;
    },
    $watchDir: function(path, plugin) {
        worker.sender.emit("watchDir", { path: path });
    },
    $unwatchDir: function(path, plugin) {
        worker.sender.emit("watchDir", { path: path });
    },
    $onWatchDirChange: function(listener) {
        worker.sender.on("watchDirResult", listener);
    },
    $offWatchDirChange: function(listener) {
        worker.sender.off("watchDirResult", listener);
    }
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/semantic_index",[], function(require, exports, module) {

var handler /*: require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker")*/;
var scopeAnalyzer = require('plugins/c9.ide.language.javascript/scope_analyzer');
var workerUtil = require("plugins/c9.ide.language/worker_util");
var KIND_PACKAGE = scopeAnalyzer.KIND_PACKAGE;
var KIND_HIDDEN = scopeAnalyzer.KIND_HIDDEN;
var GC_INTERVAL = 5 * 60 * 1000;

var index = module.exports;

var analyzedFiles = {};
var pathGuids = {};
var accessedSinceGC = {};
var summaries = {};
var imports = {};
    
index.init = function(_handler) {
    handler = _handler;
    
    var _self = this;
    setInterval(function() {
        _self.gc();
    }, GC_INTERVAL);
};
index.getAny = function(guidsOrPaths) {
    return guidsOrPaths.map(index.get.bind(index)).filter(function(i) {
        return !!i;
    });
};
index.get = function(guidOrPath) {
    accessedSinceGC["_" + guidOrPath] = true;
    var guid = pathGuids["_" + guidOrPath];
    return guid ? summaries["_" + guid] : summaries["_" + guidOrPath];
};
index.getImports = function(guidOrPath, excludeAnalyzed) {
    accessedSinceGC["_" + guidOrPath] = true;
    var guid = pathGuids["_" + guidOrPath];
    var results = guid ? imports["_" + guid] : imports["_" + guidOrPath];
    if (!results)
        return [];
    if (excludeAnalyzed)
        results = results.filter(function(r) { return !index.get(r); });
    return results;
};
index.set = function(path, guidPrefix, summary, pathImports) {
    var guid = summary && summary.guid || guidPrefix + path;
    pathGuids["_" + path] = guid;
    if (summary) {
        summary.path = path;
        summaries["_" + guid] = summary;
    }
    if (pathImports)
        imports["_" + guid] = pathImports;
};
index.setBroken = function(path, reason) {
    var guid = "broken:" + path;
    pathGuids["_" + path] = guid;
    summaries["_" + guid] = {
        broken: reason || "broken"
    };
    imports["_" + guid] = [];
};
index.flattenSummary = function(summary, result) {
    if (!summary)
        return {};
    result = result || {};
    
    var that = this;
    if (Array.isArray(summary)) {
        summary.forEach(function(e) { that.flattenSummary(e, result);});
        return result;
    }
    if (!summary || !summary.properties)
        return result;
    
    for (var p in summary.properties) {
        if (!result[p])
            result[p] = summary.properties[p];
        else
            result[p] = result[p].concat(summary.properties[p]);
        this.flattenSummary(summary.properties[p], result);
    }
    
    return result;
};
index.findEntries = function(summary, entry, matchByPrefix, dontFindAll) {
    function findUnderscoreEntries(properties, uentry) {
        if (!matchByPrefix && properties[uentry]) {
            result[uentry] = (result[uentry] || []).concat(properties[uentry]);
            if (dontFindAll)
                return;
        }
        
        for (var p in properties) {
            if (matchByPrefix && p.indexOf(uentry) === 0) {
                result[p] = (result[p] || []).concat(properties[p]);
                if (dontFindAll)
                    return;
            }
            if (!properties[p].properties)
                continue;
            findUnderscoreEntries(properties[p].properties, uentry);
        }
    }
    
    if (!summary.properties)
        return {};
    if (entry === "" && matchByPrefix)
        return this.flattenSummary(summary);
        
    var result = {};
    findUnderscoreEntries(summary.properties, "_" + entry);
    return result;
};

index.hasEntries = function(summary, entry, matchByPrefix) {
    return !!Object.keys(this.findEntries(summary, entry, matchByPrefix, true)).length;
};

index.removeByPath = function(path) {
    var guid = pathGuids["_" + path];
    if (!guid)
        return;

    delete analyzedFiles["_" + path];
    delete pathGuids["_" + guid];
    delete summaries[guid];
};

index.removeByPathPrefix = function(pathPrefixes) {
    for (var upath in pathGuids) {
        var matches = pathPrefixes.filter(function(p) {
            return upath.indexOf(p) === 1;
        });
        if (matches.length === 0)
            continue;
        
        var uguid = "_" + pathGuids[upath];
        delete summaries[uguid];
        delete imports[uguid];
        delete pathGuids[upath];
    }
};
index.gc = function() {
    var openFiles = workerUtil.getOpenFiles();
    for (var upath in pathGuids) {
        var guid = pathGuids[upath];
        
        if (accessedSinceGC[upath])
            continue;
        if (accessedSinceGC["_" + guid] || openFiles.indexOf(upath.substr(1)) > -1)
            continue;
        
        delete pathGuids[upath];
        delete summaries["_" + guid];
        delete imports["_" + guid];
    }
    accessedSinceGC = {};
};

index.clear = function() {
    pathGuids = {};
    summaries = {};
    imports = {};
    accessedSinceGC = {};
};

index.markStale = function(handler) {
    if (!handler)
        return;
    for (s in summaries) {
        if (summaries[s].handler === handler)
            summaries[s].stale = true;
    }
};

index.$clearAccessedSinceGC = function() {
    accessedSinceGC = {};
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/file_indexer",[], function(require, exports, module) {

var indexer = module.exports;
var index = require("./semantic_index");
var languageWorker = require("plugins/c9.ide.language.core/worker");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var assert = require("c9/assert");
var worker;

var QUEUE_DELAY = 5 * 1000;
var QUEUE_MAX_TIME = 120 * 1000;

var queueSet = {};
var queueTimer;
var queueWatcher;
var isJobActive = false;
var queueCallbacks = [];
var lastPath;
var lastDocValue;

indexer.init = function(_worker) {
    worker = _worker;
};
indexer.analyzeCurrent = function(path, docValue, ast, options, callback) {
    var entry = index.get(path);
    if (entry && !entry.stale &&
        (languageWorker.$lastWorker.updateScheduled || languageWorker.$lastWorker.updateAgain)) {
        entry.stale = true; // only do this once
        return callback(null, entry, index.getImports(path), entry.markers);
    }
    if (entry && !entry.stale && path === lastPath && docValue === lastDocValue)
        return callback(null, entry, index.getImports(path), entry.markers);
    
    lastPath = path;
    lastDocValue = docValue;
    
    var language = worker.language;
    var plugin = worker.getHandlerFor(path, language);
    options.language = language;
    
    var watcher = setTimeout(function() {
        console.log("Warning: did not receive a response for 20 seconds from " + plugin.$source);
    }, 20000);
    return plugin.analyzeCurrent(path, docValue, ast, options, function(err, indexEntry, markers) {
        clearTimeout(watcher);
        if (err) {
            index.setBroken(path, err);
            return callback(err);
        }
        assert(indexEntry || markers, "jsonalyzer handler must return a summary and/or markers");
        
        indexEntry = indexEntry || index.get(path) || {};
        markers = indexEntry.markers = indexEntry.markers || markers;
        indexEntry.handler = plugin;
        
        if (!options.service) {
            index.set(path, plugin.guidName + ":", indexEntry);
        }
        else {
            var oldEntry = index.get(path);
            if (oldEntry)
                oldEntry.stale = true;
        }
        
        plugin.findImports(path, docValue, ast, options, function(err, imports) {
            if (err) {
                console.error("[jsonalyzer] error finding imports for " + path + ": " + err);
                imports = [];
            }
            imports = (imports || []).filter(function(i) {
                return i !== path;
            });
            index.set(path, plugin.guidName + ":", null, imports);
            callback(null, indexEntry, imports, markers);
        });
    });
};
var enqueue = indexer.analyzeOthers = function(paths, now, callback) {
    if (callback)
        queueCallbacks.push(callback);
    
    for (var i = 0; i < paths.length; i++) {
        queueSet["_" + paths[i]] = paths[i];
    }
    
    if (now)
        return consumeQueue();
    
    if (!queueTimer)
        queueTimer = setTimeout(consumeQueue, QUEUE_DELAY);
};

function consumeQueue() {
    queueTimer = null;
    if (isJobActive)
        return;
    isJobActive = true;
    updateQueueWatcher();
    
    var paths = [];
    for (var item in queueSet) {
        if (index.get(queueSet[item]))
            continue;
        paths.push(queueSet[item]);
    }
    queueSet = {};
    
    var pathsPerPlugin = {};
    for (var i = 0; i < paths.length; i++) {
        var plugin = worker.getHandlerFor(paths[i]);
        if (!plugin) // path added when not fully initialized yet
            continue;
        if (!pathsPerPlugin[plugin.guidName]) {
            pathsPerPlugin[plugin.guidName] = {
                plugin: plugin,
                paths: []
            };
        }
        pathsPerPlugin[plugin.guidName].paths.push(paths[i]);
    }
    
    workerUtil.asyncForEach(
        Object.keys(pathsPerPlugin),
        function(guidName, next) {
            var task = pathsPerPlugin[guidName];
            task.paths = task.paths.filter(function(path) {
                var entry = index.get(path);
                return !entry || entry.stale;
            });
                 
            task.plugin.analyzeOthers(task.paths, {}, function(errs, results) {
                assert(!errs || Array.isArray(errs));
                updateQueueWatcher();
                
                if (!results)
                    return next();
                var pathsCopy = task.paths.slice();
                var resultsCopy = (results || []).slice();
                var errsCopy = (errs || []).slice();
                
                while (pathsCopy.length) {
                    var err = errsCopy.pop();
                    var path = pathsCopy.pop();
                    var result = resultsCopy.pop();
                    if (err) {
                        index.setBroken(path, err);
                        console.log("[jsonalyzer] Warning: failed to import " + path + ": " + err);
                        continue;
                    }
                    assert(result);
                    result.handler = task.plugin;
                    index.set(path, guidName + ":", result);
                }
                
                next();
            });
        },
        done
    );
    
    function done() {
        isJobActive = false;
        clearTimeout(queueWatcher);
        var callbacks = queueCallbacks;
        queueCallbacks = [];
        callbacks.forEach(function(callback) { callback(); });
    }
    
    function updateQueueWatcher() {
        clearTimeout(queueWatcher);
        queueWatcher = setTimeout(function() {
            isJobActive = false;
            console.error("Warning: file_indexer plugin timeout, restarting");
            consumeQueue();
        }, QUEUE_MAX_TIME);
    }
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/jumptodef",[], function(require, exports, module) {

var index = require("./semantic_index");
var handler;
var worker = require("plugins/c9.ide.language.core/worker");
var fileIndexer = require("./file_indexer");
var workerUtil = require("plugins/c9.ide.language/worker_util");

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    var line = doc.getLine(pos.row);
    var docValue = doc.getValue();
    var identifier = workerUtil.getIdentifier(line, pos.column);
    var indexOptions = {};
    var that = this;
    fileIndexer.analyzeCurrent(handler.path, docValue, fullAst, indexOptions, function(err, summary, imports) {
        if (err) {
            if (err.code === "ESUPERSEDED")
                return that.jumpToDefinition(doc, fullAst, pos, options, callback);
            console.error(err);
            return callback(); // can't pass error to this callback
        }
        worker.$lastWorker.getOutline(function(outline) {
            var results = [];
            if (outline && outline.items)
                results = findInOutline(outline.items, identifier);
            if (!results.length)
                results = findInSummaries([summary], identifier, results);
            var needAllImports = !results.length;
            if (needAllImports)
                fileIndexer.analyzeOthers(imports, needAllImports, done);
            else
                done();
            
            function done() {
                var summaries = index.getAny(imports);
                results = findInSummaries(summaries, identifier, results);
                if (doc.region)
                    results.forEach(function(result) {
                        result.row -= doc.region.sl;
                    });
                callback(results);
            }
        });
    });
};

function findInSummaries(summaries, identifier, results) {
    summaries.forEach(function(summary) {
        var entries = index.findEntries(summary, identifier);
        for (var uname in entries) {
            entries[uname].forEach(function(entry) {
                results.push({
                    row: entry.row,
                    column: entry.column,
                    path: summary.path,
                    icon: entry.icon
                        || entry.kind === "package" && "package"
                        || entry.kind === "event" && "event"
                        || "unknown2",
                    isGeneric: true
                });
            });
        }
    });
    return results;
}

function isNameMatch(identifier, indexName) {
    return identifier === indexName
        || indexName.replace && identifier === indexName.replace(/(.*\.)?([^.]*?)(\([^\]]*\))?$/, "$2");
}

function findInOutline(outline, identifier, results) {
    if (!results)
        results = [];
    for (var i = 0; i < outline.length; i++) {
        if (isNameMatch(identifier, outline[i].name)) {
            results.push({
                row: outline[i].pos.sl,
                column: outline[i].pos.sc,
                icon: outline[i].icon,
                isGeneric: true
            });
        }
        if (outline[i].items)
            findInOutline(outline[i].items, identifier, results);
    }
    return results;
}

function getPropertyName(node) {
    var result;
    node.rewrite(
        'PropAccess(o, p)', function(b) {
            result = b.p.value; 
        }
    );
    return result;
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util",[], function(require, exports, module) {

var assert = require("c9/assert");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var jsonalyzer;

var MAX_DOCHEAD_LENGTH = 80;
var EXTENSION_GROUPS;

module.exports.MAX_DOCHEAD_LENGTH = MAX_DOCHEAD_LENGTH;

module.exports.EXTENSION_GROUPS = EXTENSION_GROUPS;

module.exports.init = function(ctags, _jsonalyzer) {
    if (typeof _jsonalyzer === "function") {
        return _jsonalyzer();
    }
    
    jsonalyzer = _jsonalyzer || jsonalyzer;
    EXTENSION_GROUPS = ctags.LANGUAGES.map(function(l) { return l.extensions; });
};

module.exports.extractDocumentationAtRow = function(lines, row) {
    var prevRow = row > 0 ? row - 1 : 0;
    var line = lines[prevRow];
    if (line && line.match(/^\s*#/)) {
        line = line.match(/^\s*#\s*(.*)/)[1];
        var results = [line];
        for (var start = prevRow - 1; start >= 0; start--) {
            line = lines[start];
            if (!line.match(/^\s*#/))
                break;
            results.push(line.match(/^\s*#\s*(.*)/)[1]);
        }
        return workerUtil.filterDocumentation(results.join("\n"));
    }
    if (lines[row + 1] && lines[row + 1].match(/^\s*"""/)) {
        var result = "";
        for (var cur = row + 1; lines[cur]; cur++) {
            result += lines[cur].replace(/^\s*|\s*"""\s*/g, "") + "\n";
            if (lines[cur].match(/[^\s"]+\s*"""/))
                break;
        }
        return result;
    }
    var end = null;
    for (var cur = prevRow; cur >= 0; cur--) {
        line = lines[cur];
        for (var col = line.length - 2; col >= 0; col--) {
            if (!end) {
                if (line.substr(col, 2) === "*/") {
                    end = { sl: cur, sc: col };
                    col--;
                } else if (!line[col].match(/[\s\/]/)) {
                    return;
                }
            } else if (line.substr(col, 2) === "/*") {
                var rows = ["", line.substr(col + 3)];
                for (var r = cur + 1; r < end.sl; r++)
                    rows.push(lines[r]);
                rows.push(lines[end.sl].substr(0, end.sc));
                if (end.sl === cur)
                    rows = ["", line.substring(col + 3, end.sc)];
                return workerUtil.filterDocumentation(rows.join("\n"));
            }
        }
    }
};
module.exports.findMatchingTags = function(path, docValue, tag, guessFargs, extractDocumentation, results) {
    assert(tag.regex.global, "Regex must use /g flag: " + tag.regex);
    var _self = this;
    var lines = path === jsonalyzer.path && jsonalyzer.doc
        ? jsonalyzer.doc.getAllLines()
        : docValue.split(/\n/);
    
    docValue.replace(tag.regex, function(fullMatch, name, offset) {
        assert(typeof offset === "number", "Regex must have exactly one capture group: " + tag.regex);
        
        var addedOffset = fullMatch.indexOf(name);
        var row = getOffsetRow(docValue, offset + (addedOffset === -1 ? 0 : addedOffset));
        var line = lines[row];
        
        var doc, docHead;
        if (extractDocumentation && line) {
            docHead = line.length > MAX_DOCHEAD_LENGTH
                ? line.substr(line.length - MAX_DOCHEAD_LENGTH) + "..."
                : line;
            doc = _self.extractDocumentationAtRow(lines, row);
        }
        
        results["_" + name] = results["_" + name] || [];
        
        if (tag.docOnly) { // HACK: tag that only contributes documentation
            if (!doc)
                return;
            if (results["_" + name][0]) {
                results["_" + name][0].doc = doc;
                return;
            }
        }
        
        results["_" + name].push({
            row: row,
            docHead: docHead,
            guessFargs: guessFargs,
            doc: doc,
            kind: tag.kind,
            indent: tag.indent,
        });
        return fullMatch;
    });
    
    return results;
};
module.exports.findMatchingOpenFiles = function(path) {
    var openFiles = workerUtil.getOpenFiles();
    var extension = getExtension(path);
    var supported = getCompatibleExtensions(extension);
    var imports = openFiles.filter(function(path) {
        return supported.indexOf(getExtension(path)) > -1;
    });
    return imports;
};

module.exports.guessFargs = function(line, name) {
    if (!line)
        return "";
    var guess = /\([A-Za-z0-9$_,\s]*(\))?/;
    guess.lastIndex = line.indexOf(name) + name.length;
    var match = guess.exec(line);
    return match && match[0] + (match[1] ? "" : "...") || "";
};

function getExtension(path) {
    return path.match(/[^\.\\\/]*$/)[0];
}
function getCompatibleExtensions(extension) {
    for (var i = 0; i < EXTENSION_GROUPS.length; i++) {
        if (EXTENSION_GROUPS[i].indexOf(extension) > -1)
            return EXTENSION_GROUPS[i];
    }
    return [extension];
}

var getOffsetRow = module.exports.getOffsetRow = function(contents, offset) {
    var result = 0;
    var lastIndex = offset + 1;
    for (;;) {
        lastIndex = lastIndex === 0
            ? -1
            : contents.lastIndexOf("\n", lastIndex - 1);
        if (lastIndex < 0)
            return result;
        result++;
    }
};
module.exports.filterDocumentation = workerUtil.filterDocumentation;

module.exports.getParameterDocs = function(doc) {
    var result = {};
    doc && doc.replace(
        /@param (?:\{[^}]*\} )?([^ ]*)\s+([^@]*)/g,
        function(input, name, description) {
            result["_" + name] = workerUtil.filterDocumentation(description);
            return input;
        }
    );
    return result;
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/complete",[], function(require, exports, module) {

var index = require("./semantic_index");
var fileIndexer = require("./file_indexer");
var completeUtil = require("plugins/c9.ide.language/complete_util");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var ctagsUtil = require("./ctags/ctags_util");
var handler;

var PRIORITY_LOW = 1;
var PRIORITY_HIGH = 2;

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.complete = function(doc, fullAst, pos, options, callback) {
    if (options.node && options.node.cons === "PropertyInit") // HACK for javascript
        return callback();

    var lines = doc.getAllLines();
    var line = lines[pos.row];
    var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, workerUtil.getIdentifierRegex());
    if (line[pos.column - identifier.length - 1] === ".")
        return callback();
    
    getCurrentLazy(handler.path, doc, fullAst, function(err, result, imports) {
        if (err)
            console.log("[jsonalyzer] Warning: could not analyze " + handler.path + ": " + err);
        var currentFile = result;
        var currentResults = getCompletionResults(null, PRIORITY_HIGH, identifier, currentFile, pos, line);
        var otherResults = [];
        imports.forEach(function(path) {
            var summary = index.get(path);
            if (summary)
                otherResults = otherResults.concat(
                    getCompletionResults(path, PRIORITY_LOW, identifier, summary));
        });
        callback(currentResults.concat(otherResults));
        var unresolved = imports.filter(function(i) { return !index.get(i); });
        if (unresolved.length) {
            fileIndexer.analyzeOthers(unresolved, true, function() {
                if (index.getAny(unresolved).length)
                    workerUtil.completeUpdate(pos, line);
            });
        }
    });
};

function getCurrentLazy(path, doc, fullAst, callback) {
    var result = index.get(path);
    if (result)
        return callback(null, result, index.getImports(path));
    fileIndexer.analyzeCurrent(handler.path, doc.getValue(), fullAst, { service: "complete" }, callback);
}

function getCompletionResults(path, priority, identifier, summary, skipPos, skipLine) {
    if (!summary)
        return [];
    var entries = index.findEntries(summary, identifier, true);
    var file = path && path.match(/[^\/]*$/)[0];
    
    var results = [];
    for (var uname in entries) {
        entries[uname].forEach(function(e) {
            var name = uname.substr(1);
            if (skipPos && e.row === skipPos.row && !isDefinedInLine(skipLine, name, skipPos, identifier))
                return;
            if (e.noComplete)
                return;
            results.push(toCompletionResult(file, name, priority, e));
        });
    }
    return results;
}

function isDefinedInLine(line, name, skipPos, skipPrefix) {
    var first = line.indexOf(name);
    var last = line.lastIndexOf(name);
    if (first !== last)
        return true;
    return first !== skipPos.column - skipPrefix.length;
}

function toCompletionResult(file, name, priority, entry) {
    var fullName = entry.guessFargs
        ? name + ctagsUtil.guessFargs(entry.docHead, name)
        : name;
    var braces = fullName !== name ? "(^^)" : "";
    
    return {
        id: name,
        name: fullName,
        replaceText: name + braces,
        icon: "kind" in entry ? entry.kind : "unknown2",
        meta: file,
        doc: entry.doc,
        docHead: entry.docHead,
        priority: priority,
        isGeneric: true,
        guessTooltip: true,
    };
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/outline",[], function(require, exports, module) {

var fileIndexer = require("./file_indexer");
var assert = require("c9/assert");
var ctagsUtil = require("./ctags/ctags_util");
var handler;

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.outline = function(doc, ast, callback) {
    return fileIndexer.analyzeCurrent(handler.path, doc.getValue(), ast, { service: "outline" }, function(err, entry) {
        if (err) {
            console.error(err);
            return callback(); // can't pass error to this callback
        }
        
        var result = createOutline(null, entry, -1);
        var rootInfo = {
            displayPos: { el: doc.getLength() - 1 }
        };
        result = addDisplayPos(result, rootInfo);
        result.isGeneric = true;
        callback(result);
    });
};

function createOutline(name, entry, defaultIndent, parent) {
    var indent = entry.indent || defaultIndent;
    var fullName = entry.guessFargs
        ? name + ctagsUtil.guessFargs(entry.docHead, name)
        : name;
    var result = {
        icon: entry.icon || entry.kind,
        name: fullName,
        pos: { sl: entry.row, sc: entry.column },
        items: [],
        indent: indent,
        parent: parent,
    };
    if (!entry.properties)
        return result;
    assert(!Array.isArray(entry.properties));
    
    for (var uname in entry.properties) {
        entry.properties[uname].forEach(function(prop) {
            result.items.push(createOutline(uname.substr(1), prop, indent + 1, result));
        });
    }
    result.items = sortOutline(result.items);
    var candidateParent;
    result.items = result.items.filter(function(prop) {
        var parent = findParent(prop, candidateParent);
        if (parent !== result)
            parent.items.push(prop);
        else
            candidateParent = prop;
        return parent === result;
    });
    return result;
    
    function findParent(prop, parent) {
        if (!prop.indent || prop.indent <= indent || !parent)
            return result;
        
        if (parent.indent >= prop.indent)
            return findParent(prop, parent.parent);
            
        return parent;
    }
}

function sortOutline(items) {
    return items.sort(function(a, b) {
        return a.pos.sl - b.pos.sl;
    });
}

function addDisplayPos(outline, parent) {
    if (!outline.items)
        return outline;
    outline.displayPos = outline.displayPos || outline.pos;
    for (var i = 0; i < outline.items.length; i++) {
        var item = outline.items[i];
        var next = outline.items[i + 1];
        var nextLine = next ? next.pos.sl : parent.displayPos.el;
        item.displayPos = item.pos;
        item.pos = {
            sl: item.pos.sl,
            sc: item.pos.sc,
            el: nextLine,
            ec: nextLine > item.pos.sl ? 0 : item.pos.ec
        };
        addDisplayPos(item, outline);
    }
    return outline;
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/refactor",[], function(require, exports, module) {

var index = require("./semantic_index");
var fileIndexer = require("./file_indexer");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var handler;
var lastSummary;

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.getRefactorings = function(doc, fullAst, pos, options, callback) {
    findEntries(doc, fullAst, pos, function(pos, identifier, hasEntries) {
        callback({ refactorings: hasEntries ? ["renameVariable"] : []});
    });
};

module.exports.getRenamePositions = function(doc, fullAst, pos, options, callback) {
    findEntries(doc, fullAst, pos, function(pos, identifier, hasEntries) {
        if (!hasEntries)
            return callback();
        workerUtil.getTokens(doc, [identifier, identifier + "()"], function(err, results) {
            if (err)
                callback();
            callback({
                length: identifier.length,
                pos: pos,
                others: results,
                isGeneric: true
            });
        });
    });
};

module.exports.commitRename = function(doc, oldId, newName, isGeneric, callback) {
    if (!isGeneric)
        return callback();
    if (!lastSummary)
        return callback();
    var matchingDef = !!Object.keys(index.findEntries(lastSummary, newName)).length;
    callback(matchingDef && "Name '" + newName + "' is already used.");
};

function findEntries(doc, fullAst, pos, callback) {
    if (handler.language === "javascript") // optimization
        return callback();
    
    var docValue = doc.getValue();
    var line = doc.getLine(pos.row);
    var identifier = workerUtil.getIdentifier(line, pos.column);
    var prefix = workerUtil.getPrecedingIdentifier(line, pos.column);
    var realPos = { row: pos.row, column: pos.column - prefix.length };
    
    fileIndexer.analyzeCurrent(handler.path, docValue, fullAst, { service: "refactor" }, function(err, result) {
        if (err)
            console.log("[jsonalyzer] Warning: could not analyze " + handler.path + ": " + err);
        lastSummary = result;
        callback(realPos, identifier, index.hasEntries(result, identifier));
    });
    
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/highlight_occurrences",[], function(require, exports, module) {

var index = require("./semantic_index");
var handler;
var fileIndexer = require("./file_indexer");
var workerUtil = require("plugins/c9.ide.language/worker_util");

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.highlightOccurrences = function(doc, fullAst, pos, options, callback) {
    var summary = index.get(handler.path);
    if (!summary)
        return callback(); // we're closed, come back later
        
    var line = doc.getLine(pos.row);
    var identifier = workerUtil.getIdentifier(line, pos.column);
    
    var entries = index.findEntries(summary, identifier);
    if (Object.keys(entries).length)
        return callback(getOccurrences(doc, pos, identifier, entries["_" + identifier]));
    
    var imports = index.getImports(handler.path);
    var others = index.getAny(imports);
    for (var i = 0; i < others.length; i++) {
        if (index.hasEntries(others[i], identifier))
            return callback(getOccurrences(doc, pos, identifier, []));
    }
    
    callback();
};

function getOccurrences(doc, pos, identifier, entryList) {
    var line = doc.getLine(pos.row);
    var prefix = workerUtil.getPrecedingIdentifier(line, pos.column);
    var realColumn = pos.column - prefix.length;
    
    var results = [{
        pos: {
            sl: pos.row,
            el: pos.row,
            sc: realColumn,
            ec: realColumn + identifier.length
        },
        type: "occurrence_other"
    }];
    
    var foundSelf = false;
    entryList.forEach(function(entry) {
        if (!entry.column) { // guess the column
            var entryLine = doc.getLine(entry.row);
            entry.column = entryLine.indexOf(identifier);
            if (entry.column < 0)
                return;
        }
        if (entry.row === pos.row && entry.column === realColumn)
            return foundSelf = true;
        results.push({
            pos: {
                sl: entry.row,
                el: entry.row,
                sc: entry.column,
                ec: entry.column + identifier.length
            },
            type: "occurrence_main"
        });
    });
    return { markers: foundSelf ? [] : results, isGeneric: true };
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/directory_indexer",[], function(require, exports, module) {

var indexer = module.exports;
var index = require("./semantic_index");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var handler;

var PARANOID_CHECK_INTERVAL = 60 * 1000;
var QUEUE_DELAY = 2000;
var PARANOID_CHECK_SET = [
    ".git/index",
    ".hg/dirstate",
    ".svn/.wc.db",
    "node_modules/*",
    "package.json"
];

var isJobActive = false;
var lastParanoidResult = "";
var queueTimer;
var queueCallbacks = [];
var queuePaths = [];

indexer.init = function(_handler) {
    handler = _handler;
    
    enqueue("/", false);
    setInterval(function() {
        if (!queuePaths.length)
            enqueue("/", true);
    }, PARANOID_CHECK_INTERVAL);
};

var enqueue = indexer.enqueue = function(path, paranoid, callback) {
    callback && queueCallbacks.push(callback);
    queuePaths.push(path);
    
    if (queuePaths.indexOf("/") > -1)
        return; // we queued the world already
    if (paranoid === undefined && path === "/")
        paranoid = true;
    
    if (paranoid) {
        return isChangedParanoid(function(err, result) {
            if (err)
                return console.error("[jsonalyzer] directory_indexer err: " + err);
            enqueue(result ? path : "$$no-path$$", false);
        });
    }
    
    if (!queueTimer)
        queueTimer = setTimeout(consumeQueue);
};

var consumeQueue = indexer.$consumeQueue = function() {
    queueTimer = null;
    var myQueue = queuePaths;
    var myCallbacks = queueCallbacks;
    queuePaths = [];
    queueCallbacks = [];

    index.removeByPathPrefix(myQueue);
    
    workerUtil.asyncForEach(
        handler.getAllHandlers(),
        function(plugin, next) {
            plugin.analyzeWorkspaceRoot(next);
        },
        done
    );
    
    function done() {
        isJobActive = false;
        var callbacks = myCallbacks;
        myCallbacks = [];
        callbacks.forEach(function(callback) { callback(); });
    }
};
function isChangedParanoid(callback) {
    workerUtil.execFile(
        "bash",
        {
            args: [
                "-c",
                "ls -l"
                + " " + PARANOID_CHECK_SET.join(" ")
                + " `find . -maxdepth 1 -type d | grep -Ev '^\\./\\.c9|^\\.$' || echo ''`"
            ]
        },
        function(err, stdout) {
            if (err)
                return callback(err);
            if (lastParanoidResult === stdout)
                return callback(null, false);
            lastParanoidResult = stdout;
            return callback(null, true);
        }
    );
}

});

define("path",[], function(require, exports, module) {
//
//
//
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}
var splitPathRe =
  /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;
  
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : '/';
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }
  
    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }
  resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  
  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = path.substr(-1) === '/';
  path = normalizeArray(path.split('/').filter(function(p) {
    return !!p;
  }), !isAbsolute).join('/');
  
  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(paths.filter(function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);
  
  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }
  
    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }
  
    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }
  
  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }
  
  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }
  
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  
  return outputParts.join('/');
};

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    return '.';
  }

  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};

exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

exports._makeLong = function(path) {
  return path;
};

});

"disable compress";(function() {
var ctagsInput;
var submitNewContents;
var Module;
var logged = "";

(function() {
var process;
if (typeof window !== "undefined")
    process = "process is changed to type string for compatibility, sorry";

function stringToArrayBuffer(string, callback) {
    var blob = new Blob([string]);
    var f = new FileReader();
    f.onload = function(e) {
        callback(e.target.result);
    }
    f.readAsArrayBuffer(blob);
}
var sysConsole = console;
var console = {
	log: function() {
		arguments = Array.prototype.slice.call(arguments);
		logged += arguments.map(function(a) {
			return typeof a === "object" ? JSON.stringify(a) : a;
		}).join(" ") + "\n";
		sysConsole.log.apply(sysConsole, arguments)
	},
	error: function() {
		arguments = Array.prototype.slice.call(arguments);
		logged += arguments.map(function(a) {
			return typeof a === "object" ? JSON.stringify(a) : a;
		}).join(" ") + "\n";
		sysConsole.err.apply(sysConsole, arguments)
	}
}
var print = console.log;

function aa(b){throw b}var ba=void 0,ca=!0,da=null,fa=!1,a={noInitialRun:ca,noExitRuntime:ca};try{this.Module=a}catch(ha){this.Module=a={}}var ja="object"===typeof process&&"function"===typeof require,la="object"===typeof window,ma="function"===typeof importScripts,na=!la&&!ja&&!ma;if(ja){a.print=(function(b){process.stdout.write(b+"\n")});a.printErr=(function(b){process.stderr.write(b+"\n")});var oa=require("fs"),pa=require("path");a.read=(function(b){var b=pa.normalize(b),d=oa.readFileSync(b).toString();!d&&b!=pa.resolve(b)&&(b=path.join(__dirname,"..","src",b),d=oa.readFileSync(b).toString());return d});a.load=(function(b){qa(read(b))});a.arguments||(a.arguments=process.argv.slice(2))}na&&(a.print=print,"undefined"!=typeof printErr&&(a.printErr=printErr),a.read="undefined"!=typeof read?read:(function(b){snarf(b)}),a.arguments||("undefined"!=typeof scriptArgs?a.arguments=scriptArgs:"undefined"!=typeof arguments&&(a.arguments=arguments)));la&&!ma&&(a.print||(a.print=(function(b){console.log(b)})),a.printErr||(a.printErr=(function(b){console.log(b)})));if(la||ma){a.read=(function(b){var d=new XMLHttpRequest;d.open("GET",b,fa);d.send(da);return d.responseText}),a.arguments||"undefined"!=typeof arguments&&(a.arguments=arguments)}ma&&(a.print||(a.print=(function(){})),a.load=importScripts);!ma&&!la&&!ja&&!na&&aa("Unknown runtime environment. Where are we?");function qa(b){eval.call(da,b)}"undefined"==!a.load&&a.read&&(a.load=(function(b){qa(a.read(b))}));a.print||(a.print=(function(){}));a.printErr||(a.printErr=a.print);a.arguments||(a.arguments=[]);a.print=a.print;a.h=a.printErr;a.preRun||(a.preRun=[]);a.postRun||(a.postRun=[]);function sa(b){if(1==ta){return 1}var d={"%i1":1,"%i8":1,"%i16":2,"%i32":4,"%i64":8,"%float":4,"%double":8}["%"+b];d||("*"==b.charAt(b.length-1)?d=ta:"i"==b[0]&&(b=parseInt(b.substr(1)),ua(0==b%8),d=b/8));return d}var va;function wa(){var b=[],d=0;this.C=(function(c){c&=255;d&&(b.push(c),d--);if(0==b.length){if(128>c){return String.fromCharCode(c)}b.push(c);d=191<c&&224>c?1:2;return""}if(0<d){return""}var c=b[0],e=b[1],f=b[2],c=191<c&&224>c?String.fromCharCode((c&31)<<6|e&63):String.fromCharCode((c&15)<<12|(e&63)<<6|f&63);b.length=0;return c});this.K=(function(b){for(var b=unescape(encodeURIComponent(b)),d=[],f=0;f<b.length;f++){d.push(b.charCodeAt(f))}return d})}function xa(b){var d=j;j+=b;j=j+3>>2<<2;return d}function ya(b){var d=za;za+=b;za=za+3>>2<<2;za>=Aa&&Ba("Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value ( "+Aa+"), (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.");return d}var ta=4,Ca={},Da=1,Ea={},k,Fa,Ga;function Ba(b){a.print(b+":\n"+Error().stack);aa("Assertion: "+b)}function ua(b,d){b||Ba("Assertion failed: "+d)}var Ha=this;a.ccall=(function(b,d,c,e){return Ja(Ka(b),d,c,e)});function Ka(b){try{var d=eval("_"+b)}catch(c){try{d=Ha.Module["_"+b]}catch(e){}}ua(d,"Cannot call unknown function "+b+" (perhaps LLVM optimizations or closure removed it?)");return d}function Ja(b,d,c,e){function f(b,c){if("string"==c){if(b===da||b===ba||0===b){return 0}g||(g=j);var d=xa(b.length+1);La(b,d);return d}return"array"==c?(g||(g=j),d=xa(b.length),Ma(b,d),d):b}var g=0,h=0,e=e?e.map((function(b){return f(b,c[h++])})):[];b=b.apply(da,e);"string"==d?d=Na(b):(ua("array"!=d),d=b);g&&(j=g);return d}a.cwrap=(function(b,d,c){var e=Ka(b);return(function(){return Ja(e,d,c,Array.prototype.slice.call(arguments))})});function Oa(b,d,c){c=c||"i8";"*"===c.charAt(c.length-1)&&(c="i32");switch(c){case"i1":l[b]=d;break;case"i8":l[b]=d;break;case"i16":Pa[b>>1]=d;break;case"i32":t[b>>2]=d;break;case"i64":Ga=[d>>>0,Math.min(Math.floor(d/4294967296),4294967295)];t[b>>2]=Ga[0];t[b+4>>2]=Ga[1];break;case"float":Ra[b>>2]=d;break;case"double":Ta[0]=d;t[b>>2]=Ua[0];t[b+4>>2]=Ua[1];break;default:Ba("invalid type for setValue: "+c)}}a.setValue=Oa;a.getValue=(function(b,d){d=d||"i8";"*"===d.charAt(d.length-1)&&(d="i32");switch(d){case"i1":return l[b];case"i8":return l[b];case"i16":return Pa[b>>1];case"i32":return t[b>>2];case"i64":return t[b>>2];case"float":return Ra[b>>2];case"double":return Ua[0]=t[b>>2],Ua[1]=t[b+4>>2],Ta[0];default:Ba("invalid type for setValue: "+d)}return da});var Va=1,x=2,Wa=3;a.ALLOC_NORMAL=0;a.ALLOC_STACK=Va;a.ALLOC_STATIC=x;a.ALLOC_NONE=Wa;function y(b,d,c,e){var f,g;"number"===typeof b?(f=ca,g=b):(f=fa,g=b.length);var h="string"===typeof d?d:da,c=c==Wa?e:[Xa,xa,ya][c===ba?x:c](Math.max(g,h?1:d.length));if(f){return Ya(c,g),c}for(f=0;f<g;){var i=b[f];"function"===typeof i&&(i=Ca.S(i));e=h||d[f];0===e?f++:("i64"==e&&(e="i32"),Oa(c+f,i,e),f+=sa(e))}return c}a.allocate=y;function Na(b,d){for(var c=new wa,e="undefined"==typeof d,f="",g=0,h;;){h=$a[b+g];if(e&&0==h){break}f+=c.C(h);g+=1;if(!e&&g==d){break}}return f}a.Pointer_stringify=Na;a.Array_stringify=(function(b){for(var d="",c=0;c<b.length;c++){d+=String.fromCharCode(b[c])}return d});var ab,cb=4096,l,$a,Pa,db,t,eb,Ra,fb,j,hb,za,ib=a.TOTAL_STACK||5242880,Aa=a.TOTAL_MEMORY||10485760;ua(!!Int32Array&&!!Float64Array&&!!(new Int32Array(1)).subarray&&!!(new Int32Array(1)).set,"Cannot fallback to non-typed array case: Code is too specialized");var jb=new ArrayBuffer(Aa);l=new Int8Array(jb);Pa=new Int16Array(jb);t=new Int32Array(jb);$a=new Uint8Array(jb);db=new Uint16Array(jb);eb=new Uint32Array(jb);Ra=new Float32Array(jb);fb=new Float64Array(jb);t[0]=255;ua(255===$a[0]&&0===$a[3],"Typed arrays 2 must be run on a little-endian system");a.HEAP=ba;a.HEAP8=l;a.HEAP16=Pa;a.HEAP32=t;a.HEAPU8=$a;a.HEAPU16=db;a.HEAPU32=eb;a.HEAPF32=Ra;a.HEAPF64=fb;hb=(j=4*Math.ceil(.25))+ib;var kb=8*Math.ceil(hb/8);l.subarray(kb);var Ua=t.subarray(kb>>2);Ra.subarray(kb>>2);var Ta=fb.subarray(kb>>3);hb=kb+8;za=hb+4095>>12<<12;ua(za<Aa);var mb=y(lb("(null)"),"i8",x);function nb(b){for(;0<b.length;){var d=b.shift(),c=d.t;"number"===typeof c&&(c=ab[c]);c(d.G===ba?da:d.G)}}var pb=[],qb=[],rb=[];function tb(b){for(var d=b;l[d++];){}return d-b-1}a.String_len=tb;function lb(b,d,c){b=(new wa).K(b);c&&(b.length=c);d||b.push(0);return b}a.intArrayFromString=lb;a.intArrayToString=(function(b){for(var d=[],c=0;c<b.length;c++){var e=b[c];255<e&&(e&=255);d.push(String.fromCharCode(e))}return d.join("")});function La(b,d,c){b=lb(b,c);for(c=0;c<b.length;){l[d+c]=b[c],c+=1}}a.writeStringToMemory=La;function Ma(b,d){for(var c=0;c<b.length;c++){l[d+c]=b[c]}}a.writeArrayToMemory=Ma;function ub(b,d){return 0<=b?b:32>=d?2*Math.abs(1<<d-1)+b:Math.pow(2,d)+b}function vb(b,d){if(0>=b){return b}var c=32>=d?Math.abs(1<<d-1):Math.pow(2,d-1);if(b>=c&&(32>=d||b>c)){b=-2*c+b}return b}var xb=0,zb={},Ab=fa,Bb=da;function Cb(b){xb++;a.monitorRunDependencies&&a.monitorRunDependencies(xb);b?(ua(!zb[b]),zb[b]=1,Bb===da&&"undefined"!==typeof setInterval&&(Bb=setInterval((function(){var b=fa,c;for(c in zb){b||(b=ca,a.h("still waiting on run dependencies:")),a.h("dependency: "+c)}b&&a.h("(end of list)")}),6e3))):a.h("warning: run dependency added without ID")}a.addRunDependency=Cb;function Gb(b){xb--;a.monitorRunDependencies&&a.monitorRunDependencies(xb);b?(ua(zb[b]),delete zb[b]):a.h("warning: run dependency removed without ID");0==xb&&(Bb!==da&&(clearInterval(Bb),Bb=da),Ab||Hb())}a.removeRunDependency=Gb;a.preloadedImages={};a.preloadedAudios={};var Ib,Jb,z,Kb,Lb,Mb,Nb,Ob,Wb,Xb,Yb,Zb,$b,dc,ec,fc,gc,hc,ic,jc,oc,pc,qc,rc,sc,tc,yc,zc,Ac,Bc,Cc,Dc,Ec,Fc,Gc,Hc,Ic,Jc,Kc,Lc,Tc,Uc,Vc,Wc,Xc,Yc,Zc,ld,md,nd,od,pd,qd,rd,sd,td,ud,zd,Ad,Bd,Cd,Dd,Ed,Fd,Gd,Ud,Vd,Wd,Xd,Yd,Zd,$d,ae,be,ce,re,se,te,ue,ve,we,xe,ye,ze,Ae,Be,Ce,De,Ee,Fe,Ge,Ie,Je,Ke,Le,Me,Ne,Oe,Pe,Qe,Re,Se,Te,Ue,Ve,We,Xe,Ye,Ze,$e,af,bf,cf,df,ef,ff,gf,kf,lf,mf,nf,of,pf,qf,rf,sf,tf,uf,vf,wf,xf,yf,zf,Af,Bf,Cf,Df,Ef,Ff,Gf,Hf,If,Jf,Kf,Lf,Mf,Nf,Of,Pf,Qf,Rf,Sf,Tf,Uf,Vf,Wf,Xf,Yf,Zf,$f,ag,bg,cg,dg,eg,fg,gg,hg,ig,jg,kg,lg,mg,ng,og,pg,qg,rg,sg,tg,ug,vg,wg,xg,yg,zg,Bg,Cg,Dg,Eg,Fg,Gg,Hg,Ig,Jg,Kg,Lg,Mg,Ng,Og,Pg,Qg,Rg,Sg,Tg,Ug,Vg,Wg,Xg,Yg,Zg,$g,ah,bh,ch,dh,eh,fh,gh,hh,ih,jh,kh,lh,mh,nh,oh,ph,qh,rh,sh,th,uh,vh,wh,xh,yh,zh,Ah,Bh,Ch,Dh,Eh,Fh,Gh,Hh,Ih,Jh,Kh,Lh,Mh,Nh,Oh,Ph,Qh,Rh,Sh,Th,Uh,Vh,Wh,Xh,Yh,Zh,$h,ai,bi,ci,di,ei,fi,gi,hi,ii,ji,ki,li,mi,ni,oi,pi,qi,ri,si,ti,ui,vi,wi,xi,yi,zi,Ai,Bi,Ci,Di,Ei,Fi,Gi,Hi,Ii,Ji,Ki,Li,Mi,Ni,Oi,Pi,Qi,Ri,Si,Ti,Ui,Vi,Wi,Xi,Yi,Zi,$i,aj,bj,cj,dj,ej,fj,gj,hj,ij,jj,kj,lj,mj,nj,oj,pj,qj,rj,sj,tj,uj,vj,wj,xj,yj,zj,Aj,Bj,Cj,Dj,Ej,Fj,Gj,Hj,Ij,Jj,Kj,Lj,Mj,Nj,Oj,Pj,Qj,Rj,Sj,Tj,Uj,Vj,Wj,Xj,Yj,Zj,$j,ak,bk,ck,dk,ek,fk,gk,hk,ik,jk,kk,lk,mk,nk,ok,pk,qk,rk,sk,tk,uk,vk,wk,xk,yk,zk,Ak,Bk,Ck,Dk,Ek,Fk,Gk,Hk,Ik,Jk,Kk,Lk,Mk,Nk,Ok,Pk,Qk,Rk,Sk,Tk,Uk,Vk,Wk,Xk,Yk,Zk,$k,al,bl,cl,dl,el,fl,gl,hl,il,jl,kl,ll,ml,nl,ol,pl,ql,rl,sl,tl,ul,vl,wl,xl,yl,zl,Al,Bl,Cl,Dl,El,Fl,Gl,Hl,Il,Jl,Kl,Ll,Ml,Nl,Ol,Pl,Ql,Rl,Sl,Tl,Ul,Vl,Wl,Xl,Yl,Zl,$l,am,bm,cm,dm,em,fm,gm,hm,im,jm,km,lm,mm,nm,om,pm,qm,rm,sm,tm,um,vm,wm,xm,ym,zm,Am,Bm,Cm,Dm,Em,Fm,Gm,Hm,Im,Jm,Km,Lm,Mm,Nm,Om,Pm,Qm,Rm,Sm,Tm,Um,Vm,Wm,Xm,Ym,Zm,$m,an,bn,cn,dn,en,fn,gn,hn,jn,kn,ln,mn,nn,on,pn,qn,rn,sn,tn,un,vn,wn,xn,yn,zn,An,Bn,Cn,Dn,En,Fn,Gn,Hn,In,Jn,Kn,Ln,Mn,Nn,On,Pn,Qn,Rn,Sn,Tn,Un,Vn,Wn,Xn,Yn,Zn,$n,ao,bo,co,eo,fo,go,ho,io,jo,ko,lo,mo,no,oo,po,qo,ro,so,to,uo,vo,wo,xo,yo,zo,Ao,Bo,Co,Do,Eo,Fo,Go,Ho,Io,Jo,Ko,Lo,Mo,No,Oo,Po,Qo,Ro,So,To,Uo,Vo,Wo,Xo,Yo,Zo,$o,ap,bp,cp,dp,ep,fp,gp,hp,ip,jp,kp,lp,mp,np,op,pp,qp,rp,sp,tp,up,vp,wp,xp,yp,zp,Ap,Bp,Cp,Dp,Ep,Fp,Gp,Hp,Ip,Jp,Kp,Lp,Mp,Np,Op,Pp,Qp,Rp,Sp,Tp,Up,Vp,Wp,Zp,$p,aq,bq,cq,dq,eq,fq,gq,hq,iq,jq,kq,lq,mq,nq,oq,pq,qq,rq,sq,tq,uq,vq,wq,xq,yq,zq,Aq,Bq,Cq,Dq,Eq,Fq,Gq,Hq,Iq,Jq,Kq,Lq,Mq,Nq,Oq,Pq,Qq,Rq,Sq,Tq,Uq,Vq,Wq,Xq,Yq,Zq,$q,ar,br,cr,dr,er,fr,gr,hr,ir,jr,kr,lr,mr,nr,or,pr,qr,rr,sr,tr,ur,vr,wr,xr,yr,zr,Ar,Br,Cr,Dr,Er,Fr,Gr,Hr,Ir,Jr,Kr,Lr,Mr,Nr,Or,Pr,Qr,Rr,Sr,Tr,Ur,Vr,Wr,Xr,Yr,Zr,$r,as,bs,cs,ds,es,fs,gs,hs,is,js,ks,ls,ms,ns,os,ps,qs,rs,ss,ts,us,vs,ws,xs,ys,zs,As,Bs,Cs,Ds,Es,Fs,Gs,Hs,Is,Js,Ks,Ls,Ms,Ns,Os,Ps,Qs,Rs,Ss,Ts,Us,Vs,Ws,Xs,Ys,Zs,$s,at,bt,ct,dt,et,ft,gt,ht,it,jt,kt,lt,mt,nt,ot,pt,qt,rt,st,tt,ut,vt,wt,xt,yt,zt,At,Bt,Ct,Dt,Et,Ft,Gt,Ht,It,Jt,Kt,Lt,Mt,Nt,Ot,Pt,Qt,Rt,St,Tt,Ut,Vt,Wt,Xt,Yt,Zt,$t,au,bu,cu,du,eu,fu,gu,hu,iu,ju,ku,lu,mu,nu,ou,pu,qu,ru,su,tu,uu,vu,wu,xu,yu,zu,Au,Bu,Cu,Du,Eu,Fu,Gu,Hu,Iu,Ju,Ku,Lu,Mu,Nu,Ou,Pu,Qu,Ru,Su,Tu,Uu,Vu,Wu,Xu,Yu,Zu,$u,av,bv,cv,dv,ev,fv,gv,hv,iv,jv,kv,lv,mv,nv,ov,pv,qv,rv,sv,tv,uv,vv,wv,xv,yv,zv,Av,Bv,Cv,Dv,Ev,Fv,Gv,Hv,Iv,Jv,Kv,Lv,Mv,Nv,Ov,Pv,Qv,Rv,Sv,Tv,Uv,Vv,Wv,Xv,Yv,Zv,$v,aw,bw,cw,dw,ew,fw,gw,hw,iw,jw,kw,lw,mw,nw,ow,pw,qw,rw,sw,tw,uw,vw,ww,xw,yw,zw,Aw,Bw,Cw,Dw,Ew,Fw,Gw,Hw,Iw,Jw,Kw,Lw,Mw,Nw,Ow,Pw,Qw,Rw,Sw,Tw,Uw,Vw,Ww,Xw,Yw,Zw,$w,ax,bx,cx,dx,ex,fx,gx,hx,ix,jx,kx,lx,mx,nx,ox,px,qx,rx,sx,tx,ux,vx,wx,xx,D,yx,zx,Ax,Bx,Cx,E,Dx,Ex,Fx,Gx,Hx,Ix,Jx,Kx,Lx,Mx,Nx,Ox,Px,Qx,F,Rx,Sx,Tx,Ux,Vx,Wx,Xx,Yx,Zx,$x,ay,by,cy,dy,ey,fy,gy,hy,iy,jy,ky,ly,my,ny,oy,py,qy,ry,sy,ty,uy,vy,wy,xy,yy,zy,Ay,By,Cy,Dy,Ey,Fy,Gy,Hy,Iy,Jy,Ky,Ly,My,Ny,Oy,Py,Qy,Ry,Sy,Ty,Uy,H,Vy,Wy,Xy,Yy,Zy,$y,az,bz,cz,dz,ez,fz,gz,hz,iz,J,jz,kz,lz,K,mz,nz,oz,pz,qz,rz,sz,tz,uz,vz,wz,xz,yz,zz,Az,Bz,Cz,Dz,Ez,Fz,Gz,Hz,Iz,Jz,Kz,Lz,Mz,Nz,Oz,Pz,Qz,Rz,Sz,Tz,Uz,Vz,Wz,Xz,Yz,Zz,$z,aA,bA,cA,dA,eA,fA,gA,hA,iA,jA,kA,lA;Ib=y(4,"i8",x);Jb=y(4,"i8",x);z=y(4,"i8",x);Kb=y(4,"i8",x);Lb=y(80,"i8",x);Mb=y(4,"i8",x);Nb=y(4,"i8",x);Xb=y(4,"i8",x);Yb=y(4096,"i8",x);Zb=y(4,"i8",x);$b=y([-1],["i32",0,0,0],x);dc=y([0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0],x);ec=y(4,"i8",x);fc=y(4,"i8",x);gc=y(4,"i8",x);hc=y(116,"i8",x);ic=y(4,"i8",x);jc=y(4,"i8",x);oc=y(4,"i8",x);pc=y(4,"i8",x);qc=y(4,"i8",x);rc=y(4,"i8",x);sc=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);tc=y(4,"i8",x);yc=y(4,"i8",x);zc=y(24,"i8",x);Ac=y(4,"i8",x);Bc=y(4,"i8",x);Cc=y(8,"i8",x);Dc=y(4,"i8",x);Ec=y(4,"i8",x);Fc=y(44,"i8",x);Gc=y(1024,"i8",x);Hc=y(4,"i8",x);Ic=y(16,"i8",x);Jc=y(4,"i8",x);Kc=y(4,"i8",x);Lc=y([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"i8",x);Tc=y([122],["void (%struct.sVString*, i32)*",0,0,0],x);Uc=y(4,"i8",x);Vc=y([1],["i32",0,0,0],x);Wc=y(4,"i8",x);Xc=y([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,1,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0],x);Yc=y(4,"i8",x);Zc=y(4,"i8",x);ld=y(32,"i8",x);md=y(4,"i8",x);nd=y(4,"i8",x);od=y(4,"i8",x);pd=y(4,"i8",x);qd=y(4,"i8",x);rd=y(4,"i8",x);sd=y([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0],x);td=y(24,"i8",x);ud=y([115,113,108,0],"i8",x);zd=y([109,97,105,110,0],"i8",x);Ad=y([115,101,116,0],"i8",x);Bd=y([99,111,110,115,116,97,110,116,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Cd=y([109,108,116,97,98,108,101,0],"i8",x);Dd=y([115,121,110,99,104,114,111,110,105,122,101,100,0],"i8",x);Ed=y([100,101,114,105,118,101,100,32,116,121,112,101,115,32,97,110,100,32,115,116,114,117,99,116,117,114,101,115,0],"i8",x);Fd=y([99,100,101,102,32,0],"i8",x);Gd=y([115,121,110,111,110,121,109,115,0],"i8",x);Ud=y([105,44,105,110,116,101,114,102,97,99,101,44,105,110,116,101,114,102,97,99,101,115,0],"i8",x);Vd=y([120,111,114,0],"i8",x);Wd=y([118,105,101,119,115,0],"i8",x);Xd=y([115,109,108,0],"i8",x);Yd=y([112,114,111,103,114,97,109,115,0],"i8",x);Zd=y([64,101,110,99,111,100,101,0],"i8",x);$d=y([115,108,0],"i8",x);ae=y([120,110,111,114,0],"i8",x);be=y([100,111,109,97,105,110,115,0],"i8",x);ce=y([101,120,112,111,114,116,0],"i8",x);re=y([115,116,114,105,110,103,0],"i8",x);se=y([110,97,109,101,108,105,115,116,115,0],"i8",x);te=y([116,104,105,115,0],"i8",x);ue=y([102,44,102,117,110,99,116,105,111,110,44,74,97,118,97,83,99,114,105,112,116,32,102,117,110,99,116,105,111,110,115,0],"i8",x);ve=y([119,105,116,104,0],"i8",x);we=y([115,101,114,118,105,99,101,115,0],"i8",x);xe=y([115,104,0],"i8",x);ye=y([119,104,105,108,101,0],"i8",x);ze=y([112,117,98,108,105,99,97,116,105,111,110,115,0],"i8",x);Ae=y([115,116,97,116,101,0],"i8",x);Be=y([83,67,77,0],"i8",x);Ce=y([97,117,116,111,109,97,116,105,99,0],"i8",x);De=y([108,111,99,97,108,44,32,99,111,109,109,111,110,32,98,108,111,99,107,44,32,97,110,100,32,110,97,109,101,108,105,115,116,32,118,97,114,105,97,98,108,101,115,0],"i8",x);Ee=y([115,105,103,110,101,100,0],"i8",x);Fe=y([119,104,101,110,0],"i8",x);Ge=y([98,101,116,0],"i8",x);Ie=y([109,97,99,114,111,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);Je=y([119,97,105,116,0],"i8",x);Ke=y([105,110,100,101,120,101,115,0],"i8",x);Le=y([115,101,108,101,99,116,111,114,0],"i8",x);Me=y([115,104,111,114,116,0],"i8",x);Ne=y([102,105,108,101,0],"i8",x);Oe=y([94,91,32,9,93,42,91,70,83,82,93,68,91,32,9,93,43,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,92,46,0],"i8",x);Pe=y([68,72,79,66,0],"i8",x);Qe=y([112,97,114,115,101,114,32,100,101,102,105,110,105,116,105,111,110,32,109,117,115,116,32,99,111,110,116,97,105,110,32,110,97,109,101,10,0],"i8",x);Re=y([101,110,100,102,111,0],"i8",x);Se=y([97,114,99,104,105,116,101,99,116,117,114,101,0],"i8",x);Te=y([111,117,116,112,117,116,0],"i8",x);Ue=y([105,110,99,108,117,100,101,0],"i8",x);Ve=y([112,114,111,116,101,99,116,101,100,0],"i8",x);We=y([118,97,114,105,97,98,108,101,115,0],"i8",x);Xe=y([97,108,108,32,112,97,116,116,101,114,110,115,0],"i8",x);Ye=y([115,104,97,100,111,119,0],"i8",x);Ze=y([117,115,101,0],"i8",x);$e=y([116,114,105,103,103,101,114,115,0],"i8",x);af=y([97,108,105,103,110,0],"i8",x);bf=y([99,111,110,102,105,103,117,114,101,0],"i8",x);cf=y([116,121,112,101,32,97,110,100,32,115,116,114,117,99,116,117,114,101,32,99,111,109,112,111,110,101,110,116,115,0],"i8",x);df=y([117,110,116,105,108,0],"i8",x);ef=y([116,97,98,108,101,115,0],"i8",x);ff=y([117,110,108,101,115,115,0],"i8",x);gf=y([99,108,97,115,115,32,0],"i8",x);kf=y([118,97,114,105,97,98,108,101,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);lf=y([117,110,105,116,115,0],"i8",x);mf=y([115,117,98,116,121,112,101,115,0],"i8",x);nf=y([115,117,98,0],"i8",x);of=y([117,110,99,116,105,111,110,0],"i8",x);pf=y([105,110,116,101,114,102,97,99,101,32,99,111,110,116,101,110,116,115,44,32,103,101,110,101,114,105,99,32,110,97,109,101,115,44,32,97,110,100,32,111,112,101,114,97,116,111,114,115,0],"i8",x);qf=y([118,97,114,105,97,98,108,101,0],"i8",x);rf=y([117,110,97,102,102,101,99,116,101,100,0],"i8",x);sf=y([114,101,99,111,114,100,115,0],"i8",x);tf=y([99,109,100,0],"i8",x);uf=y([64,112,114,111,116,111,99,111,108,0],"i8",x);vf=y([109,97,112,115,0],"i8",x);wf=y([116,121,112,101,0],"i8",x);xf=y([101,110,116,114,121,32,112,111,105,110,116,115,0],"i8",x);yf=y([102,117,110,99,116,105,111,110,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);zf=y([116,114,97,110,115,112,111,114,116,0],"i8",x);Af=y([112,97,99,107,97,103,101,115,0],"i8",x);Bf=y([99,111,109,109,111,110,32,98,108,111,99,107,115,0],"i8",x);Cf=y([102,117,110,99,116,105,111,110,0],"i8",x);Df=y([116,111,0],"i8",x);Ef=y([98,108,111,99,107,32,108,97,98,101,108,0],"i8",x);Ff=y([97,115,115,105,103,110,109,101,110,116,0],"i8",x);Gf=y([98,108,111,99,107,32,100,97,116,97,0],"i8",x);Hf=y([117,115,101,114,45,100,101,102,105,110,101,100,32,99,111,109,109,97,110,100,115,0],"i8",x);If=y([116,104,101,110,0],"i8",x);Jf=y([112,97,99,107,101,100,0],"i8",x);Kf=y([42,67,99,33,35,36,68,100,0],"i8",x);Lf=y([99,111,109,109,97,110,100,0],"i8",x);Mf=y([115,117,98,116,121,112,101,0],"i8",x);Nf=y([108,111,99,97,108,32,118,97,114,105,97,98,108,101,115,0],"i8",x);Of=y([112,114,97,103,109,97,0],"i8",x);Pf=y([112,121,0],"i8",x);Qf=y([37,115,58,32,117,110,116,101,114,109,105,110,97,116,101,100,32,99,104,97,114,97,99,116,101,114,32,115,116,114,105,110,103,32,97,116,32,108,105,110,101,32,37,108,117,10,0],"i8",x);Rf=y([73,110,115,116,97,108,108,105,110,103,32,112,97,114,115,101,114,115,58,32,0],"i8",x);Sf=y([101,110,100,0],"i8",x);Tf=y([97,110,100,0],"i8",x);Uf=y([109,111,100,117,108,101,0],"i8",x);Vf=y([100,101,102,97,117,108,116,0],"i8",x);Wf=y([115,117,98,112,97,114,97,103,114,97,112,104,0],"i8",x);Xf=y([97,117,116,111,99,111,109,109,97,110,100,32,103,114,111,117,112,115,0],"i8",x);Yf=y([112,117,98,108,105,99,0],"i8",x);Zf=y([115,114,108,0],"i8",x);$f=y([114,101,99,111,114,100,32,102,105,101,108,100,115,0],"i8",x);ag=y([112,97,116,116,101,114,110,0],"i8",x);bg=y([42,47,43,61,60,62,0],"i8",x);cg=y([97,117,103,114,111,117,112,0],"i8",x);dg=y([115,114,97,0],"i8",x);eg=y([102,105,101,108,100,0],"i8",x);fg=y([111,118,101,114,108,111,97,100,0],"i8",x);gg=y([65,115,109,0],"i8",x);hg=y([97,98,115,116,121,112,101,0],"i8",x);ig=y([110,44,110,97,109,101,115,112,97,99,101,44,110,97,109,101,115,112,97,99,101,115,0],"i8",x);jg=y([112,104,112,0],"i8",x);kg=y([99,110,111,114,101,109,97,112,0],"i8",x);lg=y([115,108,105,0],"i8",x);mg=y([61,0],"i8",x);ng=y([100,101,102,32,0],"i8",x);og=y([99,110,111,114,101,109,97,0],"i8",x);pg=y([115,108,97,0],"i8",x);qg=y([94,91,32,9,93,42,105,110,116,101,114,102,97,99,101,91,32,9,93,43,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,0],"i8",x);rg=y([95,95,69,78,68,95,95,0],"i8",x);sg=y([114,111,99,101,100,117,114,101,0],"i8",x);tg=y([97,110,111,110,121,109,111,117,115,0],"i8",x);ug=y([99,110,111,114,101,109,0],"i8",x);vg=y([115,104,97,114,101,100,0],"i8",x);wg=y([110,101,119,99,111,118,0],"i8",x);xg=y([100,105,109,0],"i8",x);yg=y([100,111,110,101,0],"i8",x);zg=y([64,105,110,116,101,114,102,97,99,101,0],"i8",x);Bg=y([45,0],"i8",x);Cg=y([99,110,111,114,101,0],"i8",x);Dg=y([115,105,103,110,97,108,0],"i8",x);Eg=y([99,117,114,115,111,114,115,0],"i8",x);Fg=y([101,110,100,101,102,0],"i8",x);Gg=y([112,108,0],"i8",x);Hg=y([37,115,58,32,110,111,116,32,102,105,120,101,100,32,115,111,117,114,99,101,32,102,111,114,109,59,32,114,101,116,114,121,32,97,115,32,102,114,101,101,32,115,111,117,114,99,101,32,102,111,114,109,10,0],"i8",x);Ig=y([94,91,32,9,93,42,102,117,110,99,116,105,111,110,91,32,9,93,42,40,91,65,45,90,97,45,122,48,45,57,95,93,43,41,91,32,9,93,42,92,40,0],"i8",x);Jg=y([99,110,111,114,0],"i8",x);Kg=y([115,101,118,101,114,105,116,121,0],"i8",x);Lg=y([110,97,116,105,118,101,0],"i8",x);Mg=y([102,117,110,99,0],"i8",x);Ng=y([112,0],"i8",x);Og=y([99,110,111,0],"i8",x);Pg=y([115,101,108,101,99,116,0],"i8",x);Qg=y([103,111,0],"i8",x);Rg=y([97,108,108,111,99,97,116,97,98,108,101,0],"i8",x);Sg=y([119,104,101,114,101,0],"i8",x);Tg=y([108,110,111,114,101,109,97,112,0],"i8",x);Ug=y([114,111,114,0],"i8",x);Vg=y([99,114,101,97,116,101,0],"i8",x);Wg=y([118,111,108,97,116,105,108,101,0],"i8",x);Xg=y([97,116,116,97,99,104,101,100,0],"i8",x);Yg=y([108,110,111,114,101,109,97,0],"i8",x);Zg=y([114,111,108,0],"i8",x);$g=y([99,111,109,109,101,110,116,0],"i8",x);ah=y([109,95,116,114,97,110,115,0],"i8",x);bh=y([100,44,100,97,116,97,44,100,97,116,97,32,105,116,101,109,115,0],"i8",x);ch=y([101,110,100,105,102,0],"i8",x);dh=y([47,0],"i8",x);eh=y([42,46,91,120,88,93,91,54,56,93,91,54,56,93,0],"i8",x);fh=y([108,101,116,0],"i8",x);gh=y([105,110,116,101,103,101,114,0],"i8",x);hh=y([63,0],"i8",x);ih=y([112,97,114,97,103,114,97,112,104,0],"i8",x);jh=y([108,110,111,114,101,109,0],"i8",x);kh=y([105,116,99,108,58,58,99,108,97,115,115,0],"i8",x);lh=y([114,101,116,117,114,110,0],"i8",x);mh=y([104,97,110,100,108,101,114,0],"i8",x);nh=y([100,101,99,108,97,114,101,0],"i8",x);oh=y([102,114,97,103,109,101,110,116,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);ph=y([109,95,115,116,97,116,101,0],"i8",x);qh=y([108,110,111,114,101,0],"i8",x);rh=y([114,101,106,101,99,116,0],"i8",x);sh=y([115,121,110,111,110,121,109,0],"i8",x);th=y([109,95,98,97,100,95,116,114,97,110,115,0],"i8",x);uh=y([97,115,109,0],"i8",x);vh=y([102,114,97,103,109,101,110,116,0],"i8",x);wh=y([33,37,38,36,35,43,45,60,62,61,47,63,64,92,126,39,94,124,42,95,0],"i8",x);xh=y([94,91,32,9,93,42,105,109,112,108,101,109,101,110,116,115,91,32,9,93,43,92,40,91,32,9,93,42,34,40,91,94,34,93,42,41,34,91,32,9,93,42,92,41,91,32,9,93,42,59,0],"i8",x);yh=y([83,104,0],"i8",x);zh=y([83,99,104,101,109,101,0],"i8",x);Ah=y([108,110,111,114,0],"i8",x);Bh=y([114,101,103,105,115,116,101,114,0],"i8",x);Ch=y([118,105,101,119,0],"i8",x);Dh=y([109,95,98,97,100,95,115,116,97,116,101,0],"i8",x);Eh=y([115,44,115,117,98,114,111,117,116,105,110,101,44,115,117,98,114,111,117,116,105,110,101,115,0],"i8",x);Fh=y([117,110,105,111,110,0],"i8",x);Gh=y([108,110,111,0],"i8",x);Hh=y([114,101,99,111,114,100,0],"i8",x);Ih=y([100,114,111,112,0],"i8",x);Jh=y([99,44,99,108,97,115,115,44,99,108,97,115,115,101,115,0],"i8",x);Kh=y([108,111,110,103,0],"i8",x);Lh=y([95,95,68,65,84,65,95,95,0],"i8",x);Mh=y([101,115,116,114,117,99,116,111,114,0],"i8",x);Nh=y([108,111,99,97,108,32,101,110,116,105,116,105,101,115,0],"i8",x);Oh=y([105,110,111,114,101,109,97,112,0],"i8",x);Ph=y([114,97,110,103,101,0],"i8",x);Qh=y([116,101,109,112,111,114,97,114,121,0],"i8",x);Rh=y([100,105,109,32,97,115,0],"i8",x);Sh=y([109,108,0],"i8",x);Th=y([102,101,97,116,117,114,101,115,0],"i8",x);Uh=y([64,105,109,112,108,101,109,101,110,116,97,116,105,111,110,0],"i8",x);Vh=y([105,110,111,114,101,109,97,0],"i8",x);Wh=y([112,117,114,101,0],"i8",x);Xh=y([76,105,115,112,0],"i8",x);Yh=y([116,97,114,103,101,116,0],"i8",x);Zh=y([105,110,111,114,101,109,0],"i8",x);$h=y([112,114,111,99,101,115,115,0],"i8",x);ai=y([109,108,95,97,100,100,95,112,114,111,112,101,114,116,121,0],"i8",x);bi=y([105,110,111,114,101,0],"i8",x);ci=y([112,114,111,99,101,100,117,114,101,0],"i8",x);di=y([109,108,95,97,100,100,95,108,97,110,103,95,99,111,110,110,95,115,99,114,105,112,116,95,99,104,107,0],"i8",x);ei=y([70,111,114,116,114,97,110,0],"i8",x);fi=y([66,73,84,0],"i8",x);gi=y([105,110,111,114,0],"i8",x);hi=y([112,111,115,116,112,111,110,101,100,0],"i8",x);ii=y([109,108,95,97,100,100,95,106,97,118,97,95,99,111,110,110,101,99,116,105,111,110,95,115,99,114,105,112,116,0],"i8",x);ji=y([105,110,116,0],"i8",x);ki=y([115,116,100,99,97,108,108,0],"i8",x);li=y([97,115,115,105,103,110,0],"i8",x);mi=y([105,110,111,0],"i8",x);ni=y([115,101,116,91,32,9,93,43,40,91,65,45,90,97,45,122,95,48,45,57,93,43,41,91,32,9,93,42,61,0],"i8",x);oi=y([112,111,114,116,0],"i8",x);pi=y([109,108,95,97,100,100,95,100,110,101,116,95,99,111,110,110,101,99,116,105,111,110,95,115,99,114,105,112,116,0],"i8",x);qi=y([102,111,110,116,45,102,97,99,101,0],"i8",x);ri=y([98,97,115,0],"i8",x);si=y([70,97,105,108,117,114,101,32,111,110,32,97,116,116,101,109,112,116,32,116,111,32,114,101,97,100,32,102,105,108,101,0],"i8",x);ti=y([101,108,115,101,0],"i8",x);ui=y([65,110,32,101,120,99,101,112,116,105,111,110,0],"i8",x);vi=y([32,32,32,32,37,115,58,32,0],"i8",x);wi=y([115,116,97,116,105,99,0],"i8",x);xi=y([109,0],"i8",x);yi=y([97,117,103,0],"i8",x);zi=y([42,46,91,54,56,93,91,54,56,93,91,107,75,115,83,120,88,93,0],"i8",x);Ai=y([97,108,105,97,115,0],"i8",x);Bi=y([105,110,112,117,116,0],"i8",x);Ci=y([112,97,114,116,0],"i8",x);Di=y([111,110,111,114,101,109,97,112,0],"i8",x);Ei=y([99,120,120,0],"i8",x);Fi=y([99,108,97,115,115,0],"i8",x);Gi=y([112,97,99,107,97,103,101,0],"i8",x);Hi=y([109,108,95,97,100,100,95,108,97,110,103,95,99,111,110,110,101,99,116,105,111,110,95,115,99,114,105,112,116,0],"i8",x);Ii=y([99,117,114,115,111,114,0],"i8",x);Ji=y([69,120,99,101,112,116,105,111,110,0],"i8",x);Ki=y([115,101,113,117,101,110,99,101,0],"i8",x);Li=y([118,97,114,105,97,110,116,0],"i8",x);Mi=y([111,110,111,114,101,109,97,0],"i8",x);Ni=y([111,117,116,0],"i8",x);Oi=y([109,108,95,97,100,100,95,99,111,110,110,101,99,116,105,111,110,95,115,99,114,105,112,116,0],"i8",x);Pi=y([116,44,116,97,114,103,101,116,44,116,97,114,103,101,116,115,0],"i8",x);Qi=y([99,111,110,116,101,120,116,115,0],"i8",x);Ri=y([83,76,79,84,0],"i8",x);Si=y([65,32,39,115,116,114,117,99,116,117,114,101,39,32,102,105,101,108,100,0],"i8",x);Ti=y([105,0],"i8",x);Ui=y([122,115,104,0],"i8",x);Vi=y([115,109,0],"i8",x);Wi=y([91,77,109,93,97,107,101,102,105,108,101,0],"i8",x);Xi=y([46,0],"i8",x);Yi=y([111,110,111,114,101,109,0],"i8",x);Zi=y([111,116,104,101,114,115,0],"i8",x);$i=y([109,108,95,97,100,100,95,108,97,110,103,95,116,97,98,108,101,95,115,99,114,105,112,116,95,99,104,107,0],"i8",x);aj=y([100,101,115,99,114,105,98,101,115,0],"i8",x);bj=y([108,117,97,0],"i8",x);cj=y([82,101,99,111,114,100,32,102,105,101,108,100,0],"i8",x);dj=y([115,97,118,101,0],"i8",x);ej=y([80,121,116,104,111,110,0],"i8",x);fj=y([111,110,111,114,101,0],"i8",x);gj=y([111,114,0],"i8",x);hj=y([109,108,95,97,100,100,95,106,97,118,97,95,116,97,98,108,101,95,115,99,114,105,112,116,0],"i8",x);ij=y([99,108,0],"i8",x);jj=y([105,109,112,108,101,109,101,110,116,115,0],"i8",x);kj=y([92,51,0],"i8",x);lj=y([115,105,110,103,108,101,116,111,110,32,109,101,116,104,111,100,115,0],"i8",x);mj=y([65,32,99,111,110,115,116,114,117,99,116,111,114,0],"i8",x);nj=y([61,99,117,116,0],"i8",x);oj=y([111,110,115,116,114,117,99,116,111,114,0],"i8",x);pj=y([114,101,99,117,114,115,105,118,101,0],"i8",x);qj=y([117,110,100,101,102,105,110,101,0],"i8",x);rj=y([111,110,111,114,0],"i8",x);sj=y([111,112,101,110,0],"i8",x);tj=y([109,108,95,97,100,100,95,100,110,101,116,95,116,97,98,108,101,95,115,99,114,105,112,116,0],"i8",x);uj=y([115,105,110,103,108,101,116,111,110,32,109,101,116,104,111,100,0],"i8",x);vj=y([67,111,110,115,116,114,117,99,116,111,114,0],"i8",x);wj=y([101,110,117,109,0],"i8",x);xj=y([103,111,116,111,0],"i8",x);yj=y([111,110,111,0],"i8",x);zj=y([109,108,95,97,100,100,95,108,97,110,103,95,116,97,98,108,101,95,115,99,114,105,112,116,0],"i8",x);Aj=y([97,119,107,0],"i8",x);Bj=y([108,115,112,0],"i8",x);Cj=y([65,32,102,117,110,99,116,105,111,110,0],"i8",x);Dj=y([79,98,106,101,99,116,0],"i8",x);Ej=y([97,44,97,110,99,104,111,114,44,110,97,109,101,100,32,97,110,99,104,111,114,115,0],"i8",x);Fj=y([118,110,111,114,101,109,97,112,0],"i8",x);Gj=y([111,102,0],"i8",x);Hj=y([109,108,95,97,100,100,95,116,97,98,108,101,95,115,99,114,105,112,116,0],"i8",x);Ij=y([84,121,112,101,32,110,97,109,101,0],"i8",x);Jj=y([115,116,114,105,112,0],"i8",x);Kj=y([118,110,111,114,101,109,97,0],"i8",x);Lj=y([110,117,108,108,0],"i8",x);Mj=y([102,111,114,101,105,103,110,0],"i8",x);Nj=y([102,114,105,101,110,100,0],"i8",x);Oj=y([102,57,53,0],"i8",x);Pj=y([71,108,111,98,97,108,32,118,97,114,105,97,98,108,101,0],"i8",x);Qj=y([115,101,112,97,114,97,116,101,0],"i8",x);Rj=y([118,110,111,114,101,109,0],"i8",x);Sj=y([110,111,116,0],"i8",x);Tj=y([99,111,110,115,116,114,97,105,110,116,0],"i8",x);Uj=y([108,111,97,100,0],"i8",x);Vj=y([102,111,114,101,97,99,104,0],"i8",x);Wj=y([118,97,114,0],"i8",x);Xj=y([112,114,111,103,114,97,109,0],"i8",x);Yj=y([106,115,0],"i8",x);Zj=y([118,110,111,114,101,0],"i8",x);$j=y([99,104,101,99,107,0],"i8",x);ak=y([112,97,103,101,0],"i8",x);bk=y([96,0],"i8",x);ck=y([78,85,76,76,32,102,105,108,101,32,112,111,105,110,116,101,114,0],"i8",x);dk=y([101,108,105,102,0],"i8",x);ek=y([94,91,32,9,93,42,91,48,45,57,93,43,91,32,9,93,43,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,91,32,9,93,43,40,66,76,65,78,75,124,79,67,67,85,82,83,124,73,83,124,74,85,83,84,124,80,73,67,124,82,69,68,69,70,73,78,69,83,124,82,69,78,65,77,69,83,124,83,73,71,78,124,83,89,78,67,124,85,83,65,71,69,124,86,65,76,85,69,41,0],"i8",x);fk=y([77,111,100,117,108,101,32,111,114,32,102,117,110,99,116,111,114,0],"i8",x);gk=y([111,117,116,32,111,102,32,109,101,109,111,114,121,0],"i8",x);hk=y([102,117,0],"i8",x);ik=y([104,116,109,0],"i8",x);jk=y([114,101,116,114,121,0],"i8",x);kk=y([97,102,116,101,114,0],"i8",x);lk=y([42,46,50,57,91,107,75,93,0],"i8",x);mk=y([115,117,98,115,117,98,115,101,99,116,105,111,110,0],"i8",x);nk=y([118,110,111,114,0],"i8",x);ok=y([112,114,111,99,0],"i8",x);pk=y([110,101,120,116,0],"i8",x);qk=y([99,112,112,0],"i8",x);rk=y([117,110,105,113,117,101,0],"i8",x);sk=y([102,108,111,97,116,0],"i8",x);tk=y([33,126,0],"i8",x);uk=y([79,98,106,101,99,116,39,115,32,109,101,116,104,111,100,0],"i8",x);vk=y([112,114,101,99,105,115,105,111,110,0],"i8",x);wk=y([100,101,102,0],"i8",x);xk=y([118,110,111,0],"i8",x);yk=y([110,101,119,0],"i8",x);zk=y([114,101,102,101,114,101,110,99,101,115,0],"i8",x);Ak=y([102,105,110,97,108,0],"i8",x);Bk=y([94,91,32,9,93,42,60,91,32,9,93,42,116,97,114,103,101,116,91,94,62,93,43,110,97,109,101,61,34,40,91,94,34,93,43,41,34,46,42,0],"i8",x);Ck=y([61,126,0],"i8",x);Dk=y([40,42,0],"i8",x);Ek=y([102,44,102,117,110,99,116,105,111,110,44,102,117,110,99,116,105,111,110,115,0],"i8",x);Fk=y([107,115,104,0],"i8",x);Gk=y([115,99,109,0],"i8",x);Hk=y([112,111,105,110,116,101,114,0],"i8",x);Ik=y([114,101,115,99,117,101,0],"i8",x);Jk=y([105,110,99,0],"i8",x);Kk=y([110,110,111,114,101,109,97,112,0],"i8",x);Lk=y([110,97,110,100,0],"i8",x);Mk=y([112,114,105,109,97,114,121,0],"i8",x);Nk=y([33,61,0],"i8",x);Ok=y([61,101,110,100,0],"i8",x);Pk=y([94,40,91,65,45,90,97,45,122,48,45,57,64,35,36,92,46,33,63,95,93,43,41,91,32,9,93,42,58,0],"i8",x);Qk=y([79,67,97,109,108,32,77,97,120,105,109,117,109,32,100,101,112,116,104,32,114,101,97,99,104,101,100,0],"i8",x);Rk=y([65,32,112,114,101,112,114,111,99,101,115,115,111,114,32,109,97,99,114,111,0],"i8",x);Sk=y([112,103,108,111,98,97,108,0],"i8",x);Tk=y([114,101,113,117,105,114,101,0],"i8",x);Uk=y([115,99,111,110,115,0],"i8",x);Vk=y([104,43,43,0],"i8",x);Wk=y([110,110,111,114,101,109,97,0],"i8",x);Xk=y([109,111,100,0],"i8",x);Yk=y([101,120,116,101,110,100,115,0],"i8",x);Zk=y([94,91,32,9,93,42,40,40,102,105,110,97,108,124,97,98,115,116,114,97,99,116,41,91,32,9,93,43,41,42,99,108,97,115,115,91,32,9,93,43,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,0],"i8",x);$k=y([61,61,61,0],"i8",x);al=y([98,101,103,105,110,47,101,110,100,0],"i8",x);bl=y([80,101,114,108,0],"i8",x);cl=y([102,111,114,119,97,114,100,0],"i8",x);dl=y([112,101,120,116,101,114,110,97,108,0],"i8",x);el=y([114,101,110,97,109,101,0],"i8",x);fl=y([104,120,120,0],"i8",x);gl=y([110,110,111,114,101,109,0],"i8",x);hl=y([97,116,0],"i8",x);il=y([101,120,112,108,105,99,105,116,0],"i8",x);jl=y([61,61,0],"i8",x);kl=y([105,109,112,111,114,116,115,0],"i8",x);ll=y([77,111,100,117,108,101,0],"i8",x);ml=y([65,110,32,101,110,117,109,101,114,97,116,105,111,110,0],"i8",x);nl=y([66,97,115,105,99,0],"i8",x);ol=y([112,97,115,99,97,108,0],"i8",x);pl=y([114,101,100,101,102,105,110,101,0],"i8",x);ql=y([104,112,112,0],"i8",x);rl=y([110,110,111,114,101,0],"i8",x);sl=y([108,111,111,112,0],"i8",x);tl=y([101,120,99,101,112,116,105,111,110,0],"i8",x);ul=y([77,97,107,101,0],"i8",x);vl=y([60,61,62,0],"i8",x);wl=y([110,97,109,101,115,112,97,99,101,0],"i8",x);xl=y([108,105,115,112,0],"i8",x);yl=y([65,32,116,121,112,101,32,115,116,114,117,99,116,117,114,101,0],"i8",x);zl=y([112,114,101,102,105,120,0],"i8",x);Al=y([104,104,0],"i8",x);Bl=y([110,110,111,114,0],"i8",x);Cl=y([108,105,116,101,114,97,108,0],"i8",x);Dl=y([62,61,0],"i8",x);El=y([99,111,110,115,116,0],"i8",x);Fl=y([102,97,108,115,101,0],"i8",x);Gl=y([65,32,116,121,112,101,32,97,108,105,97,115,0],"i8",x);Hl=y([111,112,116,105,111,110,97,108,0],"i8",x);Il=y([72,0],"i8",x);Jl=y([110,110,111,0],"i8",x);Kl=y([108,105,110,107,97,103,101,0],"i8",x);Ll=y([62,0],"i8",x);Ml=y([99,108,97,115,115,32,109,101,109,98,101,114,115,0],"i8",x);Nl=y([102,57,48,0],"i8",x);Ol=y([116,114,117,101,0],"i8",x);Pl=y([65,32,112,114,111,112,101,114,116,121,0],"i8",x);Ql=y([111,112,101,114,97,116,111,114,0],"i8",x);Rl=y([111,110,99,101,0],"i8",x);Sl=y([104,0],"i8",x);Tl=y([110,111,114,101,109,97,112,0],"i8",x);Ul=y([108,105,98,114,97,114,121,0],"i8",x);Vl=y([69,114,108,97,110,103,0],"i8",x);Wl=y([60,0],"i8",x);Xl=y([45,62,0],"i8",x);Yl=y([112,114,111,112,101,114,116,121,0],"i8",x);Zl=y([110,97,109,101,108,105,115,116,0],"i8",x);$l=y([111,108,100,0],"i8",x);am=y([32,32,32,32,83,101,116,116,105,110,103,32,100,101,102,97,117,108,116,32,104,101,97,100,101,114,32,101,120,116,101,110,115,105,111,110,115,58,32,0],"i8",x);bm=y([110,111,114,101,109,97,0],"i8",x);cm=y([108,97,98,101,108,0],"i8",x);dm=y([116,97,115,107,115,0],"i8",x);em=y([101,120,116,101,114,110,97,108,0],"i8",x);fm=y([100,101,108,101,116,101,0],"i8",x);gm=y([60,61,0],"i8",x);hm=y(1,"i8",x);im=y([105,102,0],"i8",x);jm=y([67,111,98,111,108,0],"i8",x);km=y([97,115,114,0],"i8",x);lm=y([37,115,46,37,115,0],"i8",x);mm=y([108,44,108,97,98,101,108,44,108,97,98,101,108,115,0],"i8",x);nm=y([109,120,116,97,103,115,0],"i8",x);om=y([99,111,109,0],"i8",x);pm=y([111,98,115,111,108,101,116,101,0],"i8",x);qm=y([97,99,99,101,115,115,0],"i8",x);rm=y([32,32,32,32,97,100,100,105,110,103,32,101,120,99,108,117,100,101,32,112,97,116,116,101,114,110,58,32,37,115,10,0],"i8",x);sm=y([115,117,98,115,101,99,116,105,111,110,0],"i8",x);tm=y([110,111,114,101,109,0],"i8",x);um=y([84,99,108,0],"i8",x);vm=y([105,115,0],"i8",x);wm=y([114,101,103,105,115,116,101,114,32,100,97,116,97,32,116,121,112,101,115,0],"i8",x);xm=y([99,112,0],"i8",x);ym=y([105,110,116,101,114,110,97,108,0],"i8",x);zm=y([42,46,65,53,49,0],"i8",x);Am=y([100,101,108,101,103,97,116,101,0],"i8",x);Bm=y([124,0],"i8",x);Cm=y([34,34,34,0],"i8",x);Dm=y([108,115,114,32,0],"i8",x);Em=y([109,120,116,97,103,0],"i8",x);Fm=y([32,32,32,32,97,100,100,105,110,103,32,101,120,99,108,117,100,101,32,112,97,116,116,101,114,110,115,32,102,114,111,109,32,37,115,10,0],"i8",x);Gm=y([110,111,114,101,0],"i8",x);Hm=y([105,110,111,117,116,0],"i8",x);Im=y([117,114,108,0],"i8",x);Jm=y([112,44,112,114,111,106,101,99,116,44,112,114,111,106,101,99,116,115,0],"i8",x);Km=y([94,0],"i8",x);Lm=y([39,39,39,0],"i8",x);Mm=y([42,41,0],"i8",x);Nm=y([108,115,108,32,0],"i8",x);Om=y([79,98,106,101,99,116,32,102,105,101,108,100,0],"i8",x);Pm=y([80,82,79,71,82,65,77,0],"i8",x);Qm=y([98,97,115,104,0],"i8",x);Rm=y([115,99,104,101,109,101,0],"i8",x);Sm=y([108,111,103,105,99,97,108,0],"i8",x);Tm=y([110,111,114,0],"i8",x);Um=y([105,110,101,114,116,105,97,108,0],"i8",x);Vm=y([112,111,114,116,115,0],"i8",x);Wm=y([114,101,115,117,108,116,0],"i8",x);Xm=y([38,0],"i8",x);Ym=y([99,112,100,101,102,0],"i8",x);Zm=y([61,98,101,103,105,110,0],"i8",x);$m=y([82,69,88,88,0],"i8",x);an=y([108,120,111,114,32,0],"i8",x);bn=y([105,110,116,114,105,110,115,105,99,0],"i8",x);cn=y([112,120,105,0],"i8",x);dn=y([46,115,118,110,0],"i8",x);en=y([105,110,0],"i8",x);fn=y([100,97,116,97,116,121,112,101,0],"i8",x);gn=y([99,111,118,101,114,97,103,101,95,100,101,102,0],"i8",x);hn=y([80,72,80,0],"i8",x);jn=y([60,60,0],"i8",x);kn=y([99,100,101,102,0],"i8",x);ln=y([108,111,114,32,0],"i8",x);mn=y([112,101,114,108,0],"i8",x);nn=y([108,105,107,101,0],"i8",x);on=y([83,67,67,83,0],"i8",x);pn=y([99,109,97,112,0],"i8",x);qn=y([105,109,112,117,114,101,0],"i8",x);rn=y([110,101,116,32,100,97,116,97,32,116,121,112,101,115,0],"i8",x);sn=y([100,111,109,97,105,110,0],"i8",x);tn=y([99,111,118,101,114,97,103,101,95,98,108,111,99,107,0],"i8",x);un=y([62,62,0],"i8",x);vn=y([108,97,110,100,32,0],"i8",x);wn=y([112,98,0],"i8",x);xn=y([105,110,116,101,110,116,0],"i8",x);yn=y([116,121,112,101,100,101,102,0],"i8",x);zn=y([82,69,83,89,78,67,0],"i8",x);An=y([99,109,97,0],"i8",x);Bn=y([110,101,116,0],"i8",x);Cn=y([115,101,114,118,105,99,101,0],"i8",x);Dn=y([97,115,112,0],"i8",x);En=y([109,107,0],"i8",x);Fn=y([65,119,107,0],"i8",x);Gn=y([102,114,111,109,0],"i8",x);Hn=y([108,0],"i8",x);In=y([115,117,98,114,111,117,116,105,110,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Jn=y([109,111,100,32,0],"i8",x);Kn=y([67,108,97,115,115,39,32,109,101,116,104,111,100,0],"i8",x);Ln=y([70,117,110,99,116,105,111,110,0],"i8",x);Mn=y([105,110,118,97,114,105,97,110,116,0],"i8",x);Nn=y([60,97,40,91,32,9,93,43,91,97,45,122,93,43,61,34,63,91,94,62,34,93,42,34,63,41,42,91,32,9,93,43,110,97,109,101,61,34,63,40,91,94,62,34,93,43,41,34,63,40,91,32,9,93,43,91,97,45,122,93,43,61,34,63,91,94,62,34,93,42,34,63,41,42,91,32,9,93,42,62,0],"i8",x);On=y([82,67,83,0],"i8",x);Pn=y([99,109,0],"i8",x);Qn=y([103,117,97,114,100,101,100,0],"i8",x);Rn=y([109,111,100,117,108,101,115,0],"i8",x);Sn=y([112,117,98,108,105,99,97,116,105,111,110,0],"i8",x);Tn=y([116,121,112,101,115,32,40,115,116,114,117,99,116,115,32,97,110,100,32,114,101,99,111,114,100,115,41,0],"i8",x);Un=y([43,0],"i8",x);Vn=y([101,120,116,101,114,110,0],"i8",x);Wn=y([115,117,98,114,111,117,116,105,110,101,32,100,101,99,108,97,114,97,116,105,111,110,0],"i8",x);Xn=y([105,110,108,105,110,101,0],"i8",x);Yn=y([105,110,115,112,101,99,116,0],"i8",x);Zn=y([80,69,78,68,73,78,71,0],"i8",x);$n=y([108,109,97,112,0],"i8",x);ao=y([103,114,111,117,112,0],"i8",x);bo=y([102,117,110,99,116,105,111,110,115,0],"i8",x);co=y([37,0],"i8",x);eo=y([115,117,98,114,111,117,116,105,110,101,115,0],"i8",x);fo=y([102,55,55,0],"i8",x);go=y([105,110,104,101,114,105,116,0],"i8",x);ho=y([46,104,103,0],"i8",x);io=y([99,104,97,114,0],"i8",x);jo=y([108,109,97,0],"i8",x);ko=y([103,101,110,101,114,105,99,0],"i8",x);lo=y([101,118,101,110,116,115,0],"i8",x);mo=y([105,110,100,101,120,0],"i8",x);no=y([72,82,76,0],"i8",x);oo=y([115,117,98,114,111,117,116,105,110,101,0],"i8",x);po=y([105,109,112,108,105,99,105,116,0],"i8",x);qo=y([105,110,102,105,120,0],"i8",x);ro=y([46,103,105,116,0],"i8",x);so=y([108,109,0],"i8",x);to=y([103,101,110,101,114,97,116,101,0],"i8",x);uo=y([99,111,110,115,116,97,110,116,115,32,40,100,101,102,105,110,101,44,32,112,97,114,97,109,101,116,101,114,44,32,115,112,101,99,112,97,114,97,109,41,0],"i8",x);vo=y([94,58,40,91,65,45,90,97,45,122,95,48,45,57,93,43,41,0],"i8",x);wo=y([42,0],"i8",x);xo=y([108,97,109,98,100,97,0],"i8",x);yo=y([105,110,99,108,117,100,101,32,0],"i8",x);zo=y([117,110,100,101,102,0],"i8",x);Ao=y([67,79,66,0],"i8",x);Bo=y([118,105,114,116,117,97,108,0],"i8",x);Co=y([32,58,32,37,115,0],"i8",x);Do=y([80,114,111,116,111,99,111,108,0],"i8",x);Eo=y([32,0],"i8",x);Fo=y([92,49,0],"i8",x);Go=y([99,111,109,99,0],"i8",x);Ho=y([105,110,100,101,120,105,110,103,0],"i8",x);Io=y([97,98,115,0],"i8",x);Jo=y([101,118,101,110,116,0],"i8",x);Ko=y([69,73,70,71,69,78,0],"i8",x);Lo=y([101,110,118,0],"i8",x);Mo=y([115,101,99,116,105,111,110,0],"i8",x);No=y([105,109,97,112,0],"i8",x);Oo=y([105,116,99,108,0],"i8",x);Po=y([116,114,105,103,103,101,114,0],"i8",x);Qo=y([99,99,0],"i8",x);Ro=y([83,0],"i8",x);So=y([100,101,102,105,110,101,115,0],"i8",x);To=y([101,110,117,109,101,114,97,116,105,111,110,115,0],"i8",x);Uo=y([45,64,0],"i8",x);Vo=y([108,97,98,101,108,115,0],"i8",x);Wo=y([112,114,111,116,111,99,111,108,0],"i8",x);Xo=y([102,97,108,0],"i8",x);Yo=y([111,118,101,114,114,105,100,101,0],"i8",x);Zo=y([105,109,112,108,105,101,115,0],"i8",x);$o=y([46,100,101,112,115,0],"i8",x);ap=y([105,109,97,0],"i8",x);bp=y([102,111,114,0],"i8",x);cp=y([116,97,98,108,101,0],"i8",x);dp=y([43,64,0],"i8",x);ep=y([83,77,76,0],"i8",x);fp=y([99,108,97,115,115,32,105,109,112,108,101,109,101,110,116,97,116,105,111,110,0],"i8",x);gp=y([94,46,42,100,101,102,105,110,101,91,32,9,93,43,40,91,65,45,90,95,93,91,65,45,90,48,45,57,95,93,42,41,91,94,59,93,42,36,0],"i8",x);hp=y([98,115,104,0],"i8",x);ip=y([76,73,66,0],"i8",x);jp=y([115,99,104,0],"i8",x);kp=y([102,120,0],"i8",x);lp=y([95,36,0],"i8",x);mp=y([95,100,97,114,99,115,0],"i8",x);np=y([105,109,0],"i8",x);op=y([98,111,111,108,101,97,110,0],"i8",x);pp=y([101,114,108,0],"i8",x);qp=y([115,0],"i8",x);rp=y([126,0],"i8",x);sp=y([95,95,105,110,105,116,95,95,0],"i8",x);tp=y([82,117,98,121,0],"i8",x);up=y([102,111,114,109,97,116,115,0],"i8",x);vp=y([114,120,0],"i8",x);wp=y([105,109,112,108,101,109,101,110,116,97,116,105,111,110,0],"i8",x);xp=y([103,108,111,98,97,108,32,118,97,114,105,97,98,108,101,115,0],"i8",x);yp=y([109,120,0],"i8",x);zp=y([102,114,111,122,101,110,0],"i8",x);Ap=y([112,120,100,0],"i8",x);Bp=y([46,99,118,115,105,103,110,111,114,101,0],"i8",x);Cp=y([111,109,97,112,0],"i8",x);Dp=y([98,105,116,0],"i8",x);Ep=y([101,120,105,116,0],"i8",x);Fp=y([114,101,116,117,114,110,115,0],"i8",x);Gp=y([95,36,63,0],"i8",x);Hp=y([112,104,116,109,108,0],"i8",x);Ip=y([33,0],"i8",x);Jp=y([95,95,0],"i8",x);Kp=y([99,111,110,115,116,97,110,116,115,0],"i8",x);Lp=y([116,114,121,0],"i8",x);Mp=y([99,108,97,115,115,32,105,110,116,101,114,102,97,99,101,0],"i8",x);Np=y([112,108,120,0],"i8",x);Op=y([80,97,115,99,97,108,0],"i8",x);Pp=y([101,113,117,105,118,97,108,101,110,99,101,0],"i8",x);Qp=y([99,100,97,116,97,0],"i8",x);Rp=y([67,86,83,0],"i8",x);Sp=y([111,109,97,0],"i8",x);Tp=y([98,105,110,100,95,118,97,114,0],"i8",x);Up=y([101,110,116,105,116,121,0],"i8",x);Vp=y([119,111,114,0],"i8",x);Wp=y([42,47,0],"i8",x);Zp=y([42,42,0],"i8",x);$p=y([109,101,109,98,101,114,0],"i8",x);aq=y([32,9,0],"i8",x);bq=y([79,67,97,109,108,0],"i8",x);cq=y([105,110,116,101,114,102,97,99,101,0],"i8",x);dq=y([112,114,111,112,101,114,116,105,101,115,0],"i8",x);eq=y([98,98,0],"i8",x);fq=y([101,110,116,114,121,0],"i8",x);gq=y([115,99,114,105,112,116,0],"i8",x);hq=y([102,101,97,116,117,114,101,0],"i8",x);iq=y([79,98,106,101,99,116,105,118,101,67,0],"i8",x);jq=y([46,98,122,114,105,103,110,111,114,101,0],"i8",x);kq=y([111,109,0],"i8",x);lq=y([98,105,110,100,0],"i8",x);mq=y([119,105,114,101,0],"i8",x);nq=y([114,101,109,0],"i8",x);oq=y([47,42,0],"i8",x);pq=y([118,97,108,117,101,32,98,105,110,100,105,110,103,115,0],"i8",x);qq=y([109,97,107,0],"i8",x);rq=y([91,93,61,0],"i8",x);sq=y([101,108,0],"i8",x);tq=y([109,97,119,107,0],"i8",x);uq=y([115,116,114,117,99,116,0],"i8",x);vq=y([110,97,109,101,0],"i8",x);wq=y([46,98,122,114,0],"i8",x);xq=y([72,84,77,76,0],"i8",x);yq=y([118,109,97,112,0],"i8",x);zq=y([98,97,100,95,116,114,97,110,115,0],"i8",x);Aq=y([101,108,115,105,102,0],"i8",x);Bq=y([119,97,110,100,0],"i8",x);Cq=y([114,101,102,0],"i8",x);Dq=y([59,42,64,0],"i8",x);Eq=y([118,97,108,117,101,0],"i8",x);Fq=y([91,93,0],"i8",x);Gq=y([58,0],"i8",x);Hq=y([101,108,101,109,101,110,116,97,108,0],"i8",x);Iq=y([105,100,0],"i8",x);Jq=y([10,0],"i8",x);Kq=y([66,105,116,75,101,101,112,101,114,0],"i8",x);Lq=y([118,109,97,0],"i8",x);Mq=y([98,97,100,95,115,116,97,116,101,0],"i8",x);Nq=y([116,114,105,114,101,103,0],"i8",x);Oq=y([111,98,106,101,99,116,0],"i8",x);Pq=y([63,33,61,0],"i8",x);Qq=y([65,115,112,0],"i8",x);Rq=y([102,116,110,0],"i8",x);Sq=y([114,101,99,0],"i8",x);Tq=y([64,114,101,113,117,105,114,101,100,0],"i8",x);Uq=y([97,108,108,0],"i8",x);Vq=y([100,111,117,98,108,101,0],"i8",x);Wq=y([70,108,101,120,0],"i8",x);Xq=y([97,117,116,111,109,52,116,101,46,99,97,99,104,101,0],"i8",x);Yq=y([118,109,0],"i8",x);Zq=y([97,98,115,116,114,97,99,116,0],"i8",x);$q=y([100,111,119,110,116,111,0],"i8",x);ar=y([116,114,105,111,114,0],"i8",x);br=y([110,111,0],"i8",x);cr=y([70,97,108,99,111,110,0],"i8",x);dr=y([115,116,114,117,99,116,117,114,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);er=y([104,114,108,0],"i8",x);fr=y([95,0],"i8",x);gr=y([98,114,34,0],"i8",x);hr=y([111,110,0],"i8",x);ir=y([112,111,100,0],"i8",x);jr=y([64,111,112,116,105,111,110,97,108,0],"i8",x);kr=y([121,0],"i8",x);lr=y([101,120,112,97,110,100,101,100,0],"i8",x);mr=y([46,97,114,99,104,45,105,110,118,101,110,116,111,114,121,0],"i8",x);nr=y([110,109,97,112,0],"i8",x);or=y([95,95,97,116,116,114,105,98,117,116,101,95,95,0],"i8",x);pr=y([100,105,115,99,111,110,110,101,99,116,0],"i8",x);qr=y([116,114,105,0],"i8",x);rr=y([68,111,115,66,97,116,99,104,0],"i8",x);sr=y([102,0],"i8",x);tr=y([115,105,103,110,97,116,117,114,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);ur=y([109,101,100,105,97,0],"i8",x);vr=y([32,44,34,46,35,95,63,33,61,39,47,45,0],"i8",x);wr=y([79,80,69,78,73,78,71,32,37,115,32,97,115,32,37,115,32,108,97,110,103,117,97,103,101,32,37,115,102,105,108,101,10,0],"i8",x);xr=y([98,114,39,0],"i8",x);yr=y([92,50,46,92,51,0],"i8",x);zr=y([100,101,102,105,110,101,0],"i8",x);Ar=y([67,66,76,0],"i8",x);Br=y([98,97,99,107,0],"i8",x);Cr=y([44,32,0],"i8",x);Dr=y([64,100,121,110,97,109,105,99,0],"i8",x);Er=y([101,0],"i8",x);Fr=y([94,40,91,65,45,90,97,45,122,93,91,65,45,90,97,45,122,95,48,45,57,93,43,41,91,32,9,93,42,58,0],"i8",x);Gr=y([100,108,108,95,105,109,112,111,114,116,0],"i8",x);Hr=y([99,111,109,112,0],"i8",x);Ir=y([101,110,115,117,114,101,0],"i8",x);Jr=y([86,72,68,76,0],"i8",x);Kr=y([96,100,101,102,105,110,101,0],"i8",x);Lr=y([46,97,114,99,104,45,105,100,115,0],"i8",x);Mr=y([105,103,110,111,114,105,110,103,32,37,115,32,40,108,97,110,103,117,97,103,101,32,100,105,115,97,98,108,101,100,41,10,0],"i8",x);Nr=y([99,104,97,112,116,101,114,0],"i8",x);Or=y([110,109,97,0],"i8",x);Pr=y([86,101,114,97,0],"i8",x);Qr=y([119,105,115,104,0],"i8",x);Rr=y([99,111,110,115,116,97,110,116,0],"i8",x);Sr=y([116,114,105,97,110,100,0],"i8",x);Tr=y([99,43,43,0],"i8",x);Ur=y([97,115,0],"i8",x);Vr=y([102,117,110,99,116,111,114,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);Wr=y([95,46,63,33,61,0],"i8",x);Xr=y([117,114,34,0],"i8",x);Yr=y([40,94,124,91,32,9,93,41,40,91,65,45,90,97,45,122,48,45,57,95,46,93,43,41,92,46,40,91,65,45,90,97,45,122,48,45,57,95,93,43,41,91,32,9,93,42,61,91,32,9,93,42,102,117,110,99,116,105,111,110,91,32,9,93,42,92,40,0],"i8",x);Zr=y([98,97,116,0],"i8",x);$r=y([105,116,101,109,0],"i8",x);as=y([102,111,114,109,97,116,0],"i8",x);bs=y([109,117,116,97,98,108,101,0],"i8",x);cs=y([64,115,121,110,116,104,101,115,105,122,101,0],"i8",x);ds=y([102,105,101,108,100,115,0],"i8",x);es=y([100,108,108,95,101,120,112,111,114,116,0],"i8",x);fs=y([123,97,114,99,104,125,0],"i8",x);gs=y([105,103,110,111,114,105,110,103,32,37,115,32,40,117,110,107,110,111,119,110,32,108,97,110,103,117,97,103,101,41,10,0],"i8",x);hs=y([110,109,0],"i8",x);is=y([118,114,104,0],"i8",x);js=y([99,111,110,102,105,103,117,114,97,116,105,111,110,0],"i8",x);ks=y([116,114,105,49,0],"i8",x);ls=y([94,91,32,9,93,42,60,91,32,9,93,42,112,114,111,106,101,99,116,91,94,62,93,43,110,97,109,101,61,34,40,91,94,34,93,43,41,34,46,42,0],"i8",x);ms=y([117,114,39,0],"i8",x);ns=y([106,44,106,115,102,117,110,99,116,105,111,110,44,106,97,118,97,115,99,114,105,112,116,32,102,117,110,99,116,105,111,110,115,0],"i8",x);os=y([111,118,101,114,0],"i8",x);ps=y([115,105,103,0],"i8",x);qs=y([64,112,114,111,116,101,99,116,101,100,0],"i8",x);rs=y([83,76,97,110,103,0],"i8",x);ss=y([83,72,0],"i8",x);ts=y([99,115,115,0],"i8",x);us=y([83,77,0],"i8",x);vs=y([66,69,84,65,0],"i8",x);ws=y([100,105,109,101,110,115,105,111,110,0],"i8",x);xs=y([32,32,73,110,115,116,97,108,108,105,110,103,32,100,101,102,97,117,108,116,32,101,120,99,108,117,100,101,32,112,97,116,116,101,114,110,115,58,10,0],"i8",x);ys=y([109,97,112,0],"i8",x);zs=y([118,114,105,0],"i8",x);As=y([99,111,109,112,111,110,101,110,116,0],"i8",x);Bs=y([116,114,105,48,0],"i8",x);Cs=y([105,110,99,108,117,100,101,115,0],"i8",x);Ds=y([99,97,108,108,0],"i8",x);Es=y([98,34,0],"i8",x);Fs=y([40,94,124,91,32,9,93,41,40,91,65,45,90,97,45,122,48,45,57,95,93,43,41,91,32,9,93,42,91,61,58,93,91,32,9,93,42,102,117,110,99,116,105,111,110,91,32,9,93,42,92,40,0],"i8",x);Gs=y([103,108,111,98,97,108,0],"i8",x);Hs=y([114,117,98,121,0],"i8",x);Is=y([104,101,97,100,52,0],"i8",x);Js=y([114,101,120,120,0],"i8",x);Ks=y([85,110,107,110,111,119,110,32,102,105,108,101,32,101,120,116,101,110,115,105,111,110,58,32,37,115,10,0],"i8",x);Ls=y([64,112,117,98,108,105,99,0],"i8",x);Ms=y([102,105,110,97,108,108,121,0],"i8",x);Ns=y([114,98,0],"i8",x);Os=y([100,97,116,97,0],"i8",x);Ps=y([115,44,115,101,99,116,105,111,110,44,115,101,99,116,105,111,110,115,0],"i8",x);Qs=y([112,121,120,0],"i8",x);Rs=y([58,61,0],"i8",x);Ss=y([32,32,73,110,115,116,97,108,108,105,110,103,32,100,101,102,97,117,108,116,32,108,97,110,103,117,97,103,101,32,109,97,112,112,105,110,103,115,58,10,0],"i8",x);Ts=y([60,115,112,101,99,105,97,108,62,0],"i8",x);Us=y([118,114,0],"i8",x);Vs=y([99,97,115,101,0],"i8",x);Ws=y([116,105,109,101,0],"i8",x);Xs=y([115,117,98,112,97,114,97,103,114,97,112,104,115,0],"i8",x);Ys=y([119,101,97,107,0],"i8",x);Zs=y([100,111,0],"i8",x);$s=y([65,83,77,0],"i8",x);at=y([101,120,99,101,112,116,105,111,110,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);bt=y([112,104,112,51,0],"i8",x);ct=y([98,39,0],"i8",x);dt=y([94,91,32,9,93,42,40,40,118,97,114,124,112,117,98,108,105,99,124,112,114,111,116,101,99,116,101,100,124,112,114,105,118,97,116,101,124,115,116,97,116,105,99,41,91,32,9,93,43,41,43,92,36,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,91,32,9,93,42,91,61,59,93,0],"i8",x);et=y([110,101,119,108,105,115,116,0],"i8",x);ft=y([104,101,97,100,51,0],"i8",x);gt=y([109,97,116,99,104,0],"i8",x);ht=y([64,112,97,99,107,97,103,101,0],"i8",x);it=y([99,98,108,0],"i8",x);jt=y([112,109,0],"i8",x);kt=y([99,97,116,99,104,0],"i8",x);lt=y([101,120,116,101,114,110,97,108,32,97,110,100,32,102,111,114,119,97,114,100,32,118,97,114,105,97,98,108,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);mt=y([112,97,115,0],"i8",x);nt=y([117,110,105,111,110,32,110,97,109,101,115,0],"i8",x);ot=y([99,111,110,116,97,105,110,115,0],"i8",x);pt=y([46,46,46,0],"i8",x);qt=y([37,115,58,32,99,111,110,102,117,115,105,110,103,32,97,114,103,117,109,101,110,116,32,100,101,99,108,97,114,97,116,105,111,110,115,32,98,101,103,105,110,110,105,110,103,32,97,116,32,108,105,110,101,32,37,108,117,10,0],"i8",x);rt=y([94,91,32,9,93,42,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,91,32,9,93,43,83,69,67,84,73,79,78,92,46,0],"i8",x);st=y([83,101,116,116,105,110,103,32,111,112,116,105,111,110,32,100,101,102,97,117,108,116,115,10,0],"i8",x);tt=y([60,101,120,112,114,62,0],"i8",x);ut=y([74,97,118,97,0],"i8",x);vt=y([98,117,115,0],"i8",x);wt=y([116,97,115,107,0],"i8",x);xt=y([112,97,114,97,103,114,97,112,104,115,0],"i8",x);yt=y([114,101,103,101,120,0],"i8",x);zt=y([123,59,44,61,0],"i8",x);At=y([44,59,0],"i8",x);Bt=y([118,97,108,0],"i8",x);Ct=y([60,62,0],"i8",x);Dt=y([114,34,0],"i8",x);Et=y([118,44,118,97,114,105,97,98,108,101,44,118,97,114,105,97,98,108,101,115,0],"i8",x);Ft=y([59,0],"i8",x);Gt=y([104,101,97,100,50,0],"i8",x);Ht=y([37,115,58,32,37,115,0],"i8",x);It=y([40,59,0],"i8",x);Jt=y([109,108,105,0],"i8",x);Kt=y([64,112,114,105,118,97,116,101,0],"i8",x);Lt=y([43,45,42,47,37,94,38,124,126,33,61,60,62,44,91,93,0],"i8",x);Mt=y([40,41,0],"i8",x);Nt=y([99,111,109,112,108,101,120,0],"i8",x);Ot=y([112,117,114,101,32,118,105,114,116,117,97,108,0],"i8",x);Pt=y([98,105,0],"i8",x);Qt=y([100,101,116,97,99,104,97,98,108,101,0],"i8",x);Rt=y([80,44,112,114,111,103,114,97,109,44,112,114,111,103,114,97,109,32,105,100,115,0],"i8",x);St=y([37,115,58,37,108,100,58,32,110,117,108,108,32,101,120,112,97,110,115,105,111,110,32,111,102,32,110,97,109,101,32,112,97,116,116,101,114,110,32,34,37,115,34,0],"i8",x);Tt=y([116,121,112,101,115,0],"i8",x);Ut=y([60,117,110,105,113,117,101,62,0],"i8",x);Vt=y([98,117,102,102,101,114,0],"i8",x);Wt=y([106,97,118,97,0],"i8",x);Xt=y([115,117,112,112,108,121,49,0],"i8",x);Yt=y([112,97,114,116,115,0],"i8",x);Zt=y([71,78,85,109,97,107,101,102,105,108,101,0],"i8",x);$t=y([76,117,97,0],"i8",x);au=y([95,95,97,110,111,110,37,100,0],"i8",x);bu=y([114,39,0],"i8",x);cu=y([99,108,105,115,112,0],"i8",x);du=y([92,50,0],"i8",x);eu=y([104,101,97,100,49,0],"i8",x);fu=y([123,125,0],"i8",x);gu=y([103,97,119,107,0],"i8",x);hu=y([64,99,108,97,115,115,0],"i8",x);iu=y([37,115,58,32,117,110,101,120,112,101,99,116,101,100,32,99,108,111,115,105,110,103,32,98,114,97,99,101,32,97,116,32,108,105,110,101,32,37,108,117,10,0],"i8",x);ju=y([115,119,105,116,99,104,0],"i8",x);ku=y([37,115,58,32,114,101,116,114,121,105,110,103,32,102,105,108,101,32,119,105,116,104,32,102,97,108,108,98,97,99,107,32,98,114,97,99,101,32,109,97,116,99,104,105,110,103,32,97,108,103,111,114,105,116,104,109,10,0],"i8",x);lu=y([115,116,114,117,99,116,117,114,101,32,110,97,109,101,115,0],"i8",x);mu=y([99,111,109,109,111,110,0],"i8",x);nu=y([74,97,118,97,83,99,114,105,112,116,0],"i8",x);ou=y([100,101,102,101,114,114,101,100,0],"i8",x);pu=y([94,91,32,9,93,42,80,82,79,71,82,65,77,45,73,68,92,46,91,32,9,93,43,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,92,46,0],"i8",x);y([114,101,103,99,111,109,112,32,37,115,58,32,37,115,0],"i8",x);qu=y([78,79,78,69,0],"i8",x);ru=y([104,116,109,108,0],"i8",x);su=y([60,115,99,114,105,112,116,62,0],"i8",x);tu=y([98,111,100,121,0],"i8",x);uu=y([67,35,0],"i8",x);vu=y([115,117,112,112,108,121,48,0],"i8",x);wu=y([115,117,98,115,117,98,115,101,99,116,105,111,110,115,0],"i8",x);xu=y([112,114,111,99,101,100,117,114,101,115,0],"i8",x);yu=y([110,97,109,101,115,112,97,99,101,115,0],"i8",x);zu=y([101,113,117,0],"i8",x);Au=y([115,116,114,117,99,116,117,114,101,0],"i8",x);Bu=y([99,111,110,116,101,120,116,0],"i8",x);Cu=y([71,111,0],"i8",x);Du=y([117,34,0],"i8",x);Eu=y([94,91,32,9,93,42,40,92,36,124,58,58,92,36,124,92,36,116,104,105,115,45,62,41,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,91,32,9,93,42,61,0],"i8",x);Fu=y([83,84,68,79,85,84,0],"i8",x);Gu=y([112,117,98,108,105,99,32,102,117,110,99,116,105,111,110,0],"i8",x);Hu=y([64,100,101,102,115,0],"i8",x);Iu=y([109,97,99,114,111,115,0],"i8",x);Ju=y([105,110,116,101,114,102,97,99,101,115,0],"i8",x);Ku=y([101,110,117,109,32,116,121,112,101,115,0],"i8",x);Lu=y([117,110,107,110,111,119,110,0],"i8",x);Mu=y([99,104,97,114,97,99,116,101,114,0],"i8",x);Nu=y([100,101,98,117,103,0],"i8",x);Ou=y([101,110,117,109,32,99,111,110,115,116,97,110,116,115,0],"i8",x);Pu=y([112,44,112,97,114,97,103,114,97,112,104,44,112,97,114,97,103,114,97,112,104,115,0],"i8",x);Qu=y([117,110,107,110,111,119,110,32,114,101,103,101,120,32,102,108,97,103,58,32,39,37,99,39,0],"i8",x);Ru=y([60,115,105,108,101,110,116,62,0],"i8",x);Su=y([98,108,111,99,107,0],"i8",x);Tu=y([99,115,0],"i8",x);Uu=y([115,112,101,99,112,97,114,97,109,0],"i8",x);Vu=y([115,117,98,115,101,99,116,105,111,110,115,0],"i8",x);Wu=y([101,110,117,109,32,99,111,110,115,116,97,110,116,0],"i8",x);Xu=y([101,120,116,101,114,110,97,108,32,118,97,114,105,97,98,108,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Yu=y([101,110,100,115,0],"i8",x);Zu=y([115,105,103,110,97,116,117,114,101,0],"i8",x);$u=y([101,120,116,101,114,110,118,97,114,0],"i8",x);av=y([100,101,115,99,114,105,98,101,0],"i8",x);bv=y([117,39,0],"i8",x);cv=y([112,114,105,118,97,116,101,32,102,117,110,99,116,105,111,110,0],"i8",x);dv=y([97,115,97,0],"i8",x);ev=y([64,101,110,100,0],"i8",x);fv=y([116,121,112,101,100,101,102,115,0],"i8",x);gv=y([118,105,109,0],"i8",x);hv=y([102,117,110,99,116,105,111,110,32,112,114,111,116,111,116,121,112,101,115,0],"i8",x);iv=y([99,103,108,111,98,97,108,0],"i8",x);jv=y([114,101,99,111,114,100,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);kv=y([99,117,114,114,101,110,116,0],"i8",x);lv=y([109,120,109,108,0],"i8",x);mv=y([94,91,32,9,93,42,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,92,46,0],"i8",x);nv=y([60,98,117,102,102,101,114,62,0],"i8",x);ov=y([98,101,103,105,110,0],"i8",x);pv=y([67,43,43,0],"i8",x);qv=y([114,101,103,0],"i8",x);rv=y([115,101,99,116,105,111,110,115,0],"i8",x);sv=y([109,101,116,104,111,100,115,0],"i8",x);tv=y([112,97,116,116,101,114,110,115,32,40,118,105,114,116,117,97,108,32,111,114,32,114,101,98,111,117,110,100,41,0],"i8",x);uv=y([99,108,97,115,115,44,32,115,116,114,117,99,116,44,32,97,110,100,32,117,110,105,111,110,32,109,101,109,98,101,114,115,0],"i8",x);vv=y([102,116,100,0],"i8",x);wv=y([101,110,100,112,0],"i8",x);xv=y([102,117,110,0],"i8",x);yv=y([69,82,76,0],"i8",x);zv=y([94,91,32,9,93,42,40,40,115,116,97,116,105,99,124,112,117,98,108,105,99,124,112,114,111,116,101,99,116,101,100,124,112,114,105,118,97,116,101,41,91,32,9,93,43,41,42,102,117,110,99,116,105,111,110,91,32,9,93,43,38,63,91,32,9,93,42,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,0],"i8",x);Av=y([101,110,117,109,101,114,97,116,105,111,110,32,110,97,109,101,115,0],"i8",x);Bv=y([58,58,0],"i8",x);Cv=y([112,117,98,108,105,99,32,115,117,98,0],"i8",x);Dv=y([64,115,101,108,101,99,116,111,114,0],"i8",x);Ev=y([37,115,58,32,102,97,105,108,101,100,32,116,111,32,102,105,110,100,32,109,97,116,99,104,32,102,111,114,32,39,37,99,39,32,97,116,32,108,105,110,101,32,37,108,117,10,0],"i8",x);Fv=y([101,110,117,109,101,114,97,116,111,114,115,32,40,118,97,108,117,101,115,32,105,110,115,105,100,101,32,97,110,32,101,110,117,109,101,114,97,116,105,111,110,41,0],"i8",x);Gv=y([101,110,117,109,101,114,97,116,111,114,0],"i8",x);Hv=y([99,101,120,116,101,114,110,97,108,0],"i8",x);Iv=y([99,114,101,97,116,105,111,110,0],"i8",x);Jv=y([105,100,101,110,116,105,116,105,101,115,0],"i8",x);Kv=y([103,44,103,114,111,117,112,44,103,114,111,117,112,32,105,116,101,109,115,0],"i8",x);Lv=y([118,104,100,108,0],"i8",x);Mv=y([69,105,102,102,101,108,0],"i8",x);Nv=y([60,76,101,97,100,101,114,62,0],"i8",x);Ov=y([97,116,116,114,105,98,117,116,101,0],"i8",x);Pv=y([114,101,97,108,116,105,109,101,0],"i8",x);Qv=y([99,104,97,112,116,101,114,115,0],"i8",x);Rv=y([99,108,97,115,115,101,115,0],"i8",x);Sv=y([101,108,115,101,105,102,0],"i8",x);Tv=y([119,99,104,97,114,95,116,0],"i8",x);Uv=y([102,117,110,99,116,111,114,0],"i8",x);Vv=y([67,83,83,0],"i8",x);Wv=y([114,0],"i8",x);Xv=y([99,97,110,110,111,116,32,111,112,101,110,32,34,37,115,34,0],"i8",x);Yv=y([105,109,112,111,114,116,0],"i8",x);Zv=y([109,97,99,114,111,0],"i8",x);$v=y([100,44,100,101,102,105,110,101,44,99,111,110,115,116,97,110,116,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);aw=y([118,111,105,100,0],"i8",x);bw=y([99,111,98,0],"i8",x);cw=y([37,115,37,115,0],"i8",x);dw=y([112,114,105,118,97,116,101,32,115,117,98,0],"i8",x);ew=y([118,0],"i8",x);fw=y([87,97,114,110,105,110,103,58,32,0],"i8",x);gw=y([64,115,121,110,99,104,114,111,110,105,122,101,100,0],"i8",x);hw=y([46,45,95,0],"i8",x);iw=y([117,115,105,110,103,0],"i8",x);jw=y([117,115,104,111,114,116,0],"i8",x);kw=y([99,104,97,110,0],"i8",x);lw=y([37,115,40,37,115,41,0],"i8",x);mw=y([89,65,67,67,0],"i8",x);nw=y([117,110,115,105,103,110,101,100,0],"i8",x);ow=y([116,101,120,0],"i8",x);pw=y([98,121,116,101,0],"i8",x);qw=y([86,105,109,0],"i8",x);rw=y([116,99,108,0],"i8",x);sw=y([118,104,100,0],"i8",x);tw=y([117,108,111,110,103,0],"i8",x);uw=y([94,91,32,9,93,42,91,48,45,57,93,43,91,32,9,93,43,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,92,46,0],"i8",x);vw=y([86,101,114,105,108,111,103,0],"i8",x);ww=y([84,101,120,0],"i8",x);xw=y([60,83,73,68,62,0],"i8",x);yw=y([116,107,0],"i8",x);zw=y([97,115,115,101,114,116,0],"i8",x);Aw=y([114,101,97,108,0],"i8",x);Bw=y([109,101,116,104,111,100,0],"i8",x);Cw=y([108,111,99,97,108,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);Dw=y([115,108,111,116,115,32,40,102,114,97,103,109,101,110,116,32,117,115,101,115,41,0],"i8",x);Ew=y([117,105,110,116,0],"i8",x);Fw=y([67,0],"i8",x);Gw=y([108,111,99,97,108,0],"i8",x);Hw=y([83,81,76,0],"i8",x);Iw=y([116,121,112,101,110,97,109,101,0],"i8",x);Jw=y([101,110,100,109,0],"i8",x);Kw=y([115,101,116,115,0],"i8",x);Lw=y([112,97,99,107,97,103,101,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);Mw=y([99,112,100,101,102,32,0],"i8",x);Nw=y([112,114,111,99,101,100,117,114,101,32,112,114,111,116,111,116,121,112,101,115,32,97,110,100,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Ow=y([94,91,32,9,93,42,100,101,102,105,110,101,91,32,9,93,42,92,40,91,32,9,93,42,91,39,34,93,63,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,0],"i8",x);Pw=y([116,114,97,110,115,105,101,110,116,0],"i8",x);Qw=y([102,117,110,99,116,105,111,110,32,112,114,111,116,111,116,121,112,101,115,32,97,110,100,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Rw=y([99,0],"i8",x);Sw=y([64,112,114,111,112,101,114,116,121,0],"i8",x);Tw=y([112,114,111,116,111,116,121,112,101,115,0],"i8",x);Uw=y([58,63,43,0],"i8",x);Vw=y([116,114,97,110,115,105,116,105,111,110,0],"i8",x);Ww=y([112,114,111,116,111,116,121,112,101,0],"i8",x);Xw=y([116,114,97,110,115,0],"i8",x);Yw=y([99,111,109,112,111,110,101,110,116,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Zw=y([77,111,98,105,76,105,110,107,32,80,114,111,112,101,114,116,105,101,115,32,0],"i8",x);$w=y([116,104,114,111,119,115,0],"i8",x);ax=y([101,110,116,105,116,121,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);bx=y([109,108,112,114,111,112,0],"i8",x);cx=y([116,104,114,111,119,0],"i8",x);dx=y([99,111,110,118,101,114,116,0],"i8",x);ex=y([114,101,99,111,114,100,32,110,97,109,101,115,0],"i8",x);fx=y([77,111,98,105,76,105,110,107,32,67,111,110,110,32,83,99,114,105,112,116,115,0],"i8",x);gx=y([115,101,108,101,99,116,111,114,115,0],"i8",x);hx=y([102,44,102,105,108,101,44,102,105,108,101,32,100,101,115,99,114,105,112,116,105,111,110,115,32,40,70,68,44,32,83,68,44,32,82,68,41,0],"i8",x);ix=y([37,115,32,112,97,114,115,101,114,32,100,101,102,105,110,105,116,105,111,110,32,109,117,115,116,32,100,101,102,105,110,101,32,111,110,101,32,97,110,100,32,111,110,108,121,32,111,110,101,32,112,97,114,115,105,110,103,32,114,111,117,116,105,110,101,10,0],"i8",x);jx=y([101,110,100,102,0],"i8",x);kx=y([97,114,114,97,121,0],"i8",x);lx=y([112,97,114,97,109,101,116,101,114,0],"i8",x);mx=y([104,112,0],"i8",x);nx=y([112,114,105,118,97,116,101,0],"i8",x);ox=y([115,117,98,116,121,112,101,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);px=y([109,108,99,111,110,110,0],"i8",x);qx=y([115,108,111,116,0],"i8",x);rx=y([116,101,109,112,108,97,116,101,0],"i8",x);sx=y([112,114,111,103,114,97,109,32,40,103,108,111,98,97,108,41,32,97,110,100,32,109,111,100,117,108,101,32,118,97,114,105,97,98,108,101,115,0],"i8",x);tx=y([116,121,112,101,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);ux=y([77,111,98,105,76,105,110,107,32,84,97,98,108,101,32,83,99,114,105,112,116,115,0],"i8",x);vx=y([101,110,100,109,97,99,114,111,0],"i8",x);wx=y([65,110,116,0],"i8",x);xx=y([98,117,105,108,100,46,120,109,108,0],"i8",x);D=y(468,"i8",x);yx=y(8,"i8",x);zx=y(8,"i8",x);Ax=y([1,0,0,0,97,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Bx=y(12,"i8",x);Cx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,84,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);E=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,35,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,61,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,63,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,65,0,0,0,0,0,0,0,66,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0,68,0,0,0,0,0,0,0,69,0,0,0,0,0,0,0,70,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,73,0,0,0,0,0,0,0,74,0,0,0,0,0,0,0,75,0,0,0,0,0,0,0,76,0,0,0,0,0,0,0,77,0,0,0,0,0,0,0,78,0,0,0,0,0,0,0,79,0,0,0,0,0,0,0,80,0,0,0,0,0,0,0,81,0,0,0,0,0,0,0,82,0,0,0,0,0,0,0,83,0,0,0,0,0,0,0,84,0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,86,0,0,0,0,0,0,0,87,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,89,0,0,0,0,0,0,0,90,0,0,0,0,0,0,0,91,0,0,0,0,0,0,0,92,0,0,0,0,0,0,0,93,0,0,0,0,0,0,0,94,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Dx=y(8,"i8",x);Ex=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Fx=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Gx=y(16,"i8",x);Hx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,84,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Ix=y(4,"i8",x);Jx=y(4,"i8",x);Kx=y(8,"i8",x);Lx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,117,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,98,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,71,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Mx=y(20,"i8",x);Nx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Ox=y(4,"i8",x);Px=y(8,"i8",x);Qx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,76,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,84,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,82,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,68,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,86,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,121,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,122,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);F=y([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,35,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,61,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,63,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,65,0,0,0,0,0,0,0,66,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0,68,0,0,0,0,0,0,0,69,0,0,0,0,0,0,0,70,0,0,0,0,0,0,0,71,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Rx=y(12,"i8",x);Sx=y([1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Tx=y([0,0,0,0,5,0,0,0,0,0,0,0,-2,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Ux=y(8,"i8",x);Vx=y(4,"i8",x);Wx=y(28,"i8",x);Xx=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Yx=y(4,"i8",x);Zx=y([-1],["i32",0,0,0],x);$x=y(28,"i8",x);ay=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);by=y(12,"i8",x);cy=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,70,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,67,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);dy=y(16,"i8",x);ey=y(24,"i8",x);fy=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);gy=y(16,"i8",x);hy=y(20,"i8",x);iy=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);jy=y(12,"i8",x);ky=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);ly=y(4,"i8",x);my=y(4,"i8",x);ny=y(4,"i8",x);oy=y([0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0],x);py=y([0,0,0,0,-1,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,-1,0,0,0,3,0,0,0,-1,0,0,0,4,0,0,0,-1,0,0,0,5,0,0,0,-1,0,0,0,6,0,0,0,-1,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,1,0,0,0,10,0,0,0,2,0,0,0,11,0,0,0,1,0,0,0,12,0,0,0,3,0,0,0,13,0,0,0,-1,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,3,0,0,0],["i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0],x);qy=y(12,"i8",x);ry=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,77,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,67,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);sy=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,41,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);ty=y(12,"i8",x);uy=y([1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,73,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,70,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,77,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);vy=y(12,"i8",x);wy=y(12,"i8",x);xy=y([1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);yy=y(8,"i8",x);zy=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Ay=y(28,"i8",x);By=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Cy=y(4,"i8",x);Dy=y(4,"i8",x);Ey=y(4,"i8",x);Fy=y(4,"i8",x);Gy=y(4,"i8",x);Hy=y(4,"i8",x);Iy=y(4,"i8",x);Jy=y(4,"i8",x);Ky=y(4,"i8",x);Ly=y(4,"i8",x);My=y(4,"i8",x);Ny=y(4,"i8",x);Oy=y(4,"i8",x);Py=y(4,"i8",x);Qy=y(4,"i8",x);Ry=y(4,"i8",x);Sy=y(4,"i8",x);Ty=y(4,"i8",x);Uy=y(4,"i8",x);H=y([0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,9,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,13,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,20,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,17,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,22,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,23,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,24,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,25,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,29,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,30,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,34,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,35,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,38,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,39,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,46,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,51,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,53,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,56,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,58,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,61,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,63,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,65,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,66,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,67,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,68,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,69,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,71,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,72,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,70,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,73,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,74,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,75,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,76,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,77,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,78,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,79,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,80,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,81,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,82,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,84,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,83,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,86,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,87,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,88,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,89,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,90,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,91,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,92,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,93,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,94,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,95,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,96,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,97,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,98,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,99,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0],["*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8"],x);Vy=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Wy=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Xy=y(8,"i8",x);Yy=y(8,"i8",x);Zy=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);$y=y(12,"i8",x);az=y(36,"i8",x);bz=y(4,"i8",x);cz=y(8,"i8",x);dz=y([1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);ez=y(4,"i8",x);fz=y(4,"i8",x);gz=y(4,"i8",x);hz=y(28,"i8",x);iz=y([1,0,0,0,98,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,107,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);J=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,35,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,61,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,63,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,65,0,0,0,0,0,0,0,66,0,0,0,0,0,0,0,67,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);jz=y(12,"i8",x);kz=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);lz=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);K=y(60,"i8",x);mz=y(12,"i8",x);nz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);oz=y(4,"i8",x);pz=y(40,"i8",x);qz=y(40,"i8",x);rz=y(40,"i8",x);sz=y(40,"i8",x);tz=y(40,"i8",x);uz=y(40,"i8",x);vz=y(40,"i8",x);wz=y(40,"i8",x);xz=y(40,"i8",x);yz=y(40,"i8",x);zz=y(20,"i8",x);Az=y([1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Bz=y(8,"i8",x);Cz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Dz=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,35,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,60,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Ez=y(12,"i8",x);Fz=y(4,"i8",x);Gz=y(8,"i8",x);Hz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Iz=y(8,"i8",x);Jz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,69,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Kz=y(48,"i8",x);Lz=y(352,"i8",x);Mz=y(4,"i8",x);Nz=y(4,"i8",x);Oz=y(4,"i8",x);Pz=y(20,"i8",x);Qz=y(4,"i8",x);Rz=y(4,"i8",x);Sz=y(8,"i8",x);Tz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,117,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Uz=y([240,0,0,0,242,0,0,0,258,0,0,0,178,0,0,0,302,0,0,0,98,0,0,0,196,0,0,0,184,0,0,0,290,0,0,0,42,0,0,0,76,0,0,0,214,0,0,0,112,0,0,0,28,0,0,0,72,0,0,0,264,0,0,0,40,0,0,0,136,0,0,0,32,0,0,0,80,0,0,0,34,0,0,0,106,0,0,0,90,0,0,0,200,0,0,0,138,0,0,0,292,0,0,0,58,0,0,0,56,0,0,0,6,0,0,0,146,0,0,0,218,0,0,0,252,0,0,0,52,0,0,0,30,0,0,0,222,0,0,0,96,0,0,0,262,0,0,0,54,0,0,0,182,0,0,0,152,0,0,0,220,0,0,0,226,0,0,0,206,0,0,0,244,0,0,0],["*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0],x);Vz=y(4,"i8",x);Wz=y(8,"i8",x);Xz=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Yz=y(20,"i8",x);Zz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);$z=y(16,"i8",x);aA=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);bA=y(12,"i8",x);cA=y([1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);dA=y(20,"i8",x);eA=y(20,"i8",x);fA=y([1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);gA=y([0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);hA=y(8,"i8",x);iA=y(4,"i8",x);jA=y(4,"i8",x);kA=y(4,"i8",x);lA=y(4,"i8",x);t[dc>>2]=et|0;t[dc+12>>2]=Gs|0;t[dc+24>>2]=xg|0;t[dc+36>>2]=ci|0;t[dc+48>>2]=cq|0;t[dc+60>>2]=Au|0;t[hc>>2]=Fq|0;t[hc+4>>2]=rq|0;t[hc+8>>2]=Zp|0;t[hc+12>>2]=Ip|0;t[hc+16>>2]=rp|0;t[hc+20>>2]=dp|0;t[hc+24>>2]=Uo|0;t[hc+28>>2]=wo|0;t[hc+32>>2]=dh|0;t[hc+36>>2]=co|0;t[hc+40>>2]=Un|0;t[hc+44>>2]=Bg|0;t[hc+48>>2]=un|0;t[hc+52>>2]=jn|0;t[hc+56>>2]=Xm|0;t[hc+60>>2]=Km|0;t[hc+64>>2]=Bm|0;t[hc+68>>2]=gm|0;t[hc+72>>2]=Wl|0;t[hc+76>>2]=Ll|0;t[hc+80>>2]=Dl|0;t[hc+84>>2]=vl|0;t[hc+88>>2]=jl|0;t[hc+92>>2]=$k|0;t[hc+96>>2]=Nk|0;t[hc+100>>2]=Ck|0;t[hc+104>>2]=tk|0;t[hc+108>>2]=bk|0;t[sc>>2]=yn|0;t[sc+8>>2]=uq|0;t[sc+16>>2]=wj|0;t[sc+24>>2]=Uh|0;t[sc+32>>2]=zg|0;t[sc+40>>2]=uf|0;t[sc+48>>2]=Zd|0;t[sc+56>>2]=Sw|0;t[sc+64>>2]=gw|0;t[sc+72>>2]=Dv|0;t[sc+80>>2]=ev|0;t[sc+88>>2]=Hu|0;t[sc+96>>2]=hu|0;t[sc+104>>2]=Kt|0;t[sc+112>>2]=ht|0;t[sc+120>>2]=Ls|0;t[sc+128>>2]=qs|0;t[sc+136>>2]=cs|0;t[sc+144>>2]=Dr|0;t[sc+152>>2]=jr|0;t[sc+160>>2]=Tq|0;t[Cc>>2]=134;t[Cc+4>>2]=204;t[Fc>>2]=eu|0;t[Fc+4>>2]=Gt|0;t[Fc+8>>2]=ft|0;t[Fc+12>>2]=Is|0;t[Fc+16>>2]=os|0;t[Fc+20>>2]=$r|0;t[Fc+24>>2]=Br|0;t[Fc+28>>2]=ir|0;t[Fc+32>>2]=ov|0;t[Fc+36>>2]=Sf|0;t[Fc+40>>2]=bp|0;t[Ic>>2]=hh|0;t[Ic+4>>2]=Zq|0;t[Ic+8>>2]=Bo|0;t[Ic+12>>2]=Ot|0;t[Xc>>2]=El|0;t[Xc+12>>2]=Rh|0;t[Xc+24>>2]=xg|0;t[Xc+36>>2]=mu|0;t[Xc+48>>2]=Cf|0;t[Xc+60>>2]=nf|0;t[Xc+72>>2]=dw|0;t[Xc+84>>2]=Cv|0;t[Xc+96>>2]=cv|0;t[Xc+108>>2]=Gu|0;t[Xc+120>>2]=wf|0;t[Xc+132>>2]=wj|0;t[sd>>2]=El|0;t[sd+12>>2]=Gs|0;t[sd+24>>2]=xg|0;t[sd+36>>2]=Cf|0;t[sd+48>>2]=wf|0;t[td>>2]=hh|0;t[td+4>>2]=Gw|0;t[td+8>>2]=nx|0;t[td+12>>2]=Ve|0;t[td+16>>2]=Yf|0;t[td+20>>2]=Vf|0;t[yx>>2]=kr|0;t[zx>>2]=gv|0;t[Ax+8>>2]=cg|0;t[Ax+12>>2]=Xf|0;t[Ax+24>>2]=Lf|0;t[Ax+28>>2]=Hf|0;t[Ax+40>>2]=Cf|0;t[Ax+44>>2]=yf|0;t[Ax+56>>2]=ys|0;t[Ax+60>>2]=vf|0;t[Ax+72>>2]=qf|0;t[Ax+76>>2]=kf|0;t[Bx>>2]=Lv|0;t[Bx+4>>2]=sw|0;t[Cx+8>>2]=Rr|0;t[Cx+12>>2]=Bd|0;t[Cx+24>>2]=wf|0;t[Cx+28>>2]=tx|0;t[Cx+40>>2]=Mf|0;t[Cx+44>>2]=ox|0;t[Cx+56>>2]=Hh|0;t[Cx+60>>2]=ex|0;t[Cx+72>>2]=Up|0;t[Cx+76>>2]=ax|0;t[Cx+88>>2]=As|0;t[Cx+92>>2]=Yw|0;t[Cx+104>>2]=Ww|0;t[Cx+108>>2]=Tw|0;t[Cx+120>>2]=Cf|0;t[Cx+124>>2]=Qw|0;t[Cx+136>>2]=ci|0;t[Cx+140>>2]=Nw|0;t[Cx+152>>2]=Gi|0;t[Cx+156>>2]=Lw|0;t[Cx+168>>2]=Gw|0;t[Cx+172>>2]=Cw|0;t[E>>2]=Io|0;t[E+8>>2]=qm|0;t[E+16>>2]=kk|0;t[E+24>>2]=Ai|0;t[E+32>>2]=Uq|0;t[E+40>>2]=Tf|0;t[E+48>>2]=Se|0;t[E+56>>2]=kx|0;t[E+64>>2]=zw|0;t[E+72>>2]=Ov|0;t[E+80>>2]=ov|0;t[E+88>>2]=Su|0;t[E+96>>2]=tu|0;t[E+104>>2]=Vt|0;t[E+112>>2]=vt|0;t[E+120>>2]=Vs|0;t[E+128>>2]=As|0;t[E+136>>2]=js|0;t[E+144>>2]=Rr|0;t[E+152>>2]=pr|0;t[E+160>>2]=$q|0;t[E+168>>2]=ti|0;t[E+176>>2]=Aq|0;t[E+184>>2]=Sf|0;t[E+192>>2]=Up|0;t[E+200>>2]=Ep|0;t[E+208>>2]=Ne|0;t[E+216>>2]=bp|0;t[E+224>>2]=Cf|0;t[E+232>>2]=to|0;t[E+240>>2]=ko|0;t[E+248>>2]=ao|0;t[E+256>>2]=Qn|0;t[E+264>>2]=im|0;t[E+272>>2]=qn|0;t[E+280>>2]=en|0;t[E+288>>2]=Um|0;t[E+296>>2]=Hm|0;t[E+304>>2]=vm|0;t[E+312>>2]=cm|0;t[E+320>>2]=Ul|0;t[E+328>>2]=Kl|0;t[E+336>>2]=Cl|0;t[E+344>>2]=sl|0;t[E+352>>2]=ys|0;t[E+360>>2]=Xk|0;t[E+368>>2]=Lk|0;t[E+376>>2]=yk|0;t[E+384>>2]=pk|0;t[E+392>>2]=Tm|0;t[E+400>>2]=Sj|0;t[E+408>>2]=Lj|0;t[E+416>>2]=Gj|0;t[E+424>>2]=hr|0;t[E+432>>2]=sj|0;t[E+440>>2]=gj|0;t[E+448>>2]=Zi|0;t[E+456>>2]=Ni|0;t[E+464>>2]=Gi|0;t[E+472>>2]=oi|0;t[E+480>>2]=hi|0;t[E+488>>2]=ci|0;t[E+496>>2]=$h|0;t[E+504>>2]=Wh|0;t[E+512>>2]=Ph|0;t[E+520>>2]=Hh|0;t[E+528>>2]=Bh|0;t[E+536>>2]=rh|0;t[E+544>>2]=lh|0;t[E+552>>2]=Zg|0;t[E+560>>2]=Ug|0;t[E+568>>2]=Pg|0;t[E+576>>2]=Kg|0;t[E+584>>2]=Dg|0;t[E+592>>2]=vg|0;t[E+600>>2]=pg|0;t[E+608>>2]=lg|0;t[E+616>>2]=dg|0;t[E+624>>2]=Zf|0;t[E+632>>2]=Mf|0;t[E+640>>2]=If|0;t[E+648>>2]=Df|0;t[E+656>>2]=zf|0;t[E+664>>2]=wf|0;t[E+672>>2]=rf|0;t[E+680>>2]=lf|0;t[E+688>>2]=df|0;t[E+696>>2]=Ze|0;t[E+704>>2]=qf|0;t[E+712>>2]=Je|0;t[E+720>>2]=Fe|0;t[E+728>>2]=ye|0;t[E+736>>2]=ve|0;t[E+744>>2]=ae|0;t[E+752>>2]=Vd|0;t[Dx>>2]=ew|0;t[Ex+8>>2]=Rr|0;t[Ex+12>>2]=uo|0;t[Ex+24>>2]=Jo|0;t[Ex+28>>2]=lo|0;t[Ex+40>>2]=Cf|0;t[Ex+44>>2]=bo|0;t[Ex+56>>2]=Uf|0;t[Ex+60>>2]=Rn|0;t[Ex+72>>2]=Bn|0;t[Ex+76>>2]=rn|0;t[Ex+88>>2]=oi|0;t[Ex+92>>2]=Vm|0;t[Ex+104>>2]=Bh|0;t[Ex+108>>2]=wm|0;t[Ex+120>>2]=wt|0;t[Ex+124>>2]=dm|0;t[Fx>>2]=Kr|0;t[Fx+8>>2]=Jo|0;t[Fx+16>>2]=Cf|0;t[Fx+24>>2]=Hm|0;t[Fx+32>>2]=Bi|0;t[Fx+40>>2]=gh|0;t[Fx+48>>2]=Uf|0;t[Fx+56>>2]=Te|0;t[Fx+64>>2]=lx|0;t[Fx+72>>2]=Aw|0;t[Fx+80>>2]=Pv|0;t[Fx+88>>2]=qv|0;t[Fx+96>>2]=Uu|0;t[Fx+104>>2]=vu|0;t[Fx+112>>2]=Xt|0;t[Fx+120>>2]=wt|0;t[Fx+128>>2]=Ws|0;t[Fx+136>>2]=Bs|0;t[Fx+144>>2]=ks|0;t[Fx+152>>2]=Sr|0;t[Fx+160>>2]=qr|0;t[Fx+168>>2]=ar|0;t[Fx+176>>2]=Nq|0;t[Fx+184>>2]=Bq|0;t[Fx+192>>2]=mq|0;t[Fx+200>>2]=Vp|0;t[Gx>>2]=Us|0;t[Gx+4>>2]=zs|0;t[Gx+8>>2]=is|0;t[Hx+8>>2]=Fi|0;t[Hx+12>>2]=Rv|0;t[Hx+24>>2]=Zv|0;t[Hx+28>>2]=Ie|0;t[Hx+40>>2]=Gv|0;t[Hx+44>>2]=Fv|0;t[Hx+56>>2]=Cf|0;t[Hx+60>>2]=yf|0;t[Hx+72>>2]=wj|0;t[Hx+76>>2]=Av|0;t[Hx+88>>2]=Gw|0;t[Hx+92>>2]=Nf|0;t[Hx+104>>2]=$p|0;t[Hx+108>>2]=uv|0;t[Hx+120>>2]=Xj|0;t[Hx+124>>2]=Yd|0;t[Hx+136>>2]=Ww|0;t[Hx+140>>2]=hv|0;t[Hx+152>>2]=wt|0;t[Hx+156>>2]=dm|0;t[Hx+168>>2]=yn|0;t[Hx+172>>2]=fv|0;t[Hx+184>>2]=qf|0;t[Hx+188>>2]=kf|0;t[Hx+200>>2]=$u|0;t[Hx+204>>2]=Xu|0;t[Kx>>2]=ow|0;t[Lx+8>>2]=Nr|0;t[Lx+12>>2]=Qv|0;t[Lx+24>>2]=Mo|0;t[Lx+28>>2]=rv|0;t[Lx+40>>2]=sm|0;t[Lx+44>>2]=Vu|0;t[Lx+56>>2]=mk|0;t[Lx+60>>2]=wu|0;t[Lx+72>>2]=Ci|0;t[Lx+76>>2]=Yt|0;t[Lx+88>>2]=ih|0;t[Lx+92>>2]=xt|0;t[Lx+104>>2]=Wf|0;t[Lx+108>>2]=Xs|0;t[Lx+120>>2]=Ue|0;t[Lx+124>>2]=Cs|0;t[Mx>>2]=rw|0;t[Mx+4>>2]=yw|0;t[Mx+8>>2]=Qr|0;t[Mx+12>>2]=Oo|0;t[Nx+8>>2]=Fi|0;t[Nx+12>>2]=Rv|0;t[Nx+24>>2]=Bw|0;t[Nx+28>>2]=sv|0;t[Nx+40>>2]=ci|0;t[Nx+44>>2]=xu|0;t[Px>>2]=ud|0;t[Qx+8>>2]=Ii|0;t[Qx+12>>2]=Eg|0;t[Qx+24>>2]=Ww|0;t[Qx+28>>2]=Tw|0;t[Qx+40>>2]=Cf|0;t[Qx+44>>2]=bo|0;t[Qx+56>>2]=eg|0;t[Qx+60>>2]=$f|0;t[Qx+72>>2]=Gw|0;t[Qx+76>>2]=Nf|0;t[Qx+88>>2]=cm|0;t[Qx+92>>2]=Ef|0;t[Qx+104>>2]=Gi|0;t[Qx+108>>2]=Af|0;t[Qx+120>>2]=ci|0;t[Qx+124>>2]=xu|0;t[Qx+136>>2]=Hh|0;t[Qx+140>>2]=sf|0;t[Qx+152>>2]=Mf|0;t[Qx+156>>2]=mf|0;t[Qx+168>>2]=cp|0;t[Qx+172>>2]=ef|0;t[Qx+184>>2]=Po|0;t[Qx+188>>2]=$e|0;t[Qx+200>>2]=qf|0;t[Qx+204>>2]=We|0;t[Qx+216>>2]=mo|0;t[Qx+220>>2]=Ke|0;t[Qx+232>>2]=Jo|0;t[Qx+236>>2]=lo|0;t[Qx+248>>2]=Sn|0;t[Qx+252>>2]=ze|0;t[Qx+264>>2]=Cn|0;t[Qx+268>>2]=we|0;t[Qx+280>>2]=sn|0;t[Qx+284>>2]=be|0;t[Qx+296>>2]=Ch|0;t[Qx+300>>2]=Wd|0;t[Qx+312>>2]=sh|0;t[Qx+316>>2]=Gd|0;t[Qx+328>>2]=Cd|0;t[Qx+332>>2]=ux|0;t[Qx+344>>2]=px|0;t[Qx+348>>2]=fx|0;t[Qx+360>>2]=bx|0;t[Qx+364>>2]=Zw|0;t[F>>2]=Ur|0;t[F+8>>2]=vm|0;t[F+16>>2]=ov|0;t[F+24>>2]=tu|0;t[F+32>>2]=Ii|0;t[F+40>>2]=nh|0;t[F+48>>2]=Sf|0;t[F+56>>2]=Cf|0;t[F+64>>2]=im|0;t[F+72>>2]=ti|0;t[F+80>>2]=Sv|0;t[F+88>>2]=ch|0;t[F+96>>2]=sl|0;t[F+104>>2]=ye|0;t[F+112>>2]=Vs|0;t[F+120>>2]=bp|0;t[F+128>>2]=Zs|0;t[F+136>>2]=Ds|0;t[F+144>>2]=Gi|0;t[F+152>>2]=Of|0;t[F+160>>2]=ci|0;t[F+168>>2]=Hh|0;t[F+176>>2]=Oq|0;t[F+184>>2]=Cq|0;t[F+192>>2]=nq|0;t[F+200>>2]=lh|0;t[F+208>>2]=Fp|0;t[F+216>>2]=Mf|0;t[F+224>>2]=cp|0;t[F+232>>2]=Po|0;t[F+240>>2]=wf|0;t[F+248>>2]=mo|0;t[F+256>>2]=Jo|0;t[F+264>>2]=Sn|0;t[F+272>>2]=Cn|0;t[F+280>>2]=sn|0;t[F+288>>2]=fn|0;t[F+296>>2]=Wm|0;t[F+304>>2]=Im|0;t[F+312>>2]=ym|0;t[F+320>>2]=em|0;t[F+328>>2]=Fe|0;t[F+336>>2]=If|0;t[F+344>>2]=qf|0;t[F+352>>2]=tl|0;t[F+360>>2]=hl|0;t[F+368>>2]=hr|0;t[F+376>>2]=Mk|0;t[F+384>>2]=zk|0;t[F+392>>2]=rk|0;t[F+400>>2]=$j|0;t[F+408>>2]=Tj|0;t[F+416>>2]=Mj|0;t[F+424>>2]=Hj|0;t[F+432>>2]=zj|0;t[F+440>>2]=tj|0;t[F+448>>2]=hj|0;t[F+456>>2]=$i|0;t[F+464>>2]=Oi|0;t[F+472>>2]=Hi|0;t[F+480>>2]=pi|0;t[F+488>>2]=ii|0;t[F+496>>2]=di|0;t[F+504>>2]=ai|0;t[F+512>>2]=Gw|0;t[F+520>>2]=Qh|0;t[F+528>>2]=Ih|0;t[F+536>>2]=Ch|0;t[F+544>>2]=sh|0;t[F+552>>2]=mh|0;t[F+560>>2]=$g|0;t[F+568>>2]=Vg|0;t[F+576>>2]=Qg|0;t[Rx>>2]=Xd|0;t[Rx+4>>2]=ps|0;t[Sx+8>>2]=tl|0;t[Sx+12>>2]=at|0;t[Sx+24>>2]=Cf|0;t[Sx+28>>2]=yf|0;t[Sx+40>>2]=Uv|0;t[Sx+44>>2]=Vr|0;t[Sx+56>>2]=Zu|0;t[Sx+60>>2]=tr|0;t[Sx+72>>2]=Au|0;t[Sx+76>>2]=dr|0;t[Sx+88>>2]=wf|0;t[Sx+92>>2]=tx|0;t[Sx+104>>2]=Eq|0;t[Sx+108>>2]=pq|0;t[Tx>>2]=hg|0;t[Tx+8>>2]=Tf|0;t[Tx+16>>2]=fn|0;t[Tx+24>>2]=tl|0;t[Tx+32>>2]=Uv|0;t[Tx+40>>2]=xv|0;t[Tx+48>>2]=Zu|0;t[Tx+56>>2]=Au|0;t[Tx+64>>2]=wf|0;t[Tx+72>>2]=Bt|0;t[Ux>>2]=$d|0;t[Wx>>2]=xe|0;t[Wx+4>>2]=ss|0;t[Wx+8>>2]=hp|0;t[Wx+12>>2]=Qm|0;t[Wx+16>>2]=Fk|0;t[Wx+20>>2]=Ui|0;t[Xx+8>>2]=Cf|0;t[Xx+12>>2]=bo|0;t[$x>>2]=Be|0;t[$x+4>>2]=us|0;t[$x+8>>2]=jp|0;t[$x+12>>2]=Rm|0;t[$x+16>>2]=Gk|0;t[$x+20>>2]=Vi|0;t[ay+8>>2]=Cf|0;t[ay+12>>2]=bo|0;t[ay+24>>2]=Ad|0;t[ay+28>>2]=Kw|0;t[by>>2]=Ns|0;t[by+4>>2]=Hs|0;t[cy+8>>2]=Fi|0;t[cy+12>>2]=Rv|0;t[cy+24>>2]=Bw|0;t[cy+28>>2]=sv|0;t[cy+40>>2]=Uf|0;t[cy+44>>2]=Rn|0;t[cy+56>>2]=uj|0;t[cy+60>>2]=lj|0;t[cy+72>>2]=av|0;t[cy+76>>2]=aj|0;t[cy+88>>2]=Bu|0;t[cy+92>>2]=Qi|0;t[dy>>2]=tf|0;t[dy+4>>2]=Js|0;t[dy+8>>2]=vp|0;t[ey>>2]=Pf|0;t[ey+4>>2]=Qs|0;t[ey+8>>2]=Ap|0;t[ey+12>>2]=cn|0;t[ey+16>>2]=Uk|0;t[fy+8>>2]=Fi|0;t[fy+12>>2]=Rv|0;t[fy+24>>2]=Cf|0;t[fy+28>>2]=bo|0;t[fy+40>>2]=$p|0;t[fy+44>>2]=Ml|0;t[fy+56>>2]=qf|0;t[fy+60>>2]=We|0;t[fy+72>>2]=wl|0;t[fy+76>>2]=kl|0;t[gy>>2]=jg|0;t[gy+4>>2]=bt|0;t[gy+8>>2]=Hp|0;t[hy>>2]=Gg|0;t[hy+4>>2]=jt|0;t[hy+8>>2]=Np|0;t[hy+12>>2]=mn|0;t[iy+8>>2]=Rr|0;t[iy+12>>2]=Kp|0;t[iy+24>>2]=as|0;t[iy+28>>2]=up|0;t[iy+40>>2]=cm|0;t[iy+44>>2]=Vo|0;t[iy+56>>2]=Gi|0;t[iy+60>>2]=Af|0;t[iy+72>>2]=oo|0;t[iy+76>>2]=eo|0;t[iy+88>>2]=Wn|0;t[iy+92>>2]=In|0;t[jy>>2]=Ng|0;t[jy+4>>2]=mt|0;t[ky+8>>2]=Cf|0;t[ky+12>>2]=bo|0;t[ky+24>>2]=ci|0;t[ky+28>>2]=xu|0;t[qy>>2]=Sh|0;t[qy+4>>2]=Jt|0;t[ry+8>>2]=Fi|0;t[ry+12>>2]=Rv|0;t[ry+24>>2]=Bw|0;t[ry+28>>2]=uk|0;t[ry+40>>2]=Uf|0;t[ry+44>>2]=fk|0;t[ry+56>>2]=Wj|0;t[ry+60>>2]=Pj|0;t[ry+72>>2]=wf|0;t[ry+76>>2]=Ij|0;t[ry+88>>2]=Cf|0;t[ry+92>>2]=Cj|0;t[ry+104>>2]=vj|0;t[ry+108>>2]=mj|0;t[ry+120>>2]=cj|0;t[ry+124>>2]=Si|0;t[ry+136>>2]=Ji|0;t[ry+140>>2]=ui|0;t[sy>>2]=Tf|0;t[sy+8>>2]=ov|0;t[sy+16>>2]=Fi|0;t[sy+24>>2]=Zs|0;t[sy+32>>2]=yg|0;t[sy+40>>2]=ti|0;t[sy+48>>2]=Sf|0;t[sy+56>>2]=tl|0;t[sy+64>>2]=bp|0;t[sy+72>>2]=xv|0;t[sy+80>>2]=Cf|0;t[sy+88>>2]=Uv|0;t[sy+96>>2]=en|0;t[sy+104>>2]=fh|0;t[sy+112>>2]=gt|0;t[sy+120>>2]=Bw|0;t[sy+128>>2]=Uf|0;t[sy+136>>2]=bs|0;t[sy+144>>2]=Oq|0;t[sy+152>>2]=Gj|0;t[sy+160>>2]=Sq|0;t[sy+168>>2]=ps|0;t[sy+176>>2]=uq|0;t[sy+184>>2]=If|0;t[sy+192>>2]=Lp|0;t[sy+200>>2]=wf|0;t[sy+208>>2]=Bt|0;t[sy+216>>2]=Eq|0;t[sy+224>>2]=Bo|0;t[sy+232>>2]=ye|0;t[sy+240>>2]=ve|0;t[sy+248>>2]=gj|0;t[sy+256>>2]=Jn|0;t[sy+264>>2]=vn|0;t[sy+272>>2]=ln|0;t[sy+280>>2]=an|0;t[sy+288>>2]=Nm|0;t[sy+296>>2]=Dm|0;t[sy+304>>2]=km|0;t[sy+312>>2]=Xl|0;t[sy+320>>2]=Ol|0;t[sy+328>>2]=Fl|0;t[ty>>2]=xi|0;t[ty+4>>2]=Sl|0;t[uy+8>>2]=cq|0;t[uy+12>>2]=Mp|0;t[uy+24>>2]=wp|0;t[uy+28>>2]=fp|0;t[uy+40>>2]=Wo|0;t[uy+44>>2]=Do|0;t[uy+56>>2]=Bw|0;t[uy+60>>2]=uk|0;t[uy+72>>2]=Fi|0;t[uy+76>>2]=Kn|0;t[uy+88>>2]=Wj|0;t[uy+92>>2]=Pj|0;t[uy+104>>2]=eg|0;t[uy+108>>2]=Om|0;t[uy+120>>2]=Cf|0;t[uy+124>>2]=Cj|0;t[uy+136>>2]=Yl|0;t[uy+140>>2]=Pl|0;t[uy+152>>2]=yn|0;t[uy+156>>2]=Gl|0;t[uy+168>>2]=uq|0;t[uy+172>>2]=yl|0;t[uy+184>>2]=wj|0;t[uy+188>>2]=ml|0;t[uy+200>>2]=Zv|0;t[uy+204>>2]=Rk|0;t[vy>>2]=Wi|0;t[vy+4>>2]=Zt|0;t[wy>>2]=qq|0;t[wy+4>>2]=En|0;t[xy+8>>2]=Zv|0;t[xy+12>>2]=Iu|0;t[yy>>2]=bj|0;t[zy+8>>2]=Cf|0;t[zy+12>>2]=bo|0;t[Ay>>2]=ij|0;t[Ay+4>>2]=cu|0;t[Ay+8>>2]=sq|0;t[Ay+12>>2]=Hn|0;t[Ay+16>>2]=xl|0;t[Ay+20>>2]=Bj|0;t[By+8>>2]=Cf|0;t[By+12>>2]=bo|0;t[H>>2]=or|0;t[H+20>>2]=Zq|0;t[H+40>>2]=Mq|0;t[H+60>>2]=zq|0;t[H+80>>2]=lq|0;t[H+100>>2]=Tp|0;t[H+120>>2]=Dp|0;t[H+140>>2]=op|0;t[H+160>>2]=pw|0;t[H+180>>2]=Vs|0;t[H+200>>2]=kt|0;t[H+220>>2]=io|0;t[H+240>>2]=Fi|0;t[H+260>>2]=El|0;t[H+280>>2]=Tj|0;t[H+300>>2]=tn|0;t[H+320>>2]=gn|0;t[H+340>>2]=Zs|0;t[H+360>>2]=Vf|0;t[H+380>>2]=Am|0;t[H+400>>2]=fm|0;t[H+420>>2]=Vq|0;t[H+440>>2]=ti|0;t[H+460>>2]=wj|0;t[H+480>>2]=Jo|0;t[H+500>>2]=il|0;t[H+520>>2]=Yk|0;t[H+540>>2]=Vn|0;t[H+560>>2]=Ak|0;t[H+580>>2]=sk|0;t[H+600>>2]=bp|0;t[H+620>>2]=Vj|0;t[H+640>>2]=Nj|0;t[H+660>>2]=Cf|0;t[H+680>>2]=xj|0;t[H+700>>2]=im|0;t[H+720>>2]=jj|0;t[H+740>>2]=Yv|0;t[H+760>>2]=Xn|0;t[H+780>>2]=Hm|0;t[H+800>>2]=Bi|0;t[H+820>>2]=ji|0;t[H+840>>2]=gh|0;t[H+860>>2]=cq|0;t[H+880>>2]=ym|0;t[H+900>>2]=Gw|0;t[H+920>>2]=Kh|0;t[H+940>>2]=Dh|0;t[H+960>>2]=th|0;t[H+980>>2]=ph|0;t[H+1e3>>2]=ah|0;t[H+1020>>2]=bs|0;t[H+1040>>2]=wl|0;t[H+1060>>2]=Lg|0;t[H+1080>>2]=yk|0;t[H+1100>>2]=wg|0;t[H+1120>>2]=Ql|0;t[H+1140>>2]=Te|0;t[H+1160>>2]=fg|0;t[H+1180>>2]=Yo|0;t[H+1200>>2]=Gi|0;t[H+1220>>2]=Jf|0;t[H+1240>>2]=oi|0;t[H+1260>>2]=nx|0;t[H+1280>>2]=Xj|0;t[H+1300>>2]=Ve|0;t[H+1320>>2]=Yf|0;t[H+1340>>2]=Bh|0;t[H+1360>>2]=lh|0;t[H+1380>>2]=Ye|0;t[H+1400>>2]=Me|0;t[H+1420>>2]=Ee|0;t[H+1440>>2]=Ae|0;t[H+1460>>2]=wi|0;t[H+1480>>2]=re|0;t[H+1500>>2]=uq|0;t[H+1520>>2]=ju|0;t[H+1540>>2]=Dd|0;t[H+1560>>2]=wt|0;t[H+1580>>2]=rx|0;t[H+1600>>2]=te|0;t[H+1620>>2]=cx|0;t[H+1640>>2]=$w|0;t[H+1660>>2]=Xw|0;t[H+1680>>2]=Vw|0;t[H+1700>>2]=Pw|0;t[H+1720>>2]=Lp|0;t[H+1740>>2]=yn|0;t[H+1760>>2]=Iw|0;t[H+1780>>2]=Ew|0;t[H+1800>>2]=tw|0;t[H+1820>>2]=Fh|0;t[H+1840>>2]=nw|0;t[H+1860>>2]=jw|0;t[H+1880>>2]=iw|0;t[H+1900>>2]=Bo|0;t[H+1920>>2]=aw|0;t[H+1940>>2]=Wg|0;t[H+1960>>2]=Tv|0;t[H+1980>>2]=ye|0;t[Vy+8>>2]=Cf|0;t[Vy+12>>2]=bo|0;t[Vy+24>>2]=Fi|0;t[Vy+28>>2]=Rv|0;t[Vy+40>>2]=Bw|0;t[Vy+44>>2]=sv|0;t[Vy+56>>2]=Yl|0;t[Vy+60>>2]=dq|0;t[Vy+72>>2]=qf|0;t[Vy+76>>2]=xp|0;t[Wy>>2]=Cf|0;t[Wy+8>>2]=Ln|0;t[Wy+16>>2]=Oq|0;t[Wy+24>>2]=Dj|0;t[Wy+32>>2]=Ww|0;t[Wy+40>>2]=Wj|0;t[Wy+48>>2]=yk|0;t[Wy+56>>2]=te|0;t[Wy+64>>2]=bp|0;t[Wy+72>>2]=ye|0;t[Wy+80>>2]=Zs|0;t[Wy+88>>2]=im|0;t[Wy+96>>2]=ti|0;t[Wy+104>>2]=ju|0;t[Wy+112>>2]=Lp|0;t[Wy+120>>2]=kt|0;t[Wy+128>>2]=Ms|0;t[Xy>>2]=Yj|0;t[Yy>>2]=Wt|0;t[Zy+8>>2]=Fi|0;t[Zy+12>>2]=Rv|0;t[Zy+24>>2]=Wu|0;t[Zy+28>>2]=Ou|0;t[Zy+40>>2]=eg|0;t[Zy+44>>2]=ds|0;t[Zy+56>>2]=wj|0;t[Zy+60>>2]=Ku|0;t[Zy+72>>2]=cq|0;t[Zy+76>>2]=Ju|0;t[Zy+88>>2]=Gw|0;t[Zy+92>>2]=Nf|0;t[Zy+104>>2]=Bw|0;t[Zy+108>>2]=sv|0;t[Zy+120>>2]=Gi|0;t[Zy+124>>2]=Af|0;t[$y>>2]=ik|0;t[$y+4>>2]=ru|0;t[az>>2]=Sl|0;t[az+4>>2]=Il|0;t[az+8>>2]=Al|0;t[az+12>>2]=ql|0;t[az+16>>2]=fl|0;t[az+20>>2]=Vk|0;t[az+24>>2]=Jk|0;t[az+28>>2]=wk|0;t[cz>>2]=Qg|0;t[dz+8>>2]=Gi|0;t[dz+12>>2]=Af|0;t[dz+24>>2]=Mg|0;t[dz+28>>2]=bo|0;t[dz+40>>2]=El|0;t[dz+44>>2]=Kp|0;t[dz+56>>2]=wf|0;t[dz+60>>2]=Tt|0;t[dz+72>>2]=Wj|0;t[dz+76>>2]=We|0;t[hz>>2]=sr|0;t[hz+4>>2]=bp|0;t[hz+8>>2]=Rq|0;t[hz+12>>2]=fo|0;t[hz+16>>2]=Nl|0;t[hz+20>>2]=Oj|0;t[iz+8>>2]=Gf|0;t[iz+12>>2]=Gf|0;t[iz+24>>2]=mu|0;t[iz+28>>2]=Bf|0;t[iz+40>>2]=fq|0;t[iz+44>>2]=xf|0;t[iz+56>>2]=Cf|0;t[iz+60>>2]=bo|0;t[iz+72>>2]=cq|0;t[iz+76>>2]=pf|0;t[iz+88>>2]=As|0;t[iz+92>>2]=cf|0;t[iz+104>>2]=cm|0;t[iz+108>>2]=Vo|0;t[iz+120>>2]=Gw|0;t[iz+124>>2]=De|0;t[iz+136>>2]=Uf|0;t[iz+140>>2]=Rn|0;t[iz+152>>2]=Zl|0;t[iz+156>>2]=se|0;t[iz+168>>2]=Xj|0;t[iz+172>>2]=Yd|0;t[iz+184>>2]=oo|0;t[iz+188>>2]=eo|0;t[iz+200>>2]=wf|0;t[iz+204>>2]=Ed|0;t[iz+216>>2]=qf|0;t[iz+220>>2]=sx|0;t[J>>2]=Rg|0;t[J+8>>2]=Ff|0;t[J+16>>2]=Ce|0;t[J+24>>2]=Su|0;t[J+32>>2]=pw|0;t[J+40>>2]=Hv|0;t[J+48>>2]=iv|0;t[J+56>>2]=Mu|0;t[J+64>>2]=mu|0;t[J+72>>2]=Nt|0;t[J+80>>2]=ot|0;t[J+88>>2]=Os|0;t[J+96>>2]=ws|0;t[J+104>>2]=es|0;t[J+112>>2]=Gr|0;t[J+120>>2]=Zs|0;t[J+128>>2]=Vq|0;t[J+136>>2]=Hq|0;t[J+144>>2]=Sf|0;t[J+152>>2]=fq|0;t[J+160>>2]=Pp|0;t[J+168>>2]=em|0;t[J+176>>2]=as|0;t[J+184>>2]=Cf|0;t[J+192>>2]=im|0;t[J+200>>2]=po|0;t[J+208>>2]=Ue|0;t[J+216>>2]=Xn|0;t[J+224>>2]=gh|0;t[J+232>>2]=xn|0;t[J+240>>2]=cq|0;t[J+248>>2]=bn|0;t[J+256>>2]=Sm|0;t[J+264>>2]=ys|0;t[J+272>>2]=Uf|0;t[J+280>>2]=Zl|0;t[J+288>>2]=Ql|0;t[J+296>>2]=Hl|0;t[J+304>>2]=lx|0;t[J+312>>2]=ol|0;t[J+320>>2]=dl|0;t[J+328>>2]=Sk|0;t[J+336>>2]=Hk|0;t[J+344>>2]=vk|0;t[J+352>>2]=nx|0;t[J+360>>2]=Xj|0;t[J+368>>2]=Yf|0;t[J+376>>2]=Wh|0;t[J+384>>2]=Aw|0;t[J+392>>2]=Hh|0;t[J+400>>2]=pj|0;t[J+408>>2]=dj|0;t[J+416>>2]=Pg|0;t[J+424>>2]=Ki|0;t[J+432>>2]=wi|0;t[J+440>>2]=ki|0;t[J+448>>2]=Au|0;t[J+456>>2]=oo|0;t[J+464>>2]=Yh|0;t[J+472>>2]=If|0;t[J+480>>2]=wf|0;t[J+488>>2]=Fh|0;t[J+496>>2]=Ze|0;t[J+504>>2]=Eq|0;t[J+512>>2]=Bo|0;t[J+520>>2]=Wg|0;t[J+528>>2]=Sg|0;t[J+536>>2]=ye|0;t[jz>>2]=Ur|0;t[jz+4>>2]=lv|0;t[kz+8>>2]=Cf|0;t[kz+12>>2]=bo|0;t[kz+24>>2]=Fi|0;t[kz+28>>2]=Rv|0;t[kz+40>>2]=Bw|0;t[kz+44>>2]=sv|0;t[kz+56>>2]=Yl|0;t[kz+60>>2]=dq|0;t[kz+72>>2]=qf|0;t[kz+76>>2]=xp|0;t[kz+88>>2]=Em|0;t[kz+92>>2]=nm|0;t[lz>>2]=Cf|0;t[lz+8>>2]=Ln|0;t[lz+16>>2]=Oq|0;t[lz+24>>2]=Dj|0;t[lz+32>>2]=Ww|0;t[lz+40>>2]=Wj|0;t[lz+48>>2]=yk|0;t[lz+56>>2]=te|0;t[lz+64>>2]=bp|0;t[lz+72>>2]=ye|0;t[lz+80>>2]=Zs|0;t[lz+88>>2]=im|0;t[lz+96>>2]=ti|0;t[lz+104>>2]=ju|0;t[lz+112>>2]=Lp|0;t[lz+120>>2]=kt|0;t[lz+128>>2]=Ms|0;t[lz+136>>2]=Yf|0;t[lz+144>>2]=nx|0;t[lz+152>>2]=wi|0;t[lz+160>>2]=Fi|0;t[lz+168>>2]=Iq|0;t[lz+176>>2]=vq|0;t[lz+184>>2]=gq|0;t[lz+192>>2]=Qp|0;t[lz+200>>2]=yp|0;t[lz+208>>2]=kp|0;t[lz+216>>2]=Yo|0;t[mz>>2]=Xo|0;t[mz+4>>2]=vv|0;t[nz+8>>2]=Fi|0;t[nz+12>>2]=Rv|0;t[nz+24>>2]=Cf|0;t[nz+28>>2]=bo|0;t[nz+40>>2]=$p|0;t[nz+44>>2]=Ml|0;t[nz+56>>2]=qf|0;t[nz+60>>2]=We|0;t[nz+72>>2]=wl|0;t[nz+76>>2]=kl|0;t[zz>>2]=pp|0;t[zz+4>>2]=yv|0;t[zz+8>>2]=er|0;t[zz+12>>2]=no|0;t[Az+8>>2]=Zv|0;t[Az+12>>2]=Ie|0;t[Az+24>>2]=Cf|0;t[Az+28>>2]=bo|0;t[Az+40>>2]=Uf|0;t[Az+44>>2]=Rn|0;t[Az+56>>2]=Hh|0;t[Az+60>>2]=jv|0;t[Bz>>2]=Er|0;t[Cz+8>>2]=Fi|0;t[Cz+12>>2]=Rv|0;t[Cz+24>>2]=hq|0;t[Cz+28>>2]=Th|0;t[Cz+40>>2]=Gw|0;t[Cz+44>>2]=Nh|0;t[Dz>>2]=Ai|0;t[Dz+8>>2]=Uq|0;t[Dz+16>>2]=Tf|0;t[Dz+24>>2]=Ur|0;t[Dz+32>>2]=li|0;t[Dz+40>>2]=Xg|0;t[Dz+48>>2]=$j|0;t[Dz+56>>2]=Fi|0;t[Dz+64>>2]=dx|0;t[Dz+72>>2]=Vg|0;t[Dz+80>>2]=Iv|0;t[Dz+88>>2]=kv|0;t[Dz+96>>2]=Nu|0;t[Dz+104>>2]=ou|0;t[Dz+112>>2]=Qt|0;t[Dz+120>>2]=Zs|0;t[Dz+128>>2]=ti|0;t[Dz+136>>2]=Sv|0;t[Dz+144>>2]=Sf|0;t[Dz+152>>2]=Ir|0;t[Dz+160>>2]=lr|0;t[Dz+168>>2]=ce|0;t[Dz+176>>2]=em|0;t[Dz+184>>2]=Fl|0;t[Dz+192>>2]=hq|0;t[Dz+200>>2]=Gn|0;t[Dz+208>>2]=zp|0;t[Dz+216>>2]=im|0;t[Dz+224>>2]=Zo|0;t[Dz+232>>2]=Ho|0;t[Dz+240>>2]=qo|0;t[Dz+248>>2]=go|0;t[Dz+256>>2]=Yn|0;t[Dz+264>>2]=Mn|0;t[Dz+272>>2]=vm|0;t[Dz+280>>2]=nn|0;t[Dz+288>>2]=Gw|0;t[Dz+296>>2]=sl|0;t[Dz+304>>2]=Sj|0;t[Dz+312>>2]=pm|0;t[Dz+320>>2]=$l|0;t[Dz+328>>2]=Rl|0;t[Dz+336>>2]=gj|0;t[Dz+344>>2]=zl|0;t[Dz+352>>2]=pl|0;t[Dz+360>>2]=el|0;t[Dz+368>>2]=Tk|0;t[Dz+376>>2]=Ik|0;t[Dz+384>>2]=Wm|0;t[Dz+392>>2]=jk|0;t[Dz+400>>2]=Pg|0;t[Dz+408>>2]=Qj|0;t[Dz+416>>2]=Jj|0;t[Dz+424>>2]=If|0;t[Dz+432>>2]=Ol|0;t[Dz+440>>2]=qj|0;t[Dz+448>>2]=rk|0;t[Dz+456>>2]=df|0;t[Dz+464>>2]=Li|0;t[Dz+472>>2]=Fe|0;t[Dz+480>>2]=Vd|0;t[Ez>>2]=Zr|0;t[Ez+4>>2]=tf|0;t[Gz>>2]=ts|0;t[Hz+8>>2]=Fi|0;t[Hz+12>>2]=Rv|0;t[Hz+24>>2]=Le|0;t[Hz+28>>2]=gx|0;t[Hz+40>>2]=Iq|0;t[Hz+44>>2]=Jv|0;t[Iz>>2]=Tu|0;t[Jz+8>>2]=Fi|0;t[Jz+12>>2]=Rv|0;t[Jz+24>>2]=Zv|0;t[Jz+28>>2]=Ie|0;t[Jz+40>>2]=Gv|0;t[Jz+44>>2]=Fv|0;t[Jz+56>>2]=Jo|0;t[Jz+60>>2]=lo|0;t[Jz+72>>2]=eg|0;t[Jz+76>>2]=ds|0;t[Jz+88>>2]=wj|0;t[Jz+92>>2]=Av|0;t[Jz+104>>2]=cq|0;t[Jz+108>>2]=Ju|0;t[Jz+120>>2]=Gw|0;t[Jz+124>>2]=Nf|0;t[Jz+136>>2]=Bw|0;t[Jz+140>>2]=sv|0;t[Jz+152>>2]=wl|0;t[Jz+156>>2]=yu|0;t[Jz+168>>2]=Yl|0;t[Jz+172>>2]=dq|0;t[Jz+184>>2]=uq|0;t[Jz+188>>2]=lu|0;t[Jz+200>>2]=yn|0;t[Jz+204>>2]=fv|0;t[Kz>>2]=Tr|0;t[Kz+4>>2]=Qo|0;t[Kz+8>>2]=xm|0;t[Kz+12>>2]=qk|0;t[Kz+16>>2]=Ei|0;t[Kz+20>>2]=Sl|0;t[Kz+24>>2]=Vk|0;t[Kz+28>>2]=Al|0;t[Kz+32>>2]=mx|0;t[Kz+36>>2]=ql|0;t[Kz+40>>2]=fl|0;t[Pz>>2]=it|0;t[Pz+4>>2]=bw|0;t[Pz+8>>2]=Ar|0;t[Pz+12>>2]=Ao|0;t[Sz>>2]=Rw|0;t[Tz+8>>2]=Fi|0;t[Tz+12>>2]=Rv|0;t[Tz+24>>2]=Zv|0;t[Tz+28>>2]=Ie|0;t[Tz+40>>2]=Gv|0;t[Tz+44>>2]=Fv|0;t[Tz+56>>2]=Cf|0;t[Tz+60>>2]=yf|0;t[Tz+72>>2]=wj|0;t[Tz+76>>2]=Av|0;t[Tz+88>>2]=Gw|0;t[Tz+92>>2]=Nf|0;t[Tz+104>>2]=$p|0;t[Tz+108>>2]=uv|0;t[Tz+120>>2]=wl|0;t[Tz+124>>2]=yu|0;t[Tz+136>>2]=Ww|0;t[Tz+140>>2]=hv|0;t[Tz+152>>2]=uq|0;t[Tz+156>>2]=lu|0;t[Tz+168>>2]=yn|0;t[Tz+172>>2]=fv|0;t[Tz+184>>2]=Fh|0;t[Tz+188>>2]=nt|0;t[Tz+200>>2]=qf|0;t[Tz+204>>2]=kf|0;t[Tz+216>>2]=$u|0;t[Tz+220>>2]=lt|0;t[Wz>>2]=Ge|0;t[Xz+8>>2]=vh|0;t[Xz+12>>2]=oh|0;t[Xz+24>>2]=ag|0;t[Xz+28>>2]=Xe|0;t[Xz+40>>2]=qx|0;t[Xz+44>>2]=Dw|0;t[Xz+56>>2]=Bo|0;t[Xz+60>>2]=tv|0;t[Yz>>2]=ri|0;t[Yz+4>>2]=Pt|0;t[Yz+8>>2]=eq|0;t[Yz+12>>2]=wn|0;t[Zz+8>>2]=Rr|0;t[Zz+12>>2]=Kp|0;t[Zz+24>>2]=Cf|0;t[Zz+28>>2]=bo|0;t[Zz+40>>2]=cm|0;t[Zz+44>>2]=Vo|0;t[Zz+56>>2]=wf|0;t[Zz+60>>2]=Tt|0;t[Zz+72>>2]=qf|0;t[Zz+76>>2]=We|0;t[Zz+88>>2]=wj|0;t[Zz+92>>2]=To|0;t[$z>>2]=Aj|0;t[$z+4>>2]=gu|0;t[$z+8>>2]=tq|0;t[aA+8>>2]=Cf|0;t[aA+12>>2]=bo|0;t[bA>>2]=Dn|0;t[bA+4>>2]=dv|0;t[cA+8>>2]=Rr|0;t[cA+12>>2]=Kp|0;t[cA+24>>2]=Fi|0;t[cA+28>>2]=Rv|0;t[cA+40>>2]=Cf|0;t[cA+44>>2]=bo|0;t[cA+56>>2]=oo|0;t[cA+60>>2]=eo|0;t[cA+72>>2]=qf|0;t[cA+76>>2]=We|0;t[dA>>2]=zm|0;t[dA+4>>2]=lk|0;t[dA+8>>2]=zi|0;t[dA+12>>2]=eh|0;t[eA>>2]=uh|0;t[eA+4>>2]=$s|0;t[eA+8>>2]=qp|0;t[eA+12>>2]=Ro|0;t[fA+8>>2]=zr|0;t[fA+12>>2]=So|0;t[fA+24>>2]=cm|0;t[fA+28>>2]=Vo|0;t[fA+40>>2]=Zv|0;t[fA+44>>2]=Iu|0;t[fA+56>>2]=wf|0;t[fA+60>>2]=Tn|0;t[gA>>2]=af|0;t[gA+8>>2]=vx|0;t[gA+16>>2]=Jw|0;t[gA+24>>2]=Sf|0;t[gA+32>>2]=wv|0;t[gA+40>>2]=Yu|0;t[gA+48>>2]=zu|0;t[gA+56>>2]=cm|0;t[gA+64>>2]=Zv|0;t[gA+72>>2]=Rs|0;t[gA+80>>2]=mg|0;t[gA+88>>2]=ok|0;t[gA+96>>2]=Hh|0;t[gA+104>>2]=rv|0;t[gA+112>>2]=Ad|0;t[gA+120>>2]=uq|0;t[hA>>2]=xx|0;function L(b){return b in{32:0,9:0,10:0,11:0,12:0,13:0}}function mA(b,d){b--;do{b++;var c=l[b];if(c==d){return b}}while(c);return 0}function N(b,d,c){for(var e=0;e<c;){var f=$a[b+e],g=$a[d+e];if(f==g&&0==f){break}if(0==f){return-1}if(0==g){return 1}if(f==g){e++}else{return f>g?1:-1}}return 0}function nA(b){return 97<=b&&122>=b?b-97+65:b}function oA(b){return 48<=b&&57>=b||97<=b&&122>=b||65<=b&&90>=b}function pA(b){return 97<=b&&122>=b||65<=b&&90>=b}function qA(b,d){return N(b,d,Aa)}function rA(b){return 65<=b&&90>=b?b-65+97:b}function sA(b,d,c){for(var e=0;e<c;){var f=rA($a[b+e]),g=rA($a[d+e]);if(f==g&&0==f){break}if(0==f){return-1}if(0==g){return 1}if(f==g){e++}else{return f>g?1:-1}}return 0}function tA(b,d){var c=0,e;do{c||(e=b,c=d);var f=l[b++],g=l[c++];if(0==g){return e}g!=f&&(b=e+1,c=0)}while(f);return 0}var uA=13,vA=9,wA=17,xA=22,yA=5,zA=21,AA=2,BA=6,CA=32,DA=34,EA=29;function FA(b){GA||(GA=y([0],"i32",x));t[GA>>2]=b}var GA,HA=0;Wb=Ob=0;var IA=2,JA=[da],KA=ca;function LA(b,d){if("string"!==typeof b){return da}d===ba&&(d="/");b&&"/"==b[0]&&(d="");for(var c=(d+"/"+b).split("/").reverse(),e=[""];c.length;){var f=c.pop();""==f||"."==f||(".."==f?1<e.length&&e.pop():e.push(f))}return 1==e.length?"/":e.join("/")}function MA(b,d,c){var e={J:fa,s:fa,error:0,name:da,path:da,object:da,v:fa,w:da,o:da},b=LA(b);if("/"==b){e.J=ca,e.s=e.v=ca,e.name="/",e.path=e.w="/",e.object=e.o=NA}else{if(b!==da){for(var c=c||0,b=b.slice(1).split("/"),f=NA,g=[""];b.length;){1==b.length&&f.d&&(e.v=ca,e.w=1==g.length?"/":g.join("/"),e.o=f,e.name=b[0]);var h=b.shift();if(f.d){if(f.q){if(!f.a.hasOwnProperty(h)){e.error=AA;break}}else{e.error=uA;break}}else{e.error=20;break}f=f.a[h];if(f.link&&!(d&&0==b.length)){if(40<c){e.error=40;break}e=LA(f.link,g.join("/"));e=MA([e].concat(b).join("/"),d,c+1);break}g.push(h);0==b.length&&(e.s=ca,e.path=g.join("/"),e.object=f)}}}return e}function OA(b,d){PA();var c=MA(b,d);if(c.s){return c.object}FA(c.error);return da}function QA(b,d,c,e,f){b||(b="/");"string"===typeof b&&(b=OA(b));b||(FA(uA),aa(Error("Parent path must exist.")));b.d||(FA(20),aa(Error("Parent must be a folder.")));!b.write&&!KA&&(FA(uA),aa(Error("Parent folder must be writeable.")));if(!d||"."==d||".."==d){FA(AA),aa(Error("Name must not be empty."))}
b.a[d]={q:e===ba?ca:e,write:f===ba?fa:f,timestamp:Date.now(),u:IA++};for(var g in c){c.hasOwnProperty(g)&&(b.a[d][g]=c[g])}return b.a[d]}function RA(b,d,c,e){return QA(b,d,{d:ca,b:fa,a:{}},c,e)}function SA(b,d,c,e){b=OA(b);b===da&&aa(Error("Invalid parent."));for(d=d.split("/").reverse();d.length;){var f=d.pop();f&&(b.a.hasOwnProperty(f)||RA(b,f,c,e),b=b.a[f])}return b}function TA(b,d,c,e,f){c.d=fa;return QA(b,d,c,e,f)}function UA(b,d,c,e,f){if("string"===typeof c){for(var g=Array(c.length),h=0,i=c.length;h<i;++h){g[h]=c.charCodeAt(h)}c=g}c={b:fa,a:c.subarray?c.subarray(0):c};return TA(b,d,c,e,f)}function VA(b,d,c,e,f,g,h,i){function m(b){return{jpg:"image/jpeg",png:"image/png",bmp:"image/bmp",ogg:"audio/ogg",wav:"audio/wav",mp3:"audio/mpeg"}[b.substr(-3)]}function n(c){function m(c){i||UA(b,d,c,e,f);g&&g();Gb("cp "+p)}var n=fa;a.preloadPlugins.forEach((function(b){!n&&b.canHandle(p)&&(b.handle(c,p,m,(function(){h&&h();Gb("cp "+p)})),n=ca)}));n||m(c)}if(!WA){WA=ca;try{new Blob,XA=ca}catch(q){XA=fa,console.log("warning: no blob constructor, cannot create blobs with mimetypes")}YA="undefined"!=typeof MozBlobBuilder?MozBlobBuilder:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:!XA?console.log("warning: no BlobBuilder"):da;ZA="undefined"!=typeof window?window.URL?window.URL:window.webkitURL:console.log("warning: cannot create object URLs");a.preloadPlugins||(a.preloadPlugins=[]);a.preloadPlugins.push({canHandle:(function(b){return b.substr(-4)in{".jpg":1,".png":1,".bmp":1}}),handle:(function(b,c,d,e){var f=da;if(XA){try{f=new Blob([b],{type:m(c)})}catch(g){var h="Blob constructor present but fails: "+g+"; falling back to blob builder";va||(va={});va[h]||(va[h]=1,a.h(h))}}f||(f=new YA,f.append((new Uint8Array(b)).buffer),f=f.getBlob());var i=ZA.createObjectURL(f);ua("string"==typeof i,"createObjectURL must return a url as a string");var n=new Image;n.onload=(function(){ua(n.complete,"Image "+c+" could not be decoded");var e=document.createElement("canvas");e.width=n.width;e.height=n.height;e.getContext("2d").drawImage(n,0,0);a.preloadedImages[c]=e;ZA.revokeObjectURL(i);d&&d(b)});n.onerror=(function(){console.log("Image "+i+" could not be decoded");e&&e()});n.src=i})});a.preloadPlugins.push({canHandle:(function(b){return b.substr(-4)in{".ogg":1,".wav":1,".mp3":1}}),handle:(function(b,c,d,e){function f(e){h||(h=ca,a.preloadedAudios[c]=e,d&&d(b))}function g(){h||(h=ca,a.preloadedAudios[c]=new Audio,e&&e())}var h=fa;if(XA){try{var i=new Blob([b],{type:m(c)})}catch(n){return g()}i=ZA.createObjectURL(i);ua("string"==typeof i,"createObjectURL must return a url as a string");var p=new Audio;p.addEventListener("canplaythrough",(function(){f(p)}),fa);p.onerror=(function(){if(!h){console.log("warning: browser could not fully decode audio "+c+", trying slower base64 approach");for(var d="",e=0,g=0,i=0;i<b.length;i++){e=e<<8|b[i];for(g+=8;6<=g;){var m=e>>g-6&63,g=g-6,d=d+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[m]}}2==g?(d+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(e&3)<<4],d+="=="):4==g&&(d+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(e&15)<<2],d+="=");p.src="data:audio/x-"+c.substr(-3)+";base64,"+d;f(p)}});p.src=i;setTimeout((function(){f(p)}),1e4)}else{return g()}})})}for(var p,s=[b,d],r=s[0],u=1;u<s.length;u++){"/"!=r[r.length-1]&&(r+="/"),r+=s[u]}"/"==r[0]&&(r=r.substr(1));p=r;Cb("cp "+p);if("string"==typeof c){var v=h,w=(function(){v?v():aa('Loading data file "'+c+'" failed.')}),C=new XMLHttpRequest;C.open("GET",c,ca);C.responseType="arraybuffer";C.onload=(function(){if(200==C.status){var b=C.response;ua(b,'Loading data file "'+c+'" failed (no arrayBuffer).');b=new Uint8Array(b);n(b);Gb("al "+c)}else{w()}});C.onerror=w;C.send(da);Cb("al "+c)}else{n(c)}}function $A(b,d,c,e){!c&&!e&&aa(Error("A device must have at least one callback defined."));return TA(b,d,{b:ca,input:c,k:e},Boolean(c),Boolean(e))}function aB(b){if(b.b||b.d||b.link||b.a){return ca}var d=ca;"undefined"!==typeof XMLHttpRequest&&aa(Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."));if(a.read){try{b.a=lb(a.read(b.url),ca)}catch(c){d=fa}}else{aa(Error("Cannot load without read() or XMLHttpRequest."))}d||FA(yA);return d}function PA(){NA||(NA={q:ca,write:ca,d:ca,b:fa,timestamp:Date.now(),u:1,a:{}})}var bB,NA;function cB(b){return Number(JA[b]&&JA[b].c)}function dB(b,d){aa({f:ca,id:t[b>>2],value:d||1})}function eB(b,d){function c(b){var c;"double"===b?c=(Ua[0]=t[d+f>>2],Ua[1]=t[d+(f+4)>>2],Ta[0]):"i64"==b?c=[t[d+f>>2],t[d+(f+4)>>2]]:(b="i32",c=t[d+f>>2]);f+=Math.max(sa(b),ta);return c}for(var e=b,f=0,g=[],h,i;;){var m=e;h=l[e];if(0===h){break}i=l[e+1];if(37==h){var n=fa,q=fa,p=fa,s=fa;a:for(;;){switch(i){case 43:n=ca;break;case 45:q=ca;break;case 35:p=ca;break;case 48:if(s){break a}else{s=ca;break};default:break a}e++;i=l[e+1]}var r=0;if(42==i){r=c("i32"),e++,i=l[e+1]}else{for(;48<=i&&57>=i;){r=10*r+(i-48),e++,i=l[e+1]}}var u=fa;if(46==i){var v=0,u=ca;e++;i=l[e+1];if(42==i){v=c("i32"),e++}else{for(;;){i=l[e+1];if(48>i||57<i){break}v=10*v+(i-48);e++}}i=l[e+1]}else{v=6}var w;switch(String.fromCharCode(i)){case"h":i=l[e+2];104==i?(e++,w=1):w=2;break;case"l":i=l[e+2];108==i?(e++,w=8):w=4;break;case"L":;case"q":;case"j":w=8;break;case"z":;case"t":;case"I":w=4;break;default:w=da}w&&e++;i=l[e+1];if(-1!="diuoxXp".split("").indexOf(String.fromCharCode(i))){m=100==i||105==i;w=w||4;var C=h=c("i"+8*w),A;8==w&&(h=117==i?(h[0]>>>0)+4294967296*(h[1]>>>0):(h[0]>>>0)+4294967296*(h[1]|0));4>=w&&(h=(m?vb:ub)(h&Math.pow(256,w)-1,8*w));var I=Math.abs(h),m="";if(100==i||105==i){A=8==w&&fB?fB.stringify(C[0],C[1],da):vb(h,8*w).toString(10)}else{if(117==i){A=8==w&&fB?fB.stringify(C[0],C[1],ca):ub(h,8*w).toString(10),h=Math.abs(h)}else{if(111==i){A=(p?"0":"")+I.toString(8)}else{if(120==i||88==i){m=p?"0x":"";if(8==w&&fB){A=(C[1]>>>0).toString(16)+(C[0]>>>0).toString(16)}else{if(0>h){h=-h;A=(I-1).toString(16);C=[];for(p=0;p<A.length;p++){C.push((15-parseInt(A[p],16)).toString(16))}for(A=C.join("");A.length<2*w;){A="f"+A}}else{A=I.toString(16)}}88==i&&(m=m.toUpperCase(),A=A.toUpperCase())}else{112==i&&(0===I?A="(nil)":(m="0x",A=I.toString(16)))}}}}if(u){for(;A.length<v;){A="0"+A}}for(n&&(m=0>h?"-"+m:"+"+m);m.length+A.length<r;){q?A+=" ":s?A="0"+A:m=" "+m}A=m+A;A.split("").forEach((function(b){g.push(b.charCodeAt(0))}))}else{if(-1!="fFeEgG".split("").indexOf(String.fromCharCode(i))){h=c("double");if(isNaN(h)){A="nan",s=fa}else{if(isFinite(h)){u=fa;w=Math.min(v,20);if(103==i||71==i){u=ca,v=v||1,w=parseInt(h.toExponential(w).split("e")[1],10),v>w&&-4<=w?(i=(103==i?"f":"F").charCodeAt(0),v-=w+1):(i=(103==i?"e":"E").charCodeAt(0),v--),w=Math.min(v,20)}if(101==i||69==i){A=h.toExponential(w),/[eE][-+]\d$/.test(A)&&(A=A.slice(0,-1)+"0"+A.slice(-1))}else{if(102==i||70==i){A=h.toFixed(w)}}m=A.split("e");if(u&&!p){for(;1<m[0].length&&-1!=m[0].indexOf(".")&&("0"==m[0].slice(-1)||"."==m[0].slice(-1));){m[0]=m[0].slice(0,-1)}}else{for(p&&-1==A.indexOf(".")&&(m[0]+=".");v>w++;){m[0]+="0"}}A=m[0]+(1<m.length?"e"+m[1]:"");69==i&&(A=A.toUpperCase());n&&0<=h&&(A="+"+A)}else{A=(0>h?"-":"")+"inf",s=fa}}for(;A.length<r;){A=q?A+" ":s&&("-"==A[0]||"+"==A[0])?A[0]+"0"+A.slice(1):(s?"0":" ")+A}97>i&&(A=A.toUpperCase());A.split("").forEach((function(b){g.push(b.charCodeAt(0))}))}else{if(115==i){n=c("i8*")||mb;s=tb(n);u&&(s=Math.min(s,v));if(!q){for(;s<r--;){g.push(32)}}for(p=0;p<s;p++){g.push($a[n++])}if(q){for(;s<r--;){g.push(32)}}}else{if(99==i){for(q&&g.push(c("i8"));0<--r;){g.push(32)}q||g.push(c("i8"))}else{if(110==i){q=c("i32*"),t[q>>2]=g.length}else{if(37==i){g.push(h)}else{for(p=m;p<e+2;p++){g.push(l[p])}}}}}}}e+=2}else{g.push(h),e+=1}}return g}function gB(b,d){var c=b+tb(b);do{if(l[c]==d){return c}c--}while(c>=b);return 0}function hB(b,d,c){if(20<=c&&d%2==b%2){if(d%4==b%4){for(c=d+c;d%4;){l[b++]=l[d++]}for(var d=d>>2,b=b>>2,e=c>>2;d<e;){t[b++]=t[d++]}d<<=2;for(b<<=2;d<c;){l[b++]=l[d++]}}else{c=d+c;d%2&&(l[b++]=l[d++]);d>>=1;b>>=1;for(e=c>>1;d<e;){Pa[b++]=Pa[d++]}d<<=1;b<<=1;d<c&&(l[b++]=l[d++])}}else{for(;c--;){l[b++]=l[d++]}}}function iB(b,d,c){for(var e=fa,f,g=0;g<c;g++){f=e?0:l[d+g],l[b+g]=f,e=e||0==l[d+g]}}function jB(b){var d=tb(b),c=Xa(d+1);hB(c,b,d);l[c+d]=0;return c}function kB(b,d,c){var e=JA[b];if(e){if(e.j){if(0>c){return FA(xA),-1}if(e.object.b){if(e.object.k){for(var f=0;f<c;f++){try{e.object.k(l[d+f])}catch(g){return FA(yA),-1}}e.object.timestamp=Date.now();return f}FA(BA);return-1}f=e.position;b=JA[b];if(!b||b.object.b){FA(vA),d=-1}else{if(b.j){if(b.object.d){FA(zA),d=-1}else{if(0>c||0>f){FA(xA),d=-1}else{for(var h=b.object.a;h.length<f;){h.push(0)}for(var i=0;i<c;i++){h[f+i]=$a[d+i]}b.object.timestamp=Date.now();d=i}}}else{FA(uA),d=-1}}-1!=d&&(e.position+=d);return d}FA(uA);return-1}FA(vA);return-1}function lB(b,d,c){var e=eB(d,c),d=j;c=y(e,"i8",Va);e=1*e.length;0==e?b=0:(c=kB(b,c,e),-1==c?(JA[b]&&(JA[b].error=ca),b=0):b=Math.floor(c/1));j=d;return b}function mB(b,d){return lB(t[Ob>>2],b,d)}function nB(b,d){JA[b]?(b=JA[b],b.object.b?FA(EA):(t[d>>2]=b.position,t[d+4>>2]=(b.c?1:0)+(b.error?2:0))):FA(vA)}function oB(b,d){if(JA[b]){if(JA[b].object.b){FA(CA)}else{JA[b].position=t[d>>2];var c=t[d+4>>2];JA[b].c=Boolean(c&1);JA[b].error=Boolean(c&2)}}else{FA(vA)}}function pB(b,d){var c=ub(b&255);l[pB.l]=c;return-1==kB(d,pB.l,1)?(JA[d]&&(JA[d].error=ca),-1):c}var qB=pB,rB=da;function sB(b,d){var c=y([511,0,0,0],"i32",Va),e=t[c>>2],c=d&3,f=0!=c,g=1!=c,h=Boolean(d&512),i=Boolean(d&2048),m=Boolean(d&1024),n=Boolean(d&8),b=MA(Na(b));if(!b.v){return FA(b.error),-1}if(c=b.object||da){if(h&&i){return FA(wA),-1}if((f||h||m)&&c.d){return FA(zA),-1}if(g&&!c.q||f&&!c.write){return FA(uA),-1}if(m&&!c.b){c.a=[]}else{if(!aB(c)){return FA(yA),-1}}e=b.path}else{if(!h){return FA(AA),-1}if(!b.o.write){return FA(uA),-1}c=UA(b.o,b.name,[],e&256,e&128);e=b.w+"/"+b.name}h=JA.length;if(c.d){f=0;rB&&(f=Xa(rB.R));var g=[],q;for(q in c.a){g.push(q)}JA[h]={path:e,object:c,position:-2,i:ca,j:fa,n:fa,error:fa,c:fa,e:[],a:g,A:f}}else{JA[h]={path:e,object:c,position:0,i:g,j:f,n:n,error:fa,c:fa,e:[]}}return h}function tB(b,d){var c,d=Na(d);if("r"==d[0]){c=-1!=d.indexOf("+")?2:0}else{if("w"==d[0]){c=-1!=d.indexOf("+")?2:1,c|=1536}else{if("a"==d[0]){c=-1!=d.indexOf("+")?2:1,c|=512,c|=8}else{return FA(xA),0}}}c=sB(b,c);return-1==c?0:c}function uB(b){JA[b]||FA(vA);JA[b]?(JA[b].A&&vB(JA[b].A),JA[b]=da):FA(vA)}var wB=mB;function Ya(b,d){var c=0;if(20<=d){for(var e=b+d;b%4;){l[b++]=c}0>c&&(c+=256);for(var f=b>>2,g=e>>2,h=c|c<<8|c<<16|c<<24;f<g;){t[f++]=h}for(b=f<<2;b<e;){l[b++]=c}}else{for(;d--;){l[b++]=c}}}var xB=lB,yB={1:"Operation not permitted",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"Input/output error",6:"No such device or address",8:"Exec format error",9:"Bad file descriptor",10:"No child processes",11:"Resource temporarily unavailable",12:"Cannot allocate memory",13:"Permission denied",14:"Bad address",16:"Device or resource busy",17:"File exists",18:"Invalid cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Inappropriate ioctl for device",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read-only file system",31:"Too many links",32:"Broken pipe",33:"Numerical argument out of domain",34:"Numerical result out of range",35:"Resource deadlock avoided",36:"File name too long",37:"No locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many levels of symbolic links",42:"No message of desired type",43:"Identifier removed",60:"Device not a stream",61:"No data available",62:"Timer expired",63:"Out of streams resources",67:"Link has been severed",71:"Protocol error",72:"Multihop attempted",74:"Bad message",75:"Value too large for defined data type",84:"Invalid or incomplete multibyte or wide character",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Protocol not supported",95:"Operation not supported",97:"Address family not supported by protocol",98:"Address already in use",99:"Cannot assign requested address",100:"Network is down",101:"Network is unreachable",102:"Network dropped connection on reset",103:"Software caused connection abort",104:"Connection reset by peer",105:"No buffer space available",106:"Transport endpoint is already connected",107:"Transport endpoint is not connected",110:"Connection timed out",111:"Connection refused",113:"No route to host",114:"Operation already in progress",115:"Operation now in progress",116:"Stale NFS file handle",122:"Disk quota exceeded",125:"Operation canceled",130:"Owner died",131:"State not recoverable"},zB;function AB(b,d){var c=0;do{l[b+c]=l[d+c],c++}while(0!=l[d+(c-1)])}var BB=0,CB=4,DB=8,EB=12,FB=16,GB=20,HB=24,IB=28,JB=32,KB=40,LB=48,MB=56,NB=60,OB={};function PB(b,d,c){b=OA(Na(b),c);if(b===da||!aB(b)){return-1}t[d+EB>>2]=1;t[d+FB>>2]=0;t[d+GB>>2]=0;t[d+MB>>2]=4096;t[d+CB>>2]=b.u;c=Math.floor(b.timestamp/1e3);if(JB===ba){JB=OB.O.F;KB=OB.Q.F;LB=OB.P.F;var e=1e3*(b.timestamp%1e3);t[d+OB.O.D>>2]=e;t[d+OB.Q.D>>2]=e;t[d+OB.P.D>>2]=e}t[d+JB>>2]=c;t[d+KB>>2]=c;t[d+LB>>2]=c;var f=0,g=c=0,h=e=0;b.b?(e=h=b.u,c=g=0,f=8192):(e=1,h=0,b.d?(c=4096,g=1,f=16384):(f=b.a||b.link,c=f.length,g=Math.ceil(f.length/4096),f=b.link===ba?32768:40960));t[d+BB>>2]=e;t[d+HB>>2]=h;t[d+IB>>2]=c;t[d+NB>>2]=g;b.q&&(f|=365);b.write&&(f|=146);t[d+DB>>2]=f;return 0}var QB=da,RB=da,SB={};function TB(b){for(var d="",c=0,e;e=$a[b+c];){d+=String.fromCharCode(e),c++}return d}function UB(b,d,c,e){var f=JA[b];if(!f||f.object.b){return FA(vA),-1}if(f.i){if(f.object.d){return FA(zA),-1}if(0>c||0>e){return FA(xA),-1}for(b=0;f.e.length&&0<c;){l[d++]=f.e.pop(),c--,b++}f=f.object.a;c=Math.min(f.length-e,c);if(f.subarray||f.slice){for(var g=0;g<c;g++){l[d+g]=f[e+g]}}else{for(g=0;g<c;g++){l[d+g]=f.get(e+g)}}return b+c}FA(uA);return-1}function VB(b){var d=WB.l,c=1,e=JA[b];if(e){if(e.i){if(0>c){return FA(xA),-1}if(e.object.b){if(e.object.input){for(b=0;e.e.length&&0<c;){l[d++]=e.e.pop(),c--,b++}for(var f=0;f<c;f++){try{var g=e.object.input()}catch(h){return FA(yA),-1}if(g===da||g===ba){break}b++;l[d+f]=g}return b}FA(BA);return-1}g=e.e.length;b=UB(b,d,c,e.position);-1!=b&&(e.position+=e.e.length-g+b);return b}FA(uA);return-1}FA(vA);return-1}function WB(b){if(!JA[b]){return-1}var d=JA[b];if(d.c||d.error){return-1}b=VB(b);return 0==b?(d.c=ca,-1):-1==b?(d.error=ca,-1):$a[WB.l]}var XB=WB;function YB(b){var d=t[K+16>>2];JA[d]&&(b=ub(b&255),JA[d].e.push(b))}function O(){aa("abort() at "+Error().stack)}function ZB(){switch(8){case 8:return cb;case 54:;case 56:;case 21:;case 61:;case 63:;case 22:;case 67:;case 23:;case 24:;case 25:;case 26:;case 27:;case 69:;case 28:;case 101:;case 70:;case 71:;case 29:;case 30:;case 199:;case 75:;case 76:;case 32:;case 43:;case 44:;case 80:;case 46:;case 47:;case 45:;case 48:;case 49:;case 42:;case 82:;case 33:;case 7:;case 108:;case 109:;case 107:;case 112:;case 119:;case 121:return 200809;case 13:;case 104:;case 94:;case 95:;case 34:;case 35:;case 77:;case 81:;case 83:;case 84:;case 85:;case 86:;case 87:;case 88:;case 89:;case 90:;case 91:;case 94:;case 95:;case 110:;case 111:;case 113:;case 114:;case 115:;case 116:;case 117:;case 118:;case 120:;case 40:;case 16:;case 79:;case 19:return-1;case 92:;case 93:;case 5:;case 72:;case 6:;case 74:;case 92:;case 93:;case 96:;case 97:;case 98:;case 99:;case 102:;case 103:;case 105:return 1;case 38:;case 66:;case 50:;case 51:;case 4:return 1024;case 15:;case 64:;case 41:return 32;case 55:;case 37:;case 17:return 2147483647;case 18:;case 1:return 47839;case 59:;case 57:return 99;case 68:;case 58:return 2048;case 0:return 2097152;case 3:return 65536;case 14:return 32768;case 73:return 32767;case 39:return 16384;case 60:return 1e3;case 106:return 700;case 52:return 256;case 62:return 255;case 2:return 100;case 65:return 64;case 36:return 20;case 100:return 16;case 20:return 6;case 53:return 4}FA(xA);return-1}function $B(b){aC||(za=za+4095>>12<<12,aC=ca);var d=za;0!=b&&ya(b);return d}var aC;function bC(b,d,c){for(var d=ub(d),e=0;e<c;e++){if(l[b]==d){return b}b++}return 0}var cC=fa,WA,XA,YA,ZA;pb.unshift({t:(function(){if(!a.noFSInit&&!bB){var b,d,c,e=(function(b){b===da||10===b?(d.p(d.buffer.join("")),d.buffer=[]):d.buffer.push(i.C(b))});ua(!bB,"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");bB=ca;PA();b=b||a.stdin;d=d||a.stdout;c=c||a.stderr;var f=ca,g=ca,h=ca;b||(f=fa,b=(function(){if(!b.r||!b.r.length){var c;"undefined"!=typeof window&&"function"==typeof window.prompt?(c=window.prompt("Input: "),c===da&&(c=String.fromCharCode(0))):"function"==typeof readline&&(c=readline());c||(c="");b.r=lb(c+"\n",ca)}return b.r.shift()}));var i=new wa;d||(g=fa,d=e);d.p||(d.p=a.print);d.buffer||(d.buffer=[]);c||(h=fa,c=e);c.p||(c.p=a.print);c.buffer||(c.buffer=[]);try{RA("/","tmp",ca,ca)}catch(m){}var e=RA("/","dev",ca,ca),n=$A(e,"stdin",b),q=$A(e,"stdout",da,d);c=$A(e,"stderr",da,c);$A(e,"tty",b,d);JA[1]={path:"/dev/stdin",object:n,position:0,i:ca,j:fa,n:fa,B:!f,error:fa,c:fa,e:[]};JA[2]={path:"/dev/stdout",object:q,position:0,i:fa,j:ca,n:fa,B:!g,error:fa,c:fa,e:[]};JA[3]={path:"/dev/stderr",object:c,position:0,i:fa,j:ca,n:fa,B:!h,error:fa,c:fa,e:[]};HA=y([1],"void*",Va);Ob=y([2],"void*",Va);Wb=y([3],"void*",Va);SA("/","dev/shm/tmp",ca,ca);for(f=JA.length;f<Math.max(HA,Ob,Wb)+4;f++){JA[f]=da}JA[HA]=JA[1];JA[Ob]=JA[2];JA[Wb]=JA[3];y([y([0,0,0,0,HA,0,0,0,Ob,0,0,0,Wb,0,0,0],"void*",x)],"void*",x)}})});qb.push({t:(function(){KA=fa})});rb.push({t:(function(){bB&&(JA[2]&&0<JA[2].object.k.buffer.length&&JA[2].object.k(10),JA[3]&&0<JA[3].object.k.buffer.length&&JA[3].object.k(10))})});a.FS_createFolder=RA;a.FS_createPath=SA;a.FS_createDataFile=UA;a.FS_createPreloadedFile=VA;a.FS_createLazyFile=(function(b,d,c,e,f){if("undefined"!==typeof XMLHttpRequest){ma||aa("Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc");var g=(function(b,c){this.length=c;this.z=b;this.m=[]});g.prototype.get=(function(b){if(!(b>this.length-1||0>b)){var c=b%n;return this.I(Math.floor(b/n))[c]}});g.prototype.N=(function(b){this.I=b});var h=new XMLHttpRequest;h.open("HEAD",c,fa);h.send(da);200<=h.status&&300>h.status||304===h.status||aa(Error("Couldn't load "+c+". Status: "+h.status));var i=Number(h.getResponseHeader("Content-length")),m,n=1048576;if(!((m=h.getResponseHeader("Accept-Ranges"))&&"bytes"===m)){n=i}var q=new g(n,i);q.N((function(b){var d=b*q.z,e=(b+1)*q.z-1,e=Math.min(e,i-1);if("undefined"===typeof q.m[b]){var f=q.m;d>e&&aa(Error("invalid range ("+d+", "+e+") or no bytes requested!"));e>i-1&&aa(Error("only "+i+" bytes available! programmer error!"));var g=new XMLHttpRequest;g.open("GET",c,fa);i!==n&&g.setRequestHeader("Range","bytes="+d+"-"+e);"undefined"!=typeof Uint8Array&&(g.responseType="arraybuffer");g.overrideMimeType&&g.overrideMimeType("text/plain; charset=x-user-defined");g.send(da);200<=g.status&&300>g.status||304===g.status||aa(Error("Couldn't load "+c+". Status: "+g.status));d=g.response!==ba?new Uint8Array(g.response||[]):lb(g.responseText||"",ca);f[b]=d}"undefined"===typeof q.m[b]&&aa(Error("doXHR failed!"));return q.m[b]}));g={b:fa,a:q}}else{g={b:fa,url:c}}return TA(b,d,g,e,f)});a.FS_createLink=(function(b,d,c,e,f){return TA(b,d,{b:fa,link:c},e,f)});a.FS_createDevice=$A;FA(0);pB.l=y([0],"i8",x);a.CTags_getLanguage=(function(b){b=y(lb(b),"i8",Va);b=a._getLanguage(b);return Na(b)});a.CTags_parseFile=(function(b){a.FS_createPath("/",b.substr(0,b.lastIndexOf("/")),ca,ca);b=y(lb(b),"i8",Va);a._parseURL(b)});a.CTags_setOnParsingCompleted=(function(b){RB=b});a.CTags_setOnTagEntry=(function(b){QB=b});WB.l=y([0],"i8",x);a.requestFullScreen=(function(){function b(){}function d(){var b=fa;if((document.webkitFullScreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.mozFullscreenElement||document.fullScreenElement||document.fullscreenElement)===c){c.M=c.requestPointerLock||c.mozRequestPointerLock||c.webkitRequestPointerLock,c.M(),b=ca}if(a.onFullScreen){a.onFullScreen(b)}}var c=a.canvas;document.addEventListener("fullscreenchange",d,fa);document.addEventListener("mozfullscreenchange",d,fa);document.addEventListener("webkitfullscreenchange",d,fa);document.addEventListener("pointerlockchange",b,fa);document.addEventListener("mozpointerlockchange",b,fa);document.addEventListener("webkitpointerlockchange",b,fa);c.L=c.requestFullScreen||c.mozRequestFullScreen||(c.webkitRequestFullScreen?(function(){c.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT)}):da);c.L()});a.requestAnimationFrame=(function(b){window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||window.oRequestAnimationFrame||window.setTimeout);window.requestAnimationFrame(b)});a.pauseMainLoop=(function(){});a.resumeMainLoop=(function(){cC&&(cC=fa,da())});function dC(){var b=P(),d=P(),c=eC();if(0!=(c|0)){for(var e=b|0,f=0,g=c;;){var c=0==(L(l[g]&255)|0)&1,h=l[g],h=0==h<<24>>24?1:0==(bC(Dq|0,h&255,4)|0),i=0==(N(g,oq|0,2)|0),m=i?1:f,i=i?g+2|0:g,n=0==(m|0);a:do{if(n){g=i}else{for(f=i;0!=(N(f,Wp|0,2)|0);){if(f=f+1|0,0==l[f]<<24>>24){g=f;f=m;break a}}g=f+2|0}f=0}while(0);h&=0==(f|0);a:do{if(h){if(i=l[g],35==i<<24>>24){fC(g+1|0)}else{for(m=g;;){n=m+1|0;if(0==(L(i&255)|0)){break}m=n;i=l[n]}i=gC(m,b);0==(t[e>>2]|0)?m=c:(m=(n=58==l[i]<<24>>24)?1:c,i=n?i+1|0:i);do{if(0==(L(l[i]&255)|0)){if(0==l[i]<<24>>24){n=i}else{break a}}else{n=i}}while(0);for(;0!=(L(l[n]&255)|0);){n=n+1|0}i=hC(n,d);if(0==(t[e>>2]|0)){for(;0!=(L(l[i]&255)|0);){i=i+1|0}gC(i,b);var q=1}else{q=0}var i=b,n=d,p=j;j+=4;if(0!=(t[i>>2]|0)){var s=iC(n,p);0!=(t[p>>2]|0)?-1!=(s|0)&&jC(i,fA|0,s):0!=((0==(t[n>>2]|0)?0:68!=(nA(l[t[n+8>>2]]&255)|0)?0:2==(t[n>>2]|0)?1:4==(t[n>>2]|0)?46==l[t[n+8>>2]+2|0]<<24>>24:5!=(t[n>>2]|0)?0:46==l[t[n+8>>2]+3|0]<<24>>24)&1|0)?0==(q|0)&&jC(i,fA|0,0):0!=(m|0)&&(iC(i,p),0==(t[p>>2]|0)&&jC(i,fA|0,1))}j=p}}}while(0);c=eC();if(0==(c|0)){break}else{g=c}}}Q(b);Q(d)}dC.X=1;function fC(b){var d,c,e=P(),f=0==(kC(l[b]&255)|0);c=(e|0)>>2;var g=t[c];d=(e+4|0)>>2;var h=(g+1|0)==(t[d]|0);a:do{if(f){var i=b,m=h,n=g}else{for(var q=e+8|0,p=b,s=h,r=g;;){if(s&&(R(e),r=t[c]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[d]|0),0==(kC(l[p]&255)|0)){i=p;m=s;n=r;break a}}}}while(0);m?(R(e),f=t[c]):f=n;b=(e+8|0)>>2;l[t[b]+f|0]=0;if(0==(qA(t[b],zr|0)|0)){for(;0!=(L(l[i]&255)|0);){i=i+1|0}S(e);f=0==(kC(l[i]&255)|0);g=t[c];h=(g+1|0)==(t[d]|0);a:do{if(f){var u=h,v=g}else{m=i;q=h;for(n=g;;){if(q&&(R(e),n=t[c]),l[t[b]+n|0]=l[m],0!=l[m]<<24>>24&&(n=t[c]+1|0,t[c]=n,l[t[b]+n|0]=0),m=m+1|0,n=t[c],q=(n+1|0)==(t[d]|0),0==(kC(l[m]&255)|0)){u=q;v=n;break a}}}}while(0);u?(R(e),d=t[c]):d=v;l[t[b]+d|0]=0;jC(e,fA|0,0)}Q(e)}fC.X=1;function gC(b,d){var c;S(d);if(0==((0==(l[b]&255|0)?0:0!=(pA(l[b]&255)|0)?1:0!=(bC(lp|0,l[b]&255,3)|0))&1|0)){return b}var e=0==(kC(l[b]&255)|0);c=(d|0)>>2;var f=t[c],g=d+4|0,h=(f+1|0)==(t[g>>2]|0);a:do{if(e){var i=b,m=h,n=f}else{for(var q=d+8|0,p=b,s=h,r=f;;){if(s&&(R(d),r=t[c]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[g>>2]|0),0==(kC(l[p]&255)|0)){i=p;m=s;n=r;break a}}}}while(0);m?(R(d),c=t[c]):c=n;l[t[d+8>>2]+c|0]=0;return i}gC.X=1;function hC(b,d){var c,e,f;S(d);e=(d|0)>>2;var g=d+4|0;c=(d+8|0)>>2;for(var h=b;;){var i=l[h];if(0==i<<24>>24){f=74;break}var m=t[e],n=(m+1|0)==(t[g>>2]|0);if(0!=(L(i&255)|0)){f=81;break}n?(R(d),i=t[e]):i=m;l[t[c]+i|0]=l[h];0!=l[h]<<24>>24&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);h=h+1|0}if(81==f){if(n){f=82}else{var q=m}}else{74==f&&(m=t[e],(m+1|0)==(t[g>>2]|0)?f=82:q=m)}82==f&&(R(d),q=t[e]);l[t[c]+q|0]=0;return h}hC.X=1;function iC(b,d){var c=P();lC(c,t[b>>2],t[b+4>>2],t[b+8>>2]);var e=mC(t[c+8>>2],t[Sy>>2]);Q(c);c=-1!=(e|0);t[d>>2]=c&1;return!c?-1:e=t[py+(e<<3)+4>>2]}function kC(b){return(0==(b|0)?0:0!=(oA(b)|0)?1:0!=(bC(Gp|0,b,4)|0))&1}function nC(){var b,d,c,e,f=P(),g=eC();if(0!=(g|0)){c=(f|0)>>2;d=(f+4|0)>>2;b=(f+8|0)>>2;var h=g;a:for(;;){var i=l[h];do{if(0!=i<<24>>24){for(var m=h,n=i;;){var q=m+1|0;if(0==(L(n&255)|0)){break}m=q;n=l[q]}var p=l[m];if(34==p<<24>>24){for(var s=m;;){var r=s+1|0,u=l[r];if(34==u<<24>>24||0==u<<24>>24){h=r;continue a}else{s=r}}}else{if(39==p<<24>>24){break}}if(0==(sA(m,Sf|0,3)|0)){var v=m+3|0;if(0==(L(l[v]&255)|0)){h=v;continue a}else{var w=v}for(;0!=(L(l[w]&255)|0);){w=w+1|0}if(0==(sA(w,Cf|0,8)|0)){break}if(0==(sA(w,nf|0,3)|0)){break}else{h=w;continue a}}if(0==(sA(m,Ep|0,4)|0)){var C=m+4|0;if(0==(L(l[C]&255)|0)){h=C;continue a}else{var A=C}for(;0!=(L(l[A]&255)|0);){A=A+1|0}if(0==(sA(A,Cf|0,8)|0)){break}if(0==(sA(A,nf|0,3)|0)){break}else{h=A;continue a}}if(0==(sA(m,Yf|0,6)|0)){var I=m+6|0;if(0==(L(l[I]&255)|0)){h=I;continue a}else{var M=I}for(;0!=(L(l[M]&255)|0);){M=M+1|0}if(0==(sA(M,Cf|0,8)|0)){for(var B=M+8|0;;){if(0==(L(l[B]&255)|0)){var G=B;break}else{B=B+1|0}}b:for(;;){do{if(0==(oA(l[G]&255)|0)){var Z=t[c],X=(Z+1|0)==(t[d]|0);if(95!=l[G]<<24>>24){break b}if(X){e=145}else{var ga=Z}}else{var ra=t[c];(ra+1|0)==(t[d]|0)?e=145:ga=ra}}while(0);145==e&&(e=0,R(f),ga=t[c]);l[t[b]+ga|0]=l[G];if(0!=l[G]<<24>>24){var ka=t[c]+1|0;t[c]=ka;l[t[b]+ka|0]=0}G=G+1|0}if(X){R(f);var ia=t[c]}else{ia=Z}l[t[b]+ia|0]=0;jC(f,cA|0,2);S(f);h=G;continue a}if(0!=(sA(M,nf|0,3)|0)){var ea=M;b:for(;;){do{if(0==(oA(l[ea]&255)|0)){var wb=t[c],sb=(wb+1|0)==(t[d]|0);if(95!=l[ea]<<24>>24){break b}if(sb){e=170}else{var Db=wb}}else{var Za=t[c];(Za+1|0)==(t[d]|0)?e=170:Db=Za}}while(0);170==e&&(e=0,R(f),Db=t[c]);l[t[b]+Db|0]=l[ea];if(0!=l[ea]<<24>>24){var kc=t[c]+1|0;t[c]=kc;l[t[b]+kc|0]=0}ea=ea+1|0}if(sb){R(f);var $c=t[c]}else{$c=wb}l[t[b]+$c|0]=0;jC(f,cA|0,4);S(f);h=ea;continue a}for(var Ia=M+3|0;;){if(0==(L(l[Ia]&255)|0)){var Eb=Ia;break}else{Ia=Ia+1|0}}b:for(;;){do{if(0==(oA(l[Eb]&255)|0)){var Pb=t[c],He=(Pb+1|0)==(t[d]|0);if(95!=l[Eb]<<24>>24){break b}if(He){e=159}else{var Hd=Pb}}else{var de=t[c];(de+1|0)==(t[d]|0)?e=159:Hd=de}}while(0);159==e&&(e=0,R(f),Hd=t[c]);l[t[b]+Hd|0]=l[Eb];if(0!=l[Eb]<<24>>24){var ee=t[c]+1|0;t[c]=ee;l[t[b]+ee|0]=0}Eb=Eb+1|0}if(He){R(f);var Id=t[c]}else{Id=Pb}l[t[b]+Id|0]=0;jC(f,cA|0,3);S(f);h=Eb;continue a}if(0==(sA(m,nx|0,7)|0)){var Jd=m+7|0;if(0==(L(l[Jd]&255)|0)){h=Jd;continue a}else{var uc=Jd}for(;0!=(L(l[uc]&255)|0);){uc=uc+1|0}if(0==(sA(uc,Cf|0,8)|0)){for(var Kd=uc+8|0;;){if(0==(L(l[Kd]&255)|0)){var Qb=Kd;break}else{Kd=Kd+1|0}}b:for(;;){do{if(0==(oA(l[Qb]&255)|0)){var Mc=t[c],ad=(Mc+1|0)==(t[d]|0);if(95!=l[Qb]<<24>>24){break b}if(ad){e=187}else{var bb=Mc}}else{var Qa=t[c];(Qa+1|0)==(t[d]|0)?e=187:bb=Qa}}while(0);187==e&&(e=0,R(f),bb=t[c]);l[t[b]+bb|0]=l[Qb];if(0!=l[Qb]<<24>>24){var Rb=t[c]+1|0;t[c]=Rb;l[t[b]+Rb|0]=0}Qb=Qb+1|0}if(ad){R(f);var vc=t[c]}else{vc=Mc}l[t[b]+vc|0]=0;jC(f,cA|0,2);S(f);h=Qb;continue a}if(0!=(sA(uc,nf|0,3)|0)){var Sb=uc;b:for(;;){do{if(0==(oA(l[Sb]&255)|0)){var fe=t[c],vd=(fe+1|0)==(t[d]|0);if(95!=l[Sb]<<24>>24){break b}if(vd){e=212}else{var lc=fe}}else{var Nc=t[c];(Nc+1|0)==(t[d]|0)?e=212:lc=Nc}}while(0);212==e&&(e=0,R(f),lc=t[c]);l[t[b]+lc|0]=l[Sb];if(0!=l[Sb]<<24>>24){var ge=t[c]+1|0;t[c]=ge;l[t[b]+ge|0]=0}Sb=Sb+1|0}if(vd){R(f);var he=t[c]}else{he=fe}l[t[b]+he|0]=0;jC(f,cA|0,4);S(f);h=Sb;continue a}for(var Tb=uc+3|0;;){if(0==(L(l[Tb]&255)|0)){var Ub=Tb;break}else{Tb=Tb+1|0}}b:for(;;){do{if(0==(oA(l[Ub]&255)|0)){var bd=t[c],cd=(bd+1|0)==(t[d]|0);if(95!=l[Ub]<<24>>24){break b}if(cd){e=201}else{var ac=bd}}else{var ie=t[c];(ie+1|0)==(t[d]|0)?e=201:ac=ie}}while(0);201==e&&(e=0,R(f),ac=t[c]);l[t[b]+ac|0]=l[Ub];if(0!=l[Ub]<<24>>24){var Ld=t[c]+1|0;t[c]=Ld;l[t[b]+Ld|0]=0}Ub=Ub+1|0}if(cd){R(f);var gb=t[c]}else{gb=bd}l[t[b]+gb|0]=0;jC(f,cA|0,3);S(f);h=Ub;continue a}if(0==(sA(m,Cf|0,8)|0)){var dd=m+8|0;if(0==(L(l[dd]&255)|0)){h=dd;continue a}else{var Vb=dd}for(;;){if(0==(L(l[Vb]&255)|0)){var Sa=Vb;break}else{Vb=Vb+1|0}}b:for(;;){do{if(0==(oA(l[Sa]&255)|0)){var Oc=t[c],Pc=(Oc+1|0)==(t[d]|0);if(95!=l[Sa]<<24>>24){break b}if(Pc){e=226}else{var Md=Oc}}else{var ed=t[c];(ed+1|0)==(t[d]|0)?e=226:Md=ed}}while(0);226==e&&(e=0,R(f),Md=t[c]);l[t[b]+Md|0]=l[Sa];if(0!=l[Sa]<<24>>24){var je=t[c]+1|0;t[c]=je;l[t[b]+je|0]=0}Sa=Sa+1|0}if(Pc){R(f);var ke=t[c]}else{ke=Oc}l[t[b]+ke|0]=0;jC(f,cA|0,2);S(f);h=Sa;continue a}if(0==(sA(m,nf|0,3)|0)){var wd=m+3|0;if(0==(L(l[wd]&255)|0)){h=wd;continue a}else{var xd=wd}for(;;){if(0==(L(l[xd]&255)|0)){var ob=xd;break}else{xd=xd+1|0}}b:for(;;){do{if(0==(oA(l[ob]&255)|0)){var Fb=t[c],fd=(Fb+1|0)==(t[d]|0);if(95!=l[ob]<<24>>24){break b}if(fd){e=240}else{var le=Fb}}else{var gd=t[c];(gd+1|0)==(t[d]|0)?e=240:le=gd}}while(0);240==e&&(e=0,R(f),le=t[c]);l[t[b]+le|0]=l[ob];if(0!=l[ob]<<24>>24){var yd=t[c]+1|0;t[c]=yd;l[t[b]+yd|0]=0}ob=ob+1|0}if(fd){R(f);var Nd=t[c]}else{Nd=Fb}l[t[b]+Nd|0]=0;jC(f,cA|0,3);S(f);h=ob;continue a}if(0==(sA(m,xg|0,3)|0)){var Od=m+3|0;if(0==(L(l[Od]&255)|0)){h=Od;continue a}else{var wc=Od}for(;;){if(0==(L(l[wc]&255)|0)){var xc=wc;break}else{wc=wc+1|0}}b:for(;;){do{if(0==(oA(l[xc]&255)|0)){var hd=t[c],Pd=(hd+1|0)==(t[d]|0);if(95!=l[xc]<<24>>24){break b}if(Pd){e=254}else{var bc=hd}}else{var me=t[c];(me+1|0)==(t[d]|0)?e=254:bc=me}}while(0);254==e&&(e=0,R(f),bc=t[c]);l[t[b]+bc|0]=l[xc];if(0!=l[xc]<<24>>24){var Qd=t[c]+1|0;t[c]=Qd;l[t[b]+Qd|0]=0}xc=xc+1|0}if(Pd){R(f);var ne=t[c]}else{ne=hd}l[t[b]+ne|0]=0;jC(f,cA|0,4);S(f);h=xc;continue a}if(0==(sA(m,Fi|0,5)|0)){var cc=m+5|0;if(0==(L(l[cc]&255)|0)){h=cc;continue a}else{var id=cc}for(;;){if(0==(L(l[id]&255)|0)){var yb=id;break}else{id=id+1|0}}b:for(;;){do{if(0==(oA(l[yb]&255)|0)){var Rd=t[c],oe=(Rd+1|0)==(t[d]|0);if(95!=l[yb]<<24>>24){break b}if(oe){e=268}else{var jd=Rd}}else{var Qc=t[c];(Qc+1|0)==(t[d]|0)?e=268:jd=Qc}}while(0);268==e&&(e=0,R(f),jd=t[c]);l[t[b]+jd|0]=l[yb];if(0!=l[yb]<<24>>24){var mc=t[c]+1|0;t[c]=mc;l[t[b]+mc|0]=0}yb=yb+1|0}if(oe){R(f);var pe=t[c]}else{pe=Rd}l[t[b]+pe|0]=0;jC(f,cA|0,1);S(f);h=yb;continue a}if(0!=(sA(m,El|0,5)|0)){h=0==p<<24>>24?m:q;continue a}var Rc=m+5|0;if(0==(L(l[Rc]&255)|0)){h=Rc;continue a}else{var kd=Rc}for(;;){if(0==(L(l[kd]&255)|0)){var nc=kd;break}else{kd=kd+1|0}}b:for(;;){do{if(0==(oA(l[nc]&255)|0)){var Sd=t[c],Sc=(Sd+1|0)==(t[d]|0);if(95!=l[nc]<<24>>24){break b}if(Sc){e=282}else{var Td=Sd}}else{var qe=t[c];(qe+1|0)==(t[d]|0)?e=282:Td=qe}}while(0);282==e&&(e=0,R(f),Td=t[c]);l[t[b]+Td|0]=l[nc];if(0!=l[nc]<<24>>24){var hf=t[c]+1|0;t[c]=hf;l[t[b]+hf|0]=0}nc=nc+1|0}if(Sc){R(f);var jf=t[c]}else{jf=Sd}l[t[b]+jf|0]=0;jC(f,cA|0,0);S(f);h=nc;continue a}}while(0);var Ag=eC();if(0==(Ag|0)){break}else{h=Ag}}}Q(f)}nC.X=1;function oC(){var b,d,c,e=P(),f=eC();if(0!=(f|0)){d=(e|0)>>2;var g=e+4|0;for(b=(e+8|0)>>2;;){do{if(0==(N(f,Cf|0,8)|0)){var h=f+8|0;if(0!=(L(l[h]&255)|0)){for(;;){if(0==(L(l[h]&255)|0)){var i=h;break}else{h=h+1|0}}a:for(;;){do{if(0==(oA(l[i]&255)|0)){var m=t[d],n=(m+1|0)==(t[g>>2]|0);if(95!=l[i]<<24>>24){break a}if(n){c=304}else{var q=m}}else{h=t[d],(h+1|0)==(t[g>>2]|0)?c=304:q=h}}while(0);304==c&&(c=0,R(e),q=t[d]);l[t[b]+q|0]=l[i];0!=l[i]<<24>>24&&(h=t[d]+1|0,t[d]=h,l[t[b]+h|0]=0);i=i+1|0}n?(R(e),h=t[d]):h=m;l[t[b]+h|0]=0;for(h=i;0!=(L(l[h]&255)|0);){h=h+1|0}40==l[h]<<24>>24&&jC(e,aA|0,0);S(e)}}}while(0);f=eC();if(0==(f|0)){break}}}Q(e)}oC.X=1;function pC(b,d){for(var c,e,f,g=b;0!=(L(l[g]<<24>>24)|0);){g=g+1|0}S(d);e=(d|0)>>2;var h=d+4|0;for(c=(d+8|0)>>2;;){var i=l[g];if(0==i<<24>>24){f=360;break}if(0!=(L(i<<24>>24)|0)){f=360;break}var i=l[g],m=t[e],n=(m+1|0)==(t[h>>2]|0);if(44==i<<24>>24||40==i<<24>>24){f=367;break}if(n){R(d);var i=l[g],q=t[e]}else{q=m}l[t[c]+q|0]=i;0!=l[g]<<24>>24&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);g=g+1|0}if(360==f){if(m=t[e],(m+1|0)!=(t[h>>2]|0)){return c=t[c],c=c+m|0,l[c]=0,g}}else{if(367==f&&!n){return c=t[c],c=c+m|0,l[c]=0,g}}R(d);e=t[e];c=t[c];c=c+e|0;l[c]=0;return g}pC.X=1;function qC(){var b,d,c,e=P();d=(e|0)>>2;var f=e+4|0;b=(e+8|0)>>2;for(var g=0==(t[Xz+16>>2]|0),h=0==(t[Xz+48>>2]|0),i=0;;){for(S(e);;){var m=T();if(-1==(m|0)||10==(m|0)||13==(m|0)){break}var n=t[d];(n+1|0)==(t[f>>2]|0)&&(R(e),n=t[d]);l[t[b]+n|0]=m&255;0!=(m|0)&&(m=t[d]+1|0,t[d]=m,l[t[b]+m|0]=0)}m=t[d];(m+1|0)==(t[f>>2]|0)&&(R(e),m=t[d]);l[t[b]+m|0]=0;for(m=t[d];;){var q=m-1|0;if(0==(q|0)){var p=0;break}if(0==(L(l[t[b]+q|0]<<24>>24)|0)){p=0;break}else{m=q}}for(;(p|0)<(q|0)&&0!=(L(l[t[b]+p|0]<<24>>24)|0);){p=p+1|0}do{if(4<(q-p|0)){if(n=t[b],45!=l[n+p|0]<<24>>24){c=408}else{if(45!=l[p+(n+1)|0]<<24>>24){c=408}else{if(45!=l[n+q|0]<<24>>24){c=408}else{if(45!=l[n+(m-2)|0]<<24>>24){c=408}else{if(0!=(i|0)){var s=i}else{for(var s=p+2|0,r=m-3|0;;){if(0==(r|0)){var u=0;break}if(58==l[n+r|0]<<24>>24){u=r;break}else{r=r-1|0}}for(;;){if(0==(u|0)){var v=s;break}n=u-1|0;if(0==(L(l[t[b]+n|0]<<24>>24)|0)){v=s;break}else{u=n}}for(;(v|0)<(u|0)&&!(0==(L(l[t[b]+v|0]<<24>>24)|0)&&45!=l[t[b]+v|0]<<24>>24);){v=v+1|0}(v|0)<(u-1|0)&&(l[t[b]+u|0]=0,s=t[b]+v|0,0!=(sA(ip|0,s,Aa)|0)&&0!=(sA(Pm|0,s,Aa)|0)&&rC(s,0));s=0}}}}}}else{c=408}}while(0);a:do{if(408==c){c=0;m=t[d];n=m-1|0;if(0==(i|0)){var w=0}else{var C=i,A=0;c=409}b:for(;;){if(409==c){c=0;for(var I=A;;){if((I|0)>=(m|0)){s=C;break a}var M=t[b],r=l[M+I|0];if(42==r<<24>>24){var B=I+1|0;if((I|0)>=(n|0)){I=B;continue}if(41==l[M+B|0]<<24>>24){break}else{I=B}}else{I=I+1|0}if(125==r<<24>>24){w=I;continue b}}w=I+2|0}if((w|0)>=(m|0)){s=0;break a}r=t[b];I=r+w|0;M=l[I];do{if(39==M<<24>>24){for(B=w;;){var G=B+1|0;if((G|0)>=(m|0)){s=0;break a}var Z=l[r+G|0];if(92==Z<<24>>24){B=(G|0)<(n|0)?B+2|0:G}else{if(39!=Z<<24>>24){B=G}else{B=B+2|0;if((B|0)>=(m|0)){w=B;continue b}if(39!=l[r+B|0]<<24>>24){w=B;continue b}}}}}else{if(123==M<<24>>24){C=1;A=w+1|0;c=409;continue b}else{if(40==M<<24>>24){if((w|0)<(n|0)){if(42!=l[w+(r+1)|0]<<24>>24){X=w}else{C=1;A=w+2|0;c=409;continue b}}else{var X=w}}else{if(60==M<<24>>24){if(B=w+1|0,(B|0)<(m|0)){if(60!=l[r+B|0]<<24>>24){X=w}else{if(0==(tA(I,un|0)|0)){X=w}else{for(B=w+2|0;(B|0)<(m|0)&&0!=(L(l[t[b]+B|0]<<24>>24)|0);){B=B+1|0}G=B+4|0;for(B=(G|0)>(m|0)?B:0==(sA(t[b]+B|0,Ri|0,4)|0)?G:B;;){if((B|0)>=(m|0)){var ga=B;break}if(0==(L(l[t[b]+B|0]<<24>>24)|0)){ga=B;break}else{B=B+1|0}}for(;(ga|0)<(m|0);){G=t[b];Z=l[G+ga|0];if(62==Z<<24>>24||58==Z<<24>>24){var ra=G;c=430;break}if(0==(L(Z<<24>>24)|0)){ga=ga+1|0}else{c=429;break}}429==c&&(ra=t[b],c=430);430==c&&(c=0,l[ra+ga|0]=0,B=t[b]+B|0,0!=(sA(ip|0,B,Aa)|0)&&0!=(sA(Pm|0,B,Aa)|0)&&0!=(sA(Ri|0,B,Aa)|0)&&rC(B,2));B=ga+1|0;if((B|0)<(m|0)){c=t[b];var ka=B,ia=c,ea=l[c+B|0];c=436}else{X=m}}}}else{X=w}}else{ka=w,ia=r,ea=M,c=436}}}}}while(0);c:do{if(436==c){if(c=0,58!=ea<<24>>24){X=ka}else{do{if(g){if(h){X=ka;break c}w=l[ka+(ia+1)|0];if(58==w<<24>>24||60==w<<24>>24){w=ka}else{X=ka;break c}}else{w=ka}}while(0);for(;;){if(0==(w|0)){var wb=0;break}r=w-1|0;if(0==(L(l[t[b]+r|0]<<24>>24)|0)){wb=w;break}else{w=r}}w=wb;for(r=t[b];;){l[r+w|0]=0;for(r=w;0!=(r|0)&&!(I=r-1|0,0==l[Lc+(l[t[b]+I|0]&255)|0]<<24>>24);){r=I}if((r|0)==(w|0)){X=ka;break c}rC(t[b]+r|0,1);for(w=r;;){if(0==(w|0)){X=ka;break c}var sb=w-1|0;if(0==(L(l[t[b]+sb|0]<<24>>24)|0)){break}else{w=sb}}r=t[b];if(44!=l[r+sb|0]<<24>>24){X=ka;break c}}}}}while(0);w=X+1|0}}}while(0);if(0==(cB(t[K+16>>2])|0)){i=s}else{break}}Q(e)}qC.X=1;function rC(b,d){var c=j;j+=80;0!=(t[Xz+(d<<4)>>2]|0)&&(sC(c,b),t[c+36>>2]=t[Xz+(d<<4)+8>>2],l[c+40|0]=t[Xz+(d<<4)+4>>2]&255,tC(c));j=c}function uC(b,d){for(var c=0;!(0!=Pa[((d<<1)+H+8>>1)+(10*c|0)]<<16>>16&&vC(t[(H>>2)+(5*c|0)],b,t[(H+4>>2)+(5*c|0)]),c=c+1|0,100==(c|0));){}}function wC(){var b=t[Fz>>2],d=t[b+80>>2],c=b+48|0;xC(t[c>>2]);t[c>>2]=0;c=b+52|0;xC(t[c>>2]);t[c>>2]=0;c=b+56|0;xC(t[c>>2]);t[c>>2]=0;c=b+64|0;xC(t[c>>2]);t[c>>2]=0;c=b+60|0;xC(t[c>>2]);t[c>>2]=0;c=b+76|0;Q(t[c>>2]);t[c>>2]=0;vB(b);t[Fz>>2]=d}function xC(b){0!=(b|0)&&(Q(t[b+8>>2]),vB(b))}function yC(b,d){var c=j,e,f=zC(84);e=f>>2;t[e+12]=AC();t[e+13]=AC();t[e+14]=AC();t[e+15]=AC();t[e+16]=AC();t[e+19]=P();t[f+80>>2]=d;e=t[f+80>>2];0==(e|0)?e=0:(e=t[e+4>>2],e=3==(e|0)?(t[Ly>>2]|0)==(t[K+56>>2]|0)?4:0:2==(e|0)?(t[Ly>>2]|0)==(t[K+56>>2]|0)?5:2:14==(e|0)||7==(e|0)||12==(e|0)?4:0);t[f+72>>2]=e;t[f+68>>2]=e;BC(f,0);t[Fz>>2]=f;e=f+44|0;for(var g=b+1|0;;){for(var h=f,i=ba,m=h+44|0,n=h+12|0;;){var q=CC();if(91==(q|0)){DC(Fq|0)}else{if(40==(q|0)){EC(h)}else{if(59==(q|0)){FC(h,11)}else{if(60==(q|0)){GC()}else{if(42==(q|0)){t[n>>2]=0}else{if(-1==(q|0)){i=668;break}else{if(123==(q|0)){FC(h,3)}else{if(58==(q|0)){HC(h)}else{if(125==(q|0)){FC(h,2)}else{if(61==(q|0)){var q=h,p=t[q+80>>2],p=0==(p|0)?0:3==(t[p+4>>2]|0)&1,s=IC();if(61!=(s|0)){JC(s);a:{for(var s=j,r=ba,u=q+40|0,v=q+80|0,w=1;;){var C;if(!w){r=1442;break}w=CC();if(48==(w|0)){2==(t[u>>2]|0)&&(t[u>>2]=3),C=48,w=1}else{if(-1==(w|0)){r=1430;break}else{if(91==(w|0)){DC(Fq|0),C=91,w=1}else{if(40==(w|0)){DC(Mt|0),C=40,w=1}else{if(44==(w|0)||59==(w|0)){C=w,w=0}else{if(123==(w|0)){DC(fu|0),C=123,w=1}else{if(125==(w|0)){if(w=t[v>>2],0!=(w|0)&&3==(t[w+4>>2]|0)){C=125,w=0}else{if(0==(t[Vz>>2]|0)){r=1441;break}else{C=125,w=1}}}else{60==(w|0)?(GC(),C=60):C=w,w=1}}}}}}}}if(1441==r){s=t[t[K+40>>2]+8>>2],r=t[K+20>>2],KC(iu|0,(k=j,j+=8,t[k>>2]=s,t[k+4>>2]=r,k)),dB(yz|0,3)}else{if(1442==r){j=s;s=C;break a}1430==r&&dB(yz|0,2)}s=ba}t[q+32>>2]=1;125==(s|0)?0!=(p|0)&&(JC(125),FC(q,5)):59==(s|0)?FC(q,11):44==(s|0)&&FC(q,5);q|=0;2==(t[q>>2]|0)&&(t[q>>2]=0)}}else{44==(q|0)?FC(h,5):LC(h,q)}}}}}}}}}}if(0!=(t[t[h+(t[m>>2]<<2)+48>>2]>>2]|0)){i=681;break}}668==i&&dB(yz|0,1);h=t[f+(t[e>>2]<<2)+48>>2]|0;i=t[h>>2];if(2==(i|0)){break}else{if(6==(i|0)){h=MC(f,1);i=ba;8==(t[h>>2]|0)&&(i=(f+60|0)>>2,m=t[t[i]+8>>2],0!=(t[m>>2]|0)&&(n=t[K+56>>2],(t[Ry>>2]|0)==(n|0)|(t[Qy>>2]|0)==(n|0)?U(m,Bv|0):(t[Ly>>2]|0)==(n|0)|(t[Py>>2]|0)==(n|0)&&U(m,Xi|0)),U(t[t[i]+8>>2],t[t[h+8>>2]+8>>2]),t[t[i]>>2]=8);NC(f);continue}}OC(f);if(3==(t[h>>2]|0)){h=f;i=g;m=ba;n=t[h+4>>2];if(2==(n|0)||3==(n|0)||7==(n|0)||8==(n|0)||9==(n|0)||12==(n|0)||14==(n|0)){yC(i,h)}else{if(5==(n|0)||13==(n|0)){t[h+28>>2]=1}m=599}599==m&&(0==(PC(8,0)|0)?DC(fu|0):yC(i,h));NC(h);FC(h,2)}h=f;5==(t[t[h+(t[h+44>>2]<<2)+48>>2]>>2]|0)?BC(h,1):(i=t[t[h+(t[h+44>>2]<<2)+48>>2]>>2],11==(i|0)?i=1:2==(i|0)?(i=t[K+56>>2],i=((t[Ly>>2]|0)==(i|0)|(t[Py>>2]|0)==(i|0)?1:0==(QC(h)|0))&1):i=0,0==(i|0)?(t[Lz+8>>2]=1,NC(h)):(BC(h,0),t[Lz+8>>2]=0))}0==(b|0)?(c=t[t[K+40>>2]+8>>2],f=t[K+20>>2],KC(iu|0,(k=j,j+=8,t[k>>2]=c,t[k+4>>2]=f,k)),dB(yz|0,3)):(wC(),j=c)}function RC(b){return 1==(b|0)?0:2==(b|0)?5:3==(b|0)?2:4==(b|0)?3:5==(b|0)?4:7==(b|0)?6:8==(b|0)?7:10==(b|0)?8:11==(b|0)?9:14==(b|0)?10:16==(b|0)?11:18==(b|0)?12:-1}function SC(b){return 1==(b|0)?0:2==(b|0)?3:3==(b|0)?1:5==(b|0)?2:7==(b|0)?4:8==(b|0)?5:10==(b|0)?6:12==(b|0)?7:-1}function MC(b,d){return t[b+(((3-d+t[b+44>>2]|0)>>>0)%3<<2)+48>>2]}function QC(b){0==(b|0)?b=0:(b=t[b+4>>2],b=2==(b|0)||3==(b|0)||7==(b|0)||8==(b|0)||12==(b|0)||14==(b|0)?1:0);return b}function NC(b){var d=b+44|0,c=t[d>>2],c=1<c>>>0?0:c+1|0;t[d>>2]=c;TC(t[b+(c<<2)+48>>2])}function OC(b){var d,c,e=b>>2,f=j;j+=20;var g,h=t[((t[e+11]<<2)+48>>2)+e],i=MC(b,1);d=MC(b,2);c=d>>2;var m=h|0,n=t[m>>2];if(8==(n|0)){i=t[e+20],0!=(i|0)&&3==(t[i+4>>2]|0)&&8==(t[h>>2]|0)&&UC(h,b,1,3)}else{if(3==(n|0)){if(m=t[i>>2],1==(m|0)){0!=(t[e+3]|0)&&((t[Gy>>2]|0)!=(t[K+56>>2]|0)&&(t[e+1]=5),8==(t[c]|0)&&VC(t[e+16],d),WC(b,d))}else{if(0==(QC(b)|0)&&(d=t[e+1],!(8==(d|0)||11==(d|0)))){if((t[Py>>2]|0)!=(t[K+56>>2]|0)){j=f;return}UC(i,b,0,14);j=f;return}if(8==(m|0)){VC(t[e+16],i)}else{e=f|0;d=t[iA>>2]+1|0;t[iA>>2]=d;d=(k=j,j+=4,t[k>>2]=d,k);d=eB(au|0,d);c=d.length;for(m=0;m<c;m++){l[e+m]=d[m]}l[e+m]=0;d=(b+64|0)>>2;V(t[t[d]+8>>2],e);t[t[d]>>2]=8;t[t[d]+4>>2]=-1}e=t[b+4>>2];if((2==(e|0)||3==(e|0)||7==(e|0)||8==(e|0)||11==(e|0)||12==(e|0)||14==(e|0))&&8==(t[i>>2]|0)){e=XC(t[b+4>>2]),d=t[K+56>>2],d=(t[Ly>>2]|0)==(d|0)|(t[Py>>2]|0)==(d|0)?0:(t[Gy>>2]|0)!=(d|0),0!=(e|0)&&UC(i,b,d&1,e)}}}else{if(11==(n|0)||5==(n|0)){h=b+80|0,n=t[h>>2],0==(n|0)?g=568:3!=(t[n+4>>2]|0)&&(g=568),568==g&&(g=t[i>>2],8==(g|0)?0==((12==(t[c+1]|0)||23==(t[c+1]|0)||43==(t[c+1]|0)||52==(t[c+1]|0)||75==(t[c+1]|0)||91==(t[c+1]|0)?1:0)|0)?YC(b,i):UC(i,b,1,21):1==(g|0)&&8==(t[c]|0)&&(0==(t[e+6]|0)?8==(t[d>>2]|0)&&(i=t[K+56>>2],(t[Ly>>2]|0)==(i|0)|(t[Py>>2]|0)==(i|0)?WC(b,d):4==(t[b>>2]|0)?UC(d,b,1,18):0!=(ZC(t[b+4>>2])|0)&&UC(d,b,1,15)):YC(b,d))),(t[Ly>>2]|0)==(t[K+56>>2]|0)&&11==(t[m>>2]|0)&&(b=t[h>>2],0!=(b|0)&&(b=b+4|0,3==(t[b>>2]|0)&&(t[b>>2]=2)))}}}j=f}OC.X=1;function BC(b,d){var c=b>>2,e=0!=(d|0);if(e){var f=t[c+20]}else{t[c]=0,f=t[c+20],t[(b+4|0)>>2]=0==(QC(f)|0)?0:1}for(var g=(b+8|0)>>2,h=g+10;g<h;g++){t[g]=0}0==(f|0)||(t[c+7]=t[f+28>>2]);TC(t[c+12]);TC(t[c+13]);TC(t[c+14]);TC(t[c+15]);e?S(t[c+19]):(TC(t[c+16]),S(t[c+19]),t[c+17]=t[c+18])}BC.X=1;function TC(b){b>>=2;t[b]=0;t[b+1]=-1;t[b+3]=t[K+48>>2];t[b+4]=t[K+24>>2];S(t[b+2])}function PC(b,d){if(!(0==(d|0)|0!=(t[oy+8>>2]|0))){var c;return 0}c=t[K+56>>2];return(t[Py>>2]|0)==(c|0)?c=t[Jz+(RC(b)<<4)>>2]:(t[Ly>>2]|0)==(c|0)?c=t[Zy+(SC(b)<<4)>>2]:c=(t[Gy>>2]|0)==(c|0)?t[Hx+($C(b)<<4)>>2]:t[Tz+(aD(b)<<4)>>2]}function FC(b,d){var c=t[b+(t[b+44>>2]<<2)+48>>2];TC(c);t[c>>2]=d}function CC(){for(var b=0;;){var d=IC();if(0==(L(d)|0)){break}else{b=1}}if(0==(b|0)|l[Oz]^1){return d}var b=t[Vx>>2],c=t[b>>2];if((c+1|0)==(t[b+4>>2]|0)){R(b);var b=c=t[Vx>>2],e=t[c>>2]}else{e=c}c=b+8|0;l[t[c>>2]+e|0]=32;b|=0;e=t[b>>2]+1|0;t[b>>2]=e;l[t[c>>2]+e|0]=0;return d}function bD(){for(var b=IC(),d=IC();;){if(10==(b|0)){if(125==(d|0)){break}}else{if(-1==(b|0)){break}}b=d;d=IC()}}function DC(b){var d=j,c,e=0==(qA(fu|0,b)|0),f=e&0!=(t[Vz>>2]|0),g=t[Lz+28>>2],h=l[b]<<24>>24,i=l[b+1|0]<<24>>24,b=t[K+20>>2],m=0,n=1;a:for(;;){for(var q=0<(n|0),p=m;;){if(!q){var s=p;c=699;break a}var r=CC();if(-1==(r|0)){break a}if(l[Oz]){var p=t[Vx>>2],u=t[p>>2];if((u+1|0)==(t[p+4>>2]|0)){R(p);var p=u=t[Vx>>2],v=t[u>>2]}else{v=u}u=p+8|0;l[t[u>>2]+v|0]=r&255;0!=(r|0)&&(p|=0,v=t[p>>2]+1|0,t[p>>2]=v,l[t[u>>2]+v|0]=0)}if((r|0)==(h|0)){c=692;break}if((r|0)==(i|0)){c=696;break}else{p=r}}if(696==c){if(c=0,n=n-1|0,f){if((t[Lz+28>>2]|0)==(g|0)){m=r}else{c=698;break}}else{m=r}}else{if(692==c){if(c=0,n=n+1|0,f){if((t[Lz+28>>2]|0)==(g|0)){m=r}else{c=694;break}}else{m=r}}}}698==c?(bD(),s=i,c=699):694==c&&(bD(),s=h,c=699);699==c&&-1!=(s|0)?j=d:(d=t[t[K+40>>2]+8>>2],KC(Ev|0,(k=j,j+=12,t[k>>2]=d,t[k+4>>2]=h,t[k+8>>2]=b,k)),e?dB(yz|0,3):dB(yz|0,2))}DC.X=1;function $C(b){return 17==(b|0)?9:1==(b|0)?0:2==(b|0)?4:6==(b|0)?3:9==(b|0)?6:3==(b|0)?2:18==(b|0)?10:13==(b|0)?7:20==(b|0)?11:8==(b|0)?5:15==(b|0)?8:21==(b|0)?12:-1}function aD(b){return 21==(b|0)?13:8==(b|0)?5:9==(b|0)?6:11==(b|0)?7:15==(b|0)?8:6==(b|0)?3:2==(b|0)?4:19==(b|0)?11:3==(b|0)?2:18==(b|0)?10:20==(b|0)?12:1==(b|0)?0:16==(b|0)?9:-1}function ZC(b){return 1==(b|0)||2==(b|0)||3==(b|0)||4==(b|0)||12==(b|0)||14==(b|0)?1:0}function VC(b,d){var c=d>>2,e=b>>2;t[e]=t[c];t[e+1]=t[c+1];t[e+4]=t[c+4];t[e+3]=t[c+3];V(t[e+2],t[t[c+2]+8>>2])}function WC(b,d){if(8==(t[d>>2]|0)){var c=t[K+56>>2];UC(d,b,(2==(t[b+68>>2]|0)?1:0!=(cD(b)|0)?0:1==(t[b>>2]|0))&1,(t[Ly>>2]|0)==(c|0)|(t[Py>>2]|0)==(c|0)?10:(t[Gy>>2]|0)==(c|0)&&13==(t[b+4>>2]|0)?17:6)}}function UC(b,d,c,e){var f,g=j;j+=80;f=g>>2;var h=(0==(c|0)?0:0==(t[K+52>>2]|0))&1;if(8==(t[b>>2]|0)){var i=b+8|0;if(0!=(t[t[i>>2]>>2]|0)&&0!=(PC(e,h)|0)){var c=P(),m=P();sC(g,t[t[i>>2]+8>>2]);t[f+1]=t[b+12>>2];t[f+2]=t[b+16>>2];t[f+4]=h;t[f+9]=dD(e);b=t[K+56>>2];l[g+40|0]=t[((t[Py>>2]|0)==(b|0)?(RC(e)<<4)+Jz+4|0:(t[Ly>>2]|0)==(b|0)?(SC(e)<<4)+Zy+4|0:(t[Gy>>2]|0)==(b|0)?($C(e)<<4)+Hx+4|0:(aD(e)<<4)+Tz+4|0)>>2]&255;eD(c,d);fD(g,e,d,c,m);tC(g);if(!(0==(t[oy+4>>2]|0)|0==(c|0))&&0!=(t[c>>2]|0)){d=P();b=t[c+8>>2];do{if(3==(e|0)){if(f=gB(b,58),0!=(f|0)){for(i=f;;){if(58==l[i]<<24>>24&i>>>0>b>>>0){i=i-1|0}else{break}}f=d;h=b;i=i+1-b|0;S(f);gD(f,h,i)}}else{V(d,b)}}while(0);0!=(t[d>>2]|0)&&(hD(d),e=g+32|0,U(d,t[e>>2]),t[e>>2]=t[d+8>>2],tC(g));Q(d)}Q(c);Q(m)}}j=g}UC.X=1;function YC(b,d){var c=b>>2;if(8==(t[d>>2]|0)){var e=t[c];if(4==(e|0)){UC(d,b,1,18)}else{var f=t[c+1];10==(f|0)?UC(d,b,0,12):4==(f|0)?UC(d,b,2==(t[c+17]|0)&1,4):0!=(ZC(f)|0)&&0==(t[c+9]|0)&&(0!=(cD(b)|0)?(f=t[K+56>>2],(t[Ly>>2]|0)==(f|0)|(t[Py>>2]|0)==(f|0)?UC(d,b,2==(t[c+17]|0)&1,5):2>e>>>0&&UC(d,b,1,9)):2!=(e|0)&&0!=(t[c+3]|0)?(e=1==(e|0)&1,0==(t[c+7]|0)?UC(d,b,e,20):UC(d,b,e,8)):UC(d,b,0,21))}}}YC.X=1;function cD(b){if(8==(t[t[b+60>>2]>>2]|0)){return 1}b=t[b+80>>2];return b=(0==(b|0)?0:0!=(QC(b)|0))&1}function dD(b){var d=t[K+56>>2];return t[((t[Py>>2]|0)==(d|0)?(RC(b)<<4)+Jz+8|0:(t[Ly>>2]|0)==(d|0)?(SC(b)<<4)+Zy+8|0:(t[Gy>>2]|0)==(d|0)?($C(b)<<4)+Hx+8|0:(aD(b)<<4)+Tz+8|0)>>2]}function eD(b,d){var c,e;S(b);var f=t[d+60>>2];8==(t[f>>2]|0)&&V(b,t[t[f+8>>2]+8>>2]);var g=d+80|0;if(0!=(t[g>>2]|0)){var f=P(),g=t[g>>2],h=0==(g|0);a:do{if(!h){var i=b+8|0,m=f|0,n=f+8|0,q=g;for(c=q>>2;;){if(0==(QC(q)|0)){if(q=t[c+1],8==(q|0)||11==(q|0)){e=848}}else{e=848}848==e&&(e=0,V(f,t[i>>2]),S(b),q=t[c+15],8==(t[q>>2]|0)&&(q=t[q+8>>2],0!=(t[q>>2]|0)&&(U(b,t[q+8>>2]),hD(b))),U(b,t[t[t[c+16]+8>>2]+8>>2]),0!=(t[m>>2]|0)&&hD(b),U(b,t[n>>2]));c=t[c+20];if(0==(c|0)){break a}else{q=c,c=q>>2}}}}while(0);Q(f)}}eD.X=1;function fD(b,d,c,e,f){var g=c>>2,b=b>>2,h;if(6==(d|0)||10==(d|0)||15==(d|0)){h=860}else{if(1==(d|0)||2==(d|0)||3==(d|0)||4==(d|0)||5==(d|0)||7==(d|0)||9==(d|0)||11==(d|0)||14==(d|0)||16==(d|0)||17==(d|0)||18==(d|0)||19==(d|0)){h=862}else{if(20!=(d|0)){return}}}860==h&&(h=t[Vx>>2],0!=(t[h>>2]|0)&&(t[b+17]=t[h+8>>2]),h=862);if(862==h){if(0!=(t[e>>2]|0)&&!(0==(cD(c)|0)&&8!=(t[t[g+20]+4>>2]|0))){if(8==(t[t[g+15]>>2]|0)){t[b+15]=dD(1)}else{var i=t[g+20];t[b+15]=dD(XC(0==(i|0)?0:t[i+4>>2]))}t[b+16]=t[e+8>>2]}if(16==(d|0)||7==(d|0)||1==(d|0)){i=t[g+19],0!=(t[i>>2]|0)&&(t[b+14]=t[i+8>>2])}i=t[g+10];if(0!=(i|0)){var m=t[K+56>>2];(t[Qy>>2]|0)==(m|0)|(t[Py>>2]|0)==(m|0)|(t[Ly>>2]|0)==(m|0)&&(t[b+13]=t[Ic+(i<<2)>>2])}if(0!=(cD(c)|0)){var n;if((t[Qy>>2]|0)==(t[K+56>>2]|0)){if(3==(t[c>>2]|0)){var q=Nj|0}else{n=932}}else{n=932}932==n&&(n=t[c+68>>2],q=0==(n|0)?0:t[td+(n<<2)>>2]);t[b+11]=q}if(!(20==(d|0)||18==(d|0)||9==(d|0))){return}}if(0!=(QC(c)|0)){t[b+18]=dD(XC(t[g+1]));d=t[t[t[g+16]+8>>2]+8>>2];if(0==(d|0)){h=883}else{if(0==l[d]<<24>>24){h=883}else{var p=d}}883==h&&(c=MC(c,2),p=8!=(t[c>>2]|0)?d:t[t[c+8>>2]+8>>2]);0==(t[e>>2]|0)?e=p:(V(f,t[e+8>>2]),hD(f),U(f,p),e=t[f+8>>2]);t[b+19]=e}}fD.X=1;function XC(b){return 2==(b|0)?1:13==(b|0)?17:12==(b|0)?16:14==(b|0)?19:4==(b|0)?b:8==(b|0)?11:11==(b|0)?13:3==(b|0)?2:5==(b|0)?6:7==(b|0)?b:0}function hD(b){var d=t[K+56>>2];(t[Ry>>2]|0)==(d|0)|(t[Qy>>2]|0)==(d|0)?U(b,Bv|0):(t[Ly>>2]|0)==(d|0)|(t[Py>>2]|0)==(d|0)&&U(b,Xi|0)}function EC(b){var d,c=b>>2,e=j;j+=28;d=e>>2;var f=MC(b,1);0!=(t[c+7]|0)&&0==(t[c+8]|0)&&(t[c+9]=1);if(0!=(t[f>>2]|0)){var f=t[((t[c+11]<<2)+48>>2)+c],g=e>>2;t[g]=0;t[g+1]=1;t[g+2]=(t[Ry>>2]|0)==(t[K+56>>2]|0)&1;t[g+3]=1;t[g+4]=0;t[g+5]=0;t[g+6]=0;iD(b,e);g=CC();JC(g);if(0!=(t[d+4]|0)){BC(b,0)}else{var h=0==(t[d+3]|0);a:do{if(!h){var i=f|0;if(10==(t[i>>2]|0)){var m=b+16|0;if(0==(t[m>>2]|0)){do{if(0!=(t[d+1]|0)&&!(0==(t[c+3]|0)|40==(g|0))&&!(61==(g|0)&&2!=(t[c+10]|0))){if(0!=(t[c+1]|0)){break a}if(0==(bC(At|0,g,3)|0)){break a}}}while(0);t[i>>2]=8;jD(b);t[m>>2]=1;if(40==(g|0)&&0!=(t[d+5]|0)){j=e;return}t[c+6]=t[d];j=e;return}}}}while(0);f=b+20|0;if(0==(t[f>>2]|0)&&0!=(t[d+1]|0)){t[f>>2]=1;FC(b,1);NC(b);if(4==(t[c]|0)){j=e;return}d=j;c=t[K+20>>2];f=CC();JC(f);if(0!=(bC(zt|0,f,5)|0)){j=d}else{if((t[Ly>>2]|0)==(t[K+56>>2]|0)){var n,c=t[b+(t[b+44>>2]<<2)+48>>2],f=CC();if(0==(pA(f)|0)){if(126==(f|0)||95==(f|0)||36==(f|0)){n=1421}else{var q=f}}else{n=1421}a:do{if(1421==n){if(kD(c,f),82!=(t[c+4>>2]|0)){q=f}else{for(;;){g=CC();if(0==(pA(g)|0)){if(126==(g|0)||95==(g|0)||36==(g|0)){n=1424}else{var p=g}}else{n=1424}1424==n&&(n=0,kD(c,g),p=CC());if(!(46==(p|0)||44==(p|0))){q=p;break a}}}}}while(0);JC(q);FC(b,0);j=d}else{0==(lD(b,e)|0)?(b=t[t[K+40>>2]+8>>2],KC(qt|0,(k=j,j+=8,t[k>>2]=b,t[k+4>>2]=c,k)),dB(yz|0,2)):j=d}}j=e;return}FC(b,0)}}j=e}EC.X=1;function GC(){var b=IC();if(62!=(b|0)){var d=t[K+56>>2];(t[Qy>>2]|0)==(d|0)|(t[Py>>2]|0)==(d|0)?d=1:(d=(t[Ly>>2]|0)==(d|0),d&=1);0!=(d|0)&&1<(b-60|0)>>>0?(JC(b),DC(Ct|0)):60!=(b|0)?JC(b):(b=IC(),61!=(b|0)&&JC(b))}}function HC(b){var d=(t[Qy>>2]|0)==(t[K+56>>2]|0)?IC():CC();if(58==(d|0)){FC(b,6),t[b+12>>2]=0}else{if(JC(d),d=t[K+56>>2],(t[Qy>>2]|0)==(d|0)|(t[Py>>2]|0)==(d|0)&&0!=((12==(t[b+4>>2]|0)||2==(t[b+4>>2]|0)||7==(t[b+4>>2]|0)?1:3==(t[b+4>>2]|0)?(t[Py>>2]|0)==(t[K+56>>2]|0)&1:0)|0)){mD(b,58)}else{var d=t[b+80>>2],c=0==(d|0);!c&&12==(t[d+4>>2]|0)?(d=nD(At|0),59==(d|0)?FC(b,11):44==(d|0)&&FC(b,5)):(17==(t[MC(b,1)+4>>2]|0)||9==(t[MC(b,2)+4>>2]|0)|c^1)&&BC(b,0)}}}HC.X=1;function LC(b,d){var c=b>>2,e=MC(b,1);if(0==(pA(d)|0)&&!(126==(d|0)||95==(d|0)||36==(d|0))){var f=(t[Ly>>2]|0)==(t[K+56>>2]|0);if(!(-1!=(d|0)&f&191<(d&192)>>>0)){e=45==(d|0);if(2>(d-45|0)>>>0){0==(t[c+8]|0)&&(t[c+9]=1);if(!e){return}c=IC();if(62==(c|0)){return}JC(c);return}if(211==(d|0)){if(0!=(t[c+3]|0)){return}e=b|0;if(2!=(t[e>>2]|0)){return}t[c+1]=9;t[e>>2]=0}else{if(64==(d|0)){if(!f){return}oD(b)}else{if(62==(d|0)||33==(d|0)){c=IC();if(61==(c|0)){return}JC(c)}}}return}}f=t[b+(t[b+44>>2]<<2)+48>>2];kD(f,d);0!=(t[f>>2]|0)&&pD(f,b);f=t[c+15];8==(t[f>>2]|0)&&8==(t[t[((t[c+11]<<2)+48>>2)+c]>>2]|0)&&8==(t[e>>2]|0)&&TC(f)}LC.X=1;function oD(b){var d=t[b+(t[b+44>>2]<<2)+48>>2];kD(d,CC());43==(t[d+4>>2]|0)?t[b+4>>2]=7:qD()}function kD(b,d){var c,e,f=t[b+8>>2];TC(b);e=(f|0)>>2;if((t[Qy>>2]|0)==(t[K+56>>2]|0)&126==(d|0)){c=t[e];var g=f+4|0;if((c+1|0)==(t[g>>2]|0)){R(f);var h=t[e]}else{h=c}c=f+8|0;l[t[c>>2]+h|0]=126;h=t[e]+1|0;t[e]=h;l[t[c>>2]+h|0]=0;h=CC()}else{h=d,g=f+4|0,c=f+8|0}c>>=2;for(var i=1;;){var m=t[e];if((m+1|0)==(t[g>>2]|0)){R(f);var n=t[e]}else{n=m}m=h&255;l[t[c]+n|0]=m;h=0==(h|0);h||(n=t[e]+1|0,t[e]=n,l[t[c]+n|0]=0);if(l[Oz]){if(0==(i|0)){i=t[Vx>>2];n=t[i>>2];if((n+1|0)==(t[i+4>>2]|0)){R(i);var i=n=t[Vx>>2],q=t[n>>2]}else{q=n}n=i+8|0;l[t[n>>2]+q|0]=m;h||(m=i|0,h=t[m>>2]+1|0,t[m>>2]=h,l[t[n>>2]+h|0]=0)}h=0}else{h=i}m=IC();if(0!=(oA(m)|0)){i=h,h=m}else{if(95==(m|0)||36==(m|0)){i=h,h=m}else{i=t[K+56>>2];if(!((t[Ly>>2]|0)==(i|0)|(t[Py>>2]|0)==(i|0))){break}if(-1!=(m|0)&191<(m&192)>>>0|46==(m|0)){i=h,h=m}else{break}}}}h=t[e];(h+1|0)!=(t[g>>2]|0)?(f=t[c],e=f+h|0):(R(f),e=t[e],f=t[c],e=f+e|0);l[e]=0;JC(m);a:{e=j;j+=8;var p,g=e+4,f=b+8|0;c=t[f>>2];m=t[c+8>>2];t[e>>2]=0;t[g>>2]=0;if((t[Ly>>2]|0)==(t[K+56>>2]|0)){var s=c;p=1115}else{if(0==(rD(m,g,e)|0)){if(g=t[e>>2],0==(g|0)){s=t[f>>2],p=1115}else{var r=mC(g,t[K+56>>2]);t[b+4>>2]=r}}else{TC(b);if(0==(t[g>>2]|0)){j=e;break a}if(40!=(CC()|0)){j=e;break a}DC(Mt|0);j=e;break a}}1115==p&&(p=mC(t[s+8>>2],t[K+56>>2]),r=t[b+4>>2]=p);t[(b|0)>>2]=-1==(r|0)?8:7;j=e}}kD.X=1;function qD(){var b=CC();40==(b|0)?DC(Mt|0):JC(b)}function jD(b){var d=b+8|0;if(0!=(t[d>>2]|0)){var c=b+4|0;0==(t[c>>2]|0)&&(t[c>>2]=1)}t[d>>2]=1;t[b+12>>2]=1}function pD(b,d){var c=d>>2,e=t[b+4>>2];if(13==(e|0)){t[c+1]=1}else{if(72==(e|0)){t[c+1]=1}else{if(78==(e|0)){t[c+1]=13}else{if(92==(e|0)){t[c+1]=1}else{if(94==(e|0)){sD(d)}else{if(68==(e|0)){sD(d)}else{if(71==(e|0)){t[c+1]=1}else{if(32==(e|0)){t[c]=3}else{if(27==(e|0)){(t[Py>>2]|0)==(t[K+56>>2]|0)&&(t[c+1]=4)}else{if(87==(e|0)){BC(d,0),t[c]=4}else{if(25==(e|0)){(t[Py>>2]|0)==(t[K+56>>2]|0)&&0!=(t[c+2]|0)||(BC(d,0),t[c]=2,t[c+1]=1)}else{if(6==(e|0)){t[c+1]=1}else{if(10==(e|0)){qD(),c=CC(),123==(c|0)?DC(fu|0):JC(c)}else{if(82==(e|0)){for(c=CC();0!=(pA(c)|0)||126==(c|0)||95==(c|0)||36==(c|0);){kD(b,c),c=CC(),c=46==(c|0)||44==(c|0)?CC():c}JC(c)}else{91==(e|0)?t[c+1]=14:1==(e|0)?t[c+10]=1:56==(e|0)?tD(d):63==(e|0)?uD(d,2):46==(e|0)?t[c+1]=1:36==(e|0)?(mD(d,46),FC(d,0)):65==(e|0)?uD(d,3):66==(e|0)?uD(d,4):73==(e|0)?(e=t[K+56>>2],(t[Ly>>2]|0)==(e|0)|(t[Py>>2]|0)==(e|0)||(BC(d,0),t[c]=1,t[c+1]=1)):8==(e|0)?t[c+1]=1:30==(e|0)||31==(e|0)||35==(e|0)||76==(e|0)||99==(e|0)?40==(CC()|0)&&DC(Mt|0):33==(e|0)?t[c+1]=1:75==(e|0)?t[c+1]=12:74==(e|0)?t[c+1]=1:26==(e|0)?(mD(d,46),FC(d,0)):21==(e|0)?t[c+1]=1:42==(e|0)?t[c+1]=1:43==(e|0)?t[d+4>>2]=7:45==(e|0)?uD(d,1):-1==(e|0)?jD(d):0==(e|0)?(qD(),TC(b)):39==(e|0)?t[c+1]=1:12==(e|0)?t[c+1]=2:23==(e|0)?t[c+1]=3:96==(e|0)?t[c+1]=1:97==(e|0)?t[c+1]=1:98==(e|0)?t[c+1]=1:52==(e|0)?vD(d,8):62==(e|0)?vD(d,10):37==(e|0)?sD(d):95==(e|0)?t[c+10]=2:64==(e|0)?t[c+1]=11:11==(e|0)?t[c+1]=1:29==(e|0)?t[c+1]=1:34==(e|0)&&sD(d)}}}}}}}}}}}}}}}pD.X=1;function mD(b,d){var c,e,f=AC(),g=AC();c=(g+8|0)>>2;var h=f|0,i=f+8|0,m=d&255,n=0==(d|0);a:for(;;){var q=CC();do{if(0==(pA(q)|0)){if(126==(q|0)||95==(q|0)||36==(q|0)){e=1248}else{if((q|0)==(d|0)){var p=t[c],s=t[p>>2];(s+1|0)==(t[p+4>>2]|0)&&(R(p),p=s=t[c],s=t[s>>2]);l[t[p+8>>2]+s|0]=m;if(n){continue a}p=t[c]|0;s=t[p>>2]+1|0;t[p>>2]=s;l[t[t[c]+8>>2]+s|0]=0}else{if(60==(q|0)){DC(Ct|0);continue a}8==(t[h>>2]|0)&&(wD(b,g),TC(g))}}}else{e=1248}}while(0);1248==e&&(e=0,kD(f,q),8==(t[h>>2]|0)?U(t[c],t[t[i>>2]+8>>2]):(wD(b,g),TC(g)));if(-1==(q|0)||123==(q|0)){break}}JC(q);xC(g);xC(f)}mD.X=1;function sD(b){t[b+4>>2]=6;nD(Ft|0)}function uD(b,d){if(0!=(cD(b)|0)){if((t[Qy>>2]|0)==(t[K+56>>2]|0)){var c=CC();58==(c|0)?BC(b,0):JC(c);t[b+72>>2]=d}t[b+68>>2]=d}}function tD(b){var d,c,e,f,g,h;c=MC(b,1);h=t[b+(t[b+44>>2]<<2)+48>>2]>>2;var i=t[h+2],m=CC();7==(t[c>>2]|0)?(c=t[c+4>>2],23==(c|0)||75==(c|0)||91==(c|0)?d=m:f=1275):f=1275;a:do{if(1275==f){if(40==(m|0)){41!=(IC()|0)?(DC(Mt|0),d=IC()):(d=(i|0)>>2,c=t[d],(c+1|0)==(t[i+4>>2]|0)?(R(i),e=t[d]):e=c,c=i+8|0,l[t[c>>2]+e|0]=32,e=t[d]+1|0,t[d]=e,l[t[c>>2]+e|0]=0,d=CC(),40==(d|0)&&(U(i,Mt|0),d=40))}else{do{if(0==(pA(m)|0)&&!(126==(m|0)||95==(m|0)||36==(m|0))){if(0==(bC(Lt|0,m,17)|0)){d=m;break a}d=(i|0)>>2;f=t[d];g=(i+4|0)>>2;(f+1|0)==(t[g]|0)?(R(i),c=t[d]):c=f;f=(i+8|0)>>2;l[t[f]+c|0]=32;c=t[d]+1|0;t[d]=c;for(l[t[f]+c|0]=0;;){var n=t[d];(n+1|0)==(t[g]|0)&&(R(i),n=t[d]);l[t[f]+n|0]=m&255;0!=(m|0)&&(n=t[d]+1|0,t[d]=n,l[t[f]+n|0]=0);n=IC();if(0==(bC(Lt|0,n,17)|0)){break}else{m=n}}m=t[d];(m+1|0)==(t[g]|0)?(R(i),i=t[d]):i=m;l[t[f]+i|0]=0;d=n;break a}}while(0);e=(i|0)>>2;c=(i+4|0)>>2;d=(i+8|0)>>2;for(var q=1,p=m;;){if(0==(L(p)|0)?(0!=(q|0)&&(g=t[e],(g+1|0)==(t[c]|0)&&(R(i),g=t[e]),l[t[d]+g|0]=32,g=t[e]+1|0,t[e]=g,l[t[d]+g|0]=0),g=t[e],(g+1|0)==(t[c]|0)&&(R(i),g=t[e]),l[t[d]+g|0]=p&255,0!=(p|0)&&(g=t[e]+1|0,t[e]=g,l[t[d]+g|0]=0),p=0):p=1,g=IC(),0==(bC(It|0,g,3)|0)&-1!=(g|0)){q=p,p=g}else{break}}p=t[e];(p+1|0)==(t[c]|0)?(R(i),c=t[e]):c=p;l[t[d]+c|0]=0;d=g}}}while(0);JC(d);t[h]=8;t[h+1]=-1;jD(b)}tD.X=1;function vD(b,d){var c=b>>2;t[c+1]=d;if(!(8==(d|0)&&(t[Py>>2]|0)!=(t[K+56>>2]|0))){var e=t[((t[c+11]<<2)+48>>2)+c];xD(e,CC());t[e>>2]=8;t[c+2]=1;t[c+3]=1}}function xD(b,d){var c,e,f=t[b+8>>2];TC(b);e=(f|0)>>2;var g=f+4|0;c=(f+8|0)>>2;for(var h=d;0!=(oA(h)|0)||95==(h|0)||36==(h|0)||46==(h|0);){var i=t[e];(i+1|0)==(t[g>>2]|0)&&(R(f),i=t[e]);l[t[c]+i|0]=h&255;0!=(h|0)&&(h=t[e]+1|0,t[e]=h,l[t[c]+h|0]=0);h=IC()}i=t[e];(i+1|0)!=(t[g>>2]|0)?(c=t[c],c=c+i|0):(R(f),e=t[e],c=t[c],c=c+e|0);l[c]=0;JC(h)}xD.X=1;function nD(b){for(var d;;){var c=IC();if(-1==(c|0)||0==(c|0)){d=1351;break}if(0!=(mA(b,c)|0)){d=1350;break}}if(1350==d||1351==d){return c}}function AC(){var b=zC(20);t[b+8>>2]=P();TC(b);return b}function wD(b,d){var c,e=d+8|0,f=t[e>>2];c=(b+76|0)>>2;if(0==(t[f>>2]|0)){e=f}else{var g=t[c],h=t[g>>2];0==(h|0)?e=f:((h+1|0)==(t[g+4>>2]|0)?(R(g),f=h=t[c],h=t[h>>2]):f=g,l[t[f+8>>2]+h|0]=44,h=t[c]|0,f=t[h>>2]+1|0,t[h>>2]=f,l[t[t[c]+8>>2]+f|0]=0,e=t[e>>2])}U(t[c],t[e+8>>2])}function iD(b,d){var c,e,f,g,h,i,m=t[b+(t[b+44>>2]<<2)+48>>2];l[Oz]=1;f=t[Vx>>2];S(f);e=t[f>>2];(e+1|0)==(t[f+4>>2]|0)?(R(f),f=e=t[Vx>>2],g=t[e>>2]):g=e;e=f+8|0;l[t[e>>2]+g|0]=40;f|=0;g=t[f>>2]+1|0;t[f>>2]=g;l[t[e>>2]+g|0]=0;h=(d+24|0)>>2;t[h]=1;g=(d+4|0)>>2;f=(d+8|0)>>2;e=(d+12|0)>>2;var n=d+16|0;c=(m|0)>>2;var q=m+4|0,p=d+20|0,s=d|0,r=1,u=1,v=0;a:for(;;){var w=CC(),C=t[Vx>>2],A=t[C>>2];if((A+1|0)==(t[C+4>>2]|0)){R(C);var C=A=t[Vx>>2],I=t[A>>2]}else{I=A}A=C+8|0;l[t[A>>2]+I|0]=w&255;do{if(0==(w|0)){i=1395}else{var I=C|0,M=t[I>>2]+1|0;t[I>>2]=M;l[t[A>>2]+M|0]=0;if(38==(w|0)||42==(w|0)){t[s>>2]=1;t[f]=0;0==(v|0)&&(t[g]=0);TC(m);var B=u,G=v}else{if(44==(w|0)){t[e]=0,0==(t[f]|0)?(B=u,G=v):(t[h]=t[h]+1|0,B=u,G=0)}else{if(61==(w|0)){if(t[f]=0,t[e]=0,0==(r|0)){B=u,G=v}else{i=1378;break a}}else{if(91==(w|0)){t[f]=0,DC(Fq|0),B=u,G=v}else{if(60==(w|0)){t[f]=0,GC(),B=u,G=v}else{if(41==(w|0)){0!=(r|0)&&(t[h]=0),B=u-1|0,G=v}else{if(40==(w|0)){t[f]=0;if(0!=(r|0)){i=1385;break a}10!=(t[c]|0)?B=u+1|0:(B=CC(),42!=(B|0)?(JC(B),JC(40),t[p>>2]=1):(DC(Mt|0),B=CC(),40==(B|0)?DC(Mt|0):JC(B)),B=u);G=v}else{64==(w|0)?(t[Ly>>2]|0)!=(t[K+56>>2]|0)?i=1395:(oD(b),B=u,G=v):58==(w|0)?(t[f]=0,B=u,G=v):46==(w|0)?(t[e]=0,B=IC(),46!=(B|0)?(JC(B),t[f]=0):(B=IC(),46==(B|0)?U(t[Vx>>2],pt|0):(JC(B),t[f]=0)),B=u,G=v):i=1395}}}}}}}}}while(0);b:do{if(1395==i){i=0;do{if(0==(pA(w)|0)&&!(126==(w|0)||95==(w|0)||36==(w|0))){t[g]=0;t[f]=0;t[e]=0;t[n>>2]=1;B=u;G=v;break b}}while(0);var Z=v+1|0;1<Z>>>0&&(t[f]=0);kD(m,w);B=t[c];8==(B|0)?0!=(t[e]|0)&&(t[c]=10):7==(B|0)&&(B=t[q>>2],13==(B|0)||97==(B|0)||(t[f]=0,t[e]=0));B=u;G=Z}}while(0);u=t[p>>2];Z=0==(B|0);if(0!=(u|0)|Z){var X=u;i=1408;break}if(0!=(t[f]|0)){r=0,u=B,v=G}else{if(0==(t[e]|0)){X=0;i=1408;break}else{r=0,u=B,v=G}}}a:do{if(1378==i){t[g]=0,yD(b)}else{if(1385==i){t[e]=0,JC(40),S(C),yD(b),zD(t[Vx>>2])}else{if(1408==i&&!(0!=(X|0)|Z)){for(G=B;;){if(DC(Mt|0),G=G-1|0,0==(G|0)){break a}}}}}}while(0);0==(t[e]|0)&&TC(m);i=t[Vx>>2];m=t[i>>2];(m+1|0)==(t[i+4>>2]|0)&&(R(i),i=m=t[Vx>>2],m=t[m>>2]);l[t[i+8>>2]+m|0]=0;0!=(t[f]|0)&&S(i);l[Oz]=0}iD.X=1;function lD(b,d){var c,e=t[b+(t[b+44>>2]<<2)+48>>2],f=d+24|0,g=t[f>>2],h=e+4|0,i=e|0,m=d+8|0,n=e+8|0,q=CC(),p=0,s=0;a:for(;;){do{if(123==(q|0)){c=1463;break a}else{if(91==(q|0)){DC(Fq|0);var r=s,u=g,v=p}else{if(58==(q|0)){r=e;for(u=ba;;){var w=CC();b:for(;;){do{if(0==(pA(w)|0)){if(36==(w|0)||95==(w|0)||126==(w|0)){u=1494}else{if(60==(w|0)){u=1496;break b}else{if(58!=(w|0)){var C=w;break b}}}}else{58!=(w|0)&&(u=1494)}}while(0);1494==u&&(u=0,kD(r,w));w=CC()}1496==u&&(u=0,DC(Ct|0),C=CC());40==(C|0)?(DC(Mt|0),w=CC()):w=C;if(44!=(w|0)){break}}JC(w);r=s;u=g;v=p}else{if(40==(q|0)){DC(Mt|0),r=0==(s|0)?0:s+1|0,u=g,v=p}else{if(59==(q|0)){if(0==(g|0)|2>s>>>0){c=1467;break a}var A=g-1|0,I=0==(A|0)&1,M=p,B=s;c=1481}else{if(61==(q|0)){c=1462;break a}else{if(125==(q|0)){c=1464;break a}else{if(41==(q|0)){r=s,u=g,v=p}else{if(0==(pA(q)|0)&&!(126==(q|0)||95==(q|0)||36==(q|0))){r=s,u=g,v=p}else{kD(e,q);var G=t[h>>2];if(0==(G|0)){qD(),r=s,u=g,v=p}else{if(10==(G|0)||12==(G|0)||24==(G|0)||25==(G|0)||32==(G|0)||38==(G|0)||51==(G|0)||52==(G|0)||53==(G|0)||54==(G|0)||56==(G|0)||58==(G|0)||63==(G|0)||65==(G|0)||66==(G|0)||73==(G|0)||79==(G|0)||87==(G|0)||88==(G|0)||94==(G|0)||95==(G|0)){var Z=q;break a}else{if(81==(G|0)){qD(),r=s,u=g,v=p}else{if(86==(G|0)){r=s,u=g,v=p}else{if(13==(G|0)||97==(G|0)){r=t[Vx>>2],u=t[r>>2],0!=(u|0)&&((u+1|0)==(t[r+4>>2]|0)?(R(r),r=u=t[Vx>>2],v=t[u>>2]):v=u,u=r+8|0,l[t[u>>2]+v|0]=32,v=r|0,G=t[v>>2]+1|0,t[v>>2]=G,l[t[u>>2]+G|0]=0,U(r,t[t[n>>2]+8>>2])),r=s,u=g,v=p}else{if(0==(t[i>>2]|0)){r=s,u=g,v=p}else{if(0==(t[m>>2]|0)){Z=q;break a}M=0==(t[f>>2]|0);I=c=M&1;M=M?1:p;A=g;B=(c^1)+s|0;c=1481}}}}}}}}}}}}}}}}while(0);if(1481==c){if(c=0,0==(I|0)){r=B,u=A,v=M}else{var X=M,ga=q;c=1483;break}}q=CC();if(-1==(q|0)){X=v;ga=-1;c=1483;break}else{p=v,g=u,s=r}}1463==c?(JC(123),X=p,ga=123,c=1483):1462==c?(JC(61),X=p,ga=61,c=1483):1467==c?(JC(59),X=p,ga=59,c=1483):1464==c&&(JC(125),X=p,ga=125,c=1483);if(1483==c){if(0!=(X|0)){Z=ga}else{return FC(b,0),Z=-1!=(ga|0),Z&1}}e=AC();f=b+44|0;VC(e,t[b+(t[f>>2]<<2)+48>>2]);BC(b,0);f=t[b+(t[f>>2]<<2)+48>>2];VC(f,e);xC(e);pD(f,b);Z=-1!=(Z|0);return Z&1}lD.X=1;function yD(b){if(8==(t[MC(b,2)>>2]|0)){var d=b+44|0,c=t[d>>2];t[d>>2]=0==(c|0)?2:c-1|0;FC(b,0)}DC(Mt|0)}function AD(b,d){var c,e,f=j;j+=4;var g;e=f>>2;var h=d,i=b;a:for(;;){t[e]=i;i=l[i];if(0==i<<24>>24){var m=h;g=1561;break}i=0==(L(i&255)|0);b:do{if(!i){for(;;){var n=t[e]+1|0;t[e]=n;if(0==(L(l[n]&255)|0)){break b}}}}while(0);do{if(6==(h|0)||7==(h|0)){for(var q=t[e];;){var p=l[q];if(59==p<<24>>24||0==p<<24>>24){break}var s=q+1|0,q=t[e]=s}s=59==p<<24>>24?0:h}else{if(10==(h|0)){m=10;g=1562;break a}else{if(1==(h|0)){i=t[e],47!=l[i]<<24>>24?(s=1,q=i):(c=42!=l[i-1|0]<<24>>24&1,g=1558)}else{if(5==(h|0)){for(q=t[e];;){var r=l[q];if(123==r<<24>>24||0==r<<24>>24){break}s=q+1|0;q=t[e]=s}s=123==r<<24>>24?0:5}else{if(0==(h|0)){if(0!=(oA(l[t[e]]&255)|0)){c=BD(f,1),g=1558}else{if(i=t[e],n=l[i],46==n<<24>>24){c=BD(f,0),g=1558}else{if(35==n<<24>>24){c=BD(f,2),g=1558}else{if(64==n<<24>>24){t[e]=i+1|0;g=P();i=0==(L(l[t[e]]&255)|0);c=(g|0)>>2;var n=t[c],u=g+4|0,v=(n+1|0)==(t[u>>2]|0);b:do{if(i){for(var w=g+8|0,C=v,A=n;;){C&&(R(g),A=t[c]);l[t[w>>2]+A|0]=l[t[e]];A=t[e];0!=l[A]<<24>>24&&(A=t[c]+1|0,t[c]=A,l[t[w>>2]+A|0]=0,A=t[e]);C=A+1|0;t[e]=C;var A=t[c],I=(A+1|0)==(t[u>>2]|0);if(0==(L(l[C]&255)|0)){C=I}else{var M=I,B=A;break b}}}else{M=v,B=n}}while(0);M?(R(g),c=t[c]):c=B;i=g+8|0;l[t[i>>2]+c|0]=0;c=t[i>>2];c=0==(qA(c,ur|0)|0)?5:0==(qA(c,Yv|0)|0)?6:0==(qA(c,wl|0)|0)?7:0==(qA(c,ak|0)|0)?8:0==(qA(c,qi|0)|0)?9:0;Q(g);g=1558}else{42==n<<24>>24?(c=47==l[i-1|0]<<24>>24&1,g=1558):(s=0,q=i)}}}}}else{8==(h|0)||9==(h|0)||4==(h|0)?(i=t[e],n=l[i],39==n<<24>>24?(c=2,g=1558):125==n<<24>>24?(s=0,q=i):(c=34==n<<24>>24?3:h,g=1558)):3==(h|0)?(i=t[e],34!=l[i]<<24>>24?(s=3,q=i):(c=92==l[i-1|0]<<24>>24?3:4,g=1558)):2==(h|0)?(i=t[e],39!=l[i]<<24>>24?(s=2,q=i):(c=92==l[i-1|0]<<24>>24?2:4,g=1558)):(c=h,g=1558)}}}}}}while(0);1558==g&&(g=0,s=c,q=t[e]);if(0==(q|0)){m=s;g=1563;break}else{h=s,i=q+1|0}}if(1563==g||1561==g||1562==g){return j=f,m}}AD.X=1;function BD(b,d){var c,e=b>>2,f,g=P();c=(g|0)>>2;var h=g+4|0,i=g+8|0,m=t[e];a:for(;;){if(0==(oA(l[m]&255)|0)){if(0!=(L(l[m]&255)|0)){var n=1}else{n=l[m],n=95==n<<24>>24||45==n<<24>>24||43==n<<24>>24||62==n<<24>>24||123==n<<24>>24||46==n<<24>>24||44==n<<24>>24||58==n<<24>>24||42==n<<24>>24||35==n<<24>>24?1:0}}else{n=1}var n=0==(n|0),q=l[m];do{if(n){if(0==q<<24>>24){f=1568}else{f=1577;break a}}else{if(0==q<<24>>24){f=1568}else{if(44==q<<24>>24){f=1570;break a}else{if(123==q<<24>>24){f=1571;break a}else{var p=m}}}}}while(0);if(1568==f&&(f=0,p=eC(),0==(p|0))){f=1569;break}m=t[c];(m+1|0)==(t[h>>2]|0)&&(R(g),m=t[c]);l[t[i>>2]+m|0]=l[p];0!=l[p]<<24>>24&&(m=t[c]+1|0,t[c]=m,l[t[i>>2]+m|0]=0);m=p+1|0}if(1570==f){return CD(g,d),t[e]=m+1|0,0}if(1571==f){return CD(g,d),t[e]=m+1|0,4}if(1569==f){return CD(g,d),t[e]=0,10}if(1577==f){return CD(g,d),t[e]=m,0}}BD.X=1;function CD(b,d){0==(d|0)&&DD(b);var c=b|0,e=t[c>>2];(e+1|0)==(t[b+4>>2]|0)?(R(b),c=t[c>>2]):c=e;l[t[b+8>>2]+c|0]=0;jC(b,Hz|0,d);S(b);Q(b)}function ED(){var b,d=zC(24);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=1;t[b+3]=P();t[b+4]=P();t[b+5]=P();return d}function FD(b,d){var c=b+4|0;if((t[c>>2]|0)!=(d|0)){for(;!(GD(b),(t[c>>2]|0)==(d|0));){}}}function HD(b){Q(t[b+12>>2]);Q(t[b+16>>2]);Q(t[b+20>>2]);vB(b)}function ID(b){for(var d=b|0,c=0;;){var e=t[d>>2];15==(e|0)?(GD(b),c=c+1|0):4==(e|0)?(GD(b),c=c-1|0):JD(b);if(0==(c|0)){break}}}function KD(b){var d,c;if(0==(LD(b)|0)){return 0}for(c=(b|0)>>2;!(MD(b),GD(b),7==(t[c]|0)&&GD(b),0==(LD(b)|0));){}d=(b+4|0)>>2;0==(t[d]|0)&&(GD(b),22==(t[c]|0)&&MD(b),GD(b));var e=t[c];if(16==(e|0)){e=b|0;if(5!=(t[e>>2]|0)){for(;!(GD(b),5==(t[e>>2]|0));){}}GD(b);e=t[c]}6==(e|0)&&ND(b);e=t[d];4==(e|0)?(GD(b),GD(b),d=t[d]):d=e;39==(d|0)&&(GD(b),22==(t[c]|0)&&GD(b));a:{var f;c=(b+4|0)>>2;e=t[c];if(d=34==(e|0)){GD(b),e=t[c]}if(13==(e|0)||15==(e|0)||22==(e|0)||36==(e|0)||39==(e|0)||41==(e|0)||46==(e|0)){f=1;for(d=e;;){if(36==(d|0)){d=b;GD(d);for(var e=d+4|0,g=d|0;;){var h=t[e>>2];if(15==(h|0)||41==(h|0)){break}11==(t[g>>2]|0)&&OD(d);GD(d);6==(t[g>>2]|0)&&ND(d)}}else{f=18==(d|0)?f-1|0:6==(d|0)||12==(d|0)||25==(d|0)||27==(d|0)||32==(d|0)?f+1|0:f}GD(b);if(0>=(f|0)){break}d=t[c]}}else{c=17==(t[b>>2]|0);if(d){c&&(f=1714)}else{if(c){f=1714}else{break a}}1714==f&&GD(b);GD(b)}}return 1}KD.X=1;function LD(b){var d=b+4|0;26==(t[d>>2]|0)&&GD(b);var c=b|0;if(11==(t[c>>2]|0)){b=1}else{if(d=t[d>>2],4==(d|0)){b=1}else{if(30!=(d|0)&&43!=(d|0)){b=0}else{return GD(b),22==(t[c>>2]|0)&1}}}return b}function MD(b){var d,c,e,f=j;j+=80;e=f>>2;if(0!=(t[Cz+16>>2]|0)&&(c=b+8|0,0!=(t[oy+8>>2]|t[c>>2]|0))){var g=b+12|0;sC(f,t[t[g>>2]+8>>2]);t[e+4]=0==(t[c>>2]|0)&1;t[e+9]=t[Cz+24>>2];l[f+40|0]=t[Cz+20>>2]&255;t[e+15]=t[Cz+8>>2];c=b+16|0;t[e+16]=t[t[c>>2]+8>>2];tC(f);if(0!=(t[oy+4>>2]|0)){var h=PD(t[t[c>>2]+8>>2]);c=(h|0)>>2;d=t[c];if((d+1|0)==(t[h+4>>2]|0)){R(h);var i=t[c]}else{i=d}d=(h+8|0)>>2;l[t[d]+i|0]=46;i=t[c]+1|0;t[c]=i;l[t[d]+i|0]=0;U(h,t[t[g>>2]+8>>2]);t[e+8]=t[d];tC(f);Q(h)}}V(t[b+20>>2],t[t[b+12>>2]+8>>2]);j=f}MD.X=1;function ND(b){GD(b);var d=t[b>>2];(1==(d|0)||19==(d|0))&&GD(b);JD(b)}function GD(b){var d,c;d=(b|0)>>2;t[d]=0;var e=b+4|0;t[e>>2]=-1;b=(b+12|0)>>2;for(S(t[b]);;){var f=T();if(92==(f|0)){c=1761;break}else{if(34==(f|0)){c=1765;break}else{if(39==(f|0)){c=1766;break}else{if(36==(f|0)){c=1729;break}else{if(41==(f|0)){c=1727;break}else{if(32==(f|0)||10==(f|0)||9==(f|0)){continue}else{if(62==(f|0)){c=1753;break}else{if(46==(f|0)){c=1730;break}else{if(63==(f|0)||58==(f|0)){c=1742;break}else{if(93==(f|0)){c=1726;break}else{if(33==(f|0)){c=1724;break}else{if(125==(f|0)){c=1725;break}else{if(126==(f|0)){c=1734;break}else{if(44==(f|0)){c=1728;break}else{if(-1==(f|0)){c=1722;break}else{if(59==(f|0)){c=1723;break}else{if(40==(f|0)){c=1733;break}else{if(91==(f|0)){c=1732;break}else{if(43==(f|0)||42==(f|0)||94==(f|0)||61==(f|0)){c=1735;break}else{if(47==(f|0)){c=1757;break}else{if(60==(f|0)){c=1749;break}else{if(123==(f|0)){c=1731;break}else{if(45!=(f|0)){c=1767;break}}}}}}}}}}}}}}}}}}}}}}}var g=T();if(62==(g|0)){c=1737;break}else{if(45!=(g|0)){c=1739;break}}QD(10)}if(1739==c){0==(L(g)|0)&&W(g),t[d]=17}else{if(1761==c){var h=T();92!=(h|0)&&0==(L(h)|0)&&W(h);t[d]=17}else{if(1765==c){t[d]=22,RD(t[b])}else{if(1766==c){t[d]=2,37==(T()|0)&&SD(),39!=(T()|0)&&QD(10)}else{if(1729==c){t[d]=10}else{if(1727==c){t[d]=5}else{if(1753==c){h=T(),1<(h-61|0)>>>0&&0==(L(h)|0)&&W(h),t[d]=17}else{if(1730==c){t[d]=9}else{if(1742==c){h=T(),61==(h|0)?t[d]=17:(0==(L(h)|0)&&W(h),t[d]=58==(f|0)?6:19)}else{if(1726==c){t[d]=4}else{if(1724==c){t[d]=1}else{if(1725==c){t[d]=3}else{if(1734==c){t[d]=23}else{if(1767==c){if(0!=(pA(f)|0)){TD(t[b],f),h=UD(t[b],t[Oy>>2]),t[e>>2]=h,t[d]=-1==(h|0)?11:12}else{if(10>(f-48|0)>>>0){h=VD(f),U(t[b],t[h+8>>2]),Q(h),t[d]=13}else{if(124==(f|0)||64==(f|0)||38==(f|0)||35==(f|0)){b=t[b];c=(b|0)>>2;g=b+4|0;for(e=(b+8|0)>>2;;){if(h=t[c],(h+1|0)==(t[g>>2]|0)&&(R(b),h=t[c]),l[t[e]+h|0]=f&255,0!=(f|0)&&(h=t[c]+1|0,t[c]=h,l[t[e]+h|0]=0),h=T(),32<(h|0)){f=h}else{break}}f=t[c];(f+1|0)==(t[g>>2]|0)&&(R(b),f=t[c]);l[t[e]+f|0]=0;0==(L(h)|0)&&W(h);t[d]=17}else{t[d]=0}}}}else{1728==c?t[d]=7:1722==c?dB(tz|0,1):1723==c?t[d]=20:1733==c?t[d]=16:1732==c?t[d]=15:1735==c?t[d]=17:1757==c?(h=T(),!(61==(h|0)||47==(h|0))&&0==(L(h)|0)&&W(h),t[d]=17):1737==c?t[d]=8:1749==c?(h=T(),1<(h-61|0)>>>0&&0==(L(h)|0)&&W(h),t[d]=17):1731==c&&(t[d]=14)}}}}}}}}}}}}}}}GD.X=1;function OD(b){var d,c,e,f=j;j+=80;e=f>>2;if(0!=(t[Cz+32>>2]|0)&0!=(t[oy+8>>2]|0)){c=t[t[b+12>>2]+8>>2];var g=P();sC(f,c);t[e+4]=1;t[e+9]=t[Cz+40>>2];l[f+40|0]=t[Cz+36>>2]&255;V(g,t[t[b+16>>2]+8>>2]);c=(g|0)>>2;d=t[c];if((d+1|0)==(t[g+4>>2]|0)){R(g);var h=t[c]}else{h=d}d=(g+8|0)>>2;l[t[d]+h|0]=46;h=t[c]+1|0;t[c]=h;l[t[d]+h|0]=0;U(g,t[t[b+20>>2]+8>>2]);t[e+15]=t[Cz+24>>2];t[e+16]=t[d];tC(f);Q(g)}j=f}OD.X=1;function JD(b){var d,c,e=ED();c=e>>2;WD(e,b);GD(b);d=(b|0)>>2;6==(t[d]|0)&&(GD(e),GD(b));var f=t[c+1];if(35==(f|0)){if(11!=(t[d]|0)&&11!=(t[b+4>>2]|0)){HD(e);return}GD(b)}else{if(5==(f|0)||14==(f|0)||20==(f|0)){WD(e,b),GD(b)}11==(t[c]|0)&&(15==(t[d]|0)?ID(b):0==(qA(fi|0,t[t[c+3]+8>>2])|0)&&GD(b))}HD(e)}function WD(b,d){var c=d>>2,e=b>>2;t[e]=t[c];t[e+1]=t[c+1];t[e+2]=t[c+2];V(t[e+3],t[t[c+3]+8>>2]);V(t[e+4],t[t[c+4]+8>>2]);V(t[e+5],t[t[c+5]+8>>2])}function QD(b){for(;;){var d=T();if(-1==(d|0)|(d|0)==(b|0)){break}}}function RD(b){var d,c,e,f,g,h,i,m=P(),n=P();h=(n+8|0)>>2;g=(m+8|0)>>2;f=(m|0)>>2;var q=m+4|0;e=(b+8|0)>>2;c=(b|0)>>2;var p=b+4|0;d=(n|0)>>2;var s=n+4|0,r=0,u=0,v=0;a:for(;;){var v=91==(v|0),w=0;b:for(;;){for(var C=0==(r|0),A=w;;){if(0!=(A|0)){break a}A=T();if(10==(A|0)){i=1866;break b}else{if(37==(A|0)){i=1874;break b}else{if(-1==(A|0)){A=1;continue}else{if(34!=(A|0)){var I=u,M=r,B=A;break b}}}}if(C){r=0;w=1;continue b}if(A=0==(qA(t[h],t[g])|0)){A&=1}else{I=u;M=r;B=34;break b}}}b:do{if(1866==i){if(i=0,C||S(n),v?(S(m),S(n),w=t[f],(w+1|0)==(t[q>>2]|0)&&(R(m),w=t[f]),l[t[g]+w|0]=93,w=t[f]+1|0,t[f]=w,l[t[g]+w|0]=0,gD(m,t[e],t[c]-1|0),S(b),A=w=1):(w=r,A=u),0==(w|0)|0==(A|0)){I=A,M=w,B=10}else{for(;;){var G=T();if(0==(L(G)|0)){I=A;M=w;B=G;break b}}}}else{1874==i&&(i=0,I=u,M=r,B=SD())}}while(0);u=t[c];(u+1|0)==(t[p>>2]|0)?(R(b),v=t[c]):v=u;u=B&255;l[t[e]+v|0]=u;v=0==(B|0);v||(r=t[c]+1|0,t[c]=r,l[t[e]+r|0]=0);0==(M|0)?r=0:(r=t[d],(r+1|0)==(t[s>>2]|0)&&(R(n),r=t[d]),l[t[h]+r|0]=u,v||(u=t[d]+1|0,t[d]=u,l[t[h]+u|0]=0),u=t[d],(u+1|0)==(t[s>>2]|0)&&(R(n),u=t[d]),l[t[h]+u|0]=0,r=M);u=I;v=B}d=t[c];(d+1|0)!=(t[p>>2]|0)?(e=t[e],e=e+d|0):(R(b),b=t[c],e=t[e],e=e+b|0);l[e]=0;Q(n);Q(m)}RD.X=1;function TD(b,d){var c,e;e=(b|0)>>2;var f=b+4|0;c=(b+8|0)>>2;for(var g=d;;){var h=t[e];(h+1|0)==(t[f>>2]|0)&&(R(b),h=t[e]);l[t[c]+h|0]=g&255;0!=(g|0)&&(g=t[e]+1|0,t[e]=g,l[t[c]+g|0]=0);h=T();if(0!=(oA(h)|0)|95==(h|0)){g=h}else{break}}g=t[e];(g+1|0)==(t[f>>2]|0)?(R(b),e=t[e]):e=g;l[t[c]+e|0]=0;0==(L(h)|0)&&W(h)}TD.X=1;function VD(b){var d,c=P();d=c>>2;b=XD(b);V(c,t[b+8>>2]);Q(b);b=T();if(46==(b|0)){var e=XD(0),b=(c|0)>>2,f=t[b];if((f+1|0)==(t[d+1]|0)){R(c);var g=t[b]}else{g=f}f=c+8|0;l[t[f>>2]+g|0]=46;g=t[b]+1|0;t[b]=g;l[t[f>>2]+g|0]=0;U(c,t[e+8>>2]);Q(e);f=T()}else{f=b}if(101==(rA(f)|0)){e=XD(0);b=(c|0)>>2;g=t[b];if((g+1|0)==(t[d+1]|0)){R(c);var h=t[b]}else{h=g}g=c+8|0;l[t[g>>2]+h|0]=f&255;0!=(f|0)&&(f=t[b]+1|0,t[b]=f,l[t[g>>2]+f|0]=0);U(c,t[e+8>>2]);Q(e)}else{0==(L(f)|0)&&W(f)}e=c|0;b=t[e>>2];if((b+1|0)!=(t[d+1]|0)){return d=t[(c+8|0)>>2],d=d+b|0,l[d]=0,c}R(c);b=t[e>>2];d=t[(c+8|0)>>2];d=d+b|0;l[d]=0;return c}VD.X=1;function XD(b){var d,c,e=P(),b=0==(b|0)?T():b;if(45==(b|0)){b=(e|0)>>2;d=t[b];if((d+1|0)==(t[e+4>>2]|0)){R(e);var f=t[b]}else{f=d}d=e+8|0;l[t[d>>2]+f|0]=45;f=t[b]+1|0;t[b]=f;l[t[d>>2]+f|0]=0;var g=T()}else{g=10>(b-48|0)>>>0?b:T()}d=(e|0)>>2;f=e+4|0;for(b=(e+8|0)>>2;;){if(-1==(g|0)){c=1953;break}var h=t[d],i=(h+1|0)==(t[f>>2]|0);if(!(95==(g|0)|10>(g-48|0)>>>0)){c=1960;break}if(i){R(e);var m=t[d]}else{m=h}l[t[b]+m|0]=g&255;0!=(g|0)&&(g=t[d]+1|0,t[d]=g,l[t[b]+g|0]=0);g=T()}if(1953==c){var n=t[d];if((n+1|0)==(t[f>>2]|0)){n=-1}else{return c=t[b],h=c+n|0,l[h]=0,W(-1),e}}else{if(1960==c){if(i){n=g}else{return c=t[b],h=c+h|0,l[h]=0,W(g),e}}}R(e);h=t[d];c=t[b];h=c+h|0;l[h]=0;W(n);return e}XD.X=1;function SD(){var b=T();if(72==(b|0)){b=92}else{if(66==(b|0)){b=8}else{if(82==(b|0)){b=13}else{if(81==(b|0)){b=96}else{if(76==(b|0)){b=126}else{if(70==(b|0)){b=12}else{if(86==(b|0)){b=124}else{if(84==(b|0)){b=9}else{if(41==(b|0)){b=93}else{if(62==(b|0)){b=125}else{if(65==(b|0)){b=64}else{if(78==(b|0)){b=10}else{if(83==(b|0)){b=35}else{if(37!=(b|0)&&39!=(b|0)){if(68==(b|0)){b=36}else{if(60==(b|0)){b=123}else{if(34!=(b|0)){if(10==(b|0)){QD(37),b=0}else{if(40==(b|0)){b=91}else{if(47==(b|0)){var b=XD(0),d;for(d=t[b+8>>2];L(l[d]);){d++}var c=1;45==l[d]?(c=-1,d++):43==l[d]&&d++;var e=10;!e&&48==l[d]&&(120==l[d+1]||88==l[d+1]?(e=16,d+=2):(e=8,d++));e||(e=10);for(var f,g=0;0!=(f=l[d])&&!(f=parseInt(String.fromCharCode(f),e),isNaN(f));){g=g*e+f,d++}g*=c;if(2147483647<g||-2147483648>g){g=2147483647<g?2147483647:-2147483648,FA(DA)}d=g;Q(b);return 47==(T()|0)&256>d>>>0?d:0}b=67==(b|0)?94:0}}}}}}}}}}}}}}}}}}}return b}function YD(b,d){var c;S(d);var e=0==((0!=(oA(l[b]&255)|0)|95==(l[b]&255|0)|58==(l[b]&255|0))&1|0);c=(d|0)>>2;var f=t[c],g=d+4|0,h=(f+1|0)==(t[g>>2]|0);a:do{if(e){var i=b,m=h,n=f}else{for(var q=d+8|0,p=b,s=h,r=f;;){if(s&&(R(d),r=t[c]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[g>>2]|0),0==((0!=(oA(l[p]&255)|0)|95==(l[p]&255|0)|58==(l[p]&255|0))&1|0)){i=p;m=s;n=r;break a}}}}while(0);if(!m){return c=t[(d+8|0)>>2],n=c+n|0,l[n]=0,i}R(d);n=t[c];c=t[(d+8|0)>>2];n=c+n|0;l[n]=0;return i}YD.X=1;function ZD(b,d){var c=P();YD(b,c);jC(c,Az|0,d);Q(c)}function $D(){var b,d,c,e=P(),f=eC();if(0!=(f|0)){c=(e|0)>>2;d=(e+4|0)>>2;for(b=(e+8|0)>>2;;){do{if(35!=l[f]<<24>>24){if(0==(N(f,Cf|0,8)|0)){var g=aE(f+8|0),h=0==(bE(l[g]&255)|0),i=t[c],m=(i+1|0)==(t[d]|0);a:do{if(h){var n=m,q=i}else{for(var p=g,s=m,r=i;;){if(s&&(R(e),r=t[c]),l[t[b]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[b]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[d]|0),0==(bE(l[p]&255)|0)){n=s;q=r;break a}}}}while(0);n?(R(e),g=t[c]):g=q;l[t[b]+g|0]=0;jC(e,nz|0,1);S(e)}else{if(0==(N(f,Fi|0,5)|0)){g=aE(f+5|0);h=0==(bE(l[g]&255)|0);i=t[c];m=(i+1|0)==(t[d]|0);a:do{if(h){var u=m,v=i}else{p=g;s=m;for(r=i;;){if(s&&(R(e),r=t[c]),l[t[b]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[b]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[d]|0),0==(bE(l[p]&255)|0)){u=s;v=r;break a}}}}while(0);u?(R(e),g=t[c]):g=v;l[t[b]+g|0]=0;jC(e,nz|0,0);S(e)}else{if(0==(N(f,Uj|0,4)|0)){g=aE(f+4|0);h=0==(bE(l[g]&255)|0);i=t[c];m=(i+1|0)==(t[d]|0);a:do{if(h){var w=m,C=i}else{p=g;s=m;for(r=i;;){if(s&&(R(e),r=t[c]),l[t[b]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[b]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[d]|0),0==(bE(l[p]&255)|0)){w=s;C=r;break a}}}}while(0);w?(R(e),g=t[c]):g=C;l[t[b]+g|0]=0;jC(e,nz|0,4);S(e)}}}}}while(0);f=eC();if(0==(f|0)){break}}}Q(e)}$D.X=1;function aE(b){for(;0!=(L(l[b]<<24>>24)|0);){b=b+1|0}return b}function bE(b){return(95==(b|0)|0!=(oA(b)|0))&1}function cE(){var b,d=zC(36);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+6]=0;t[b+8]=0;t[b+7]=0;t[b+4]=t[K+48>>2];t[b+5]=t[K+24>>2];return d}function dE(b){Q(t[b+8>>2]);Q(t[b+12>>2]);vB(b)}function eE(b){var d,c=cE(),e=cE();Y(b);var f=b+4|0;if(23==(t[f>>2]|0)){for(var g=b|0;;){Y(b);var h=t[g>>2];if(23==(h|0)){d=2104;break}else{if(20==(h|0)){d=2103;break}else{if(21==(h|0)){d=2120;break}}}}if(2104==d){Y(b);f=(b|0)>>2;22!=(t[f]|0)?fE(b):(Y(b),15==(t[f]|0)&&(Y(b),24==(t[b+4>>2]|0)&&(Y(b),17==(t[f]|0)&&(fE(b),18==(t[f]|0)&&(Y(b),18==(t[f]|0)&&Y(b))))));Y(b);if(20!=(t[g>>2]|0)){dE(c);dE(e);return}Y(b);Y(b);dE(c);dE(e);return}if(2103==d){Y(b);Y(b);dE(c);dE(e);return}if(2120==d){dE(c);dE(e);return}}gE(e,b);Y(b);g=b|0;d=c+8|0;for(var h=e+8|0,i=1,m=t[g>>2];;){i=23==(m|0)?0:i;a:do{if(19==(m|0)){eE(b)}else{if(22==(m|0)){hE(b)}else{do{if(0!=(i|0)&&2>(t[f>>2]-21|0)>>>0){var n=0==(t[t[d>>2]>>2]|0);Y(b);if(!n){break a}Y(b);gE(c,b);iE(c,t[h>>2]);n=c;if(0==(t[n+28>>2]|0)){var m=P(),q=t[n+12>>2];0==(t[q>>2]|0)?V(m,t[t[n+8>>2]+8>>2]):(V(m,t[q+8>>2]),U(m,Xi|0),U(m,t[t[n+8>>2]+8>>2]));var q=m|0,p=t[q>>2];(p+1|0)==(t[m+4>>2]|0)?(R(m),q=t[q>>2]):q=p;l[t[m+8>>2]+q|0]=0;jE(n,5);Q(m)}break a}}while(0)}}Y(b)}while(0);n=t[g>>2];if(1<(n-20|0)>>>0){m=n}else{break}}20==(n|0)&&(Y(b),Y(b));dE(c);dE(e)}eE.X=1;function fE(b){var d,c,e;c=(b|0)>>2;for(d=(b+4|0)>>2;;){Y(b);var f=t[c];22==(f|0)&&(Y(b),f=t[c]);if(19==(f|0)){eE(b)}else{if(20==(f|0)){break}else{if(6==(f|0)){f=t[d];if(18==(f|0)||17==(f|0)||27==(f|0)){Y(b),f=t[d]}if(18==(f|0)||17==(f|0)||27==(f|0)){Y(b),f=t[d]}0==(f|0)?kE(b):lE(b)}else{if(18==(f|0)){if(Y(b),18==(t[c]|0)&&(Y(b),23==(t[c]|0))){e=2142;break}}else{lE(b)}}}}}2142!=e&&(Y(b),Y(b))}function kE(b){var d,c=cE();0==(t[b+4>>2]|0)&&Y(b);gE(c,b);Y(b);d=(b|0)>>2;var e=t[d];7==(e|0)&&(mE(b),e=t[d]);4==(e|0)?(Y(b),Y(b),d=t[d]):d=e;12==(d|0)&&(nE(b),oE(c));pE(b);dE(c)}function lE(b){if(6==(t[b>>2]|0)){var d=t[b+4>>2];11==(d|0)||12==(d|0)||14==(d|0)||15==(d|0)||16==(d|0)?b=qE(b):(13==(d|0)?rE(b):8==(d|0)||9==(d|0)||10==(d|0)?sE(b):tE(b),b=1)}else{b=tE(b)}return b}function sE(b){var d=b+4|0,c=t[d>>2];if(10==(c|0)){Y(b),c=b|0,12==(t[c>>2]|0)?nE(b):lE(b),Y(b),9==(t[d>>2]|0)&&(Y(b),7==(t[c>>2]|0)&&mE(b))}else{if(8==(c|0)||9==(c|0)){Y(b),d=b|0,c=t[d>>2],7==(c|0)?(mE(b),d=t[d>>2]):d=c,12==(d|0)?nE(b):lE(b)}}}function qE(b){var d,c,e=b+4|0;for(d=(b|0)>>2;;){Y(b);11==(t[e>>2]|0)&&Y(b);var f=t[d];7==(f|0)&&(mE(b),f=t[d]);if(12==(f|0)){c=2188;break}pE(b);if(13==(t[d]|0)){var g=0;break}Y(b);if(13==(t[d]|0)){g=0;break}if(12!=(t[e>>2]|0)){g=1;break}}2188==c&&(nE(b),g=1);return g}function rE(b){var d;Y(b);d=(b|0)>>2;var c=t[d];7==(c|0)&&(mE(b),c=t[d]);if(12==(c|0)){for(;!(Y(b),c=t[d],21==(c|0)||20==(c|0)||13==(c|0)||23==(c|0));){}}}function Y(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+16|0)>>2;b=(b+20|0)>>2;a:for(;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(40==(h|0)){f=2203;break}else{if(63==(h|0)){f=2214;break}else{if(46==(h|0)){f=2207;break}else{if(125==(h|0)){f=2210;break}else{if(62==(h|0)){f=2258;break}else{if(33==(h|0)){f=2259;break}else{if(41==(h|0)){f=2204;break}else{if(-1==(h|0)){f=2202;break}else{if(93==(h|0)){f=2213;break}else{if(32==(h|0)||10==(h|0)||9==(h|0)){continue}else{if(92==(h|0)){f=2216;break}else{if(44==(h|0)){f=2206;break}else{if(91==(h|0)){f=2212;break}else{if(61==(h|0)){f=2211;break}else{if(58==(h|0)){f=2208;break}else{if(39==(h|0)||34==(h|0)){f=2215;break}else{if(47==(h|0)){var i=T();if(47==(i|0)){uE(10);continue}else{if(62==(i|0)){f=2225;break}else{if(42!=(i|0)){f=2221;break}}}for(;;){uE(42);var m=T();if(47==(m|0)){continue a}W(m);if(-1==(m|0)||0==(m|0)){continue a}}}else{if(123==(h|0)){f=2209;break}else{if(59==(h|0)){f=2205;break}else{if(60!=(h|0)){f=2260;break}}}}}}}}}}}}}}}}}}}}var n=T();if(115==(n|0)||109==(n|0)||102==(n|0)){f=2236;break}else{if(47==(n|0)){f=2246;break}else{if(33!=(n|0)){f=2227;break}}}var q=T();if(45!=(q|0)){f=2229;break}var p=T();if(45!=(p|0)){f=2231;break}for(;;){uE(45);m=T();if(45==(m|0)){break}W(m);if(-1==(m|0)||0==(m|0)){continue a}}m=T();62!=(m|0)&&(W(m),W(45))}if(2203==f){t[e]=7}else{if(2214==f){t[e]=24}else{if(2207==f){t[e]=11}else{if(2229==f){W(q),W(33),t[e]=22,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2210==f){t[e]=13}else{if(2258==f){t[e]=23,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2259==f){t[e]=15}else{if(2236==f){g=T();if(109==(n|0)||102==(n|0)){if(120!=(g|0)){W(g);W(n);t[e]=22;t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}if(109==(n|0)||102==(n|0)){g=T();58==(g|0)?t[e]=19:(W(g),W(120),W(n),t[e]=22);t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}}else{if(115==(n|0)&&58==(g|0)){t[e]=19;t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}}W(g);W(n);t[e]=22;t[d]=t[K+48>>2];t[b]=t[K+24>>2]}else{if(2204==f){t[e]=2}else{if(2202==f){dB(sz|0,1)}else{if(2213==f){t[e]=18}else{if(2227==f){W(n),t[e]=22,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2216==f){g=T(),!(92==(g|0)||34==(g|0))&&0==(L(g)|0)&&W(g),t[e]=1,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2206==f){t[e]=5}else{if(2212==f){t[e]=17}else{if(2211==f){t[e]=14}else{if(2231==f){W(p),W(45),W(33),t[e]=22,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2208==f){t[e]=4}else{if(2215==f){t[e]=10,vE(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2209==f){t[e]=12}else{if(2225==f){t[e]=21,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2221==f){W(i),t[e]=16,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2205==f){t[e]=3}else{if(2246==f){var g=T(),s=115==(g|0);if(115==(g|0)||109==(g|0)||102==(g|0)){c=T();if(109==(g|0)||102==(g|0)){if(120!=(c|0)){W(c);W(g);t[e]=22;t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}}else{if(120!=(c|0)){s&58==(c|0)?t[e]=20:(W(c),W(g),t[e]=22);t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}}s=T();58==(s|0)?t[e]=20:(W(s),W(c),W(g),t[e]=22)}else{W(g),W(47),t[e]=22}t[d]=t[K+48>>2];t[b]=t[K+24>>2]}else{if(2260==f){if(0==(wE(h)|0)){t[e]=0}else{f=t[c];i=(f|0)>>2;q=f+4|0;for(n=(f+8|0)>>2;!(s=t[i],(s+1|0)==(t[q>>2]|0)&&(R(f),s=t[i]),l[t[n]+s|0]=h&255,0!=(h|0)&&(s=t[i]+1|0,t[i]=s,l[t[n]+s|0]=0),s=T(),0==(wE(s)|0));){h=s}h=t[i];(h+1|0)==(t[q>>2]|0)&&(R(f),h=t[i]);l[t[n]+h|0]=0;0==(L(s)|0)&&W(s);t[d]=t[K+48>>2];t[b]=t[K+24>>2];d=UD(t[c],t[Ky>>2]);t[g>>2]=d;t[e]=-1==(d|0)?9:6}}}}}}}}}}}}}}}}}}}}}}}}}}}Y.X=1;function tE(b){var d,c,e,f,g=cE(),h=cE(),i=P();S(i);e=(b+12|0)>>2;V(i,t[t[e]+8>>2]);c=(b+4|0)>>2;d=t[c];if(17==(d|0)){Y(b);var m=1;d=t[c]}else{m=0}18==(d|0)&&(Y(b),d=t[c]);19==(d|0)&&Y(b);d=(b|0)>>2;if(6==(t[d]|0)){var n=t[c];if(20==(n|0)){return e=cE(),f=P(),c=(b+32|0)>>2,g=t[c],S(f),h=b+12|0,V(f,t[t[h>>2]+8>>2]),20==(t[b+4>>2]|0)&&Y(b),t[c]=1,iE(b,t[b+8>>2]),gE(e,b),Y(b),12==(t[b>>2]|0)&&(xE(e),nE(b)),V(t[h>>2],t[f+8>>2]),t[c]=g,dE(e),Q(f),1}if(13==(n|0)){rE(b);var q=1}else{if(0==(n|0)){return kE(b),1}if(5==(n|0)){c=m;e=cE();f=cE();g=P();S(g);h=b+12|0;V(g,t[t[h>>2]+8>>2]);5==(t[b+4>>2]|0)&&Y(b);gE(e,b);Y(b);var i=b|0,p=t[i>>2];if(4==(p|0)){Y(b),Y(b),q=2379}else{var s=p}for(;;){2379==q&&(s=t[i>>2]);if(3==(s|0)){break}Y(b);q=2379}0!=(c|0)&&jE(e,4);V(t[h>>2],t[g+8>>2]);dE(e);dE(f);Q(g);return 1}8==(n|0)||9==(n|0)||10==(n|0)?(sE(b),q=1):11==(n|0)||12==(n|0)||14==(n|0)||15==(n|0)||16==(n|0)?q=qE(b):(Y(b),q=1)}}else{q=1}gE(g,b);s=g+8|0;m=0;a:for(;;){p=m;for(m=t[d];;){if(14==(m|0)){f=2336;break a}else{if(3==(m|0)){var r=q;break a}else{if(13==(m|0)){f=2363;break a}}}Y(b);m=t[d];n=11==(m|0);b:do{if(n){for(var u=p;;){Y(b);var v=t[c];do{if(-1==(v|0)){if(0==(u|0)){var w=b,C=ba,C=(g+8|0)>>2,A=t[C];0!=(t[A>>2]|0)&&(U(A,Xi|0),A=t[C]);U(A,t[t[w+8>>2]+8>>2]);A=t[C];w=t[A>>2];(w+1|0)!=(t[A+4>>2]|0)?C=A:(R(A),C=w=t[C],w=t[w>>2]);C=C+8|0;C=t[C>>2];C=C+w|0;C=l[C]=0}else{V(i,t[t[e]+8>>2]),iE(b,t[s>>2]),C=u}}else{if(4==(v|0)){if(xE(g),Y(b),C=t[d],14==(C|0)){if(Y(b),12==(t[d]|0)){f=2328;break a}else{C=1}}else{if(11==(C|0)){if(Y(b),-1==(t[c]|0)){f=2326;break a}else{C=1}}else{C=1}}}else{C=u}}}while(0);Y(b);u=t[d];if(11==(u|0)){u=C}else{var I=C,M=u;break b}}}else{I=p,M=m}}while(0);7==(M|0)?(mE(b),m=t[d]):m=M;4==(m|0)&&(Y(b),Y(b),m=t[d]);if(17==(m|0)){break}else{p=I}}m=b;n=m|0;if(17==(t[n>>2]|0)){Y(m);for(v=1;!(u=t[n>>2],v=(17==(u|0)&1)+v|0,v=((18==(u|0)&0<(v|0))<<31>>31)+v|0,Y(m),!(0!=(v|0)|18!=(u|0)));){}}m=I}a:do{if(2336==f){Y(b);r=t[c];do{if(0==(r|0)){Y(b);-1==(t[c]|0)?7==(t[d]|0)?f=2341:(gE(h,b),Y(b),f=2340):f=2340;if(2340==f){if(I=t[d],7==(I|0)){f=2341}else{var B=I}}2341==f&&(mE(b),B=t[d]);if(12==(B|0)){if(0==(t[b+32>>2]|0)){nE(b);oE(g);if(0==(t[t[h+8>>2]>>2]|0)){r=q;break a}oE(h);r=q;break a}jE(g,2);0!=(t[t[h+8>>2]>>2]|0)&&oE(h);nE(b)}I=q}else{I=t[d],12==(I|0)?(yE(b,g),I=13==(t[d]|0)?1:q):(7==(I|0)?(mE(b),12==(t[d]|0)&&(jE(g,2),nE(b))):6==(r|0)&&(Y(b),I=t[c],4>I>>>0&&(Y(b),M=t[d],7==(M|0)&&(mE(b),M=t[d]),3==(M|0)&&0==(t[b+24>>2]|0)&&(0==(p|0)&1<(I-2|0)>>>0?oE(g):xE(g)))),I=q)}}while(0);pE(b);r=I}else{2326==f?(V(i,t[t[e]+8>>2]),iE(b,t[s>>2]),jE(b,2),r=b+28|0,t[r>>2]=1,pE(b),t[r>>2]=0,r=1):2328==f?(yE(b,g),pE(b),t[b+28>>2]=0,r=1):2363==f&&(r=0)}}while(0);V(t[e],t[i+8>>2]);dE(g);dE(h);Q(i);return r}tE.X=1;function gE(b,d){var c=d>>2,e=b>>2;t[e+6]=t[c+6];t[e+4]=t[c+4];t[e+5]=t[c+5];t[e]=t[c];t[e+1]=t[c+1];t[e+8]=t[c+8];V(t[e+2],t[t[c+2]+8>>2]);V(t[e+3],t[t[c+3]+8>>2])}function iE(b,d){var c;c=(b+12|0)>>2;var e=t[c];0!=(t[e>>2]|0)&&(U(e,Xi|0),e=t[c]);U(e,t[d+8>>2]);var f=t[c],e=t[f>>2];(e+1|0)!=(t[f+4>>2]|0)?(f=f+8|0,f=t[f>>2],c=f+e|0):(R(f),e=t[c],c=t[e>>2],f=e+8|0,f=t[f>>2],c=f+c|0);l[c]=0}function xE(b){if(0==(t[b+28>>2]|0)){var d=P(),c=t[b+12>>2];0==(t[c>>2]|0)?V(d,t[t[b+8>>2]+8>>2]):(V(d,t[c+8>>2]),U(d,Xi|0),U(d,t[t[b+8>>2]+8>>2]));var c=d|0,e=t[c>>2];(e+1|0)==(t[d+4>>2]|0)?(R(d),c=t[c>>2]):c=e;e=d+8|0;l[t[e>>2]+c|0]=0;0==(zE(t[Rz>>2],t[e>>2])|0)&&(AE(t[Rz>>2],BE(d)),jE(b,1));Q(d)}}xE.X=1;function jE(b,d){if(0!=(t[kz+(d<<4)>>2]|0)&&0==(t[b+28>>2]|0)){var c=0==(d|0)?0==(t[b+32>>2]|0)?0:2:d,e=b+12|0;if(0!=(t[t[e>>2]>>2]|0)){var f=P();V(f,t[t[e>>2]+8>>2]);U(f,Xi|0);e=b+8|0;U(f,t[t[e>>2]+8>>2]);var g=f|0,h=t[g>>2];(h+1|0)==(t[f+4>>2]|0)?(R(f),g=t[g>>2]):g=h;h=f+8|0;l[t[h>>2]+g|0]=0;V(t[e>>2],t[h>>2]);Q(f)}e=j;j+=80;f=e>>2;0!=(t[kz+(c<<4)>>2]|0)&&0==(t[b+28>>2]|0)&&(sC(e,t[t[b+8>>2]+8>>2]),t[f+1]=t[b+16>>2],t[f+2]=t[b+20>>2],t[f+9]=t[kz+(c<<4)+8>>2],l[e+40|0]=t[kz+(c<<4)+4>>2]&255,tC(e));j=e}}jE.X=1;function pE(b){for(var d=b|0;;){var c=t[d>>2];if(13==(c|0)||3==(c|0)){break}else{7==(c|0)?mE(b):12==(c|0)?nE(b):Y(b)}}}function yE(b,d){var c,e,f=cE();c=(b|0)>>2;for(var g=b+4|0,h=d+8|0;;){Y(b);e=10==(t[c]|0)?2434:-1==(t[g>>2]|0)?2434:2441;if(2434==e){e=0;gE(f,b);Y(b);var i=t[c];if(4!=(i|0)){var m=i}else{Y(b),0!=(t[g>>2]|0)?(iE(f,t[h>>2]),jE(f,3),Y(b)):(Y(b),e=t[c],7==(e|0)&&(mE(b),e=t[c]),12==(e|0)&&(iE(f,t[h>>2]),jE(f,2),nE(b),Y(b))),e=2441}}2441==e&&(m=t[c]);if(5!=(m|0)){break}}pE(b);dE(f)}yE.X=1;function mE(b){var d=b|0;if(7==(t[d>>2]|0)){Y(b);for(var c=1;;){var e=t[d>>2],c=(7==(e|0)&1)+c|0,c=((2==(e|0)&0<(c|0))<<31>>31)+c|0;Y(b);if(!(0!=(c|0)|2!=(e|0))){break}}}}function oE(b){if(0==(t[b+28>>2]|0)){var d=P(),c=t[b+12>>2];0==(t[c>>2]|0)?V(d,t[t[b+8>>2]+8>>2]):(V(d,t[c+8>>2]),U(d,Xi|0),U(d,t[t[b+8>>2]+8>>2]));var c=d|0,e=t[c>>2];(e+1|0)==(t[d+4>>2]|0)?(R(d),c=t[c>>2]):c=e;e=d+8|0;l[t[e>>2]+c|0]=0;0==(zE(t[fz>>2],t[e>>2])|0)&&(AE(t[fz>>2],BE(d)),jE(b,0));Q(d)}}oE.X=1;function nE(b){var d,c,e,f=P();S(f);V(f,t[t[b+12>>2]+8>>2]);c=(b+24|0)>>2;t[c]=t[c]+1|0;d=(b|0)>>2;e=t[d];if(12==(e|0)){if(-1!=(t[b+4>>2]|0)){var g=1,h=12;e=2472}else{Y(b);var i=t[d];e=2471}}else{i=e,e=2471}2471==e&&13!=(i|0)&&(g=1,h=i,e=2472);a:do{if(2472==e){for(;;){12==(h|0)?nE(b):g=lE(b);if(0==(g|0)){break a}Y(b);h=t[d];if(13==(h|0)){break a}else{e=2472}}}}while(0);Q(f);t[c]=t[c]-1|0}function hE(b){var d;d=(b|0)>>2;var c=t[d];22==(c|0)&&(Y(b),c=t[d]);if(9==(c|0)&&(Y(b),4==(t[d]|0)&&(Y(b),9==(t[d]|0)))){for(c=9;!(22==(c|0)&&(hE(b),Y(b),c=t[d]),19==(c|0)?eE(b):Y(b),c=t[d],1>=(c-20|0)>>>0);){}}}function vE(b,d){var c,e,f;f=(b|0)>>2;e=(b+4|0)>>2;c=(b+8|0)>>2;var g=1;a:for(;;){for(;;){if(!g){break a}var h=T();if(92==(h|0)){var h=T(),i=t[f]}else{if(-1==(h|0)){g=0;continue a}if((h|0)==(d|0)){g=0;continue a}i=t[f]}(i+1|0)==(t[e]|0)&&(R(b),i=t[f]);l[t[c]+i|0]=h&255;0!=(h|0)&&(h=t[f]+1|0,t[f]=h,l[t[c]+h|0]=0)}}g=t[f];(g+1|0)!=(t[e]|0)?(c=t[c],c=c+g|0):(R(b),e=t[f],c=t[c],c=c+e|0);l[c]=0}vE.X=1;function wE(b){return 0!=(pA(b)|0)|10>(b-48|0)>>>0?1:95==(b|0)||64==(b|0)||36==(b|0)||35==(b|0)?1:0}function CE(){var b,d=zC(28);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=-1;t[b+3]=P();t[b+4]=0;t[b+5]=t[K+48>>2];t[b+6]=t[K+24>>2];return d}function DE(b){if(0!=(b|0)){Q(t[b+12>>2]);var d=b+16|0;DE(t[d>>2]);t[d>>2]=0;vB(b)}}function EE(){var b;b=t[lA>>2]-1|0;t[lA>>2]=b;Q(t[(t[jA>>2]+12>>2)+(7*b|0)]);var d=t[lA>>2];b=t[jA>>2]>>2;t[b+(7*d|0)]=0;t[b+(7*d|0)+1]=-1;t[b+(7*d|0)+4]=0;t[b+(7*d|0)+2]=-1;t[b+(7*d|0)+3]=0;t[b+(7*d|0)+5]=0}function FE(b){return 17==(b|0)||47==(b|0)||50==(b|0)||55==(b|0)?1:0}function GE(b){return 4==(b|0)||28==(b|0)||48==(b|0)||16==(b|0)||9==(b|0)||7==(b|0)||32==(b|0)||49==(b|0)||60==(b|0)?1:0}function HE(b){for(var d=b|0;!(IE(b,11),JE(b),11!=(t[d>>2]|0));){}}function KE(b){for(var d=0;;){if(62==(t[b+4>>2]|0)){HE(b);var c=1}else{c=0}if(0==(c|0)){var e=d;break}else{d=1}}for(;;){if(d=b,c=t[d+4>>2],19==(c|0)?(LE(d),d=1):25==(c|0)||26==(c|0)||38==(c|0)||22==(c|0)?(HE(d),d=1):d=0,0==(d|0)){var f=e;break}else{e=1}}for(;!(e=b,d=e+4|0,c=t[d>>2],30==(c|0)?(ME(e),e=1):2==(c|0)?(JE(e),0==(GE(t[d>>2])|0)?HE(e):NE(e),e=1):55==(c|0)?(JE(e),e=1):19==(c|0)?(LE(e),e=1):0!=((5==(c|0)||6==(c|0)||13==(c|0)||14==(c|0)||21==(c|0)||22==(c|0)||26==(c|0)||27==(c|0)||38==(c|0)||39==(c|0)||40==(c|0)||41==(c|0)||54==(c|0)||63==(c|0)||64==(c|0)||65==(c|0)?1:0)|0)?(HE(e),e=1):0!=(GE(c)|0)?(NE(e),e=1):3==(t[e>>2]|0)?(JE(e),d=e|0,9!=(t[d>>2]|0)?d=0:(OE(e),d=(7==(t[d>>2]|0)?0==(qA(t[t[e+12>>2]+8>>2],mg|0)|0):0)&1),HE(e),e=d):(d=t[e+4>>2],8==(d|0)?(PE(e,1),e=1):56==(d|0)?(QE(e),e=1):35==(d|0)?(PE(e,9),e=1):0==(d|0)||11==(d|0)||12==(d|0)||20==(d|0)||21==(d|0)||29==(d|0)||31==(d|0)||37==(d|0)||42==(d|0)||44==(d|0)||46==(d|0)||51==(d|0)||58==(d|0)?(HE(e),e=1):e=0),0==(e|0));){f=1}return f}function RE(b){for(var d,c=b+4|0,e=b+16|0,f=0;;){var g=t[c>>2];if(19==(g|0)){LE(b),f=1}else{if(18==(g|0)){SE(b);g=t[e>>2];if(0==(g|0)){d=2647;break}g=t[g+4>>2];if(!(15==(g|0)||24==(g|0)||52==(g|0)||66==(g|0))){d=2649;break}HE(b);f=1}else{if(10==(g|0)||23==(g|0)||57==(g|0)){d=2648;break}else{0==(FE(g)|0)?HE(b):JE(b),f=1}}}}if(2647==d||2648==d||2649==d){return f}}function LE(b){JE(b);3==(t[b>>2]|0)&&TE(b,2);HE(b)}function SE(b){b=b+16|0;if(0==(t[b>>2]|0)){var d=CE();t[b>>2]=d;JE(d)}}function TE(b,d){var c,e=j;j+=80;c=e>>2;var f=b+8|0;t[f>>2]=d;if(0!=(UE(d)|0)){sC(e,t[t[b+12>>2]+8>>2]);f=t[f>>2];1==(f|0)&&(t[c]=2!=(t[oy+76>>2]|0)&1);t[c+1]=t[b+20>>2];t[c+2]=t[b+24>>2];t[c+4]=2>(f-6|0)>>>0&1;t[c+9]=t[iz+(f<<4)+8>>2];l[e+40|0]=t[iz+(f<<4)+4>>2]&255;t[c+6]=6!=(f|0)&1;if(0!=(t[lA>>2]|0)){var f=t[jA>>2],g=0,h=t[lA>>2];a:for(;;){for(var i=0==(g|0),m=h;;){if(!(0!=(m|0)&i)){break a}var m=m-1|0,n=f+28*m|0;if(3==(t[n>>2]|0)){var q=t[(f+8>>2)+(7*m|0)];if(!(-1==(q|0)||4==(q|0))){g=n;h=m;continue a}}}}f=g;0!=(f|0)&&(t[c+15]=t[iz+(t[f+8>>2]<<4)+8>>2],t[c+16]=t[t[f+12>>2]+8>>2])}c=t[lA>>2];if(0==(c|0)){var p=0}else{f=t[jA>>2];for(h=g=0;;){if(h=4==(t[(f+8>>2)+(7*g|0)]|0)?1:h,g=g+1|0,!(g>>>0<c>>>0&0==(h|0))){p=h;break}}}if(0!=(p|0)&&0==(UE(4)|0)){j=e;return}tC(e)}j=e}TE.X=1;function UE(b){var d=t[iz+(b<<4)>>2];return 0==(d|0)?0:0==(2>(b-6|0)>>>0&1|0)?d:t[oy+8>>2]}function ME(b){var d;JE(b);d=(b|0)>>2;if(3==(t[d]|0)){TE(b,4);var c=VE(b);d=2703}else{var e=t[b+4>>2];1==(e|0)||36==(e|0)?(JE(b),e=t[d],9==(e|0)?(JE(b),d=t[d]):d=e,7!=(d|0)?d=2704:(TE(b,4),c=VE(b),d=2703)):d=2704}if(2703==d){if(0==(c|0)){d=2704}else{var f=c}}2704==d&&(f=CE(),t[f>>2]=3,t[f+8>>2]=4);WE(f);for(c=b+4|0;;){if(d=t[c>>2],57==(d|0)){XE(b,11)}else{if(18==(d|0)){break}else{23==(d|0)?XE(b,3):0!=(FE(d)|0)?JE(b):0==(GE(d)|0)?HE(b):YE(b)}}}SE(b);HE(b);EE();DE(f)}ME.X=1;function NE(b){var d,c;YE(b);d=(b|0)>>2;var e=t[d];if(1==(e|0)){ZE(b);var f=t[d];c=2717}else{11!=(e|0)&&(f=e,c=2717)}if(2717==c&&(2==(f|0)&&JE(b),$E(b),11!=(t[d]|0))){return}HE(b)}function JE(b){var d,c,e;d=b+16|0;DE(t[d>>2]);c=(b|0)>>2;t[c]=0;t[b+8>>2]=-1;t[b+4>>2]=-1;t[d>>2]=0;d=(b+12|0)>>2;S(t[d]);for(var f=b+20|0,g=b+24|0;;){var h=aF();t[f>>2]=t[K+48>>2];t[g>>2]=t[K+24>>2];if(46==(h|0)){e=2744;break}else{if(42==(h|0)||47==(h|0)||43==(h|0)||45==(h|0)||61==(h|0)||60==(h|0)||62==(h|0)){var i=h;e=2731;break}else{if(44==(h|0)){e=2727;break}else{if(41==(h|0)){e=2729;break}else{if(10==(h|0)){break}else{if(40==(h|0)){e=2728;break}else{if(33==(h|0)){e=2739;break}else{if(-1==(h|0)){e=2726;break}else{if(37==(h|0)){e=2730;break}else{if(34==(h|0)||39==(h|0)){e=2751;break}else{if(59==(h|0)){e=2752;break}else{if(58==(h|0)){e=2753;break}else{if(!(32==(h|0)||9==(h|0))){e=2756;break}}}}}}}}}}}}}}a:do{if(2744==e){bF(t[d],46);i=aF();if(46!=(i|0)){cF(i);t[c]=0;return}i=t[d];h=t[i>>2];(h+1|0)==(t[i+4>>2]|0)&&(R(i),i=h=t[d],h=t[h>>2]);l[t[i+8>>2]+h|0]=46;i=t[d]|0;h=t[i>>2]+1|0;t[i>>2]=h;l[t[t[d]+8>>2]+h|0]=0;h=t[d];i=t[h>>2];(i+1|0)==(t[h+4>>2]|0)?(R(h),d=i=t[d],i=t[i>>2]):d=h;l[t[d+8>>2]+i|0]=0;t[c]=7;return}if(2731==e){for(;;){h=t[d];b=t[h>>2];(b+1|0)==(t[h+4>>2]|0)&&(R(h),h=b=t[d],b=t[b>>2]);l[t[h+8>>2]+b|0]=i&255;0!=(i|0)&&(i=t[d]|0,h=t[i>>2]+1|0,t[i>>2]=h,l[t[t[d]+8>>2]+h|0]=0);var m=aF();if(0==(bC(bg|0,m,7)|0)){break}else{i=m}}cF(m);h=t[d];i=t[h>>2];(i+1|0)==(t[h+4>>2]|0)?(R(h),d=i=t[d],i=t[i>>2]):d=h;l[t[d+8>>2]+i|0]=0;t[c]=7;return}if(2727==e){t[c]=1;return}if(2729==e){t[c]=8;return}if(2756==e){if(0!=(pA(h)|0)){c=b;i=ba;i=(c+12|0)>>2;bF(t[i],h);h=UD(t[i],t[Ny>>2]);d=c+4|0;t[d>>2]=h;b=c|0;-1!=(h|0)?t[b>>2]=4:(t[b>>2]=3,i=t[t[i]+8>>2],0==(N(i,Sf|0,3)|0)&&(h=PD(i+3|0),i=UD(h,t[Ny>>2]),Q(h),-1!=(i|0)&&(h=CE(),c=c+16|0,t[c>>2]=h,t[h>>2]=4,t[t[c>>2]+4>>2]=i,t[d>>2]=18)));return}10>(h-48|0)>>>0?(i=dF(h),U(t[d],t[i+8>>2]),Q(i),t[c]=6):t[c]=0;return}if(2728==e){t[c]=9;return}if(2739==e){if(0==(t[gz>>2]|0)){eF(),t[Nz>>2]=0}else{for(;;){if(f=aF(),-1==(f|0)||10==(f|0)){break a}}}}else{if(2726==e){dB(rz|0,1)}else{if(2730==e){t[c]=10;return}if(2751==e){fF(t[d],h);t[c]=12;return}if(2752==e){t[c]=11;return}if(2753==e){d=aF();58==(d|0)?t[c]=2:(cF(d),t[c]=0);return}}}}while(0);t[c]=11;0!=(t[gz>>2]|0)&&gF()}JE.X=1;function PE(b,d){var c,e;JE(b);c=(b|0)>>2;for(var f=b+12|0,g=t[c];;){if(7==(g|0)){if(0==(qA(t[t[f>>2]+8>>2],dh|0)|0)){JE(b);3==(t[c]|0)&&(TE(b,d),JE(b));hF(b);var h=t[c];e=2801}}else{h=g,e=2801}2801==e&&(e=0,3==(h|0)&&TE(b,7));JE(b);g=t[c];9==(g|0)&&(OE(b),g=t[c]);1==(g|0)&&(JE(b),g=t[c]);if(11==(g|0)){break}}HE(b)}function QE(b){var d,c,e;JE(b);c=(b|0)>>2;7==(t[c]|0)?0!=(qA(t[t[b+12>>2]+8>>2],dh|0)|0)?e=2814:(JE(b),3==(t[c]|0)&&TE(b,12),d=VE(b),hF(b)):e=2814;2814==e&&(e=CE(),d=e>>2,t[d]=3,t[d+2]=12,V(t[d+3],tg|0),d=e);a:for(;;){for(e=t[c];;){if(3!=(e|0)){break a}TE(b,5);JE(b);e=t[c];if(1==(e|0)){break}}JE(b)}HE(b);WE(d);c=b+4|0;if(18!=(t[c>>2]|0)){for(;!(iF(b),18==(t[c>>2]|0));){}}SE(b);HE(b);EE();DE(d)}QE.X=1;function VE(b){var d,c,e=CE();c=e>>2;d=b>>2;t[c]=t[d];t[c+1]=t[d+1];t[c+2]=t[d+2];t[c+3]=t[d+3];t[c+4]=t[d+4];t[c+5]=t[d+5];t[c+6]=t[d+6];t[e+12>>2]=BE(t[b+12>>2]);t[b+16>>2]=0;return e}function hF(b){IE(b,7);11!=(t[b>>2]|0)&&JE(b)}function WE(b){var d,c;d=t[jA>>2];0==(d|0)?(t[lA>>2]=0,t[kA>>2]=10,d=zC(280),t[jA>>2]=d):(c=t[lA>>2],(c|0)==(t[kA>>2]|0)&&(c=c+10|0,t[kA>>2]=c,d=jF(d,28*c|0),t[jA>>2]=d));c=(d+28*t[lA>>2]|0)>>2;d=b>>2;t[c]=t[d];t[c+1]=t[d+1];t[c+2]=t[d+2];t[c+3]=t[d+3];t[c+4]=t[d+4];t[c+5]=t[d+5];t[c+6]=t[d+6];b=BE(t[b+12>>2]);d=t[lA>>2];t[(t[jA>>2]+12>>2)+(7*d|0)]=b;t[lA>>2]=d+1|0}function iF(b){var d=t[b+4>>2];if(0!=(GE(d)|0)){NE(b)}else{if(61==(d|0)){HE(b);var d=b+4|0,c=33==(t[d>>2]|0);a:do{if(c){for(;;){var e=b;HE(e);var f=e+4|0,g=18==(t[f>>2]|0);b:do{if(!g){for(;;){if(iF(e),18==(t[f>>2]|0)){break b}}}}while(0);SE(e);HE(e);if(33!=(t[d>>2]|0)){break a}}}}while(0);SE(b);HE(b)}else{56==(d|0)?QE(b):HE(b)}}}function IE(b,d){for(var c=b|0,e=b+16|0;;){var f=t[c>>2];if((f|0)==(d|0)|11==(f|0)){break}f=t[e>>2];if(0!=(f|0)&&11==(t[f>>2]|0)){break}JE(b)}}function OE(b){for(var d=b|0,c=0;;){var e=t[d>>2];if(11==(e|0)){break}else{c=9==(e|0)?c+1|0:8==(e|0)?c-1|0:c}JE(b);if(0>=(c|0)){break}}}function YE(b){var d=b>>2,c=b+4|0,e=t[c>>2];if(16==(e|0)){JE(b);var f=t[c>>2];9==(f|0)||43==(f|0)?JE(b):IE(b,11)}else{if(4==(e|0)||9==(e|0)||28==(e|0)||32==(e|0)||48==(e|0)){JE(b);var f=b|0,g=t[f>>2];9==(g|0)?(OE(b),f=t[f>>2]):f=g;7==(f|0)&&0==(qA(t[t[d+3]+8>>2],wo|0)|0)&&(JE(b),JE(b))}else{if(7==(e|0)){JE(b);f=b|0;g=t[f>>2];if(7==(g|0)){if(0==(qA(t[t[d+3]+8>>2],wo|0)|0)){JE(b),f=t[f>>2]}else{return}}else{f=g}9==(f|0)?OE(b):6==(f|0)&&JE(b)}else{if(49==(e|0)){JE(b),7==(t[d]|0)&&0==(qA(t[t[d+3]+8>>2],dh|0)|0)&&(JE(b),JE(b),JE(b))}else{if(60==(e|0)){if(JE(b),9==(t[d]|0)){OE(b)}else{d=(b|0)>>2;c=t[d];1==(c|0)&&(ZE(b),c=t[d]);2==(c|0)?(JE(b),d=t[d]):d=c;3==(d|0)&&TE(b,12);WE(b);HE(b);d=b+4|0;c=t[d>>2];44==(c|0)||53==(c|0)?(HE(b),g=2964):f=c;for(;;){2964==g&&(f=t[d>>2]);if(18==(f|0)){break}0==(GE(f)|0)?HE(b):(g=b,YE(g),c=g|0,e=t[c>>2],1==(e|0)?(ZE(g),c=t[c>>2]):c=e,2==(c|0)&&JE(g),$E(g));g=2964}SE(b);IE(b,11);EE()}}else{IE(b,11)}}}}}}YE.X=1;function ZE(b){for(var d,c=b+4|0,e=b|0;;){JE(b);var f=t[c>>2];12==(f|0)||29==(f|0)?(JE(b),OE(b)):38==(f|0)||0==(f|0)||21==(f|0)||31==(f|0)||37==(f|0)||44==(f|0)||42==(f|0)||46==(f|0)||51==(f|0)||58==(f|0)?JE(b):IE(b,11);f=t[e>>2];if(2==(f|0)){d=2915;break}else{if(1!=(f|0)){break}}}2915!=d&&IE(b,11)}function $E(b){var d,c;d=(b|0)>>2;var e=t[d];if(10==(e|0)){HE(b)}else{for(var f=b+4|0;;){if(4==(e|0)){e=t[f>>2];if(23==(e|0)||57==(e|0)){c=2929;break}t[d]=3}else{if(3!=(e|0)){c=2927;break}}kF(b);e=t[d];if(11==(e|0)){c=2925;break}else{if(1!=(e|0)){continue}}JE(b);e=t[d]}2929!=c&&2927!=c&&2925==c&&HE(b)}}function kF(b){var d;0==(t[lA>>2]|0)?d=13:(d=t[(t[jA>>2]+28*(t[lA>>2]-1)|0)+8>>2],d=3==(d|0)?7:12==(d|0)?5:11==(d|0)?7:13);TE(b,d);JE(b);d=(b|0)>>2;var c=t[d];9==(c|0)&&(OE(b),c=t[d]);7==(c|0)&&0==(qA(t[t[b+12>>2]+8>>2],wo|0)|0)&&(JE(b),9==(t[d]|0)?OE(b):JE(b));if(7==(t[d]|0)){if(c=t[t[b+12>>2]+8>>2],0==(qA(c,dh|0)|0)){JE(b),hF(b)}else{if(0==(qA(c,mg|0)|0)){for(c=7;!(1==(c|0)||11==(c|0));){JE(b),c=t[d],9==(c|0)&&(OE(b),c=t[d])}}}}}kF.X=1;function XE(b,d){JE(b);3==(t[b>>2]|0)&&TE(b,d);WE(b);HE(b);KE(b);RE(b);10==(t[b+4>>2]|0)&&lF(b);SE(b);HE(b);EE()}function cF(b){t[Jx>>2]=b}function lF(b){var d,c=b+4|0,e=t[c>>2];if(10==(e|0)){HE(b),d=2987}else{var f=e}for(;;){if(2987==d&&(f=t[c>>2]),23==(f|0)){XE(b,3),d=2987}else{if(18==(f|0)){break}else{57==(f|0)?XE(b,11):0!=(FE(f)|0)?JE(b):0==(GE(f)|0)?JE(b):YE(b),d=2987}}}}function aF(){var b=t[Jx>>2];0==(b|0)?b=0==(t[gz>>2]|0)?mF():nF():t[Jx>>2]=0;return b}function eF(){for(;;){var b=T();if(-1==(b|0)||10==(b|0)){break}}return b}function gF(){for(var b;;){var d=aF();if(!(32==(d|0)||9==(d|0))){break}}if(10>(d-48|0)>>>0){for(var c=d,e=d=0;;){if(0==(e|0)){var f=CE();t[f>>2]=5}else{f=e}b=(f+12|0)>>2;var g=t[b],e=t[g>>2];(e+1|0)==(t[g+4>>2]|0)&&(R(g),g=e=t[b],e=t[e>>2]);l[t[g+8>>2]+e|0]=c&255;0!=(c|0)&&(c=t[b]|0,g=t[c>>2]+1|0,t[c>>2]=g,l[t[t[b]+8>>2]+g|0]=0);g=aF();e=d+1|0;if(10>(g-48|0)>>>0&5>(e|0)){c=g,d=e,e=f}else{break}}0>(d|0)|0==(f|0)||(c=t[b],d=t[c>>2],(d+1|0)==(t[c+4>>2]|0)?(R(c),b=d=t[b],d=t[d>>2]):b=c,l[t[b+8>>2]+d|0]=0,TE(f,6),DE(f));f=g}else{f=d}cF(f)}gF.X=1;function bF(b,d){var c,e;e=(b|0)>>2;var f=b+4|0;c=(b+8|0)>>2;for(var g=d;;){var h=t[e];(h+1|0)==(t[f>>2]|0)&&(R(b),h=t[e]);l[t[c]+h|0]=g&255;0!=(g|0)&&(h=t[e]+1|0,t[e]=h,l[t[c]+h|0]=0);h=aF();if(0!=(oA(h)|0)|95==(h|0)){g=h}else{break}}g=t[e];(g+1|0)!=(t[f>>2]|0)?(c=t[c],c=c+g|0):(R(b),e=t[e],c=t[c],c=c+e|0);l[c]=0;cF(h)}function dF(b){var d,c=P(),b=oF(b);V(c,t[b+8>>2]);Q(b);b=aF();if(46==(b|0)){d=oF(0);var b=(c|0)>>2,e=t[b];if((e+1|0)==(t[c+4>>2]|0)){R(c);var f=t[b]}else{f=e}e=c+8|0;l[t[e>>2]+f|0]=46;f=t[b]+1|0;t[b]=f;l[t[e>>2]+f|0]=0;U(c,t[d+8>>2]);Q(d);var g=aF()}else{g=b}if(101==(rA(g)|0)){e=oF(0);f=c|0;d=f>>2;var h=t[d],b=c+4|0;if((h+1|0)==(t[b>>2]|0)){R(c);var i=t[d]}else{i=h}h=c+8|0;l[t[h>>2]+i|0]=g&255;0!=(g|0)&&(g=t[d]+1|0,t[d]=g,l[t[h>>2]+g|0]=0);U(c,t[e+8>>2]);Q(e);d=f;e=b}else{cF(g),d=c|0,e=c+4|0}b=t[d>>2];if((b+1|0)!=(t[e>>2]|0)){return d=t[(c+8|0)>>2],b=d+b|0,l[b]=0,c}R(c);b=t[d>>2];d=t[(c+8|0)>>2];b=d+b|0;l[b]=0;return c}dF.X=1;function oF(b){var d,c,e=P();if(45==(b|0)){b=(e|0)>>2;d=t[b];if((d+1|0)==(t[e+4>>2]|0)){R(e);var f=t[b]}else{f=d}d=e+8|0;l[t[d>>2]+f|0]=45;f=t[b]+1|0;t[b]=f;l[t[d>>2]+f|0]=0;var g=aF()}else{g=10>(b-48|0)>>>0?b:aF()}d=(e|0)>>2;f=e+4|0;for(b=(e+8|0)>>2;;){if(-1==(g|0)){c=3069;break}var h=t[d],i=(h+1|0)==(t[f>>2]|0);if(10<=(g-48|0)>>>0){c=3077;break}if(i){R(e);var m=t[d]}else{m=h}l[t[b]+m|0]=g&255;0!=(g|0)&&(g=t[d]+1|0,t[d]=g,l[t[b]+g|0]=0);g=aF()}if(3077==c){if(i){var n=g;c=3078}else{var q=g,p=h}}else{if(3069==c){if(c=t[d],(c+1|0)==(t[f>>2]|0)){n=-1,c=3078}else{l[t[b]+c|0]=0;var s;cF(-1);return e}}}3078==c&&(R(e),q=n,p=t[d]);l[t[b]+p|0]=0;if(95!=(q|0)){return cF(q),e}for(;;){q=aF();if(-1==(q|0)){s=-1;c=3083;break}if(0==(pA(q)|0)){s=q;c=3086;break}}if(3086==c||3083==c){return cF(s),e}}oF.X=1;function nF(){var b=T();do{if(38==(b|0)){for(;;){var d=T();if(!(0!=(L(d)|0)&10!=(d|0))){break}}if(10==(d|0)){t[Vc>>2]=1;var c=0,e=10}else{33==(d|0)?(c=0,e=33):(W(d),c=1,e=38)}}else{c=0==(t[Vc>>2]|0)?1:35==(b|0)||33==(b|0)?0:1,e=b}}while(0);a:for(;;){var f=e;b:for(;;){if(c){break a}b=0==(L(f)|0);c:do{if(b){var g=f}else{for(;;){if(d=T(),0==(L(d)|0)){g=d;break c}}}}while(0);do{if(33!=(g|0)&&!(0!=(t[Vc>>2]|0)&35==(g|0))){if(38!=(g|0)){c=1;e=g;continue a}f=T();continue b}}while(0);f=-1==(eF()|0)?-1:T();t[Vc>>2]=1}}t[Vc>>2]=10==(f|0)&1;return f}nF.X=1;function fF(b,d){var c,e,f=j,g=t[K+20>>2];l[ly]=1;e=(b|0)>>2;var h=b+4|0;c=(b+8|0)>>2;for(var i=aF();(i|0)!=(d|0)&&!(-1==(i|0)||10==(i|0));){var m=t[e];(m+1|0)==(t[h>>2]|0)&&(R(b),m=t[e]);l[t[c]+m|0]=i&255;0!=(i|0)&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);i=aF()}m=-1==(i|0);if(-1==(i|0)||10==(i|0)){i=t[t[K+40>>2]+8>>2],KC(Qf|0,(k=j,j+=8,t[k>>2]=i,t[k+4>>2]=g,k)),m&&dB(rz|0,1),0==(t[gz>>2]|0)&&dB(rz|0,2)}g=t[e];(g+1|0)!=(t[h>>2]|0)?(c=t[c],c=c+g|0):(R(b),e=t[e],c=t[c],c=c+e|0);l[c]=0;l[ly]=0;j=f}fF.X=1;function mF(){var b;if(0==(t[Nz>>2]|0)){var d=0,c=0,e=1}else{var f=T();t[Nz>>2]=t[Nz>>2]+1|0;if(10==(f|0)){t[Nz>>2]=0,d=1,c=10,e=1}else{if(33!=(f|0)|l[ly]){if(38!=(f|0)){var g=0,h=f;b=3132}else{f=T(),10==(f|0)?dB(rz|0,2):(W(f),g=0,h=38,b=3132)}}else{c=eF(),t[Nz>>2]=0,e=d=1}}}a:for(;;){3132==b&&(b=0,d=g,c=h,e=0==(t[Nz>>2]|0));var h=(g=0==(d|0))?-1:10,i=c,f=e;b:for(;;){if(!f){b=3146;break a}f=pF();if(4==(f|0)){t[Nz>>2]=6,i=h,f=0}else{if(2==(f|0)){b=3137;break}else{if(0==(f|0)||1==(f|0)){b=3136;break a}else{if(5==(f|0)){b=3139}else{if(3!=(f|0)){g=d;h=i;b=3132;continue a}}}}do{if(3139==b&&(b=0,!g)){t[Nz>>2]=6;i=10;f=0;continue b}}while(0);for(t[Nz>>2]=5;;){var m=T(),n=t[Nz>>2]+1|0;t[Nz>>2]=n;if(10==(m|0)){break}else{if(!(32==(m|0)||9==(m|0))){break b}}}t[Nz>>2]=0;i=10;f=1}}3137==b?(eF(),g=d,h=i):6<n>>>0?(W(m),g=d,h=32):(g=d,h=m);b=3132}if(3146==b){return i}3136==b&&dB(rz|0,2)}mF.X=1;function pF(){var b,d,c,e=P();d=(e|0)>>2;var f=e+4|0;b=(e+8|0)>>2;var g=0;a:for(;;){var h=T();if(0==(g|0)&&0!=(bC(Kf|0,h,9)|0)){var i=2;c=3162;break}if(9==(h|0)){i=5;c=3162;break}if(5==(g|0)){c=3152;break}do{if(-1==(h|0)){i=4;c=3162;break a}else{if(10==(h|0)){c=3161;break a}else{if(32!=(h|0)){if(10<=(h-48|0)>>>0){i=1;c=3162;break a}var m=t[d];(m+1|0)==(t[f>>2]|0)&&(R(e),m=t[d]);l[t[b]+m|0]=h&255;0!=(h|0)&&(m=t[d]+1|0,t[d]=m,l[t[b]+m|0]=0)}}}}while(0);g=g+1|0;if(6<=(g|0)){i=0;c=3162;break}}if(3152==c){if(48==(h|0)||32==(h|0)){i=5,c=3162}else{var h=t[d],n=0==(h|0)?3:1,q=h}}else{3161==c&&(i=6,c=3162)}3162==c&&(n=i,q=t[d]);if(0==(q|0)){return Q(e),n}(q+1|0)==(t[f>>2]|0)?(R(e),d=t[d]):d=q;l[t[b]+d|0]=0;b=CE();t[b>>2]=5;V(t[b+12>>2],t[e+8>>2]);TE(b,6);DE(b);Q(e);return n}pF.X=1;function qF(){var b,d=zC(20);b=d>>2;t[b]=-1;t[b+1]=-1;t[b+2]=P();t[b+3]=t[K+48>>2];t[b+4]=t[K+24>>2];return d}function rF(b){0!=(b|0)&&(Q(t[b+8>>2]),vB(b))}function sF(b,d){var c,e=qF();tF(e);var f=e|0;if(5==(t[f>>2]|0)){tF(e);var g=0}else{g=1}for(var h=b|0;;){uF(e,d);tF(b);var i=t[h>>2];if(15==(i|0)||6==(i|0)){tF(e)}else{vF(b);var i=b,m=i|0;if(11!=(t[m>>2]|0)){for(;!(tF(i),wF(i),11==(t[m>>2]|0));){}}if(g){c=3210;break}tF(e);if(6==(t[f>>2]|0)){c=3211;break}}}3211==c?rF(e):3210==c&&rF(e)}function uF(b,d){var c,e=j;j+=80;c=e>>2;var f=b+8|0;sC(e,t[t[f>>2]+8>>2]);if(0!=(t[dz+(d<<4)>>2]|0)&&(t[c+1]=t[b+12>>2],t[c+2]=t[b+16>>2],t[c+9]=t[dz+(d<<4)+8>>2],l[e+40|0]=t[dz+(d<<4)+4>>2]&255,tC(e),0!=(t[Zb>>2]|0)&0!=(t[oy+4>>2]|0))){var g=P();V(g,t[t[Zb>>2]+8>>2]);U(g,Xi|0);U(g,t[t[f>>2]+8>>2]);t[c+8]=t[g+8>>2];tC(e);Q(g)}j=e}uF.X=1;function vF(b){var d,c=b|0,e=b+4|0;a:for(;;){var f=t[c>>2];if(3==(f|0)){d=3222;break}else{if(5==(f|0)){d=3221;break}}var g=t[e>>2];if(2>(g-6|0)>>>0){d=3225;break}if(9==(f|0)){wF(b)}else{12!=(f|0)&&(d=3228);do{if(3228==d&&(d=0,!(9==(g|0)|13==(f|0)))){if(5==(g|0)){tF(b);wF(b);continue a}else{if(8==(g|0)){tF(b);wF(b);continue a}else{d=3238;break a}}}}while(0);tF(b)}}3238!=d&&(3222==d?(tF(b),14==(t[c>>2]|0)&&(tF(b),tF(b))):3221==d?wF(b):3225==d&&(tF(b),wF(b)))}function wF(b){var d=b|0,c=t[d>>2];if(5==(c|0)){var e=6}else{if(7==(c|0)){e=8}else{if(9==(c|0)){e=10}else{return}}}tF(b);for(var f=1;;){var g=t[d>>2],f=((g|0)==(c|0)&1)+f|0,f=(((g|0)==(e|0)&0<(f|0))<<31>>31)+f|0;tF(b);if(!(0!=(f|0)|(g|0)!=(e|0))){break}}}function xF(b,d){var c,e,f;f=(b|0)>>2;e=(b+4|0)>>2;c=(b+8|0)>>2;var g=96==(d|0),h=1;a:for(;;){b:for(;;){if(!h){break a}var i=T();do{if(-1==(i|0)){h=0;continue a}else{if(92==(i|0)&&!g){var i=T(),m=t[f];(m+1|0)==(t[e]|0)&&(R(b),m=t[f]);l[t[c]+m|0]=i&255;if(0==(i|0)){continue b}i=t[f]+1|0;t[f]=i;l[t[c]+i|0]=0;continue b}}}while(0);if((i|0)==(d|0)){h=0;continue a}m=t[f];(m+1|0)==(t[e]|0)&&(R(b),m=t[f]);l[t[c]+m|0]=i&255;0!=(i|0)&&(i=t[f]+1|0,t[f]=i,l[t[c]+i|0]=0)}}g=t[f];(g+1|0)!=(t[e]|0)?(c=t[c],c=c+g|0):(R(b),e=t[f],c=t[c],c=c+e|0);l[c]=0}xF.X=1;function tF(b){var d,c,e,f;e=(b|0)>>2;t[e]=-1;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+12|0)>>2;for(b=(b+16|0)>>2;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(91==(h|0)){f=3307;break}else{if(!(32==(h|0)||13==(h|0)||9==(h|0))){if(46==(h|0)){f=3310;break}else{if(41==(h|0)){f=3304;break}else{if(125==(h|0)){f=3306;break}else{if(40==(h|0)){f=3303;break}else{if(42==(h|0)){f=3309;break}else{if(34==(h|0)||39==(h|0)||96==(h|0)){f=3300;break}else{if(10==(h|0)){var i=t[$b>>2];if(2>(i-3|0)>>>0|6==(i|0)|8==(i|0)|10==(i|0)){f=3291;break}}else{if(-1==(h|0)){f=3292;break}else{if(60==(h|0)){if(45==(T()|0)){f=3302;break}}else{if(44==(h|0)){f=3311;break}else{if(93==(h|0)){f=3308;break}else{if(47==(h|0)){var m=T();if(47==(m|0)){uE(10),W(10)}else{if(42==(m|0)){i=0}else{f=3299;break}for(;;){var n=T(),q=10==(n|0)?1:i;if(-1==(n|0)||42==(n|0)){i=T();if(47==(i|0)){break}W(i);if(-1==(i|0)||0==(i|0)){break}else{i=q}}else{i=q}}W(0!=(q|0)?10:32)}}else{f=123==(h|0)?3305:3312;break}}}}}}}}}}}}}}}if(3307==f){t[e]=9}else{if(3312==f){m=t[c];q=(m|0)>>2;i=m+4|0;for(f=(m+8|0)>>2;;){var p=t[q];(p+1|0)==(t[i>>2]|0)&&(R(m),p=t[q]);l[t[f]+p|0]=h&255;0!=(h|0)&&(p=t[q]+1|0,t[q]=p,l[t[f]+p|0]=0);p=T();if(0==((0!=(pA(p)|0)|10>(p-48|0)>>>0?1:95==(p|0)||64==(p|0)||36==(p|0)||35==(p|0)?1:128<(p|0))&1|0)){break}else{h=p}}h=t[q];(h+1|0)==(t[i>>2]|0)&&(R(m),h=t[q]);f=t[f];h=f+h|0;l[h]=0;W(p);t[d]=t[K+48>>2];t[b]=t[K+24>>2];d=mC(t[t[c]+8>>2],t[My>>2]);t[g>>2]=d;t[e]=-1==(d|0)?3:2}else{3291==f?t[e]=11:3310==f?t[e]=14:3304==f?t[e]=6:3306==f?t[e]=8:3302==f?t[e]=13:3303==f?t[e]=5:3299==f?(t[e]=1,W(m)):3309==f?t[e]=12:3300==f?(t[e]=4,xF(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2]):3292==f?dB(qz|0,1):3311==f?t[e]=15:3308==f?t[e]=10:3305==f&&(t[e]=7)}}t[$b>>2]=t[e]}tF.X=1;function yF(){var b,d=zC(32);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+6]=0;t[b+7]=0;t[b+4]=t[K+48>>2];t[b+5]=t[K+24>>2];return d}function zF(b){Q(t[b+8>>2]);Q(t[b+12>>2]);vB(b)}function AF(b){var d,c=yF();BF(c);CF(c,t[b+12>>2]);BF(b);d=(b|0)>>2;var e=t[d],f=11==(e|0);a:do{if(f){for(var g=b+4|0;;){BF(b);-1==(t[g>>2]|0)&&(DF(c,b),BF(b));var h=t[d];if(11!=(h|0)){var i=h;break a}}}else{i=e}}while(0);7==(i|0)?(EF(b),d=t[d]):d=i;12==(d|0)&&(0==(FF(b,c)|0)?GF(c):HF(c));IF(b);zF(c)}function JF(b,d){if(6==(t[b>>2]|0)){var c=t[b+4>>2];if(8==(c|0)||9==(c|0)||10==(c|0)){var e=b+4|0,f=t[e>>2];if(10==(f|0)){BF(b),f=b|0,12==(t[f>>2]|0)?FF(b,b):JF(b,0),BF(b),9==(t[e>>2]|0)&&(BF(b),7==(t[f>>2]|0)&&EF(b))}else{if(8==(f|0)||9==(f|0)){BF(b),e=b|0,f=t[e>>2],7==(f|0)?(EF(b),e=t[e>>2]):e=f,12==(e|0)?FF(b,b):JF(b,0)}}e=1}else{if(13==(c|0)){BF(b),e=b|0,f=t[e>>2],7==(f|0)?(EF(b),e=t[e>>2]):e=f,12==(e|0)&&FF(b,b),e=1}else{if(11==(c|0)||12==(c|0)||14==(c|0)||15==(c|0)||16==(c|0)){for(var g=b+4|0,c=(b|0)>>2;;){BF(b);11==(t[g>>2]|0)&&BF(b);var h=t[c];7==(h|0)&&(EF(b),h=t[c]);if(12==(h|0)){e=3377;break}IF(b);if(13==(t[c]|0)){f=0;break}BF(b);if(13==(t[c]|0)){f=0;break}if(12!=(t[g>>2]|0)){f=1;break}}3377==e&&(FF(b,b),f=1);e=f}else{KF(b,d),e=1}}}}else{e=KF(b,d)}return e}function BF(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+16|0)>>2;b=(b+20|0)>>2;a:for(;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(58==(h|0)){f=3397;break}else{if(44==(h|0)){f=3395;break}else{if(123==(h|0)){f=3398;break}else{if(46==(h|0)){f=3396;break}else{if(39==(h|0)||34==(h|0)){f=3403;break}else{if(92==(h|0)){f=3404;break}else{if(61==(h|0)){f=3400;break}else{if(59==(h|0)){f=3394;break}else{if(93==(h|0)){f=3402;break}else{if(40==(h|0)){f=3392;break}else{if(-1==(h|0)){f=3391;break}else{if(125==(h|0)){f=3399;break}else{if(41==(h|0)){f=3393;break}else{if(91==(h|0)){f=3401;break}else{if(32==(h|0)||10==(h|0)||9==(h|0)){continue}else{if(47!=(h|0)){f=3413;break}}}}}}}}}}}}}}}}var i=T();if(47==(i|0)){uE(10)}else{if(42!=(i|0)){f=3409;break}for(;;){uE(42);var m=T();if(47==(m|0)){continue a}W(m);if(-1==(m|0)||0==(m|0)){continue a}}}}if(3409==f){t[e]=15,W(i)}else{if(3397==f){t[e]=4}else{if(3395==f){t[e]=5}else{if(3398==f){t[e]=12}else{if(3396==f){t[e]=11}else{if(3403==f){t[e]=10,LF(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(3404==f){g=T(),!(92==(g|0)||34==(g|0))&&0==(L(g)|0)&&W(g),t[e]=1,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(3400==f){t[e]=14}else{if(3394==f){t[e]=3}else{if(3402==f){t[e]=17}else{if(3392==f){t[e]=7}else{if(3391==f){dB(pz|0,1)}else{if(3399==f){t[e]=13}else{if(3393==f){t[e]=2}else{if(3401==f){t[e]=16}else{if(3413==f){if(0==(MF(h)|0)){t[e]=0}else{var i=t[c],m=(i|0)>>2,n=i+4|0;for(f=(i+8|0)>>2;;){var q=t[m];(q+1|0)==(t[n>>2]|0)&&(R(i),q=t[m]);l[t[f]+q|0]=h&255;0!=(h|0)&&(q=t[m]+1|0,t[m]=q,l[t[f]+q|0]=0);q=T();if(0==(MF(q)|0)){break}else{h=q}}h=t[m];(h+1|0)==(t[n>>2]|0)?(R(i),i=t[m]):i=h;l[t[f]+i|0]=0;0==(L(q)|0)&&W(q);t[d]=t[K+48>>2];t[b]=t[K+24>>2];d=UD(t[c],t[Iy>>2]);t[g>>2]=d;t[e]=-1==(d|0)?9:6}}}}}}}}}}}}}}}}}}BF.X=1;function KF(b,d){var c,e,f,g,h=b>>2,i,m=yF(),n=yF(),q=P();S(q);var p=0!=(d|0),s=p&1;g=(b+4|0)>>2;e=t[g];if(5==(e|0)){e=0==(t[h+6]|0)&1;BF(b);var r=e;e=t[g]}else{r=0}7==(e|0)?(BF(b),e=b|0,11==(t[e>>2]|0)&&BF(b)):e=b|0;f=e>>2;NF(m,b);e=(b+12|0)>>2;var u=m+8|0;a:for(;;){var v=t[f];if(3==(v|0)){i=3459;break}else{if(14==(v|0)){i=3461;break}else{if(13==(v|0)){var w=0;break}}}BF(b);var v=t[f],C=11==(v|0);b:do{if(C){for(var A=s;;){BF(b);var I=t[g];do{if(-1==(I|0)){if(0==(A|0)){DF(m,b);var M=0}else{V(q,t[t[e]+8>>2]),CF(b,t[u>>2]),M=A}}else{if(4==(I|0)){if(HF(m),BF(b),M=t[f],11==(M|0)){if(BF(b),-1==(t[g]|0)){i=3451;break a}else{M=1}}else{if(14==(M|0)){if(BF(b),12==(t[f]|0)){i=3453;break a}else{M=1}}else{M=1}}}else{M=A}}}while(0);BF(b);A=t[f];if(11==(A|0)){A=M}else{var B=0;c=M;var G=A;break b}}}else{B=r,c=s,G=v}}while(0);7==(G|0)?(EF(b),r=t[f]):r=G;if(16==(r|0)&&(r=b,s=r|0,16==(t[s>>2]|0))){BF(r);for(C=1;!(v=t[s>>2],C=(16==(v|0)&1)+C|0,C=((17==(v|0)&0<(C|0))<<31>>31)+C|0,BF(r),!(0!=(C|0)|17!=(v|0)));){}}r=B;s=c}a:do{if(3451==i){V(q,t[t[e]+8>>2]),CF(b,t[u>>2]),OF(b,2),w=b+28|0,t[w>>2]=1,IF(b),t[w>>2]=0,w=1}else{if(3453==i){PF(b,m),IF(b),t[h+7]=0,w=1}else{if(3459==i){0!=(t[h+6]|0)|0==(r|0)||OF(m,4),w=1}else{if(3461==i){BF(b);w=t[g];do{if(0==(w|0)){BF(b);-1==(t[g]|0)?7==(t[f]|0)?i=3466:(NF(n,b),BF(b),i=3465):i=3465;if(3465==i){if(B=t[f],7==(B|0)){i=3466}else{var Z=B}}3466==i&&(EF(b),Z=t[f]);if(12==(Z|0)){if(p){OF(m,2),0!=(t[t[n+8>>2]>>2]|0)&&GF(n),FF(b,m)}else{0==(FF(b,m)|0)?GF(m):HF(m);if(0==(t[t[n+8>>2]>>2]|0)){w=1;break a}GF(n);w=1;break a}}}else{if(B=t[f],12==(B|0)){if(0==(PF(b,m)|0)&&!(0!=(t[h+6]|0)|0==(r|0))){B=P();c=t[e];0==(t[c>>2]|0)?V(B,t[t[h+2]+8>>2]):(V(B,t[c+8>>2]),U(B,Xi|0),U(B,t[t[h+2]+8>>2]));c=B|0;G=t[c>>2];(G+1|0)==(t[B+4>>2]|0)&&(R(B),G=t[c>>2]);c=(B+8|0)>>2;l[t[c]+G|0]=0;do{if(0==(zE(t[ez>>2],t[c])|0)&&0==(zE(t[Qz>>2],t[c])|0)){BF(b);if(3!=(t[f]|0)&&(IF(b),3!=(t[f]|0))){break}OF(m,4)}}while(0);Q(B)}}else{7==(B|0)?(EF(b),12==(t[f]|0)&&(OF(m,2),FF(b,m))):6==(w|0)?(BF(b),B=t[g],4>B>>>0&&(BF(b),c=t[f],7==(c|0)&&(EF(b),c=t[f]),3==(c|0)&&0==(t[h+6]|0)&&(0==(s|0)&1<(B-2|0)>>>0?GF(m):HF(m)))):-1==(w|0)&&!(0!=(t[h+6]|0)|0==(r|0))&&(B=P(),c=t[e],0==(t[c>>2]|0)?V(B,t[t[h+2]+8>>2]):(V(B,t[c+8>>2]),U(B,Xi|0),U(B,t[t[h+2]+8>>2])),c=B|0,G=t[c>>2],(G+1|0)==(t[B+4>>2]|0)&&(R(B),G=t[c>>2]),c=(B+8|0)>>2,l[t[c]+G|0]=0,0==(zE(t[ez>>2],t[c])|0)&&0==(zE(t[Qz>>2],t[c])|0)&&(IF(b),3==(t[f]|0)&&OF(m,4)),Q(B))}}}while(0);IF(b);w=1}}}}}while(0);V(t[e],t[q+8>>2]);zF(m);zF(n);Q(q);return w}KF.X=1;function NF(b,d){var c=d>>2,e=b>>2;t[e+6]=t[c+6];t[e+4]=t[c+4];t[e+5]=t[c+5];t[e]=t[c];t[e+1]=t[c+1];V(t[e+2],t[t[c+2]+8>>2]);V(t[e+3],t[t[c+3]+8>>2])}function CF(b,d){var c;c=(b+12|0)>>2;var e=t[c];0!=(t[e>>2]|0)&&(U(e,Xi|0),e=t[c]);U(e,t[d+8>>2]);var f=t[c],e=t[f>>2];(e+1|0)!=(t[f+4>>2]|0)?(f=f+8|0,f=t[f>>2],c=f+e|0):(R(f),e=t[c],c=t[e>>2],f=e+8|0,f=t[f>>2],c=f+c|0);l[c]=0}function DF(b,d){var c;c=(b+8|0)>>2;var e=t[c];0!=(t[e>>2]|0)&&(U(e,Xi|0),e=t[c]);U(e,t[t[d+8>>2]+8>>2]);var f=t[c],e=t[f>>2];(e+1|0)!=(t[f+4>>2]|0)?(f=f+8|0,f=t[f>>2],c=f+e|0):(R(f),e=t[c],c=t[e>>2],f=e+8|0,f=t[f>>2],c=f+c|0);l[c]=0}function HF(b){if(0==(t[b+28>>2]|0)){var d=P(),c=t[b+12>>2];0==(t[c>>2]|0)?V(d,t[t[b+8>>2]+8>>2]):(V(d,t[c+8>>2]),U(d,Xi|0),U(d,t[t[b+8>>2]+8>>2]));var c=d|0,e=t[c>>2];(e+1|0)==(t[d+4>>2]|0)?(R(d),c=t[c>>2]):c=e;e=d+8|0;l[t[e>>2]+c|0]=0;0==(zE(t[Qz>>2],t[e>>2])|0)&&(AE(t[Qz>>2],BE(d)),OF(b,1));Q(d)}}HF.X=1;function OF(b,d){if(0!=(t[Vy+(d<<4)>>2]|0)&&0==(t[b+28>>2]|0)){var c=b+12|0;if(0!=(t[t[c>>2]>>2]|0)){var e=P();V(e,t[t[c>>2]+8>>2]);U(e,Xi|0);c=b+8|0;U(e,t[t[c>>2]+8>>2]);var f=e|0,g=t[f>>2];(g+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=g;g=e+8|0;l[t[g>>2]+f|0]=0;V(t[c>>2],t[g>>2]);Q(e)}c=j;j+=80;e=c>>2;0!=(t[Vy+(d<<4)>>2]|0)&&0==(t[b+28>>2]|0)&&(sC(c,t[t[b+8>>2]+8>>2]),t[e+1]=t[b+16>>2],t[e+2]=t[b+20>>2],t[e+9]=t[Vy+(d<<4)+8>>2],l[c+40|0]=t[Vy+(d<<4)+4>>2]&255,tC(c));j=c}}function IF(b){for(var d=b|0;;){var c=t[d>>2];if(13==(c|0)||3==(c|0)){break}else{7==(c|0)?EF(b):12==(c|0)?FF(b,b):BF(b)}}}function PF(b,d){var c,e,f=yF();c=(b|0)>>2;var g=b+4|0,h=d+8|0,i=0;a:for(;;){BF(b);var m=t[c];do{if(13==(m|0)){var n=0;e=3574;break a}else{if(10==(m|0)){e=3562}else{if(-1==(t[g>>2]|0)){e=3562}else{var q=i;e=3569}}}}while(0);if(3562==e){if(e=0,NF(f,b),BF(b),m=t[c],4!=(m|0)){var p=i,s=m}else{BF(b),0!=(t[g>>2]|0)?(CF(f,t[h>>2]),OF(f,3),BF(b),q=1):(BF(b),e=t[c],7==(e|0)&&(EF(b),e=t[c]),12!=(e|0)?q=i:(CF(f,t[h>>2]),OF(f,2),FF(b,f),BF(b),q=1)),e=3569}}3569==e&&(e=0,p=q,s=t[c]);if(5==(s|0)){i=p}else{break}}if(3574==e){return zF(f),n}IF(b);n=p;zF(f);return n}PF.X=1;function EF(b){var d=b|0;if(7==(t[d>>2]|0)){BF(b);for(var c=1;;){var e=t[d>>2],c=(7==(e|0)&1)+c|0,c=((2==(e|0)&0<(c|0))<<31>>31)+c|0;BF(b);if(!(0!=(c|0)|2!=(e|0))){break}}}}function QF(b){var d=l[b+1|0];100==d<<24>>24||68==d<<24>>24?(d=l[b+2|0],101==d<<24>>24||69==d<<24>>24?(b=l[b+3|0],b=102==b<<24>>24|70==b<<24>>24):b=0):b=0;return b&1}function GF(b){if(0==(t[b+28>>2]|0)){var d=P(),c=t[b+12>>2];0==(t[c>>2]|0)?V(d,t[t[b+8>>2]+8>>2]):(V(d,t[c+8>>2]),U(d,Xi|0),U(d,t[t[b+8>>2]+8>>2]));var c=d|0,e=t[c>>2];(e+1|0)==(t[d+4>>2]|0)?(R(d),c=t[c>>2]):c=e;e=d+8|0;l[t[e>>2]+c|0]=0;0==(zE(t[ez>>2],t[e>>2])|0)&&(AE(t[ez>>2],BE(d)),OF(b,0));Q(d)}}GF.X=1;function FF(b,d){var c,e,f,g,h,i,m=P();h=(b+24|0)>>2;t[h]=t[h]+1|0;g=(b|0)>>2;e=t[g];if(12==(e|0)){if(e=b+4|0,-1!=(t[e>>2]|0)){var n=12,q=e}else{BF(b),c=t[g],i=3606}}else{c=e,i=3606}if(3606==i){if(13==(c|0)){var p=0;Q(m);g=t[h];t[h]=g-1|0;return p}n=c;q=b+4|0}f=(b+12|0)>>2;e=(d+8|0)>>2;c=(m+8|0)>>2;var s=0,r=n;a:for(;;){var u=t[q>>2];do{if(0==(u|0)){V(m,t[t[f]+8>>2]),CF(b,t[e]),AF(b),V(t[f],t[c]),n=s}else{if(7==(u|0)){V(m,t[t[f]+8>>2]),CF(b,t[e]),JF(b,1),V(t[f],t[c]),n=1}else{if(5==(u|0)){V(m,t[t[f]+8>>2]),CF(b,t[e]),JF(b,s),V(t[f],t[c]),n=s}else{if(12==(r|0)){FF(b,d),n=s}else{if(0==(JF(b,s)|0)){p=s;i=3620;break a}else{n=s}}}}}}while(0);BF(b);r=t[g];if(13==(r|0)){p=n;i=3618;break}else{s=n}}if(3620==i||3618==i){return Q(m),g=t[h],t[h]=g-1|0,p}}FF.X=1;function LF(b,d){var c,e,f;f=(b|0)>>2;e=(b+4|0)>>2;c=(b+8|0)>>2;var g=1;a:for(;;){for(;;){if(!g){break a}var h=T();if(92==(h|0)){var h=T(),i=t[f]}else{if(-1==(h|0)){g=0;continue a}if((h|0)==(d|0)){g=0;continue a}i=t[f]}(i+1|0)==(t[e]|0)&&(R(b),i=t[f]);l[t[c]+i|0]=h&255;0!=(h|0)&&(h=t[f]+1|0,t[f]=h,l[t[c]+h|0]=0)}}g=t[f];(g+1|0)!=(t[e]|0)?(c=t[c],c=c+g|0):(R(b),e=t[f],c=t[c],c=c+e|0);l[c]=0}LF.X=1;function MF(b){return 0!=(pA(b)|0)|10>(b-48|0)>>>0?1:95==(b|0)||64==(b|0)||36==(b|0)||35==(b|0)?1:0}function RF(){var b,d=P(),c=eC();if(0!=(c|0)){for(;;){var e=40==l[c]<<24>>24;a:do{if(e){if(0==(QF(c)|0)){for(var f=c;;){var g=f+1|0,f=l[g];if(0==f<<24>>24){break a}var h=l[g];if(0!=(L(f&255)|0)){b=3677;break}if(40==h<<24>>24||41==h<<24>>24){break a}else{if(58==h<<24>>24){var i=g;break}else{f=g}}}do{if(3677==b){if(b=0,58==h<<24>>24){i=g}else{break a}}}while(0);for(;;){var m=i+1|0,n=l[m];if(58==n<<24>>24){i=m}else{break}}if(0!=(QF(i)|0)){for(var f=m,q=n;;){if(0==q<<24>>24){var p=f;break}var s=f+1|0;if(0!=(L(q&255)|0)){p=f;break}f=s;q=l[s]}for(;0!=(L(l[p]&255)|0);){p=p+1|0}SF(d,p)}}else{f=c;for(q=40;;){if(0==q<<24>>24){var r=f;break}s=f+1|0;if(0!=(L(q&255)|0)){r=f;break}f=s;q=l[s]}for(;0!=(L(l[r]&255)|0);){r=r+1|0}SF(d,r)}}}while(0);c=eC();if(0==(c|0)){break}}}Q(d)}RF.X=1;function SF(b,d){var c,e,f;c=l[d];a:do{if(39==c<<24>>24){var g=d+1|0}else{if(40==c<<24>>24){if(e=l[d+1|0],113==e<<24>>24||81==e<<24>>24?(e=l[d+2|0],117==e<<24>>24||85==e<<24>>24?(e=l[d+3|0],111==e<<24>>24||79==e<<24>>24?(e=l[d+4|0],116==e<<24>>24||84==e<<24>>24?(e=l[d+5|0],e=101==e<<24>>24||69==e<<24>>24?0!=(L(l[d+6|0]&255)|0):0):e=0):e=0):e=0):e=0,0==(e&1|0)){g=d}else{for(e=d+7|0;;){if(0==(L(l[e]&255)|0)){g=e;break a}else{e=e+1|0}}}}else{g=d}}}while(0);e=(b|0)>>2;var h=b+4|0;for(c=(b+8|0)>>2;;){var i=l[g];if(0==i<<24>>24||40==i<<24>>24){f=3697;break}if(0!=(L(i&255)|0)){f=3697;break}var i=l[g],m=t[e],n=(m+1|0)==(t[h>>2]|0);if(41==i<<24>>24){f=3704;break}if(n){R(b);var i=l[g],q=t[e]}else{q=m}l[t[c]+q|0]=i;0!=l[g]<<24>>24&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);g=g+1|0}if(3697==f){if(m=t[e],(m+1|0)==(t[h>>2]|0)){f=3705}else{var p=m}}else{3704==f&&(n?f=3705:p=m)}3705==f&&(R(b),p=t[e]);l[t[c]+p|0]=0;0!=(t[e]|0)&&jC(b,By|0,0);S(b)}SF.X=1;function TF(b,d,c){if(0!=(d|0)&0!=(b|0)&b>>>0<d>>>0){for(;;){if(0==(L(l[b]<<24>>24)|0)){var e=d;break}else{b=b+1|0}}for(;0!=(L(l[e]<<24>>24)|0);){e=e-1|0}if(b>>>0<e>>>0){var f=(b|0)==(e|0),d=(c|0)>>2,g=t[d],h=c+4|0,i=(g+1|0)==(t[h>>2]|0);a:do{if(f){var m=i,n=g}else{for(var q=c+8|0,p=b,s=i,r=g;;){if(s&&(R(c),r=t[d]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[d]+1|0,t[d]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[d],s=(r+1|0)==(t[h>>2]|0),(p|0)==(e|0)){m=s;n=r;break a}}}}while(0);m?(R(c),e=t[d]):e=n;l[t[c+8>>2]+e|0]=0;jC(c,zy|0,0);S(c)}}}TF.X=1;function UF(){var b,d=P(),c=VF();if(-1!=(c|0)){for(var e=d+8|0,f=1,g=0,h=0,i=1;;){if(0==(i|0)){var m=g,n=f;b=3760}else{if(0!=(g|0)&9==(c|0)){WF();var q=i,p=h,s=g,r=f}else{m=0,n=1,b=3760}}a:do{if(3760==b){if(b=0,10==(c|0)){q=1,p=h,s=m,r=n}else{if(0!=(L(c)|0)){q=0,p=h,s=m,r=n}else{if(123==(c|0)){XF(123,125),q=0,p=h,s=m,r=n}else{if(35==(c|0)){WF(),q=0,p=h,s=m,r=n}else{if(40==(c|0)){XF(40,41),q=0,p=h,s=m,r=n}else{if(58==(c|0)){q=0,p=h,r=s=1}else{if(0==(n|0)){q=0,p=h,s=m,r=0}else{if(0==(YF(c)|0)){q=0,p=h,s=m,r=0}else{ZF(c,d);q=t[e>>2];if(0==(qA(q,Fg|0)|0)){p=q=0,s=m}else{if(0!=(h|0)){WF(),q=0,p=h,s=m}else{do{if(0==(qA(q,zr|0)|0)){if(0==(YF(c)|0)){p=t[e>>2]}else{ZF($F(),d);jC(d,xy|0,0);WF();q=0;p=1;s=m;r=n;break a}}else{p=q}}while(0);0==(qA(p,ce|0)|0)&&0!=(YF(c)|0)&&ZF($F(),d);q=$F();do{if(0==(bC(Uw|0,q,4)|0)){if(61!=(q|0)){p=q=0;s=m;r=n;break a}}else{f=58==(q|0)?1:m;p=VF();if(61!=(p|0)){W(p);p=q=0;s=f;r=n;break a}if(43==(q|0)){WF();p=q=0;s=f;r=n;break a}}}while(0);jC(d,xy|0,0);WF();s=p=q=0}}r=n}}}}}}}}}}while(0);c=VF();if(-1==(c|0)){break}else{f=r,g=s,h=p,i=q}}}Q(d)}UF.X=1;function VF(){var b=T();92==(b|0)&&(b=T(),b=10!=(b|0)?b:T());return b}function WF(){for(var b;;){var d=VF();if(-1==(d|0)){b=3796;break}else{if(10==(d|0)){break}}}3796!=b&&W(10)}function XF(b,d){var c=j,e,f=b<<24>>24,g=d<<24>>24,h=t[K+20>>2],i=0,m=1;a:for(;;){if(0>=(m|0)){var n=i;break}for(;;){var q=VF();if((q|0)==(f|0)){e=3803;break}if((q|0)==(g|0)){e=3804;break}if(-1==(q|0)||10==(q|0)){n=q;break a}}3803==e?(e=0,i=f,m=m+1|0):3804==e&&(e=0,i=g,m=m-1|0)}-1==(n|0)&&(e=t[t[K+40>>2]+8>>2],KC(Ev|0,(k=j,j+=12,t[k>>2]=e,t[k+4>>2]=f,t[k+8>>2]=h,k)));j=c}function YF(b){return(0==(b|0)?0:0!=(oA(b)|0)?1:0!=(bC(hw|0,b,4)|0))&1}function ZF(b,d){var c;S(d);var e=0==(YF(b)|0);c=(d|0)>>2;var f=d+4|0;a:do{if(e){var g=b}else{for(var h=d+8|0,i=b;;){var m=t[c];(m+1|0)==(t[f>>2]|0)&&(R(d),m=t[c]);l[t[h>>2]+m|0]=i&255;0!=(i|0)&&(i=t[c]+1|0,t[c]=i,l[t[h>>2]+i|0]=0);i=VF();if(0==(YF(i)|0)){g=i;break a}}}}while(0);W(g);e=t[c];(e+1|0)!=(t[f>>2]|0)?(c=t[(d+8|0)>>2],c=c+e|0):(R(d),f=t[c],c=t[(d+8|0)>>2],c=c+f|0);l[c]=0}ZF.X=1;function $F(){for(var b;;){var d=VF();if(10==(d|0)){b=3830;break}if(0==(L(d)|0)){b=3831;break}}if(3831==b||3830==b){return d}}function aG(b,d){V(t[rc>>2],b);t[qc>>2]=d}function bG(){S(t[rc>>2])}function cG(b){var d,c;d=(b+4|0)>>2;a:for(;;){for(var e=t[d];;){if(0==(e|0)){c=3867;break a}var f=l[e];if(0==f<<24>>24){c=3867;break a}if(0!=(dG(f)|0)){c=3869;break a}if(64==f<<24>>24){c=3871;break a}if(0!=((32==f<<24>>24|9==f<<24>>24)&1|0)){c=3873;break}f&=255;if(123==(f|0)){c=3883;break a}else{if(40==(f|0)){c=3875;break a}else{if(45==(f|0)){c=3892;break a}else{if(44==(f|0)){c=3887;break a}else{if(34==(f|0)){c=3890;break a}else{if(43==(f|0)){c=3891;break a}else{if(58==(f|0)){c=3889;break a}else{if(93==(f|0)){c=3886;break a}else{if(125==(f|0)){c=3884;break a}else{if(35==(f|0)){c=3877;break a}else{if(59==(f|0)){c=3888;break a}else{if(92==(f|0)){c=3876;break a}else{if(41==(f|0)){c=3882;break a}else{if(91==(f|0)){c=3885;break a}else{if(47!=(f|0)){c=3893;break a}}}}}}}}}}}}}}}var g=e+1|0,f=l[g];if(42==f<<24>>24){c=3879;break}else{if(47!=f<<24>>24){c=3881;break a}}e=t[d]=0}if(3873==c){c=0;for(var f=b+4|0,h=t[f>>2];0!=((32==l[h]<<24>>24|9==l[h]<<24>>24)&1|0);){h=h+1|0}t[f>>2]=h}else{if(3879==c){c=0;var h=f=ba,f=(b+4|0)>>2,i=t[f]+2|0,m=1,n=1;b:for(;;){c:for(;;){for(var q=0==(m|0),p=i;;){if(q){break b}if(0!=(p|0)){var s=l[p];if(47==s<<24>>24){break}else{if(0!=s<<24>>24){break c}}}i=eC();t[f]=i;if(0==(i|0)){h=3980;break b}else{p=i}}if(n){break}else{i=p,m=0}}i=p+1|0;n=42!=s<<24>>24}3980!=h&&(t[f]=p)}}}if(3871==c){eG(b);var r=mC(t[t[b>>2]+8>>2],t[Uy>>2]),u=-1==(r|0)?37:r}else{if(3883==c){t[d]=e+1|0,u=28}else{if(3875==c){t[d]=e+1|0,u=26}else{if(3892==c){t[d]=e+1|0,u=25}else{if(3887==c){t[d]=e+1|0,u=23}else{if(3890==c){d=(b+4|0)>>2;b=t[d];c=0;a:for(;;){e=b;for(g=0;;){var v=e+1|0;if(c|0==(v|0)){r=3947;break a}p=l[v];if(0==p<<24>>24){r=3948;break a}else{if(34==p<<24>>24&&0==(g|0)){b=v;c=1;continue a}}e=v;g=92==p<<24>>24&1}}3947==r?t[d]=v:3948==r&&(t[d]=v);u=37}else{3891==c?(t[d]=e+1|0,u=24):3893==c?(t[d]=e+1|0,u=37):3869==c?(fG(b),r=mC(t[t[b>>2]+8>>2],t[Uy>>2]),u=-1==(r|0)?22:r):3889==c?(t[d]=e+1|0,u=33):3886==c?(t[d]=e+1|0,u=31):3884==c?(t[d]=e+1|0,u=29):3867==c?(r=eC(),t[d]=r,u=0==(r|0)?38:36):3877==c?(t[d]=e+1|0,u=34):3888==c?(t[d]=e+1|0,u=32):3876==c?(t[d]=e+1|0,u=35):3881==c?(t[d]=g,u=37):3882==c?(t[d]=e+1|0,u=27):3885==c&&(t[d]=e+1|0,u=30)}}}}}}return u}cG.X=1;function dG(b){return(0==(26>(b-97&255)&1|0)?0!=(26>(b-65&255)&1|0):1)&1}function fG(b){var d;d=(b|0)>>2;S(t[d]);var b=(b+4|0)>>2,c=t[b],e=l[c];if(0!=(dG(e)|0)|95==e<<24>>24){var f=t[d],c=t[f>>2];(c+1|0)==(t[f+4>>2]|0)&&(R(f),c=t[d],e=l[t[b]],f=c,c=t[c>>2]);l[t[f+8>>2]+c|0]=e;e=t[b];0!=l[e]<<24>>24&&(e=t[d]|0,c=t[e>>2]+1|0,t[e>>2]=c,l[t[t[d]+8>>2]+c|0]=0,e=t[b])}else{e=c}e=e+1|0;c=l[e];f=0==(gG(c)|0);a:do{if(f){var g=e}else{for(var h=e,i=c;;){var m=t[d],n=t[m>>2];(n+1|0)==(t[m+4>>2]|0)&&(R(m),n=t[d],i=l[h],m=n,n=t[n>>2]);l[t[m+8>>2]+n|0]=i;0!=l[h]<<24>>24&&(i=t[d]|0,n=t[i>>2]+1|0,t[i>>2]=n,l[t[t[d]+8>>2]+n|0]=0);h=h+1|0;i=l[h];if(0==(gG(i)|0)){g=h;break a}}}}while(0);t[b]=g;b=t[d];g=t[b>>2];(g+1|0)!=(t[b+4>>2]|0)?(b=b+8|0,b=t[b>>2],d=b+g|0):(R(b),g=t[d],d=t[g>>2],b=g+8|0,b=t[b>>2],d=b+d|0);l[d]=0}fG.X=1;function hG(b,d){if(27==(d|0)||29==(d|0)||31==(d|0)){var c=t[Kc>>2]-1|0;t[Kc>>2]=c}else{26==(d|0)||28==(d|0)||30==(d|0)?(c=t[Kc>>2]+1|0,t[Kc>>2]=c):c=t[Kc>>2]}0==(c|0)&&(t[z>>2]=t[rd>>2])}function eG(b){var d;d=(b|0)>>2;S(t[d]);var b=(b+4|0)>>2,c=t[b];if(64==l[c]<<24>>24){var e=t[d],f=t[e>>2];(f+1|0)==(t[e+4>>2]|0)?(R(e),f=t[d],c=l[t[b]],e=f,f=t[f>>2]):c=64;l[t[e+8>>2]+f|0]=c;c=t[b];0!=l[c]<<24>>24&&(c=t[d]|0,e=t[c>>2]+1|0,t[c>>2]=e,l[t[t[d]+8>>2]+e|0]=0,c=t[b])}c=c+1|0;e=l[c];f=0==(gG(e)|0);a:do{if(f){var g=c}else{for(var h=c,i=e;;){var m=t[d],n=t[m>>2];(n+1|0)==(t[m+4>>2]|0)&&(R(m),n=t[d],i=l[h],m=n,n=t[n>>2]);l[t[m+8>>2]+n|0]=i;0!=l[h]<<24>>24&&(i=t[d]|0,n=t[i>>2]+1|0,t[i>>2]=n,l[t[t[d]+8>>2]+n|0]=0);h=h+1|0;i=l[h];if(0==(gG(i)|0)){g=h;break a}}}}while(0);t[b]=g;b=t[d];g=t[b>>2];(g+1|0)!=(t[b+4>>2]|0)?(b=b+8|0,b=t[b>>2],d=b+g|0):(R(b),g=t[d],d=t[g>>2],b=g+8|0,b=t[b>>2],d=b+d|0);l[d]=0}eG.X=1;function gG(b){return(0==(10>(b-48&255)&1|0)?95==b<<24>>24|0!=(dG(b)|0):1)&1}function iG(b,d){var c=j;j+=80;sC(c,b);t[c+36>>2]=t[uy+(d<<4)+8>>2];l[c+40|0]=t[uy+(d<<4)+4>>2]&255;var e=t[rc>>2];0!=(e|0)&&(t[c+60>>2]=t[uy+(t[qc>>2]<<4)+8>>2],t[c+64>>2]=t[e+8>>2]);tC(c);j=c}function jG(b,d){24==(d|0)?(t[z>>2]=238,t[Ac>>2]=4):10==(d|0)?(bG(),t[z>>2]=16):25==(d|0)?(t[z>>2]=238,t[Ac>>2]=3):28==(d|0)&&(t[z>>2]=250,hG(0,28),t[rd>>2]=26)}function kG(b){return 32==b<<24>>24||9==b<<24>>24||13==b<<24>>24||10==b<<24>>24?1:0}function lG(b){var d,b=(b+4|0)>>2,c=t[b],e=0;a:for(;;){for(var f=c,g=0;;){var h=f+1|0;if(e|0==(h|0)){d=24;break a}var i=l[h];if(34==i<<24>>24){if(0==(g|0)){c=h;e=1;continue a}}else{if(0==i<<24>>24){d=25;break a}}f=h;g=92==i<<24>>24&1}}24==d?t[b]=h:25==d&&(t[b]=h)}function mG(){for(var b,d=t[t[K+40>>2]+8>>2],c=tb(d),e=P();;){var f=c-1|0;if(0<(f|0)&46!=l[d+f|0]<<24>>24){c=f}else{var g=f;break}}for(;;){if(0>=(g|0)){var h=g;break}c=l[d+g|0];if(92==c<<24>>24||47==c<<24>>24){b=41;break}g=g-1|0}41==b&&(h=g+1|0);b=d+h|0;f=f-h|0;S(e);gD(e,b,f);f=e|0;h=t[f>>2];(h+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=h;h=e+8|0;l[t[h>>2]+f|0]=0;f=t[h>>2];h=l[f];0!=(26>(h-97&255)&1|0)&&(l[f]=h-32&255);nG(e,2);Q(e)}mG.X=1;function oG(b,d){27==(d|0)||14==(d|0)||13==(d|0)?(pG(),t[z>>2]=248,t[Tc>>2]=248):7==(d|0)?(pG(),t[z>>2]=128,t[Tc>>2]=122):0==(d|0)?(pG(),t[z>>2]=t[Tc>>2]):26==(d|0)?(pG(),t[z>>2]=86,t[Tc>>2]=86):17==(d|0)?(pG(),t[z>>2]=68,t[Tc>>2]=68):6==(d|0)?(l[yc]=0,qG()):16==(d|0)?(pG(),t[z>>2]=88):2==(d|0)&&(pG(),t[z>>2]=24,t[Tc>>2]=24)}function rG(b){var d,c;d=(b+4|0)>>2;a:for(;;){for(var e=t[d];;){if(0!=(e|0)){var f=l[e];if(0!=f<<24>>24){break}}var g=eC();t[d]=g;if(0==(g|0)){var h=48;break a}else{e=g}}if(0!=(sG(f)|0)){c=75;break}if(0!=(10>(f-48&255)&1|0)){c=77;break}if(0!=(kG(f)|0)){for(var g=b+4|0,i=t[g>>2];0!=(kG(l[i])|0);){i=i+1|0}t[g>>2]=i}else{g=f&255;if(0!=(t[Gc+(g<<2)>>2]|0)){c=81;break}if(123==(g|0)){c=89;break}else{if(125==(g|0)){c=90;break}else{if(39==(g|0)){c=91;break}else{if(41==(g|0)){c=86;break}else{if(91==(g|0)){c=87;break}else{if(93==(g|0)){c=88;break}else{if(44==(g|0)){c=92;break}else{if(61==(g|0)){c=93;break}else{if(59==(g|0)){c=94;break}else{if(34==(g|0)){c=95;break}else{if(95==(g|0)){c=96;break}else{if(35==(g|0)){c=97;break}else{if(92==(g|0)){c=98;break}else{if(40!=(g|0)){c=99;break}}}}}}}}}}}}}}var m=e+1|0;if(42!=l[m]<<24>>24){c=85;break}tG(b)}}if(89==c){t[d]=e+1|0,h=36}else{if(90==c){t[d]=e+1|0,h=37}else{if(91==c){t[d]=e+1|0,h=38}else{if(85==c){t[d]=m,h=32}else{if(86==c){t[d]=e+1|0,h=33}else{if(81==c){h=uG(b)}else{if(87==c){t[d]=e+1|0,h=34}else{if(88==c){t[d]=e+1|0,h=35}else{if(75==c){vG(b),b=mC(t[t[b>>2]+8>>2],t[Ty>>2]),h=-1==(b|0)?31:b}else{if(77==c){b=b+4|0;d=t[b>>2];if(0!=(10>(l[d]-48&255)&1|0)){for(;!(d=d+1|0,t[b>>2]=d,0==(10>(l[d]-48&255)&1|0));){}}h=41}else{92==c?(t[d]=e+1|0,h=44):93==c?(t[d]=e+1|0,h=40):94==c?(t[d]=e+1|0,h=43):95==c?(lG(b),h=41):96==c?(t[d]=e+1|0,h=41):97==c?(t[d]=e+1|0,h=46):98==c?(t[d]=e+1|0,h=47):99==c&&(t[d]=e+1|0,h=41)}}}}}}}}}}return h}rG.X=1;function sG(b){return(0==(26>(b-97&255)&1|0)?0!=(26>(b-65&255)&1|0):1)&1}function vG(b){var d;d=(b|0)>>2;S(t[d]);var b=(b+4|0)>>2,c=t[b],e=l[c];if(0!=(sG(e)|0)|95==e<<24>>24){var f=t[d],c=t[f>>2];(c+1|0)==(t[f+4>>2]|0)&&(R(f),c=t[d],e=l[t[b]],f=c,c=t[c>>2]);l[t[f+8>>2]+c|0]=e;e=t[b];0!=l[e]<<24>>24&&(e=t[d]|0,c=t[e>>2]+1|0,t[e>>2]=c,l[t[t[d]+8>>2]+c|0]=0,e=t[b])}else{e=c}e=e+1|0;c=l[e];f=0==(wG(c)|0);a:do{if(f){var g=e}else{for(var h=e,i=c;;){var m=t[d],n=t[m>>2];(n+1|0)==(t[m+4>>2]|0)&&(R(m),n=t[d],i=l[h],m=n,n=t[n>>2]);l[t[m+8>>2]+n|0]=i;0!=l[h]<<24>>24&&(i=t[d]|0,n=t[i>>2]+1|0,t[i>>2]=n,l[t[t[d]+8>>2]+n|0]=0);h=h+1|0;i=l[h];if(0==(wG(i)|0)){g=h;break a}}}}while(0);t[b]=g;b=t[d];g=t[b>>2];(g+1|0)!=(t[b+4>>2]|0)?(b=b+8|0,b=t[b>>2],d=b+g|0):(R(b),g=t[d],d=t[g>>2],b=g+8|0,b=t[b>>2],d=b+d|0);l[d]=0}vG.X=1;function uG(b){var d;d=(b+4|0)>>2;var c=t[d],b=(b|0)>>2;S(t[b]);var e=t[d],f=0==(t[Gc+((l[e]&255)<<2)>>2]|0),g=t[b],h=(t[g>>2]+1|0)==(t[g+4>>2]|0);a:do{if(f){var i=0,m=h,n=g}else{for(var q=0,p=g,s=h,r=e;;){if(s&&(R(p),r=t[d],p=t[b]),l[t[p+8>>2]+t[p>>2]|0]=l[r+q|0],p=t[d],0==l[p+q|0]<<24>>24?r=p:(p=t[b]|0,r=t[p>>2]+1|0,t[p>>2]=r,l[t[t[b]+8>>2]+r|0]=0,r=t[d]),q=q+1|0,p=t[b],s=(t[p>>2]+1|0)==(t[p+4>>2]|0),0==(t[Gc+((l[r+q|0]&255)<<2)>>2]|0)){i=q;m=s;n=p;break a}}}}while(0);m?(R(n),m=t[b]):m=n;l[t[m+8>>2]+t[m>>2]|0]=0;t[d]=t[d]+i|0;if(2>(i|0)){d=l[c]&255,d=61==(d|0)?40:124==(d|0)?39:42}else{if(2==(i|0)&&45==l[c]<<24>>24&&62==l[c+1|0]<<24>>24){return 45}d=42}return d}uG.X=1;function tG(b){var d,c;d=(b+4|0)>>2;var e=t[d]+2|0,f=1,g=0;a:for(;;){var g=0==(g|0),h=e;b:for(;;){var e=0==(f|0),i=h;c:for(;;){if(e){c=167;break a}do{if(0!=(i|0)&&(h=l[i],0!=h<<24>>24)){if(42==h<<24>>24){var m=1;c=166;break b}else{if(41==h<<24>>24){break c}else{if(40==h<<24>>24){c=161;break b}else{if(34!=h<<24>>24){c=165;break b}}}}t[d]=i;lG(b);i=t[d];continue c}}while(0);h=eC();t[d]=h;if(0==(h|0)){c=169;break a}else{i=h}}if(g){m=0;c=166;break}else{h=i,f=0}}do{if(161==c){if(c=0,42!=l[i+1|0]<<24>>24){m=0,c=166}else{t[d]=i;tG(b);var n=t[d];if(0==(n|0)){c=170;break a}else{var q=0}}}else{165==c&&(m=0,c=166)}}while(0);166==c&&(c=0,n=i,q=m&1);e=n+1|0;g=q}167==c&&(t[d]=i)}function xG(){for(var b,d=t[Xb>>2];;){var c=d-1|0;if(0>=(d|0)){var e=-1;b=205;break}if(0==(t[t[Yb+(c<<4)+12>>2]>>2]|0)){d=c}else{e=c;b=204;break}}if(205==b||204==b){return e}}function yG(b,d){if(42==(d|0)){var c=l[t[b+8>>2]]<<24>>24;58==(c|0)?(t[rd>>2]=20,t[z>>2]=154,t[Ib>>2]=40):126==(c|0)?(t[z>>2]=172,l[md]=0):63==(c|0)&&(t[z>>2]=144,l[md]=0)}else{40==(d|0)&&(t[z>>2]=20)}}function wG(b){if(0!=(10>(b-48&255)&1|0)){return 1}b=0!=(sG(b)|0)|95==b<<24>>24|39==b<<24>>24;return b&1}function pG(){l[yc]&&(l[yc]=0,zG())}function qG(){var b=zG();5==(b|0)?zG():4==(b|0)?zG():3==(b|0)?zG():0==(b|0)&&zG()}function nG(b,d){var c=j;j+=80;!(0==(t[ry+(d<<4)>>2]|0)|0==(b|0))&&0!=(t[b>>2]|0)&&(AG(c,t[b+8>>2],d),tC(c));j=c}function AG(b,d,c){var e=b>>2;sC(b,d);t[e+9]=t[ry+(c<<4)+8>>2];l[b+40|0]=t[ry+(c<<4)+4>>2]&255;2==(c|0)&&(t[e]=1,t[e+1]=1);b=xG();-1<(b|0)&&(t[e+15]=0==(t[Yb+(b<<4)+4>>2]|0)?wf|0:6==(t[Yb+(b<<4)+4>>2]|0)?al|0:2==(t[Yb+(b<<4)+4>>2]|0)?Fi|0:3==(t[Yb+(b<<4)+4>>2]|0)?Eq|0:1==(t[Yb+(b<<4)+4>>2]|0)?ll|0:4==(t[Yb+(b<<4)+4>>2]|0)?Cf|0:5==(t[Yb+(b<<4)+4>>2]|0)?Bw|0:0,t[e+16]=t[t[Yb+(b<<4)+12>>2]+8>>2])}function zG(){for(var b,d=t[Xb>>2];;){var c=d-1|0;if(0>=(d|0)){b=300;break}if(0==(t[Yb+(c<<4)>>2]|0)){b=299;break}else{d=c}}if(299==b){return t[Xb>>2]=c,t[z>>2]=t[Yb+(c<<4)+8>>2],S(t[Yb+(c<<4)+12>>2]),b=t[Yb+(c<<4)+4>>2]}if(300==b){return t[Xb>>2]=0,t[z>>2]=122,-1}}function BG(b,d,c,e){var f=j,g=t[Xb>>2];255<(g|0)?KC(Qk|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k)):(t[Yb+(g<<4)>>2]=b,t[Yb+(g<<4)+4>>2]=d,t[Yb+(g<<4)+8>>2]=c,b=xG(),0==(e|0)?(t[Xb>>2]=g+1|0,S(t[Yb+(g<<4)+12>>2])):(g=t[Yb+(g<<4)+12>>2],-1<(b|0)?(V(g,t[t[Yb+(b<<4)+12>>2]+8>>2]),g=t[Yb+(t[Xb>>2]<<4)+12>>2],d=t[g>>2],(d+1|0)==(t[g+4>>2]|0)&&(R(g),g=d=t[Yb+(t[Xb>>2]<<4)+12>>2],d=t[d>>2]),c=4==(t[Yb+(b<<4)+4>>2]|0)||5==(t[Yb+(b<<4)+4>>2]|0)||3==(t[Yb+(b<<4)+4>>2]|0)||1==(t[Yb+(b<<4)+4>>2]|0)?47:0==(t[Yb+(b<<4)+4>>2]|0)?46:6==(t[Yb+(b<<4)+4>>2]|0)?32:2==(t[Yb+(b<<4)+4>>2]|0)?35:36,b=g+8|0,l[t[b>>2]+d|0]=c,0!=c<<24>>24&&(d=g|0,c=t[d>>2]+1|0,t[d>>2]=c,l[t[b>>2]+c|0]=0),U(g,t[e+8>>2])):V(g,t[e+8>>2]),t[Xb>>2]=t[Xb>>2]+1|0));j=f}BG.X=1;function CG(b,d){30==(d|0)?(DG(),t[z>>2]=160,EG(160)):11==(d|0)?(EG(12),t[z>>2]=20):1==(d|0)?(BG(0,6,20,0),t[z>>2]=20):6==(d|0)?qG():10==(d|0)?(t[rd>>2]=20,t[z>>2]=114,t[Ib>>2]=45):36==(d|0)?(t[z>>2]=104,t[Ib>>2]=37,t[rd>>2]=12,FG(0,36)):39==(d|0)||33==(d|0)||35==(d|0)||37==(d|0)?DG():12==(d|0)?GG():5==(d|0)||24==(d|0)?(DG(),EG(12),t[z>>2]=20):0==(d|0)?(GG(),t[z>>2]=188):15==(d|0)?(EG(12),t[z>>2]=20):32==(d|0)||34==(d|0)?(EG(12),t[z>>2]=20):43==(d|0)?t[z>>2]=20:4==(d|0)||27==(d|0)||(l[yc]=1,oG(0,d))}function EG(b){BG(1,3,b,0)}function GG(){var b=xG();-1<(b|0)?(t[Xb>>2]=b,t[z>>2]=t[Yb+(b<<4)+8>>2],S(t[Yb+(b<<4)+12>>2])):(t[Xb>>2]=0,t[z>>2]=122)}function DG(){var b=t[Xb>>2];1>(b|0)?t[z>>2]=122:(b=b-1|0,t[Xb>>2]=b,t[z>>2]=t[Yb+(b<<4)+8>>2],S(t[Yb+(b<<4)+12>>2]))}function FG(b,d){35==(d|0)?t[qd>>2]=t[qd>>2]+1|0:33==(d|0)?t[od>>2]=t[od>>2]+1|0:34==(d|0)?t[qd>>2]=t[qd>>2]-1|0:37==(d|0)?t[pd>>2]=t[pd>>2]+1|0:36==(d|0)?t[pd>>2]=t[pd>>2]-1|0:32==(d|0)&&(t[od>>2]=t[od>>2]-1|0);(t[Ib>>2]|0)==(d|0)&0==(t[od>>2]|0)&0==(t[qd>>2]|0)&0==(t[pd>>2]|0)?t[z>>2]=t[rd>>2]:6==(d|0)&&(zG(),t[z>>2]=122)}function HG(){var b=j;j+=80;var d,c=P(),e=eC();t[nd>>2]=e;if(0!=(e|0)){for(var f=0,g=0,h=0,i=0,m=0,n=0,q=0,p=0;;){var s=e+1|0;t[nd>>2]=s;var r=l[e],e=r&255;if(0==r<<24>>24){if(r=eC(),t[nd>>2]=r,0==(r|0)){var u=p,v=q,w=n,C=m,A=i,I=h,M=g,B=f}else{if(s=l[r],0==s<<24>>24){u=p,v=q,w=n,C=m,A=i,I=h,M=g,B=f}else{if((0==(h|0)|0==(f|0))&0==(i|0)){d=r+1|0,t[nd>>2]=d,G=s&255,Z=d}else{var G=e,Z=r}d=522}}}else{G=e,Z=s,d=522}a:do{if(522==d){if(d=0,0!=(q|0)){123==(n|0)&125==(G|0)?(u=p,v=0,w=n):40==(n|0)&42==(G|0)?(41!=l[Z]<<24>>24?(u=p,v=q):(t[nd>>2]=Z+1|0,u=p,v=0),w=40):(u=p,v=q,w=n),C=m,A=i,I=h,M=g,B=f}else{if(0!=(m|0)){u=p,v=0,w=n,C=39==(G|0)?0:m,A=i,I=h,M=g,B=f}else{if(40==(G|0)){42==l[Z]<<24>>24?(t[nd>>2]=Z+1|0,u=p,v=1,w=40,C=0,A=i,I=h,M=g):(u=p,v=0,w=n,C=0,A=i,I=h,M=0==(h|0)?g:1),B=f}else{if(123==(G|0)){u=p,v=1,w=123,C=0,A=i,I=h,M=g,B=f}else{if(39==(G|0)){u=p,v=0,w=n,C=1,A=i,I=h,M=g,B=f}else{if(41==(G|0)){u=p,v=0,w=n,C=0,A=i,I=h,M=0,B=f}else{if(59==(G|0)){if(0!=(h|0)&0==(g|0)){e=1}else{u=p;v=0;w=n;C=0;A=i;I=h;M=g;B=f;break}}else{e=f}do{if(0==(h|0)|0==(e|0)){I=h,B=e}else{B=l[Z];if(0==B<<24>>24){u=p;v=0;w=n;C=0;A=i;I=h;M=g;B=e;break a}else{if(32==B<<24>>24){I=h;B=e;break}}0==(rA(101==B<<24>>24&1)|0)?102!=(rA(l[t[nd>>2]]&255)|0)?(B=h,u=e):(B=(u=0==(IG(cl|0)|0))?h:0,u=u?e:0):(B=(u=0==(IG(Vn|0)|0))?h:0,u=u?e:0);if(0==(B|0)|0==(u|0)){I=B,B=u}else{0!=(t[b+32>>2]|0)&&tC(b);u=p;v=0;w=n;C=0;A=i;I=0;M=g;B=0;break a}}}while(0);if(0==(i|0)){0!=(I|0)?(u=p,v=0,w=n,A=C=0):(u=rA(G),99==(u|0)?(u=(A=0==(IG(oj|0)|0))?p:1,v=0,w=n,C=0,A=A&1^1):100==(u|0)?(u=(A=0==(IG(Mh|0)|0))?p:1,v=0,w=n,C=0,A=A&1^1):112==(u|0)?(u=(A=0==(IG(sg|0)|0))?p:1,v=0,w=n,C=0,A=A&1^1):102==(u|0)?(u=(A=0==(IG(of|0)|0))?p:0,v=0,w=n,C=0,A=A&1^1):(u=p,v=0,w=n,A=C=0),I=0)}else{if(u=l[t[nd>>2]],0==u<<24>>24){u=p,v=0,w=n,C=0,A=i}else{u=0==(L(u&255)|0);v=t[nd>>2];b:do{if(u){var X=v}else{for(w=v;;){if(w=w+1|0,t[nd>>2]=w,C=t[nd>>2],0==(L(l[w]&255)|0)){X=C;break b}else{w=C}}}}while(0);b:for(;;){u=l[X];if(0==u<<24>>24){break}do{if(0==(oA(u&255)|0)&&(v=l[X],!(95==v<<24>>24||46==v<<24>>24)&&10<=((v&255)-48|0)>>>0)){break b}}while(0);X=X+1|0}w=t[nd>>2];u=c;v=w;w=X-w|0;S(u);gD(u,v,w);u=b;v=p;!(0==(t[ky+(v<<4)>>2]|0)|0==(c|0))&&0!=(t[c>>2]|0)?(sC(u,t[c+8>>2]),t[u+36>>2]=t[ky+(v<<4)+8>>2],l[u+40|0]=t[ky+(v<<4)+4>>2]&255):sC(u,0);t[nd>>2]=X;u=p;v=0;w=n;A=C=0;I=1}}M=g}}}}}}}}while(0);e=t[nd>>2];if(0==(e|0)){break}else{f=B,g=M,h=I,i=A,m=C,n=w,q=v,p=u}}}Q(c);j=b}HG.X=1;function IG(b){for(var d,c=0;;){var e=l[b];if(0==e<<24>>24){break}if((rA(e<<24>>24)|0)!=(rA(l[t[nd>>2]+c|0]&255)|0)){d=568;break}b=b+1|0;c=c+1|0}if(568==d&&0!=l[b]<<24>>24||0!=(oA(l[t[nd>>2]+c|0]&255)|0)){return 0}d=t[nd>>2]+c|0;b=l[d];if(95==b<<24>>24||46==b<<24>>24){return 0}t[nd>>2]=d;return 1}function JG(){var b,d,c,e,f=j;j+=80;var g,h=P();e=(h|0)>>2;var i=h+4|0;c=(h+8|0)>>2;var m=f+40|0,n=f+36|0,q=f+32|0,p=0,s=0;a:for(;;){var r=eC();if(0==(r|0)){var u=p;break}if(0!=(s|0)){s=0==(N(r,nj|0,4)|0)?0:s}else{if(s=l[r],61==s<<24>>24){r=r+1|0;if(0==(pA(l[r]<<24>>24)|0)){r=0}else{c:{for(var s=r,v=aq|0,w=ba,C={};;){w=l[v++];if(!w){break}C[w]=1}for(;;){w=l[s];if(!w){break}if(w in C){break c}s++}s=0}v=0==(s|0)?tb(r):s-r|0;s=zC(v+1|0);iB(s,r,v);for(v=r=l[s+v|0]=0;;){var A=0==(qA(s,t[Fc+(v<<2)>>2])|0)?1:r,v=v+1|0;if(11>v>>>0&0==(A|0)){r=A}else{break}}vB(s);r=A}s=r}else{if(0==(qA(r,Lh|0)|0)){u=p;break}if(0==(qA(r,rg|0)|0)){u=p;break}if(35!=s<<24>>24){for(;;){v=r+1|0;if(0==(L(s&255)|0)){break}r=v;s=l[v]}do{if(0==(N(r,nf|0,3)|0)){b=p;var I=4,M=r+3|0}else{if(0==(N(r,Ze|0,3)|0)){s=r+3|0;if(0==(L(l[s]&255)|0)){s=0;continue a}for(;;){v=l[s];if(0==v<<24>>24){break}if(0==(L(v&255)|0)){break}else{s=s+1|0}}if(0!=(N(s,Rr|0,8)|0)){s=0;continue a}b=p;I=0;M=s+8|0}else{if(0!=(N(r,Gi|0,7)|0)){if(0==(N(r,as|0,6)|0)){b=p;I=1;M=r+6|0;g=631;break}if(0==((95==(l[r]&255|0)|0!=(pA(l[r]&255)|0))&1|0)){s=0;continue a}else{s=r}for(;;){if(0==(KG(l[s]&255)|0)){var B=s;break}else{s=s+1|0}}for(;;){var G=B+1|0;if(0==(L(l[B]&255)|0)){break}else{B=G}}if(58!=l[B]<<24>>24){s=0;continue a}if(s=58==l[G]<<24>>24){s=0;continue a}else{var Z=r,X=p;d=X>>2;var ga=s?-1:2,ra=1;break}}g=r+7|0;0==(p|0)?I=P():(S(p),I=p);for(v=g;0!=(L(l[v]&255)|0);){v=v+1|0}b=(I|0)>>2;M=I+4|0;for(s=I+8|0;;){w=l[v];if(59==w<<24>>24){break}if(0!=(L(w&255)|0)){break}w=t[b];(w+1|0)==(t[M>>2]|0)&&(R(I),w=t[b]);l[t[s>>2]+w|0]=l[v];0!=l[v]<<24>>24&&(w=t[b]+1|0,t[b]=w,l[t[s>>2]+w|0]=0);v=v+1|0}U(I,Bv|0);b=I;I=3;M=g}}g=631}while(0);do{if(631==g){if(g=0,p=l[M],0==p<<24>>24){Z=M,X=b,d=X>>2,ga=I,ra=0}else{if(0==(L(p&255)|0)){p=b;s=0;continue a}else{Z=M,X=b,d=X>>2,ga=I,ra=0}}}}while(0);for(p=Z;;){if(0==(L(l[p]&255)|0)){var ka=p;break}p=p+1|0}b:for(;;){p=l[ka];if(!(0==p<<24>>24||35==p<<24>>24)){var ia=ka,ea=p;break}p=eC();if(0==(p|0)){u=X;break a}for(;;){if(0==(L(l[p]&255)|0)){ka=p;continue b}else{p=p+1|0}}}for(;;){if(0==(KG(ea&255)|0)){if(1==(ga|0)){g=647;break}else{if(3!=(ga|0)){break}}if(58!=l[ia]<<24>>24){break}}ea=t[e];(ea+1|0)==(t[i>>2]|0)&&(R(h),ea=t[e]);l[t[c]+ea|0]=l[ia];0!=l[ia]<<24>>24&&(ea=t[e]+1|0,t[e]=ea,l[t[c]+ea|0]=0);ia=ea=ia+1|0;ea=l[ea]}647==g&&(g=0,0==(t[e]|0)&&61==l[ia]<<24>>24&&U(h,Fu|0));p=t[e];(p+1|0)==(t[i>>2]|0)&&(R(h),p=t[e]);l[t[c]+p|0]=0;if(0!=(t[e]|0)){do{if(4==(ga|0)){sC(f,t[c]);do{p=ba;s=ia;r=v=0;b:for(;;){for(w=s;;){var wb=l[w];if(0!=wb<<24>>24){break}s=eC();if(0==(s|0)){var sb=0;break b}else{w=s}}s=0==(r|0);for(C=wb;;){C&=255;if(32==(C|0)||9==(C|0)){var Db=v,Za=r;break}else{if(58==(C|0)){p=688;break}else{if(40==(C|0)){p=690;break}else{if(41==(C|0)){p=691;break}else{if(59==(C|0)){if(s){sb=1;break b}}else{if(123==(C|0)&&s){sb=0;break b}}}}}}if(0==(v|0)){p=697;break}if(0==((95==(C|0)|0!=(pA(C)|0))&1|0)){sb=0;break b}else{v=w}for(;;){var kc=v+1|0;if(0==(KG(l[kc]&255)|0)){break}else{v=kc}}w=kc;v=0;C=l[kc]}do{if(688==p){if(p=0,s){if(1==(v|0)){sb=0;break b}else{Db=1,Za=0}}else{Db=v,Za=r}}else{if(690==p){p=0,Db=v,Za=r+1|0}else{if(691==p){p=0,Db=v,Za=r-1|0}else{if(697==p){if(p=0,s){sb=0;break b}else{Db=0,Za=r}}}}}}while(0);s=w+1|0;v=Db;r=Za}if(1==(sb|0)){if(1==(t[iy+80>>2]|0)){p=5}else{S(h);p=X;s=0;continue a}}else{p=4}}while(0);l[m]=t[iy+(p<<4)+4>>2]&255;t[n>>2]=t[iy+(p<<4)+8>>2];tC(f);!(0==(t[oy+4>>2]|0)|ra|0==(X|0))&&0!=(t[d]|0)&&(p=P(),V(p,t[d+2]),U(p,t[c]),t[q>>2]=t[p+8>>2],tC(f),Q(p))}else{jC(h,iy|0,ga),!(0==(t[oy+4>>2]|0)|ra|3==(ga|0)|0==(X|0))&&0!=(t[d]|0)&&(p=P(),V(p,t[d+2]),U(p,t[c]),jC(p,iy|0,ga),Q(p))}}while(0)}S(h);p=X}s=0}}}Q(h);0!=(u|0)&&Q(u);j=f}JG.X=1;function KG(b){return(95==(b|0)|0!=(oA(b)|0))&1}function LG(){var b,d,c,e=j;j+=12;var f,g=e+4;c=g>>2;var h=e+8,i=P(),m=P(),n=P(),q=MG(12);t[e>>2]=0;var p=i|0,s=i+8|0;d=(m|0)>>2;var r=m+4|0;b=(m+8|0)>>2;var u=n|0,v=0,w=1;a:for(;;){for(;;){var C=eC();if(0==(C|0)){break a}var A=l[NG(C)];if(0!=A<<24>>24){if(35!=A<<24>>24){break}if(!w){break}}}0==(v|0)&&S(i);U(i,C);DD(i);var I=t[s>>2],M=92==l[I+(t[p>>2]-1)|0]<<24>>24;b:do{if(M){zD(i);U(i,Eo|0);var B=1}else{var G=NG(I),Z=G-I|0;if(w){for(var X=ba,ga=t[q+4>>2],ra=q|0,ka=n+8|0,ia=0;;){if((ia|0)>=(ga|0)){X=770;break}var ea=t[ra>>2],wb=ea+12*ia|0;if(0!=(wb|0)){var sb=t[(ea+4>>2)+(3*ia|0)];if(0==(qA(t[ka>>2],t[sb+8>>2])|0)){break}}ia=ia+1|0}770!=X&&((t[wb>>2]|0)<(Z|0)||S(sb));var Db=OG(G,e);if(0!=(Db|0)){PG(Db+3|0,e)}else{for(var Za,kc=G;;){if(0==l[kc]<<24>>24){var $c=0;break}var Ia=QG(kc);if(0==(N(Ia,wk|0,3)|0)){$c=Ia;break}if(0==(N(Ia,Fi|0,5)|0)){$c=Ia;break}if(0==(N(Ia,kn|0,4)|0)){$c=Ia;break}if(0==(N(Ia,Ym|0,5)|0)){$c=Ia;break}kc=RG(Ia)}Za=$c;var Eb=0==(Za|0);c:do{if(!Eb){t[c]=0;do{if(0==(N(Za,ng|0,4)|0)){var Pb=NG(Za+3|0)}else{if(0==(N(Za,gf|0,6)|0)){var He=NG(Za+5|0);t[c]=1;Pb=He}else{if(0==(N(Za,Fd|0,5)|0)){var Hd=SG(NG(Za+4|0),g);if(0==(Hd|0)){break c}else{Pb=Hd;break}}if(0!=(N(Za,Mw|0,6)|0)){break c}var de=SG(NG(Za+5|0),g);if(0==(de|0)){break c}else{Pb=de}}}}while(0);var ee=TG(q,Z,n),Id=t[c];if(0==(Id|0)){var Jd=m,uc=n,Kd=ee,Qb;var Mc=UG(Pb,Jd),ad=ba;if(0==(Mc|0)){var bb=0}else{var Qa=mA(Mc,40);if(0==(Qa|0)){bb=0}else{var Rb=1,vc=Qa;e:for(;;){for(var Sb=0<(Rb|0),fe=vc;;){var vd=fe+1|0;if(!Sb){break e}var lc=l[vd];if(41==lc<<24>>24){ad=981;break}else{if(40==lc<<24>>24){ad=980;break}else{if(0==lc<<24>>24){break e}else{fe=vd}}}}981==ad?(ad=0,Rb=Rb-1|0,vc=vd):980==ad&&(ad=0,Rb=Rb+1|0,vc=vd)}l[vd]=0;bb=jB(Qa)}}Qb=bb;VG(Jd,uc,Kd);0!=(Qb|0)&&vB(Qb)}else{WG(Pb,m,n,ee)}for(var Nc=Z,ge=m,he=Id,Tb=q|0,Ub=q+4|0,bd=t[Ub>>2],cd=0,ac=0;;){if((ac|0)>=(bd|0)){var ie=cd;break}var Ld=t[Tb>>2]+12*ac|0;if((t[Ld>>2]|0)<(Nc|0)){cd=Ld,ac=ac+1|0}else{ie=Ld;break}}if((ac|0)==(bd|0)){var gb=q,dd=ge,Vb=ba,Sa=ba,Sa=(gb+4|0)>>2,Oc=t[Sa],Pc=gb+8|0,Md=t[Pc>>2];if((Oc|0)<(Md|0)){var ed=Oc,je=gb|0}else{var ke=Md+1|0;t[Pc>>2]=ke;var wd=gb|0,Vb=wd>>2;t[Vb]=jF(t[Vb],12*ke|0);var xd=P();t[(t[Vb]+4>>2)+(3*t[Sa]|0)]=xd;ed=t[Sa];je=wd}var ob=t[je>>2];t[Sa]=ed+1|0;V(t[(ob+4>>2)+(3*ed|0)],t[dd+8>>2]);t[(ob+8>>2)+(3*ed|0)]=0;var Fb=t[Tb>>2]+12*bd|0}else{t[Ub>>2]=ac+1|0,V(t[ie+4>>2],t[ge+8>>2]),Fb=ie}t[Fb>>2]=Nc;t[Fb+8>>2]=0==(he|0)&1}}while(0);var fd=XG(I);do{if(0!=(fd|0)){S(m);var le=0==(YG(l[fd]<<24>>24)|0),gd=t[d],yd=(gd+1|0)==(t[r>>2]|0);c:do{if(le){var Nd=yd,Od=gd}else{for(var wc=fd,xc=yd,hd=gd;;){if(xc){R(m);var Pd=t[d]}else{Pd=hd}l[t[b]+Pd|0]=l[wc];if(0!=l[wc]<<24>>24){var bc=t[d]+1|0;t[d]=bc;l[t[b]+bc|0]=0}var me=wc+1|0,Qd=t[d],ne=(Qd+1|0)==(t[r>>2]|0);if(0==(YG(l[me]<<24>>24)|0)){Nd=ne;Od=Qd;break c}else{wc=me,xc=ne,hd=Qd}}}}while(0);if(Nd){R(m);var cc=t[d]}else{cc=Od}l[t[b]+cc|0]=0;var id=TG(q,Z,n),yb=0!=(id|0);if(0==(ZG(fd,h)|0)){if(!yb&&0!=(t[u>>2]|0)){B=0;break b}var Rd=t[b],oe=n,jd=ba,Qc=j;j+=80;jd=Qc>>2;sC(Qc,Rd);t[jd+9]=qf|0;l[Qc+40|0]=118;0!=(t[oe>>2]|0)&&(t[jd+15]=Fi|0,t[jd+16]=t[oe+8>>2]);tC(Qc);j=Qc}else{yb?f=743:0==(t[u>>2]|0)&&(f=743),743==f&&(f=0,VG(m,n,id)),vB(t[h>>2])}}}while(0);var mc=tA(QG(I),Yv|0);if(0!=(mc|0)&&0!=(L(l[mc+6|0]<<24>>24)|0)){var pe=NG(mc+7|0),Rc=P(),kd=P(),nc=QG(pe),Sd=0==l[nc]<<24>>24;c:do{if(!Sd){for(var Sc=kd+8|0,Td=Rc+8|0,qe=nc;;){var hf=QG(UG(qe,Rc));UG(hf,kd);0!=(qA(t[Sc>>2],Ur|0)|0)&&0!=(qA(t[Td>>2],Ur|0)|0)&&jC(Rc,fy|0,4);if(0==l[hf]<<24>>24){break c}else{qe=hf}}}}while(0);Q(Rc);Q(kd)}}}else{PG(G,e)}B=0}}while(0);v=B;w=0==(t[e>>2]|0)}Q(n);Q(m);Q(i);var jf=q+8|0,Ag=0<(t[jf>>2]|0),JH=q|0,KH=t[JH>>2];a:do{if(Ag){for(var Xp=0,LH=KH;;){Q(t[(LH+4>>2)+(3*Xp|0)]);var MH=Xp+1|0,NH=t[JH>>2];if((MH|0)<(t[jf>>2]|0)){Xp=MH,LH=NH}else{var Yp=NH;break a}}}else{Yp=KH}}while(0);if(0==(Yp|0)){var OH=q}else{vB(Yp),OH=q}vB(OH);j=e}LG.X=1;function NG(b){for(;0!=(L(l[b]<<24>>24)|0);){b=b+1|0}return b}function PG(b,d){for(var c=b;;){c=tA(c,t[d>>2]);if(0==(c|0)){break}t[d>>2]=0;c=OG(c+3|0,d);if(0==(c|0)){break}else{c=c+3|0}}}function OG(b,d){for(var c,e=b;;){var f=l[e];if(34==f<<24>>24||39==f<<24>>24){if(0==(N(e,Cm|0,3)|0)){c=774;break}if(0==(N(e,Lm|0,3)|0)){c=776;break}f=$G(e);if(0==l[f]<<24>>24){var g=0;break}else{e=f}}else{if(0==f<<24>>24||35==f<<24>>24){g=0;break}}e=e+1|0}776==c?(t[d>>2]=Lm|0,g=e):774==c&&(t[d>>2]=Cm|0,g=e);return g}function SG(b,d){var c,e=NG(b);if(0==(N(Vn|0,e,6)|0)){e=NG(e+6|0);if(0==(N(Gn|0,e,4)|0)){var f;return 0}var g=e}else{g=e}if(0==(N(Fi|0,g,5)|0)){return t[d>>2]=1,f=NG(g+5|0)}var e=0,h=b;a:for(;;){var i=l[g];if(0==i<<24>>24){f=0;c=804;break}var m=e+1|0;if(2>(e|0)){var n=g}else{f=0;c=806;break}for(;;){if(0==i<<24>>24||61==i<<24>>24||40==i<<24>>24){var q=i;break}var p=n+1|0;if(0!=(L(i<<24>>24)|0)){c=797;break}n=p;i=l[p]}797==c&&(c=0,q=l[n]);if(40==q<<24>>24){c=801;break}else{if(0==q<<24>>24||61==q<<24>>24){f=0;c=807;break}}for(i=n=NG(n);;){if(42==l[i]<<24>>24){i=i+1|0}else{e=m;g=n;h=i;continue a}}}if(801==c){return h}if(804==c||806==c||807==c){return f}}SG.X=1;function TG(b,d,c){var e;S(c);for(var f=b|0,b=b+4|0,g=0,h=0,i=0;;){if((i|0)>=(t[b>>2]|0)){e=817;break}var m=t[f>>2],n=m+12*i|0;if((t[n>>2]|0)>=(d|0)){e=816;break}0!=(h|0)&&U(c,Xi|0);U(c,t[t[(m+4>>2)+(3*i|0)]+8>>2]);g=0==(t[(m+8>>2)+(3*i|0)]|0)&1;h=n;i=i+1|0}if(817==e||816==e){return g}}function WG(b,d,c,e){var f,g,h=P();S(h);var i=NG(UG(b,d));if(40==l[i]<<24>>24){g=(h|0)>>2;f=(h+4|0)>>2;b=(h+8|0)>>2;for(i=i+1|0;;){var m=l[i];if(0==m<<24>>24){i=eC();if(0==(i|0)){break}var n=t[g];(n+1|0)==(t[f]|0)&&(R(h),n=t[g]);l[t[b]+n|0]=32;n=t[g]+1|0;t[g]=n;l[t[b]+n|0]=0}else{if(41==m<<24>>24){break}n=t[g];(n+1|0)==(t[f]|0)&&(R(h),m=l[i],n=t[g]);l[t[b]+n|0]=m;0!=l[i]<<24>>24&&(n=t[g]+1|0,t[g]=n,l[t[b]+n|0]=0);i=i+1|0}}i=t[g];(i+1|0)==(t[f]|0)?(R(h),f=t[g]):f=i;l[t[b]+f|0]=0}d=t[(d+8|0)>>2];f=j;j+=80;b=f>>2;sC(f,d);t[b+9]=Fi|0;l[f+40|0]=99;0!=(t[c>>2]|0)&&(t[(f+60|0)>>2]=0==(e|0)?Cf|0:Fi|0,t[b+16]=t[c+8>>2]);t[b+14]=t[h+8>>2];tC(f);j=f;Q(h)}WG.X=1;function XG(b){var d,c=mA(b,61);if(0==(c|0)){var e;return 0}for(var f=c;;){var f=f+1|0,g=l[f];if(0==g<<24>>24||40==g<<24>>24||35==g<<24>>24){var h=c;break}else{if(61==g<<24>>24){e=0;d=860;break}}}if(860==d){return e}for(;;){d=h-1|0;if(d>>>0<b>>>0){var i=d;break}if(0==(L(l[d]<<24>>24)|0)){i=d;break}else{h=d}}for(;i>>>0>=b>>>0&&0!=(YG(l[i]<<24>>24)|0);){i=i-1|0}d=i+1|0;if(0==((95==(l[d]<<24>>24|0)|0!=(pA(l[d]<<24>>24)|0))&1|0)){return 0}for(;i>>>0>=b>>>0&&0!=(L(l[i]<<24>>24)|0);){i=i-1|0}return(i+1|0)==(b|0)?d:0}function YG(b){return(95==(b|0)|0!=(oA(b)|0))&1}function ZG(b,d){var c,e,f,g=NG(RG(NG(b)));if(61!=l[g]<<24>>24){return 0}g=NG(g+1|0);if(0!=(N(g,xo|0,6)|0)){return 0}var g=g+6|0,h=NG(g);if((h|0)==(g|0)){return 0}g=P();f=(g|0)>>2;c=t[f];e=(g+4|0)>>2;if((c+1|0)==(t[e]|0)){R(g);var i=t[f]}else{i=c}c=(g+8|0)>>2;l[t[c]+i|0]=40;i=t[f]+1|0;t[f]=i;for(l[t[c]+i|0]=0;;){var i=l[h],m=t[f],n=(m+1|0)==(t[e]|0);if(58==i<<24>>24||0==i<<24>>24){break}if(n){R(g);var i=l[h],q=t[f]}else{q=m}l[t[c]+q|0]=i;0!=l[h]<<24>>24&&(i=t[f]+1|0,t[f]=i,l[t[c]+i|0]=0);h=h+1|0}n&&(R(g),m=t[f]);l[t[c]+m|0]=41;m=t[f]+1|0;t[f]=m;l[t[c]+m|0]=0;m=t[f];(m+1|0)==(t[e]|0)?(R(g),e=t[f]):e=m;l[t[c]+e|0]=0;0!=(d|0)&&(t[d>>2]=jB(t[c]));Q(g);return 1}ZG.X=1;function VG(b,d,c){var e,f=j;j+=80;e=f>>2;b=b+8|0;sC(f,t[b>>2]);var g=f+36|0;t[g>>2]=Cf|0;var h=f+40|0;l[h]=102;0!=(t[d>>2]|0)&&(0==(c|0)?t[e+15]=Cf|0:(t[g>>2]=$p|0,l[h]=109,t[e+15]=Fi|0),t[e+16]=t[d+8>>2]);d=t[b>>2];0==(N(d,Jp|0,2)|0)&&0!=(qA(d,sp|0)|0)?(t[e+11]=nx|0,t[e+4]=1):t[e+11]=Yf|0;tC(f);j=f}function $G(b){var d,c=b,e=0;a:for(;;){for(var f=0==(e|0),g=c;;){var h=g+1|0,c=l[h];if(0==c<<24>>24){var i=h;d=934;break a}if(!f){break}if(92==c<<24>>24){c=h;e=1;continue a}if(c<<24>>24==l[b]<<24>>24){break a}else{g=h}}c=h;e=e-1|0}return 934==d?i:g+2|0}function QG(b){var d;a:for(;;){var c=l[b];b:do{if(34==c<<24>>24||39==c<<24>>24||35==c<<24>>24){var e=b;d=949}else{if(0==c<<24>>24){var f=b;d=953;break a}else{do{if(0!=(sA(b,bv|0,2)|0)&&0!=(sA(b,Du|0,2)|0)&&0!=(sA(b,bu|0,2)|0)&&0!=(sA(b,Dt|0,2)|0)&&0!=(sA(b,ct|0,2)|0)&&0!=(sA(b,Es|0,2)|0)){do{if(0!=(sA(b,ms|0,3)|0)&&0!=(sA(b,Xr|0,3)|0)&&0!=(sA(b,xr|0,3)|0)&&0!=(sA(b,gr|0,3)|0)){var g=b,h=c;break b}}while(0);e=b+2|0;d=949;break b}}while(0);e=b+1|0;d=949}}}while(0);if(949==d&&(d=0,g=$G(e),h=l[g],0==h<<24>>24)){f=g;d=954;break}if(0==((95==(h<<24>>24|0)|0!=(pA(h<<24>>24)|0))&1|0)){b=g+1|0}else{f=g;d=952;break}}if(952==d||953==d||954==d){return f}}QG.X=1;function UG(b,d){var c;S(d);var e=0==(YG(l[b]<<24>>24)|0);c=(d|0)>>2;var f=t[c],g=d+4|0,h=(f+1|0)==(t[g>>2]|0);a:do{if(e){var i=b,m=h,n=f}else{for(var q=d+8|0,p=b,s=h,r=f;;){if(s&&(R(d),r=t[c]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[g>>2]|0),0==(YG(l[p]<<24>>24)|0)){i=p;m=s;n=r;break a}}}}while(0);if(!m){return c=t[(d+8|0)>>2],n=c+n|0,l[n]=0,i}R(d);n=t[c];c=t[(d+8|0)>>2];n=c+n|0;l[n]=0;return i}UG.X=1;function RG(b){for(;0!=(YG(l[b]<<24>>24)|0);){b=b+1|0}return b}function aH(){var b,d=j;j+=4;var c;b=d>>2;var e=bH();t[tc>>2]=e;e=1;a:for(;;){b:for(;;){var f=eC();if(0==(f|0)){break a}t[b]=f;if(0!=(cH(d,Zm|0)|0)){e=0;continue a}if(0!=(cH(d,Ok|0)|0)){e=1;continue a}dH(d);0==(cH(d,Vs|0)|0)?0!=(cH(d,bp|0)|0)?c=1005:0!=(cH(d,im|0)|0)?c=1005:0!=(cH(d,ff|0)|0)?c=1005:0!=(cH(d,ye|0)|0)&&(c=1005):c=1005;1005==c&&(c=0,AE(t[tc>>2],PD(hm|0)));0==(cH(d,Uf|0)|0)?0!=(cH(d,Fi|0)|0)?eH(d,0):0!=(cH(d,wk|0)|0)?eH(d,1):0!=(cH(d,av|0)|0)?eH(d,4):0!=(cH(d,Bu|0)|0)&&eH(d,5):eH(d,2);c:for(;;){var f=t[b],g=l[f];if(0==g<<24>>24){continue b}do{if(e){var h=t[b];if(0==(L(g&255)|0)){if(35==l[h]<<24>>24){continue b}do{if(0==(cH(d,ov|0)|0)&&0==(cH(d,Zs|0)|0)){do{if(0!=(cH(d,Sf|0)|0)&&(f=t[tc>>2],g=t[f+4>>2],0!=(g|0))){Q(t[t[f+8>>2]+(g-1<<2)>>2]);f=t[tc>>2];g=f+4|0;h=t[g>>2]-1|0;t[g>>2]=h;t[t[f+8>>2]+(h<<2)>>2]=0;continue c}}while(0);f=t[b];g=l[f];if(34==g<<24>>24){for(;;){if(f=f+1|0,t[b]=f,g=l[f],0==g<<24>>24||34==g<<24>>24){continue c}}}else{if(0==g<<24>>24){continue c}else{var i=f}}for(;;){if(f=i+1|0,t[b]=f,g=t[b],0!=(oA(l[f]&255)|0)){i=g}else{if(95==l[g]<<24>>24){i=g}else{continue c}}}}}while(0);AE(t[tc>>2],PD(hm|0));continue c}}else{h=f}}while(0);t[b]=h+1|0}}}fH(t[tc>>2]);j=d}aH.X=1;function cH(b,d){var c=tb(d),e=t[b>>2],f=l[e+c|0];if(0!=(N(e,d,c)|0)){return 0}if(0!=f<<24>>24){if(0!=(L(f&255)|0)|40==f<<24>>24){e=t[b>>2]}else{return 0}}t[b>>2]=e+c|0;return 1}function dH(b){if(0!=(L(l[t[b>>2]]&255)|0)){for(;;){var d=t[b>>2]+1|0;t[b>>2]=d;if(0==(L(l[d]&255)|0)){break}}}}function eH(b,d){if(0!=(L(l[t[b>>2]]&255)|0)){var c=P(),e=gH(b,c,d);if(-1!=(e|0)&&0!=(t[c>>2]|0)){var f,g=j;j+=80;f=g>>2;var h=c|0,i=t[h>>2];(i+1|0)==(t[c+4>>2]|0)&&(R(c),i=t[h>>2]);h=c+8|0;l[t[h>>2]+i|0]=0;var m=t[tc>>2],i=P(),n=t[m+4>>2];if(0!=(n|0)){for(var m=m+8|0,q=0,p=0;;){var s=t[t[m>>2]+(q<<2)>>2];0!=(t[s>>2]|0)&&(U(i,0!=(p|0)?Xi|0:hm|0),U(i,t[s+8>>2]),p=p+1|0);q=q+1|0;if((q|0)==(n|0)){break}}}sC(g,t[h>>2]);0!=(t[i>>2]|0)&&(t[f+15]=Fi|0,t[f+16]=t[i+8>>2]);t[f+9]=t[cy+(e<<4)+8>>2];l[g+40|0]=t[cy+(e<<4)+4>>2]&255;tC(g);AE(t[tc>>2],BE(c));S(c);Q(i);j=g}Q(c)}}function gH(b,d,c){var e,f,g=b>>2,h;f=(d|0)>>2;var i=d+4|0;e=(d+8|0)>>2;a:for(;;){var m=1==(c|0);do{if(m){dH(b);var n=Wr|0;h=1061}else{var q=2>(c-4|0)>>>0?vr|0:fr|0;dH(b);if(3==(c|0)){n=q,h=1061}else{if(0!=(c|0)){var p=q}else{if(p=t[g],60!=l[p]<<24>>24){p=q}else{if(60==l[p+1|0]<<24>>24){var s=-1;h=1081;break a}else{p=q}}}}}}while(0);if(1061==h){h=0;for(var p=d,q=b,r=ba,u=0;;){if(28==(u|0)){var v=0,r=1101;break}var w=t[hc+(u<<2)>>2];if(0==(cH(q,w)|0)){u=u+1|0}else{break}}1101!=r&&(U(p,w),v=1);p=v;if(0==(p|0)){p=n}else{s=c;h=1078;break}}for(q=t[g];;){r=l[q];if(0==r<<24>>24){s=c;h=1077;break a}q=l[t[g]];if(0==(oA(r&255)|0)&&0==(0!=(mA(p,q<<24>>24)|0)&1|0)){s=c;h=1079;break a}r=t[f];(r+1|0)==(t[i>>2]|0)&&(R(d),r=t[f]);l[t[e]+r|0]=q;0!=q<<24>>24&&(r=t[f]+1|0,t[f]=r,l[t[e]+r|0]=0);r=t[g]+1|0;t[g]=r;if(m){if(46==q<<24>>24){break}if(0==(0!=(mA(Pq|0,q<<24>>24)|0)&1|0)){q=r}else{s=1;h=1080;break a}}else{q=r}}c=t[f];(c+1|0)==(t[i>>2]|0)&&(R(d),c=t[f]);l[t[e]+c|0]=0;S(d);c=3}if(1081==h||1077==h||1078==h||1080==h||1079==h){return s}}gH.X=1;function hH(){var b=P(),d=eC();if(0!=(d|0)){for(;;){var c=40==l[d]<<24>>24;a:do{if(c){var e=l[d+1|0];do{if(68==e<<24>>24||100==e<<24>>24){var f=l[d+2|0];if(69==f<<24>>24||101==f<<24>>24){if(f=l[d+3|0],70==f<<24>>24||102==f<<24>>24){for(var f=d,g=40;;){var h=f+1|0;if(0!=(L(g)|0)){var i=f;break}f=h;g=l[h]&255}for(;;){f=l[i];if(0==f<<24>>24){break}if(0==(L(f&255)|0)&&40!=l[i]<<24>>24){break}i=i+1|0}iH(b,i);jC(b,ay|0,0);if(40!=l[i]<<24>>24){break a}f=i;g=l[i+1|0]}else{f=d,g=e}}else{f=d,g=e}}else{f=d,g=e}}while(0);if(83==g<<24>>24||115==g<<24>>24){if(e=l[f+2|0],69==e<<24>>24||101==e<<24>>24){if(e=l[f+3|0],(84==e<<24>>24||116==e<<24>>24)&&33==l[f+4|0]<<24>>24&&0!=(L(l[f+5|0]&255)|0)){for(e=f;;){f=l[e];if(0==f<<24>>24){var m=e;break}if(0==(L(f&255)|0)){e=e+1|0}else{m=e;break}}for(;0!=(L(l[m]&255)|0);){m=m+1|0}iH(b,m);jC(b,ay|0,1)}}}}}while(0);d=eC();if(0==(d|0)){break}}}Q(b)}hH.X=1;function iH(b,d){var c,e,f;S(b);e=(b|0)>>2;var g=b+4|0;c=(b+8|0)>>2;for(var h=d;;){var i=l[h];if(0==i<<24>>24||40==i<<24>>24||41==i<<24>>24){f=1133;break}var m=t[e],n=(m+1|0)==(t[g>>2]|0);if(0!=(L(i&255)|0)){f=1140;break}n?(R(b),i=t[e]):i=m;l[t[c]+i|0]=l[h];0!=l[h]<<24>>24&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);h=h+1|0}if(1133==f){if(h=t[e],(h+1|0)==(t[g>>2]|0)){f=1141}else{var q=h}}else{1140==f&&(n?f=1141:q=m)}1141==f&&(R(b),q=t[e]);l[t[c]+q|0]=0}iH.X=1;function jH(){var b,d,c,e=P(),f=eC();if(0!=(f|0)){d=(e|0)>>2;var g=e+4|0;for(b=(e+8|0)>>2;;){var h=l[f],i=35==h<<24>>24;a:do{if(!i){for(var m=f,n=h;;){var q=m+1|0;if(0==(L(n&255)|0)){break}m=q;n=l[q]}n=0==(N(m,Cf|0,8)|0);b:do{if(n){if(q=m+8|0,0==(L(l[q]&255)|0)){var p=0,s=m}else{if(0==(L(l[q]&255)|0)){break a}for(;;){if(0==(L(l[q]&255)|0)){p=1;s=q;break b}else{q=q+1|0}}}}else{p=0,s=m}}while(0);do{if(0==(oA(l[s]&255)|0)){if(95==l[s]<<24>>24){m=s}else{break a}}else{m=s}}while(0);b:for(;;){do{if(0==(oA(l[m]&255)|0)){var r=t[d],u=(r+1|0)==(t[g>>2]|0);if(95!=l[m]<<24>>24){break b}if(u){c=1159}else{var v=r}}else{n=t[d],(n+1|0)==(t[g>>2]|0)?c=1159:v=n}}while(0);1159==c&&(c=0,R(e),v=t[d]);l[t[b]+v|0]=l[m];0!=l[m]<<24>>24&&(n=t[d]+1|0,t[d]=n,l[t[b]+n|0]=0);m=m+1|0}u?(R(e),n=t[d]):n=r;for(l[t[b]+n|0]=0;;){var w=m+1|0;if(0==(L(l[m]&255)|0)){break}else{m=w}}if(40==l[m]<<24>>24){for(n=w;0!=(L(l[n]&255)|0);){n=n+1|0}41!=l[n]<<24>>24?n=p:(n=0!=(qA(kH(t[t[K>>2]+8>>2]),bf|0)|0)?0:0==(qA(t[e+8>>2],zd|0)|0),n&=1,n=0==(n|0)?1:p)}else{n=p}0!=(n|0)&&jC(e,Xx|0,0);S(e)}}while(0);f=eC();if(0==(f|0)){break}}}Q(e)}jH.X=1;function lH(){var b,d=j;j+=4;var c;b=d>>2;var e=P(),f=eC();if(0!=(f|0)){for(var g=e+8|0,h=-1;;){for(var f=mH(f),i=t[b]=f;;){f=t[Mz>>2];if(0!=(f|0)){i=tA(i,Mm|0);t[b]=i;if(0==(i|0)){var m=h;break}t[Mz>>2]=f-1|0;t[b]=i+2|0}var n,f=d;n=P();t[f>>2]=nH(t[f>>2],n);for(var f=t[n+8>>2],i=-1,q=0;;){var p=0==(qA(f,t[Tx+(q<<3)>>2])|0)?t[Tx+(q<<3)+4>>2]:i,q=q+1|0;if(10>q>>>0&-1==(p|0)){i=p}else{break}}Q(n);n=p;f=t[b];-1==(n|0)?n=h:(f=nH(mH(f),e),t[b]=f,i=t[g>>2],-2==(n|0)?(oH(h,i),n=h):oH(n,i));h=f;if(0==(tA(h,Dk|0)|0)){if(0==(h|0)){m=n;break}else{f=h}}else{if(h=tA(h+2|0,Mm|0),t[b]=h,0==(h|0)){c=1199;break}else{f=h}}if(0==l[f]<<24>>24){m=n;break}else{h=n,i=f}}1199==c&&(c=0,t[Mz>>2]=t[Mz>>2]+1|0,m=n);f=eC();if(0==(f|0)){break}else{h=m}}}Q(e);j=d}lH.X=1;function mH(b){for(;0!=(L(l[b]&255)|0);){b=b+1|0}return b}function nH(b,d){var c;S(d);var e=b,f=0,g=l[b];a:for(;;){for(var h=0!=(f|0),i=0==(f|0),m=e,n=g;;){if(0==n<<24>>24){var q=m;c=1233;break a}var p=l[m];if(!(0==(pH(n&255)|0)|h)){c=1221;break a}var n=m+1|0,s=l[n];if(40==p<<24>>24&&42==s<<24>>24&i){c=1219;break a}if(34!=s<<24>>24|92==p<<24>>24){m=n,n=s}else{e=n;f=1;g=34;continue a}}}if(1221==c){if(0==p<<24>>24|0==(m|0)){return m}e=0==(pH(p&255)|0);c=(d|0)>>2;f=t[c];g=d+4|0;h=(f+1|0)==(t[g>>2]|0);a:do{if(e){var r=m,u=h,v=f}else{i=d+8|0;q=m;n=h;for(p=f;;){if(n&&(R(d),p=t[c]),l[t[i>>2]+p|0]=l[q],0!=l[q]<<24>>24&&(p=t[c]+1|0,t[c]=p,l[t[i>>2]+p|0]=0),q=q+1|0,p=t[c],n=(p+1|0)==(t[g>>2]|0),0==(pH(l[q]&255)|0)){r=q;u=n;v=p;break a}}}}while(0);u?(R(d),m=t[c]):m=v;l[t[d+8>>2]+m|0]=0;return r}if(1233==c){return q}if(1219==c){return t[Mz>>2]=t[Mz>>2]+1|0,m+2|0}}nH.X=1;function oH(b,d){var c=j;j+=80;sC(c,d);t[c+36>>2]=t[Sx+(b<<4)+8>>2];l[c+40|0]=t[Sx+(b<<4)+4>>2]&255;tC(c);j=c}function pH(b){return 0!=(oA(b)|0)?1:0==(b|0)?0:0!=(bC(wh|0,b,21)|0)&1}function qH(){var b,d=zC(28);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+4]=0;t[b+5]=t[K+48>>2];t[b+6]=t[K+24>>2];return d}function rH(b){Q(t[b+8>>2]);Q(t[b+12>>2]);vB(b)}function sH(b){$(b);8==(t[b>>2]|0)&&(tH(b,5),$(b))}function uH(b){var d=t[b+4>>2];if(27==(d|0)){vH(b)}else{if(1==(d|0)){wH(b,0)}else{if(55==(d|0)){xH(b)}else{if(28==(d|0)){yH(b)}else{if(31==(d|0)){var c,d=qH();$(d);$(b);var e=b|0;14==(t[e>>2]|0)&&$(d);for(c=(b+4|0)>>2;68!=(t[c]|0)&&6!=(t[e>>2]|0);){$(b)}tH(d,14);68==(t[c]|0)&&($(b),1==(t[c]|0)&&wH(b,1),zH(b,1));rH(d)}else{if(53==(d|0)){xH(b)}else{if(54==(d|0)){xH(b)}else{if(17==(d|0)){d=qH();c=d>>2;$(d);2==(t[c+1]|0)&&$(d);var e=b+4|0,f=0==(t[e>>2]|0);a:do{if(!f){for(var g=b|0;;){if($(b),14==(t[g>>2]|0)&&$(d),0==(t[e>>2]|0)){break a}}}}while(0);e=t[c];(8==(e|0)||13==(e|0))&&tH(d,6);AH(b,t[c+2]);wH(b,0);S(t[b+12>>2]);zH(b,0);rH(d)}else{if(69==(d|0)){for(c=b+4|0;!(d=0==(t[c>>2]|0),$(b),d);){}15==(t[b>>2]|0)&&BH(b,16);zH(b,1)}else{if(3==(d|0)){CH(b,0)}else{if(65==(d|0)){zH(b,0)}else{if(30==(d|0)){c=qH();d=qH();$(c);$(b);e=b|0;14==(t[e>>2]|0)&&($(c),$(b));if(45==(t[b+4>>2]|0)&&(f=t[c>>2],8==(f|0)||13==(f|0))){$(d),$(b),14==(t[e>>2]|0)&&($(d),$(b)),AH(c,t[d+8>>2]),tH(c,13)}zH(b,0);rH(c);rH(d)}else{if(52==(d|0)){xH(b)}else{if(34==(d|0)){DH(b)}else{if(26==(d|0)){CH(b,9)}else{if(66==(d|0)){d=qH();$(d);$(b);e=(b|0)>>2;f=t[e];14==(f|0)&&($(d),$(b),f=t[e]);10==(f|0)&&EH(b);for(f=b+4|0;!(c=0==(t[f>>2]|0))&&6!=(t[e]|0);){$(b)}e=t[d>>2];(8==(e|0)||13==(e|0))&&c&&tH(d,18);zH(b,1);rH(d)}else{32==(d|0)?(c=qH(),$(c),$(b),d=b|0,e=t[d>>2],14==(e|0)?($(c),$(b),d=t[d>>2]):d=e,10==(d|0)&&(d=t[c>>2],(8==(d|0)||13==(d|0))&&tH(c,15)),zH(b,0),rH(c)):35==(d|0)?DH(b):33==(d|0)?(c=qH(),$(c),$(b),29==(t[b+4>>2]|0)&&(d=t[c>>2],(8==(d|0)||13==(d|0))&&tH(c,16)),zH(b,0),rH(c)):67==(d|0)?(c=qH(),$(c),$(b),d=t[c>>2],(8==(d|0)||13==(d|0))&&14==(t[b+4>>2]|0)&&tH(c,19),zH(b,1),rH(c)):59==(d|0)?FH(b):62==(d|0)?GH(b):61==(d|0)?FH(b):42==(d|0)?(c=qH(),$(c),$(b),d=t[c>>2],(8==(d|0)||13==(d|0))&&6!=(t[b>>2]|0)&&tH(c,12),zH(b,1),rH(c)):58==(d|0)?FH(b):19==(d|0)?HH(b):7==(d|0)?IH(b,0):4==(d|0)?wH(b,0):56==(d|0)?xH(b):29==(d|0)?PH(b):57==(d|0)?FH(b):6==(d|0)?HH(b):60==(d|0)&&FH(b)}}}}}}}}}}}}}}}}}uH.X=1;function wH(b,d){var c,e;1==(t[b>>2]|0)&&(sH(b),$(b));e=(b+4|0)>>2;if(1!=(t[e]|0)&&($(b),QH(b,d),1!=(t[e]|0))){return}$(b);var f=qH();c=(b+4|0)>>2;if(4==(t[c]|0)){for(var g=f+4|0,h=b|0,i=0==(d|0);;){$(b);$(f);var m=t[g>>2];if(3==(m|0)){tH(b,0)}else{if(63==(t[c]|0)&64==(m|0)){$(b),27==(t[c]|0)&&($(b),m=t[h>>2],(8==(m|0)||13==(m|0))&&tH(b,10))}else{if(m=t[h>>2],8==(m|0)||13==(m|0)){i?tH(b,12):tH(b,4)}}}BH(b,6);$(b);if(4!=(t[c]|0)){break}}}rH(f);c=(b+16|0)>>2;f=t[c]+1|0;t[c]=f;if(5==(t[e]|0)){e=f}else{for(;!(IH(b,0),0!=(RH(b)|0)&&$(b),5==(t[e]|0));){}e=t[c]}t[c]=e-1|0;$(b)}function CH(b,d){$(b);var c=t[b>>2];(8==(c|0)||13==(c|0))&&tH(b,d)}function DH(b){var d=qH();$(d);0==(t[d+4>>2]|0)&&$(d);$(b);var c=t[d>>2];(8==(c|0)||13==(c|0))&&tH(d,17);zH(b,0);rH(d)}function HH(b){var d,c,e,f,g,h=qH();f=h>>2;var i=P();e=(b+4|0)>>2;var m=6==(t[e]|0),n=m?2:7;d=(b+12|0)>>2;V(i,t[t[d]+8>>2]);$(b);SH(h,b);$(b);c=(b|0)>>2;var q=t[c];14==(q|0)&&(0!=(t[i>>2]|0)&&AH(b,t[f+2]),$(b),SH(h,b),$(b),q=t[c]);10==(q|0)&&EH(b);m&&2>(t[e]-24|0)>>>0&&($(b),$(b),10==(t[c]|0)&&EH(b));if(0!=(RH(b)|0)){tH(h,1)}else{for(;;){var p=t[e];if(0==(p|0)||1==(p|0)){break}else{if(44==(p|0)||37==(p|0)||38==(p|0)||39==(p|0)){g=1362;break}}if(21==(t[c]|0)){g=1361;break}if(0!=(RH(b)|0)){g=1361;break}$(b);36==(p|0)&&10==(t[c]|0)&&EH(b)}if(1361==g&&(44==(p|0)||37==(p|0)||38==(p|0)||39==(p|0))){g=1362}1362==g&&(AH(b,t[f+2]),m=t[f],8==(m|0)||13==(m|0)?g=1364:-1!=(t[e]|0)&&(g=1364),1364==g&&tH(h,n),S(t[d]));21==(t[c]|0)&&$(b);c=t[e];4==(c|0)&&(QH(b,0),c=t[e]);2>c>>>0&&(AH(b,t[f+2]),f=t[f],8==(f|0)||13==(f|0)?g=1373:-1!=(t[e]|0)&&(g=1373),1373==g&&tH(h,n),wH(b,1),S(t[d]))}b=t[d];d=(i+8|0)>>2;d=t[d];V(b,d);rH(h);Q(i)}HH.X=1;function $(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+20|0)>>2;b=(b+24|0)>>2;a:for(;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(46==(h|0)){f=1386;break}else{if(125==(h|0)){f=1389;break}else{if(40==(h|0)){f=1382;break}else{if(126==(h|0)){f=1390;break}else{if(58==(h|0)){f=1384;break}else{if(41==(h|0)){f=1383;break}else{if(91==(h|0)){f=1391;break}else{if(123==(h|0)){f=1388;break}else{if(93==(h|0)){f=1392;break}else{if(61==(h|0)){f=1393;break}else{if(39==(h|0)||34==(h|0)){f=1394;break}else{if(45==(h|0)){var i=T();if(45!=(i|0)){f=1397;break}uE(10)}else{if(60==(h|0)||62==(h|0)){f=1400;break}else{if(92==(h|0)){f=1405;break}else{if(47==(h|0)){var m=T();if(47==(m|0)){uE(10)}else{if(42!=(m|0)){f=1410;break}for(;;){uE(42);var n=T();if(47==(n|0)){continue a}W(n);if(-1==(n|0)||0==(n|0)){continue a}}}}else{if(!(32==(h|0)||10==(h|0)||9==(h|0))){if(-1==(h|0)){f=1381;break}else{if(59==(h|0)){f=1385;break}else{if(44==(h|0)){f=1387;break}else{if(0==((0!=(pA(h)|0)|64==(h|0)|95==(h|0))&1|0)){f=1415;break}for(var q=t[c],p=n=ba,p=(q|0)>>2,s=q+4|0,n=(q+8|0)>>2,r=h;;){var u=t[p];(u+1|0)==(t[s>>2]|0)&&(R(q),u=t[p]);l[t[n]+u|0]=r&255;0!=(r|0)&&(u=t[p]+1|0,t[p]=u,l[t[n]+u|0]=0);u=T();if(0==((0!=(pA(u)|0)|10>(u-48|0)>>>0?1:95==(u|0)||64==(u|0)||36==(u|0)||35==(u|0)?1:0)|0)){break}else{r=u}}r=t[p];(r+1|0)==(t[s>>2]|0)?(R(q),q=t[p]):q=r;l[t[n]+q|0]=0;0==(L(u)|0)&&W(u);t[d]=t[K+48>>2];t[b]=t[K+24>>2];n=UD(t[c],t[Hy>>2]);t[g>>2]=n;if(-1==(n|0)){f=1418;break}else{if(23!=(n|0)){f=1419;break}}S(t[c]);uE(10)}}}}}}}}}}}}}}}}}}}}if(1386==f){t[e]=14}else{if(1389==f){t[e]=16}else{if(1382==f){t[e]=10}else{if(1390==f){t[e]=19}else{if(1415==f){t[e]=0}else{if(1384==f){t[e]=5}else{if(1383==f){t[e]=4}else{if(1391==f){t[e]=17}else{if(1388==f){t[e]=15}else{if(1392==f){t[e]=18}else{if(1393==f){t[e]=21}else{if(1394==f){t[e]=13;e=t[c];g=h;c=(e|0)>>2;f=e+4|0;h=(e+8|0)>>2;i=1;a:for(;;){for(;;){if(!i){break a}m=T();if(-1==(m|0)|(m|0)==(g|0)){i=0;continue a}n=t[c];(n+1|0)==(t[f>>2]|0)&&(R(e),n=t[c]);l[t[h]+n|0]=m&255;0!=(m|0)&&(m=t[c]+1|0,t[c]=m,l[t[h]+m|0]=0)}}g=t[c];(g+1|0)!=(t[f>>2]|0)?(h=t[h],e=h+g|0):(R(e),e=t[c],h=t[h],e=h+e|0);l[e]=0;t[d]=t[K+48>>2];t[b]=t[K+24>>2]}else{1397==f?(0==(L(i)|0)&&W(i),t[e]=11):1400==f?(d=T(),(d|0)!=(h|0)?(W(d),t[e]=0):t[e]=60==(h|0)?1:2):1405==f?(h=T(),!(92==(h|0)||39==(h|0)||34==(h|0))&&0==(L(h)|0)&&W(h),t[e]=3,t[d]=t[K+48>>2],t[b]=t[K+24>>2]):1410==f?(t[e]=20,W(m)):1419==f?t[e]=9:1418==f?t[e]=8:1381==f?dB(xz|0,1):1385==f?t[e]=6:1387==f&&(t[e]=7)}}}}}}}}}}}}}$.X=1;function IH(b,d){var c,e,f;e=(b|0)>>2;c=(b+4|0)>>2;var g=0==(d|0);a:for(;;){var h=1==(t[e]|0);b:do{if(h){sH(b);var i=0;f=1488}else{var m=t[c];c:do{if(40==(m|0)){for($(b);;){var n=41==(t[c]|0);$(b);if(n){var q=0;break b}}}else{if(43==(m|0)){$(b);q=0;break b}else{if(70==(m|0)){$(b);uH(b);var p=0}else{if(1==(m|0)||4==(m|0)){wH(b,1),p=0}else{if(11==(m|0)||13==(m|0)){f=1465}else{if(7==(m|0)){for(p=7;41!=(p|0);){if(1==(p|0)){f=1452;break}$(b);p=t[c]}if(1452==f){f=0,wH(b,0),p=0!=(RH(b)|0)&1}else{$(b);var p=t[c],n=5==(p|0),s=10!=(p|0)&(n^1);d:do{if(s){for(var r=p;;){2>(r-8|0)>>>0&&$(b);IH(b,1);0!=(RH(b)|0)&&$(b);var r=t[c],u=5==(r|0);if(!(10!=(r|0)&(u^1))){var v=u,w=r;break d}}}else{v=n,w=p}}while(0);v?($(b),p=t[c]):p=w;7==(p|0)||10==(p|0)?($(b),p=0!=(RH(b)|0)&1):p=0}}else{if(14==(m|0)){$(b);$(b);if(0!=(t[c]|0)){break a}for(;;){if($(b),15==(t[c]|0)){f=1465;break c}}}else{5!=(m|0)&&$(b),p=0}}}}}}}}while(0);if(1465==f){f=0;$(b);m=5==(t[c]|0);c:do{if(!m){for(;;){if(IH(b,0),0!=(RH(b)|0)&&$(b),5==(t[c]|0)){break c}}}}while(0);$(b);m=t[c];(11==(m|0)||13==(m|0)||14==(m|0))&&$(b);p=0!=(RH(b)|0)&1}m=0==(p|0);c:for(;;){if(!m){i=p;f=1488;break b}n=t[c];if(5==(n|0)){i=0;f=1488;break b}if(0!=(RH(b)|0)){i=0;f=1488;break b}if(!(10!=(n|0)|g)){break a}if(5==(t[e]|0)&&($(b),n=t[c],11==(n|0)||12==(n|0)||14==(n|0))){break a}$(b);n=t[e];if(10==(n|0)||15==(n|0)||17==(n|0)){TH(b),n=t[e]}do{if(1!=(n|0)&&(s=t[c],!(43==(s|0)||11==(s|0)||13==(s|0)||14==(s|0)||1==(s|0)))){if(7!=(s|0)){continue c}IH(b,1);continue c}}while(0);IH(b,0)}}}while(0);1488==f&&(f=0,q=0!=(RH(b)|0)&0==(i|0)?1:i);h=t[c];if(5==(h|0)){break}if(!((10!=(h|0)|g)&0==(q|0))){break}}}IH.X=1;function xH(b){var d,c=qH(),e=qH(),f=qH();$(b);d=(b|0)>>2;do{if(10==(t[d]|0)){$(c);$(b);var g=t[d],h=7==(g|0),g=4!=(g|0)&(h^1);a:do{if(g){for(;;){$(b);var i=t[d],m=7==(i|0);if(!(4!=(i|0)&(m^1))){var n=m;break a}}}else{n=h}}while(0);if(n){$(e);$(b);g=t[d];h=7==(g|0);g=4!=(g|0)&(h^1);a:do{if(g){for(;;){if($(b),i=t[d],m=7==(i|0),!(4!=(i|0)&(m^1))){var q=m;break a}}}else{q=h}}while(0);q&&($(f),13==(t[c>>2]|0)&&13==(t[e>>2]|0)&&13==(t[f>>2]|0)&&(AH(c,t[e+8>>2]),AH(c,t[f+8>>2]),tH(c,20)));4!=(t[d]|0)&&BH(b,4)}}}while(0);zH(b,1);rH(c);rH(e);rH(f)}xH.X=1;function FH(b){var d,c=qH(),e=qH();$(b);d=(b|0)>>2;if(10==(t[d]|0)){$(c);$(b);var f=t[d],g=7==(f|0),f=4!=(f|0)&(g^1);a:do{if(f){for(;;){$(b);var h=t[d],i=7==(h|0);if(!(4!=(h|0)&(i^1))){var m=i;break a}}}else{m=g}}while(0);m&&($(e),13==(t[c>>2]|0)&&13==(t[e>>2]|0)&&(AH(c,t[e+8>>2]),tH(c,21)));4!=(t[d]|0)&&BH(b,4)}zH(b,1);rH(c);rH(e)}function GH(b){var d,c=qH(),e=qH(),f=qH();$(b);d=(b|0)>>2;do{if(10==(t[d]|0)){$(c);$(b);var g=t[d],h=7==(g|0),g=4!=(g|0)&(h^1);a:do{if(g){for(;;){$(b);var i=t[d],m=7==(i|0);if(!(4!=(i|0)&(m^1))){var n=m;break a}}}else{n=h}}while(0);if(n){$(e);$(b);g=t[d];h=7==(g|0);g=4!=(g|0)&(h^1);a:do{if(g){for(;;){if($(b),i=t[d],m=7==(i|0),!(4!=(i|0)&(m^1))){var q=m;break a}}}else{q=h}}while(0);q&&($(f),13==(t[c>>2]|0)&&13==(t[e>>2]|0)&&13==(t[f>>2]|0)&&(AH(c,t[e+8>>2]),AH(c,t[f+8>>2]),tH(c,22)));4!=(t[d]|0)&&BH(b,4)}}}while(0);zH(b,1);rH(c);rH(e);rH(f)}GH.X=1;function vH(b){var d,c,e=qH();$(e);c=(e|0)>>2;17==(t[c]|0)&&($(e),$(b));$(b);d=(b|0)>>2;var f=t[d];14==(f|0)?($(e),f=t[c],17==(f|0)&&($(e),$(b),f=t[c]),14==(f|0)&&($(e),17==(t[c]|0)&&($(e),$(b))),$(b),f=t[d],14!=(f|0)?d=f:($(e),17==(t[c]|0)&&($(e),$(b)),$(b),d=t[d])):d=f;if(10==(d|0)){if(c=t[c],8==(c|0)||13==(c|0)){tH(e,10),c=b+12|0,V(t[c>>2],t[t[e+8>>2]+8>>2]),UH(b),S(t[c>>2])}}else{44==(t[b+4>>2]|0)&&8==(t[c]|0)&&tH(e,10)}zH(b,0);rH(e)}vH.X=1;function RH(b){var d=t[b>>2];return(6==(d|0)||19==(d|0)||20==(d|0)?1:71==(t[b+4>>2]|0))&1}function yH(b){var d,c,e=qH(),f=qH();$(e);$(b);var g=b|0;14==(t[g>>2]|0)&&($(e),$(b));for(d=(b+4|0)>>2;45!=(t[d]|0)&&0==(RH(b)|0);){$(b)}if(0==(RH(b)|0)){$(f);$(b);14==(t[g>>2]|0)&&($(f),$(b));for(var h=e+8|0,g=b+12|0;;){var i=t[d];if(1==(i|0)||16==(i|0)){break}if(0!=(RH(b)|0)){c=1618;break}4==(i|0)?(AH(b,t[h>>2]),QH(b,1),S(t[g>>2])):$(b)}if(1618==c&&!(1==(i|0)||16==(i|0))){zH(b,1);rH(e);rH(f);return}c=f+8|0;AH(e,t[c>>2]);tH(e,11);AH(b,t[c>>2]);1==(t[d]|0)&&wH(b,1);S(t[g>>2])}zH(b,1);rH(e);rH(f)}yH.X=1;function PH(b){var d,c,e=qH(),f=P();c=(b+12|0)>>2;V(f,t[t[c]+8>>2]);AH(e,t[c]);$(e);if(8==(t[e>>2]|0)&&($(b),d=(b+4|0)>>2,0==(t[d]|0))){$(b);AH(b,t[e+8>>2]);var g=t[d];20==(g|0)||21==(g|0)?(tH(e,8),UH(b)):27==(g|0)?tH(e,10):22==(g|0)&&($(b),3==(t[d]|0)&&tH(e,0));S(t[c])}V(t[c],t[f+8>>2]);rH(e);Q(f)}function EH(b){10==(t[b>>2]|0)&&TH(b)}function tH(b,d){if(0!=(t[Qx+(d<<4)>>2]|0)){var c=b+12|0;if(0!=(t[t[c>>2]>>2]|0)){var e=P();V(e,t[t[c>>2]+8>>2]);U(e,Xi|0);c=b+8|0;U(e,t[t[c>>2]+8>>2]);var f=e|0,g=t[f>>2];(g+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=g;g=e+8|0;l[t[g>>2]+f|0]=0;V(t[c>>2],t[g>>2]);Q(e)}c=j;j+=80;e=c>>2;0!=(t[Qx+(d<<4)>>2]|0)&&(sC(c,t[t[b+8>>2]+8>>2]),t[e+1]=t[b+20>>2],t[e+2]=t[b+24>>2],t[e+9]=t[Qx+(d<<4)+8>>2],l[c+40|0]=t[Qx+(d<<4)+4>>2]&255,tC(c));j=c}}function zH(b,d){var c=t[b+16>>2];if(!(0!=(d|0)&&0!=(RH(b)|0))){for(;;){$(b);if(0!=(RH(b)|0)){break}if(0!=((0>=(c|0)?0:5==(t[b+4>>2]|0)?(t[b+16>>2]|0)==(c|0)&1:0)|0)){break}}}}function TH(b){var d=b|0,c=t[d>>2];if(10==(c|0)){var e=4}else{if(15==(c|0)){e=16}else{if(17==(c|0)){e=18}else{return}}}$(b);for(var f=1;;){var g=t[d>>2],f=((g|0)==(c|0)&1)+f|0,f=(((g|0)==(e|0)&0<(f|0))<<31>>31)+f|0;$(b);if(!(0!=(f|0)|(g|0)!=(e|0))){break}}}function AH(b,d){var c;c=(b+12|0)>>2;var e=t[c];0!=(t[e>>2]|0)&&(U(e,Xi|0),e=t[c]);U(e,t[d+8>>2]);var f=t[c],e=t[f>>2];(e+1|0)!=(t[f+4>>2]|0)?(f=f+8|0,f=t[f>>2],c=f+e|0):(R(f),e=t[c],c=t[e>>2],f=e+8|0,f=t[f>>2],c=f+c|0);l[c]=0}function UH(b){var d,c;d=(b|0)>>2;if(10==(t[d]|0)){var e=10}else{$(b),e=t[d]}var f=b+4|0;a:for(;;){(7==(e|0)||10==(e|0))&&$(b);if(6>(t[f>>2]-46|0)>>>0){c=1701}else{var g=t[d];if(8==(g|0)||13==(g|0)){tH(b,3),c=1701}else{var h=g}}for(;;){1701==c&&(c=0,h=t[d]);if(7==(h|0)||10==(h|0)){e=h;continue a}else{if(4==(h|0)){break a}}$(b);g=t[d];10!=(g|0)?h=g:(EH(b),c=1701)}}}function QH(b,d){var c,e=b+4|0,f=t[e>>2];if(4==(f|0)){$(b),c=1708}else{var g=f}a:for(;;){1708==c&&(g=t[e>>2]);do{if(19==(g|0)){HH(b)}else{if(3==(g|0)){CH(b,0)}else{if(6==(g|0)){HH(b)}else{if(29==(g|0)){PH(b)}else{if(28==(g|0)){CH(b,11)}else{if(26==(g|0)){CH(b,9)}else{if(1==(g|0)||5==(g|0)){break a}else{8==(t[b>>2]|0)&&(0==(d|0)?tH(b,12):tH(b,4))}}}}}}}}while(0);BH(b,6);$(b);c=1708}}function BH(b,d){var c=b|0;if((t[c>>2]|0)!=(d|0)){for(;!($(b),(t[c>>2]|0)==(d|0));){}}}function SH(b,d){var c=d>>2,e=b>>2;t[e+5]=t[c+5];t[e+6]=t[c+6];t[e]=t[c];t[e+1]=t[c+1];V(t[e+2],t[t[c+2]+8>>2]);V(t[e+3],t[t[c+3]+8>>2])}function VH(){var b,d=P(),c=eC();if(0!=(c|0)){for(;;){if(0!=(L(l[c]&255)|0)){c=c+1|0}else{var e=l[c];a:do{if(!(0==e<<24>>24||35==e<<24>>24)){for(var f=c,g=e;;){if(0==g<<24>>24){var h=0;break}var i=f+1|0;if(0!=(L(g&255)|0)){b=1782;break}f=i;g=l[i]}1782==b&&(b=0,h=l[f]&255);if(0!=(L(h)|0)){for(;0!=(L(l[f]&255)|0);){f=f+1|0}if(0!=(WH(c,ok|0)|0)){XH(f,d,2)}else{do{if(0==(WH(c,Fi|0)|0)&&0==(WH(c,kh|0)|0)){do{if(0==(WH(c,Yf|0)|0)&&0==(WH(c,Ve|0)|0)&&0==(WH(c,nx|0)|0)){break a}}while(0);if(0==(WH(f,Bw|0)|0)){break a}for(c=f+6|0;0!=(L(l[c]&255)|0);){c=c+1|0}XH(c,d,1);break a}}while(0);XH(f,d,0)}}}}while(0);c=eC();if(0==(c|0)){break}}}}Q(d)}VH.X=1;function WH(b,d){return 0==(N(b,d,tb(d))|0)&1}function XH(b,d,c){var e,f,g;S(d);f=(d|0)>>2;var h=d+4|0;for(e=(d+8|0)>>2;;){var i=l[b];if(0==i<<24>>24){g=1804;break}var m=t[f],n=(m+1|0)==(t[h>>2]|0);if(0!=(L(i&255)|0)){g=1811;break}n?(R(d),i=t[f]):i=m;l[t[e]+i|0]=l[b];0!=l[b]<<24>>24&&(i=t[f]+1|0,t[f]=i,l[t[e]+i|0]=0);b=b+1|0}if(1811==g){if(n){g=1812}else{var q=m}}else{1804==g&&(m=t[f],(m+1|0)==(t[h>>2]|0)?g=1812:q=m)}1812==g&&(R(d),q=t[f]);l[t[e]+q|0]=0;jC(d,Nx|0,c)}XH.X=1;function YH(){var b,d=zC(24);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+4]=t[K+48>>2];t[b+5]=t[K+24>>2];return d}function ZH(b){Q(t[b+8>>2]);Q(t[b+12>>2]);vB(b)}function $H(b,d){var c,e,f=YH(),g=P();S(g);e=(b|0)>>2;c=t[e];if(4==(c|0)){c=b>>2;var h=f>>2;t[h+4]=t[c+4];t[h+5]=t[c+5];t[h]=t[c];t[h+1]=t[c+1];V(t[h+2],t[t[c+2]+8>>2]);V(t[h+3],t[t[c+3]+8>>2]);aI(b);h=t[e]}else{h=c}if(10==(h|0)){aI(b);c=(g|0)>>2;for(h=b+8|0;;){var i=t[e];if(6==(i|0)){0!=(t[c]|0)&&U(g,Eo|0),U(g,t[t[h>>2]+8>>2])}else{if(11==(i|0)){break}}aI(b)}h=t[c];(h+1|0)==(t[g+4>>2]|0)?(R(g),c=t[c]):c=h;h=g+8|0;l[t[h>>2]+c|0]=0;V(t[f+8>>2],t[h>>2]);bI(f,d);c=0;h=t[e]}else{c=1}13==(h|0)&&(aI(b),h=t[e]);if(8==(h|0)){aI(b);h=9==(t[e]|0);c=0!=(c|0);a:do{if(!h){for(var i=g|0,m=b+8|0;;){if(c&&(0!=(t[i>>2]|0)&&U(g,Eo|0),U(g,t[t[m>>2]+8>>2])),aI(b),9==(t[e]|0)){break a}}}}while(0);c&&(e=g|0,c=t[e>>2],(c+1|0)==(t[g+4>>2]|0)?(R(g),e=t[e>>2]):e=c,c=g+8|0,l[t[c>>2]+e|0]=0,V(t[f+8>>2],t[c>>2]),bI(f,d))}ZH(f);Q(g)}$H.X=1;function bI(b,d){if(0!=(t[Lx+(d<<4)>>2]|0)){var c=b+12|0;if(0!=(t[t[c>>2]>>2]|0)){var e=P();V(e,t[t[c>>2]+8>>2]);U(e,Xi|0);c=b+8|0;U(e,t[t[c>>2]+8>>2]);var f=e|0,g=t[f>>2];(g+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=g;g=e+8|0;l[t[g>>2]+f|0]=0;V(t[c>>2],t[g>>2]);Q(e)}c=j;j+=80;e=c>>2;0!=(t[Lx+(d<<4)>>2]|0)&&(sC(c,t[t[b+8>>2]+8>>2]),t[e+1]=t[b+16>>2],t[e+2]=t[b+20>>2],t[e+9]=t[Lx+(d<<4)+8>>2],l[c+40|0]=t[Lx+(d<<4)+4>>2]&255,tC(c));j=c}}function cI(b,d){var c,e,f;f=(b|0)>>2;e=(b+4|0)>>2;c=(b+8|0)>>2;var g=1;a:for(;;){for(;;){if(!g){break a}var h=T();if(-1==(h|0)){g=0;continue a}else{if(92==(h|0)){var h=T(),i=t[f];(i+1|0)==(t[e]|0)&&(R(b),i=t[f]);l[t[c]+i|0]=h&255;if(0==(h|0)){continue}h=t[f]+1|0;t[f]=h;l[t[c]+h|0]=0;continue}}if((h|0)==(d|0)){g=0;continue a}i=t[f];(i+1|0)==(t[e]|0)&&(R(b),i=t[f]);l[t[c]+i|0]=h&255;0!=(h|0)&&(h=t[f]+1|0,t[f]=h,l[t[c]+h|0]=0)}}g=t[f];(g+1|0)!=(t[e]|0)?(c=t[c],c=c+g|0):(R(b),e=t[f],c=t[c],c=c+e|0);l[c]=0}cI.X=1;function dI(b,d){var c,e;e=(b|0)>>2;var f=b+4|0;c=(b+8|0)>>2;for(var g=d;;){var h=t[e];(h+1|0)==(t[f>>2]|0)&&(R(b),h=t[e]);l[t[c]+h|0]=g&255;0!=(g|0)&&(g=t[e]+1|0,t[e]=g,l[t[c]+g|0]=0);h=T();if(0==(eI(h)|0)){break}else{g=h}}g=t[e];(g+1|0)==(t[f>>2]|0)?(R(b),e=t[e]):e=g;l[t[c]+e|0]=0;0==(L(h)|0)&&W(h)}function aI(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+16|0)>>2;for(b=(b+20|0)>>2;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(42==(h|0)){f=1916;break}else{if(-1==(h|0)){f=1908;break}else{if(40==(h|0)){f=1909;break}else{if(44==(h|0)){f=1911;break}else{if(125==(h|0)){f=1913;break}else{if(39==(h|0)||34==(h|0)){f=1917;break}else{if(123==(h|0)){f=1912;break}else{if(32==(h|0)||10==(h|0)||9==(h|0)){continue}else{if(93==(h|0)){f=1915;break}else{if(92==(h|0)){f=1918;break}else{if(91==(h|0)){f=1914;break}else{if(41==(h|0)){f=1910;break}else{if(37!=(h|0)){f=1924;break}}}}}}}}}}}}}uE(10)}1916==f?t[e]=13:1908==f?dB(wz|0,1):1909==f?t[e]=5:1911==f?t[e]=3:1924==f?0==(eI(h)|0)?t[e]=0:(dI(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2],t[e]=6):1913==f?t[e]=9:1917==f?(t[e]=7,cI(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2]):1912==f?t[e]=8:1915==f?t[e]=11:1918==f?(f=T(),0==(pA(f)|0)?W(f):(dI(t[c],f),t[d]=t[K+48>>2],t[b]=t[K+24>>2],d=UD(t[c],t[Jy>>2]),t[g>>2]=d,t[e]=-1==(d|0)?6:4)):1914==f?t[e]=10:1910==f&&(t[e]=2)}aI.X=1;function fI(b){t[Ix>>2]=b}function eI(b){return 0!=(pA(b)|0)|10>(b-48|0)>>>0?1:95==(b|0)||45==(b|0)||36==(b|0)||35==(b|0)||46==(b|0)?1:0}function gI(b,d){var c;S(b);if(0==(hI(d)|0)){var e=t[(b|0)>>2];return e=0!=(e|0)&1}var f=0==(hI(d)|0),e=b|0;c=e>>2;var g=b+4|0;a:do{if(f){var h=d}else{for(var i=b+8|0,m=d;;){var n=t[c];(n+1|0)==(t[g>>2]|0)&&(R(b),n=t[c]);l[t[i>>2]+n|0]=m&255;0!=(m|0)&&(m=t[c]+1|0,t[c]=m,l[t[i>>2]+m|0]=0);m=iI();if(0==(hI(m)|0)){h=m;break a}}}}while(0);fI(h);f=t[c];(f+1|0)==(t[g>>2]|0)?(R(b),c=t[c]):c=f;l[t[b+8>>2]+c|0]=0;e=t[e>>2];return e=0!=(e|0)&1}gI.X=1;function jI(b){var d=0==(L(b)|0);a:do{if(d){var c=b}else{for(;;){var e=iI();if(0==(L(e)|0)){c=e;break a}}}}while(0);return c}function kI(b,d){for(var c=b<<24>>24,e=d<<24>>24,f=1;;){var g=iI(),f=(g|0)==(c|0)?f+1|0:(((g|0)==(e|0))<<31>>31)+f|0;if(0>=(f|0)){break}}return iI()}function hI(b){return(0!=(oA(b)|0)|95==(b|0)|96==(b|0))&1}function lI(){var b,d=zC(24);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+4]=t[K+48>>2];t[b+5]=t[K+24>>2];return d}function mI(b){0!=(b|0)&&(Q(t[b+8>>2]),Q(t[b+12>>2]),vB(b))}function nI(b,d){var c=t[b+4>>2];83==(c|0)?oI(b):23==(c|0)?uE(59):28==(c|0)?pI(b):79==(c|0)?oI(b):58==(c|0)?(c=lI(),qI(b),12==(t[b+4>>2]|0)?(qI(c),rI(c,9)):4==(t[b>>2]|0)&&rI(b,9),mI(c)):18==(c|0)?(c=lI(),qI(c),0==(d|0)?rI(c,0):rI(c,10),uE(59),mI(c)):16==(c|0)?sI(b):24==(c|0)?sI(b):61==(c|0)&&pI(b)}function oI(b){var d,c=lI();d=(b+4|0)>>2;var e=t[d];qI(c);qI(b);if(38==(t[d]|0)&&(qI(b),d=65==(t[d]|0),rI(c,83==(e|0)?1:2),d)){e=lI();qI(e);for(d=e+4|0;!(qI(b),uE(59),rI(e,3),qI(e),23==(t[d>>2]|0));){}uE(59);mI(e)}mI(c)}function sI(b){var d=lI(),c=b+4|0,e=t[c>>2];qI(d);24!=(e|0)?(rI(d,5),tI(),uE(59)):(qI(b),38==(t[c>>2]|0)&&(rI(d,4),tI(),uE(59)));mI(d)}function pI(b){var d,c,e,f=lI();c=(b+4|0)>>2;var g=28==(t[c]|0);qI(f);qI(b);d=(b|0)>>2;if(1==(t[d]|0)){var h=b|0;if(1==(t[h>>2]|0)){qI(b);for(var i=1;;){var m=t[h>>2],i=(1==(m|0)&1)+i|0,i=((2==(m|0)&0<(i|0))<<31>>31)+i|0;qI(b);if(!(0!=(i|0)|2!=(m|0))){break}}}}a:do{if(g){if(68!=(t[c]|0)){e=2060}else{for(qI(b);;){if(38==(t[c]|0)){e=2060;break a}if(8==(t[d]|0)){break a}qI(b)}}}else{e=2060}}while(0);do{if(2060==e&&8!=(t[d]|0)){if(38!=(t[c]|0)){mI(f);return}if(g){rI(f,7);for(d=f+8|0;;){if(qI(b),23==(t[c]|0)){if(qI(b),e=(28==(t[b+4>>2]|0)?1:0!=(uI(b,t[d>>2])|0))&1,uE(59),0!=(e|0)){break}}else{nI(b,1)}}}else{rI(f,8);for(d=f+8|0;;){if(qI(b),23==(t[c]|0)){if(qI(b),e=(61==(t[b+4>>2]|0)?1:0!=(uI(b,t[d>>2])|0))&1,uE(59),0!=(e|0)){break}}else{nI(b,1)}}}mI(f);return}}while(0);rI(f,6);mI(f)}pI.X=1;function iI(){var b,d=t[Ix>>2];0==(d|0)?d=T():t[Ix>>2]=0;if(34==(d|0)){for(;;){if(b=T(),-1==(b|0)||34==(b|0)){var c=64;break}}return c}if(47==(d|0)){b=2086}else{var e=d}a:do{if(2086==b){if(c=T(),-1==(c|0)){dB(vz|0,1)}else{if(42==(c|0)){e=vI()}else{if(47==(c|0)){for(;;){if(c=T(),-1==(c|0)||10==(c|0)){e=c;break a}}}else{return W(c),c=47}}}}}while(0);if(-1==(e|0)){dB(vz|0,1)}else{return e}}function qI(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+16|0)>>2;for(b=(b+20|0)>>2;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(34==(h|0)){f=2106;break}else{if(59==(h|0)){f=2103;break}else{if(41==(h|0)){f=2102;break}else{if(-1==(h|0)){f=2100;break}else{if(46==(h|0)){f=2104;break}else{if(44==(h|0)){f=2105;break}else{if(40==(h|0)){f=2101;break}else{if(32==(h|0)||10==(h|0)||9==(h|0)){continue}else{if(39==(h|0)){f=2128;break}else{if(45!=(h|0)){f=2112;break}}}}}}}}}}var i=T();if(45!=(i|0)){f=2109;break}uE(10)}if(2106==f){t[e]=9,wI(t[c]),t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2103==f){t[e]=8}else{if(2102==f){t[e]=2}else{if(2100==f){dB(uz|0,1)}else{if(2112==f){if(0==((95==(h|0)|0!=(pA(h)|0))&1|0)){t[e]=0}else{var i=t[c],m;m=(i|0)>>2;var n=i+4|0;for(f=(i+8|0)>>2;;){var q=t[m];(q+1|0)==(t[n>>2]|0)&&(R(i),q=t[m]);l[t[f]+q|0]=h&255;0!=(h|0)&&(q=t[m]+1|0,t[m]=q,l[t[f]+q|0]=0);q=T();if(0==((0==(pA(q)|0)?95==(q|0)|10>(q-48|0)>>>0:1)&1|0)){break}else{h=q}}h=t[m];(h+1|0)==(t[n>>2]|0)?(R(i),i=t[m]):i=h;l[t[f]+i|0]=0;0==(L(q)|0)&&W(q);t[d]=t[K+48>>2];t[b]=t[K+24>>2];d=UD(t[c],t[Ey>>2]);t[g>>2]=d;t[e]=-1==(d|0)?4:5}}else{2104==f?t[e]=6:2105==f?t[e]=3:2101==f?t[e]=1:2109==f&&(0==(L(i)|0)&&W(i),t[e]=7)}}}}}}qI.X=1;function rI(b,d){if(0!=(t[Cx+(d<<4)>>2]|0)){var c=b+12|0;if(0!=(t[t[c>>2]>>2]|0)){var e=P();V(e,t[t[c>>2]+8>>2]);U(e,Xi|0);c=b+8|0;U(e,t[t[c>>2]+8>>2]);var f=e|0,g=t[f>>2];(g+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=g;g=e+8|0;l[t[g>>2]+f|0]=0;V(t[c>>2],t[g>>2]);Q(e)}c=j;j+=80;e=c>>2;0!=(t[Cx+(d<<4)>>2]|0)&&(sC(c,t[t[b+8>>2]+8>>2]),t[e+1]=t[b+16>>2],t[e+2]=t[b+20>>2],t[e+9]=t[Cx+(d<<4)+8>>2],l[c+40|0]=t[Cx+(d<<4)+4>>2]&255,tC(c));j=c}}function uI(b,d){if(4!=(t[b>>2]|0)){var c;return 0}c=0==(sA(t[t[b+8>>2]+8>>2],t[d+8>>2],Aa)|0);return c&1}function tI(){for(var b=lI(),d=b+4|0;!(qI(b),23==(t[d>>2]|0));){}mI(b)}function wI(b){var d,c,e;e=(b|0)>>2;c=(b+4|0)>>2;d=(b+8|0)>>2;var f=1;a:for(;;){for(;;){if(!f){break a}var g=T();if(-1==(g|0)||34==(g|0)){f=0;continue a}else{if(92==(g|0)){var g=T(),h=t[e]}else{h=t[e]}(h+1|0)==(t[c]|0)&&(R(b),h=t[e]);l[t[d]+h|0]=g&255;0!=(g|0)&&(g=t[e]+1|0,t[e]=g,l[t[d]+g|0]=0)}}}f=t[e];(f+1|0)!=(t[c]|0)?(d=t[d],d=d+f|0):(R(b),b=t[e],d=t[d],d=d+b|0);l[d]=0}wI.X=1;function xI(){for(var b;;){var d=eC();if(0==(d|0)){var c=0;b=2211;break}for(;0!=(L(l[d]&255)|0);){d=d+1|0}if(34!=l[d]<<24>>24){c=d;b=2210;break}}if(2210==b||2211==b){return c}}function yI(b){var d,c,e=P(),f=92==l[b]<<24>>24;a:do{if(f){for(var g=b;;){var g=g+1|0,h=l[g];if(0==h<<24>>24){c=g;break a}if(0==(L(h&255)|0)){c=g;break a}}}else{if(0==(N(b,Hr|0,4)|0)){var i=0;Q(e);return i}if(0==(N(b,Go|0,4)|0)||0!=(N(b,om|0,3)|0)){return i=0,Q(e),i}g=b+3|0;h=l[g];109==h<<24>>24&&(g=b+4|0,h=l[g],97==h<<24>>24&&(g=b+5|0,h=l[g],110==h<<24>>24&&(g=b+6|0,g=h=100==l[g]<<24>>24?b+7|0:g,h=l[h])));g=33==h<<24>>24?g+1|0:g;if(32==l[g]<<24>>24){h=32}else{return i=1,Q(e),i}for(;;){if(0==h<<24>>24){c=g;break a}var m=g+1|0;if(0==(L(h&255)|0)){c=g;break a}g=m;h=l[m]}}}while(0);for(;;){b=0==(L(l[c]&255)|0);a:do{if(b){if(45==l[c]<<24>>24){f=c;for(g=45;;){if(0==g<<24>>24){i=f;break a}h=f+1|0;if(0!=(L(g&255)|0)){i=f;break a}f=h;g=l[h]}}else{i=c}}else{i=c+1|0}}while(0);c=l[i];if(0==c<<24>>24){break}if(0==(oA(c&255)|0)){c=i}else{d=2249;break}}if(2249==d&&0!=l[i]<<24>>24){c=(e|0)>>2;b=e+4|0;for(d=(e+8|0)>>2;!(f=t[c],(f+1|0)==(t[b>>2]|0)&&(R(e),f=t[c]),l[t[d]+f|0]=l[i],0!=l[i]<<24>>24&&(f=t[c]+1|0,t[c]=f,l[t[d]+f|0]=0),i=i+1|0,0==(oA(l[i]&255)|0)&&95!=l[i]<<24>>24);){}i=t[c];(i+1|0)==(t[b>>2]|0)&&(R(e),i=t[c]);l[t[d]+i|0]=0;jC(e,Ax|0,1);S(e);i=1;Q(e);return i}yI(xI());i=1;Q(e);return i}yI.X=1;function zI(b){return 0==(N(b,ys|0,3)|0)||0==(N(b,hs|0,2)|0)||0==(N(b,Or|0,3)|0)||0==(N(b,nr|0,4)|0)||0==(N(b,Yq|0,2)|0)||0==(N(b,Lq|0,3)|0)||0==(N(b,yq|0,4)|0)||0==(N(b,kq|0,2)|0)||0==(N(b,Sp|0,3)|0)||0==(N(b,Cp|0,4)|0)||0==(N(b,np|0,2)|0)||0==(N(b,ap|0,3)|0)||0==(N(b,No|0,4)|0)||0==(N(b,so|0,2)|0)||0==(N(b,jo|0,3)|0)||0==(N(b,$n|0,4)|0)||0==(N(b,Pn|0,2)|0)||0==(N(b,An|0,3)|0)||0==(N(b,pn|0,4)|0)||0==(N(b,br|0,2)|0)||0==(N(b,Tm|0,3)|0)||0==(N(b,Gm|0,4)|0)||0==(N(b,tm|0,5)|0)||0==(N(b,bm|0,6)|0)||0==(N(b,Tl|0,7)|0)||0==(N(b,Jl|0,3)|0)||0==(N(b,Bl|0,4)|0)||0==(N(b,rl|0,5)|0)||0==(N(b,gl|0,6)|0)||0==(N(b,Wk|0,7)|0)||0==(N(b,Kk|0,8)|0)||0==(N(b,xk|0,3)|0)||0==(N(b,nk|0,4)|0)||0==(N(b,Zj|0,5)|0)||0==(N(b,Rj|0,6)|0)||0==(N(b,Kj|0,7)|0)||0==(N(b,Fj|0,8)|0)||0==(N(b,yj|0,3)|0)||0==(N(b,rj|0,4)|0)||0==(N(b,fj|0,5)|0)||0==(N(b,Yi|0,6)|0)||0==(N(b,Mi|0,7)|0)||0==(N(b,Di|0,8)|0)||0==(N(b,mi|0,3)|0)||0==(N(b,gi|0,4)|0)||0==(N(b,bi|0,5)|0)||0==(N(b,Zh|0,6)|0)||0==(N(b,Vh|0,7)|0)||0==(N(b,Oh|0,8)|0)||0==(N(b,Gh|0,3)|0)||0==(N(b,Ah|0,4)|0)||0==(N(b,qh|0,5)|0)||0==(N(b,jh|0,6)|0)||0==(N(b,Yg|0,7)|0)||0==(N(b,Tg|0,8)|0)||0==(N(b,Og|0,3)|0)||0==(N(b,Jg|0,4)|0)||0==(N(b,Cg|0,5)|0)||0==(N(b,ug|0,6)|0)?1:0==(N(b,og|0,7)|0)?1:0==(N(b,kg|0,8)|0)&1}zI.X=1;function AI(b){for(var d,c,e=P();;){var f=l[b];if(0==f<<24>>24){c=b;break}var g=b+1|0;if(0==(oA(f&255)|0)){d=2393;break}else{b=g}}2393==d&&(c=33==l[b]<<24>>24?g:b);a:for(;;){g=l[c];do{if(0!=g<<24>>24&&0!=(L(g&255)|0)){c=c+1|0;continue a}}while(0);if(0==(N(c,Nv|0,8)|0)){var h=c;break}do{if(0==(N(c,nv|0,8)|0)){d=2402}else{if(0==(N(c,Ru|0,8)|0)){d=2402}else{if(0==(N(c,su|0,8)|0)){d=2402}else{if(0==(N(c,Ut|0,8)|0)){d=2402}else{if(0==(N(c,tt|0,6)|0)){var i=c+6|0}else{if(0!=(N(c,Ts|0,9)|0)){h=c;break a}i=c+9|0}}}}}}while(0);2402==d&&(d=0,i=c+8|0);if(0==l[i]<<24>>24){h=i;break}else{c=i}}c=(e|0)>>2;i=e+4|0;for(d=(e+8|0)>>2;!(g=t[c],(g+1|0)==(t[i>>2]|0)&&(R(e),g=t[c]),l[t[d]+g|0]=l[h],0!=l[h]<<24>>24&&(g=t[c]+1|0,t[c]=g,l[t[d]+g|0]=0),h=h+1|0,g=l[h],0==g<<24>>24||32==g<<24>>24);){}h=t[c];(h+1|0)==(t[i>>2]|0)&&(R(e),h=t[c]);d=t[d];d=d+h|0;l[d]=0;jC(e,Ax|0,3);S(e);Q(e)}AI.X=1;function BI(b){var d,c,e=j;j+=4;var f,g=P();d=b+2|0;var h=l[d];110==h<<24>>24?(d=b+3|0,h=l[d],99!=h<<24>>24?b=d:(d=b+4|0,h=l[d],116!=h<<24>>24?b=d:(d=b+5|0,h=l[d],105!=h<<24>>24?b=d:(d=b+6|0,h=l[d],111!=h<<24>>24?b=d:(h=b+7|0,b=h=110==l[h]<<24>>24?b+8|0:h,h=l[h]))))):b=d;b=33==h<<24>>24?b+1|0:b;h=0==(L(l[b]&255)|0);a:do{if(!h){for(d=b;;){c=l[d];if(0==c<<24>>24){break a}if(0==(L(c&255)|0)){break}else{d=d+1|0}}if(0!=l[d]<<24>>24){var i=CI(d,e);if(0==((65<=(l[i]&255)&&90>=(l[i]&255))|0)&&(d=t[e>>2],!(115==(d|0)||100==(d|0)||97==(d|0)||60==(d|0)))){break}c=(g|0)>>2;var m=g+4|0;for(d=(g+8|0)>>2;;){var n=t[c];(n+1|0)==(t[m>>2]|0)&&(R(g),n=t[c]);l[t[d]+n|0]=l[i];0!=l[i]<<24>>24&&(n=t[c]+1|0,t[c]=n,l[t[d]+n|0]=0);i=i+1|0;if(0==(oA(l[i]&255)|0)&&(n=l[i],!(95==n<<24>>24||46==n<<24>>24||35==n<<24>>24))){break}}i=t[c];(i+1|0)==(t[m>>2]|0)?(R(g),c=t[c]):c=i;l[t[d]+c|0]=0;jC(g,Ax|0,2);S(g)}}}while(0);for(;;){b=xI();if(0==(b|0)){f=2445;break}if(0!=(N(b,Re|0,5)|0)&&0==(N(b,jx|0,4)|0)){f=2446;break}}2446==f?(Q(g),j=e):2445==f&&(Q(g),j=e)}BI.X=1;function DI(b){var d,c=P(),e=b+3|0,f=l[e];114==f<<24>>24?(e=b+4|0,f=l[e],111!=f<<24>>24?b=e:(e=b+5|0,f=l[e],117!=f<<24>>24?b=e:(f=b+6|0,b=f=112==l[f]<<24>>24?b+7|0:f,f=l[f]))):b=e;if(0!=(L(f&255)|0)){for(e=b;;){b=l[e];if(0==b<<24>>24){d=2469;break}if(0==(L(b&255)|0)){break}else{e=e+1|0}}if(2469!=d&&0!=l[e]<<24>>24&&0!=(sA(e,Sf|0,3)|0)){b=(c|0)>>2;f=c+4|0;for(d=(c+8|0)>>2;;){var g=t[b];(g+1|0)==(t[f>>2]|0)&&(R(c),g=t[b]);l[t[d]+g|0]=l[e];0!=l[e]<<24>>24&&(g=t[b]+1|0,t[b]=g,l[t[d]+g|0]=0);e=e+1|0;if(0==(oA(l[e]&255)|0)&&95!=l[e]<<24>>24){break}}e=t[b];(e+1|0)==(t[f>>2]|0)?(R(c),b=t[b]):b=e;l[t[d]+b|0]=0;jC(c,Ax|0,0);S(c)}}Q(c)}DI.X=1;function EI(b){var d,c,e=P(),b=b+3|0;if(0!=(L(l[b]&255)|0)){for(;;){var f=l[b];if(0==f<<24>>24){d=2495;break}var g=b+1|0;if(0==(L(f&255)|0)){break}else{b=g}}if(2495!=d){f=l[b];if(118==f<<24>>24){d=2476}else{if(0==f<<24>>24||38==f<<24>>24||64==f<<24>>24||91==f<<24>>24){Q(e);return}var h=b;c=f}if(2476==d){if(58!=l[g]<<24>>24){h=b,c=118}else{Q(e);return}}for(;;){if(0==c<<24>>24||36==c<<24>>24){var i=c;break}g=h+1|0;if(0!=(oA(c&255)|0)){d=2480;break}h=g;c=l[g]}2480==d&&(i=l[h]);if(0!=i<<24>>24){c=(e|0)>>2;g=e+4|0;d=(e+8|0)>>2;for(b=i;0!=b<<24>>24;){if(i=t[c],(i+1|0)==(t[g>>2]|0)&&(R(e),b=l[h],i=t[c]),l[t[d]+i|0]=b,0!=l[h]<<24>>24&&(i=t[c]+1|0,t[c]=i,l[t[d]+i|0]=0),h=h+1|0,i=l[h],0!=(oA(l[h]&255)|0)){b=i}else{if(95==i<<24>>24||35==i<<24>>24||58==i<<24>>24||36==i<<24>>24){b=i}else{break}}}i=t[c];(i+1|0)==(t[g>>2]|0)&&(R(e),i=t[c]);l[t[d]+i|0]=0;jC(e,Ax|0,4);S(e)}}}Q(e)}EI.X=1;function FI(b){return-2==(b|0)?b=Lu|0:b=t[t[t[Cy>>2]+(b<<2)>>2]>>2]}function CI(b,d){var c=d>>2,e=tb(b),f=0!=(d|0);f&&(t[c]=0);if(3<e>>>0){if(58==l[b+1|0]<<24>>24){f&&(t[c]=l[b]&255);var g;return b+2|0}if(5<e>>>0){if(0!=(sA(b,xw|0,5)|0)){e=0}else{return f&&(t[c]=l[b]&255),b+5|0}}else{e=0}}else{e=0}for(;;){if(f=l[b+e|0]&255,35==(f|0)?t[c]=97:46==(f|0)&&(t[c]=100),e=e+1|0,f=b+e|0,0==(oA(l[f]&255)|0)&&(f=l[f],!(95==f<<24>>24||46==f<<24>>24||35==f<<24>>24))){g=b;break}}return g}CI.X=1;function jC(b,d,c){var e=j;j+=80;!(0==(t[d+(c<<4)>>2]|0)|0==(b|0))&&0!=(t[b>>2]|0)&&(sC(e,t[b+8>>2]),t[e+36>>2]=t[d+(c<<4)+8>>2],l[e+40|0]=t[d+(c<<4)+4>>2]&255,tC(e));j=e}function GI(b){var d=MG(52);t[d>>2]=HI(b);return d}function II(b){var d=t[oy+128>>2];if(-1==(d|0)){if(d=JI(KI(b)),-2!=(d|0)){var c=d}else{var e;var d=kH(b),f=t[Dy>>2];if(0==(f|0)){e=-2}else{for(var g=t[Cy>>2],h=-2,i=0;;){var m=t[t[g+(i<<2)>>2]+44>>2];if(0!=(m|0)){var n;n=ba;for(var q=m+4|0,m=m+8|0,p=0,s=0;;){if(0!=(s|0)){var r=s;n=2999;break}if(p>>>0>=t[q>>2]>>>0){r=0;n=3e3;break}s=0==(sA(t[t[t[m>>2]+(p<<2)>>2]+8>>2],d,Aa)|0)&1;p=p+1|0}n=2999==n||3e3==n?r:ba;h=0==(n|0)?h:i}i=i+1|0;if(!(i>>>0<f>>>0&-2==(h|0))){e=h;break}}}if(-2!=(e|0)){c=e}else{if(LI(b),0==(t[ld+20>>2]|0)){c=-2}else{if(b=tB(b,Wv|0),0==(b|0)){c=-2}else{e=P();r=MI(e,b);if(0==(r|0)){c=-2}else{if(35!=l[r]<<24>>24){c=-2}else{if(33!=l[r+1|0]<<24>>24){c=-2}else{d=gB(r,47);r=NI(0==(d|0)?r+2|0:d+1|0);d=r+8|0;f=JI(t[d>>2]);if(-2==(f|0)){if(f=t[Dy>>2],0==(f|0)){c=-2}else{g=t[Cy>>2];i=-2;for(h=0;;){if(n=t[t[g+(h<<2)>>2]>>2],i=0==(n|0)?i:0==(sA(t[d>>2],n,Aa)|0)?h:i,h=h+1|0,!(h>>>0<f>>>0&-2==(i|0))){c=i;break}}}}else{c=f}Q(r)}}}Q(e);uB(b)}}}}}else{c=d}return c}function JI(b){var d=t[Dy>>2];if(0==(d|0)){var c;return-2}for(var e=0,f=d;;){if(d=t[t[t[Cy>>2]+(e<<2)>>2]+48>>2],0==(d|0)?d=-2:(d=0==(-1!=(OI(d,b,186)|0)&1|0)?-2:e,f=t[Dy>>2]),e=e+1|0,!(e>>>0<f>>>0&-2==(d|0))){c=d;break}}return c}function PI(b){for(var d=j,c,e=t[t[t[Cy>>2]+(b<<2)>>2]+44>>2],f=0==(e|0),g=e+4|0,h=e+8|0,e=1,i=0;!f&&i>>>0<t[g>>2]>>>0;){var e=0!=(e|0)?hm|0:Eo|0,m=t[t[t[h>>2]+(i<<2)>>2]+8>>2];mB(lw|0,(k=j,j+=8,t[k>>2]=e,t[k+4>>2]=m,k));e=0;i=i+1|0}g=t[t[t[Cy>>2]+(b<<2)>>2]+48>>2];b=0==(g|0);f=g+4|0;g=g+8|0;h=e;for(e=0;;){if(b){c=2587;break}if(e>>>0>=t[f>>2]>>>0){c=2586;break}h=0!=(h|0)?hm|0:Eo|0;i=t[t[t[g>>2]+(e<<2)>>2]+8>>2];mB(lm|0,(k=j,j+=8,t[k>>2]=h,t[k+4>>2]=i,k));h=0;e=e+1|0}2587==c?j=d:2586==c&&(j=d)}PI.X=1;function QI(){var b,d=j;b=zC(176);t[Cy>>2]=b;KC(Rf|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));for(var c=0;;){var e=ab[t[Uz+(c<<2)>>2]]();b=e>>2;var f=0==(e|0);a:do{if(!f){var g=t[b];do{if(0!=(g|0)&&0!=l[g]<<24>>24){f=e+24|0;do{if(0==(t[b+8]|0)){if(!(0==(t[f>>2]|0)^0==(t[b+7]|0))){RI(1,ix|0,(k=j,j+=4,t[k>>2]=g,k));break a}}else{t[f>>2]=132}}while(0);f=0!=(c|0)?Cr|0:hm|0;KC(cw|0,(k=j,j+=8,t[k>>2]=f,t[k+4>>2]=g,k));g=t[Dy>>2];t[Dy>>2]=g+1|0;t[b+9]=g;t[t[Cy>>2]+(g<<2)>>2]=e;break a}}while(0);RI(1,Qe|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k))}}while(0);b=c+1|0;if(44==(b|0)){break}else{c=b}}KC(Jq|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));b=t[Dy>>2];if(0!=(b|0)){for(c=0;!(t[t[t[Cy>>2]+(c<<2)>>2]+40>>2]=1,c=c+1|0,c>>>0>=b>>>0);){}}c=t[Dy>>2];if(0!=(c|0)){for(b=0;!(e=t[t[t[Cy>>2]+(b<<2)>>2]+20>>2],0!=(e|0)&&(ab[e](b),c=t[Dy>>2]),b=b+1|0,b>>>0>=c>>>0);){}}j=d}QI.X=1;function NI(b){var d,c,e,f=P();c=(f|0)>>2;var g=f+4|0;for(d=(f+8|0)>>2;;){for(S(f);;){if(0==(L(l[b]<<24>>24)|0)){var h=b;break}else{b=b+1|0}}for(;;){b=l[h];if(0==b<<24>>24){e=2676;break}var i=t[c],m=(i+1|0)==(t[g>>2]|0);if(0!=(L(b<<24>>24)|0)){e=2683;break}m?(R(f),b=t[c]):b=i;l[t[d]+b|0]=l[h];0!=l[h]<<24>>24&&(b=t[c]+1|0,t[c]=b,l[t[d]+b|0]=0);h=h+1|0}if(2676==e){if(e=0,b=t[c],(b+1|0)==(t[g>>2]|0)){e=2684}else{var n=b}}else{2683==e&&(e=0,m?e=2684:n=i)}2684==e&&(e=0,R(f),n=t[c]);l[t[d]+n|0]=0;if(0==(qA(t[d],Lo|0)|0)){b=h}else{break}}return f}NI.X=1;function KC(b){var d=j;j+=4;0!=(t[oy+88>>2]|0)&&(t[d>>2]=arguments[KC.length],wB(b,t[d>>2]));j=d}function rD(b,d,c){var e,f=t[oy+60>>2];if(0==(f|0)){var g;return 0}var h=tb(b),i=0!=(d|0);i&&(t[d>>2]=0);for(var m=t[f+4>>2],n=h+1|0,f=f+8|0,q=0;;){if(q>>>0>=m>>>0){g=0;e=2724;break}var p=t[t[f>>2]+(q<<2)>>2],s=t[p+8>>2];if(0==(N(s,b,h)|0)){p=t[p>>2];if((h|0)==(p|0)){g=1;e=2720;break}var r=l[s+h|0];if((p|0)==(n|0)&43==r<<24>>24){e=2711;break}if(61==r<<24>>24){e=2714;break}}q=q+1|0}if(2714==e){if(0==(c|0)){return 0}t[c>>2]=s+n|0;return 0}if(2711==e){return!i?1:t[d>>2]=1}if(2720==e||2724==e){return g}}function SI(b){var d=j,c=b+1|0,e=l[b];if(0==e<<24>>24){c=oz,b=t[c>>2],0!=(b|0)&&(fH(b),t[c>>2]=0)}else{if(64==e<<24>>24){b=tB(c,Wv|0);if(0==(b|0)){var f=0}else{if(e=bH(),0!=(cB(b)|0)){f=e}else{for(;;){var g=P();MI(g,b);DD(g);0==(t[g>>2]|0)?Q(g):AE(e,g);if(0!=(cB(b)|0)){f=e;break}}}}b=f;0==(b|0)&&RI(5,Xv|0,(k=j,j+=4,t[k>>2]=c,k));f=t[oz>>2];if(0==(f|0)){t[oz>>2]=b}else{e=b+4|0;if(0!=(t[e>>2]|0)){for(var g=b+8|0,h=0;!(AE(f,t[t[g>>2]+(h<<2)>>2]),t[t[g>>2]+(h<<2)>>2]=0,h=h+1|0,h>>>0>=t[e>>2]>>>0);){}}fH(b)}KC(Fm|0,(k=j,j+=4,t[k>>2]=c,k))}else{c=PD(b),f=t[oz>>2],0==(f|0)&&(f=bH(),t[oz>>2]=f),AE(f,c),KC(rm|0,(k=j,j+=4,t[k>>2]=b,k))}}j=d}function kH(b){var d=gB(b,47);return 0==(d|0)?b:d+1|0}function zC(b){var d=j,b=Xa(b);if(0!=(b|0)){return j=d,b}RI(1,gk|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));j=d;return b}function MG(b){var d=j;var c=Xa(b);0==(c|0)||0==(t[c-4>>2]&3|0)||Ya(c,b);if(0!=(c|0)){return j=d,c}RI(1,gk|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));j=d;return c}function jF(b,d){var c=j;if(0==(b|0)){var e=zC(d)}else{e=0==(b|0)?Xa(d):TI(b,d),0==(e|0)&&(RI(1,gk|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k)),e=0)}j=c;return e}function HI(b){var d=zC(tb(b)+1|0);AB(d,b);return d}function LI(b){var d=j;j+=72;var c=t[ld>>2];if(!(0!=(c|0)&&0==(qA(b,c)|0))){if(c=t[ld>>2],0!=(c|0)&&(vB(c),t[ld>>2]=0),b=HI(b),t[ld>>2]=b,0!=(PB(b,d,ca)|0)){t[ld+4>>2]=0}else{var b=d+8|0,c=t[b>>2],e=40960==(c&61440|0);t[ld+8>>2]=e&1;if(e){if(0==(PB(t[ld>>2],d)|0)){b=t[b>>2]}else{t[ld+4>>2]=0;j=d;return}}else{b=c}t[ld+4>>2]=1;c=b&61440;t[ld+12>>2]=16384==(c|0)&1;t[ld+16>>2]=32768==(c|0)&1;t[ld+20>>2]=0!=(b&73|0)&1;t[ld+24>>2]=b>>>11&1;t[ld+28>>2]=t[d+28>>2]}}j=d}LI.X=1;function KI(b){b=gB(kH(b),46);return 0==(b|0)?hm|0:b+1|0}function UI(b,d,c,e,f){var g=j;j+=12;var h=g+4,i=g+8;var m=j;j+=256;var n=0==(f|0);b:do{if(n){var q=9}else{for(var p=0,s=9;;){var r=l[f+p|0];if(0==r<<24>>24){q=s;break b}r=r<<24>>24;101==(r|0)?s|=1:98==(r|0)?s&=-2:105==(r|0)?s|=2:RI(2,Qu|0,(k=j,j+=4,t[k>>2]=l[f]<<24>>24,k));p=p+1|0}}}while(0);f=zC(16);n="";q&2&&(n+="i");SB[f]=RegExp(TB(d),n);j=m;0!=(f|0)&&(VI(e,g,h,i),WI(b,f,HI(c),l[g],t[h>>2],t[i>>2]));j=g}function VI(b,d,c,e){c>>=2;l[d]=0;t[c]=0;t[e>>2]=0;var f=0==(b|0);a:do{if(!f){f=l[b];do{if(0==f<<24>>24){break a}else{if(44==f<<24>>24){var g=b,h=114}else{g=b+1|0,h=l[g],44==h<<24>>24||0==h<<24>>24?h=f:(g=b,h=114)}}}while(0);l[d]=h;b=44==l[g]<<24>>24?g+1|0:g;if(0==l[b]<<24>>24){t[c]=HI(yt|0);return}d=mA(b,44);if(0==(d|0)){t[c]=HI(b);return}f=d-b|0;g=zC(f+1|0);t[c]=g;iB(g,b,f);l[t[c]+f|0]=0;c=d+1|0;if(0==l[c]<<24>>24){return}t[e>>2]=HI(c);return}}while(0);l[d]=114;t[c]=HI(yt|0)}VI.X=1;function WI(b,d,c,e,f,g){var h,i=t[Yx>>2];if((t[Zx>>2]|0)<(b|0)){i=jF(i,(b<<3)+8|0);t[Yx>>2]=i;h=t[Zx>>2]+1|0;var m=(h|0)>(b|0);a:do{if(!m){for(var n=h;;){if(t[i+(n<<3)>>2]=0,t[i+(n<<3)+4>>2]=0,n=n+1|0,(n|0)>(b|0)){break a}}}}while(0);t[Zx>>2]=b}h=i;i=(b<<3)+h|0;h=((b<<3)+h+4|0)>>2;m=jF(t[i>>2],28*t[h]+28|0);b=m>>2;t[i>>2]=m;i=t[h];t[h]=i+1|0;t[b+(7*i|0)]=d;t[b+(7*i|0)+1]=0;t[b+(7*i|0)+2]=c;t[b+(7*i|0)+3]=1;l[m+28*i+16|0]=e;t[b+(7*i|0)+5]=f;t[b+(7*i|0)+6]=g}WI.X=1;function RI(b,d){var c=j;j+=4;t[c>>2]=arguments[RI.length];var e=0!=(b&2|0)?fw|0:hm|0;lB(t[Wb>>2],Ht|0,(k=j,j+=8,t[k>>2]=0,t[k+4>>2]=e,k));xB(t[Wb>>2],d,t[c>>2]);if(0!=(b&4|0)){var e=t[Wb>>2],f,g=t[GA>>2];zB||(zB=Xa(256));f=zB;if(g in yB){if(255<yB[g].length){FA(DA)}else{for(var g=yB[g],h=0;h<g.length;h++){l[f+h]=g.charCodeAt(h)}l[f+h]=0}}else{FA(xA)}f=zB;lB(e,Co|0,(k=j,j+=4,t[k>>2]=f,k))}pB(10,t[Wb>>2]);0==(b&1|0)?j=c:(nb(rb),aa("exit(1) called, at "+Error().stack))}function S(b){t[b>>2]=0;l[t[b+8>>2]]=0}function zD(b){var d=b|0,c=t[d>>2];0!=(c|0)&&(c=c-1|0,t[d>>2]=c,l[t[b+8>>2]+c|0]=0)}function XI(b){var d=l[b];if(0==d<<24>>24){return 0}for(var c=0;;){var c=c<<1,e=d&255^(0==(c&256|0)?c:c&254|1),b=b+1|0,d=l[b];if(0==d<<24>>24){break}else{c=e}}return(40503*e|0)>>>9&127}function YI(b,d,c){var e,f,g,h=P();f=(h|0)>>2;var i=h+4|0;e=(h+8|0)>>2;a:for(;;){var m=l[d];do{if(92==m<<24>>24){var n=d+1|0,q=l[n],p=q<<24>>24,s=p-48|0;if(10>s>>>0){if(9>(p-49|0)>>>0){var r=t[c+(s<<3)>>2];-1!=(r|0)&&gD(h,b+r|0,t[c+(s<<3)+4>>2]-r|0)}r=n}else{var u=n,v=q;g=2926}}else{if(0==m<<24>>24){break a}else{u=d,v=m,g=2926}}}while(0);2926==g&&(g=0,10==v<<24>>24||13==v<<24>>24||(m=t[f],(m+1|0)==(t[i>>2]|0)?(R(h),d=l[u],m=t[f]):d=v,l[t[e]+m|0]=d,0!=l[u]<<24>>24&&(d=t[f]+1|0,t[f]=d,l[t[e]+d|0]=0)),r=u);d=r+1|0}b=t[f];if((b+1|0)!=(t[i>>2]|0)){return e=t[e],e=e+b|0,l[e]=0,h}R(h);f=t[f];e=t[e];e=e+f|0;l[e]=0;return h}YI.X=1;function bH(){var b,d=zC(12);b=d>>2;t[b]=0;t[b+1]=0;t[b+2]=0;return d}function AE(b,d){var c,e;e=(b+8|0)>>2;var f=t[e];c=(b+4|0)>>2;if(0==(f|0)){t[c]=0,t[b>>2]=10,f=zC(40),t[e]=f}else{var g=t[c],h=b|0;(g|0)==(t[h>>2]|0)&&(g=g+10|0,t[h>>2]=g,f=jF(f,g<<2),t[e]=f)}e=f;f=t[c];t[c]=f+1|0;t[e+(f<<2)>>2]=d}function fH(b){var d;if(0!=(b|0)){d=(b+8|0)>>2;if(0!=(t[d]|0)){var c;c=(b+4|0)>>2;if(0!=(t[c]|0)){for(var e=b+8|0,f=0;!(Q(t[t[e>>2]+(f<<2)>>2]),t[t[e>>2]+(f<<2)>>2]=0,f=f+1|0,f>>>0>=t[c]>>>0);){}}t[c]=0;vB(t[d]);t[d]=0}t[b>>2]=0;t[b+4>>2]=0;vB(b)}}function ZI(b){var d=bH(),c=t[b>>2];if(0==(c|0)){return d}for(;!(AE(d,PD(c)),b=b+4|0,c=t[b>>2],0==(c|0));){}return d}function zE(b,d){return-1!=(OI(b,d,66)|0)&1}function OI(b,d,c){for(var e,f=b+4|0,b=b+8|0,g=0,h=-1;;){if(-1!=(h|0)){var i=h;e=2989;break}if(g>>>0>=t[f>>2]>>>0){i=-1;e=2988;break}h=0==(ab[c](d,t[t[b>>2]+(g<<2)>>2])|0)?-1:g;g=g+1|0}if(2988==e||2989==e){return i}}function R(b){var d=t[b+4>>2];1073741824>d>>>0&&$I(b,d<<1)}function $I(b,d){var c=b+8|0,e=jF(t[c>>2],d);t[b+4>>2]=d;t[c>>2]=e}function Q(b){if(0!=(b|0)){var d=t[b+8>>2];0!=(d|0)&&vB(d);vB(b)}}function P(){var b,d=zC(12);b=d>>2;t[b]=0;t[b+1]=32;t[b+2]=zC(32);S(d);return d}function U(b,d){var c,e=tb(d);c=(b|0)>>2;var f=t[c],g=e+1|0,h=b+4|0,i=(g+f|0)>>>0<t[h>>2]>>>0;a:do{if(i){var m=f}else{for(;;){R(b);var n=t[c];if((g+n|0)>>>0<t[h>>2]>>>0){m=n;break a}}}}while(0);AB(t[b+8>>2]+m|0,d);t[c]=t[c]+e|0}function BE(b){var d=P();U(d,t[b+8>>2]);return d}function PD(b){var d=P();U(d,b);return d}function gD(b,d,c){var e,f=l[d],g=0!=(c|0)&0!=f<<24>>24;e=(b|0)>>2;var h=t[e],i=b+4|0,m=(h+1|0)==(t[i>>2]|0);a:do{if(g){for(var n=b+8|0,q=d,p=c,s=m,r=f,u=h;;){if(s&&(R(b),r=l[q],u=t[e]),l[t[n>>2]+u|0]=r,0!=l[q]<<24>>24&&(u=t[e]+1|0,t[e]=u,l[t[n>>2]+u|0]=0),p=p-1|0,q=q+1|0,r=l[q],u=t[e],s=(u+1|0)==(t[i>>2]|0),!(0!=(p|0)&0!=r<<24>>24)){var v=s,w=u;break a}}}else{v=m,w=h}}while(0);v&&(R(b),w=t[e]);b=t[(b+8|0)>>2];b=b+w|0;l[b]=0}gD.X=1;function DD(b){var d;d=(b|0)>>2;for(b=b+8|0;0!=(L(l[t[b>>2]+(t[d]-1)|0]<<24>>24)|0);){var c=t[d];if(0==(c|0)){break}c=c-1|0;t[d]=c;l[t[b>>2]+c|0]=0}}function V(b,d){S(b);U(b,d)}function lC(b,d,c,e){t[b+4>>2]>>>0<c>>>0&&$I(b,c);b=t[b+8>>2];if(0==(d|0)){var f,d=b+0|0}else{for(c=0;;){if(l[b+c|0]=rA(l[e+c|0]<<24>>24)&255,c=c+1|0,(c|0)==(d|0)){f=d;break}}d=b+f|0}l[d]=0}function vC(b,d,c){var e=XI(b),f=t[aJ()+(e<<2)>>2];if(0==(f|0)){t[aJ()+(e<<2)>>2]=bJ(b,d,c)}else{for(e=f;;){var g=e|0,e=t[g>>2];if(0==(e|0)){break}}t[g>>2]=bJ(b,d,c)}}function JC(b){t[Lz+4>>2]=t[Lz>>2];t[Lz>>2]=b}function cJ(){return t[Lz+(t[Lz+28>>2]<<4)+44>>2]}function dJ(){return(t[Lz+28>>2]<<4)+Lz+32|0}function aJ(){if(l[Uc]){var b=t[bz>>2];return b}b=zC(512);t[bz>>2]=b;for(var d=0;!(t[b+(d<<2)>>2]=0,d=d+1|0,128==(d|0));){}l[Uc]=1;return b}function bJ(b,d,c){var e,f=zC(16);e=f>>2;t[e]=0;t[e+1]=b;t[e+2]=d;t[e+3]=c;return f}function mC(b,d){var c,e,f=t[aJ()+(XI(b)<<2)>>2];for(c=f>>2;;){if(0==(f|0)){var g=-1;e=3099;break}if((t[c+2]|0)==(d|0)&&0==(qA(b,t[c+1])|0)){break}f=t[c];c=f>>2}return 3099==e?g:g=t[c+3]}function UD(b,d){var c=P();lC(c,t[b>>2],t[b+4>>2],t[b+8>>2]);var e=mC(t[c+8>>2],d);Q(c);return e}function vI(){for(var b,d=T();;){if(-1==(d|0)){var c=-1;b=3117;break}var e=T();if(42==(d|0)&47==(e|0)){c=32;b=3116;break}else{d=e}}if(3117==b||3116==b){return c}}function IC(){var b,d=t[Lz>>2];if(0==(d|0)){var c=d=0}else{t[Lz>>2]=t[Lz+4>>2];t[Lz+4>>2]=0;var e;return d}a:for(;;){b:for(;;){for(var f=T();;){if(9==(f|0)||32==(f|0)){var g=f;b=3150;break b}else{if(-1==(f|0)){var h=0,i=0,m=-1;b=3151;break b}else{if(10==(f|0)){b=3122;break b}else{if(34==(f|0)){b=3123;break b}else{if(39==(f|0)){b=3126;break b}else{if(35==(f|0)){break}else{if(47==(f|0)){b=3127;break b}else{if(92==(f|0)){b=3132;break b}else{if(63!=(f|0)){b=3144;break b}}}}}}}}}var n=T();if(63!=(n|0)){b=3136;break b}var q=T();if(40==(q|0)){g=91;b=3150;break b}else{if(41==(q|0)){h=d;i=c;m=93;b=3151;break b}else{if(60==(q|0)){var p=d,s=c,r=123;break b}else{if(47==(q|0)){f=92;continue}else{if(62==(q|0)){b=3138;break b}else{if(33==(q|0)){b=3139;break b}else{if(39==(q|0)){b=3140;break b}else{if(45==(q|0)){b=3141;break b}else{if(61!=(q|0)){b=3143;break b}}}}}}}}}f=35}if(0==(t[Lz+20>>2]|0)){p=d;s=c;r=35;break}t[Lz+16>>2]=2;t[Lz+20>>2]=0;d=1}b:do{if(3150==b){b=0,p=d,s=c,r=g}else{if(3151==b){b=0,p=h,s=i,r=m}else{if(3136==b){b=0,W(n),p=d,s=c,r=63}else{if(3144==b){b=0;do{if(64==(f|0)&0!=(t[Lz+12>>2]|0)&&34==(T()|0)){t[Lz+20>>2]=0;eJ(1);p=d;s=c;r=211;break b}}while(0);t[Lz+20>>2]=0;if(0==(d|0)){p=0,s=c,r=f}else{var c=f,u=cJ(),v=t[Lz+16>>2];if(2==(v|0)){c=fJ(c)}else{if(3==(v|0)){u=ba;c=48!=(c|0)&1;u=ba;v=cJ();u=t[Lz+28>>2];if(19>u>>>0){t[Lz+28>>2]=u+1|0;u=dJ()>>2;t[u]=v;var w=t[Lz+8>>2];t[u+1]=w;t[u+2]=c;c=(0==(v|0)?0!=(t[Vz>>2]|c|0)?0:0!=(w|0)?1:0==(t[oy+120>>2]|0):1)&1;t[u+3]=c}else{c=0}u=c;t[Lz+16>>2]=0}else{if(4==(v|0)){c:{if(0!=(pA(c)|0)||126==(c|0)||95==(c|0)||36==(c|0)){if(gJ(c),0==(qA(t[t[Lz+24>>2]+8>>2],Ys|0)|0)){for(;;){var C=T();if(32!=(C|0)){break}}if(0==(pA(C)|0)&&!(126==(C|0)||95==(C|0)||36==(C|0))){t[Lz+16>>2]=0;break c}gJ(C);hJ()}}t[Lz+16>>2]=0}}else{1==(v|0)?iJ(c):5==(v|0)&&iJ(c)}}c=u}continue a}}else{if(3122==b){b=0,t[Lz+20>>2]=1,p=0!=(d|0)&0==(c|0)?0:d,s=c,r=10}else{if(3123==b){b=0,t[Lz+20>>2]=0,eJ(0),p=d,s=c,r=211}else{if(3143==b){b=0,W(q),JC(63),p=d,s=c,r=63}else{if(3126==b){b=0;t[Lz+20>>2]=0;p=ba;r=s=0;c:for(;;){if(0==(s|0)){for(s=r;;){var A=T();if(-1==(A|0)){p=3180;break c}var I=s+1|0;if(10==(A|0)){p=3174;break c}else{if(39==(A|0)){p=3183;break c}else{if(92!=(A|0)){break}}}T();s=I}s=0==(s|0)&&0!=(bC(Pe|0,nA(A),5)|0)?A:0;r=I}else{for(u=r;;){var M=T();if(-1==(M|0)){p=3185;break c}v=u+1|0;if(10==(M|0)){p=3174;break c}else{if(39==(M|0)){p=3184;break c}else{if(92==(M|0)){T();u=v;continue}}}if(0==(u|0)&&0!=(bC(Pe|0,nA(M),5)|0)){s=M;r=v;continue c}if(0==(oA(M)|0)){p=3178;break c}else{u=v}}}}3178==p?W(M):3174==p&&W(10);p=d;s=c;r=195}else{if(3127==b){if(b=0,p=T(),42==(p|0)?p=1:47==(p|0)?p=2:(W(p),p=0),2==(p|0)){for(;;){var B=T();if(-1==(B|0)||10==(B|0)){break}else{if(92!=(B|0)){continue}}T()}r=B;10!=(r|0)?(p=d,s=c):(W(10),p=d,s=c,r=10)}else{1==(p|0)?(p=d,s=c,r=vI()):(t[Lz+20>>2]=0,p=d,s=c,r=47)}}else{3138==b?(b=0,p=d,s=c,r=125):3139==b?(b=0,p=d,s=c,r=124):3140==b?(b=0,p=d,s=c,r=94):3141==b?(b=0,p=d,s=c,r=126):3132==b&&(b=0,p=T(),10!=(p|0)&&(63==(p|0)?JC(63):W(p)),p=d,s=c,r=92)}}}}}}}}}}while(0);if(0==(p|s|0)){e=r;break}else{d=p,c=s}}return e}IC.X=1;function eJ(b){if(0!=(b|0)){for(;!(b=T(),-1==(b|0)||34==(b|0));){}}else{for(;;){b=T();if(-1==(b|0)||34==(b|0)){break}else{if(92!=(b|0)){continue}}T()}}}function iJ(b){var d;if(0==(pA(b)|0)){if(126==(b|0)||95==(b|0)||36==(b|0)){d=3203}}else{d=3203}3203==d&&(gJ(b),0==(cJ()|0)&&hJ());t[Lz+16>>2]=0}function fJ(b){var d=j;j+=12;for(var c=d|0,e,f=b,b=0;;){if(9<=b>>>0){e=3274;break}if(0!=(b|0)){var g=T();if(-1==(g|0)){break}if(0==(pA(g)|0)){break}else{f=g}}l[c+b|0]=f&255;b=b+1|0}3274!=e&&W(g);e=c+b|0;l[e]=0;e=0==(qA(c,zr|0)|0);a:do{if(e){t[Lz+16>>2]=1,g=0}else{if(0==(qA(c,zo|0)|0)){t[Lz+16>>2]=5,g=0}else{if(0==(N(c,im|0,2)|0)){t[Lz+16>>2]=3,g=0}else{do{if(0!=(qA(c,dk|0)|0)&&0!=(qA(c,ti|0)|0)){if(0==(qA(c,ch|0)|0)){c=t[Lz+28>>2];0!=(c|0)&&(t[Lz+28>>2]=c-1|0);c=cJ();t[Lz+16>>2]=0;g=c;break a}t[Lz+16>>2]=0==(qA(c,Of|0)|0)?4:0;g=0;break a}}while(0);g=jJ();t[Lz+(t[Lz+28>>2]<<4)+44>>2]=g;0==(g|0)&&0==(qA(c,ti|0)|0)&&0==(t[Vz>>2]|0)&&(b=dJ(),t[b+8>>2]=(0==(t[b+4>>2]|0)?0!=(t[Lz+8>>2]|0):1)&1);t[Lz+16>>2]=0}}}}while(0);j=d;return g}fJ.X=1;function gJ(b){var d=t[Lz+24>>2],c,e;S(d);e=(d|0)>>2;var f=d+4|0;for(c=(d+8|0)>>2;;){var g=t[e];(g+1|0)==(t[f>>2]|0)&&(R(d),g=t[e]);l[t[c]+g|0]=b&255;0!=(b|0)&&(b=t[e]+1|0,t[e]=b,l[t[c]+b|0]=0);g=T();if(-1==(g|0)){break}if(0!=(oA(g)|0)){b=g}else{if(95==(g|0)||36==(g|0)){b=g}else{break}}}W(g);b=t[e];(b+1|0)!=(t[f>>2]|0)?(c=t[c],c=c+b|0):(R(d),d=t[e],c=t[c],c=c+d|0);l[c]=0}function hJ(){var b=t[t[Lz+24>>2]+8>>2],d,c=j;j+=80;d=c>>2;var e=0==(t[K+52>>2]|0);0!=(t[Tz+16>>2]|0)&&0!=(t[oy+8>>2]|0)|e^1&&(sC(c,b),t[d]=2!=(t[oy+76>>2]|0)&1,t[d+4]=e&1,t[d+6]=1,t[d+9]=Zv|0,l[c+40|0]=100,tC(c));j=c}function W(b){t[K+28>>2]=b}function jJ(){var b;b=dJ()>>2;0==(t[Lz+8>>2]|0)|0!=(t[Vz>>2]|0)||(t[b+1]=1);if(0!=(t[b]|0)){return 1}if(0==(t[b+2]|0)){return 0}b=0!=(t[b+1]|0);return b&1}function kJ(b){var d,c;d=t[K+40>>2];0!=(d|0)&&Q(d);t[K+40>>2]=b;d=t[K+44>>2];0!=(d|0)&&vB(d);d=(b+8|0)>>2;var e=t[d];if(0==(t[oy+144>>2]|0)){c=3323}else{if(0!=(47==(l[e]<<24>>24|0)&1|0)){c=3323}else{var f;f=t[NaN>>2];var g,h;var i;if(0==(47==(l[e]<<24>>24|0)&1|0)){i=tb(0);var m=tb(e)+i|0,n=zC(m+1|0);AB(n,0);AB(n+i|0,e);l[n+m|0]=0;i=n}else{i=HI(e)}m=mA(i,47);c:for(;;){var q=m+1|0,p=m+2|0,n=m+3|0;if(0==(m|0)){break}for(;;){if(0==l[m]<<24>>24){break c}if(46!=l[q]<<24>>24){break}var s=l[p];if(46==s<<24>>24){h=2791;break}else{if(!(47==s<<24>>24||0==s<<24>>24)){break}}AB(m,p)}do{if(2791==h&&(h=0,p=l[n],47==p<<24>>24||0==p<<24>>24)){for(q=m;;){q=q-1|0;if(q>>>0<i>>>0){var r=m;break}if(0!=(47==(l[q]<<24>>24|0)&1|0)){r=q;break}}AB(r,n);m=r;continue c}}while(0);m=mA(q,47)}h=0!=l[i]<<24>>24?i:HI(dh|0);r=f;for(f=h;;){if(l[f]<<24>>24==l[r]<<24>>24){r=r+1|0,f=f+1|0}else{var u=r,v=f;break}}for(;;){if((v|0)==(h|0)){var w=h;g=2824;break}r=v-1|0;u=u-1|0;if(47==l[r]<<24>>24){var C=0,A=u;break}else{v=r}}if(2824!=g){for(;!(g=mA(A+1|0,47),0==(g|0));){C=C+1|0,A=g}g=zC(3*C+tb(v)+1|0);l[g]=0;w=0<(C|0);b:do{if(w){for(A=C;;){if(A=A-1|0,u=g+tb(g)|0,Fa=3092014,l[u]=Fa&255,Fa>>=8,l[u+1]=Fa&255,Fa>>=8,l[u+2]=Fa&255,Fa>>=8,l[u+3]=Fa&255,0>=(A|0)){break b}}}}while(0);C=tb(g);w=0;do{l[g+C+w]=l[v+w],w++}while(0!=l[v+(w-1)]);vB(h);w=g}f=w}}3323==c&&(f=HI(e));t[K+44>>2]=f;b=t[b>>2];b>>>0>t[NaN>>2]>>>0&&(t[NaN>>2]=b);b=t[oy+104>>2];b=0==(b|0)?0:-1!=(OI(b,KI(t[d]),186)|0)&1;t[K+52>>2]=b;d=II(t[d]);t[K+56>>2]=d}function T(){var b=t[K+28>>2];if(0!=(b|0)){t[K+28>>2]=0;var d;return b}for(var c=t[K+12>>2];;){if(0==(c|0)){b=lJ(),0==(b|0)?b=t[K+12>>2]:(b=t[b+8>>2],t[K+12>>2]=b),c=(0==(b|0))<<31>>31}else{b=c+1|0;t[K+12>>2]=b;var c=l[c],e=c&255;0!=c<<24>>24?c=e:(t[K+12>>2]=0,c=e,b=0)}if(0==(c|0)){c=b}else{d=c;break}}return d}function lJ(){var b,d=t[K+8>>2];0==(d|0)&&(d=P(),t[K+8>>2]=d);S(d);a:for(;;){for(var c,d=ba;;){c=XB(t[K+16>>2]);if(0==(t[K+36>>2]|0)|-1==(c|0)){var e=c;break}t[K+24>>2]=t[Ox>>2];t[K+36>>2]=0;t[K+20>>2]=t[K+20>>2]+1|0;t[K+48>>2]=t[K+48>>2]+1|0;if(!(35==(c|0)&0!=(t[oy+152>>2]|0))){e=c;break}if(0==(mJ()|0)){d=3399;break}}3399==d&&(oB(t[K+16>>2],Ox),e=XB(t[K+16>>2]));-1==(e|0)?(t[K+32>>2]=1,d=-1):10==(e|0)?(t[K+36>>2]=1,nB(t[K+16>>2],Ox),d=10):13==(e|0)?(d=XB(t[K+16>>2]),10==(d|0)?(t[K+36>>2]=1,nB(t[K+16>>2],Ox),d=10):(YB(d),d=13)):d=e;c=d;d=-1!=(c|0);do{if(d){var f=t[K+8>>2],g=t[f>>2];(g+1|0)==(t[f+4>>2]|0)&&(R(f),f=g=t[K+8>>2],g=t[g>>2]);l[t[f+8>>2]+g|0]=c&255;if(0!=(c|0)){if(f=t[K+8>>2]|0,g=t[f>>2]+1|0,t[f>>2]=g,l[t[t[K+8>>2]+8>>2]+g|0]=0,10==(c|0)){b=3357;break a}else{-1==(c|0)&&(b=3358)}}}else{b=3358}}while(0);if(3358==b&&(b=0,c=t[K+8>>2],f=t[c>>2],0!=(f|0))){var h=c,i=f;break}if(!d){var m=0;b=3367;break}}if(3357==b){h=i=t[K+8>>2],i=t[i>>2]}else{if(3367==b){return m}}(i+1|0)==(t[h+4>>2]|0)&&(R(h),h=i=t[K+8>>2],i=t[i>>2]);l[t[h+8>>2]+i|0]=0;h=t[K+8>>2];if(0==(t[h>>2]|0)){return h}b=t[K+56>>2];if(!(-2==(b|0)|(t[Zx>>2]|0)<(b|0))&&(e=t[Yx>>2],i=(b<<3)+e+4|0,0!=(t[i>>2]|0))){b=(b<<3)+e|0;for(e=0;;){c=h;d=t[b>>2]+28*e|0;m=j;j+=80;for(var n=c+8|0,f=m|0,g=TB(t[n>>2]),q=SB[t[d>>2]].exec(g),p=0;10>p;p++){var s=-1,r=-1;q&&p<q.length&&(s=g.indexOf(q[p]),r=s+q[p].length);t[f+8*p>>2]=s;t[f+(8*p+4)>>2]=r}if(0==((q?0:1)|0)){if(g=t[d+4>>2],1==(g|0)){g=j;j+=80;for(n=0;10>(n|0);){q=t[f+(n<<3)>>2];if(-1==(q|0)){break}t[g+(n<<3)>>2]=q;t[g+(n<<3)+4>>2]=t[f+(n<<3)+4>>2]-q|0;n=n+1|0}ab[t[d+8>>2]](t[c+8>>2],g|0,n);j=g}else{if(0==(g|0)){c=j;g=d+8|0;f=YI(t[n>>2],t[g>>2],f);q=n=ba;q=(f|0)>>2;for(n=(f+8|0)>>2;0!=(L(l[t[n]]<<24>>24)|0);){p=t[q];if(0==(p|0)){break}if(1<p>>>0){for(p=1;;){var u=t[n];l[u+(p-1)|0]=l[u+p|0];p=p+1|0;u=t[q];if(p>>>0>=u>>>0){break}}p=u-1|0}else{p=0}t[q]=p;l[t[n]+p|0]=0}DD(f);0==(t[f>>2]|0)?(d=t[t[K+40>>2]+8>>2],n=t[K+20>>2],g=t[g>>2],RI(2,St|0,(k=j,j+=12,t[k>>2]=d,t[k+4>>2]=n,t[k+8>>2]=g,k))):(g=f,d=d+12|0,n=j,j+=80,0!=(t[d>>2]|0)&&(sC(n,t[g+8>>2]),l[n+40|0]=l[d+4|0],t[n+36>>2]=t[d+8>>2],tC(n)),j=n);Q(f);j=c}}}j=m;e=e+1|0;if(e>>>0>=t[i>>2]>>>0){break}}}return m=t[K+8>>2]}lJ.X=1;function uE(b){for(;;){var d=T();if(-1==(d|0)|(d|0)==(b|0)){break}}}function eC(){var b=lJ();if(0==(b|0)){return 0}var d=t[b+8>>2],c;c=(b|0)>>2;b=t[b+8>>2]+(t[c]-1)|0;10==l[b]<<24>>24&&(l[b]=0,t[c]=t[c]-1|0);return d}function MI(b,d){var c,e=j;j+=4;var f;S(b);if(0==(d|0)){return RI(1,ck|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k)),j=e,0}c=(b+8|0)>>2;for(var g=b+4|0;;){var h=t[c]+(t[g>>2]-2)|0;nB(d,e);l[h]=0;var i;a:{i=t[c];var m=t[g>>2],n=d;if(JA[n]){var q=JA[n];if(q.error||q.c){i=0}else{for(var p=ba,s=0;s<m-1&&10!=p;s++){p=WB(n);if(-1==p){if(q.error){i=0;break a}if(q.c){break}}l[i+s]=p}l[i+s]=0}}else{i=0}}if(0==(i|0)){f=3380;break}h=l[h];if(0==h<<24>>24||10==h<<24>>24||13==h<<24>>24){break}R(b);oB(d,e)}if(3380==f){if(0!=(cB(d)|0)){return j=e,0}RI(5,si|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));j=e;return 0}t[b>>2]=tb(t[b+8>>2]);h=t[c];c=(b|0)>>2;m=t[c];f=h+(m-1)|0;g=l[f];if(13==g<<24>>24){return l[f]=10,j=e,i}h=h+(m-2)|0;if(!(13==l[h]<<24>>24&10==g<<24>>24)){return j=e,i}l[h]=10;l[f]=0;t[c]=t[c]-1|0;j=e;return i}MI.X=1;function mJ(){var b,d=j;j+=80;var c;b=d>>2;var e=nJ();if(10>(e-48|0)>>>0){YB(e),c=3419}else{if(108!=(e|0)){var f=0}else{105!=(XB(t[K+16>>2])|0)?f=0:110!=(XB(t[K+16>>2])|0)?f=0:101!=(XB(t[K+16>>2])|0)?f=0:(e=XB(t[K+16>>2]),32==(e|0)||9==(e|0)?c=3419:f=0)}}if(3419==c){var g;a:{c=0;for(f=nJ();;){if(-1==(f|0)){g=3434;break}e=f-48|0;if(10<=e>>>0){g=3437;break}c=e+10*c|0;f=XB(t[K+16>>2])}if(3437==g){if(YB(f),32==(f|0)||9==(f|0)){g=c;break a}}else{3434==g&&YB(-1)}g=0}if(0==(g|0)){f=0}else{c=oJ();f=c|0;if(0==(t[f>>2]|0)){t[K+48>>2]=g-1|0}else{e=c+8|0;if(-2==(II(t[e>>2])|0)){e=0}else{var e=t[e>>2],h=t[K+4>>2];if(0!=(47==(l[e]<<24>>24|0)&1|0)|0==(h|0)){e=BE(c)}else{var i=t[h+8>>2],m,h=P();m=47==(l[i+(tb(i)-1)|0]<<24>>24|0)&1;V(h,i);if(0==(m|0)){m=(h|0)>>2;var i=t[m],n=h+4|0;if((i+1|0)==(t[n>>2]|0)){R(h);var q=t[m]}else{q=i}i=(h+8|0)>>2;l[t[i]+q|0]=47;q=t[m]+1|0;t[m]=q;l[t[i]+q|0]=0;q=t[m];(q+1|0)==(t[n>>2]|0)?(R(h),m=t[m]):m=q;l[t[i]+m|0]=0}U(h,e);e=h}kJ(e);e=1}0!=(e|0)&&(t[K+48>>2]=g-1|0)}0!=(t[oy>>2]|0)&&0!=(t[f>>2]|0)&1==(g|0)&&(sC(d,kH(t[c+8>>2])),t[b+5]=1,t[b]=1,t[b+1]=1,t[b+9]=Ne|0,l[d+40|0]=70,tC(d));Q(c);f=1}}j=d;return f}mJ.X=1;function nJ(){for(;;){var b=XB(t[K+16>>2]);if(!(32==(b|0)||9==(b|0))){break}}return b}function oJ(){var b,d,c=P(),e=nJ(),f=34==(e|0);a:do{if(f){var g=c|0;b=g>>2;for(var h=c+4|0,i=c+8|0,m=XB(t[K+16>>2]);;){if(-1==(m|0)||34==(m|0)){var n=g,q=h,p=i;break a}else{if(10==(m|0)){var s=g,r=h,u=i;d=3457;break a}}var v=t[b];(v+1|0)==(t[h>>2]|0)&&(R(c),v=t[b]);l[t[i>>2]+v|0]=m&255;0!=(m|0)&&(m=t[b]+1|0,t[b]=m,l[t[i>>2]+m|0]=0);m=XB(t[K+16>>2])}}else{g=c|0;b=g>>2;h=c+4|0;i=c+8|0;for(m=e;;){if(-1==(m|0)||9==(m|0)||32==(m|0)){n=g;q=h;p=i;break a}else{if(10==(m|0)){s=g;r=h;u=i;d=3457;break a}}v=t[b];(v+1|0)==(t[h>>2]|0)&&(R(c),v=t[b]);l[t[i>>2]+v|0]=m&255;0!=(m|0)&&(m=t[b]+1|0,t[b]=m,l[t[i>>2]+m|0]=0);m=XB(t[K+16>>2])}}}while(0);3457==d&&(YB(10),n=s,q=r,p=u);d=t[n>>2];if((d+1|0)!=(t[q>>2]|0)){return p=t[p>>2],p=p+d|0,l[p]=0,c}R(c);n=t[n>>2];p=t[p>>2];p=p+n|0;l[p]=0;return c}oJ.X=1;function pJ(){if(!l[Hc]){l[Hc]=1;QI();var b=j,d=bH();t[ny>>2]=d;KC(st|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));var d=j,c=ZI(az|0);t[oy+104>>2]=c;if(0!=(t[oy+88>>2]|0)){mB(am|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));var e=t[oy+104>>2],c=j,f=e+4|0;if(0!=(t[f>>2]|0)){for(var e=e+8|0,g=0;;){var h=0!=(g|0)?Cr|0:hm|0,i=t[t[t[e>>2]+(g<<2)>>2]+8>>2];mB(cw|0,(k=j,j+=8,t[k>>2]=h,t[k+4>>2]=i,k));g=g+1|0;if(g>>>0>=t[f>>2]>>>0){break}}}j=c;qB(10,t[Ob>>2])}j=d;KC(Ss|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));d=j;if(0!=(t[Dy>>2]|0)){for(c=0;;){f=FI(c);KC(vi|0,(k=j,j+=4,t[k>>2]=f,k));f=c;e=j;h=t[t[Cy>>2]+(f<<2)>>2];i=h+44|0;g=t[i>>2];0!=(g|0)&&fH(g);var g=h+48|0,m=t[g>>2];0!=(m|0)&&fH(m);m=t[h+16>>2];m=0==(m|0)?bH():ZI(m);t[i>>2]=m;h=t[h+12>>2];h=0==(h|0)?bH():ZI(h);t[g>>2]=h;0!=(t[oy+88>>2]|0)&&PI(f);KC(Jq|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));j=e;c=c+1|0;if(c>>>0>=t[Dy>>2]>>>0){break}}}j=d;KC(xs|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));SI(fs|0);SI(Lr|0);SI(mr|0);SI(Xq|0);SI(Kq|0);SI(wq|0);SI(jq|0);SI(Rp|0);SI(Bp|0);SI(mp|0);SI($o|0);SI(Ko|0);SI(ro|0);SI(ho|0);SI(Zn|0);SI(On|0);SI(zn|0);SI(on|0);SI(dn|0);j=b}}function qJ(b){pJ();return FI(II(b))}a._getLanguage=qJ;function rJ(b){var d=j,c=t[oy+128>>2],c=-1==(c|0)?II(b):c;if(-2==(c|0)){KC(gs|0,(k=j,j+=4,t[k>>2]=b,k))}else{if(0==(t[t[t[Cy>>2]+(c<<2)>>2]+40>>2]|0)){KC(Mr|0,(k=j,j+=4,t[k>>2]=b,k))}else{0!=(t[oy+136>>2]|0)&&ba();var e=j;j+=4;var f=t[NaN>>2];nB(t[NaN>>2],e);var g=0,h=0;a:for(;;){var i=g,g=h;b:for(;;){for(;;){var m=g+1|0;var h=b,n=c,g=m,q;var p=h,s=n;q=j;var r=t[K+16>>2];0!=(r|0)&&(uB(r),t[K+16>>2]=0);r=tB(p,Ns|0);t[K+16>>2]=r;if(0==(r|0)){RI(6,Xv|0,(k=j,j+=4,t[k>>2]=p,k)),p=0}else{var r=kH(p),u=t[K>>2];0!=(u|0)&&Q(u);u=PD(p);t[K>>2]=u;u=t[K+4>>2];0!=(u|0)&&Q(u);(r|0)==(p|0)?t[K+4>>2]=0:(u=P(),t[K+4>>2]=u,r=r+(p^-1)|0,S(u),gD(u,p,r));nB(t[K+16>>2],Ox);nB(t[K+16>>2],K+24|0);t[K+12>>2]=0;t[K+20>>2]=0;t[K+32>>2]=0;t[K+36>>2]=1;r=t[K+8>>2];0!=(r|0)&&S(r);kJ(PD(p));t[K+48>>2]=0;s=FI(s);r=0!=(t[K+52>>2]|0)?yo|0:hm|0;KC(wr|0,(k=j,j+=12,t[k>>2]=p,t[k+4>>2]=s,t[k+8>>2]=r,k));p=1}j=q;q=p;0==(q|0)?g=0:(n=t[t[Cy>>2]+(n<<2)>>2],0!=(t[oy+72>>2]|0)&&ba(),q=ba,p=j,j+=80,q=p>>2,0!=(t[oy>>2]|0)&&(sC(p,kH(h)),t[q+5]=1,t[q]=1,t[q+1]=1,t[q+9]=Ne|0,l[p+40|0]=70,tC(p)),j=p,h=t[n+24>>2],0==(h|0)?(h=t[n+28>>2],g=0==(h|0)?0:ab[h](g)):(ab[h](),g=0),0!=(t[oy+72>>2]|0)&&ba(t[K+44>>2]),h=t[K+16>>2],0!=(h|0)&&(0!=(t[oy+148>>2]|0)&&(LI(t[t[K>>2]+8>>2]),h=t[K+16>>2]),uB(h),t[K+16>>2]=0));if(0==(g|0)){break a}else{if(2==(g|0)){break b}else{if(1==(g|0)){break}else{g=m}}}}oB(t[NaN>>2],e);t[NaN>>2]=f;i=1;g=m}nB(t[NaN>>2],e);g=i;h=m;f=t[NaN>>2]}j=e;0!=(t[oy+136>>2]|0)&&ba(i)}}j=d;RB&&RB(Na(b))}function sJ(b){var d=j;pJ();if(4294967293<II(b)>>>0){mB(Ks|0,(k=j,j+=4,t[k>>2]=b,k))}else{var c=tB(b,Wv|0);if(0==(c|0)){var c=Na(b),e=Na(b),f=e.lastIndexOf("/");VA(e.substr(0,f),e.substr(f+1),c,ca,ca,(function(){ab[38](b)}),(function(){ab[82](b)}))}else{uB(c),rJ(b)}}j=d}a._parseURL=sJ;function tC(b){var b=b>>2,d=t[b+9],c=t[b+1],e=t[b+7],f=t[b+3];QB&&QB(Na(t[b+8]),Na(d),c,Na(e),Na(f))}function sC(b,d){for(var c=b>>2,e=b>>2,f=e+20;e<f;e++){t[e]=0}t[c]=1==(t[oy+76>>2]|0)&1;t[c+1]=t[K+48>>2];t[c+3]=FI(t[K+56>>2]);t[c+2]=t[K+24>>2];t[c+7]=t[K+44>>2];t[c+8]=d}function Xa(b){do{if(245>b>>>0){var d=11>b>>>0?16:b+11&-8,c=d>>>3,e=t[D>>2],f=e>>>(c>>>0);if(0!=(f&3|0)){var g=(f&1^1)+c|0,h=g<<1,d=(h<<2)+D+40|0,c=(h+2<<2)+D+40|0,b=t[c>>2],h=b+8|0,f=t[h>>2];(d|0)==(f|0)?t[D>>2]=e&(1<<g^-1):f>>>0<t[D+16>>2]>>>0?O():(t[c>>2]=f,t[f+12>>2]=d);g<<=3;t[b+4>>2]=g|3;g=b+(g|4)|0;t[g>>2]|=1;return h}if(d>>>0>t[D+8>>2]>>>0){if(0==(f|0)){if(0==(t[D+4>>2]|0)){e=d;break}h=tJ(d);if(0==(h|0)){e=d;break}return h}var b=2<<c,b=f<<c&(b|-b),c=(b&-b)-1|0,b=c>>>12&16,f=c>>>(b>>>0),c=f>>>5&8,i=f>>>(c>>>0),f=i>>>2&4,m=i>>>(f>>>0),i=m>>>1&2,m=m>>>(i>>>0),n=m>>>1&1,f=(c|b|f|i|n)+(m>>>(n>>>0))|0,b=f<<1,i=(b<<2)+D+40|0,m=(b+2<<2)+D+40|0,c=t[m>>2],b=c+8|0,n=t[b>>2];(i|0)==(n|0)?t[D>>2]=e&(1<<f^-1):n>>>0<t[D+16>>2]>>>0?O():(t[m>>2]=n,t[n+12>>2]=i);f<<=3;e=f-d|0;t[c+4>>2]=d|3;i=c;c=i+d|0;t[i+(d|4)>>2]=e|1;t[i+f>>2]=e;n=t[D+8>>2];0!=(n|0)&&(d=t[D+20>>2],i=n>>>2&1073741822,f=(i<<2)+D+40|0,m=t[D>>2],n=1<<(n>>>3),0==(m&n|0)?(t[D>>2]=m|n,h=f,g=(i+2<<2)+D+40|0):(i=(i+2<<2)+D+40|0,m=t[i>>2],m>>>0<t[D+16>>2]>>>0?O():(h=m,g=i)),t[g>>2]=d,t[h+12>>2]=d,t[d+8>>2]=h,t[d+12>>2]=f);t[D+8>>2]=e;t[D+20>>2]=c;return h=b}e=d}else{if(4294967231<b>>>0){e=-1}else{if(e=b+11&-8,0!=(t[D+4>>2]|0)&&(d=uJ(e),0!=(d|0))){return h=d}}}}while(0);g=t[D+8>>2];e>>>0>g>>>0?(h=t[D+12>>2],e>>>0<h>>>0?(h=h-e|0,t[D+12>>2]=h,g=t[D+24>>2],t[D+24>>2]=g+e|0,t[e+(g+4)>>2]=h|1,t[g+4>>2]=e|3,h=g+8|0):h=vJ(e)):(d=g-e|0,h=t[D+20>>2],15<d>>>0?(t[D+20>>2]=h+e|0,t[D+8>>2]=d,t[e+(h+4)>>2]=d|1,t[h+g>>2]=d,t[h+4>>2]=e|3):(t[D+8>>2]=0,t[D+20>>2]=0,t[h+4>>2]=g|3,g=g+(h+4)|0,t[g>>2]|=1),h=h+8|0);return h}Xa.X=1;function tJ(b){var d,c,e=t[D+4>>2],f=(e&-e)-1|0,e=f>>>12&16,g=f>>>(e>>>0),f=g>>>5&8;c=g>>>(f>>>0);var g=c>>>2&4,h=c>>>(g>>>0);c=h>>>1&2;var h=h>>>(c>>>0),i=h>>>1&1,e=g=f=t[D+((f|e|g|c|i)+(h>>>(i>>>0))<<2)+304>>2];c=e>>2;for(f=(t[f+4>>2]&-8)-b|0;;){h=t[g+16>>2];if(0==(h|0)){if(g=t[g+20>>2],0==(g|0)){break}else{c=g}}else{c=h}h=(t[c+4>>2]&-8)-b|0;i=h>>>0<f>>>0;g=c;e=i?c:e;c=e>>2;f=i?h:f}var h=e,m=t[D+16>>2];h>>>0<m>>>0&&O();g=h+b|0;h>>>0<g>>>0||O();var i=t[c+6],n=t[c+3],q=(n|0)==(e|0);a:do{if(q){var p=e+20|0,s=t[p>>2];do{if(0==(s|0)){var r=e+16|0,u=t[r>>2];if(0==(u|0)){var v=0;d=v>>2;break a}}else{r=p,u=s}}while(0);for(;;){if(p=u+20|0,s=t[p>>2],0!=(s|0)){r=p,u=s}else{if(p=u+16|0,s=t[p>>2],0==(s|0)){break}else{r=p,u=s}}}r>>>0<m>>>0?O():(t[r>>2]=0,v=u,d=v>>2)}else{r=t[c+2],r>>>0<m>>>0?O():(t[r+12>>2]=n,t[n+8>>2]=r,v=n,d=v>>2)}}while(0);m=0==(i|0);a:do{if(!m){n=e+28|0;q=(t[n>>2]<<2)+D+304|0;do{if((e|0)==(t[q>>2]|0)){if(t[q>>2]=v,0==(v|0)){t[D+4>>2]&=1<<t[n>>2]^-1;break a}}else{if(i>>>0<t[D+16>>2]>>>0&&O(),r=i+16|0,(t[r>>2]|0)==(e|0)?t[r>>2]=v:t[i+20>>2]=v,0==(v|0)){break a}}}while(0);v>>>0<t[D+16>>2]>>>0&&O();t[d+6]=i;n=t[c+4];0!=(n|0)&&(n>>>0<t[D+16>>2]>>>0?O():(t[d+4]=n,t[n+24>>2]=v));n=t[c+5];0!=(n|0)&&(n>>>0<t[D+16>>2]>>>0?O():(t[d+5]=n,t[n+24>>2]=v))}}while(0);if(16>f>>>0){var w=f+b|0;t[c+1]=w|3;w=w+(h+4)|0;t[w>>2]|=1;return w=e+8|0}t[c+1]=b|3;t[b+(h+4)>>2]=f|1;t[h+f+b>>2]=f;h=t[D+8>>2];if(0!=(h|0)){b=t[D+20>>2];v=h>>>2&1073741822;d=(v<<2)+D+40|0;c=t[D>>2];h=1<<(h>>>3);if(0==(c&h|0)){t[D>>2]=c|h;var w=d,C=(v+2<<2)+D+40|0}else{v=(v+2<<2)+D+40|0,c=t[v>>2],c>>>0<t[D+16>>2]>>>0?O():(w=c,C=v)}t[C>>2]=b;t[w+12>>2]=b;t[b+8>>2]=w;t[b+12>>2]=d}t[D+8>>2]=f;t[D+20>>2]=g;return w=e+8|0}tJ.X=1;function vJ(b){var d,c;0==(t[zc>>2]|0)&&wJ();var e=0==(t[D+440>>2]&4|0);a:do{if(e){var f=t[D+24>>2];if(0==(f|0)){c=3592}else{if(f=xJ(f),0==(f|0)){c=3592}else{var g=t[zc+8>>2],g=b+47-t[D+12>>2]+g&-g;if(2147483647>g>>>0){c=$B(g);var h=(c|0)==(t[f>>2]+t[f+4>>2]|0);d=h?c:-1;var h=h?g:0,i=g,m=c;c=3599}else{var n=0}}}if(3592==c){if(f=$B(0),-1==(f|0)){n=0}else{var g=t[zc+8>>2],g=g+(b+47)&-g,q=f,p=t[zc+4>>2],s=p-1|0,g=0==(s&q|0)?g:g-q+(s+q&-p)|0;2147483647>g>>>0?(c=$B(g),d=(h=(c|0)==(f|0))?f:-1,h=h?g:0,i=g,m=c,c=3599):n=0}}b:do{if(3599==c){c=-i|0;if(-1!=(d|0)){var r=h,u=d;c=3612;break a}do{if(-1!=(m|0)&2147483647>i>>>0){if(i>>>0<(b+48|0)>>>0){if(n=t[zc+8>>2],n=b+47-i+n&-n,2147483647>n>>>0){if(-1==($B(n)|0)){$B(c);n=h;break b}else{n=n+i|0}}else{n=i}}else{n=i}}else{n=i}}while(0);if(-1!=(m|0)){r=n;u=m;c=3612;break a}t[D+440>>2]|=4;var v=h;c=3609;break a}}while(0);t[D+440>>2]|=4;v=n}else{v=0}c=3609}while(0);3609==c&&(e=t[zc+8>>2],e=e+(b+47)&-e,2147483647>e>>>0&&(e=$B(e),d=$B(0),-1!=(d|0)&-1!=(e|0)&e>>>0<d>>>0&&(d=d-e|0,e=(h=d>>>0>(b+40|0)>>>0)?e:-1,-1!=(e|0)&&(r=h?d:v,u=e,c=3612))));do{if(3612==c){v=t[D+432>>2]+r|0;t[D+432>>2]=v;v>>>0>t[D+436>>2]>>>0&&(t[D+436>>2]=v);v=t[D+24>>2];e=0==(v|0);a:do{if(e){d=t[D+16>>2];0==(d|0)|u>>>0<d>>>0&&(t[D+16>>2]=u);t[D+444>>2]=u;t[D+448>>2]=r;t[D+456>>2]=0;t[D+36>>2]=t[zc>>2];t[D+32>>2]=-1;for(d=0;!(h=d<<1,i=(h<<2)+D+40|0,t[D+(h+3<<2)+40>>2]=i,t[D+(h+2<<2)+40>>2]=i,d=d+1|0,32==(d|0));){}yJ(u,r-40|0)}else{h=D+444|0;for(d=h>>2;0!=(h|0);){var w=t[d],C=h+4|0,A=t[C>>2];if((u|0)==(w+A|0)){c=3621;break}h=t[d+2];d=h>>2}do{if(3621==c&&0==(t[d+3]&8|0)&&(h=v,h>>>0>=w>>>0&h>>>0<u>>>0)){t[C>>2]=A+r|0;yJ(t[D+24>>2],t[D+12>>2]+r|0);break a}}while(0);u>>>0<t[D+16>>2]>>>0&&(t[D+16>>2]=u);d=u+r|0;for(h=D+444|0;0!=(h|0);){var I=h|0;if((t[I>>2]|0)==(d|0)){c=3630;break}h=t[h+8>>2]}if(3630==c&&0==(t[h+12>>2]&8|0)){return t[I>>2]=u,w=h+4|0,t[w>>2]=t[w>>2]+r|0,b=zJ(u,d,b)}AJ(u,r)}}while(0);v=t[D+12>>2];if(v>>>0>b>>>0){return r=v-b|0,t[D+12>>2]=r,w=u=t[D+24>>2],t[D+24>>2]=w+b|0,t[b+(w+4)>>2]=r|1,t[u+4>>2]=b|3,b=u+8|0}}}while(0);t[GA>>2]=12;return 0}vJ.X=1;function uJ(b){var d,c,e,f,g,h=b>>2,i,m=-b|0,n=b>>>8;if(0==(n|0)){var q=0}else{if(16777215<b>>>0){q=31}else{var p=(n+1048320|0)>>>16&8,s=n<<p,r=(s+520192|0)>>>16&4,u=s<<r,v=(u+245760|0)>>>16&2,w=14-(r|p|v)+(u<<v>>>15)|0,q=b>>>((w+7|0)>>>0)&1|w<<1}}var C=t[D+(q<<2)+304>>2],A=0==(C|0);a:do{if(A){var I=0,M=m,B=0}else{var G=31==(q|0)?0:25-(q>>>1)|0,Z=0,X=m,ga=C;g=ga>>2;for(var ra=b<<G,ka=0;;){var ia=t[g+1]&-8,ea=ia-b|0;if(ea>>>0<X>>>0){if((ia|0)==(b|0)){I=ga;M=ea;B=ga;break a}else{var wb=ga,sb=ea}}else{wb=Z,sb=X}var Db=t[g+5],Za=t[((ra>>>31<<2)+16>>2)+g],kc=0==(Db|0)|(Db|0)==(Za|0)?ka:Db;if(0==(Za|0)){I=wb;M=sb;B=kc;break a}else{Z=wb,X=sb,ga=Za,g=ga>>2,ra<<=1,ka=kc}}}}while(0);if(0==(B|0)&0==(I|0)){var $c=2<<q,Ia=t[D+4>>2]&($c|-$c);if(0==(Ia|0)){var Eb=0;return Eb}var Pb=(Ia&-Ia)-1|0,He=Pb>>>12&16,Hd=Pb>>>(He>>>0),de=Hd>>>5&8,ee=Hd>>>(de>>>0),Id=ee>>>2&4,Jd=ee>>>(Id>>>0),uc=Jd>>>1&2,Kd=Jd>>>(uc>>>0),Qb=Kd>>>1&1,Mc=t[D+((de|He|Id|uc|Qb)+(Kd>>>(Qb>>>0))<<2)+304>>2]}else{Mc=B}var ad=0==(Mc|0);a:do{if(ad){var bb=M,Qa=I;f=Qa>>2}else{var Rb=Mc;e=Rb>>2;for(var vc=M,Sb=I;;){var fe=(t[e+1]&-8)-b|0,vd=fe>>>0<vc>>>0,lc=vd?fe:vc,Nc=vd?Rb:Sb,ge=t[e+4];if(0!=(ge|0)){Rb=ge,e=Rb>>2,vc=lc,Sb=Nc}else{var he=t[e+5];if(0==(he|0)){bb=lc;Qa=Nc;f=Qa>>2;break a}else{Rb=he,e=Rb>>2,vc=lc,Sb=Nc}}}}}while(0);if(0==(Qa|0)||bb>>>0>=(t[D+8>>2]-b|0)>>>0){return Eb=0}var Tb=Qa;c=Tb>>2;var Ub=t[D+16>>2];Tb>>>0<Ub>>>0&&O();var bd=Tb+b|0;Tb>>>0<bd>>>0||O();var cd=t[f+6],ac=t[f+3],ie=(ac|0)==(Qa|0);a:do{if(ie){var Ld=Qa+20|0,gb=t[Ld>>2];do{if(0==(gb|0)){var dd=Qa+16|0,Vb=t[dd>>2];if(0==(Vb|0)){var Sa=0;d=Sa>>2;break a}else{var Oc=dd,Pc=Vb}}else{Oc=Ld,Pc=gb}}while(0);for(;;){var Md=Pc+20|0,ed=t[Md>>2];if(0!=(ed|0)){Oc=Md,Pc=ed}else{var je=Pc+16|0,ke=t[je>>2];if(0==(ke|0)){break}else{Oc=je,Pc=ke}}}Oc>>>0<Ub>>>0?O():(t[Oc>>2]=0,Sa=Pc,d=Sa>>2)}else{var wd=t[f+2];wd>>>0<Ub>>>0?O():(t[wd+12>>2]=ac,t[ac+8>>2]=wd,Sa=ac,d=Sa>>2)}}while(0);var xd=0==(cd|0);a:do{if(xd){var ob=Qa}else{var Fb=Qa+28|0,fd=(t[Fb>>2]<<2)+D+304|0;do{if((Qa|0)==(t[fd>>2]|0)){if(t[fd>>2]=Sa,0==(Sa|0)){t[D+4>>2]&=1<<t[Fb>>2]^-1;ob=Qa;break a}}else{cd>>>0<t[D+16>>2]>>>0&&O();var le=cd+16|0;(t[le>>2]|0)==(Qa|0)?t[le>>2]=Sa:t[cd+20>>2]=Sa;if(0==(Sa|0)){ob=Qa;break a}}}while(0);Sa>>>0<t[D+16>>2]>>>0&&O();t[d+6]=cd;var gd=t[f+4];0!=(gd|0)&&(gd>>>0<t[D+16>>2]>>>0?O():(t[d+4]=gd,t[gd+24>>2]=Sa));var yd=t[f+5];0==(yd|0)?ob=Qa:yd>>>0<t[D+16>>2]>>>0?O():(t[d+5]=yd,t[yd+24>>2]=Sa,ob=Qa)}}while(0);do{if(16>bb>>>0){var Nd=bb+b|0;t[ob+4>>2]=Nd|3;var Od=Nd+(Tb+4)|0;t[Od>>2]|=1}else{if(t[ob+4>>2]=b|3,t[h+(c+1)]=bb|1,t[(bb>>2)+c+h]=bb,256>bb>>>0){var wc=bb>>>2&1073741822,xc=(wc<<2)+D+40|0,hd=t[D>>2],Pd=1<<(bb>>>3);if(0==(hd&Pd|0)){t[D>>2]=hd|Pd;var bc=xc,me=(wc+2<<2)+D+40|0}else{var Qd=(wc+2<<2)+D+40|0,ne=t[Qd>>2];ne>>>0<t[D+16>>2]>>>0?O():(bc=ne,me=Qd)}t[me>>2]=bd;t[bc+12>>2]=bd;t[h+(c+2)]=bc;t[h+(c+3)]=xc}else{var cc=bd,id=bb>>>8;if(0==(id|0)){var yb=0}else{if(16777215<bb>>>0){yb=31}else{var Rd=(id+1048320|0)>>>16&8,oe=id<<Rd,jd=(oe+520192|0)>>>16&4,Qc=oe<<jd,mc=(Qc+245760|0)>>>16&2,pe=14-(jd|Rd|mc)+(Qc<<mc>>>15)|0,yb=bb>>>((pe+7|0)>>>0)&1|pe<<1}}var Rc=(yb<<2)+D+304|0;t[h+(c+7)]=yb;t[h+(c+5)]=0;t[h+(c+4)]=0;var kd=t[D+4>>2],nc=1<<yb;if(0==(kd&nc|0)){t[D+4>>2]=kd|nc,t[Rc>>2]=cc,t[h+(c+6)]=Rc,t[h+(c+3)]=cc,t[h+(c+2)]=cc}else{for(var Sd=bb<<(31==(yb|0)?0:25-(yb>>>1)|0),Sc=t[Rc>>2];(t[Sc+4>>2]&-8|0)!=(bb|0);){var Td=(Sd>>>31<<2)+Sc+16|0,qe=t[Td>>2];if(0==(qe|0)){i=3709;break}else{Sd<<=1,Sc=qe}}if(3709==i){if(Td>>>0<t[D+16>>2]>>>0){O()}else{t[Td>>2]=cc;t[h+(c+6)]=Sc;t[h+(c+3)]=cc;t[h+(c+2)]=cc;break}}var hf=Sc+8|0,jf=t[hf>>2],Ag=t[D+16>>2];Sc>>>0<Ag>>>0&&O();jf>>>0<Ag>>>0?O():(t[jf+12>>2]=cc,t[hf>>2]=cc,t[h+(c+2)]=jf,t[h+(c+3)]=Sc,t[h+(c+6)]=0)}}}}while(0);return Eb=ob+8|0}uJ.X=1;function BJ(){var b;0==(t[zc>>2]|0)&&wJ();b=t[D+24>>2];if(0!=(b|0)){var d=t[D+12>>2];if(40<d>>>0){var c=t[zc+8>>2],e=(Math.floor(((d-41+c|0)>>>0)/(c>>>0))-1)*c|0,f=xJ(b);if(0==(t[f+12>>2]&8|0)&&(d=$B(0),b=(f+4|0)>>2,(d|0)==(t[f>>2]+t[b]|0)&&(e=$B(-(2147483646<e>>>0?-2147483648-c|0:e)|0),c=$B(0),-1!=(e|0)&c>>>0<d>>>0&&(e=d-c|0,(d|0)!=(c|0))))){t[b]=t[b]-e|0;t[D+432>>2]=t[D+432>>2]-e|0;yJ(t[D+24>>2],t[D+12>>2]-e|0);return}}t[D+12>>2]>>>0>t[D+28>>2]>>>0&&(t[D+28>>2]=-1)}}BJ.X=1;function vB(b){var d,c,e,f,g,h,i,m=b>>2,n;if(0!=(b|0)){var q=b-8|0,p=t[D+16>>2];q>>>0<p>>>0&&O();var s=t[b-4>>2],r=s&3;1==(r|0)&&O();var u=s&-8;i=u>>2;var v=b+(u-8)|0,w=0==(s&1|0);a:do{if(w){var C=t[q>>2];if(0==(r|0)){return}var A=-8-C|0;h=A>>2;var I=b+A|0,M=I,B=C+u|0;I>>>0<p>>>0&&O();if((M|0)==(t[D+20>>2]|0)){g=(b+(u-4)|0)>>2;if(3!=(t[g]&3|0)){var G=M;f=G>>2;var Z=B;break}t[D+8>>2]=B;t[g]&=-2;t[h+(m+1)]=B|1;t[v>>2]=B;return}var X=C>>>3;if(256>C>>>0){var ga=t[h+(m+2)],ra=t[h+(m+3)];if((ga|0)==(ra|0)){t[D>>2]&=1<<X^-1;G=M;f=G>>2;Z=B;break}var ka=((C>>>2&1073741822)<<2)+D+40|0;(ga|0)!=(ka|0)&ga>>>0<p>>>0&&O();if((ra|0)==(ka|0)|ra>>>0>=p>>>0){t[ga+12>>2]=ra;t[ra+8>>2]=ga;G=M;f=G>>2;Z=B;break}else{O()}}var ia=I,ea=t[h+(m+6)],wb=t[h+(m+3)],sb=(wb|0)==(ia|0);b:do{if(sb){var Db=A+(b+20)|0,Za=t[Db>>2];do{if(0==(Za|0)){var kc=A+(b+16)|0,$c=t[kc>>2];if(0==($c|0)){var Ia=0;e=Ia>>2;break b}else{var Eb=kc,Pb=$c}}else{Eb=Db,Pb=Za}}while(0);for(;;){var He=Pb+20|0,Hd=t[He>>2];if(0!=(Hd|0)){Eb=He,Pb=Hd}else{var de=Pb+16|0,ee=t[de>>2];if(0==(ee|0)){break}else{Eb=de,Pb=ee}}}Eb>>>0<p>>>0?O():(t[Eb>>2]=0,Ia=Pb,e=Ia>>2)}else{var Id=t[h+(m+2)];Id>>>0<p>>>0?O():(t[Id+12>>2]=wb,t[wb+8>>2]=Id,Ia=wb,e=Ia>>2)}}while(0);if(0==(ea|0)){G=M,f=G>>2,Z=B}else{var Jd=A+(b+28)|0,uc=(t[Jd>>2]<<2)+D+304|0;do{if((ia|0)==(t[uc>>2]|0)){if(t[uc>>2]=Ia,0==(Ia|0)){t[D+4>>2]&=1<<t[Jd>>2]^-1;G=M;f=G>>2;Z=B;break a}}else{ea>>>0<t[D+16>>2]>>>0&&O();var Kd=ea+16|0;(t[Kd>>2]|0)==(ia|0)?t[Kd>>2]=Ia:t[ea+20>>2]=Ia;if(0==(Ia|0)){G=M;f=G>>2;Z=B;break a}}}while(0);Ia>>>0<t[D+16>>2]>>>0&&O();t[e+6]=ea;var Qb=t[h+(m+4)];0!=(Qb|0)&&(Qb>>>0<t[D+16>>2]>>>0?O():(t[e+4]=Qb,t[Qb+24>>2]=Ia));var Mc=t[h+(m+5)];0==(Mc|0)?(G=M,f=G>>2,Z=B):Mc>>>0<t[D+16>>2]>>>0?O():(t[e+5]=Mc,t[Mc+24>>2]=Ia,G=M,f=G>>2,Z=B)}}else{G=q,f=G>>2,Z=u}}while(0);var ad=G;c=ad>>2;ad>>>0<v>>>0||O();var bb=b+(u-4)|0,Qa=t[bb>>2];0==(Qa&1|0)&&O();do{if(0==(Qa&2|0)){if((v|0)==(t[D+24>>2]|0)){var Rb=t[D+12>>2]+Z|0;t[D+12>>2]=Rb;t[D+24>>2]=G;t[f+1]=Rb|1;(G|0)==(t[D+20>>2]|0)&&(t[D+20>>2]=0,t[D+8>>2]=0);if(Rb>>>0<=t[D+28>>2]>>>0){return}BJ();return}if((v|0)==(t[D+20>>2]|0)){var vc=t[D+8>>2]+Z|0;t[D+8>>2]=vc;t[D+20>>2]=G;t[f+1]=vc|1;t[(vc>>2)+c]=vc;return}var Sb=(Qa&-8)+Z|0,fe=Qa>>>3,vd=256>Qa>>>0;a:do{if(vd){var lc=t[m+i],Nc=t[((u|4)>>2)+m];if((lc|0)==(Nc|0)){t[D>>2]&=1<<fe^-1}else{var ge=((Qa>>>2&1073741822)<<2)+D+40|0;(lc|0)!=(ge|0)&&lc>>>0<t[D+16>>2]>>>0&&O();(Nc|0)!=(ge|0)&&Nc>>>0<t[D+16>>2]>>>0&&O();t[lc+12>>2]=Nc;t[Nc+8>>2]=lc}}else{var he=v,Tb=t[i+(m+4)],Ub=t[((u|4)>>2)+m],bd=(Ub|0)==(he|0);b:do{if(bd){var cd=u+(b+12)|0,ac=t[cd>>2];do{if(0==(ac|0)){var ie=u+(b+8)|0,Ld=t[ie>>2];if(0==(Ld|0)){var gb=0;d=gb>>2;break b}else{var dd=ie,Vb=Ld}}else{dd=cd,Vb=ac}}while(0);for(;;){var Sa=Vb+20|0,Oc=t[Sa>>2];if(0!=(Oc|0)){dd=Sa,Vb=Oc}else{var Pc=Vb+16|0,Md=t[Pc>>2];if(0==(Md|0)){break}else{dd=Pc,Vb=Md}}}dd>>>0<t[D+16>>2]>>>0?O():(t[dd>>2]=0,gb=Vb,d=gb>>2)}else{var ed=t[m+i];ed>>>0<t[D+16>>2]>>>0?O():(t[ed+12>>2]=Ub,t[Ub+8>>2]=ed,gb=Ub,d=gb>>2)}}while(0);if(0!=(Tb|0)){var je=u+(b+20)|0,ke=(t[je>>2]<<2)+D+304|0;do{if((he|0)==(t[ke>>2]|0)){if(t[ke>>2]=gb,0==(gb|0)){t[D+4>>2]&=1<<t[je>>2]^-1;break a}}else{Tb>>>0<t[D+16>>2]>>>0&&O();var wd=Tb+16|0;(t[wd>>2]|0)==(he|0)?t[wd>>2]=gb:t[Tb+20>>2]=gb;if(0==(gb|0)){break a}}}while(0);gb>>>0<t[D+16>>2]>>>0&&O();t[d+6]=Tb;var xd=t[i+(m+2)];0!=(xd|0)&&(xd>>>0<t[D+16>>2]>>>0?O():(t[d+4]=xd,t[xd+24>>2]=gb));var ob=t[i+(m+3)];0!=(ob|0)&&(ob>>>0<t[D+16>>2]>>>0?O():(t[d+5]=ob,t[ob+24>>2]=gb))}}}while(0);t[f+1]=Sb|1;t[(Sb>>2)+c]=Sb;if((G|0)!=(t[D+20>>2]|0)){var Fb=Sb}else{t[D+8>>2]=Sb;return}}else{t[bb>>2]=Qa&-2,t[f+1]=Z|1,Fb=t[(Z>>2)+c]=Z}}while(0);if(256>Fb>>>0){var fd=Fb>>>2&1073741822,le=(fd<<2)+D+40|0,gd=t[D>>2],yd=1<<(Fb>>>3);if(0==(gd&yd|0)){t[D>>2]=gd|yd;var Nd=le,Od=(fd+2<<2)+D+40|0}else{var wc=(fd+2<<2)+D+40|0,xc=t[wc>>2];xc>>>0<t[D+16>>2]>>>0?O():(Nd=xc,Od=wc)}t[Od>>2]=G;t[Nd+12>>2]=G;t[f+2]=Nd;t[f+3]=le}else{var hd=G,Pd=Fb>>>8;if(0==(Pd|0)){var bc=0}else{if(16777215<Fb>>>0){bc=31}else{var me=(Pd+1048320|0)>>>16&8,Qd=Pd<<me,ne=(Qd+520192|0)>>>16&4,cc=Qd<<ne,id=(cc+245760|0)>>>16&2,yb=14-(ne|me|id)+(cc<<id>>>15)|0,bc=Fb>>>((yb+7|0)>>>0)&1|yb<<1}}var Rd=(bc<<2)+D+304|0;t[f+7]=bc;t[f+5]=0;t[f+4]=0;var oe=t[D+4>>2],jd=1<<bc;do{if(0==(oe&jd|0)){t[D+4>>2]=oe|jd,t[Rd>>2]=hd,t[f+6]=Rd,t[f+3]=G,t[f+2]=G}else{for(var Qc=Fb<<(31==(bc|0)?0:25-(bc>>>1)|0),mc=t[Rd>>2];(t[mc+4>>2]&-8|0)!=(Fb|0);){var pe=(Qc>>>31<<2)+mc+16|0,Rc=t[pe>>2];if(0==(Rc|0)){n=3862;break}else{Qc<<=1,mc=Rc}}if(3862==n){if(pe>>>0<t[D+16>>2]>>>0){O()}else{t[pe>>2]=hd;t[f+6]=mc;t[f+3]=G;t[f+2]=G;break}}var kd=mc+8|0,nc=t[kd>>2],Sd=t[D+16>>2];mc>>>0<Sd>>>0&&O();nc>>>0<Sd>>>0?O():(t[nc+12>>2]=hd,t[kd>>2]=hd,t[f+2]=nc,t[f+3]=mc,t[f+6]=0)}}while(0);var Sc=t[D+32>>2]-1|0;t[D+32>>2]=Sc;if(0==(Sc|0)){for(var Td=D+452|0;;){var qe=t[Td>>2];if(0==(qe|0)){break}else{Td=qe+8|0}}t[D+32>>2]=-1}}}}vB.X=1;function xJ(b){var d,c,e=D+444|0;for(d=e>>2;;){var f=t[d];if(f>>>0<=b>>>0&&(f+t[d+1]|0)>>>0>b>>>0){var g=e;c=3904;break}d=t[d+2];if(0==(d|0)){g=0;c=3905;break}else{e=d,d=e>>2}}if(3904==c||3905==c){return g}}function yJ(b,d){var c=b+8|0,c=0==(c&7|0)?0:-c&7,e=d-c|0;t[D+24>>2]=b+c|0;t[D+12>>2]=e;t[c+(b+4)>>2]=e|1;t[d+(b+4)>>2]=40;t[D+28>>2]=t[zc+16>>2]}function TI(b,d){var c,e,f;if(4294967231<d>>>0){return t[GA>>2]=12,0}var g=b-8|0;e=(b-4|0)>>2;var h=t[e],i=h&-8,m=i-8|0,n=b+m|0;g>>>0<t[D+16>>2]>>>0&&O();var q=h&3;1!=(q|0)&-8<(m|0)||O();c=(b+(i-4)|0)>>2;0==(t[c]&1|0)&&O();m=11>d>>>0?16:d+11&-8;if(0==(q|0)){var p=0,s,h=t[g+4>>2]&-8;s=256>m>>>0?0:h>>>0>=(m+4|0)>>>0&&(h-m|0)>>>0<=t[zc+8>>2]<<1>>>0?g:0;f=3939}else{i>>>0<m>>>0?(n|0)==(t[D+24>>2]|0)&&(c=t[D+12>>2]+i|0,c>>>0>m>>>0&&(p=c-m|0,t[e]=m|h&1|2,t[b+(m-4)>>2]=p|1,t[D+24>>2]=b+(m-8)|0,t[D+12>>2]=p,p=0,s=g,f=3939)):(p=i-m|0,15<p>>>0?(t[e]=m|h&1|2,t[b+(m-4)>>2]=p|3,t[c]|=1,p=b+m|0):p=0,s=g,f=3939)}if(3939==f&&0!=(s|0)){return 0!=(p|0)&&vB(p),s+8|0}g=Xa(d);if(0==(g|0)){return 0}e=i-(0==(t[e]&3|0)?8:4)|0;hB(g,b,e>>>0<d>>>0?e:d);vB(b);return g}TI.X=1;function wJ(){if(0==(t[zc>>2]|0)){var b=ZB();0!=(b-1&b|0)&&O();t[zc+8>>2]=b;t[zc+4>>2]=b;t[zc+12>>2]=-1;t[zc+16>>2]=2097152;t[zc+20>>2]=0;t[D+440>>2]=0;b=Math.floor(Date.now()/1e3);t[zc>>2]=b&-16^1431655768}}function zJ(b,d,c){var e,f,g,h=d>>2,i=b>>2,m,n=b+8|0,n=0==(n&7|0)?0:-n&7;f=d+8|0;var q=0==(f&7|0)?0:-f&7;g=q>>2;var p=d+q|0,s=n+c|0;f=s>>2;var s=b+s|0,r=p-(b+n)-c|0;t[(n+4>>2)+i]=c|3;if((p|0)==(t[D+24>>2]|0)){return m=t[D+12>>2]+r|0,t[D+12>>2]=m,t[D+24>>2]=s,t[f+(i+1)]=m|1,b=b+(n|8)|0}if((p|0)==(t[D+20>>2]|0)){return m=t[D+8>>2]+r|0,t[D+8>>2]=m,t[D+20>>2]=s,t[f+(i+1)]=m|1,t[(m>>2)+i+f]=m,b=b+(n|8)|0}var u=t[g+(h+1)];if(1==(u&3|0)){var c=u&-8,v=u>>>3,w=256>u>>>0;a:do{if(w){var C=t[((q|8)>>2)+h],A=t[g+(h+3)];if((C|0)==(A|0)){t[D>>2]&=1<<v^-1}else{var I=((u>>>2&1073741822)<<2)+D+40|0;(C|0)!=(I|0)&&C>>>0<t[D+16>>2]>>>0&&O();(A|0)!=(I|0)&&A>>>0<t[D+16>>2]>>>0&&O();t[C+12>>2]=A;t[A+8>>2]=C}}else{var C=p,A=t[((q|24)>>2)+h],I=t[g+(h+3)],M=(I|0)==(C|0);b:do{if(M){var B=q|16,G=B+(d+4)|0,Z=t[G>>2];do{if(0==(Z|0)){var X=d+B|0,ga=t[X>>2];if(0==(ga|0)){var ra=0;e=ra>>2;break b}}else{X=G,ga=Z}}while(0);for(;;){if(B=ga+20|0,G=t[B>>2],0!=(G|0)){X=B,ga=G}else{if(B=ga+16|0,G=t[B>>2],0==(G|0)){break}else{X=B,ga=G}}}X>>>0<t[D+16>>2]>>>0?O():(t[X>>2]=0,ra=ga,e=ra>>2)}else{X=t[((q|8)>>2)+h],X>>>0<t[D+16>>2]>>>0?O():(t[X+12>>2]=I,t[I+8>>2]=X,ra=I,e=ra>>2)}}while(0);if(0!=(A|0)){I=q+(d+28)|0;M=(t[I>>2]<<2)+D+304|0;do{if((C|0)==(t[M>>2]|0)){if(t[M>>2]=ra,0==(ra|0)){t[D+4>>2]&=1<<t[I>>2]^-1;break a}}else{if(A>>>0<t[D+16>>2]>>>0&&O(),X=A+16|0,(t[X>>2]|0)==(C|0)?t[X>>2]=ra:t[A+20>>2]=ra,0==(ra|0)){break a}}}while(0);ra>>>0<t[D+16>>2]>>>0&&O();t[e+6]=A;C=q|16;A=t[(C>>2)+h];0!=(A|0)&&(A>>>0<t[D+16>>2]>>>0?O():(t[e+4]=A,t[A+24>>2]=ra));C=t[(C+4>>2)+h];0!=(C|0)&&(C>>>0<t[D+16>>2]>>>0?O():(t[e+5]=C,t[C+24>>2]=ra))}}}while(0);e=d+(c|q)|0;d=c+r|0}else{e=p,d=r}e=e+4|0;t[e>>2]&=-2;t[f+(i+1)]=d|1;t[(d>>2)+i+f]=d;if(256>d>>>0){var ka=d>>>2&1073741822;m=(ka<<2)+D+40|0;e=t[D>>2];d=1<<(d>>>3);if(0==(e&d|0)){t[D>>2]=e|d;var ia=m,ea=(ka+2<<2)+D+40|0}else{ka=(ka+2<<2)+D+40|0,d=t[ka>>2],d>>>0<t[D+16>>2]>>>0?O():(ia=d,ea=ka)}t[ea>>2]=s;t[ia+12>>2]=s;t[f+(i+2)]=ia;t[f+(i+3)]=m;return b=b+(n|8)|0}ea=d>>>8;0==(ea|0)?ea=0:16777215<d>>>0?ea=31:(ia=(ea+1048320|0)>>>16&8,e=ea<<ia,ea=(e+520192|0)>>>16&4,e<<=ea,h=(e+245760|0)>>>16&2,ia=14-(ea|ia|h)+(e<<h>>>15)|0,ea=d>>>((ia+7|0)>>>0)&1|ia<<1);ia=(ea<<2)+D+304|0;t[f+(i+7)]=ea;t[f+(i+5)]=0;t[f+(i+4)]=0;e=t[D+4>>2];h=1<<ea;if(0==(e&h|0)){return t[D+4>>2]=e|h,t[ia>>2]=s,t[f+(i+6)]=ia,t[f+(i+3)]=s,t[f+(i+2)]=s,b=b+(n|8)|0}ea=d<<(31==(ea|0)?0:25-(ea>>>1)|0);for(ia=t[ia>>2];(t[ia+4>>2]&-8|0)!=(d|0);){if(ka=(ea>>>31<<2)+ia+16|0,e=t[ka>>2],0==(e|0)){m=4026;break}else{ea<<=1,ia=e}}if(4026==m){return ka>>>0<t[D+16>>2]>>>0&&O(),t[ka>>2]=s,t[f+(i+6)]=ia,t[f+(i+3)]=s,t[f+(i+2)]=s,b=b+(n|8)|0}m=ia+8|0;ka=t[m>>2];ea=t[D+16>>2];ia>>>0<ea>>>0&&O();ka>>>0<ea>>>0&&O();t[ka+12>>2]=s;t[m>>2]=s;t[f+(i+2)]=ka;t[f+(i+3)]=ia;t[f+(i+6)]=0;return b=b+(n|8)|0}zJ.X=1;function AJ(b,d){var c,e,f,g=t[D+24>>2];e=g>>2;var h=xJ(g),i=t[h>>2];c=t[h+4>>2];var h=i+c|0,m=i+(c-39)|0,i=i+(c-47)+(0==(m&7|0)?0:-m&7)|0,i=i>>>0<(g+16|0)>>>0?g:i,m=i+8|0;c=m>>2;yJ(b,d-40|0);t[i+4>>2]=27;t[c]=t[D+444>>2];t[c+1]=t[D+448>>2];t[c+2]=t[D+452>>2];t[c+3]=t[D+456>>2];t[D+444>>2]=b;t[D+448>>2]=d;t[D+456>>2]=0;t[D+452>>2]=m;c=i+28|0;t[c>>2]=7;m=(i+32|0)>>>0<h>>>0;a:do{if(m){for(var n=c;;){var q=n+4|0;t[q>>2]=7;if((n+8|0)>>>0<h>>>0){n=q}else{break a}}}}while(0);if((i|0)!=(g|0)){if(h=i-g|0,i=h+(g+4)|0,t[i>>2]&=-2,t[e+1]=h|1,t[g+h>>2]=h,256>h>>>0){var p=h>>>2&1073741822;f=(p<<2)+D+40|0;i=t[D>>2];h=1<<(h>>>3);if(0==(i&h|0)){t[D>>2]=i|h;var s=f,r=(p+2<<2)+D+40|0}else{p=(p+2<<2)+D+40|0,h=t[p>>2],h>>>0<t[D+16>>2]>>>0?O():(s=h,r=p)}t[r>>2]=g;t[s+12>>2]=g;t[e+2]=s;t[e+3]=f}else{if(r=h>>>8,0==(r|0)?r=0:16777215<h>>>0?r=31:(s=(r+1048320|0)>>>16&8,i=r<<s,r=(i+520192|0)>>>16&4,i<<=r,c=(i+245760|0)>>>16&2,s=14-(r|s|c)+(i<<c>>>15)|0,r=h>>>((s+7|0)>>>0)&1|s<<1),s=(r<<2)+D+304|0,t[e+7]=r,t[e+5]=0,t[e+4]=0,i=t[D+4>>2],c=1<<r,0==(i&c|0)){t[D+4>>2]=i|c,t[s>>2]=g,t[e+6]=s,t[e+3]=g,t[e+2]=g}else{r=h<<(31==(r|0)?0:25-(r>>>1)|0);for(s=t[s>>2];(t[s+4>>2]&-8|0)!=(h|0);){if(p=(r>>>31<<2)+s+16|0,i=t[p>>2],0==(i|0)){f=4065;break}else{r<<=1,s=i}}4065==f?(p>>>0<t[D+16>>2]>>>0&&O(),t[p>>2]=g,t[e+6]=s,t[e+3]=g,t[e+2]=g):(f=s+8|0,p=t[f>>2],r=t[D+16>>2],s>>>0<r>>>0&&O(),p>>>0<r>>>0&&O(),t[p+12>>2]=g,t[f>>2]=g,t[e+2]=p,t[e+3]=s,t[e+6]=0)}}}}AJ.X=1;var fB=da;a.H=(function(b){function d(){for(var b=0;3>b;b++){e.push(0)}}var c=b.length+1,e=[y(lb("/bin/this.program"),"i8",x)];d();for(var f=0;f<c-1;f+=1){e.push(y(lb(b[f]),"i8",x)),d()}e.push(0);e=y(e,"i32",x);return _main(c,e,0)});ab=[0,0,(function(b){UI(b,Fr|0,Fo|0,mm|0,0)}),0,(function(b){t[Fy>>2]=b;for(var d=0;!(vC(t[Fx+(d<<3)>>2],b,t[Fx+(d<<3)+4>>2]),d=d+1|0,26==(d|0));){}}),0,(function(){var b,d=GI(hn|0);b=d>>2;t[b+3]=gy|0;t[b+5]=272;t[b+8]=1;return d}),0,JG,0,(function(b){t[Hy>>2]=b;for(b=0;!(vC(t[F+(b<<3)>>2],t[Hy>>2],t[F+(b<<3)+4>>2]),b=b+1|0,73==(b|0));){}}),0,CG,0,(function(b){t[Ty>>2]=b;t[Gc+132>>2]=1;t[Gc+144>>2]=1;t[Gc+148>>2]=1;t[Gc+152>>2]=1;t[Gc+168>>2]=1;t[Gc+172>>2]=1;t[Gc+180>>2]=1;t[Gc+184>>2]=1;t[Gc+188>>2]=1;t[Gc+232>>2]=1;t[Gc+240>>2]=1;t[Gc+244>>2]=1;t[Gc+248>>2]=1;t[Gc+252>>2]=1;t[Gc+256>>2]=1;t[Gc+376>>2]=1;t[Gc+504>>2]=1;t[Gc+496>>2]=1;for(b=0;!(vC(t[sy+(b<<3)>>2],t[Ty>>2],t[sy+(b<<3)+4>>2]),b=b+1|0,42==(b|0));){}}),0,(function(b,d){0==(d|0)?(t[z>>2]=260,t[rd>>2]=16):26==(d|0)?(iG(t[t[Mb>>2]+8>>2],7),S(t[Mb>>2]),t[rd>>2]=16,t[z>>2]=250,hG(0,26)):22==(d|0)?V(t[Mb>>2],t[b+8>>2]):34==(d|0)?t[z>>2]=150:5==(d|0)?t[z>>2]=62:3==(d|0)?t[z>>2]=174:4==(d|0)?t[z>>2]=124:28==(d|0)?(t[rd>>2]=16,t[z>>2]=250,hG(0,28)):1==(d|0)&&(t[z>>2]=198,t[rd>>2]=16)}),0,(function(b,d){31==(d|0)?(nG(b,7),l[Kb]=1,t[Ib>>2]=43,t[rd>>2]=18,t[z>>2]=208):37==(d|0)&&(zG(),t[z>>2]=122)}),0,(function(b,d){8==(d|0)||29==(d|0)?(t[z>>2]=114,t[Ib>>2]=3,t[rd>>2]=20):14==(d|0)?oG(0,14):13==(d|0)||27==(d|0)?t[z>>2]=188:19==(d|0)?(S(t[Ec>>2]),BG(0,2,12,0),l[yc]=0,t[z>>2]=122):25==(d|0)?(t[z>>2]=20,BG(1,4,160,b)):10==(d|0)?t[z>>2]=160:(t[z>>2]=12,CG(0,d))}),0,(function(){var b=j;j+=8;var d=P(),c=P();t[rc>>2]=c;c=P();t[Mb>>2]=c;c=P();t[Wc>>2]=c;c=P();t[ec>>2]=c;c=b|0;t[c>>2]=P();t[b+4>>2]=eC();t[z>>2]=16;var e=cG(b),f=38==(e|0);a:do{if(!f){for(var g=e;;){if(ab[t[z>>2]](t[c>>2],g),g=cG(b),38==(g|0)){break a}}}}while(0);Q(d);Q(t[rc>>2]);Q(t[Mb>>2]);Q(t[Wc>>2]);Q(t[ec>>2]);t[rc>>2]=0;t[Mb>>2]=0;t[ec>>2]=0;t[Wc>>2]=0;j=b}),0,(function(b,d){34==(d|0)?(t[z>>2]=114,t[Ib>>2]=35,t[rd>>2]=24):31==(d|0)&&(nG(b,0),V(t[Ec>>2],t[b+8>>2]),t[z>>2]=104,t[Ib>>2]=40,t[rd>>2]=268)}),0,jG,0,(function(){var b,d=GI(Vl|0);b=d>>2;t[b+1]=Az|0;t[b+2]=4;t[b+3]=zz|0;t[b+6]=286;return d}),0,(function(){var b,d=GI(yh|0);b=d>>2;t[b+1]=Xx|0;t[b+2]=1;t[b+3]=Wx|0;t[b+6]=190;return d}),0,(function(){var b,d=GI(xq|0);b=d>>2;t[b+3]=$y|0;t[b+5]=164;t[b+8]=1;return d}),0,(function(){var b,d=GI(nu|0);b=d>>2;t[b+3]=Xy|0;t[b+1]=Vy|0;t[b+2]=5;t[b+6]=202;t[b+5]=288;return d}),0,(function(b){t[Qy>>2]=b;uC(b,1)}),0,rJ,0,(function(){var b,d=GI(ei|0);b=d>>2;t[b+1]=iz|0;t[b+2]=14;t[b+3]=hz|0;t[b+7]=162;t[b+5]=216;return d}),0,(function(){var b,d=GI(uu|0);b=d>>2;t[b+1]=Jz|0;t[b+2]=13;t[b+3]=Iz|0;t[b+7]=142;t[b+5]=254;return d}),0,(function(b){t[Gy>>2]=b;uC(b,4)}),0,(function(b,d){26==(d|0)?(t[z>>2]=48,t[rd>>2]=46,t[Ib>>2]=27):32==(d|0)?(iG(t[t[Mb>>2]+8>>2],8),S(t[Mb>>2])):22==(d|0)&&V(t[Mb>>2],t[b+8>>2])}),0,(function(b,d){(t[Ib>>2]|0)==(d|0)&&(t[z>>2]=t[rd>>2])}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=qH(),f=(k=Da++,d[k]=1,Ea[k]=b,t[xz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:for(var g=e,h=g|0,i=g+4|0;!($(g),1==(t[h>>2]|0)?sH(g):uH(g),5==(t[i>>2]|0));){}b=3;break;case 4:rH(e);return;default:ua(0,"bad label: "+b)}}catch(m){(!m.f||!(m.id in d))&&aa(m),c[Ea[m.id]](m.value)}}}),0,(function(){var b,d=GI(zh|0);b=d>>2;t[b+1]=ay|0;t[b+2]=2;t[b+3]=$x|0;t[b+6]=224;return d}),0,(function(){var b,d=GI(um|0);b=d>>2;t[b+1]=Nx|0;t[b+2]=3;t[b+3]=Mx|0;t[b+6]=94;return d}),0,(function(){var b,d=GI(bl|0);b=d>>2;t[b+1]=iy|0;t[b+2]=6;t[b+3]=hy|0;t[b+6]=8;return d}),0,(function(){var b,d=GI(Op|0);b=d>>2;t[b+3]=jy|0;t[b+1]=ky|0;t[b+2]=2;t[b+6]=232;return d}),0,(function(b){UI(b,ls|0,Fo|0,Jm|0,0);UI(b,Bk|0,Fo|0,Pi|0,0)}),0,(function(b,d){if(22==(d|0)){var c=b+8|0;aG(t[c>>2],2);iG(t[c>>2],2)}t[z>>2]=74}),0,(function(b){t[Ry>>2]=b;uC(b,0)}),0,(function(b,d){return 0==(qA(b,t[d+8>>2])|0)&1}),0,(function(b,d){31==(d|0)&&(nG(b,2),V(t[Dc>>2],t[b+8>>2]),t[Ib>>2]=40,t[rd>>2]=280,t[z>>2]=104)}),0,nC,0,(function(){var b,d=GI(cr|0);b=d>>2;t[b+1]=nz|0;t[b+2]=5;t[b+3]=mz|0;t[b+6]=276;return d}),0,(function(b,d){24==(d|0)?(t[z>>2]=284,t[Ac>>2]=4):9==(d|0)?t[z>>2]=46:25==(d|0)?(t[z>>2]=284,t[Ac>>2]=3):10==(d|0)?(bG(),t[z>>2]=16):28==(d|0)&&(t[z>>2]=256)}),0,(function(){var b,d=GI(jm|0);b=d>>2;t[b+3]=Pz|0;t[b+5]=78;t[b+8]=1;return d}),0,(function(b){UI(b,ek|0,Fo|0,bh|0,Ti|0);UI(b,Oe|0,Fo|0,hx|0,Ti|0);UI(b,uw|0,Fo|0,Kv|0,Ti|0);UI(b,mv|0,Fo|0,Pu|0,Ti|0);UI(b,pu|0,Fo|0,Rt|0,Ti|0);UI(b,rt|0,Fo|0,Ps|0,Ti|0)}),0,(function(){var b,d=GI(ut|0);b=d>>2;t[b+1]=Zy|0;t[b+2]=8;t[b+3]=Yy|0;t[b+7]=142;t[b+5]=266;return d}),0,(function(){}),0,(function(){var b=j;j+=8;for(var d=P(),c=0;;){var e=P();t[Yb+(c<<4)+12>>2]=e;c=c+1|0;if(256==(c|0)){break}}t[Xb>>2]=0;mG();c=P();t[Nb>>2]=c;c=P();t[Dc>>2]=c;c=P();t[Ec>>2]=c;c=P();t[Jb>>2]=c;V(c,fr|0);c=b|0;t[c>>2]=P();t[b+4>>2]=eC();t[z>>2]=122;var e=rG(b),f=48==(e|0);a:do{if(!f){for(var g=e;;){if(ab[t[z>>2]](t[c>>2],g),g=rG(b),48==(g|0)){break a}}}}while(0);Q(d);Q(t[Jb>>2]);Q(t[Nb>>2]);Q(t[Dc>>2]);Q(t[Ec>>2]);for(d=0;!(Q(t[Yb+(d<<4)+12>>2]),d=d+1|0,256==(d|0));){}j=b}),0,(function(b,d){38==(d|0)?(t[rd>>2]=86,t[z>>2]=228):32==(d|0)?(t[rd>>2]=86,t[Ib>>2]=33,t[z>>2]=114):31==(d|0)?(nG(b,4),BG(0,0,122,b),l[yc]=1,t[Ib>>2]=40,t[rd>>2]=168,t[z>>2]=154):oG(0,d)}),0,(function(b,d){32==(d|0)||18==(d|0)||28==(d|0)||21==(d|0)||(31==(d|0)?(nG(b,1),BG(0,5,122,b),t[z>>2]=110):6==(d|0)?zG():t[z>>2]=122)}),0,(function(){var b,d=GI($t|0);b=d>>2;t[b+1]=zy|0;t[b+2]=1;t[b+3]=yy|0;t[b+6]=140;return d}),0,(function(b){t[Ey>>2]=b;for(var d=0;!(vC(t[E+(d<<3)>>2],b,t[E+(d<<3)+4>>2]),d=d+1|0,95==(d|0));){}}),0,VH,0,(function(){var b,d=GI(ep|0);b=d>>2;t[b+1]=Sx|0;t[b+2]=7;t[b+3]=Rx|0;t[b+6]=158;return d}),0,(function(){var b,d=GI(vs|0);b=d>>2;t[b+1]=Xz|0;t[b+2]=4;t[b+3]=Wz|0;t[b+6]=148;return d}),0,(function(b){t[Uy>>2]=b;for(b=0;!(vC(t[sc+(b<<3)>>2],t[Uy>>2],t[sc+(b<<3)+4>>2]),b=b+1|0,21==(b|0));){}}),0,dC,0,FG,0,(function(){var b,d=GI(Xh|0);b=d>>2;t[b+1]=By|0;t[b+2]=1;t[b+3]=Ay|0;t[b+6]=180;return d}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=12;h=c}),g:0};;){try{switch(b){case 2:var e,f,g=P();e=1;f=0;var h=(k=Da++,d[k]=1,Ea[k]=b,t[vz>>2]=k,0);b=12;break;case 12:b=0==(h|0)?3:11;break;case 3:b=-1==(f|0)?11:4;break;case 4:var i=f=iI();b=32==(i|0)||9==(i|0)?5:59==(i|0)||10==(i|0)?6:7;break;case 5:b=-1==(f|0)?11:4;break;case 6:e=1;b=5;break;case 7:b=0==(e|0)?10:8;break;case 8:b=0==(gI(g,f)|0)?10:9;break;case 9:a:{var i=g,m=ba,n=i+8|0,q=mC(t[n>>2],t[Fy>>2]);if(0==(q|0)){m=1967}else{if(-1==(q|0)){break a}}do{if(1967==m&&96==l[t[n>>2]]<<24>>24){gI(i,jI(iI()));for(jC(i,Ex|0,0);10!=(iI()|0);){}fI(10);break a}}while(0);var p=jI(iI()),s=40==(p|0)?kI(40,41):p,r=jI(s),u=91==(r|0)?kI(91,93):r,v=jI(u);if(35==(v|0)){var w=iI(),C=40!=(w|0)?w:kI(40,41)}else{C=v}var A=jI(C);if(0!=(hI(A)|0)){var i=q,n=A,m=ba,I=P();b:for(;;){if(0==(hI(n)|0)){var M=n,m=2007;break}gI(I,n);jC(I,Ex|0,i);var B=jI(iI()),G=91==(B|0)?kI(91,93):B,Z=jI(G),X=61==(Z|0);c:do{if(X){if(123==(jI(iI())|0)){m=2001;break b}for(;;){var ga=iI();if(59==(ga|0)||44==(ga|0)){var ra=ga;break c}}}else{ra=Z}}while(0);if(44!=(ra|0)){M=ra;m=2008;break}n=jI(iI())}2001==m?(kI(123,125),M=123,Q(I),fI(M)):2007==m?(Q(I),fI(M)):2008==m&&(Q(I),fI(M))}}b=10;break;case 10:e=0;b=5;break;case 11:Q(g);return;default:ua(0,"bad label: "+b)}}catch(ka){(!ka.f||!(ka.id in d))&&aa(ka),c[Ea[ka.id]](ka.value)}}}),0,yG,0,(function(){var b,d=GI(Mv|0);b=d>>2;t[b+1]=Cz|0;t[b+2]=3;t[b+3]=Bz|0;t[b+6]=130;t[b+5]=176;return d}),0,(function(b,d){(t[Ib>>2]|0)==(d|0)?t[z>>2]=t[rd>>2]:6==(d|0)&&(zG(),t[z>>2]=122)}),0,(function(b){t[My>>2]=b;vC(Gi|0,b,0);vC(Yv|0,b,1);vC(El|0,b,2);vC(wf|0,b,3);vC(Wj|0,b,4);vC(Mg|0,b,5);vC(uq|0,b,6);vC(cq|0,b,7);vC(ys|0,b,8);vC(kw|0,b,9)}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;h=c}),g:0};;){try{switch(b){case 2:var e=cE(),f=bH();t[Rz>>2]=f;var g=bH();t[fz>>2]=g;var h=(k=Da++,d[k]=1,Ea[k]=b,t[sz>>2]=k,0);b=5;break;case 5:b=0==(h|0)?3:4;break;case 3:var i=e,m=ba,m=(i|0)>>2,n=i+4|0;a:for(;;){Y(i);var q=t[m];if(22==(q|0)){Y(i);if(24==(t[m]|0)){for(Y(i);;){var p=24==(t[m]|0);Y(i);if(p){continue a}}}if(-1==(t[n>>2]|0)&&(Y(i),23!=(t[m]|0))){for(;;){if(Y(i),23==(t[m]|0)){continue a}}}}else{19==(q|0)?eE(i):fE(i)}};case 4:fH(t[Rz>>2]);fH(t[fz>>2]);t[Rz>>2]=0;t[fz>>2]=0;dE(e);return;default:ua(0,"bad label: "+b)}}catch(s){(!s.f||!(s.id in d))&&aa(s),c[Ea[s.id]](s.value)}}}),0,oC,0,oG,0,(function(b,d){if(22==(d|0)){var c=b+8|0;iG(t[c>>2],0);aG(t[c>>2],0)}t[z>>2]=74}),0,LG,0,(function(b,d){31==(d|0)?nG(b,8):oG(0,d);t[z>>2]=122}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=ED(),f=(k=Da++,d[k]=1,Ea[k]=b,t[tz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:FD(e,7);var g=e,h=ba;GD(g);var i=g|0,m=t[i>>2];if(11==(m|0)){var n=g,q=j;j+=80;var p=n+12|0;0!=(t[Cz>>2]|0)&&(sC(q,t[t[p>>2]+8>>2]),t[q+36>>2]=t[Cz+8>>2],l[q+40|0]=t[Cz+4>>2]&255,tC(q));V(t[n+16>>2],t[t[p>>2]+8>>2]);j=q;GD(g);h=1608}else{var s=m}for(;;){1608==h&&(s=t[i>>2]);if(15==(s|0)){ID(g)}else{if(12==(s|0)){var r=t[g+4>>2];if(31==(r|0)){if(n=g,p=q=ba,GD(n),q=(n|0)>>2,11==(t[q]|0)){for(var u=n+4|0;;){JD(n);var v=t[q];if(12==(v|0)){var w=t[u>>2];if(45==(w|0)){for(var C=n,A=C|0,I=C+4|0;!(GD(C),0!=(LD(C)|0)&&(GD(C),3==(t[I>>2]|0)&&(GD(C),0!=(LD(C)|0)&&(MD(C),GD(C)))),7!=(t[A>>2]|0));){}p=1635}else{if(18==(w|0)){GD(n)}else{if(21==(w|0)||55==(w|0)||44==(w|0)||50==(w|0)){p=1635}}}1635==p&&(p=0,FD(n,18),GD(n));var M=t[q]}else{M=v}if(20==(M|0)){GD(n);var B=t[q]}else{B=M}if(11!=(B|0)){break}}}}else{if(24==(r|0)){for(var n=g,q=ba,q=(n+4|0)>>2,G=t[q];;){if(24==(G|0)){p=n;u=ba;u=(p+8|0)>>2;t[u]=1;GD(p);C=p|0;if(14==(t[C>>2]|0)){t[u]=0;for(A=14;;){if(11==(A|0)){var Z;if(11!=(t[p>>2]|0)){var X=0,ga=X&1}else{X=0==(sA(t[t[p+12>>2]+8>>2],qu|0,Aa)|0),ga=X&1}Z=ga;t[u]|=0==(Z|0)&1}else{if(3==(A|0)){break}}GD(p);A=t[C>>2]}GD(p)}var ra=t[q]}else{ra=G}!(24==(ra|0)||33==(ra|0)||29==(ra|0))&&0==(KD(n)|0)&&GD(n);var ka=t[q];if(18==(ka|0)||33==(ka|0)||29==(ka|0)){break}else{G=ka}}}else{GD(g)}}}else{GD(g)}}if(18==(t[g+4>>2]|0)){break}else{h=1608}}b=3;break;case 4:HD(e);return;default:ua(0,"bad label: "+b)}}catch(ia){(!ia.f||!(ia.id in d))&&aa(ia),c[Ea[ia.id]](ia.value)}}}),0,(function(){for(;0!=(eC()|0);){}}),0,qJ,0,(function(){var b,d=GI(Cu|0);b=d>>2;t[b+1]=dz|0;t[b+2]=5;t[b+3]=cz|0;t[b+6]=230;t[b+5]=116;return d}),0,(function(){var b,d=GI(iq|0);b=d>>2;t[b+1]=uy|0;t[b+2]=13;t[b+3]=ty|0;t[b+6]=22;t[b+5]=100;return d}),0,(function(){var b=P(),d=eC();if(0!=(d|0)){for(;;){for(var c=ba,e=d;;){var f=e+1|0;if(0==(L(l[e]&255)|0)){break}else{e=f}}e=l[e];if(45==e<<24>>24){if(45==l[f]<<24>>24){var g=0}else{c=3733}}else{0==e<<24>>24?g=0:c=3733}3733==c&&(g=1);0!=(g|0)&&(c=tA(d,Cf|0),0!=(c|0)&&(e=mA(d,61),0==(e|0)?(d=c+9|0,TF(d,mA(d,40),b)):TF(d,e,b)));d=eC();if(0==(d|0)){break}}}Q(b)}),0,(function(b){var d=j,c;c=2;for(var e={},f={2:(function(b){c=7;n=b}),g:0};;){try{switch(c){case 2:var g=(t[Py>>2]|0)==(t[K+56>>2]|0)&1;t[Vz>>2]=1<b>>>0&1;t[Lz>>2]=0;t[Lz+4>>2]=0;t[Lz+8>>2]=0;t[Lz+12>>2]=g;t[Lz+16>>2]=0;t[Lz+20>>2]=1;t[Lz+28>>2]=0;t[Lz+32>>2]=0;t[Lz+36>>2]=0;t[Lz+40>>2]=0;t[Lz+44>>2]=0;var h=t[Lz+24>>2];if(0==(h|0)){var i=P();t[Lz+24>>2]=i}else{S(h)}var m=P();t[Vx>>2]=m;var n=(k=Da++,e[k]=1,Ea[k]=c,t[yz>>2]=k,0);c=7;break;case 7:c=0==(n|0)?3:4;break;case 3:yC(0,0);var q=0;c=6;break;case 4:if(0!=(t[Fz>>2]|0)){for(;!(wC(),0==(t[Fz>>2]|0));){}}3==(n|0)&1==(b|0)?c=5:(q=0,c=6);break;case 5:var p=t[(t[K+40>>2]+8|0)>>2];KC(ku|0,(k=j,j+=4,t[k>>2]=p,k));q=1;c=6;break;case 6:Q(t[Vx>>2]);var s=t[Lz+24>>2];0!=(s|0)&&(Q(s),t[Lz+24>>2]=0);j=d;return q;default:ua(0,"bad label: "+c)}}catch(r){(!r.f||!(r.id in e))&&aa(r),f[Ea[r.id]](r.value)}}}),0,(function(b,d){if(31==(d|0)){l[md]||(l[md]=1,0==(t[ic>>2]|0)&&(t[z>>2]=110))}else{if(33==(d|0)){var c=t[ic>>2]-1|0;t[ic>>2]=c;0==(c|0)&&(t[z>>2]=110)}else{32==(d|0)&&(t[ic>>2]=t[ic>>2]+1|0)}}}),0,(function(){var b,d=GI(ej|0);b=d>>2;t[b+1]=fy|0;t[b+2]=5;t[b+3]=ey|0;t[b+6]=126;return d}),0,qC,0,(function(b,d){t[z>>2]=22!=(d|0)?304:0==(qA(t[b+8>>2],zr|0)|0)?298:304}),0,(function(){var b,d=GI(Pr|0);b=d>>2;t[b+1]=Hx|0;t[b+2]=13;t[b+3]=Gx|0;t[b+7]=142;t[b+5]=44;return d}),0,(function(b,d){(t[Ib>>2]|0)==(d|0)?t[z>>2]=t[rd>>2]:oG(0,d)}),0,(function(){var b=KI(t[t[K>>2]+8>>2]),d=0==(qA(b,eq|0)|0)?sd|0:0==(qA(b,wn|0)|0)?dc|0:Xc|0,c=eC();if(0!=(c|0)){for(;;){if(0!=(L(l[c]<<24>>24)|0)){c=c+1|0}else{do{if(0!=l[c]<<24>>24){for(var e=d;0!=(t[e>>2]|0);){var f;f=c;for(var g=e,h=ba,i=g|0,m=0,n=t[i>>2];m>>>0<tb(n)>>>0;){if(n=t[i>>2],(rA(l[f+m|0]<<24>>24)|0)==(l[n+m|0]<<24>>24|0)){m=m+1|0}else{var q=0,h=341;break}}if(341!=h){q=P();h=g+8|0;i=0<(t[h>>2]+1|0);b:do{if(i){for(var n=0,p=f+m|0;;){if(p=pC(p,q),n=n+1|0,(n|0)>=(t[h>>2]+1|0)){break b}}}}while(0);jC(q,Zz|0,t[g+4>>2]);Q(q);q=1}f=q;if(0==(f|0)){e=e+12|0}else{break}}if(0==(qA(b,eq|0)|0)){e=c,46==l[e]<<24>>24&&(f=P(),pC(e+1|0,f),jC(f,Zz|0,2),Q(f))}else{e=c;for(f=e+(tb(e)-1)|0;0!=(L(l[f]<<24>>24)|0);){f=f-1|0}58==l[f]<<24>>24&&(g=P(),gD(g,e,f-e|0),jC(g,Zz|0,2),Q(g))}}}while(0);c=eC();if(0==(c|0)){break}}}}}),0,lH,0,(function(b,d){34==(d|0)?t[Bc>>2]=t[Bc>>2]+1|0:12==(d|0)?GG():14==(d|0)?(GG(),oG(0,14)):45==(d|0)&&(EG(160),t[z>>2]=20)}),0,(function(b){var d=j,c;c=2;for(var e={},f={2:(function(b){c=7;i=b}),g:0};;){try{switch(c){case 2:var g=CE();t[my>>2]=g;var h=CE();t[gz>>2]=1<b>>>0&1;t[Nz>>2]=0;var i=(k=Da++,e[k]=1,Ea[k]=c,t[rz>>2]=k,0);c=7;break;case 7:c=1==(i|0)?6:3;break;case 3:c=2!=(i|0)|0!=(t[gz>>2]|0)?5:4;break;case 4:var m=t[(t[K+40>>2]+8|0)>>2];KC(Hg|0,(k=j,j+=4,t[k>>2]=m,k));var n=1;c=6;break;case 5:var q=h;JE(q);for(var p=q|0,s=q+4|0;;){if(11==(t[p>>2]|0)){JE(q)}else{var r=t[s>>2];if(23==(r|0)){XE(q,3)}else{if(57==(r|0)){XE(q,11)}else{if(3==(r|0)){var u=q,v=ba;JE(u);v=(u+4|0)>>2;11==(t[v]|0)&&(JE(u),3==(t[u>>2]|0)&&TE(u,0));WE(u);HE(u);KE(u);if(18!=(t[v]|0)){for(;!(HE(u),18==(t[v]|0));){}}SE(u);HE(u);EE()}else{if(45==(r|0)){XE(q,10)}else{if(18==(r|0)){HE(q)}else{if(34==(r|0)){u=q;v=ba;JE(u);3==(t[u>>2]|0)&&TE(u,8);WE(u);HE(u);KE(u);var w=u+4|0,C=t[w>>2];if(10==(C|0)){lF(u),v=2626}else{var A=C}for(;;){2626==v&&(A=t[w>>2]);if(18==(A|0)){break}HE(u);v=2626}SE(u);HE(u);EE()}else{0!=(FE(r)|0)?JE(q):0==(KE(q)|RE(q)|0)&&JE(q)}}}}}}}};case 6:var I=0==(t[lA>>2]|0);a:do{if(!I){for(;;){if(EE(),0==(t[lA>>2]|0)){break a}}}}while(0);var M=t[jA>>2];0!=(M|0)&&vB(M);t[jA>>2]=0;t[lA>>2]=0;t[kA>>2]=0;DE(h);DE(t[my>>2]);j=d;return n;default:ua(0,"bad label: "+c)}}catch(B){(!B.f||!(B.id in e))&&aa(B),f[Ea[B.id]](B.value)}}}),0,(function(b){UI(b,Nn|0,du|0,Ej|0,Ti|0);UI(b,Ig|0,Fo|0,ue|0,0)}),0,(function(b,d){var c=t[gc>>2];0!=(c|0)&&(t[rd>>2]=c,t[gc>>2]=0);32==(d|0)?(iG(t[t[Mb>>2]+8>>2],6),S(t[Mb>>2])):22==(d|0)?V(t[Mb>>2],t[b+8>>2]):28==(d|0)||26==(d|0)||30==(d|0)?(t[z>>2]=250,t[gc>>2]=t[rd>>2],t[rd>>2]=166,hG(0,d)):29==(d|0)&&(t[z>>2]=t[rd>>2])}),0,(function(b,d){if(31==(d|0)){var c=t[b+8>>2];0==(26>(l[c]-65&255)&1|0)?(t[z>>2]=154,t[rd>>2]=168,t[Ib>>2]=39):(V(t[Nb>>2],c),AG(Lb,t[t[Nb>>2]+8>>2],6),t[z>>2]=234)}else{36==(d|0)?t[z>>2]=18:0==(d|0)&&(t[z>>2]=86)}}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=lI(),f=(k=Da++,d[k]=1,Ea[k]=b,t[uz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:for(var g=e,h=g+4|0;!(qI(g),nI(g,0),23==(t[h>>2]|0));){}b=3;break;case 4:mI(e);return;default:ua(0,"bad label: "+b)}}catch(i){(!i.f||!(i.id in d))&&aa(i),c[Ea[i.id]](i.value)}}}),0,(function(b,d){if(31==(d|0)){l[md]||(l[md]=1)}else{if(32==(d|0)){t[jc>>2]=t[jc>>2]+1|0}else{if(42==(d|0)){58==l[t[b+8>>2]]<<24>>24?(t[z>>2]=228,t[rd>>2]=110):0==(t[jc>>2]|0)&l[md]&&(t[z>>2]=110,yG(b,42))}else{if(33==(d|0)){var c=t[jc>>2]-1|0;t[jc>>2]=c;0==(c|0)&&(t[z>>2]=110)}else{0==(t[jc>>2]|0)&l[md]&&(t[z>>2]=110,yG(b,d))}}}}}),0,(function(b,d){if(22==(d|0)){var c=b+8|0;iG(t[c>>2],1);aG(t[c>>2],1)}t[z>>2]=26}),0,(function(b){t[Oy>>2]=b;for(b=0;!(vC(t[Dz+(b<<3)>>2],t[Oy>>2],t[Dz+(b<<3)+4>>2]),b=b+1|0,61==(b|0));){}}),0,(function(){var b,d=GI(Fn|0);b=d>>2;t[b+1]=aA|0;t[b+2]=1;t[b+3]=$z|0;t[b+6]=120;return d}),0,RF,0,(function(){var b,d=GI(ww|0);b=d>>2;t[b+3]=Kx|0;t[b+1]=Lx|0;t[b+2]=8;t[b+6]=246;t[b+5]=236;return d}),0,(function(){var b,d=GI(pv|0);b=d>>2;t[b+1]=Tz|0;t[b+2]=14;t[b+3]=Kz|0;t[b+7]=142;t[b+5]=36;return d}),0,(function(b,d){return 0==(sA(b,t[d+8>>2],Aa)|0)&1}),0,(function(b,d){32==(d|0)||21==(d|0)||(42==(d|0)?(BG(1,4,20,b),t[z>>2]=110):6==(d|0)?zG():41==(d|0)?(BG(1,3,20,b),t[z>>2]=110):31==(d|0)?(BG(1,3,20,b),t[z>>2]=110):t[z>>2]=12)}),0,jH,0,(function(b,d){if((t[Ib>>2]|0)==(d|0)){t[z>>2]=t[rd>>2]}else{if(((l[Zc]?29:0)|0)==(d|0)){t[z>>2]=t[Yc>>2]}}}),0,(function(b){UI(b,gp|0,Fo|0,Ek|0,Ti|0);UI(b,xh|0,Fo|0,ig|0,0)}),0,(function(){var b,d=GI(Fw|0);b=d>>2;t[b+1]=Tz|0;t[b+2]=14;t[b+3]=Sz|0;t[b+7]=142;t[b+5]=64;return d}),0,(function(b,d){if(22==(d|0)){if(l[fc]){l[fc]=0;bG();var c=t[rd>>2];t[z>>2]=c;ab[c](b,22)}else{c=b+8|0,iG(t[c>>2],10),aG(t[c>>2],10),l[fc]=1}}else{28==(d|0)?t[z>>2]=166:32==(d|0)&&(l[fc]&&bG(),c=t[rd>>2],t[z>>2]=c,ab[c](b,32))}}),0,(function(){var b,d=GI(ul|0);b=d>>2;t[b+1]=xy|0;t[b+2]=1;t[b+4]=vy|0;t[b+3]=wy|0;t[b+6]=270;return d}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;h=c}),g:0};;){try{switch(b){case 2:var e=yF(),f=bH();t[Qz>>2]=f;var g=bH();t[ez>>2]=g;var h=(k=Da++,d[k]=1,Ea[k]=b,t[pz>>2]=k,0);b=5;break;case 5:b=0==(h|0)?3:4;break;case 3:for(var i=e,m=i|0,n=i+4|0;;){BF(i),6!=(t[m>>2]|0)?JF(i,0):0==(t[n>>2]|0)?AF(i):JF(i,0)};case 4:fH(t[Qz>>2]);fH(t[ez>>2]);t[Qz>>2]=0;t[ez>>2]=0;zF(e);return;default:ua(0,"bad label: "+b)}}catch(q){(!q.f||!(q.id in d))&&aa(q),c[Ea[q.id]](q.value)}}}),0,sJ,0,(function(){var b,d=GI(qw|0);b=d>>2;t[b+1]=Ax|0;t[b+2]=5;t[b+3]=zx|0;t[b+6]=210;return d}),0,(function(b,d){(t[Ib>>2]|0)==(d|0)?t[z>>2]=t[rd>>2]:((l[Kb]?37:0)|0)==(d|0)?t[z>>2]=122:oG(0,d)}),0,(function(){var b=xI();a:for(;;){for(var d=0==(b|0);;){if(d){break a}var c;c=b;var e=0==(N(c,Hr|0,4)|0)?1:0==(N(c,Go|0,4)|0)?1:0!=(N(c,om|0,3)|0)?1:yI(c);0!=(zI(c)|0)&&AI(c);0==(N(c,hk|0,2)|0)&&BI(c);0==(N(c,yi|0,3)|0)&&DI(c);0==(N(c,fh|0,3)|0)&&EI(c);c=e;if(0!=(c|0)){break}}b=xI()}}),0,(function(b){t[Sy>>2]=b;for(b=0;!(vC(t[gA+(b<<3)>>2],t[Sy>>2],t[gA+(b<<3)+4>>2]),b=b+1|0,16==(b|0));){}}),0,(function(){var b,d=GI(rr|0);b=d>>2;t[b+3]=Ez|0;t[b+5]=306;t[b+8]=1;return d}),0,(function(b){t[Ny>>2]=b;for(b=0;!(vC(t[J+(b<<3)>>2],t[Ny>>2],t[J+(b<<3)+4>>2]),b=b+1|0,68==(b|0));){}}),0,(function(){var b,d=GI($m|0);b=d>>2;t[b+3]=dy|0;t[b+5]=296;t[b+8]=1;return d}),0,(function(){var b,d=GI(vw|0);b=d>>2;t[b+1]=Ex|0;t[b+2]=8;t[b+3]=Dx|0;t[b+6]=108;t[b+5]=4;return d}),0,(function(){var b,d=GI(rs|0);b=d>>2;t[b+3]=Ux|0;t[b+5]=194;t[b+8]=1;return d}),0,hH,0,(function(){var b,d=GI(Jr|0);b=d>>2;t[b+1]=Cx|0;t[b+2]=11;t[b+3]=Bx|0;t[b+6]=170;t[b+5]=92;return d}),0,(function(){t[z>>2]=t[rd>>2]}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=qF(),f=(k=Da++,d[k]=1,Ea[k]=b,t[qz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:for(var g=e,h=g|0,i=g+4|0;;){if(tF(g),2==(t[h>>2]|0)){var m=t[i>>2];if(4==(m|0)){sF(g,4)}else{if(5==(m|0)){var n=g,q=qF();tF(q);5==(t[q>>2]|0)&&wF(q);tF(n);wF(n);vF(n);7==(t[n>>2]|0)&&wF(n);uF(q,1);rF(q)}else{if(2==(m|0)){sF(g,2)}else{if(0==(m|0)){var p=qF();tF(p);uF(p,0);if(0==(t[Zb>>2]|0)&0!=(t[oy+4>>2]|0)){var s=P();t[Zb>>2]=s;V(s,t[t[p+8>>2]+8>>2])}rF(p)}else{3==(m|0)&&sF(g,3)}}}}}};case 4:rF(e);Q(t[Zb>>2]);t[Zb>>2]=0;return;default:ua(0,"bad label: "+b)}}catch(r){(!r.f||!(r.id in d))&&aa(r),c[Ea[r.id]](r.value)}}}),0,HG,0,(function(b,d){20==(d|0)?(tC(Lb),S(t[Nb>>2]),t[z>>2]=154,t[rd>>2]=168,t[Ib>>2]=39):42==(d|0)?(t[z>>2]=122,zG(),l[yc]=0):39==(d|0)?(tC(Lb),S(t[Nb>>2]),t[z>>2]=168):(tC(Lb),S(t[Nb>>2]),t[z>>2]=154,t[rd>>2]=168,t[Ib>>2]=39,zG(),oG(0,d))}),0,(function(b){t[Jy>>2]=b;vC(Nr|0,t[Jy>>2],0);vC(Mo|0,t[Jy>>2],1);vC(sm|0,t[Jy>>2],2);vC(mk|0,t[Jy>>2],3);vC(Ci|0,t[Jy>>2],4);vC(ih|0,t[Jy>>2],5);vC(Wf|0,t[Jy>>2],6);vC(Ue|0,t[Jy>>2],7)}),0,(function(b,d){if(28==(d|0)||32==(d|0)){var c=t[Wc>>2];0==(t[c>>2]|0)?iG(t[t[ec>>2]+8>>2],t[Ac>>2]):(iG(t[c+8>>2],t[Ac>>2]),S(t[Wc>>2]));t[z>>2]=26;jG(0,d);S(t[ec>>2])}else{33==(d|0)?(U(t[Wc>>2],t[t[ec>>2]+8>>2]),U(t[Wc>>2],Gq|0),S(t[ec>>2])):22==(d|0)?V(t[ec>>2],t[b+8>>2]):26==(d|0)&&(t[z>>2]=48,t[rd>>2]=238,t[Ib>>2]=27)}}),0,(function(){var b,d=GI(wx|0);b=d>>2;t[b+3]=hA|0;t[b+5]=60;t[b+8]=1;return d}),0,(function(){var b,d=GI(gg|0);b=d>>2;t[b+1]=fA|0;t[b+2]=4;t[b+3]=eA|0;t[b+4]=dA|0;t[b+6]=102;t[b+5]=212;return d}),0,(function(){var b,d=GI(mw|0);b=d>>2;t[b+3]=yx|0;t[b+5]=2;t[b+8]=1;return d}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=YH(),f=(k=Da++,d[k]=1,Ea[k]=b,t[wz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:for(var g=e,h=g|0,i=g+4|0;;){if(aI(g),4==(t[h>>2]|0)){var m=t[i>>2];3==(m|0)?$H(g,3):4==(m|0)?$H(g,4):5==(m|0)?$H(g,5):1==(m|0)?$H(g,1):7==(m|0)?$H(g,7):0==(m|0)?$H(g,0):2==(m|0)?$H(g,2):6==(m|0)&&$H(g,6)}};case 4:ZH(e);return;default:ua(0,"bad label: "+b)}}catch(n){(!n.f||!(n.id in d))&&aa(n),c[Ea[n.id]](n.value)}}}),0,(function(b,d){6==(d|0)?zG():31==(d|0)?(nG(b,3),BG(0,3,122,b),l[yc]=1,t[z>>2]=110):42==(d|0)?(nG(b,5),BG(0,4,122,b),t[z>>2]=110):32==(d|0)||18==(d|0)||28==(d|0)||21==(d|0)||(t[z>>2]=122)}),0,hG,0,(function(){var b,d=GI(tp|0);b=d>>2;t[b+1]=cy|0;t[b+2]=6;t[b+3]=by|0;t[b+6]=278;return d}),0,(function(b){t[Py>>2]=b;uC(b,2)}),0,(function(b,d){22==(d|0)?V(t[Mb>>2],t[b+8>>2]):32==(d|0)?(iG(t[t[Mb>>2]+8>>2],6),S(t[Mb>>2])):30==(d|0)||26==(d|0)?(t[z>>2]=250,t[rd>>2]=256):29==(d|0)&&(t[z>>2]=74)}),0,(function(){var b,d=GI(Qq|0);b=d>>2;t[b+1]=cA|0;t[b+2]=5;t[b+3]=bA|0;t[b+6]=70;return d}),0,(function(b,d){2==(d|0)?(t[z>>2]=294,t[rd>>2]=260):32==(d|0)?(iG(t[t[Mb>>2]+8>>2],9),S(t[Mb>>2]),t[z>>2]=16):1==(d|0)?(t[z>>2]=198,t[rd>>2]=260):22==(d|0)&&V(t[Mb>>2],t[b+8>>2])}),0,(function(){var b,d=GI(Hw|0);b=d>>2;t[b+1]=Qx|0;t[b+2]=23;t[b+3]=Px|0;t[b+6]=50;t[b+5]=10;return d}),0,(function(){var b,d=GI(Wq|0);b=d>>2;t[b+3]=jz|0;t[b+1]=kz|0;t[b+2]=6;t[b+6]=118;t[b+5]=300;return d}),0,(function(b){t[Ly>>2]=b;uC(b,3)}),0,(function(b,d){var c=t[Ec>>2];19==(d|0)?BG(0,2,122,c):S(c);t[z>>2]=122}),0,UF,0,(function(b){UI(b,Zk|0,kj|0,Jh|0,0);UI(b,qg|0,Fo|0,Ud|0,0);UI(b,Ow|0,Fo|0,$v|0,0);UI(b,zv|0,kj|0,Ek|0,0);UI(b,Eu|0,du|0,Et|0,0);UI(b,dt|0,kj|0,Et|0,0);UI(b,Fs|0,du|0,ns|0,0);UI(b,Yr|0,yr|0,ns|0,0);UI(b,Yr|0,kj|0,ns|0,0)}),0,(function(b,d){var c=t[pc>>2];0!=(c|0)&&(t[rd>>2]=c,t[pc>>2]=0);29==(d|0)?(t[z>>2]=t[rd>>2],bG()):22==(d|0)&&(iG(t[b+8>>2],11),c=t[rd>>2],t[pc>>2]=c,t[Ib>>2]=23,l[Zc]=1,t[Yc>>2]=c,t[rd>>2]=274,t[z>>2]=192)}),0,$D,0,aH,0,(function(b,d){23==(d|0)||22==(d|0)?(BG(0,1,122,t[Dc>>2]),t[z>>2]=122):9==(d|0)?(t[z>>2]=104,t[Ib>>2]=45,t[rd>>2]=280):32==(d|0)?(t[z>>2]=104,t[rd>>2]=122,t[Ib>>2]=33,FG(0,32)):(S(t[Dc>>2]),t[z>>2]=122)}),0,(function(){for(var b=0;;){var d=eC();if(0==(d|0)){break}b=AD(d,b);if(10==(b|0)){break}}}),0,(function(b,d){if(22==(d|0)){V(t[ec>>2],t[b+8>>2])}else{if(28==(d|0)||32==(d|0)){var c=t[Wc>>2];0==(t[c>>2]|0)?iG(t[t[ec>>2]+8>>2],t[Ac>>2]):(iG(t[c+8>>2],t[Ac>>2]),S(t[Wc>>2]));t[z>>2]=74;jG(0,d);S(t[ec>>2])}else{33==(d|0)?(U(t[Wc>>2],t[t[ec>>2]+8>>2]),U(t[Wc>>2],Gq|0),S(t[ec>>2])):26==(d|0)&&(t[z>>2]=48,t[rd>>2]=284,t[Ib>>2]=27)}}}),0,(function(){var b=P(),d=eC();if(0!=(d|0)){for(;;){var c=l[d];if(45==c<<24>>24){for(var e=d+1|0,c=b,d=P(),f=t[d+8>>2],e=YD(e,d);0!=(L(l[e]&255)|0);){e=e+1|0}e=40==l[e]<<24>>24?e+1|0:e;0==(qA(f,Hh|0)|0)?ZD(e,3):0==(qA(f,zr|0)|0)?ZD(e,0):0==(qA(f,Uf|0)|0)&&(f=e,e=P(),YD(f,e),jC(e,Az|0,2),V(c,t[e+8>>2]),Q(e));Q(d)}else{if(!(37==c<<24>>24||34==c<<24>>24)&&0!=(pA(c&255)|0)){c=d;f=b;d=P();YD(c,d);var c=d,e=ba,g=j;j+=80;e=g>>2;0!=(t[Az+16>>2]|0)&&0!=(t[c>>2]|0)&&(sC(g,t[c+8>>2]),t[e+9]=t[Az+24>>2],l[g+40|0]=t[Az+20>>2]&255,0!=(f|0)&&0!=(t[f>>2]|0)&&(t[e+15]=Uf|0,t[e+16]=t[f+8>>2]),tC(g));j=g;Q(d)}}d=eC();if(0==(d|0)){break}}}Q(b)}),0,(function(b){t[Iy>>2]=b;for(b=0;!(vC(t[Wy+(b<<3)>>2],t[Iy>>2],t[Wy+(b<<3)+4>>2]),b=b+1|0,17==(b|0));){}}),0,(function(){var b,d=GI(Vv|0);b=d>>2;t[b+1]=Hz|0;t[b+2]=3;t[b+3]=Gz|0;t[b+6]=282;return d}),0,(function(){var b,d=GI(bq|0);b=d>>2;t[b+1]=ry|0;t[b+2]=9;t[b+3]=qy|0;t[b+6]=84;t[b+5]=14;return d}),0,(function(b,d){if(22==(d|0)){if(l[oc]){l[oc]=0;bG();var c=t[rd>>2];t[z>>2]=c;ab[c](b,22)}else{c=b+8|0,iG(t[c>>2],11),aG(t[c>>2],11),l[oc]=1}}else{28==(d|0)?(t[z>>2]=274,l[oc]=0):32==(d|0)&&(l[oc]&&bG(),c=t[rd>>2],t[z>>2]=c,ab[c](b,32))}}),0,(function(b){UI(b,Pk|0,Fo|0,Eh|0,0)}),0,(function(b,d){22==(d|0)&&iG(t[b+8>>2],12);t[z>>2]=304}),0,(function(b){t[Ky>>2]=b;for(b=0;!(vC(t[lz+(b<<3)>>2],t[Ky>>2],t[lz+(b<<3)+4>>2]),b=b+1|0,28==(b|0));){}}),0,(function(){var b,d=GI(nl|0);b=d>>2;t[b+1]=Zz|0;t[b+2]=6;t[b+3]=Yz|0;t[b+6]=156;return d}),0,(function(b,d){35==(d|0)?l[Jc]=1:36==(d|0)?l[Jc]?l[Jc]=0:t[z>>2]=16:l[Jc]=0}),0,(function(b){UI(b,vo|0,Fo|0,mm|0,0);UI(b,ni|0,Fo|0,Et|0,0)}),0];a.FUNCTION_TABLE=ab;function Hb(b){function d(){var c=0;Ab=ca;a._main&&(nb(qb),c=a.H(b),a.noExitRuntime||nb(rb));if(a.postRun){for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);0<a.postRun.length;){a.postRun.pop()()}}return c}b=b||a.arguments;if(0<xb){return a.h("run() called, but dependencies remain, so not running"),0}if(a.preRun){"function"==typeof a.preRun&&(a.preRun=[a.preRun]);var c=a.preRun;a.preRun=[];for(var e=c.length-1;0<=e;e--){c[e]()}if(0<xb){return 0}}return a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1);d()}),1),0):d()}a.run=a.T=Hb;if(a.preInit){for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;){a.preInit.pop()()}}nb(pb);var CJ=ca;a.noInitialRun&&(CJ=fa);CJ&&Hb()

Module = this.Module;

})();

define("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags.min",[], function(require, exports, module) {

	module.exports = Module;
	module.exports.CTags_parseTempFile = function(filename, contents) {
		filename = "file." + filename.match(/[^.]*$/)[0];
		this.FS_createDataFile("/", filename, contents, true, true);
		logged = "";
		this.CTags_parseFile("/" + filename);
	};
	var logged = "";
	module.exports.getLog = function() {
		return logged.replace(/\n$/, "");
	};
	Module.print = function() {
		arguments = Array.prototype.slice.call(arguments);
		logged += arguments.map(function(a) {
			return typeof a === "object" ? JSON.stringify(a) : a;
		}).join(" ") + "\n";
		console.log.apply(sysConsole, arguments)
	};
	Module.printErr = function() {
		arguments = Array.prototype.slice.call(arguments);
		logged += arguments.map(function(a) {
			return typeof a === "object" ? JSON.stringify(a) : a;
		}).join(" ") + "\n";
		console.err.apply(sysConsole, arguments)
	};

	
});
})();

define("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_ex",[], function(require, exports, module) {
var ctags = require("./ctags.min");

var util = require("./ctags_util");

var MAX_DOCHEAD_LENGTH = 80;

var CTAGS_OPTIONS = [
    '--langdef=js',
    '--langmap=js:.js',
    '--regex-js=/([A-Za-z0-9._$]+)[ \\t]*[:=][ \\t]*\\{/\\1/,object/',
    '--regex-js=/([A-Za-z0-9._$()]+)[ \\t]*[:=][ \\t]*function[ \\t]*\\(/\\1/,function/',
    '--regex-js=/function[ \\t]+([A-Za-z0-9._$]+)[ \\t]*\\(([^)])\\)/\\1/,function/',
    '--regex-js=/([A-Za-z0-9._$]+)[ \\t]*[:=][ \\t]*\\[/\\1/,array/',
    '--regex-js=/([^= ]+)[ \\t]*=[ \\t]*[^"]\'[^\']*/\\1/,string/',
    '--regex-js=/([^= ]+)[ \\t]*=[ \\t]*[^\']"[^"]*/\\1/,string/',
    
    '--langdef=rust',
    '--langmap=rust:.rs',
    '--regex-rust=/[ \\t]*fn[ \\t]+([a-zA-Z0-9_]+)/\\1/f,function/',
    '--regex-rust=/[ \\t]*type[ \\t]+([a-zA-Z0-9_]+)/\\1/T,types/',
    '--regex-rust=/[ \\t]*enum[ \\t]+([a-zA-Z0-9_]+)/\\1/T,types/',
    '--regex-rust=/[ \\t]*struct[ \\t]+([a-zA-Z0-9_]+)/\\1/m,types/',
    '--regex-rust=/[ \\t]*class[ \\t]+([a-zA-Z0-9_]+)/\\1/m,types/',
    '--regex-rust=/[ \\t]*mod[ \\t]+([a-zA-Z0-9_]+)/\\1/m,modules/',
    '--regex-rust=/[ \\t]*const[ \\t]+([a-zA-Z0-9_]+)/\\1/m,consts/',
    '--regex-rust=/[ \\t]*trait[ \\t]+([a-zA-Z0-9_]+)/\\1/m,traits/',
    '--regex-rust=/[ \\t]*impl[ \\t]+([a-zA-Z0-9_]+)/\\1/m,impls/',
    '--regex-rust=/[ \\t]*impl[ \\t]+of[ \\t]([a-zA-Z0-9_]+)/\\1/m,impls/',
    
    '--langmap=PHP:+.inc',
    '--PHP-kinds=+cf',
    '--regex-PHP=/abstract class ([^ ]*)/\\1/c/',
    '--regex-PHP=/interface ([^ ]*)/\\1/c/',
    '--regex-PHP=/(public |static |abstract |protected |private )+function ([^ (]*)/\\2/f/',

    '--regex-make=/-D([^ =]+).+$/\\1/d,definition/',
    
    '--langdef=markdown',
    '--langmap=markdown:.markdown',
    '--regex-markdown=/^#[ \\t]+(.*)/\\1/h,heading1/',
    '--regex-markdown=/^##[ \\t]+(.*)/\\1/h,heading2/',
    '--regex-markdown=/^###[ \\t]+(.*)/\\1/h,heading3/',
    
    '--langdef=ActionScript',
    '--langmap=ActionScript:.as',
    '--regex-ActionScript=/^[ \\t]*[(private|public|static)( \\t)]*function[ \\t]+([A-Za-z0-9_]+)[ \\t]*\\(/\\1/f,function/',
    '--regex-ActionScript=/^[ \\t]*[(public)( \\t)]*function[ \\t]+(set|get)[ \\t]+([A-Za-z0-9_]+)[ \\t]*\\(/\\2/p,property/',
    '--regex-ActionScript=/.*\\.prototype\\.([A-Za-z0-9 ]+)=([ \\t]?)function([ \\t]?)*\\(/\\1/f,function/',
];
var LANGUAGES = module.exports.LANGUAGES = [
    { guessFargs: true, extensions: ["as"], name: "actionscript" },
    { guessFargs: false, extensions: ["asm", "a"], name: "assembly_x86" },
    { guessFargs: true, extensions: ["sh"], name: "sh" },
    { guessFargs: true, extensions: ["js"], name: "javascript" },
    { guessFargs: true, extensions: ["html"], name: "html" },
    { guessFargs: true, extensions: ["coffee"], name: "coffee" },
    { guessFargs: true, extensions: ["bas"]},
    { guessFargs: true, extensions: ["asp"]},
    { guessFargs: true, extensions: ["cpp", "c", "cc", "cxx", "h", "hh", "hpp"], name: "c_cpp" },
    { guessFargs: true, extensions: ["cs"], name: "csharp" },
    { guessFargs: false, extensions: ["e", "ge"], extractDocs: false, name: "eiffel" },
    { guessFargs: true, extensions: ["erl", "hrl"], name: "erlang" },
    { guessFargs: false, extensions: ["f", "for", "ftn", "f77", "f90", "f95"]}, // Fortran
    { guessFargs: true, extensions: ["lisp", "cl", "lsp"]},
    { guessFargs: true, extensions: ["lua"], name: "lua" },
    { guessFargs: false, extensions: ["cob"], name: "cobol" },
    { guessFargs: true, extensions: ["pas", "p"], name: "pascal" },
    { guessFargs: true, extensions: ["scm", "sm", "scheme", "oak"], name: "scheme" },
    { guessFargs: true, extensions: ["pl", "pm"], name: "perl" },
    { guessFargs: false, extensions: ["prolog"], name: "prolog" },
    { guessFargs: false, extensions: ["ltx", "tex", "bib", "sty", "cls", "clo"], name: "latex" },
    { guessFargs: true, extensions: ["php", "php3", "phtml", "inc"], name: "php" },
    { guessFargs: true, extensions: ["py"], name: "python" },
    { guessFargs: false, extensions: ["y", "ym"]},
    { guessFargs: true, extensions: ["java"], name: "java" },
    { guessFargs: true, extensions: ["rb", "ru"], name: "ruby" },
    { guessFargs: true, extensions: ["ss"]}
];

module.exports.languages = LANGUAGES.map(function(l) { return l.name; }).filter(Boolean);
module.exports.extensions = [].concat.apply([], LANGUAGES.map(function(l) { return l.extensions; }));
util.init(module.exports);

module.exports.pathForLanguage = function(language, path) {
    var ext = path.match(/[^./]*$/)[0];
    LANGUAGES.some(function(r) {
        if (r.name == language) {
            if (r.extensions.indexOf(ext) == -1)
                path = "tmp." + r.extensions[0];
            return true;
        }
    });
    return path;
};

module.exports.analyze = function(path, doc, options, callback) {
    if (!doc)
        return callback("No contents");
    
    var lines;
    if (doc.getAllLines) {
        lines = doc.getAllLines();
        doc = doc.getValue();
    }
    else {
        if (doc.getValue)
            doc = doc.getValue();
        lines = doc.split(/\n/);
    }
    
    var result = {
        doc: doc ? util.extractDocumentationAtRow(lines, 0) : undefined,
        properties: {}
    };
    
    var isDone = false;
    var language = getLanguage(path);
    var guessFargs = language && language.guessFargs;
    ctags.CTags_setOnTagEntry(function(name, kind, row, sourceFile, language) {
        analyzeTag(lines, name, kind, row, sourceFile, guessFargs, result.properties);
    });
    
    ctags.CTags_setOnParsingCompleted(function() {
        isDone = true;
        callback(null, result);
    });
    
    var filename = path.match(/[^\/]*$/)[0];
    ctags.FS_createPath("/", "data", true, true);
    try {
        ctags.CTags_parseTempFile(filename, doc);
    } catch (err) {
        if (isDone)
            throw err;
        return callback("Internal error in CTags: " + err);
    }
    if (!isDone) {
        callback(ctags.getLog() || "ctags analysis failed");
        callback = function() {
            throw new Error("Callback called too late");
        };
    }
};

function getLanguage(path) {
    var ext = path.substr(path.lastIndexOf(".") + 1);
    return ext && LANGUAGES.filter(function(l) {
        return l.extensions.indexOf(ext) > -1;
    })[0];
}
    
function analyzeTag(lines, name, kind, row, sourceFile, guessFargs, results) {
    var line = lines[row - 1] || "";
    var doc = util.extractDocumentationAtRow(lines, row - 1);

    var docHead = line.length > MAX_DOCHEAD_LENGTH
        ? line.substr(MAX_DOCHEAD_LENGTH) + "..."
        : line;
    if (docHead.indexOf(name) === -1) // sanity check
        docHead = null;
    var icon = getIconForKind(kind);
    
    var result = {
        row: row - 1,
        doc: doc,
        docHead: docHead,
        kind: kind,
        icon: icon
    };
    if (icon === "method" || icon === "method2") {
        result.guessFargs = guessFargs;
        result.properties = {
            _return: []
        };
    }
    
    results["_" + name] = results["_" + name] || [];
    results["_" + name].push(result);
}

function getIconForKind(kind) {
    switch (kind) {
        case "member": 
            return "property";
        case "function":
            return "method";
        case "prototype":
            return "method2";
        case "class": case "module": case "typedef":
            return "package";
        default:
            return "property2";
    }
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/handler_registry",[], function(require, exports, module) {

var assert = require("c9/assert");

module.exports.HandlerRegistry = function() {
    var handlers = [];
    var supportedLanguages = "";
    var supportedExtensions = "";
    
    return {
        registerHandler: function(handler, options) {
            options = options || {};
            var existing = handlers.filter(function(h) { return h.$source && handler.$source === h.$source; });
            if (existing.length || handlers.indexOf(handler) > -1)
                return;
            
            handler.sender = options.sender;
            if (handler.init)
                handler.init(options, function(err) {
                    if (err)
                        console.error("Error initializing " + handler.$source, err.stack || err);
                });
        
            var languages = handler.languages;
            var extensions = handler.extensions;
            handler.guidName = languages.join("");
            assert(languages && extensions, "Handlers must have a languages and extensions property");
            
            handler.supportedLanguages = "$.";
            handler.supportedExtensions = "$.";
            handlers.push(handler);
            languages.forEach(function(e) {
                supportedLanguages += (supportedLanguages ? "|^" : "^") + e;
                handler.supportedLanguages += "|^" + e + "$";
            });
            extensions.forEach(function(e) {
                supportedExtensions += (supportedExtensions ? "|^" : "^") + e + "$";
                handler.supportedExtensions += "|^" + e + "$";
            });
        },
        
        unregisterHandler: function(source) {
            handlers = handlers.filter(function(h) { return !(h.$source && source === h.$source); });
        },
        
        getHandlerFor: function(path, language) {
            var match = path && path.match(/\.([^/.]*)$/);
            var extension = match && match[1] || "";
            if (!extension.match(supportedExtensions) && !(language || "").match(supportedLanguages))
                return null;
            
            var results = handlers.filter(function(p) {
                if (p.disabled) return false;
                if (language && language.match(p.supportedLanguages)) return true;
                if (p.supportedExtensions && extension.match(p.supportedExtensions)) return true;
                if (p.supportedPaths && path && path.match(p.supportedPaths)) return true;
                return false;
            });
            if (results.length > 1)
                results = results.filter(function(r) { return !r.isGeneric; });
            
            return results[0];
        },
        
        getAllHandlers: function() {
            return handlers;
        }
    
    };
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler",[], function(require, exports, module) {

var asyncForEach = require("plugins/c9.ide.language.core/worker").asyncForEach;
var workerUtil = require("plugins/c9.ide.language/worker_util");
var child_process = typeof process === "undefined" || !process.version
    ? null
    : arguments[0]("child_process");
module.exports = {
    languages: [],
    extensions: [],
    maxCallInterval: 2000,
    CALL_INTERVAL_MIN: 500,
    
    CALL_INTERVAL_BASIC: 1200,
    init: function(options, callback) {
        callback();
    },
    findImports: function(path, value, ast, options, callback) {
        callback();
    },
    analyzeCurrent: function(path, value, ast, options, callback) {
        callback();
    },
    analyzeOthers: function(paths, options, callback) {
        callback();
    },
    analyzeWorkspaceRoot: function(callback) {
        callback();
    },
    analyzeCurrentAll: function(paths, options, callback) {
        var errs = [];
        var results = [];
        var _self = this;
        asyncForEach(
            paths,
            function(path, next) {
                workerUtil.readFile(path, { unsaved: true }, function(err, doc) {
                    if (err) {
                        errs.push(err);
                        results.push(null);
                        return next();
                    }
                    
                    _self.analyzeCurrent(path, doc, null, options, function(err, result) {
                        errs.push(err);
                        results.push(result);
                        next();
                    });
                });
            },
            function() {
                callback(errs, results);
            }
        );
    },
    $lint: function(linter, args, stdin, options, callback) {
        var a = arguments;
        callback = a[4] || a[3] || a[2];
        options = typeof a[3] == "object" && a[3]
            || typeof a[2] == "object" && !(a[2] instanceof Buffer) && a[2];
        stdin = (typeof a[2] == "string" || a[2] instanceof Buffer) && a[2];

        if (!child_process)
            return callback(new Error("Only implemented for server-side plugins"));
        
        options = options || {};
        options.maxBuffer = options.maxBuffer || 200 * 1024;
        options.env = options.env || {};
        var PATH = options.env.PATH || this.defaultEnv && this.defaultEnv.PATH || process.env.PATH;
        options.env.PATH = process.platform === "linux"
            ? PATH + ":/mnt/shared/bin"
            : PATH;
        for (var key in process.env) {
            options.env[key] = options.env[key] != null ? options.env[key] : process.env[key];
        }
        
        try {
            var child = child_process.execFile(
                linter, args, options,
                function(err, stdout, stderr) {
                    if (err && ["ENOENT", "EACCES"].indexOf(err.code) > -1) {
                        err = new Error(err.code + ": No " + (linter === "bash" ? "linter" : linter) + " installation found");
                        err.code = "EFATAL";
                        return callback(err, stdout, stderr);
                    }
                    
                    callback(null, stdout, stderr, err);
                }
            );

            child.stdin.on("error", function(e) {
            });
    
            if (stdin)
                child.stdin.end(stdin);
        }
        catch (err) {
            err.code = "EFATAL";
            callback(err);
        }
    }
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/server_handler_wrapper",[], function(require, exports, module) {
    
    var lastId = 0;
    module.exports.ServerHandlerWrapper = function(descriptor, worker) {
        var PluginBase = require("./jsonalyzer_base_handler");
        var handler = Object.create(PluginBase);
        handler.$source = descriptor.path;
        handler.languages = descriptor.properties.languages;
        handler.extensions = descriptor.properties.extensions;
        handler.maxCallInterval = descriptor.properties.maxCallInterval;
        
        if (descriptor.functions.analyzeCurrent)
            handler.analyzeCurrent = function(path, value, ast, options, callback) {
                callServer({
                    handlerPath: descriptor.path,
                    maxCallInterval: descriptor.properties.maxCallInterval,
                    semaphore: handler.$source,
                    filePath: path,
                    method: "analyzeCurrent",
                    args: [path, null, null, options]
                }, callback);
            };
        if (descriptor.functions.findImports)
            handler.findImports = function(path, value, ast, options, callback) {
                callServer({
                    handlerPath: descriptor.path,
                    maxCallInterval: descriptor.properties.maxCallInterval,
                    filePath: path,
                    method: "findImports",
                    args: [path, null, null, options]
                }, callback);
            };
        if (descriptor.functions.analyzeOthers)
            handler.analyzeOthers = function(paths, options, callback) {
                callServer({
                    handlerPath: descriptor.path,
                    maxCallInterval: descriptor.properties.maxCallInterval,
                    filePath: null, // we're not using collab for these so we don't care
                    method: "analyzeOthers",
                    args: [paths, options]
                }, callback);
            };
        return handler;
    
        function callServer(options, callback) {
            options.id = ++lastId;
            worker.sender.on("jsonalyzerCallServerResult", function onResult(e) {
                if (e.data.id !== options.id)
                    return;
                
                worker.sender.off("jsonalyzerCallServerResult", onResult);

                var err = e.data.result[0];
                if (err && err.code === "EFATAL") {
                    console.error("Fatal error in " + descriptor.path, err);
                    handler.disabled = err;
                }

                callback.apply(null, e.data.result);
            });
            worker.sender.emit("jsonalyzerCallServer", options);
        }
    };
    
});

define("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker",[], function(require, exports, module) {

var baseLanguageHandler = require("plugins/c9.ide.language/base_handler");
var languageWorker = require("plugins/c9.ide.language.core/worker");
var index = require("./semantic_index");
var jumptodef = require("./jumptodef");
var complete = require("./complete");
var outline = require("./outline");
var refactor = require("./refactor");
var highlight = require("./highlight_occurrences");
var scopeAnalyzer = require('plugins/c9.ide.language.javascript/scope_analyzer');
var directoryIndexer = require("./directory_indexer");
var fileIndexer = require("./file_indexer");
var ctagsUtil = require("./ctags/ctags_util");
var ctagsEx = require("./ctags/ctags_ex");
var HandlerRegistry = require("./handler_registry").HandlerRegistry;
var ServerHandlerWrapper = require("./server_handler_wrapper").ServerHandlerWrapper;
require("treehugger/traverse"); // add traversal methods

var worker = module.exports = Object.create(baseLanguageHandler);
var isOnline = false;
var isInWebWorker = typeof window == "undefined" || !window.location || !window.document;
var handlers = new HandlerRegistry();
var handlersServer = new HandlerRegistry();

worker.$isInited = false;
worker.DEBUG = true;
worker.KIND_DEFAULT = scopeAnalyzer.KIND_DEFAULT;
worker.KIND_PACKAGE = scopeAnalyzer.KIND_PACKAGE;

worker.init = function(callback) {
    worker.sender.on("onlinechange", function(event) {
        worker.onOnlineChange(event);
    });
    worker.sender.on("filechange", function(event) {
        worker.onFileChange(event);
    });
    worker.sender.on("dirchange", function(event) {
        worker.onDirChange(event);
    });
    worker.sender.on("jsonalyzerRegister", function(event) {
        worker.loadPlugin(event.data.modulePath, event.data.contents, function(err, plugin) {
            if (err) return console.error(err);
            plugin.$source = event.data.modulePath;
            
            var oldHandler = worker.getHandlerFor(worker.path, worker.language);
            var options = event.data.options || {};
            
            options.sender = worker.sender;
            handlers.registerHandler(plugin, worker, options);
            if (oldHandler !== worker.getHandlerFor(worker.path, worker.language)) {
                index.markStale(oldHandler);
                languageWorker.$lastWorker.onUpdate();
            }
                
            worker.sender.emit("jsonalyzerRegistered",
                { modulePath: event.data.modulePath, err: err });
        });
    });
    worker.sender.on("jsonalyzerRegisterServer", function(event) {
        var oldHandler = worker.getServerHandlerFor(worker.path, worker.language);
        handlersServer.registerHandler(
            new ServerHandlerWrapper(event.data, worker), worker);
        if (oldHandler !== worker.getServerHandlerFor(worker.path, worker.language)) {
            index.markStale(oldHandler);
            var clientHandler = worker.getHandlerFor(worker.path, worker.language);
            if (oldHandler !== clientHandler)
                index.markStale(clientHandler);
            languageWorker.$lastWorker.onUpdate();
        }
    });
    worker.sender.on("jsonalyzerUnregister", function(event) {
        if (window.require)
            window.require.modules[event.data.modulePath] = null;
        handlers.unregisterHandler(event.data.modulePath);
        worker.sender.emit("jsonalyzerUnregistered", { modulePath: event.data.modulePath });
    });
    worker.sender.on("jsonalyzerUnregisterServer", function(event) {
        handlersServer.unregisterHandler(event.data.modulePath);
        worker.sender.emit("jsonalyzerUnregisteredServer", { modulePath: event.data.modulePath });
    });
    
    directoryIndexer.init(this);
    fileIndexer.init(this);
    index.init(this);
    jumptodef.init(this);
    complete.init(this);
    outline.init(this);
    refactor.init(this);
    highlight.init(this);
    ctagsUtil.init(ctagsEx, this);
    callback();
};

worker.loadPlugin = function(modulePath, contents, callback) {
    if (contents) {
        contents = contents.replace(/^(define\()(function|["'])/m, function(_, def, arg1) {
            if (arg1 == "function")
                return def + "'" + modulePath + "',[]," + arg1;
            return _;
        });
        try {
            eval.call(null, contents + "\n//@ sourceURL=" + modulePath);
        } catch (e) {
            return callback("Could not load language handler " + modulePath + ": " + e);
        }
    }
    var handler;
    try {
        handler = require(modulePath);
        if (!handler)
            throw new Error("Unable to load required module: " + modulePath);
    } catch (e) {
        if (isInWebWorker)
            return callback("Could not load language handler " + modulePath + ": " + e);
        return require([modulePath], function(handler) {
            if (!handler)
                return callback("Could not load language handler " + modulePath);
            callback(null, handler);
        });
    }
    callback(null, handler);
};

worker.handlesLanguage = function(language, part) {
    return (!part || !part.index) && this.getHandlerFor(this.path, language);
};

worker.onDocumentOpen = function(path, doc, oldPath, callback) {
    if (this.$isInited && !this.getHandlerFor(path, null))
        return callback();
    fileIndexer.analyzeOthers([path]);
    callback();
};

worker.analyze = function(doc, ast, options, callback) {
    if (options.minimalAnalysis && index.get(worker.path) || !worker.path)
        return callback();
    var fullDoc = this.doc.getValue();
    this.language = this.doc.$language;
        
    fileIndexer.analyzeCurrent(worker.path, fullDoc, ast, options, function(err, result, imports, markers) {
        if (err)
            console.error("[jsonalyzer] Warning: could not analyze " + worker.path + ": " + (err.stack || err));
        if (imports && imports.length)
            fileIndexer.analyzeOthers(imports, true);
        
        callback(markers);
    });
};

worker.complete = complete.complete.bind(complete);

worker.outline = outline.outline.bind(outline);

worker.jumpToDefinition = jumptodef.jumpToDefinition.bind(jumptodef);

worker.getRefactorings = refactor.getRefactorings.bind(refactor);

worker.getRenamePositions = refactor.getRenamePositions.bind(refactor);

worker.commitRename = refactor.commitRename.bind(refactor);

worker.highlightOccurrences = highlight.highlightOccurrences.bind(highlight);

worker.onOnlineChange = function(event) {
    isOnline = event.data.isOnline;
},

worker.onFileChange = function(event) {
    if (worker.disabled)
        return;
    var path = event.data.path.replace(/^\/((?!workspace)[^\/]+\/[^\/]+\/)?workspace\//, "");
    
    if (!this.getHandlerFor(path, null))
        return;
    
    if (event.data.isSave && path === this.path)
        return fileIndexer.analyzeCurrent(path, event.data.value, null, { isSave: true }, function() {});

    index.removeByPath(path);
    fileIndexer.analyzeOthers([path]);
};

worker.onDirChange = function(event) {
    directoryIndexer.enqueue(event.data.path);
};

worker.getHandlerFor = function(path, language) {
    language = language || (worker.path === path && worker.language);
    
    return handlers.getHandlerFor(path, language)
        || this.getServerHandlerFor(path, language);
};

worker.getServerHandlerFor = function(path, language) {
    language = language || (worker.path === path && worker.language);
    
    return handlersServer.getHandlerFor(path, language);
};

worker.getAllHandlers = function() {
    return handlers.getAllHandlers();
};

worker.getHandlerRegistry = function() {
    return handlers;
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_html",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var BaseHandler = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var handler = module.exports = Object.create(BaseHandler);

handler.extensions = ["htm", "html"];
handler.languages = ["html"];
handler.maxCallInterval = handler.CALL_INTERVAL_BASIC;

var TAGS = [
    { regex: /(?:^|\n)\s*<(xml|html)\b/g, kind: "package" },
    { regex: /(?:^|\n)\s*<(form|h1|body|head)\b/g, kind: "method", indent: 1 },
    { regex: /\sng-app=["']([A-Za-z0-9$_\.]+)/g, kind: "property", indent: 1 },
    { regex: /\sng-controller=["']([A-Za-z0-9$_\.]+)/g, kind: "property", indent: 1 },
    { regex: /\sng-repeat="[^\"]+ in ([^\"]+)/g, kind: "property2", indent: 1 },
    { regex: /\sng-repeat='[^\']+ in ([^\']+)/g, kind: "property2", indent: 1 },
    { regex: /\sng-click=["']([A-Za-z0-9$_\.]+)/g, kind: "property2", indent: 1 },
    { regex: /\sng-model=["']([A-Za-z0-9$_\.]+)/g, kind: "property2", indent: 1 },
    { regex: /\sdata-bind="[^"]*\b(?:foreach|click|value|checked):\s*(?:\$root\.)?([A-Za-z0-9$_\.]+)/g, kind: "property2", indent: 1 },
    { regex: /\sdata-bind='[^']*\b(?:foreach|click|value|checked):\s*(?:\$root\.)?([A-Za-z0-9$_\.]+)/g, kind: "property2", indent: 1 },
];
var GUESS_FARGS = false;
var EXTRACT_DOCS = false;

handler.init = function(options, callback) {
    callback();
};

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "" || doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });
    for (var id in results) {
        results[id].forEach(function(r) {
            r.noComplete = true;
        });
    }
    
    callback(null, { properties: results });
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_make",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)([A-Za-z0-9 \.].*?)\s*:(?!=)/g, kind: "property" },
    { regex: /(?:^|\n)([A-Za-z0-9].*?)\s*:=/g, kind: "property2" }
];
var GUESS_FARGS = false;
var EXTRACT_DOCS = false;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["makefile"];

handler.extensions = [];

handler.supportedPaths = "(^|\/)Makefile.*";

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(
            path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });
    callback(null, { properties: results });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_go",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*package\s+([^\s\(]+)/g, kind: "package" },
    { regex: /(?:^|\n)\s*type\s+([^\s\(]+)/g, kind: "method2", indent: 1 },
    { regex: /(?:^|\n)\s*func\s+([^\s\r\(]+)/g, kind: "method", indent: 1 },
    {
        regex: new RegExp(
            "(?:^|\\n)\\s*import\\s+([^ \\(]+)"
        ),
        kind: "import"
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["golang"];

handler.extensions = ["go"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    var serverHandler = jsonalyzer.getServerHandlerFor(path, "go");
    if (options.service || !serverHandler)
        return callback(null, { properties: results });
    
    serverHandler.analyzeCurrent(path, doc, ast, options, function(err, summary, markers) {
        if (err && err.code === "ESUPERSEDED")
            return callback(err);
        if (err)
            console.error(err.stack || err);
        return callback(null, { properties: results }, markers);
    });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_ctags",[], function(require, exports, module) {

var index = require("plugins/c9.ide.language.jsonalyzer/worker/semantic_index");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var ctags = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_ex");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");
var asyncForEach = require("plugins/c9.ide.language.core/worker").asyncForEach;
var workerUtil = require("plugins/c9.ide.language/worker_util");

var handler = module.exports = Object.create(PluginBase);

var IDLE_TIME = 50;

handler.languages = ctags.languages;

handler.extensions = ctags.extensions;

handler.isGeneric = true;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback();
    if ((options.service === "complete" || options.isSave) && index.get(path))
        return callback(null, index.get(path));
    if (options.language)
        path = ctags.pathForLanguage(options.language, path);
    ctags.analyze(path, doc, options, callback);
};

handler.analyzeOthers = function(paths, options, callback) {
    var errs = [];
    var results = [];
    var _self = this;
    asyncForEach(
        paths,
        function(path, next) {
            workerUtil.readFile(path, { unsaved: true }, function(err, doc) {
                if (err) {
                    errs.push(err);
                    results.push(null);
                    return next();
                }
                
                _self.analyzeCurrent(path, doc, null, {}, function(err, result) {
                    errs.push(err);
                    results.push(result);
                    next();
                });
            });
        },
        function() {
            callback(errs, results);
        }
    );
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_rb",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*module\s+([^ \(]+)/g, kind: "package" },
    { regex: /(?:^|\n)\s*class\s+([^ \(]+)/g, kind: "package" },
    { regex: /(?:^|\n)\s*def\s+([^ \(]+)/g, kind: "method" },
    {
        regex: new RegExp(
            "(?:^|\\n)\\s*include\\s+([^ \\(]+)"
        ),
        kind: "import"
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["ruby"];

handler.extensions = ["rb"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    var serverHandler = jsonalyzer.getServerHandlerFor(path, "ruby");
    if (options.service || !serverHandler)
        return callback(null, { properties: results });
    
    serverHandler.analyzeCurrent(path, doc, ast, options, function(err, summary, markers) {
        if (err && err.code === "ESUPERSEDED")
            return callback(err);
        if (err)
            console.error(err.stack || err);
        return callback(null, { properties: results }, markers);
    });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_sh",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*([A-Za-z0-9_]+)\(\)/g, kind: "method" },
    { regex: /(?:^|\n)\s*(\.|source)\s+([A-Za-z0-9_]+)/g, kind: "import" }
];
var GUESS_FARGS = false;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["sh"];

handler.extensions = ["sh"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(
            path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    var serverHandler = jsonalyzer.getServerHandlerFor(path, "sh");
    if (options.service || !serverHandler)
        return callback(null, { properties: results });
    
    serverHandler.analyzeCurrent(path, doc, ast, options, function(err, summary, markers) {
        if (err && err.code === "ESUPERSEDED")
            return callback(err);
        if (err)
            console.error(err.stack || err);
        return callback(null, { properties: results }, markers);
    });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_php",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*(?:abstract\s+)?class ([^ ]*)/g, kind: "package" },
    { regex: /(?:^|\n)\s*interface ([^ ]*)/g, kind: "package" },
    {
        regex: /(?:^|\n)\s*(?:public\s+|static\s+|abstract\s+|protected\s+|private\s+|final\s+)*function ([^ (]*)/g,
        kind: "method"
    },
    {
        regex: new RegExp(
            "(?:^|\n)\s*include\\("
            + "(?:\\$\\w+(?:\\[[\\w']+\\])?)?"
            + "(?:\\s*\\.\\s*)?",
            "g"
        ),
        kind: "import"
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["php"];

handler.extensions = ["php"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    var serverHandler = jsonalyzer.getServerHandlerFor(path, "php");
    if (options.service || !serverHandler)
        return callback(null, { properties: results });
    
    serverHandler.analyzeCurrent(path, doc, ast, options, function(err, summary, markers) {
        if (err && err.code === "ESUPERSEDED")
            return callback(err);
        if (err)
            console.error(err.stack || err);
        return callback(null, { properties: results }, markers);
    });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_md",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /^# (.*?)[#\s]*$/gm, kind: "property" },
    { regex: /^([A-Za-z0-9].*?)[ \t]*\n={2,}$/gm, kind: "property" },
    { regex: /^#{3,} (.*?)[# \t]*$/gm, kind: "property2", indent: 2 },
    { regex: /^([A-Za-z0-9].*?)[ \t]*\n-{3,}$/gm, kind: "property2", indent: 2 },
    { regex: /^#{2} (.*?)[# \t]*$/gm, kind: "property2", indent: 1 },
    { regex: /^([A-Za-z0-9].*?)[ \t]*\n-{2}$/gm, kind: "property2", indent: 1 },
];
var GUESS_FARGS = false;
var EXTRACT_DOCS = false;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["markdown"];

handler.extensions = ["md", "markdown"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(
            path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });
    callback(null, { properties: results });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.javascript.infer/path",[], function(require, exports, module) {

function getBasePath(file, workspaceDir) {
    if (file.substr(0, workspaceDir.length) === workspaceDir)
        file = file.substr(workspaceDir.length + 1);
    return file.replace(/\/?[^\/]*$/, "");
}

function canonicalizePath(path, basePath) {
    if (basePath && isRelativePath(path))
        path = basePath + "/" + path;
    return normalizePath(path).replace(/^\.\//, "");
}

function isRelativePath(path) {
    return !!path.match(/^\.\.\/|^\.\//);
}

function isAbsolutePath(path) {
    return !!path.match(/^\//);
}

function uncanonicalizePath(path, basePath) {
    if (basePath === "")
        return "./" + path;
    var pathParts = path.split("/");
    var basePathParts = basePath.split("/");
    for (var common = 0; common < basePathParts.length; common++)
        if (basePathParts[common] !== pathParts[common])
            break;
    var dirsUp = pathParts.length - 1 - common;
    var resultParts = [];
    for (var i = 0; i < dirsUp; i++)
        resultParts.push("..");
    if (!dirsUp)
        resultParts.push(".");
    for (var j = common; j < pathParts.length; j++)
        resultParts.push(pathParts[j]);
    return resultParts.join("/");
}

function normalizePath(path) {
    var isAbsolute = path.charAt(0) === '/',
        trailingSlash = path.substr(-1) === '/';

    path = normalizePathArray(path.split('/').filter(function(p) {
        return !!p;
    }), !isAbsolute).join('/');

    if (!path && !isAbsolute) {
        path = '.';
    }
    if (path && trailingSlash) {
        path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
}

function normalizePathArray(parts, allowAboveRoot) {
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
            parts.splice(i, 1);
        }
        else if (last === '..') {
            parts.splice(i, 1);
            up++;
        }
        else if (up) {
            parts.splice(i, 1);
            up--;
        }
    }
    if (allowAboveRoot) {
        for (; up--; up) {
            parts.unshift('..');
        }
    }

    return parts;
}

exports.canonicalizePath = canonicalizePath;
exports.uncanonicalizePath = uncanonicalizePath;
exports.getBasePath = getBasePath;
exports.isRelativePath = isRelativePath;
exports.isAbsolutePath = isAbsolutePath;
exports.normalizePath = normalizePath;

});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_js",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");
var pathUtil = require("plugins/c9.ide.language.javascript.infer/path");

var TAGS = [
    {
        regex: /function\s*([A-Za-z0-9$_]+)\s*\(/g,
        kind: "unknown2"
    },
    {
        regex: /exports\.([A-Za-z0-9$_]+)\s*=\s*function\b/g,
        kind: "unknown2"
    },
    {
        regex: /\s(\w+)\s*:\s*\w+(?:\s|,)/g,
        kind: "unknown2",
        docOnly: true
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.extensions = ["js", "jsx"];

handler.languages = ["javascript", "jsx"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, EXTRACT_DOCS, GUESS_FARGS, results);
    });
    for (var p in results) {
        if (results[p][0])
            results[p][0].kind = null;
    }
    callback(null, { properties: results });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    var openFiles = ctagsUtil.findMatchingOpenFiles(path);
    var astImports = findImportsInAST(path, ast);

    callback(null, openFiles.concat(astImports));
};

function findImportsInAST(path, ast) {
    if (!ast)
        return [];
    
    return []; // Don't import anything now that tern does this for us
    
    var basePath = path.match(/^(.*?)(\/[^\/]+)?$/)[1];
    return ast.collectTopDown(
        'Call(Var("require"), [String(required)])', function(b) {
            var name = b.required.value;
            if (name.match(/^text!/))
                return;
            var isFilePath = pathUtil.isAbsolutePath(name) || pathUtil.isRelativePath(name);
            if (!isFilePath)
                name = guessFilePath(basePath, name);
            if (!name)
                return;
            
            var result = isFilePath ? pathUtil.canonicalizePath(name, basePath) : "js_p:" + name;
            if (isFilePath && !result.match(/\.js$/))
                result += ".js";
            return result;
        }
    ).toArray();
}

function guessFilePath(basePath, importPath) {
    var baseDir = importPath.match(/[^\/]+/);
    if (!baseDir)
        return;
    var i = basePath.indexOf(baseDir[0]);
    if (i === -1)
        return;
    return basePath.substr(0, i) + importPath;
}

});

define("plugins/c9.ide.language.javascript.eslint/worker/eslint_browserified",[], function() { return /******/ (function(modules) { // webpackBootstrap
 	var installedModules = {};
 	function __webpack_require__(moduleId) {
 		if(installedModules[moduleId]) {
 			return installedModules[moduleId].exports;
 		}
 		var module = installedModules[moduleId] = {
 			i: moduleId,
 			l: false,
 			exports: {}
 		};
 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
 		module.l = true;
 		return module.exports;
 	}
 	__webpack_require__.m = modules;
 	__webpack_require__.c = installedModules;
 	__webpack_require__.d = function(exports, name, getter) {
 		if(!__webpack_require__.o(exports, name)) {
 			Object.defineProperty(exports, name, {
 				configurable: false,
 				enumerable: true,
 				get: getter
 			});
 		}
 	};
 	__webpack_require__.n = function(module) {
 		var getter = module && module.__esModule ?
 			function getDefault() { return module['default']; } :
 			function getModuleExports() { return module; };
 		__webpack_require__.d(getter, 'a', getter);
 		return getter;
 	};
 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
 	__webpack_require__.p = "";
 	return __webpack_require__(__webpack_require__.s = 173);
 })
 ([
 (function(module, exports, __webpack_require__) {

"use strict";
var esutils = __webpack_require__(68);
var espree = __webpack_require__(69);
var anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/;
var anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/;
var arrayOrTypedArrayPattern = /Array$/;
var arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;
var bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;
var breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/;
var thisTagPattern = /^[\s*]*@this/m;

var COMMENTS_IGNORE_PATTERN = /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/;
var LINEBREAKS = new Set(["\r\n", "\r", "\n", "\u2028", "\u2029"]);
var LINEBREAK_MATCHER = /\r\n|[\r\n\u2028\u2029]/;
var SHEBANG_MATCHER = /^#!([^\r\n]+)/;
var STATEMENT_LIST_PARENTS = new Set(["Program", "BlockStatement", "SwitchCase"]);
function isModifyingReference(reference, index, references) {
	var identifier = reference.identifier;
	var modifyingDifferentIdentifier = index === 0 || references[index - 1].identifier !== identifier;

	return identifier && reference.init === false && reference.isWrite() && modifyingDifferentIdentifier;
}
function startsWithUpperCase(s) {
	return s[0] !== s[0].toLocaleLowerCase();
}
function isES5Constructor(node) {
	return node.id && startsWithUpperCase(node.id.name);
}
function getUpperFunction(node) {
	while (node) {
		if (anyFunctionPattern.test(node.type)) {
			return node;
		}
		node = node.parent;
	}
	return null;
}
function isFunction(node) {
	return Boolean(node && anyFunctionPattern.test(node.type));
}
function isLoop(node) {
	return Boolean(node && anyLoopPattern.test(node.type));
}
function isInLoop(node) {
	while (node && !isFunction(node)) {
		if (isLoop(node)) {
			return true;
		}

		node = node.parent;
	}

	return false;
}
function isNullOrUndefined(node) {
	return module.exports.isNullLiteral(node) || node.type === "Identifier" && node.name === "undefined" || node.type === "UnaryExpression" && node.operator === "void";
}
function isCallee(node) {
	return node.parent.type === "CallExpression" && node.parent.callee === node;
}
function isReflectApply(node) {
	return node.type === "MemberExpression" && node.object.type === "Identifier" && node.object.name === "Reflect" && node.property.type === "Identifier" && node.property.name === "apply" && node.computed === false;
}
function isArrayFromMethod(node) {
	return node.type === "MemberExpression" && node.object.type === "Identifier" && arrayOrTypedArrayPattern.test(node.object.name) && node.property.type === "Identifier" && node.property.name === "from" && node.computed === false;
}
function isMethodWhichHasThisArg(node) {
	while (node) {
		if (node.type === "Identifier") {
			return arrayMethodPattern.test(node.name);
		}
		if (node.type === "MemberExpression" && !node.computed) {
			node = node.property;
			continue;
		}

		break;
	}

	return false;
}
function negate(f) {
	return function (token) {
		return !f(token);
	};
}
function hasJSDocThisTag(node, sourceCode) {
	var jsdocComment = sourceCode.getJSDocComment(node);

	if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {
		return true;
	}
	return sourceCode.getCommentsBefore(node).some(function (comment) {
		return thisTagPattern.test(comment.value);
	});
}
function isParenthesised(sourceCode, node) {
	var previousToken = sourceCode.getTokenBefore(node),
		nextToken = sourceCode.getTokenAfter(node);

	return Boolean(previousToken && nextToken) && previousToken.value === "(" && previousToken.range[1] <= node.range[0] && nextToken.value === ")" && nextToken.range[0] >= node.range[1];
}
function isArrowToken(token) {
	return token.value === "=>" && token.type === "Punctuator";
}
function isCommaToken(token) {
	return token.value === "," && token.type === "Punctuator";
}
function isSemicolonToken(token) {
	return token.value === ";" && token.type === "Punctuator";
}
function isColonToken(token) {
	return token.value === ":" && token.type === "Punctuator";
}
function isOpeningParenToken(token) {
	return token.value === "(" && token.type === "Punctuator";
}
function isClosingParenToken(token) {
	return token.value === ")" && token.type === "Punctuator";
}
function isOpeningBracketToken(token) {
	return token.value === "[" && token.type === "Punctuator";
}
function isClosingBracketToken(token) {
	return token.value === "]" && token.type === "Punctuator";
}
function isOpeningBraceToken(token) {
	return token.value === "{" && token.type === "Punctuator";
}
function isClosingBraceToken(token) {
	return token.value === "}" && token.type === "Punctuator";
}
function isCommentToken(token) {
	return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
}
function isKeywordToken(token) {
	return token.type === "Keyword";
}
function getOpeningParenOfParams(node, sourceCode) {
	return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);
}
function createGlobalLinebreakMatcher() {
	return new RegExp(LINEBREAK_MATCHER.source, "g");
}
function equalTokens(left, right, sourceCode) {
	var tokensL = sourceCode.getTokens(left);
	var tokensR = sourceCode.getTokens(right);

	if (tokensL.length !== tokensR.length) {
		return false;
	}
	for (var i = 0; i < tokensL.length; ++i) {
		if (tokensL[i].type !== tokensR[i].type || tokensL[i].value !== tokensR[i].value) {
			return false;
		}
	}

	return true;
}
module.exports = {
	COMMENTS_IGNORE_PATTERN: COMMENTS_IGNORE_PATTERN,
	LINEBREAKS: LINEBREAKS,
	LINEBREAK_MATCHER: LINEBREAK_MATCHER,
	SHEBANG_MATCHER: SHEBANG_MATCHER,
	STATEMENT_LIST_PARENTS: STATEMENT_LIST_PARENTS,
	isTokenOnSameLine: function isTokenOnSameLine(left, right) {
		return left.loc.end.line === right.loc.start.line;
	},


	isNullOrUndefined: isNullOrUndefined,
	isCallee: isCallee,
	isES5Constructor: isES5Constructor,
	getUpperFunction: getUpperFunction,
	isFunction: isFunction,
	isLoop: isLoop,
	isInLoop: isInLoop,
	isArrayFromMethod: isArrayFromMethod,
	isParenthesised: isParenthesised,
	createGlobalLinebreakMatcher: createGlobalLinebreakMatcher,
	equalTokens: equalTokens,

	isArrowToken: isArrowToken,
	isClosingBraceToken: isClosingBraceToken,
	isClosingBracketToken: isClosingBracketToken,
	isClosingParenToken: isClosingParenToken,
	isColonToken: isColonToken,
	isCommaToken: isCommaToken,
	isCommentToken: isCommentToken,
	isKeywordToken: isKeywordToken,
	isNotClosingBraceToken: negate(isClosingBraceToken),
	isNotClosingBracketToken: negate(isClosingBracketToken),
	isNotClosingParenToken: negate(isClosingParenToken),
	isNotColonToken: negate(isColonToken),
	isNotCommaToken: negate(isCommaToken),
	isNotOpeningBraceToken: negate(isOpeningBraceToken),
	isNotOpeningBracketToken: negate(isOpeningBracketToken),
	isNotOpeningParenToken: negate(isOpeningParenToken),
	isNotSemicolonToken: negate(isSemicolonToken),
	isOpeningBraceToken: isOpeningBraceToken,
	isOpeningBracketToken: isOpeningBracketToken,
	isOpeningParenToken: isOpeningParenToken,
	isSemicolonToken: isSemicolonToken,
	isStringLiteral: function isStringLiteral(node) {
		return node.type === "Literal" && typeof node.value === "string" || node.type === "TemplateLiteral";
	},
	isBreakableStatement: function isBreakableStatement(node) {
		return breakableTypePattern.test(node.type);
	},
	getLabel: function getLabel(node) {
		if (node.parent.type === "LabeledStatement") {
			return node.parent.label.name;
		}
		return null;
	},
	getModifyingReferences: function getModifyingReferences(references) {
		return references.filter(isModifyingReference);
	},
	isSurroundedBy: function isSurroundedBy(val, character) {
		return val[0] === character && val[val.length - 1] === character;
	},
	isDirectiveComment: function isDirectiveComment(node) {
		var comment = node.value.trim();

		return node.type === "Line" && comment.indexOf("eslint-") === 0 || node.type === "Block" && (comment.indexOf("global ") === 0 || comment.indexOf("eslint ") === 0 || comment.indexOf("eslint-") === 0);
	},
	getTrailingStatement: esutils.ast.trailingStatement,
	getVariableByName: function getVariableByName(initScope, name) {
		var scope = initScope;

		while (scope) {
			var variable = scope.set.get(name);

			if (variable) {
				return variable;
			}

			scope = scope.upper;
		}

		return null;
	},
	isDefaultThisBinding: function isDefaultThisBinding(node, sourceCode) {
		if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {
			return false;
		}
		var isAnonymous = node.id === null;

		while (node) {
			var parent = node.parent;

			switch (parent.type) {
				case "LogicalExpression":
				case "ConditionalExpression":
					node = parent;
					break;
				case "ReturnStatement":
					{
						var func = getUpperFunction(parent);

						if (func === null || !isCallee(func)) {
							return true;
						}
						node = func.parent;
						break;
					}
				case "ArrowFunctionExpression":
					if (node !== parent.body || !isCallee(parent)) {
						return true;
					}
					node = parent.parent;
					break;
				case "Property":
				case "MethodDefinition":
					return parent.value !== node;
				case "AssignmentExpression":
				case "AssignmentPattern":
					if (parent.left.type === "MemberExpression") {
						return false;
					}
					if (isAnonymous && parent.left.type === "Identifier" && startsWithUpperCase(parent.left.name)) {
						return false;
					}
					return true;
				case "VariableDeclarator":
					return !(isAnonymous && parent.init === node && parent.id.type === "Identifier" && startsWithUpperCase(parent.id.name));
				case "MemberExpression":
					return parent.object !== node || parent.property.type !== "Identifier" || !bindOrCallOrApplyPattern.test(parent.property.name) || !isCallee(parent) || parent.parent.arguments.length === 0 || isNullOrUndefined(parent.parent.arguments[0]);
				case "CallExpression":
					if (isReflectApply(parent.callee)) {
						return parent.arguments.length !== 3 || parent.arguments[0] !== node || isNullOrUndefined(parent.arguments[1]);
					}
					if (isArrayFromMethod(parent.callee)) {
						return parent.arguments.length !== 3 || parent.arguments[1] !== node || isNullOrUndefined(parent.arguments[2]);
					}
					if (isMethodWhichHasThisArg(parent.callee)) {
						return parent.arguments.length !== 2 || parent.arguments[0] !== node || isNullOrUndefined(parent.arguments[1]);
					}
					return true;
				default:
					return true;
			}
		}
		return true;
	},
	getPrecedence: function getPrecedence(node) {
		switch (node.type) {
			case "SequenceExpression":
				return 0;

			case "AssignmentExpression":
			case "ArrowFunctionExpression":
			case "YieldExpression":
				return 1;

			case "ConditionalExpression":
				return 3;

			case "LogicalExpression":
				switch (node.operator) {
					case "||":
						return 4;
					case "&&":
						return 5;
				}

			case "BinaryExpression":

				switch (node.operator) {
					case "|":
						return 6;
					case "^":
						return 7;
					case "&":
						return 8;
					case "==":
					case "!=":
					case "===":
					case "!==":
						return 9;
					case "<":
					case "<=":
					case ">":
					case ">=":
					case "in":
					case "instanceof":
						return 10;
					case "<<":
					case ">>":
					case ">>>":
						return 11;
					case "+":
					case "-":
						return 12;
					case "*":
					case "/":
					case "%":
						return 13;
					case "**":
						return 15;
				}

			case "UnaryExpression":
			case "AwaitExpression":
				return 16;

			case "UpdateExpression":
				return 17;

			case "CallExpression":
				return 18;

			case "NewExpression":
				return 19;

			default:
				return 20;
		}
	},
	isEmptyBlock: function isEmptyBlock(node) {
		return Boolean(node && node.type === "BlockStatement" && node.body.length === 0);
	},
	isEmptyFunction: function isEmptyFunction(node) {
		return isFunction(node) && module.exports.isEmptyBlock(node.body);
	},
	getStaticPropertyName: function getStaticPropertyName(node) {
		var prop = void 0;

		switch (node && node.type) {
			case "Property":
			case "MethodDefinition":
				prop = node.key;
				break;

			case "MemberExpression":
				prop = node.property;
				break;
		}

		switch (prop && prop.type) {
			case "Literal":
				return String(prop.value);

			case "TemplateLiteral":
				if (prop.expressions.length === 0 && prop.quasis.length === 1) {
					return prop.quasis[0].value.cooked;
				}
				break;

			case "Identifier":
				if (!node.computed) {
					return prop.name;
				}
				break;
		}

		return null;
	},
	getDirectivePrologue: function getDirectivePrologue(node) {
		var directives = [];
		if (node.type === "Program" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression" ||
		node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement") {
			var statements = node.type === "Program" ? node.body : node.body.body;

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = statements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var statement = _step.value;

					if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal") {
						directives.push(statement);
					} else {
						break;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}

		return directives;
	},
	isDecimalInteger: function isDecimalInteger(node) {
		return node.type === "Literal" && typeof node.value === "number" && /^(0|[1-9]\d*)$/.test(node.raw);
	},
	getFunctionNameWithKind: function getFunctionNameWithKind(node) {
		var parent = node.parent;
		var tokens = [];

		if (parent.type === "MethodDefinition" && parent.static) {
			tokens.push("static");
		}
		if (node.async) {
			tokens.push("async");
		}
		if (node.generator) {
			tokens.push("generator");
		}

		if (node.type === "ArrowFunctionExpression") {
			tokens.push("arrow", "function");
		} else if (parent.type === "Property" || parent.type === "MethodDefinition") {
			if (parent.kind === "constructor") {
				return "constructor";
			}
			if (parent.kind === "get") {
				tokens.push("getter");
			} else if (parent.kind === "set") {
				tokens.push("setter");
			} else {
				tokens.push("method");
			}
		} else {
			tokens.push("function");
		}

		if (node.id) {
			tokens.push("'" + node.id.name + "'");
		} else {
			var name = module.exports.getStaticPropertyName(parent);

			if (name) {
				tokens.push("'" + name + "'");
			}
		}

		return tokens.join(" ");
	},
	getFunctionHeadLoc: function getFunctionHeadLoc(node, sourceCode) {
		var parent = node.parent;
		var start = null;
		var end = null;

		if (node.type === "ArrowFunctionExpression") {
			var arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);

			start = arrowToken.loc.start;
			end = arrowToken.loc.end;
		} else if (parent.type === "Property" || parent.type === "MethodDefinition") {
			start = parent.loc.start;
			end = getOpeningParenOfParams(node, sourceCode).loc.start;
		} else {
			start = node.loc.start;
			end = getOpeningParenOfParams(node, sourceCode).loc.start;
		}

		return {
			start: Object.assign({}, start),
			end: Object.assign({}, end)
		};
	},
	getParenthesisedText: function getParenthesisedText(sourceCode, node) {
		var leftToken = sourceCode.getFirstToken(node);
		var rightToken = sourceCode.getLastToken(node);

		while (sourceCode.getTokenBefore(leftToken) && sourceCode.getTokenBefore(leftToken).type === "Punctuator" && sourceCode.getTokenBefore(leftToken).value === "(" && sourceCode.getTokenAfter(rightToken) && sourceCode.getTokenAfter(rightToken).type === "Punctuator" && sourceCode.getTokenAfter(rightToken).value === ")") {
			leftToken = sourceCode.getTokenBefore(leftToken);
			rightToken = sourceCode.getTokenAfter(rightToken);
		}

		return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);
	},
	couldBeError: function couldBeError(node) {
		switch (node.type) {
			case "Identifier":
			case "CallExpression":
			case "NewExpression":
			case "MemberExpression":
			case "TaggedTemplateExpression":
			case "YieldExpression":
			case "AwaitExpression":
				return true; // possibly an error object.

			case "AssignmentExpression":
				return module.exports.couldBeError(node.right);

			case "SequenceExpression":
				{
					var exprs = node.expressions;

					return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);
				}

			case "LogicalExpression":
				return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);

			case "ConditionalExpression":
				return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);

			default:
				return false;
		}
	},
	isNullLiteral: function isNullLiteral(node) {
		return node.type === "Literal" && node.value === null && !node.regex;
	},
	canTokensBeAdjacent: function canTokensBeAdjacent(leftValue, rightValue) {
		var leftToken = void 0;

		if (typeof leftValue === "string") {
			var leftTokens = espree.tokenize(leftValue, { ecmaVersion: 2015 });

			leftToken = leftTokens[leftTokens.length - 1];
		} else {
			leftToken = leftValue;
		}

		var rightToken = typeof rightValue === "string" ? espree.tokenize(rightValue, { ecmaVersion: 2015 })[0] : rightValue;

		if (leftToken.type === "Punctuator" || rightToken.type === "Punctuator") {
			if (leftToken.type === "Punctuator" && rightToken.type === "Punctuator") {
				var PLUS_TOKENS = new Set(["+", "++"]);
				var MINUS_TOKENS = new Set(["-", "--"]);

				return !(PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) || MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value));
			}
			return true;
		}

		if (leftToken.type === "String" || rightToken.type === "String" || leftToken.type === "Template" || rightToken.type === "Template") {
			return true;
		}

		if (leftToken.type !== "Numeric" && rightToken.type === "Numeric" && rightToken.value.startsWith(".")) {
			return true;
		}

		return false;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var core = __webpack_require__(13);
var hide = __webpack_require__(17);
var redefine = __webpack_require__(15);
var ctx = __webpack_require__(22);
var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
	own = !IS_FORCED && target && target[key] !== undefined;
	out = (own ? target : source)[key];
	exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	if (target) redefine(target, key, out, type & $export.U);
	if (exports[key] != out) hide(exports, key, exp);
	if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (exec) {
  try {
	return !!exec();
  } catch (e) {
	return true;
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(3);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var store = __webpack_require__(74)('wks');
var uid = __webpack_require__(36);
var _Symbol = __webpack_require__(4).Symbol;
var USE_SYMBOL = typeof _Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(658);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var util = __webpack_require__(108);
var doctrine = __webpack_require__(164);
var variableUtil = __webpack_require__(27);
var pragmaUtil = __webpack_require__(71);

var usedPropTypesAreEquivalent = function usedPropTypesAreEquivalent(propA, propB) {
  if (propA.name === propB.name) {
	if (!propA.allNames && !propB.allNames) {
			return true;
	} else if (Array.isArray(propA.allNames) && Array.isArray(propB.allNames) && propA.allNames.join('') === propB.allNames.join('')) {
			return true;
	}
	return false;
  }
  return false;
};

var mergeUsedPropTypes = function mergeUsedPropTypes(propsList, newPropsList) {
  var propsToAdd = [];
  newPropsList.forEach(function (newProp) {
	var newPropisAlreadyInTheList = propsList.some(function (prop) {
			return usedPropTypesAreEquivalent(prop, newProp);
	});
	if (!newPropisAlreadyInTheList) {
			propsToAdd.push(newProp);
	}
  });
  return propsList.concat(propsToAdd);
};
function Components() {
  this._list = {};
  this._getId = function (node) {
	return node && node.range.join(':');
  };
}
Components.prototype.add = function (node, confidence) {
  var id = this._getId(node);
  if (this._list[id]) {
	if (confidence === 0 || this._list[id].confidence === 0) {
			this._list[id].confidence = 0;
	} else {
			this._list[id].confidence = Math.max(this._list[id].confidence, confidence);
	}
	return this._list[id];
  }
  this._list[id] = {
	node: node,
	confidence: confidence
  };
  return this._list[id];
};
Components.prototype.get = function (node) {
  var id = this._getId(node);
  return this._list[id];
};
Components.prototype.set = function (node, props) {
  while (node && !this._list[this._getId(node)]) {
	node = node.parent;
  }
  if (!node) {
	return;
  }
  var id = this._getId(node);
  var copyUsedPropTypes = void 0;
  if (this._list[id]) {
	copyUsedPropTypes = this._list[id].usedPropTypes && this._list[id].usedPropTypes.slice();
  }
  this._list[id] = util._extend(this._list[id], props);
  if (this._list[id] && props.usedPropTypes) {
	this._list[id].usedPropTypes = mergeUsedPropTypes(copyUsedPropTypes || [], props.usedPropTypes);
  }
};
Components.prototype.list = function () {
  var list = {};
  var usedPropTypes = {};
  for (var i in this._list) {
	if (!has(this._list, i) || this._list[i].confidence >= 2) {
			continue;
	}
	var component = null;
	var node = null;
	node = this._list[i].node;
	while (!component && node.parent) {
			node = node.parent;
			if (node.type === 'Decorator') {
		break;
			}
			component = this.get(node);
	}
	if (component) {
			var newUsedProps = (this._list[i].usedPropTypes || []).filter(function (propType) {
		return !propType.node || propType.node.kind !== 'init';
			});

			var componentId = this._getId(component.node);
			usedPropTypes[componentId] = (usedPropTypes[componentId] || []).concat(newUsedProps);
	}
  }
  for (var j in this._list) {
	if (!has(this._list, j) || this._list[j].confidence < 2) {
			continue;
	}
	var id = this._getId(this._list[j].node);
	list[j] = this._list[j];
	if (usedPropTypes[id]) {
			list[j].usedPropTypes = (list[j].usedPropTypes || []).concat(usedPropTypes[id]);
	}
  }
  return list;
};
Components.prototype.length = function () {
  var length = 0;
  for (var i in this._list) {
	if (!has(this._list, i) || this._list[i].confidence < 2) {
			continue;
	}
	length++;
  }
  return length;
};

function componentRule(rule, context) {
  var createClass = pragmaUtil.getCreateClassFromContext(context);
  var pragma = pragmaUtil.getFromContext(context);
  var sourceCode = context.getSourceCode();
  var components = new Components();
  var utils = {
	isES5Component: function isES5Component(node) {
			if (!node.parent) {
		return false;
			}
			return new RegExp('^(' + pragma + '\\.)?' + createClass + '$').test(sourceCode.getText(node.parent.callee));
	},
	isES6Component: function isES6Component(node) {
			if (utils.isExplicitComponent(node)) {
		return true;
			}

			if (!node.superClass) {
		return false;
			}
			return new RegExp('^(' + pragma + '\\.)?(Pure)?Component$').test(sourceCode.getText(node.superClass));
	},
	isExplicitComponent: function isExplicitComponent(node) {
			var comment = void 0;
			try {
		comment = sourceCode.getJSDocComment(node);
			} catch (e) {
		comment = null;
			}

			if (comment === null) {
		return false;
			}

			var commentAst = doctrine.parse(comment.value, {
		unwrap: true,
		tags: ['extends', 'augments']
			});

			var relevantTags = commentAst.tags.filter(function (tag) {
		return tag.name === 'React.Component' || tag.name === 'React.PureComponent';
			});

			return relevantTags.length > 0;
	},
	isPureComponent: function isPureComponent(node) {
			if (node.superClass) {
		return new RegExp('^(' + pragma + '\\.)?PureComponent$').test(sourceCode.getText(node.superClass));
			}
			return false;
	},
	hasDestructuredReactCreateElement: function hasDestructuredReactCreateElement() {
			var variables = variableUtil.variablesInScope(context);
			var variable = variableUtil.getVariable(variables, 'createElement');
			if (variable) {
		var map = variable.scope.set;
		if (map.has('React')) {
					return true;
		}
			}
			return false;
	},
	isReactCreateElement: function isReactCreateElement(node) {
			var calledOnReact = node && node.callee && node.callee.object && node.callee.object.name === 'React' && node.callee.property && node.callee.property.name === 'createElement';

			var calledDirectly = node && node.callee && node.callee.name === 'createElement';

			if (this.hasDestructuredReactCreateElement()) {
		return calledDirectly || calledOnReact;
			}
			return calledOnReact;
	},
	isReturningJSX: function isReturningJSX(ASTnode, strict) {
			var property = void 0;
			var node = ASTnode;
			switch (node.type) {
		case 'ReturnStatement':
					property = 'argument';
					break;
		case 'ArrowFunctionExpression':
					property = 'body';
					break;
		default:
					node = utils.findReturnStatement(node);
					if (!node) {
			return false;
					}
					property = 'argument';
			}

			var returnsConditionalJSXConsequent = node[property] && node[property].type === 'ConditionalExpression' && node[property].consequent.type === 'JSXElement';
			var returnsConditionalJSXAlternate = node[property] && node[property].type === 'ConditionalExpression' && node[property].alternate.type === 'JSXElement';
			var returnsConditionalJSX = strict ? returnsConditionalJSXConsequent && returnsConditionalJSXAlternate : returnsConditionalJSXConsequent || returnsConditionalJSXAlternate;

			var returnsJSX = node[property] && node[property].type === 'JSXElement';
			var returnsReactCreateElement = this.isReactCreateElement(node[property]);

			return Boolean(returnsConditionalJSX || returnsJSX || returnsReactCreateElement);
	},
	findReturnStatement: function findReturnStatement(node) {
			if ((!node.value || !node.value.body || !node.value.body.body) && (!node.body || !node.body.body)) {
		return false;
			}

			var bodyNodes = node.value ? node.value.body.body : node.body.body;

			var i = bodyNodes.length - 1;
			for (; i >= 0; i--) {
		if (bodyNodes[i].type === 'ReturnStatement') {
					return bodyNodes[i];
		}
			}
			return false;
	},
	getParentComponent: function getParentComponent() {
			return utils.getParentES6Component() || utils.getParentES5Component() || utils.getParentStatelessComponent();
	},
	getParentES5Component: function getParentES5Component() {
			var scope = context.getScope();
			while (scope) {
		var node = scope.block && scope.block.parent && scope.block.parent.parent;
		if (node && utils.isES5Component(node)) {
					return node;
		}
		scope = scope.upper;
			}
			return null;
	},
	getParentES6Component: function getParentES6Component() {
			var scope = context.getScope();
			while (scope && scope.type !== 'class') {
		scope = scope.upper;
			}
			var node = scope && scope.block;
			if (!node || !utils.isES6Component(node)) {
		return null;
			}
			return node;
	},
	getParentStatelessComponent: function getParentStatelessComponent() {
			var scope = context.getScope();
			while (scope) {
		var node = scope.block;
		var isClass = node.type === 'ClassExpression';
		var isFunction = /Function/.test(node.type); // Functions
		var isMethod = node.parent && node.parent.type === 'MethodDefinition'; // Classes methods
		var isArgument = node.parent && node.parent.type === 'CallExpression'; // Arguments (callback, etc.)
		var isJSXExpressionContainer = node.parent && node.parent.type === 'JSXExpressionContainer';
		if (isClass || isArgument) {
					return null;
		}
		if (isFunction && !isMethod && !isJSXExpressionContainer) {
					return node;
		}
		scope = scope.upper;
			}
			return null;
	},
	getRelatedComponent: function getRelatedComponent(node) {
			var i = void 0;
			var j = void 0;
			var k = void 0;
			var l = void 0;
			var componentNode = void 0;
			var componentPath = [];
			while (node) {
		if (node.property && node.property.type === 'Identifier') {
					componentPath.push(node.property.name);
		}
		if (node.object && node.object.type === 'Identifier') {
					componentPath.push(node.object.name);
		}
		node = node.object;
			}
			componentPath.reverse();
			var componentName = componentPath.slice(0, componentPath.length - 1).join('.');
			var variableName = componentPath.shift();
			if (!variableName) {
		return null;
			}
			var variableInScope = void 0;
			var variables = variableUtil.variablesInScope(context);
			for (i = 0, j = variables.length; i < j; i++) {
		if (variables[i].name === variableName) {
					variableInScope = variables[i];
					break;
		}
			}
			if (!variableInScope) {
		return null;
			}
			var refs = variableInScope.references;
			var refId = void 0;
			for (i = 0, j = refs.length; i < j; i++) {
		refId = refs[i].identifier;
		if (refId.parent && refId.parent.type === 'MemberExpression') {
					refId = refId.parent;
		}
		if (sourceCode.getText(refId) !== componentName) {
					continue;
		}
		if (refId.type === 'MemberExpression') {
					componentNode = refId.parent.right;
		} else if (refId.parent && refId.parent.type === 'VariableDeclarator') {
					componentNode = refId.parent.init;
		}
		break;
			}

			if (componentNode) {
		return components.add(componentNode, 1);
			}
			var defInScope = void 0;
			var defs = variableInScope.defs;
			for (i = 0, j = defs.length; i < j; i++) {
		if (defs[i].type === 'ClassName' || defs[i].type === 'FunctionName' || defs[i].type === 'Variable') {
					defInScope = defs[i];
					break;
		}
			}
			if (!defInScope || !defInScope.node) {
		return null;
			}
			componentNode = defInScope.node.init || defInScope.node;
			for (i = 0, j = componentPath.length; i < j; i++) {
		if (!componentNode.properties) {
					continue;
		}
		for (k = 0, l = componentNode.properties.length; k < l; k++) {
					if (componentNode.properties[k].key && componentNode.properties[k].key.name === componentPath[i]) {
			componentNode = componentNode.properties[k];
			break;
					}
		}
		if (!componentNode || !componentNode.value) {
					return null;
		}
		componentNode = componentNode.value;
			}
			return components.add(componentNode, 1);
	}
  };
  var detectionInstructions = {
	ClassExpression: function ClassExpression(node) {
			if (!utils.isES6Component(node)) {
		return;
			}
			components.add(node, 2);
	},

	ClassDeclaration: function ClassDeclaration(node) {
			if (!utils.isES6Component(node)) {
		return;
			}
			components.add(node, 2);
	},

	ClassProperty: function ClassProperty(node) {
			node = utils.getParentComponent();
			if (!node) {
		return;
			}
			components.add(node, 2);
	},

	ObjectExpression: function ObjectExpression(node) {
			if (!utils.isES5Component(node)) {
		return;
			}
			components.add(node, 2);
	},

	FunctionExpression: function FunctionExpression(node) {
			if (node.async) {
		components.add(node, 0);
		return;
			}
			var component = utils.getParentComponent();
			if (!component || component.parent && component.parent.type === 'JSXExpressionContainer') {
		components.add(node, 0);
		return;
			}
			components.add(component, 1);
	},

	FunctionDeclaration: function FunctionDeclaration(node) {
			if (node.async) {
		components.add(node, 0);
		return;
			}
			node = utils.getParentComponent();
			if (!node) {
		return;
			}
			components.add(node, 1);
	},

	ArrowFunctionExpression: function ArrowFunctionExpression(node) {
			if (node.async) {
		components.add(node, 0);
		return;
			}
			var component = utils.getParentComponent();
			if (!component || component.parent && component.parent.type === 'JSXExpressionContainer') {
		components.add(node, 0);
		return;
			}
			if (component.expression && utils.isReturningJSX(component)) {
		components.add(component, 2);
			} else {
		components.add(component, 1);
			}
	},

	ThisExpression: function ThisExpression(node) {
			var component = utils.getParentComponent();
			if (!component || !/Function/.test(component.type) || !node.parent.property) {
		return;
			}
			components.add(node, 0);
	},

	ReturnStatement: function ReturnStatement(node) {
			if (!utils.isReturningJSX(node)) {
		return;
			}
			node = utils.getParentComponent();
			if (!node) {
		var scope = context.getScope();
		components.add(scope.block, 1);
		return;
			}
			components.add(node, 2);
	}
  };
  var ruleInstructions = rule(context, components, utils);
  var updatedRuleInstructions = util._extend({}, ruleInstructions);
  Object.keys(detectionInstructions).forEach(function (instruction) {
	updatedRuleInstructions[instruction] = function (node) {
			detectionInstructions[instruction](node);
			return ruleInstructions[instruction] ? ruleInstructions[instruction](node) : void 0;
	};
  });
  return updatedRuleInstructions;
}

Components.detect = function (rule) {
  return componentRule.bind(this, rule);
};

module.exports = Components;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(5);
var IE8_DOM_DEFINE = __webpack_require__(116);
var toPrimitive = __webpack_require__(32);
var dP = Object.defineProperty;

exports.f = __webpack_require__(11) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
	return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
;(function () {
  var undefined;
  var VERSION = '4.17.4';
  var LARGE_ARRAY_SIZE = 200;
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
			FUNC_ERROR_TEXT = 'Expected a function';
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var MAX_MEMOIZE_SIZE = 500;
  var PLACEHOLDER = '__lodash_placeholder__';
  var CLONE_DEEP_FLAG = 1,
			CLONE_FLAT_FLAG = 2,
			CLONE_SYMBOLS_FLAG = 4;
  var COMPARE_PARTIAL_FLAG = 1,
			COMPARE_UNORDERED_FLAG = 2;
  var WRAP_BIND_FLAG = 1,
			WRAP_BIND_KEY_FLAG = 2,
			WRAP_CURRY_BOUND_FLAG = 4,
			WRAP_CURRY_FLAG = 8,
			WRAP_CURRY_RIGHT_FLAG = 16,
			WRAP_PARTIAL_FLAG = 32,
			WRAP_PARTIAL_RIGHT_FLAG = 64,
			WRAP_ARY_FLAG = 128,
			WRAP_REARG_FLAG = 256,
			WRAP_FLIP_FLAG = 512;
  var DEFAULT_TRUNC_LENGTH = 30,
			DEFAULT_TRUNC_OMISSION = '...';
  var HOT_COUNT = 800,
			HOT_SPAN = 16;
  var LAZY_FILTER_FLAG = 1,
			LAZY_MAP_FLAG = 2,
			LAZY_WHILE_FLAG = 3;
  var INFINITY = 1 / 0,
			MAX_SAFE_INTEGER = 9007199254740991,
			MAX_INTEGER = 1.7976931348623157e+308,
			NAN = 0 / 0;
  var MAX_ARRAY_LENGTH = 4294967295,
			MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
			HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
  var wrapFlags = [['ary', WRAP_ARY_FLAG], ['bind', WRAP_BIND_FLAG], ['bindKey', WRAP_BIND_KEY_FLAG], ['curry', WRAP_CURRY_FLAG], ['curryRight', WRAP_CURRY_RIGHT_FLAG], ['flip', WRAP_FLIP_FLAG], ['partial', WRAP_PARTIAL_FLAG], ['partialRight', WRAP_PARTIAL_RIGHT_FLAG], ['rearg', WRAP_REARG_FLAG]];
  var argsTag = '[object Arguments]',
			arrayTag = '[object Array]',
			asyncTag = '[object AsyncFunction]',
			boolTag = '[object Boolean]',
			dateTag = '[object Date]',
			domExcTag = '[object DOMException]',
			errorTag = '[object Error]',
			funcTag = '[object Function]',
			genTag = '[object GeneratorFunction]',
			mapTag = '[object Map]',
			numberTag = '[object Number]',
			nullTag = '[object Null]',
			objectTag = '[object Object]',
			promiseTag = '[object Promise]',
			proxyTag = '[object Proxy]',
			regexpTag = '[object RegExp]',
			setTag = '[object Set]',
			stringTag = '[object String]',
			symbolTag = '[object Symbol]',
			undefinedTag = '[object Undefined]',
			weakMapTag = '[object WeakMap]',
			weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
			dataViewTag = '[object DataView]',
			float32Tag = '[object Float32Array]',
			float64Tag = '[object Float64Array]',
			int8Tag = '[object Int8Array]',
			int16Tag = '[object Int16Array]',
			int32Tag = '[object Int32Array]',
			uint8Tag = '[object Uint8Array]',
			uint8ClampedTag = '[object Uint8ClampedArray]',
			uint16Tag = '[object Uint16Array]',
			uint32Tag = '[object Uint32Array]';
  var reEmptyStringLeading = /\b__p \+= '';/g,
			reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
			reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
			reUnescapedHtml = /[&<>"']/g,
			reHasEscapedHtml = RegExp(reEscapedHtml.source),
			reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
  var reEscape = /<%-([\s\S]+?)%>/g,
			reEvaluate = /<%([\s\S]+?)%>/g,
			reInterpolate = /<%=([\s\S]+?)%>/g;
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
			reIsPlainProp = /^\w*$/,
			reLeadingDot = /^\./,
			rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
			reHasRegExpChar = RegExp(reRegExpChar.source);
  var reTrim = /^\s+|\s+$/g,
			reTrimStart = /^\s+/,
			reTrimEnd = /\s+$/;
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
			reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
			reSplitDetails = /,? & /;
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reEscapeChar = /\\(\\)?/g;
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
  var reFlags = /\w*$/;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsOctal = /^0o[0-7]+$/i;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var reNoMatch = /($^)/;
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
  var rsAstralRange = '\\ud800-\\udfff',
			rsComboMarksRange = '\\u0300-\\u036f',
			reComboHalfMarksRange = '\\ufe20-\\ufe2f',
			rsComboSymbolsRange = '\\u20d0-\\u20ff',
			rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
			rsDingbatRange = '\\u2700-\\u27bf',
			rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
			rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
			rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
			rsPunctuationRange = '\\u2000-\\u206f',
			rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
			rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
			rsVarRange = '\\ufe0e\\ufe0f',
			rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = '[\'\u2019]',
			rsAstral = '[' + rsAstralRange + ']',
			rsBreak = '[' + rsBreakRange + ']',
			rsCombo = '[' + rsComboRange + ']',
			rsDigits = '\\d+',
			rsDingbat = '[' + rsDingbatRange + ']',
			rsLower = '[' + rsLowerRange + ']',
			rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
			rsFitz = '\\ud83c[\\udffb-\\udfff]',
			rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
			rsNonAstral = '[^' + rsAstralRange + ']',
			rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
			rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
			rsUpper = '[' + rsUpperRange + ']',
			rsZWJ = '\\u200d';
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
			rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
			rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
			rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
			reOptMod = rsModifier + '?',
			rsOptVar = '[' + rsVarRange + ']?',
			rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
			rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
			rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
			rsSeq = rsOptVar + reOptMod + rsOptJoin,
			rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
			rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
  var reApos = RegExp(rsApos, 'g');
  var reComboMark = RegExp(rsCombo, 'g');
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
  var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var contextProps = ['Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object', 'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'];
  var templateCounter = -1;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var deburredLetters = {
	'\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	'\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	'\xc7': 'C', '\xe7': 'c',
	'\xd0': 'D', '\xf0': 'd',
	'\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	'\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	'\xcc': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	'\xec': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
	'\xd1': 'N', '\xf1': 'n',
	'\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	'\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	'\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	'\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	'\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
	'\xc6': 'Ae', '\xe6': 'ae',
	'\xde': 'Th', '\xfe': 'th',
	'\xdf': 'ss',
	'\u0100': 'A', '\u0102': 'A', '\u0104': 'A',
	'\u0101': 'a', '\u0103': 'a', '\u0105': 'a',
	'\u0106': 'C', '\u0108': 'C', '\u010A': 'C', '\u010C': 'C',
	'\u0107': 'c', '\u0109': 'c', '\u010B': 'c', '\u010D': 'c',
	'\u010E': 'D', '\u0110': 'D', '\u010F': 'd', '\u0111': 'd',
	'\u0112': 'E', '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011A': 'E',
	'\u0113': 'e', '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011B': 'e',
	'\u011C': 'G', '\u011E': 'G', '\u0120': 'G', '\u0122': 'G',
	'\u011D': 'g', '\u011F': 'g', '\u0121': 'g', '\u0123': 'g',
	'\u0124': 'H', '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	'\u0128': 'I', '\u012A': 'I', '\u012C': 'I', '\u012E': 'I', '\u0130': 'I',
	'\u0129': 'i', '\u012B': 'i', '\u012D': 'i', '\u012F': 'i', '\u0131': 'i',
	'\u0134': 'J', '\u0135': 'j',
	'\u0136': 'K', '\u0137': 'k', '\u0138': 'k',
	'\u0139': 'L', '\u013B': 'L', '\u013D': 'L', '\u013F': 'L', '\u0141': 'L',
	'\u013A': 'l', '\u013C': 'l', '\u013E': 'l', '\u0140': 'l', '\u0142': 'l',
	'\u0143': 'N', '\u0145': 'N', '\u0147': 'N', '\u014A': 'N',
	'\u0144': 'n', '\u0146': 'n', '\u0148': 'n', '\u014B': 'n',
	'\u014C': 'O', '\u014E': 'O', '\u0150': 'O',
	'\u014D': 'o', '\u014F': 'o', '\u0151': 'o',
	'\u0154': 'R', '\u0156': 'R', '\u0158': 'R',
	'\u0155': 'r', '\u0157': 'r', '\u0159': 'r',
	'\u015A': 'S', '\u015C': 'S', '\u015E': 'S', '\u0160': 'S',
	'\u015B': 's', '\u015D': 's', '\u015F': 's', '\u0161': 's',
	'\u0162': 'T', '\u0164': 'T', '\u0166': 'T',
	'\u0163': 't', '\u0165': 't', '\u0167': 't',
	'\u0168': 'U', '\u016A': 'U', '\u016C': 'U', '\u016E': 'U', '\u0170': 'U', '\u0172': 'U',
	'\u0169': 'u', '\u016B': 'u', '\u016D': 'u', '\u016F': 'u', '\u0171': 'u', '\u0173': 'u',
	'\u0174': 'W', '\u0175': 'w',
	'\u0176': 'Y', '\u0177': 'y', '\u0178': 'Y',
	'\u0179': 'Z', '\u017B': 'Z', '\u017D': 'Z',
	'\u017A': 'z', '\u017C': 'z', '\u017E': 'z',
	'\u0132': 'IJ', '\u0133': 'ij',
	'\u0152': 'Oe', '\u0153': 'oe',
	'\u0149': "'n", '\u017F': 's'
  };
  var htmlEscapes = {
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;',
	'"': '&quot;',
	"'": '&#39;'
  };
  var htmlUnescapes = {
	'&amp;': '&',
	'&lt;': '<',
	'&gt;': '>',
	'&quot;': '"',
	'&#39;': "'"
  };
  var stringEscapes = {
	'\\': '\\',
	"'": "'",
	'\n': 'n',
	'\r': 'r',
	'\u2028': 'u2028',
	'\u2029': 'u2029'
  };
  var freeParseFloat = parseFloat,
			freeParseInt = parseInt;
  var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;
  var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();
  var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function () {
	try {
			return freeProcess && freeProcess.binding && freeProcess.binding('util');
	} catch (e) {}
  }();
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
			nodeIsDate = nodeUtil && nodeUtil.isDate,
			nodeIsMap = nodeUtil && nodeUtil.isMap,
			nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
			nodeIsSet = nodeUtil && nodeUtil.isSet,
			nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function addMapEntry(map, pair) {
	map.set(pair[0], pair[1]);
	return map;
  }
  function addSetEntry(set, value) {
	set.add(value);
	return set;
  }
  function apply(func, thisArg, args) {
	switch (args.length) {
			case 0:
		return func.call(thisArg);
			case 1:
		return func.call(thisArg, args[0]);
			case 2:
		return func.call(thisArg, args[0], args[1]);
			case 3:
		return func.call(thisArg, args[0], args[1], args[2]);
	}
	return func.apply(thisArg, args);
  }
  function arrayAggregator(array, setter, iteratee, accumulator) {
	var index = -1,
		length = array == null ? 0 : array.length;

	while (++index < length) {
			var value = array[index];
			setter(accumulator, value, iteratee(value), array);
	}
	return accumulator;
  }
  function arrayEach(array, iteratee) {
	var index = -1,
		length = array == null ? 0 : array.length;

	while (++index < length) {
			if (iteratee(array[index], index, array) === false) {
		break;
			}
	}
	return array;
  }
  function arrayEachRight(array, iteratee) {
	var length = array == null ? 0 : array.length;

	while (length--) {
			if (iteratee(array[length], length, array) === false) {
		break;
			}
	}
	return array;
  }
  function arrayEvery(array, predicate) {
	var index = -1,
		length = array == null ? 0 : array.length;

	while (++index < length) {
			if (!predicate(array[index], index, array)) {
		return false;
			}
	}
	return true;
  }
  function arrayFilter(array, predicate) {
	var index = -1,
		length = array == null ? 0 : array.length,
		resIndex = 0,
		result = [];

	while (++index < length) {
			var value = array[index];
			if (predicate(value, index, array)) {
		result[resIndex++] = value;
			}
	}
	return result;
  }
  function arrayIncludes(array, value) {
	var length = array == null ? 0 : array.length;
	return !!length && baseIndexOf(array, value, 0) > -1;
  }
  function arrayIncludesWith(array, value, comparator) {
	var index = -1,
		length = array == null ? 0 : array.length;

	while (++index < length) {
			if (comparator(value, array[index])) {
		return true;
			}
	}
	return false;
  }
  function arrayMap(array, iteratee) {
	var index = -1,
		length = array == null ? 0 : array.length,
		result = Array(length);

	while (++index < length) {
			result[index] = iteratee(array[index], index, array);
	}
	return result;
  }
  function arrayPush(array, values) {
	var index = -1,
		length = values.length,
		offset = array.length;

	while (++index < length) {
			array[offset + index] = values[index];
	}
	return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
	var index = -1,
		length = array == null ? 0 : array.length;

	if (initAccum && length) {
			accumulator = array[++index];
	}
	while (++index < length) {
			accumulator = iteratee(accumulator, array[index], index, array);
	}
	return accumulator;
  }
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	var length = array == null ? 0 : array.length;
	if (initAccum && length) {
			accumulator = array[--length];
	}
	while (length--) {
			accumulator = iteratee(accumulator, array[length], length, array);
	}
	return accumulator;
  }
  function arraySome(array, predicate) {
	var index = -1,
		length = array == null ? 0 : array.length;

	while (++index < length) {
			if (predicate(array[index], index, array)) {
		return true;
			}
	}
	return false;
  }
  var asciiSize = baseProperty('length');
  function asciiToArray(string) {
	return string.split('');
  }
  function asciiWords(string) {
	return string.match(reAsciiWord) || [];
  }
  function baseFindKey(collection, predicate, eachFunc) {
	var result;
	eachFunc(collection, function (value, key, collection) {
			if (predicate(value, key, collection)) {
		result = key;
		return false;
			}
	});
	return result;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
	var length = array.length,
		index = fromIndex + (fromRight ? 1 : -1);

	while (fromRight ? index-- : ++index < length) {
			if (predicate(array[index], index, array)) {
		return index;
			}
	}
	return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
	return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  function baseIndexOfWith(array, value, fromIndex, comparator) {
	var index = fromIndex - 1,
		length = array.length;

	while (++index < length) {
			if (comparator(array[index], value)) {
		return index;
			}
	}
	return -1;
  }
  function baseIsNaN(value) {
	return value !== value;
  }
  function baseMean(array, iteratee) {
	var length = array == null ? 0 : array.length;
	return length ? baseSum(array, iteratee) / length : NAN;
  }
  function baseProperty(key) {
	return function (object) {
			return object == null ? undefined : object[key];
	};
  }
  function basePropertyOf(object) {
	return function (key) {
			return object == null ? undefined : object[key];
	};
  }
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	eachFunc(collection, function (value, index, collection) {
			accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
	});
	return accumulator;
  }
  function baseSortBy(array, comparer) {
	var length = array.length;

	array.sort(comparer);
	while (length--) {
			array[length] = array[length].value;
	}
	return array;
  }
  function baseSum(array, iteratee) {
	var result,
		index = -1,
		length = array.length;

	while (++index < length) {
			var current = iteratee(array[index]);
			if (current !== undefined) {
		result = result === undefined ? current : result + current;
			}
	}
	return result;
  }
  function baseTimes(n, iteratee) {
	var index = -1,
		result = Array(n);

	while (++index < n) {
			result[index] = iteratee(index);
	}
	return result;
  }
  function baseToPairs(object, props) {
	return arrayMap(props, function (key) {
			return [key, object[key]];
	});
  }
  function baseUnary(func) {
	return function (value) {
			return func(value);
	};
  }
  function baseValues(object, props) {
	return arrayMap(props, function (key) {
			return object[key];
	});
  }
  function cacheHas(cache, key) {
	return cache.has(key);
  }
  function charsStartIndex(strSymbols, chrSymbols) {
	var index = -1,
		length = strSymbols.length;

	while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	return index;
  }
  function charsEndIndex(strSymbols, chrSymbols) {
	var index = strSymbols.length;

	while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	return index;
  }
  function countHolders(array, placeholder) {
	var length = array.length,
		result = 0;

	while (length--) {
			if (array[length] === placeholder) {
		++result;
			}
	}
	return result;
  }
  var deburrLetter = basePropertyOf(deburredLetters);
  var escapeHtmlChar = basePropertyOf(htmlEscapes);
  function escapeStringChar(chr) {
	return '\\' + stringEscapes[chr];
  }
  function getValue(object, key) {
	return object == null ? undefined : object[key];
  }
  function hasUnicode(string) {
	return reHasUnicode.test(string);
  }
  function hasUnicodeWord(string) {
	return reHasUnicodeWord.test(string);
  }
  function iteratorToArray(iterator) {
	var data,
		result = [];

	while (!(data = iterator.next()).done) {
			result.push(data.value);
	}
	return result;
  }
  function mapToArray(map) {
	var index = -1,
		result = Array(map.size);

	map.forEach(function (value, key) {
			result[++index] = [key, value];
	});
	return result;
  }
  function overArg(func, transform) {
	return function (arg) {
			return func(transform(arg));
	};
  }
  function replaceHolders(array, placeholder) {
	var index = -1,
		length = array.length,
		resIndex = 0,
		result = [];

	while (++index < length) {
			var value = array[index];
			if (value === placeholder || value === PLACEHOLDER) {
		array[index] = PLACEHOLDER;
		result[resIndex++] = index;
			}
	}
	return result;
  }
  function setToArray(set) {
	var index = -1,
		result = Array(set.size);

	set.forEach(function (value) {
			result[++index] = value;
	});
	return result;
  }
  function setToPairs(set) {
	var index = -1,
		result = Array(set.size);

	set.forEach(function (value) {
			result[++index] = [value, value];
	});
	return result;
  }
  function strictIndexOf(array, value, fromIndex) {
	var index = fromIndex - 1,
		length = array.length;

	while (++index < length) {
			if (array[index] === value) {
		return index;
			}
	}
	return -1;
  }
  function strictLastIndexOf(array, value, fromIndex) {
	var index = fromIndex + 1;
	while (index--) {
			if (array[index] === value) {
		return index;
			}
	}
	return index;
  }
  function stringSize(string) {
	return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
  }
  function stringToArray(string) {
	return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
  function unicodeSize(string) {
	var result = reUnicode.lastIndex = 0;
	while (reUnicode.test(string)) {
			++result;
	}
	return result;
  }
  function unicodeToArray(string) {
	return string.match(reUnicode) || [];
  }
  function unicodeWords(string) {
	return string.match(reUnicodeWord) || [];
  }
  var runInContext = function runInContext(context) {
	context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
	var Array = context.Array,
		Date = context.Date,
		Error = context.Error,
		Function = context.Function,
		Math = context.Math,
		Object = context.Object,
		RegExp = context.RegExp,
		String = context.String,
		TypeError = context.TypeError;
	var arrayProto = Array.prototype,
		funcProto = Function.prototype,
		objectProto = Object.prototype;
	var coreJsData = context['__core-js_shared__'];
	var funcToString = funcProto.toString;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var idCounter = 0;
	var maskSrcKey = function () {
			var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
			return uid ? 'Symbol(src)_1.' + uid : '';
	}();
	var nativeObjectToString = objectProto.toString;
	var objectCtorString = funcToString.call(Object);
	var oldDash = root._;
	var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	var Buffer = moduleExports ? context.Buffer : undefined,
		_Symbol = context.Symbol,
		Uint8Array = context.Uint8Array,
		allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
		getPrototype = overArg(Object.getPrototypeOf, Object),
		objectCreate = Object.create,
		propertyIsEnumerable = objectProto.propertyIsEnumerable,
		splice = arrayProto.splice,
		spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined,
		symIterator = _Symbol ? _Symbol.iterator : undefined,
		symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	var defineProperty = function () {
			try {
		var func = getNative(Object, 'defineProperty');
		func({}, '', {});
		return func;
			} catch (e) {}
	}();
	var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
		ctxNow = Date && Date.now !== root.Date.now && Date.now,
		ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
	var nativeCeil = Math.ceil,
		nativeFloor = Math.floor,
		nativeGetSymbols = Object.getOwnPropertySymbols,
		nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
		nativeIsFinite = context.isFinite,
		nativeJoin = arrayProto.join,
		nativeKeys = overArg(Object.keys, Object),
		nativeMax = Math.max,
		nativeMin = Math.min,
		nativeNow = Date.now,
		nativeParseInt = context.parseInt,
		nativeRandom = Math.random,
		nativeReverse = arrayProto.reverse;
	var DataView = getNative(context, 'DataView'),
		Map = getNative(context, 'Map'),
		Promise = getNative(context, 'Promise'),
		Set = getNative(context, 'Set'),
		WeakMap = getNative(context, 'WeakMap'),
		nativeCreate = getNative(Object, 'create');
	var metaMap = WeakMap && new WeakMap();
	var realNames = {};
	var dataViewCtorString = toSource(DataView),
		mapCtorString = toSource(Map),
		promiseCtorString = toSource(Promise),
		setCtorString = toSource(Set),
		weakMapCtorString = toSource(WeakMap);
	var symbolProto = _Symbol ? _Symbol.prototype : undefined,
		symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
		symbolToString = symbolProto ? symbolProto.toString : undefined;
	function lodash(value) {
			if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
		if (value instanceof LodashWrapper) {
					return value;
		}
		if (hasOwnProperty.call(value, '__wrapped__')) {
					return wrapperClone(value);
		}
			}
			return new LodashWrapper(value);
	}
	var baseCreate = function () {
			function object() {}
			return function (proto) {
		if (!isObject(proto)) {
					return {};
		}
		if (objectCreate) {
					return objectCreate(proto);
		}
		object.prototype = proto;
		var result = new object();
		object.prototype = undefined;
		return result;
			};
	}();
	function baseLodash() {}
	function LodashWrapper(value, chainAll) {
			this.__wrapped__ = value;
			this.__actions__ = [];
			this.__chain__ = !!chainAll;
			this.__index__ = 0;
			this.__values__ = undefined;
	}
	lodash.templateSettings = {
			'escape': reEscape,
			'evaluate': reEvaluate,
			'interpolate': reInterpolate,
			'variable': '',
			'imports': {
		'_': lodash
			}
	};
	lodash.prototype = baseLodash.prototype;
	lodash.prototype.constructor = lodash;

	LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	LodashWrapper.prototype.constructor = LodashWrapper;
	function LazyWrapper(value) {
			this.__wrapped__ = value;
			this.__actions__ = [];
			this.__dir__ = 1;
			this.__filtered__ = false;
			this.__iteratees__ = [];
			this.__takeCount__ = MAX_ARRAY_LENGTH;
			this.__views__ = [];
	}
	function lazyClone() {
			var result = new LazyWrapper(this.__wrapped__);
			result.__actions__ = copyArray(this.__actions__);
			result.__dir__ = this.__dir__;
			result.__filtered__ = this.__filtered__;
			result.__iteratees__ = copyArray(this.__iteratees__);
			result.__takeCount__ = this.__takeCount__;
			result.__views__ = copyArray(this.__views__);
			return result;
	}
	function lazyReverse() {
			if (this.__filtered__) {
		var result = new LazyWrapper(this);
		result.__dir__ = -1;
		result.__filtered__ = true;
			} else {
		result = this.clone();
		result.__dir__ *= -1;
			}
			return result;
	}
	function lazyValue() {
			var array = this.__wrapped__.value(),
					dir = this.__dir__,
					isArr = isArray(array),
					isRight = dir < 0,
					arrLength = isArr ? array.length : 0,
					view = getView(0, arrLength, this.__views__),
					start = view.start,
					end = view.end,
					length = end - start,
					index = isRight ? end : start - 1,
					iteratees = this.__iteratees__,
					iterLength = iteratees.length,
					resIndex = 0,
					takeCount = nativeMin(length, this.__takeCount__);

			if (!isArr || !isRight && arrLength == length && takeCount == length) {
		return baseWrapperValue(array, this.__actions__);
			}
			var result = [];

			outer: while (length-- && resIndex < takeCount) {
		index += dir;

		var iterIndex = -1,
			value = array[index];

		while (++iterIndex < iterLength) {
					var data = iteratees[iterIndex],
							iteratee = data.iteratee,
							type = data.type,
							computed = iteratee(value);

					if (type == LAZY_MAP_FLAG) {
			value = computed;
					} else if (!computed) {
			if (type == LAZY_FILTER_FLAG) {
							continue outer;
			} else {
							break outer;
			}
					}
		}
		result[resIndex++] = value;
			}
			return result;
	}
	LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	LazyWrapper.prototype.constructor = LazyWrapper;
	function Hash(entries) {
			var index = -1,
					length = entries == null ? 0 : entries.length;

			this.clear();
			while (++index < length) {
		var entry = entries[index];
		this.set(entry[0], entry[1]);
			}
	}
	function hashClear() {
			this.__data__ = nativeCreate ? nativeCreate(null) : {};
			this.size = 0;
	}
	function hashDelete(key) {
			var result = this.has(key) && delete this.__data__[key];
			this.size -= result ? 1 : 0;
			return result;
	}
	function hashGet(key) {
			var data = this.__data__;
			if (nativeCreate) {
		var result = data[key];
		return result === HASH_UNDEFINED ? undefined : result;
			}
			return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	function hashHas(key) {
			var data = this.__data__;
			return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}
	function hashSet(key, value) {
			var data = this.__data__;
			this.size += this.has(key) ? 0 : 1;
			data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
			return this;
	}
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	function ListCache(entries) {
			var index = -1,
					length = entries == null ? 0 : entries.length;

			this.clear();
			while (++index < length) {
		var entry = entries[index];
		this.set(entry[0], entry[1]);
			}
	}
	function listCacheClear() {
			this.__data__ = [];
			this.size = 0;
	}
	function listCacheDelete(key) {
			var data = this.__data__,
					index = assocIndexOf(data, key);

			if (index < 0) {
		return false;
			}
			var lastIndex = data.length - 1;
			if (index == lastIndex) {
		data.pop();
			} else {
		splice.call(data, index, 1);
			}
			--this.size;
			return true;
	}
	function listCacheGet(key) {
			var data = this.__data__,
					index = assocIndexOf(data, key);

			return index < 0 ? undefined : data[index][1];
	}
	function listCacheHas(key) {
			return assocIndexOf(this.__data__, key) > -1;
	}
	function listCacheSet(key, value) {
			var data = this.__data__,
					index = assocIndexOf(data, key);

			if (index < 0) {
		++this.size;
		data.push([key, value]);
			} else {
		data[index][1] = value;
			}
			return this;
	}
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	function MapCache(entries) {
			var index = -1,
					length = entries == null ? 0 : entries.length;

			this.clear();
			while (++index < length) {
		var entry = entries[index];
		this.set(entry[0], entry[1]);
			}
	}
	function mapCacheClear() {
			this.size = 0;
			this.__data__ = {
		'hash': new Hash(),
		'map': new (Map || ListCache)(),
		'string': new Hash()
			};
	}
	function mapCacheDelete(key) {
			var result = getMapData(this, key)['delete'](key);
			this.size -= result ? 1 : 0;
			return result;
	}
	function mapCacheGet(key) {
			return getMapData(this, key).get(key);
	}
	function mapCacheHas(key) {
			return getMapData(this, key).has(key);
	}
	function mapCacheSet(key, value) {
			var data = getMapData(this, key),
					size = data.size;

			data.set(key, value);
			this.size += data.size == size ? 0 : 1;
			return this;
	}
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	function SetCache(values) {
			var index = -1,
					length = values == null ? 0 : values.length;

			this.__data__ = new MapCache();
			while (++index < length) {
		this.add(values[index]);
			}
	}
	function setCacheAdd(value) {
			this.__data__.set(value, HASH_UNDEFINED);
			return this;
	}
	function setCacheHas(value) {
			return this.__data__.has(value);
	}
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;
	function Stack(entries) {
			var data = this.__data__ = new ListCache(entries);
			this.size = data.size;
	}
	function stackClear() {
			this.__data__ = new ListCache();
			this.size = 0;
	}
	function stackDelete(key) {
			var data = this.__data__,
					result = data['delete'](key);

			this.size = data.size;
			return result;
	}
	function stackGet(key) {
			return this.__data__.get(key);
	}
	function stackHas(key) {
			return this.__data__.has(key);
	}
	function stackSet(key, value) {
			var data = this.__data__;
			if (data instanceof ListCache) {
		var pairs = data.__data__;
		if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
					pairs.push([key, value]);
					this.size = ++data.size;
					return this;
		}
		data = this.__data__ = new MapCache(pairs);
			}
			data.set(key, value);
			this.size = data.size;
			return this;
	}
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	function arrayLikeKeys(value, inherited) {
			var isArr = isArray(value),
					isArg = !isArr && isArguments(value),
					isBuff = !isArr && !isArg && isBuffer(value),
					isType = !isArr && !isArg && !isBuff && isTypedArray(value),
					skipIndexes = isArr || isArg || isBuff || isType,
					result = skipIndexes ? baseTimes(value.length, String) : [],
					length = result.length;

			for (var key in value) {
		if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
		key == 'length' ||
		isBuff && (key == 'offset' || key == 'parent') ||
		isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
		isIndex(key, length)))) {
					result.push(key);
		}
			}
			return result;
	}
	function arraySample(array) {
			var length = array.length;
			return length ? array[baseRandom(0, length - 1)] : undefined;
	}
	function arraySampleSize(array, n) {
			return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
	}
	function arrayShuffle(array) {
			return shuffleSelf(copyArray(array));
	}
	function assignMergeValue(object, key, value) {
			if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
		baseAssignValue(object, key, value);
			}
	}
	function assignValue(object, key, value) {
			var objValue = object[key];
			if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
		baseAssignValue(object, key, value);
			}
	}
	function assocIndexOf(array, key) {
			var length = array.length;
			while (length--) {
		if (eq(array[length][0], key)) {
					return length;
		}
			}
			return -1;
	}
	function baseAggregator(collection, setter, iteratee, accumulator) {
			baseEach(collection, function (value, key, collection) {
		setter(accumulator, value, iteratee(value), collection);
			});
			return accumulator;
	}
	function baseAssign(object, source) {
			return object && copyObject(source, keys(source), object);
	}
	function baseAssignIn(object, source) {
			return object && copyObject(source, keysIn(source), object);
	}
	function baseAssignValue(object, key, value) {
			if (key == '__proto__' && defineProperty) {
		defineProperty(object, key, {
					'configurable': true,
					'enumerable': true,
					'value': value,
					'writable': true
		});
			} else {
		object[key] = value;
			}
	}
	function baseAt(object, paths) {
			var index = -1,
					length = paths.length,
					result = Array(length),
					skip = object == null;

			while (++index < length) {
		result[index] = skip ? undefined : get(object, paths[index]);
			}
			return result;
	}
	function baseClamp(number, lower, upper) {
			if (number === number) {
		if (upper !== undefined) {
					number = number <= upper ? number : upper;
		}
		if (lower !== undefined) {
					number = number >= lower ? number : lower;
		}
			}
			return number;
	}
	function baseClone(value, bitmask, customizer, key, object, stack) {
			var result,
					isDeep = bitmask & CLONE_DEEP_FLAG,
					isFlat = bitmask & CLONE_FLAT_FLAG,
					isFull = bitmask & CLONE_SYMBOLS_FLAG;

			if (customizer) {
		result = object ? customizer(value, key, object, stack) : customizer(value);
			}
			if (result !== undefined) {
		return result;
			}
			if (!isObject(value)) {
		return value;
			}
			var isArr = isArray(value);
			if (isArr) {
		result = initCloneArray(value);
		if (!isDeep) {
					return copyArray(value, result);
		}
			} else {
		var tag = getTag(value),
			isFunc = tag == funcTag || tag == genTag;

		if (isBuffer(value)) {
					return cloneBuffer(value, isDeep);
		}
		if (tag == objectTag || tag == argsTag || isFunc && !object) {
					result = isFlat || isFunc ? {} : initCloneObject(value);
					if (!isDeep) {
			return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
					}
		} else {
					if (!cloneableTags[tag]) {
			return object ? value : {};
					}
					result = initCloneByTag(value, tag, baseClone, isDeep);
		}
			}
			stack || (stack = new Stack());
			var stacked = stack.get(value);
			if (stacked) {
		return stacked;
			}
			stack.set(value, result);

			var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;

			var props = isArr ? undefined : keysFunc(value);
			arrayEach(props || value, function (subValue, key) {
		if (props) {
					key = subValue;
					subValue = value[key];
		}
		assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
			});
			return result;
	}
	function baseConforms(source) {
			var props = keys(source);
			return function (object) {
		return baseConformsTo(object, source, props);
			};
	}
	function baseConformsTo(object, source, props) {
			var length = props.length;
			if (object == null) {
		return !length;
			}
			object = Object(object);
			while (length--) {
		var key = props[length],
			predicate = source[key],
			value = object[key];

		if (value === undefined && !(key in object) || !predicate(value)) {
					return false;
		}
			}
			return true;
	}
	function baseDelay(func, wait, args) {
			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			return setTimeout(function () {
		func.apply(undefined, args);
			}, wait);
	}
	function baseDifference(array, values, iteratee, comparator) {
			var index = -1,
					includes = arrayIncludes,
					isCommon = true,
					length = array.length,
					result = [],
					valuesLength = values.length;

			if (!length) {
		return result;
			}
			if (iteratee) {
		values = arrayMap(values, baseUnary(iteratee));
			}
			if (comparator) {
		includes = arrayIncludesWith;
		isCommon = false;
			} else if (values.length >= LARGE_ARRAY_SIZE) {
		includes = cacheHas;
		isCommon = false;
		values = new SetCache(values);
			}
			outer: while (++index < length) {
		var value = array[index],
			computed = iteratee == null ? value : iteratee(value);

		value = comparator || value !== 0 ? value : 0;
		if (isCommon && computed === computed) {
					var valuesIndex = valuesLength;
					while (valuesIndex--) {
			if (values[valuesIndex] === computed) {
							continue outer;
			}
					}
					result.push(value);
		} else if (!includes(values, computed, comparator)) {
					result.push(value);
		}
			}
			return result;
	}
	var baseEach = createBaseEach(baseForOwn);
	var baseEachRight = createBaseEach(baseForOwnRight, true);
	function baseEvery(collection, predicate) {
			var result = true;
			baseEach(collection, function (value, index, collection) {
		result = !!predicate(value, index, collection);
		return result;
			});
			return result;
	}
	function baseExtremum(array, iteratee, comparator) {
			var index = -1,
					length = array.length;

			while (++index < length) {
		var value = array[index],
			current = iteratee(value);

		if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
					var computed = current,
							result = value;
		}
			}
			return result;
	}
	function baseFill(array, value, start, end) {
			var length = array.length;

			start = toInteger(start);
			if (start < 0) {
		start = -start > length ? 0 : length + start;
			}
			end = end === undefined || end > length ? length : toInteger(end);
			if (end < 0) {
		end += length;
			}
			end = start > end ? 0 : toLength(end);
			while (start < end) {
		array[start++] = value;
			}
			return array;
	}
	function baseFilter(collection, predicate) {
			var result = [];
			baseEach(collection, function (value, index, collection) {
		if (predicate(value, index, collection)) {
					result.push(value);
		}
			});
			return result;
	}
	function baseFlatten(array, depth, predicate, isStrict, result) {
			var index = -1,
					length = array.length;

			predicate || (predicate = isFlattenable);
			result || (result = []);

			while (++index < length) {
		var value = array[index];
		if (depth > 0 && predicate(value)) {
					if (depth > 1) {
			baseFlatten(value, depth - 1, predicate, isStrict, result);
					} else {
			arrayPush(result, value);
					}
		} else if (!isStrict) {
					result[result.length] = value;
		}
			}
			return result;
	}
	var baseFor = createBaseFor();
	var baseForRight = createBaseFor(true);
	function baseForOwn(object, iteratee) {
			return object && baseFor(object, iteratee, keys);
	}
	function baseForOwnRight(object, iteratee) {
			return object && baseForRight(object, iteratee, keys);
	}
	function baseFunctions(object, props) {
			return arrayFilter(props, function (key) {
		return isFunction(object[key]);
			});
	}
	function baseGet(object, path) {
			path = castPath(path, object);

			var index = 0,
					length = path.length;

			while (object != null && index < length) {
		object = object[toKey(path[index++])];
			}
			return index && index == length ? object : undefined;
	}
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
			var result = keysFunc(object);
			return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}
	function baseGetTag(value) {
			if (value == null) {
		return value === undefined ? undefinedTag : nullTag;
			}
			return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
	}
	function baseGt(value, other) {
			return value > other;
	}
	function baseHas(object, key) {
			return object != null && hasOwnProperty.call(object, key);
	}
	function baseHasIn(object, key) {
			return object != null && key in Object(object);
	}
	function baseInRange(number, start, end) {
			return number >= nativeMin(start, end) && number < nativeMax(start, end);
	}
	function baseIntersection(arrays, iteratee, comparator) {
			var includes = comparator ? arrayIncludesWith : arrayIncludes,
					length = arrays[0].length,
					othLength = arrays.length,
					othIndex = othLength,
					caches = Array(othLength),
					maxLength = Infinity,
					result = [];

			while (othIndex--) {
		var array = arrays[othIndex];
		if (othIndex && iteratee) {
					array = arrayMap(array, baseUnary(iteratee));
		}
		maxLength = nativeMin(array.length, maxLength);
		caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
			}
			array = arrays[0];

			var index = -1,
					seen = caches[0];

			outer: while (++index < length && result.length < maxLength) {
		var value = array[index],
			computed = iteratee ? iteratee(value) : value;

		value = comparator || value !== 0 ? value : 0;
		if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
					othIndex = othLength;
					while (--othIndex) {
			var cache = caches[othIndex];
			if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
							continue outer;
			}
					}
					if (seen) {
			seen.push(computed);
					}
					result.push(value);
		}
			}
			return result;
	}
	function baseInverter(object, setter, iteratee, accumulator) {
			baseForOwn(object, function (value, key, object) {
		setter(accumulator, iteratee(value), key, object);
			});
			return accumulator;
	}
	function baseInvoke(object, path, args) {
			path = castPath(path, object);
			object = parent(object, path);
			var func = object == null ? object : object[toKey(last(path))];
			return func == null ? undefined : apply(func, object, args);
	}
	function baseIsArguments(value) {
			return isObjectLike(value) && baseGetTag(value) == argsTag;
	}
	function baseIsArrayBuffer(value) {
			return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
	}
	function baseIsDate(value) {
			return isObjectLike(value) && baseGetTag(value) == dateTag;
	}
	function baseIsEqual(value, other, bitmask, customizer, stack) {
			if (value === other) {
		return true;
			}
			if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
		return value !== value && other !== other;
			}
			return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
			var objIsArr = isArray(object),
					othIsArr = isArray(other),
					objTag = objIsArr ? arrayTag : getTag(object),
					othTag = othIsArr ? arrayTag : getTag(other);

			objTag = objTag == argsTag ? objectTag : objTag;
			othTag = othTag == argsTag ? objectTag : othTag;

			var objIsObj = objTag == objectTag,
					othIsObj = othTag == objectTag,
					isSameTag = objTag == othTag;

			if (isSameTag && isBuffer(object)) {
		if (!isBuffer(other)) {
					return false;
		}
		objIsArr = true;
		objIsObj = false;
			}
			if (isSameTag && !objIsObj) {
		stack || (stack = new Stack());
		return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
			}
			if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
		var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
			othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

		if (objIsWrapped || othIsWrapped) {
					var objUnwrapped = objIsWrapped ? object.value() : object,
							othUnwrapped = othIsWrapped ? other.value() : other;

					stack || (stack = new Stack());
					return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
		}
			}
			if (!isSameTag) {
		return false;
			}
			stack || (stack = new Stack());
			return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}
	function baseIsMap(value) {
			return isObjectLike(value) && getTag(value) == mapTag;
	}
	function baseIsMatch(object, source, matchData, customizer) {
			var index = matchData.length,
					length = index,
					noCustomizer = !customizer;

			if (object == null) {
		return !length;
			}
			object = Object(object);
			while (index--) {
		var data = matchData[index];
		if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
					return false;
		}
			}
			while (++index < length) {
		data = matchData[index];
		var key = data[0],
			objValue = object[key],
			srcValue = data[1];

		if (noCustomizer && data[2]) {
					if (objValue === undefined && !(key in object)) {
			return false;
					}
		} else {
					var stack = new Stack();
					if (customizer) {
			var result = customizer(objValue, srcValue, key, object, source, stack);
					}
					if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
			return false;
					}
		}
			}
			return true;
	}
	function baseIsNative(value) {
			if (!isObject(value) || isMasked(value)) {
		return false;
			}
			var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
			return pattern.test(toSource(value));
	}
	function baseIsRegExp(value) {
			return isObjectLike(value) && baseGetTag(value) == regexpTag;
	}
	function baseIsSet(value) {
			return isObjectLike(value) && getTag(value) == setTag;
	}
	function baseIsTypedArray(value) {
			return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}
	function baseIteratee(value) {
			if (typeof value == 'function') {
		return value;
			}
			if (value == null) {
		return identity;
			}
			if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
		return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
			}
			return property(value);
	}
	function baseKeys(object) {
			if (!isPrototype(object)) {
		return nativeKeys(object);
			}
			var result = [];
			for (var key in Object(object)) {
		if (hasOwnProperty.call(object, key) && key != 'constructor') {
					result.push(key);
		}
			}
			return result;
	}
	function baseKeysIn(object) {
			if (!isObject(object)) {
		return nativeKeysIn(object);
			}
			var isProto = isPrototype(object),
					result = [];

			for (var key in object) {
		if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
					result.push(key);
		}
			}
			return result;
	}
	function baseLt(value, other) {
			return value < other;
	}
	function baseMap(collection, iteratee) {
			var index = -1,
					result = isArrayLike(collection) ? Array(collection.length) : [];

			baseEach(collection, function (value, key, collection) {
		result[++index] = iteratee(value, key, collection);
			});
			return result;
	}
	function baseMatches(source) {
			var matchData = getMatchData(source);
			if (matchData.length == 1 && matchData[0][2]) {
		return matchesStrictComparable(matchData[0][0], matchData[0][1]);
			}
			return function (object) {
		return object === source || baseIsMatch(object, source, matchData);
			};
	}
	function baseMatchesProperty(path, srcValue) {
			if (isKey(path) && isStrictComparable(srcValue)) {
		return matchesStrictComparable(toKey(path), srcValue);
			}
			return function (object) {
		var objValue = get(object, path);
		return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
			};
	}
	function baseMerge(object, source, srcIndex, customizer, stack) {
			if (object === source) {
		return;
			}
			baseFor(source, function (srcValue, key) {
		if (isObject(srcValue)) {
					stack || (stack = new Stack());
					baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
		} else {
					var newValue = customizer ? customizer(object[key], srcValue, key + '', object, source, stack) : undefined;

					if (newValue === undefined) {
			newValue = srcValue;
					}
					assignMergeValue(object, key, newValue);
		}
			}, keysIn);
	}
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
			var objValue = object[key],
					srcValue = source[key],
					stacked = stack.get(srcValue);

			if (stacked) {
		assignMergeValue(object, key, stacked);
		return;
			}
			var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;

			var isCommon = newValue === undefined;

			if (isCommon) {
		var isArr = isArray(srcValue),
			isBuff = !isArr && isBuffer(srcValue),
			isTyped = !isArr && !isBuff && isTypedArray(srcValue);

		newValue = srcValue;
		if (isArr || isBuff || isTyped) {
					if (isArray(objValue)) {
			newValue = objValue;
					} else if (isArrayLikeObject(objValue)) {
			newValue = copyArray(objValue);
					} else if (isBuff) {
			isCommon = false;
			newValue = cloneBuffer(srcValue, true);
					} else if (isTyped) {
			isCommon = false;
			newValue = cloneTypedArray(srcValue, true);
					} else {
			newValue = [];
					}
		} else if (isPlainObject(srcValue) || isArguments(srcValue)) {
					newValue = objValue;
					if (isArguments(objValue)) {
			newValue = toPlainObject(objValue);
					} else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
			newValue = initCloneObject(srcValue);
					}
		} else {
					isCommon = false;
		}
			}
			if (isCommon) {
		stack.set(srcValue, newValue);
		mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
		stack['delete'](srcValue);
			}
			assignMergeValue(object, key, newValue);
	}
	function baseNth(array, n) {
			var length = array.length;
			if (!length) {
		return;
			}
			n += n < 0 ? length : 0;
			return isIndex(n, length) ? array[n] : undefined;
	}
	function baseOrderBy(collection, iteratees, orders) {
			var index = -1;
			iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

			var result = baseMap(collection, function (value, key, collection) {
		var criteria = arrayMap(iteratees, function (iteratee) {
					return iteratee(value);
		});
		return { 'criteria': criteria, 'index': ++index, 'value': value };
			});

			return baseSortBy(result, function (object, other) {
		return compareMultiple(object, other, orders);
			});
	}
	function basePick(object, paths) {
			return basePickBy(object, paths, function (value, path) {
		return hasIn(object, path);
			});
	}
	function basePickBy(object, paths, predicate) {
			var index = -1,
					length = paths.length,
					result = {};

			while (++index < length) {
		var path = paths[index],
			value = baseGet(object, path);

		if (predicate(value, path)) {
					baseSet(result, castPath(path, object), value);
		}
			}
			return result;
	}
	function basePropertyDeep(path) {
			return function (object) {
		return baseGet(object, path);
			};
	}
	function basePullAll(array, values, iteratee, comparator) {
			var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
					index = -1,
					length = values.length,
					seen = array;

			if (array === values) {
		values = copyArray(values);
			}
			if (iteratee) {
		seen = arrayMap(array, baseUnary(iteratee));
			}
			while (++index < length) {
		var fromIndex = 0,
			value = values[index],
			computed = iteratee ? iteratee(value) : value;

		while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
					if (seen !== array) {
			splice.call(seen, fromIndex, 1);
					}
					splice.call(array, fromIndex, 1);
		}
			}
			return array;
	}
	function basePullAt(array, indexes) {
			var length = array ? indexes.length : 0,
					lastIndex = length - 1;

			while (length--) {
		var index = indexes[length];
		if (length == lastIndex || index !== previous) {
					var previous = index;
					if (isIndex(index)) {
			splice.call(array, index, 1);
					} else {
			baseUnset(array, index);
					}
		}
			}
			return array;
	}
	function baseRandom(lower, upper) {
			return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	}
	function baseRange(start, end, step, fromRight) {
			var index = -1,
					length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
					result = Array(length);

			while (length--) {
		result[fromRight ? length : ++index] = start;
		start += step;
			}
			return result;
	}
	function baseRepeat(string, n) {
			var result = '';
			if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
		return result;
			}
			do {
		if (n % 2) {
					result += string;
		}
		n = nativeFloor(n / 2);
		if (n) {
					string += string;
		}
			} while (n);

			return result;
	}
	function baseRest(func, start) {
			return setToString(overRest(func, start, identity), func + '');
	}
	function baseSample(collection) {
			return arraySample(values(collection));
	}
	function baseSampleSize(collection, n) {
			var array = values(collection);
			return shuffleSelf(array, baseClamp(n, 0, array.length));
	}
	function baseSet(object, path, value, customizer) {
			if (!isObject(object)) {
		return object;
			}
			path = castPath(path, object);

			var index = -1,
					length = path.length,
					lastIndex = length - 1,
					nested = object;

			while (nested != null && ++index < length) {
		var key = toKey(path[index]),
			newValue = value;

		if (index != lastIndex) {
					var objValue = nested[key];
					newValue = customizer ? customizer(objValue, key, nested) : undefined;
					if (newValue === undefined) {
			newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
					}
		}
		assignValue(nested, key, newValue);
		nested = nested[key];
			}
			return object;
	}
	var baseSetData = !metaMap ? identity : function (func, data) {
			metaMap.set(func, data);
			return func;
	};
	var baseSetToString = !defineProperty ? identity : function (func, string) {
			return defineProperty(func, 'toString', {
		'configurable': true,
		'enumerable': false,
		'value': constant(string),
		'writable': true
			});
	};
	function baseShuffle(collection) {
			return shuffleSelf(values(collection));
	}
	function baseSlice(array, start, end) {
			var index = -1,
					length = array.length;

			if (start < 0) {
		start = -start > length ? 0 : length + start;
			}
			end = end > length ? length : end;
			if (end < 0) {
		end += length;
			}
			length = start > end ? 0 : end - start >>> 0;
			start >>>= 0;

			var result = Array(length);
			while (++index < length) {
		result[index] = array[index + start];
			}
			return result;
	}
	function baseSome(collection, predicate) {
			var result;

			baseEach(collection, function (value, index, collection) {
		result = predicate(value, index, collection);
		return !result;
			});
			return !!result;
	}
	function baseSortedIndex(array, value, retHighest) {
			var low = 0,
					high = array == null ? low : array.length;

			if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
		while (low < high) {
					var mid = low + high >>> 1,
							computed = array[mid];

					if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
			low = mid + 1;
					} else {
			high = mid;
					}
		}
		return high;
			}
			return baseSortedIndexBy(array, value, identity, retHighest);
	}
	function baseSortedIndexBy(array, value, iteratee, retHighest) {
			value = iteratee(value);

			var low = 0,
					high = array == null ? 0 : array.length,
					valIsNaN = value !== value,
					valIsNull = value === null,
					valIsSymbol = isSymbol(value),
					valIsUndefined = value === undefined;

			while (low < high) {
		var mid = nativeFloor((low + high) / 2),
			computed = iteratee(array[mid]),
			othIsDefined = computed !== undefined,
			othIsNull = computed === null,
			othIsReflexive = computed === computed,
			othIsSymbol = isSymbol(computed);

		if (valIsNaN) {
					var setLow = retHighest || othIsReflexive;
		} else if (valIsUndefined) {
					setLow = othIsReflexive && (retHighest || othIsDefined);
		} else if (valIsNull) {
					setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
		} else if (valIsSymbol) {
					setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
		} else if (othIsNull || othIsSymbol) {
					setLow = false;
		} else {
					setLow = retHighest ? computed <= value : computed < value;
		}
		if (setLow) {
					low = mid + 1;
		} else {
					high = mid;
		}
			}
			return nativeMin(high, MAX_ARRAY_INDEX);
	}
	function baseSortedUniq(array, iteratee) {
			var index = -1,
					length = array.length,
					resIndex = 0,
					result = [];

			while (++index < length) {
		var value = array[index],
			computed = iteratee ? iteratee(value) : value;

		if (!index || !eq(computed, seen)) {
					var seen = computed;
					result[resIndex++] = value === 0 ? 0 : value;
		}
			}
			return result;
	}
	function baseToNumber(value) {
			if (typeof value == 'number') {
		return value;
			}
			if (isSymbol(value)) {
		return NAN;
			}
			return +value;
	}
	function baseToString(value) {
			if (typeof value == 'string') {
		return value;
			}
			if (isArray(value)) {
		return arrayMap(value, baseToString) + '';
			}
			if (isSymbol(value)) {
		return symbolToString ? symbolToString.call(value) : '';
			}
			var result = value + '';
			return result == '0' && 1 / value == -INFINITY ? '-0' : result;
	}
	function baseUniq(array, iteratee, comparator) {
			var index = -1,
					includes = arrayIncludes,
					length = array.length,
					isCommon = true,
					result = [],
					seen = result;

			if (comparator) {
		isCommon = false;
		includes = arrayIncludesWith;
			} else if (length >= LARGE_ARRAY_SIZE) {
		var set = iteratee ? null : createSet(array);
		if (set) {
					return setToArray(set);
		}
		isCommon = false;
		includes = cacheHas;
		seen = new SetCache();
			} else {
		seen = iteratee ? [] : result;
			}
			outer: while (++index < length) {
		var value = array[index],
			computed = iteratee ? iteratee(value) : value;

		value = comparator || value !== 0 ? value : 0;
		if (isCommon && computed === computed) {
					var seenIndex = seen.length;
					while (seenIndex--) {
			if (seen[seenIndex] === computed) {
							continue outer;
			}
					}
					if (iteratee) {
			seen.push(computed);
					}
					result.push(value);
		} else if (!includes(seen, computed, comparator)) {
					if (seen !== result) {
			seen.push(computed);
					}
					result.push(value);
		}
			}
			return result;
	}
	function baseUnset(object, path) {
			path = castPath(path, object);
			object = parent(object, path);
			return object == null || delete object[toKey(last(path))];
	}
	function baseUpdate(object, path, updater, customizer) {
			return baseSet(object, path, updater(baseGet(object, path)), customizer);
	}
	function baseWhile(array, predicate, isDrop, fromRight) {
			var length = array.length,
					index = fromRight ? length : -1;

			while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}

			return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
	}
	function baseWrapperValue(value, actions) {
			var result = value;
			if (result instanceof LazyWrapper) {
		result = result.value();
			}
			return arrayReduce(actions, function (result, action) {
		return action.func.apply(action.thisArg, arrayPush([result], action.args));
			}, result);
	}
	function baseXor(arrays, iteratee, comparator) {
			var length = arrays.length;
			if (length < 2) {
		return length ? baseUniq(arrays[0]) : [];
			}
			var index = -1,
					result = Array(length);

			while (++index < length) {
		var array = arrays[index],
			othIndex = -1;

		while (++othIndex < length) {
					if (othIndex != index) {
			result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
					}
		}
			}
			return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	}
	function baseZipObject(props, values, assignFunc) {
			var index = -1,
					length = props.length,
					valsLength = values.length,
					result = {};

			while (++index < length) {
		var value = index < valsLength ? values[index] : undefined;
		assignFunc(result, props[index], value);
			}
			return result;
	}
	function castArrayLikeObject(value) {
			return isArrayLikeObject(value) ? value : [];
	}
	function castFunction(value) {
			return typeof value == 'function' ? value : identity;
	}
	function castPath(value, object) {
			if (isArray(value)) {
		return value;
			}
			return isKey(value, object) ? [value] : stringToPath(toString(value));
	}
	var castRest = baseRest;
	function castSlice(array, start, end) {
			var length = array.length;
			end = end === undefined ? length : end;
			return !start && end >= length ? array : baseSlice(array, start, end);
	}
	var clearTimeout = ctxClearTimeout || function (id) {
			return root.clearTimeout(id);
	};
	function cloneBuffer(buffer, isDeep) {
			if (isDeep) {
		return buffer.slice();
			}
			var length = buffer.length,
					result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

			buffer.copy(result);
			return result;
	}
	function cloneArrayBuffer(arrayBuffer) {
			var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
			new Uint8Array(result).set(new Uint8Array(arrayBuffer));
			return result;
	}
	function cloneDataView(dataView, isDeep) {
			var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
			return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}
	function cloneMap(map, isDeep, cloneFunc) {
			var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
			return arrayReduce(array, addMapEntry, new map.constructor());
	}
	function cloneRegExp(regexp) {
			var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
			result.lastIndex = regexp.lastIndex;
			return result;
	}
	function cloneSet(set, isDeep, cloneFunc) {
			var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
			return arrayReduce(array, addSetEntry, new set.constructor());
	}
	function cloneSymbol(symbol) {
			return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}
	function cloneTypedArray(typedArray, isDeep) {
			var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
			return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}
	function compareAscending(value, other) {
			if (value !== other) {
		var valIsDefined = value !== undefined,
			valIsNull = value === null,
			valIsReflexive = value === value,
			valIsSymbol = isSymbol(value);

		var othIsDefined = other !== undefined,
			othIsNull = other === null,
			othIsReflexive = other === other,
			othIsSymbol = isSymbol(other);

		if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
					return 1;
		}
		if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
					return -1;
		}
			}
			return 0;
	}
	function compareMultiple(object, other, orders) {
			var index = -1,
					objCriteria = object.criteria,
					othCriteria = other.criteria,
					length = objCriteria.length,
					ordersLength = orders.length;

			while (++index < length) {
		var result = compareAscending(objCriteria[index], othCriteria[index]);
		if (result) {
					if (index >= ordersLength) {
			return result;
					}
					var order = orders[index];
					return result * (order == 'desc' ? -1 : 1);
		}
			}
			//
			return object.index - other.index;
	}
	function composeArgs(args, partials, holders, isCurried) {
			var argsIndex = -1,
					argsLength = args.length,
					holdersLength = holders.length,
					leftIndex = -1,
					leftLength = partials.length,
					rangeLength = nativeMax(argsLength - holdersLength, 0),
					result = Array(leftLength + rangeLength),
					isUncurried = !isCurried;

			while (++leftIndex < leftLength) {
		result[leftIndex] = partials[leftIndex];
			}
			while (++argsIndex < holdersLength) {
		if (isUncurried || argsIndex < argsLength) {
					result[holders[argsIndex]] = args[argsIndex];
		}
			}
			while (rangeLength--) {
		result[leftIndex++] = args[argsIndex++];
			}
			return result;
	}
	function composeArgsRight(args, partials, holders, isCurried) {
			var argsIndex = -1,
					argsLength = args.length,
					holdersIndex = -1,
					holdersLength = holders.length,
					rightIndex = -1,
					rightLength = partials.length,
					rangeLength = nativeMax(argsLength - holdersLength, 0),
					result = Array(rangeLength + rightLength),
					isUncurried = !isCurried;

			while (++argsIndex < rangeLength) {
		result[argsIndex] = args[argsIndex];
			}
			var offset = argsIndex;
			while (++rightIndex < rightLength) {
		result[offset + rightIndex] = partials[rightIndex];
			}
			while (++holdersIndex < holdersLength) {
		if (isUncurried || argsIndex < argsLength) {
					result[offset + holders[holdersIndex]] = args[argsIndex++];
		}
			}
			return result;
	}
	function copyArray(source, array) {
			var index = -1,
					length = source.length;

			array || (array = Array(length));
			while (++index < length) {
		array[index] = source[index];
			}
			return array;
	}
	function copyObject(source, props, object, customizer) {
			var isNew = !object;
			object || (object = {});

			var index = -1,
					length = props.length;

			while (++index < length) {
		var key = props[index];

		var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

		if (newValue === undefined) {
					newValue = source[key];
		}
		if (isNew) {
					baseAssignValue(object, key, newValue);
		} else {
					assignValue(object, key, newValue);
		}
			}
			return object;
	}
	function copySymbols(source, object) {
			return copyObject(source, getSymbols(source), object);
	}
	function copySymbolsIn(source, object) {
			return copyObject(source, getSymbolsIn(source), object);
	}
	function createAggregator(setter, initializer) {
			return function (collection, iteratee) {
		var func = isArray(collection) ? arrayAggregator : baseAggregator,
			accumulator = initializer ? initializer() : {};

		return func(collection, setter, getIteratee(iteratee, 2), accumulator);
			};
	}
	function createAssigner(assigner) {
			return baseRest(function (object, sources) {
		var index = -1,
			length = sources.length,
			customizer = length > 1 ? sources[length - 1] : undefined,
			guard = length > 2 ? sources[2] : undefined;

		customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

		if (guard && isIterateeCall(sources[0], sources[1], guard)) {
					customizer = length < 3 ? undefined : customizer;
					length = 1;
		}
		object = Object(object);
		while (++index < length) {
					var source = sources[index];
					if (source) {
			assigner(object, source, index, customizer);
					}
		}
		return object;
			});
	}
	function createBaseEach(eachFunc, fromRight) {
			return function (collection, iteratee) {
		if (collection == null) {
					return collection;
		}
		if (!isArrayLike(collection)) {
					return eachFunc(collection, iteratee);
		}
		var length = collection.length,
			index = fromRight ? length : -1,
			iterable = Object(collection);

		while (fromRight ? index-- : ++index < length) {
					if (iteratee(iterable[index], index, iterable) === false) {
			break;
					}
		}
		return collection;
			};
	}
	function createBaseFor(fromRight) {
			return function (object, iteratee, keysFunc) {
		var index = -1,
			iterable = Object(object),
			props = keysFunc(object),
			length = props.length;

		while (length--) {
					var key = props[fromRight ? length : ++index];
					if (iteratee(iterable[key], key, iterable) === false) {
			break;
					}
		}
		return object;
			};
	}
	function createBind(func, bitmask, thisArg) {
			var isBind = bitmask & WRAP_BIND_FLAG,
					Ctor = createCtor(func);

			function wrapper() {
		var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
		return fn.apply(isBind ? thisArg : this, arguments);
			}
			return wrapper;
	}
	function createCaseFirst(methodName) {
			return function (string) {
		string = toString(string);

		var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;

		var chr = strSymbols ? strSymbols[0] : string.charAt(0);

		var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);

		return chr[methodName]() + trailing;
			};
	}
	function createCompounder(callback) {
			return function (string) {
		return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
			};
	}
	function createCtor(Ctor) {
			return function () {
		var args = arguments;
		switch (args.length) {
					case 0:
			return new Ctor();
					case 1:
			return new Ctor(args[0]);
					case 2:
			return new Ctor(args[0], args[1]);
					case 3:
			return new Ctor(args[0], args[1], args[2]);
					case 4:
			return new Ctor(args[0], args[1], args[2], args[3]);
					case 5:
			return new Ctor(args[0], args[1], args[2], args[3], args[4]);
					case 6:
			return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
					case 7:
			return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
		}
		var thisBinding = baseCreate(Ctor.prototype),
			result = Ctor.apply(thisBinding, args);
		return isObject(result) ? result : thisBinding;
			};
	}
	function createCurry(func, bitmask, arity) {
			var Ctor = createCtor(func);

			function wrapper() {
		var length = arguments.length,
			args = Array(length),
			index = length,
			placeholder = getHolder(wrapper);

		while (index--) {
					args[index] = arguments[index];
		}
		var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);

		length -= holders.length;
		if (length < arity) {
					return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
		}
		var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
		return apply(fn, this, args);
			}
			return wrapper;
	}
	function createFind(findIndexFunc) {
			return function (collection, predicate, fromIndex) {
		var iterable = Object(collection);
		if (!isArrayLike(collection)) {
					var iteratee = getIteratee(predicate, 3);
					collection = keys(collection);
					predicate = function predicate(key) {
			return iteratee(iterable[key], key, iterable);
					};
		}
		var index = findIndexFunc(collection, predicate, fromIndex);
		return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
			};
	}
	function createFlow(fromRight) {
			return flatRest(function (funcs) {
		var length = funcs.length,
			index = length,
			prereq = LodashWrapper.prototype.thru;

		if (fromRight) {
					funcs.reverse();
		}
		while (index--) {
					var func = funcs[index];
					if (typeof func != 'function') {
			throw new TypeError(FUNC_ERROR_TEXT);
					}
					if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
			var wrapper = new LodashWrapper([], true);
					}
		}
		index = wrapper ? index : length;
		while (++index < length) {
					func = funcs[index];

					var funcName = getFuncName(func),
							data = funcName == 'wrapper' ? getData(func) : undefined;

					if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
			wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
					} else {
			wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
					}
		}
		return function () {
					var args = arguments,
							value = args[0];

					if (wrapper && args.length == 1 && isArray(value)) {
			return wrapper.plant(value).value();
					}
					var index = 0,
							result = length ? funcs[index].apply(this, args) : value;

					while (++index < length) {
			result = funcs[index].call(this, result);
					}
					return result;
		};
			});
	}
	function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
			var isAry = bitmask & WRAP_ARY_FLAG,
					isBind = bitmask & WRAP_BIND_FLAG,
					isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
					isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
					isFlip = bitmask & WRAP_FLIP_FLAG,
					Ctor = isBindKey ? undefined : createCtor(func);

			function wrapper() {
		var length = arguments.length,
			args = Array(length),
			index = length;

		while (index--) {
					args[index] = arguments[index];
		}
		if (isCurried) {
					var placeholder = getHolder(wrapper),
							holdersCount = countHolders(args, placeholder);
		}
		if (partials) {
					args = composeArgs(args, partials, holders, isCurried);
		}
		if (partialsRight) {
					args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
		}
		length -= holdersCount;
		if (isCurried && length < arity) {
					var newHolders = replaceHolders(args, placeholder);
					return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
		}
		var thisBinding = isBind ? thisArg : this,
			fn = isBindKey ? thisBinding[func] : func;

		length = args.length;
		if (argPos) {
					args = reorder(args, argPos);
		} else if (isFlip && length > 1) {
					args.reverse();
		}
		if (isAry && ary < length) {
					args.length = ary;
		}
		if (this && this !== root && this instanceof wrapper) {
					fn = Ctor || createCtor(fn);
		}
		return fn.apply(thisBinding, args);
			}
			return wrapper;
	}
	function createInverter(setter, toIteratee) {
			return function (object, iteratee) {
		return baseInverter(object, setter, toIteratee(iteratee), {});
			};
	}
	function createMathOperation(operator, defaultValue) {
			return function (value, other) {
		var result;
		if (value === undefined && other === undefined) {
					return defaultValue;
		}
		if (value !== undefined) {
					result = value;
		}
		if (other !== undefined) {
					if (result === undefined) {
			return other;
					}
					if (typeof value == 'string' || typeof other == 'string') {
			value = baseToString(value);
			other = baseToString(other);
					} else {
			value = baseToNumber(value);
			other = baseToNumber(other);
					}
					result = operator(value, other);
		}
		return result;
			};
	}
	function createOver(arrayFunc) {
			return flatRest(function (iteratees) {
		iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
		return baseRest(function (args) {
					var thisArg = this;
					return arrayFunc(iteratees, function (iteratee) {
			return apply(iteratee, thisArg, args);
					});
		});
			});
	}
	function createPadding(length, chars) {
			chars = chars === undefined ? ' ' : baseToString(chars);

			var charsLength = chars.length;
			if (charsLength < 2) {
		return charsLength ? baseRepeat(chars, length) : chars;
			}
			var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
			return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
	}
	function createPartial(func, bitmask, thisArg, partials) {
			var isBind = bitmask & WRAP_BIND_FLAG,
					Ctor = createCtor(func);

			function wrapper() {
		var argsIndex = -1,
			argsLength = arguments.length,
			leftIndex = -1,
			leftLength = partials.length,
			args = Array(leftLength + argsLength),
			fn = this && this !== root && this instanceof wrapper ? Ctor : func;

		while (++leftIndex < leftLength) {
					args[leftIndex] = partials[leftIndex];
		}
		while (argsLength--) {
					args[leftIndex++] = arguments[++argsIndex];
		}
		return apply(fn, isBind ? thisArg : this, args);
			}
			return wrapper;
	}
	function createRange(fromRight) {
			return function (start, end, step) {
		if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
					end = step = undefined;
		}
		start = toFinite(start);
		if (end === undefined) {
					end = start;
					start = 0;
		} else {
					end = toFinite(end);
		}
		step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
		return baseRange(start, end, step, fromRight);
			};
	}
	function createRelationalOperation(operator) {
			return function (value, other) {
		if (!(typeof value == 'string' && typeof other == 'string')) {
					value = toNumber(value);
					other = toNumber(other);
		}
		return operator(value, other);
			};
	}
	function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
			var isCurry = bitmask & WRAP_CURRY_FLAG,
					newHolders = isCurry ? holders : undefined,
					newHoldersRight = isCurry ? undefined : holders,
					newPartials = isCurry ? partials : undefined,
					newPartialsRight = isCurry ? undefined : partials;

			bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
			bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

			if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
		bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
			}
			var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];

			var result = wrapFunc.apply(undefined, newData);
			if (isLaziable(func)) {
		setData(result, newData);
			}
			result.placeholder = placeholder;
			return setWrapToString(result, func, bitmask);
	}
	function createRound(methodName) {
			var func = Math[methodName];
			return function (number, precision) {
		number = toNumber(number);
		precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
		if (precision) {
					var pair = (toString(number) + 'e').split('e'),
							value = func(pair[0] + 'e' + (+pair[1] + precision));

					pair = (toString(value) + 'e').split('e');
					return +(pair[0] + 'e' + (+pair[1] - precision));
		}
		return func(number);
			};
	}
	var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
			return new Set(values);
	};
	function createToPairs(keysFunc) {
			return function (object) {
		var tag = getTag(object);
		if (tag == mapTag) {
					return mapToArray(object);
		}
		if (tag == setTag) {
					return setToPairs(object);
		}
		return baseToPairs(object, keysFunc(object));
			};
	}
	function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
			var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
			if (!isBindKey && typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			var length = partials ? partials.length : 0;
			if (!length) {
		bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
		partials = holders = undefined;
			}
			ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
			arity = arity === undefined ? arity : toInteger(arity);
			length -= holders ? holders.length : 0;

			if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
		var partialsRight = partials,
			holdersRight = holders;

		partials = holders = undefined;
			}
			var data = isBindKey ? undefined : getData(func);

			var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

			if (data) {
		mergeData(newData, data);
			}
			func = newData[0];
			bitmask = newData[1];
			thisArg = newData[2];
			partials = newData[3];
			holders = newData[4];
			arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);

			if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
		bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
			}
			if (!bitmask || bitmask == WRAP_BIND_FLAG) {
		var result = createBind(func, bitmask, thisArg);
			} else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
		result = createCurry(func, bitmask, arity);
			} else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
		result = createPartial(func, bitmask, thisArg, partials);
			} else {
		result = createHybrid.apply(undefined, newData);
			}
			var setter = data ? baseSetData : setData;
			return setWrapToString(setter(result, newData), func, bitmask);
	}
	function customDefaultsAssignIn(objValue, srcValue, key, object) {
			if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
		return srcValue;
			}
			return objValue;
	}
	function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
			if (isObject(objValue) && isObject(srcValue)) {
		stack.set(srcValue, objValue);
		baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
		stack['delete'](srcValue);
			}
			return objValue;
	}
	function customOmitClone(value) {
			return isPlainObject(value) ? undefined : value;
	}
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
			var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
					arrLength = array.length,
					othLength = other.length;

			if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
		return false;
			}
			var stacked = stack.get(array);
			if (stacked && stack.get(other)) {
		return stacked == other;
			}
			var index = -1,
					result = true,
					seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;

			stack.set(array, other);
			stack.set(other, array);
			while (++index < arrLength) {
		var arrValue = array[index],
			othValue = other[index];

		if (customizer) {
					var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
		}
		if (compared !== undefined) {
					if (compared) {
			continue;
					}
					result = false;
					break;
		}
		if (seen) {
					if (!arraySome(other, function (othValue, othIndex) {
			if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
							return seen.push(othIndex);
			}
					})) {
			result = false;
			break;
					}
		} else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
					result = false;
					break;
		}
			}
			stack['delete'](array);
			stack['delete'](other);
			return result;
	}
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
			switch (tag) {
		case dataViewTag:
					if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
			return false;
					}
					object = object.buffer;
					other = other.buffer;

		case arrayBufferTag:
					if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
			return false;
					}
					return true;

		case boolTag:
		case dateTag:
		case numberTag:
					return eq(+object, +other);

		case errorTag:
					return object.name == other.name && object.message == other.message;

		case regexpTag:
		case stringTag:
					return object == other + '';

		case mapTag:
					var convert = mapToArray;

		case setTag:
					var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
					convert || (convert = setToArray);

					if (object.size != other.size && !isPartial) {
			return false;
					}
					var stacked = stack.get(object);
					if (stacked) {
			return stacked == other;
					}
					bitmask |= COMPARE_UNORDERED_FLAG;
					stack.set(object, other);
					var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
					stack['delete'](object);
					return result;

		case symbolTag:
					if (symbolValueOf) {
			return symbolValueOf.call(object) == symbolValueOf.call(other);
					}
			}
			return false;
	}
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
			var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
					objProps = getAllKeys(object),
					objLength = objProps.length,
					othProps = getAllKeys(other),
					othLength = othProps.length;

			if (objLength != othLength && !isPartial) {
		return false;
			}
			var index = objLength;
			while (index--) {
		var key = objProps[index];
		if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
					return false;
		}
			}
			var stacked = stack.get(object);
			if (stacked && stack.get(other)) {
		return stacked == other;
			}
			var result = true;
			stack.set(object, other);
			stack.set(other, object);

			var skipCtor = isPartial;
			while (++index < objLength) {
		key = objProps[index];
		var objValue = object[key],
			othValue = other[key];

		if (customizer) {
					var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
		}
		if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
					result = false;
					break;
		}
		skipCtor || (skipCtor = key == 'constructor');
			}
			if (result && !skipCtor) {
		var objCtor = object.constructor,
			othCtor = other.constructor;
		if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
					result = false;
		}
			}
			stack['delete'](object);
			stack['delete'](other);
			return result;
	}
	function flatRest(func) {
			return setToString(overRest(func, undefined, flatten), func + '');
	}
	function getAllKeys(object) {
			return baseGetAllKeys(object, keys, getSymbols);
	}
	function getAllKeysIn(object) {
			return baseGetAllKeys(object, keysIn, getSymbolsIn);
	}
	var getData = !metaMap ? noop : function (func) {
			return metaMap.get(func);
	};
	function getFuncName(func) {
			var result = func.name + '',
					array = realNames[result],
					length = hasOwnProperty.call(realNames, result) ? array.length : 0;

			while (length--) {
		var data = array[length],
			otherFunc = data.func;
		if (otherFunc == null || otherFunc == func) {
					return data.name;
		}
			}
			return result;
	}
	function getHolder(func) {
			var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
			return object.placeholder;
	}
	function getIteratee() {
			var result = lodash.iteratee || iteratee;
			result = result === iteratee ? baseIteratee : result;
			return arguments.length ? result(arguments[0], arguments[1]) : result;
	}
	function getMapData(map, key) {
			var data = map.__data__;
			return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
	}
	function getMatchData(object) {
			var result = keys(object),
					length = result.length;

			while (length--) {
		var key = result[length],
			value = object[key];

		result[length] = [key, value, isStrictComparable(value)];
			}
			return result;
	}
	function getNative(object, key) {
			var value = getValue(object, key);
			return baseIsNative(value) ? value : undefined;
	}
	function getRawTag(value) {
			var isOwn = hasOwnProperty.call(value, symToStringTag),
					tag = value[symToStringTag];

			try {
		value[symToStringTag] = undefined;
		var unmasked = true;
			} catch (e) {}

			var result = nativeObjectToString.call(value);
			if (unmasked) {
		if (isOwn) {
					value[symToStringTag] = tag;
		} else {
					delete value[symToStringTag];
		}
			}
			return result;
	}
	var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
			if (object == null) {
		return [];
			}
			object = Object(object);
			return arrayFilter(nativeGetSymbols(object), function (symbol) {
		return propertyIsEnumerable.call(object, symbol);
			});
	};
	var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
			var result = [];
			while (object) {
		arrayPush(result, getSymbols(object));
		object = getPrototype(object);
			}
			return result;
	};
	var getTag = baseGetTag;
	if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
			getTag = function getTag(value) {
		var result = baseGetTag(value),
			Ctor = result == objectTag ? value.constructor : undefined,
			ctorString = Ctor ? toSource(Ctor) : '';

		if (ctorString) {
					switch (ctorString) {
			case dataViewCtorString:
							return dataViewTag;
			case mapCtorString:
							return mapTag;
			case promiseCtorString:
							return promiseTag;
			case setCtorString:
							return setTag;
			case weakMapCtorString:
							return weakMapTag;
					}
		}
		return result;
			};
	}
	function getView(start, end, transforms) {
			var index = -1,
					length = transforms.length;

			while (++index < length) {
		var data = transforms[index],
			size = data.size;

		switch (data.type) {
					case 'drop':
			start += size;break;
					case 'dropRight':
			end -= size;break;
					case 'take':
			end = nativeMin(end, start + size);break;
					case 'takeRight':
			start = nativeMax(start, end - size);break;
		}
			}
			return { 'start': start, 'end': end };
	}
	function getWrapDetails(source) {
			var match = source.match(reWrapDetails);
			return match ? match[1].split(reSplitDetails) : [];
	}
	function hasPath(object, path, hasFunc) {
			path = castPath(path, object);

			var index = -1,
					length = path.length,
					result = false;

			while (++index < length) {
		var key = toKey(path[index]);
		if (!(result = object != null && hasFunc(object, key))) {
					break;
		}
		object = object[key];
			}
			if (result || ++index != length) {
		return result;
			}
			length = object == null ? 0 : object.length;
			return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
	}
	function initCloneArray(array) {
			var length = array.length,
					result = array.constructor(length);
			if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
		result.index = array.index;
		result.input = array.input;
			}
			return result;
	}
	function initCloneObject(object) {
			return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
	}
	function initCloneByTag(object, tag, cloneFunc, isDeep) {
			var Ctor = object.constructor;
			switch (tag) {
		case arrayBufferTag:
					return cloneArrayBuffer(object);

		case boolTag:
		case dateTag:
					return new Ctor(+object);

		case dataViewTag:
					return cloneDataView(object, isDeep);

		case float32Tag:case float64Tag:
		case int8Tag:case int16Tag:case int32Tag:
		case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:
					return cloneTypedArray(object, isDeep);

		case mapTag:
					return cloneMap(object, isDeep, cloneFunc);

		case numberTag:
		case stringTag:
					return new Ctor(object);

		case regexpTag:
					return cloneRegExp(object);

		case setTag:
					return cloneSet(object, isDeep, cloneFunc);

		case symbolTag:
					return cloneSymbol(object);
			}
	}
	function insertWrapDetails(source, details) {
			var length = details.length;
			if (!length) {
		return source;
			}
			var lastIndex = length - 1;
			details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
			details = details.join(length > 2 ? ', ' : ' ');
			return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	}
	function isFlattenable(value) {
			return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
	}
	function isIndex(value, length) {
			length = length == null ? MAX_SAFE_INTEGER : length;
			return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
	}
	function isIterateeCall(value, index, object) {
			if (!isObject(object)) {
		return false;
			}
			var type = typeof index === 'undefined' ? 'undefined' : _typeof(index);
			if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
		return eq(object[index], value);
			}
			return false;
	}
	function isKey(value, object) {
			if (isArray(value)) {
		return false;
			}
			var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
			if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
		return true;
			}
			return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
	}
	function isKeyable(value) {
			var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
			return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
	}
	function isLaziable(func) {
			var funcName = getFuncName(func),
					other = lodash[funcName];

			if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
		return false;
			}
			if (func === other) {
		return true;
			}
			var data = getData(other);
			return !!data && func === data[0];
	}
	function isMasked(func) {
			return !!maskSrcKey && maskSrcKey in func;
	}
	var isMaskable = coreJsData ? isFunction : stubFalse;
	function isPrototype(value) {
			var Ctor = value && value.constructor,
					proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

			return value === proto;
	}
	function isStrictComparable(value) {
			return value === value && !isObject(value);
	}
	function matchesStrictComparable(key, srcValue) {
			return function (object) {
		if (object == null) {
					return false;
		}
		return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
			};
	}
	function memoizeCapped(func) {
			var result = memoize(func, function (key) {
		if (cache.size === MAX_MEMOIZE_SIZE) {
					cache.clear();
		}
		return key;
			});

			var cache = result.cache;
			return result;
	}
	function mergeData(data, source) {
			var bitmask = data[1],
					srcBitmask = source[1],
					newBitmask = bitmask | srcBitmask,
					isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

			var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
			if (!(isCommon || isCombo)) {
		return data;
			}
			if (srcBitmask & WRAP_BIND_FLAG) {
		data[2] = source[2];
		newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
			}
			var value = source[3];
			if (value) {
		var partials = data[3];
		data[3] = partials ? composeArgs(partials, value, source[4]) : value;
		data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
			}
			value = source[5];
			if (value) {
		partials = data[5];
		data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
		data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
			}
			value = source[7];
			if (value) {
		data[7] = value;
			}
			if (srcBitmask & WRAP_ARY_FLAG) {
		data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
			}
			if (data[9] == null) {
		data[9] = source[9];
			}
			data[0] = source[0];
			data[1] = newBitmask;

			return data;
	}
	function nativeKeysIn(object) {
			var result = [];
			if (object != null) {
		for (var key in Object(object)) {
					result.push(key);
		}
			}
			return result;
	}
	function objectToString(value) {
			return nativeObjectToString.call(value);
	}
	function overRest(func, start, transform) {
			start = nativeMax(start === undefined ? func.length - 1 : start, 0);
			return function () {
		var args = arguments,
			index = -1,
			length = nativeMax(args.length - start, 0),
			array = Array(length);

		while (++index < length) {
					array[index] = args[start + index];
		}
		index = -1;
		var otherArgs = Array(start + 1);
		while (++index < start) {
					otherArgs[index] = args[index];
		}
		otherArgs[start] = transform(array);
		return apply(func, this, otherArgs);
			};
	}
	function parent(object, path) {
			return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	}
	function reorder(array, indexes) {
			var arrLength = array.length,
					length = nativeMin(indexes.length, arrLength),
					oldArray = copyArray(array);

			while (length--) {
		var index = indexes[length];
		array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
			}
			return array;
	}
	var setData = shortOut(baseSetData);
	var setTimeout = ctxSetTimeout || function (func, wait) {
			return root.setTimeout(func, wait);
	};
	var setToString = shortOut(baseSetToString);
	function setWrapToString(wrapper, reference, bitmask) {
			var source = reference + '';
			return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	}
	function shortOut(func) {
			var count = 0,
					lastCalled = 0;

			return function () {
		var stamp = nativeNow(),
			remaining = HOT_SPAN - (stamp - lastCalled);

		lastCalled = stamp;
		if (remaining > 0) {
					if (++count >= HOT_COUNT) {
			return arguments[0];
					}
		} else {
					count = 0;
		}
		return func.apply(undefined, arguments);
			};
	}
	function shuffleSelf(array, size) {
			var index = -1,
					length = array.length,
					lastIndex = length - 1;

			size = size === undefined ? length : size;
			while (++index < size) {
		var rand = baseRandom(index, lastIndex),
			value = array[rand];

		array[rand] = array[index];
		array[index] = value;
			}
			array.length = size;
			return array;
	}
	var stringToPath = memoizeCapped(function (string) {
			var result = [];
			if (reLeadingDot.test(string)) {
		result.push('');
			}
			string.replace(rePropName, function (match, number, quote, string) {
		result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
			});
			return result;
	});
	function toKey(value) {
			if (typeof value == 'string' || isSymbol(value)) {
		return value;
			}
			var result = value + '';
			return result == '0' && 1 / value == -INFINITY ? '-0' : result;
	}
	function toSource(func) {
			if (func != null) {
		try {
					return funcToString.call(func);
		} catch (e) {}
		try {
					return func + '';
		} catch (e) {}
			}
			return '';
	}
	function updateWrapDetails(details, bitmask) {
			arrayEach(wrapFlags, function (pair) {
		var value = '_.' + pair[0];
		if (bitmask & pair[1] && !arrayIncludes(details, value)) {
					details.push(value);
		}
			});
			return details.sort();
	}
	function wrapperClone(wrapper) {
			if (wrapper instanceof LazyWrapper) {
		return wrapper.clone();
			}
			var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
			result.__actions__ = copyArray(wrapper.__actions__);
			result.__index__ = wrapper.__index__;
			result.__values__ = wrapper.__values__;
			return result;
	}
	function chunk(array, size, guard) {
			if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
		size = 1;
			} else {
		size = nativeMax(toInteger(size), 0);
			}
			var length = array == null ? 0 : array.length;
			if (!length || size < 1) {
		return [];
			}
			var index = 0,
					resIndex = 0,
					result = Array(nativeCeil(length / size));

			while (index < length) {
		result[resIndex++] = baseSlice(array, index, index += size);
			}
			return result;
	}
	function compact(array) {
			var index = -1,
					length = array == null ? 0 : array.length,
					resIndex = 0,
					result = [];

			while (++index < length) {
		var value = array[index];
		if (value) {
					result[resIndex++] = value;
		}
			}
			return result;
	}
	function concat() {
			var length = arguments.length;
			if (!length) {
		return [];
			}
			var args = Array(length - 1),
					array = arguments[0],
					index = length;

			while (index--) {
		args[index - 1] = arguments[index];
			}
			return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
	}
	var difference = baseRest(function (array, values) {
			return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
	});
	var differenceBy = baseRest(function (array, values) {
			var iteratee = last(values);
			if (isArrayLikeObject(iteratee)) {
		iteratee = undefined;
			}
			return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
	});
	var differenceWith = baseRest(function (array, values) {
			var comparator = last(values);
			if (isArrayLikeObject(comparator)) {
		comparator = undefined;
			}
			return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
	});
	function drop(array, n, guard) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return [];
			}
			n = guard || n === undefined ? 1 : toInteger(n);
			return baseSlice(array, n < 0 ? 0 : n, length);
	}
	function dropRight(array, n, guard) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return [];
			}
			n = guard || n === undefined ? 1 : toInteger(n);
			n = length - n;
			return baseSlice(array, 0, n < 0 ? 0 : n);
	}
	function dropRightWhile(array, predicate) {
			return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
	}
	function dropWhile(array, predicate) {
			return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
	}
	function fill(array, value, start, end) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return [];
			}
			if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
		start = 0;
		end = length;
			}
			return baseFill(array, value, start, end);
	}
	function findIndex(array, predicate, fromIndex) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return -1;
			}
			var index = fromIndex == null ? 0 : toInteger(fromIndex);
			if (index < 0) {
		index = nativeMax(length + index, 0);
			}
			return baseFindIndex(array, getIteratee(predicate, 3), index);
	}
	function findLastIndex(array, predicate, fromIndex) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return -1;
			}
			var index = length - 1;
			if (fromIndex !== undefined) {
		index = toInteger(fromIndex);
		index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
			}
			return baseFindIndex(array, getIteratee(predicate, 3), index, true);
	}
	function flatten(array) {
			var length = array == null ? 0 : array.length;
			return length ? baseFlatten(array, 1) : [];
	}
	function flattenDeep(array) {
			var length = array == null ? 0 : array.length;
			return length ? baseFlatten(array, INFINITY) : [];
	}
	function flattenDepth(array, depth) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return [];
			}
			depth = depth === undefined ? 1 : toInteger(depth);
			return baseFlatten(array, depth);
	}
	function fromPairs(pairs) {
			var index = -1,
					length = pairs == null ? 0 : pairs.length,
					result = {};

			while (++index < length) {
		var pair = pairs[index];
		result[pair[0]] = pair[1];
			}
			return result;
	}
	function head(array) {
			return array && array.length ? array[0] : undefined;
	}
	function indexOf(array, value, fromIndex) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return -1;
			}
			var index = fromIndex == null ? 0 : toInteger(fromIndex);
			if (index < 0) {
		index = nativeMax(length + index, 0);
			}
			return baseIndexOf(array, value, index);
	}
	function initial(array) {
			var length = array == null ? 0 : array.length;
			return length ? baseSlice(array, 0, -1) : [];
	}
	var intersection = baseRest(function (arrays) {
			var mapped = arrayMap(arrays, castArrayLikeObject);
			return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
	});
	var intersectionBy = baseRest(function (arrays) {
			var iteratee = last(arrays),
					mapped = arrayMap(arrays, castArrayLikeObject);

			if (iteratee === last(mapped)) {
		iteratee = undefined;
			} else {
		mapped.pop();
			}
			return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
	});
	var intersectionWith = baseRest(function (arrays) {
			var comparator = last(arrays),
					mapped = arrayMap(arrays, castArrayLikeObject);

			comparator = typeof comparator == 'function' ? comparator : undefined;
			if (comparator) {
		mapped.pop();
			}
			return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
	});
	function join(array, separator) {
			return array == null ? '' : nativeJoin.call(array, separator);
	}
	function last(array) {
			var length = array == null ? 0 : array.length;
			return length ? array[length - 1] : undefined;
	}
	function lastIndexOf(array, value, fromIndex) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return -1;
			}
			var index = length;
			if (fromIndex !== undefined) {
		index = toInteger(fromIndex);
		index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
			}
			return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
	}
	function nth(array, n) {
			return array && array.length ? baseNth(array, toInteger(n)) : undefined;
	}
	var pull = baseRest(pullAll);
	function pullAll(array, values) {
			return array && array.length && values && values.length ? basePullAll(array, values) : array;
	}
	function pullAllBy(array, values, iteratee) {
			return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
	}
	function pullAllWith(array, values, comparator) {
			return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
	}
	var pullAt = flatRest(function (array, indexes) {
			var length = array == null ? 0 : array.length,
					result = baseAt(array, indexes);

			basePullAt(array, arrayMap(indexes, function (index) {
		return isIndex(index, length) ? +index : index;
			}).sort(compareAscending));

			return result;
	});
	function remove(array, predicate) {
			var result = [];
			if (!(array && array.length)) {
		return result;
			}
			var index = -1,
					indexes = [],
					length = array.length;

			predicate = getIteratee(predicate, 3);
			while (++index < length) {
		var value = array[index];
		if (predicate(value, index, array)) {
					result.push(value);
					indexes.push(index);
		}
			}
			basePullAt(array, indexes);
			return result;
	}
	function reverse(array) {
			return array == null ? array : nativeReverse.call(array);
	}
	function slice(array, start, end) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return [];
			}
			if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
		start = 0;
		end = length;
			} else {
		start = start == null ? 0 : toInteger(start);
		end = end === undefined ? length : toInteger(end);
			}
			return baseSlice(array, start, end);
	}
	function sortedIndex(array, value) {
			return baseSortedIndex(array, value);
	}
	function sortedIndexBy(array, value, iteratee) {
			return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
	}
	function sortedIndexOf(array, value) {
			var length = array == null ? 0 : array.length;
			if (length) {
		var index = baseSortedIndex(array, value);
		if (index < length && eq(array[index], value)) {
					return index;
		}
			}
			return -1;
	}
	function sortedLastIndex(array, value) {
			return baseSortedIndex(array, value, true);
	}
	function sortedLastIndexBy(array, value, iteratee) {
			return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
	}
	function sortedLastIndexOf(array, value) {
			var length = array == null ? 0 : array.length;
			if (length) {
		var index = baseSortedIndex(array, value, true) - 1;
		if (eq(array[index], value)) {
					return index;
		}
			}
			return -1;
	}
	function sortedUniq(array) {
			return array && array.length ? baseSortedUniq(array) : [];
	}
	function sortedUniqBy(array, iteratee) {
			return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
	}
	function tail(array) {
			var length = array == null ? 0 : array.length;
			return length ? baseSlice(array, 1, length) : [];
	}
	function take(array, n, guard) {
			if (!(array && array.length)) {
		return [];
			}
			n = guard || n === undefined ? 1 : toInteger(n);
			return baseSlice(array, 0, n < 0 ? 0 : n);
	}
	function takeRight(array, n, guard) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return [];
			}
			n = guard || n === undefined ? 1 : toInteger(n);
			n = length - n;
			return baseSlice(array, n < 0 ? 0 : n, length);
	}
	function takeRightWhile(array, predicate) {
			return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
	}
	function takeWhile(array, predicate) {
			return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
	}
	var union = baseRest(function (arrays) {
			return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	});
	var unionBy = baseRest(function (arrays) {
			var iteratee = last(arrays);
			if (isArrayLikeObject(iteratee)) {
		iteratee = undefined;
			}
			return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
	});
	var unionWith = baseRest(function (arrays) {
			var comparator = last(arrays);
			comparator = typeof comparator == 'function' ? comparator : undefined;
			return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
	});
	function uniq(array) {
			return array && array.length ? baseUniq(array) : [];
	}
	function uniqBy(array, iteratee) {
			return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
	}
	function uniqWith(array, comparator) {
			comparator = typeof comparator == 'function' ? comparator : undefined;
			return array && array.length ? baseUniq(array, undefined, comparator) : [];
	}
	function unzip(array) {
			if (!(array && array.length)) {
		return [];
			}
			var length = 0;
			array = arrayFilter(array, function (group) {
		if (isArrayLikeObject(group)) {
					length = nativeMax(group.length, length);
					return true;
		}
			});
			return baseTimes(length, function (index) {
		return arrayMap(array, baseProperty(index));
			});
	}
	function unzipWith(array, iteratee) {
			if (!(array && array.length)) {
		return [];
			}
			var result = unzip(array);
			if (iteratee == null) {
		return result;
			}
			return arrayMap(result, function (group) {
		return apply(iteratee, undefined, group);
			});
	}
	var without = baseRest(function (array, values) {
			return isArrayLikeObject(array) ? baseDifference(array, values) : [];
	});
	var xor = baseRest(function (arrays) {
			return baseXor(arrayFilter(arrays, isArrayLikeObject));
	});
	var xorBy = baseRest(function (arrays) {
			var iteratee = last(arrays);
			if (isArrayLikeObject(iteratee)) {
		iteratee = undefined;
			}
			return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
	});
	var xorWith = baseRest(function (arrays) {
			var comparator = last(arrays);
			comparator = typeof comparator == 'function' ? comparator : undefined;
			return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
	});
	var zip = baseRest(unzip);
	function zipObject(props, values) {
			return baseZipObject(props || [], values || [], assignValue);
	}
	function zipObjectDeep(props, values) {
			return baseZipObject(props || [], values || [], baseSet);
	}
	var zipWith = baseRest(function (arrays) {
			var length = arrays.length,
					iteratee = length > 1 ? arrays[length - 1] : undefined;

			iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
			return unzipWith(arrays, iteratee);
	});
	function chain(value) {
			var result = lodash(value);
			result.__chain__ = true;
			return result;
	}
	function tap(value, interceptor) {
			interceptor(value);
			return value;
	}
	function thru(value, interceptor) {
			return interceptor(value);
	}
	var wrapperAt = flatRest(function (paths) {
			var length = paths.length,
					start = length ? paths[0] : 0,
					value = this.__wrapped__,
					interceptor = function interceptor(object) {
		return baseAt(object, paths);
			};

			if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
		return this.thru(interceptor);
			}
			value = value.slice(start, +start + (length ? 1 : 0));
			value.__actions__.push({
		'func': thru,
		'args': [interceptor],
		'thisArg': undefined
			});
			return new LodashWrapper(value, this.__chain__).thru(function (array) {
		if (length && !array.length) {
					array.push(undefined);
		}
		return array;
			});
	});
	function wrapperChain() {
			return chain(this);
	}
	function wrapperCommit() {
			return new LodashWrapper(this.value(), this.__chain__);
	}
	function wrapperNext() {
			if (this.__values__ === undefined) {
		this.__values__ = toArray(this.value());
			}
			var done = this.__index__ >= this.__values__.length,
					value = done ? undefined : this.__values__[this.__index__++];

			return { 'done': done, 'value': value };
	}
	function wrapperToIterator() {
			return this;
	}
	function wrapperPlant(value) {
			var result,
					parent = this;

			while (parent instanceof baseLodash) {
		var clone = wrapperClone(parent);
		clone.__index__ = 0;
		clone.__values__ = undefined;
		if (result) {
					previous.__wrapped__ = clone;
		} else {
					result = clone;
		}
		var previous = clone;
		parent = parent.__wrapped__;
			}
			previous.__wrapped__ = value;
			return result;
	}
	function wrapperReverse() {
			var value = this.__wrapped__;
			if (value instanceof LazyWrapper) {
		var wrapped = value;
		if (this.__actions__.length) {
					wrapped = new LazyWrapper(this);
		}
		wrapped = wrapped.reverse();
		wrapped.__actions__.push({
					'func': thru,
					'args': [reverse],
					'thisArg': undefined
		});
		return new LodashWrapper(wrapped, this.__chain__);
			}
			return this.thru(reverse);
	}
	function wrapperValue() {
			return baseWrapperValue(this.__wrapped__, this.__actions__);
	}
	var countBy = createAggregator(function (result, value, key) {
			if (hasOwnProperty.call(result, key)) {
		++result[key];
			} else {
		baseAssignValue(result, key, 1);
			}
	});
	function every(collection, predicate, guard) {
			var func = isArray(collection) ? arrayEvery : baseEvery;
			if (guard && isIterateeCall(collection, predicate, guard)) {
		predicate = undefined;
			}
			return func(collection, getIteratee(predicate, 3));
	}
	function filter(collection, predicate) {
			var func = isArray(collection) ? arrayFilter : baseFilter;
			return func(collection, getIteratee(predicate, 3));
	}
	var find = createFind(findIndex);
	var findLast = createFind(findLastIndex);
	function flatMap(collection, iteratee) {
			return baseFlatten(map(collection, iteratee), 1);
	}
	function flatMapDeep(collection, iteratee) {
			return baseFlatten(map(collection, iteratee), INFINITY);
	}
	function flatMapDepth(collection, iteratee, depth) {
			depth = depth === undefined ? 1 : toInteger(depth);
			return baseFlatten(map(collection, iteratee), depth);
	}
	function forEach(collection, iteratee) {
			var func = isArray(collection) ? arrayEach : baseEach;
			return func(collection, getIteratee(iteratee, 3));
	}
	function forEachRight(collection, iteratee) {
			var func = isArray(collection) ? arrayEachRight : baseEachRight;
			return func(collection, getIteratee(iteratee, 3));
	}
	var groupBy = createAggregator(function (result, value, key) {
			if (hasOwnProperty.call(result, key)) {
		result[key].push(value);
			} else {
		baseAssignValue(result, key, [value]);
			}
	});
	function includes(collection, value, fromIndex, guard) {
			collection = isArrayLike(collection) ? collection : values(collection);
			fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;

			var length = collection.length;
			if (fromIndex < 0) {
		fromIndex = nativeMax(length + fromIndex, 0);
			}
			return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
	}
	var invokeMap = baseRest(function (collection, path, args) {
			var index = -1,
					isFunc = typeof path == 'function',
					result = isArrayLike(collection) ? Array(collection.length) : [];

			baseEach(collection, function (value) {
		result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
			});
			return result;
	});
	var keyBy = createAggregator(function (result, value, key) {
			baseAssignValue(result, key, value);
	});
	function map(collection, iteratee) {
			var func = isArray(collection) ? arrayMap : baseMap;
			return func(collection, getIteratee(iteratee, 3));
	}
	function orderBy(collection, iteratees, orders, guard) {
			if (collection == null) {
		return [];
			}
			if (!isArray(iteratees)) {
		iteratees = iteratees == null ? [] : [iteratees];
			}
			orders = guard ? undefined : orders;
			if (!isArray(orders)) {
		orders = orders == null ? [] : [orders];
			}
			return baseOrderBy(collection, iteratees, orders);
	}
	var partition = createAggregator(function (result, value, key) {
			result[key ? 0 : 1].push(value);
	}, function () {
			return [[], []];
	});
	function reduce(collection, iteratee, accumulator) {
			var func = isArray(collection) ? arrayReduce : baseReduce,
					initAccum = arguments.length < 3;

			return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	}
	function reduceRight(collection, iteratee, accumulator) {
			var func = isArray(collection) ? arrayReduceRight : baseReduce,
					initAccum = arguments.length < 3;

			return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	}
	function reject(collection, predicate) {
			var func = isArray(collection) ? arrayFilter : baseFilter;
			return func(collection, negate(getIteratee(predicate, 3)));
	}
	function sample(collection) {
			var func = isArray(collection) ? arraySample : baseSample;
			return func(collection);
	}
	function sampleSize(collection, n, guard) {
			if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
		n = 1;
			} else {
		n = toInteger(n);
			}
			var func = isArray(collection) ? arraySampleSize : baseSampleSize;
			return func(collection, n);
	}
	function shuffle(collection) {
			var func = isArray(collection) ? arrayShuffle : baseShuffle;
			return func(collection);
	}
	function size(collection) {
			if (collection == null) {
		return 0;
			}
			if (isArrayLike(collection)) {
		return isString(collection) ? stringSize(collection) : collection.length;
			}
			var tag = getTag(collection);
			if (tag == mapTag || tag == setTag) {
		return collection.size;
			}
			return baseKeys(collection).length;
	}
	function some(collection, predicate, guard) {
			var func = isArray(collection) ? arraySome : baseSome;
			if (guard && isIterateeCall(collection, predicate, guard)) {
		predicate = undefined;
			}
			return func(collection, getIteratee(predicate, 3));
	}
	var sortBy = baseRest(function (collection, iteratees) {
			if (collection == null) {
		return [];
			}
			var length = iteratees.length;
			if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
		iteratees = [];
			} else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
		iteratees = [iteratees[0]];
			}
			return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	});
	var now = ctxNow || function () {
			return root.Date.now();
	};
	function after(n, func) {
			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			n = toInteger(n);
			return function () {
		if (--n < 1) {
					return func.apply(this, arguments);
		}
			};
	}
	function ary(func, n, guard) {
			n = guard ? undefined : n;
			n = func && n == null ? func.length : n;
			return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
	}
	function before(n, func) {
			var result;
			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			n = toInteger(n);
			return function () {
		if (--n > 0) {
					result = func.apply(this, arguments);
		}
		if (n <= 1) {
					func = undefined;
		}
		return result;
			};
	}
	var bind = baseRest(function (func, thisArg, partials) {
			var bitmask = WRAP_BIND_FLAG;
			if (partials.length) {
		var holders = replaceHolders(partials, getHolder(bind));
		bitmask |= WRAP_PARTIAL_FLAG;
			}
			return createWrap(func, bitmask, thisArg, partials, holders);
	});
	var bindKey = baseRest(function (object, key, partials) {
			var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
			if (partials.length) {
		var holders = replaceHolders(partials, getHolder(bindKey));
		bitmask |= WRAP_PARTIAL_FLAG;
			}
			return createWrap(key, bitmask, object, partials, holders);
	});
	function curry(func, arity, guard) {
			arity = guard ? undefined : arity;
			var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
			result.placeholder = curry.placeholder;
			return result;
	}
	function curryRight(func, arity, guard) {
			arity = guard ? undefined : arity;
			var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
			result.placeholder = curryRight.placeholder;
			return result;
	}
	function debounce(func, wait, options) {
			var lastArgs,
					lastThis,
					maxWait,
					result,
					timerId,
					lastCallTime,
					lastInvokeTime = 0,
					leading = false,
					maxing = false,
					trailing = true;

			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			wait = toNumber(wait) || 0;
			if (isObject(options)) {
		leading = !!options.leading;
		maxing = 'maxWait' in options;
		maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
		trailing = 'trailing' in options ? !!options.trailing : trailing;
			}

			function invokeFunc(time) {
		var args = lastArgs,
			thisArg = lastThis;

		lastArgs = lastThis = undefined;
		lastInvokeTime = time;
		result = func.apply(thisArg, args);
		return result;
			}

			function leadingEdge(time) {
		lastInvokeTime = time;
		timerId = setTimeout(timerExpired, wait);
		return leading ? invokeFunc(time) : result;
			}

			function remainingWait(time) {
		var timeSinceLastCall = time - lastCallTime,
			timeSinceLastInvoke = time - lastInvokeTime,
			result = wait - timeSinceLastCall;

		return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
			}

			function shouldInvoke(time) {
		var timeSinceLastCall = time - lastCallTime,
			timeSinceLastInvoke = time - lastInvokeTime;
		return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
			}

			function timerExpired() {
		var time = now();
		if (shouldInvoke(time)) {
					return trailingEdge(time);
		}
		timerId = setTimeout(timerExpired, remainingWait(time));
			}

			function trailingEdge(time) {
		timerId = undefined;
		if (trailing && lastArgs) {
					return invokeFunc(time);
		}
		lastArgs = lastThis = undefined;
		return result;
			}

			function cancel() {
		if (timerId !== undefined) {
					clearTimeout(timerId);
		}
		lastInvokeTime = 0;
		lastArgs = lastCallTime = lastThis = timerId = undefined;
			}

			function flush() {
		return timerId === undefined ? result : trailingEdge(now());
			}

			function debounced() {
		var time = now(),
			isInvoking = shouldInvoke(time);

		lastArgs = arguments;
		lastThis = this;
		lastCallTime = time;

		if (isInvoking) {
					if (timerId === undefined) {
			return leadingEdge(lastCallTime);
					}
					if (maxing) {
			timerId = setTimeout(timerExpired, wait);
			return invokeFunc(lastCallTime);
					}
		}
		if (timerId === undefined) {
					timerId = setTimeout(timerExpired, wait);
		}
		return result;
			}
			debounced.cancel = cancel;
			debounced.flush = flush;
			return debounced;
	}
	var defer = baseRest(function (func, args) {
			return baseDelay(func, 1, args);
	});
	var delay = baseRest(function (func, wait, args) {
			return baseDelay(func, toNumber(wait) || 0, args);
	});
	function flip(func) {
			return createWrap(func, WRAP_FLIP_FLAG);
	}
	function memoize(func, resolver) {
			if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			var memoized = function memoized() {
		var args = arguments,
			key = resolver ? resolver.apply(this, args) : args[0],
			cache = memoized.cache;

		if (cache.has(key)) {
					return cache.get(key);
		}
		var result = func.apply(this, args);
		memoized.cache = cache.set(key, result) || cache;
		return result;
			};
			memoized.cache = new (memoize.Cache || MapCache)();
			return memoized;
	}
	memoize.Cache = MapCache;
	function negate(predicate) {
			if (typeof predicate != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			return function () {
		var args = arguments;
		switch (args.length) {
					case 0:
			return !predicate.call(this);
					case 1:
			return !predicate.call(this, args[0]);
					case 2:
			return !predicate.call(this, args[0], args[1]);
					case 3:
			return !predicate.call(this, args[0], args[1], args[2]);
		}
		return !predicate.apply(this, args);
			};
	}
	function once(func) {
			return before(2, func);
	}
	var overArgs = castRest(function (func, transforms) {
			transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

			var funcsLength = transforms.length;
			return baseRest(function (args) {
		var index = -1,
			length = nativeMin(args.length, funcsLength);

		while (++index < length) {
					args[index] = transforms[index].call(this, args[index]);
		}
		return apply(func, this, args);
			});
	});
	var partial = baseRest(function (func, partials) {
			var holders = replaceHolders(partials, getHolder(partial));
			return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
	});
	var partialRight = baseRest(function (func, partials) {
			var holders = replaceHolders(partials, getHolder(partialRight));
			return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
	});
	var rearg = flatRest(function (func, indexes) {
			return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
	});
	function rest(func, start) {
			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			start = start === undefined ? start : toInteger(start);
			return baseRest(func, start);
	}
	function spread(func, start) {
			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			start = start == null ? 0 : nativeMax(toInteger(start), 0);
			return baseRest(function (args) {
		var array = args[start],
			otherArgs = castSlice(args, 0, start);

		if (array) {
					arrayPush(otherArgs, array);
		}
		return apply(func, this, otherArgs);
			});
	}
	function throttle(func, wait, options) {
			var leading = true,
					trailing = true;

			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			if (isObject(options)) {
		leading = 'leading' in options ? !!options.leading : leading;
		trailing = 'trailing' in options ? !!options.trailing : trailing;
			}
			return debounce(func, wait, {
		'leading': leading,
		'maxWait': wait,
		'trailing': trailing
			});
	}
	function unary(func) {
			return ary(func, 1);
	}
	function wrap(value, wrapper) {
			return partial(castFunction(wrapper), value);
	}
	function castArray() {
			if (!arguments.length) {
		return [];
			}
			var value = arguments[0];
			return isArray(value) ? value : [value];
	}
	function clone(value) {
			return baseClone(value, CLONE_SYMBOLS_FLAG);
	}
	function cloneWith(value, customizer) {
			customizer = typeof customizer == 'function' ? customizer : undefined;
			return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
	}
	function cloneDeep(value) {
			return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	}
	function cloneDeepWith(value, customizer) {
			customizer = typeof customizer == 'function' ? customizer : undefined;
			return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	}
	function conformsTo(object, source) {
			return source == null || baseConformsTo(object, source, keys(source));
	}
	function eq(value, other) {
			return value === other || value !== value && other !== other;
	}
	var gt = createRelationalOperation(baseGt);
	var gte = createRelationalOperation(function (value, other) {
			return value >= other;
	});
	var isArguments = baseIsArguments(function () {
			return arguments;
	}()) ? baseIsArguments : function (value) {
			return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	};
	var isArray = Array.isArray;
	var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
	function isArrayLike(value) {
			return value != null && isLength(value.length) && !isFunction(value);
	}
	function isArrayLikeObject(value) {
			return isObjectLike(value) && isArrayLike(value);
	}
	function isBoolean(value) {
			return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
	}
	var isBuffer = nativeIsBuffer || stubFalse;
	var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
	function isElement(value) {
			return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	}
	function isEmpty(value) {
			if (value == null) {
		return true;
			}
			if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
		return !value.length;
			}
			var tag = getTag(value);
			if (tag == mapTag || tag == setTag) {
		return !value.size;
			}
			if (isPrototype(value)) {
		return !baseKeys(value).length;
			}
			for (var key in value) {
		if (hasOwnProperty.call(value, key)) {
					return false;
		}
			}
			return true;
	}
	function isEqual(value, other) {
			return baseIsEqual(value, other);
	}
	function isEqualWith(value, other, customizer) {
			customizer = typeof customizer == 'function' ? customizer : undefined;
			var result = customizer ? customizer(value, other) : undefined;
			return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
	}
	function isError(value) {
			if (!isObjectLike(value)) {
		return false;
			}
			var tag = baseGetTag(value);
			return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
	}
	function isFinite(value) {
			return typeof value == 'number' && nativeIsFinite(value);
	}
	function isFunction(value) {
			if (!isObject(value)) {
		return false;
			}
			var tag = baseGetTag(value);
			return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	function isInteger(value) {
			return typeof value == 'number' && value == toInteger(value);
	}
	function isLength(value) {
			return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	function isObject(value) {
			var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
			return value != null && (type == 'object' || type == 'function');
	}
	function isObjectLike(value) {
			return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
	}
	var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
	function isMatch(object, source) {
			return object === source || baseIsMatch(object, source, getMatchData(source));
	}
	function isMatchWith(object, source, customizer) {
			customizer = typeof customizer == 'function' ? customizer : undefined;
			return baseIsMatch(object, source, getMatchData(source), customizer);
	}
	function isNaN(value) {
			return isNumber(value) && value != +value;
	}
	function isNative(value) {
			if (isMaskable(value)) {
		throw new Error(CORE_ERROR_TEXT);
			}
			return baseIsNative(value);
	}
	function isNull(value) {
			return value === null;
	}
	function isNil(value) {
			return value == null;
	}
	function isNumber(value) {
			return typeof value == 'number' || isObjectLike(value) && baseGetTag(value) == numberTag;
	}
	function isPlainObject(value) {
			if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
		return false;
			}
			var proto = getPrototype(value);
			if (proto === null) {
		return true;
			}
			var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
			return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}
	var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
	function isSafeInteger(value) {
			return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	}
	var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
	function isString(value) {
			return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
	}
	function isSymbol(value) {
			return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
	}
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	function isUndefined(value) {
			return value === undefined;
	}
	function isWeakMap(value) {
			return isObjectLike(value) && getTag(value) == weakMapTag;
	}
	function isWeakSet(value) {
			return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	}
	var lt = createRelationalOperation(baseLt);
	var lte = createRelationalOperation(function (value, other) {
			return value <= other;
	});
	function toArray(value) {
			if (!value) {
		return [];
			}
			if (isArrayLike(value)) {
		return isString(value) ? stringToArray(value) : copyArray(value);
			}
			if (symIterator && value[symIterator]) {
		return iteratorToArray(value[symIterator]());
			}
			var tag = getTag(value),
					func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;

			return func(value);
	}
	function toFinite(value) {
			if (!value) {
		return value === 0 ? value : 0;
			}
			value = toNumber(value);
			if (value === INFINITY || value === -INFINITY) {
		var sign = value < 0 ? -1 : 1;
		return sign * MAX_INTEGER;
			}
			return value === value ? value : 0;
	}
	function toInteger(value) {
			var result = toFinite(value),
					remainder = result % 1;

			return result === result ? remainder ? result - remainder : result : 0;
	}
	function toLength(value) {
			return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	}
	function toNumber(value) {
			if (typeof value == 'number') {
		return value;
			}
			if (isSymbol(value)) {
		return NAN;
			}
			if (isObject(value)) {
		var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
		value = isObject(other) ? other + '' : other;
			}
			if (typeof value != 'string') {
		return value === 0 ? value : +value;
			}
			value = value.replace(reTrim, '');
			var isBinary = reIsBinary.test(value);
			return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
	}
	function toPlainObject(value) {
			return copyObject(value, keysIn(value));
	}
	function toSafeInteger(value) {
			return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
	}
	function toString(value) {
			return value == null ? '' : baseToString(value);
	}
	var assign = createAssigner(function (object, source) {
			if (isPrototype(source) || isArrayLike(source)) {
		copyObject(source, keys(source), object);
		return;
			}
			for (var key in source) {
		if (hasOwnProperty.call(source, key)) {
					assignValue(object, key, source[key]);
		}
			}
	});
	var assignIn = createAssigner(function (object, source) {
			copyObject(source, keysIn(source), object);
	});
	var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
			copyObject(source, keysIn(source), object, customizer);
	});
	var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
			copyObject(source, keys(source), object, customizer);
	});
	var at = flatRest(baseAt);
	function create(prototype, properties) {
			var result = baseCreate(prototype);
			return properties == null ? result : baseAssign(result, properties);
	}
	var defaults = baseRest(function (args) {
			args.push(undefined, customDefaultsAssignIn);
			return apply(assignInWith, undefined, args);
	});
	var defaultsDeep = baseRest(function (args) {
			args.push(undefined, customDefaultsMerge);
			return apply(mergeWith, undefined, args);
	});
	function findKey(object, predicate) {
			return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
	}
	function findLastKey(object, predicate) {
			return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
	}
	function forIn(object, iteratee) {
			return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
	}
	function forInRight(object, iteratee) {
			return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
	}
	function forOwn(object, iteratee) {
			return object && baseForOwn(object, getIteratee(iteratee, 3));
	}
	function forOwnRight(object, iteratee) {
			return object && baseForOwnRight(object, getIteratee(iteratee, 3));
	}
	function functions(object) {
			return object == null ? [] : baseFunctions(object, keys(object));
	}
	function functionsIn(object) {
			return object == null ? [] : baseFunctions(object, keysIn(object));
	}
	function get(object, path, defaultValue) {
			var result = object == null ? undefined : baseGet(object, path);
			return result === undefined ? defaultValue : result;
	}
	function has(object, path) {
			return object != null && hasPath(object, path, baseHas);
	}
	function hasIn(object, path) {
			return object != null && hasPath(object, path, baseHasIn);
	}
	var invert = createInverter(function (result, value, key) {
			result[value] = key;
	}, constant(identity));
	var invertBy = createInverter(function (result, value, key) {
			if (hasOwnProperty.call(result, value)) {
		result[value].push(key);
			} else {
		result[value] = [key];
			}
	}, getIteratee);
	var invoke = baseRest(baseInvoke);
	function keys(object) {
			return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	function keysIn(object) {
			return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}
	function mapKeys(object, iteratee) {
			var result = {};
			iteratee = getIteratee(iteratee, 3);

			baseForOwn(object, function (value, key, object) {
		baseAssignValue(result, iteratee(value, key, object), value);
			});
			return result;
	}
	function mapValues(object, iteratee) {
			var result = {};
			iteratee = getIteratee(iteratee, 3);

			baseForOwn(object, function (value, key, object) {
		baseAssignValue(result, key, iteratee(value, key, object));
			});
			return result;
	}
	var merge = createAssigner(function (object, source, srcIndex) {
			baseMerge(object, source, srcIndex);
	});
	var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
			baseMerge(object, source, srcIndex, customizer);
	});
	var omit = flatRest(function (object, paths) {
			var result = {};
			if (object == null) {
		return result;
			}
			var isDeep = false;
			paths = arrayMap(paths, function (path) {
		path = castPath(path, object);
		isDeep || (isDeep = path.length > 1);
		return path;
			});
			copyObject(object, getAllKeysIn(object), result);
			if (isDeep) {
		result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
			}
			var length = paths.length;
			while (length--) {
		baseUnset(result, paths[length]);
			}
			return result;
	});
	function omitBy(object, predicate) {
			return pickBy(object, negate(getIteratee(predicate)));
	}
	var pick = flatRest(function (object, paths) {
			return object == null ? {} : basePick(object, paths);
	});
	function pickBy(object, predicate) {
			if (object == null) {
		return {};
			}
			var props = arrayMap(getAllKeysIn(object), function (prop) {
		return [prop];
			});
			predicate = getIteratee(predicate);
			return basePickBy(object, props, function (value, path) {
		return predicate(value, path[0]);
			});
	}
	function result(object, path, defaultValue) {
			path = castPath(path, object);

			var index = -1,
					length = path.length;
			if (!length) {
		length = 1;
		object = undefined;
			}
			while (++index < length) {
		var value = object == null ? undefined : object[toKey(path[index])];
		if (value === undefined) {
					index = length;
					value = defaultValue;
		}
		object = isFunction(value) ? value.call(object) : value;
			}
			return object;
	}
	function set(object, path, value) {
			return object == null ? object : baseSet(object, path, value);
	}
	function setWith(object, path, value, customizer) {
			customizer = typeof customizer == 'function' ? customizer : undefined;
			return object == null ? object : baseSet(object, path, value, customizer);
	}
	var toPairs = createToPairs(keys);
	var toPairsIn = createToPairs(keysIn);
	function transform(object, iteratee, accumulator) {
			var isArr = isArray(object),
					isArrLike = isArr || isBuffer(object) || isTypedArray(object);

			iteratee = getIteratee(iteratee, 4);
			if (accumulator == null) {
		var Ctor = object && object.constructor;
		if (isArrLike) {
					accumulator = isArr ? new Ctor() : [];
		} else if (isObject(object)) {
					accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
		} else {
					accumulator = {};
		}
			}
			(isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
		return iteratee(accumulator, value, index, object);
			});
			return accumulator;
	}
	function unset(object, path) {
			return object == null ? true : baseUnset(object, path);
	}
	function update(object, path, updater) {
			return object == null ? object : baseUpdate(object, path, castFunction(updater));
	}
	function updateWith(object, path, updater, customizer) {
			customizer = typeof customizer == 'function' ? customizer : undefined;
			return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	}
	function values(object) {
			return object == null ? [] : baseValues(object, keys(object));
	}
	function valuesIn(object) {
			return object == null ? [] : baseValues(object, keysIn(object));
	}
	function clamp(number, lower, upper) {
			if (upper === undefined) {
		upper = lower;
		lower = undefined;
			}
			if (upper !== undefined) {
		upper = toNumber(upper);
		upper = upper === upper ? upper : 0;
			}
			if (lower !== undefined) {
		lower = toNumber(lower);
		lower = lower === lower ? lower : 0;
			}
			return baseClamp(toNumber(number), lower, upper);
	}
	function inRange(number, start, end) {
			start = toFinite(start);
			if (end === undefined) {
		end = start;
		start = 0;
			} else {
		end = toFinite(end);
			}
			number = toNumber(number);
			return baseInRange(number, start, end);
	}
	function random(lower, upper, floating) {
			if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
		upper = floating = undefined;
			}
			if (floating === undefined) {
		if (typeof upper == 'boolean') {
					floating = upper;
					upper = undefined;
		} else if (typeof lower == 'boolean') {
					floating = lower;
					lower = undefined;
		}
			}
			if (lower === undefined && upper === undefined) {
		lower = 0;
		upper = 1;
			} else {
		lower = toFinite(lower);
		if (upper === undefined) {
					upper = lower;
					lower = 0;
		} else {
					upper = toFinite(upper);
		}
			}
			if (lower > upper) {
		var temp = lower;
		lower = upper;
		upper = temp;
			}
			if (floating || lower % 1 || upper % 1) {
		var rand = nativeRandom();
		return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
			}
			return baseRandom(lower, upper);
	}
	var camelCase = createCompounder(function (result, word, index) {
			word = word.toLowerCase();
			return result + (index ? capitalize(word) : word);
	});
	function capitalize(string) {
			return upperFirst(toString(string).toLowerCase());
	}
	function deburr(string) {
			string = toString(string);
			return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	}
	function endsWith(string, target, position) {
			string = toString(string);
			target = baseToString(target);

			var length = string.length;
			position = position === undefined ? length : baseClamp(toInteger(position), 0, length);

			var end = position;
			position -= target.length;
			return position >= 0 && string.slice(position, end) == target;
	}
	function escape(string) {
			string = toString(string);
			return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
	}
	function escapeRegExp(string) {
			string = toString(string);
			return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
	}
	var kebabCase = createCompounder(function (result, word, index) {
			return result + (index ? '-' : '') + word.toLowerCase();
	});
	var lowerCase = createCompounder(function (result, word, index) {
			return result + (index ? ' ' : '') + word.toLowerCase();
	});
	var lowerFirst = createCaseFirst('toLowerCase');
	function pad(string, length, chars) {
			string = toString(string);
			length = toInteger(length);

			var strLength = length ? stringSize(string) : 0;
			if (!length || strLength >= length) {
		return string;
			}
			var mid = (length - strLength) / 2;
			return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
	}
	function padEnd(string, length, chars) {
			string = toString(string);
			length = toInteger(length);

			var strLength = length ? stringSize(string) : 0;
			return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
	}
	function padStart(string, length, chars) {
			string = toString(string);
			length = toInteger(length);

			var strLength = length ? stringSize(string) : 0;
			return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
	}
	function parseInt(string, radix, guard) {
			if (guard || radix == null) {
		radix = 0;
			} else if (radix) {
		radix = +radix;
			}
			return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	}
	function repeat(string, n, guard) {
			if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
		n = 1;
			} else {
		n = toInteger(n);
			}
			return baseRepeat(toString(string), n);
	}
	function replace() {
			var args = arguments,
					string = toString(args[0]);

			return args.length < 3 ? string : string.replace(args[1], args[2]);
	}
	var snakeCase = createCompounder(function (result, word, index) {
			return result + (index ? '_' : '') + word.toLowerCase();
	});
	function split(string, separator, limit) {
			if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
		separator = limit = undefined;
			}
			limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
			if (!limit) {
		return [];
			}
			string = toString(string);
			if (string && (typeof separator == 'string' || separator != null && !isRegExp(separator))) {
		separator = baseToString(separator);
		if (!separator && hasUnicode(string)) {
					return castSlice(stringToArray(string), 0, limit);
		}
			}
			return string.split(separator, limit);
	}
	var startCase = createCompounder(function (result, word, index) {
			return result + (index ? ' ' : '') + upperFirst(word);
	});
	function startsWith(string, target, position) {
			string = toString(string);
			position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);

			target = baseToString(target);
			return string.slice(position, position + target.length) == target;
	}
	function template(string, options, guard) {
			var settings = lodash.templateSettings;

			if (guard && isIterateeCall(string, options, guard)) {
		options = undefined;
			}
			string = toString(string);
			options = assignInWith({}, options, settings, customDefaultsAssignIn);

			var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
					importsKeys = keys(imports),
					importsValues = baseValues(imports, importsKeys);

			var isEscaping,
					isEvaluating,
					index = 0,
					interpolate = options.interpolate || reNoMatch,
					source = "__p += '";
			var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
			var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';

			string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
		interpolateValue || (interpolateValue = esTemplateValue);
		source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
		if (escapeValue) {
					isEscaping = true;
					source += "' +\n__e(" + escapeValue + ") +\n'";
		}
		if (evaluateValue) {
					isEvaluating = true;
					source += "';\n" + evaluateValue + ";\n__p += '";
		}
		if (interpolateValue) {
					source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
		}
		index = offset + match.length;
		return match;
			});

			source += "';\n";
			var variable = options.variable;
			if (!variable) {
		source = 'with (obj) {\n' + source + '\n}\n';
			}
			source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
			source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';

			var result = attempt(function () {
		return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
			});
			result.source = source;
			if (isError(result)) {
		throw result;
			}
			return result;
	}
	function toLower(value) {
			return toString(value).toLowerCase();
	}
	function toUpper(value) {
			return toString(value).toUpperCase();
	}
	function trim(string, chars, guard) {
			string = toString(string);
			if (string && (guard || chars === undefined)) {
		return string.replace(reTrim, '');
			}
			if (!string || !(chars = baseToString(chars))) {
		return string;
			}
			var strSymbols = stringToArray(string),
					chrSymbols = stringToArray(chars),
					start = charsStartIndex(strSymbols, chrSymbols),
					end = charsEndIndex(strSymbols, chrSymbols) + 1;

			return castSlice(strSymbols, start, end).join('');
	}
	function trimEnd(string, chars, guard) {
			string = toString(string);
			if (string && (guard || chars === undefined)) {
		return string.replace(reTrimEnd, '');
			}
			if (!string || !(chars = baseToString(chars))) {
		return string;
			}
			var strSymbols = stringToArray(string),
					end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

			return castSlice(strSymbols, 0, end).join('');
	}
	function trimStart(string, chars, guard) {
			string = toString(string);
			if (string && (guard || chars === undefined)) {
		return string.replace(reTrimStart, '');
			}
			if (!string || !(chars = baseToString(chars))) {
		return string;
			}
			var strSymbols = stringToArray(string),
					start = charsStartIndex(strSymbols, stringToArray(chars));

			return castSlice(strSymbols, start).join('');
	}
	function truncate(string, options) {
			var length = DEFAULT_TRUNC_LENGTH,
					omission = DEFAULT_TRUNC_OMISSION;

			if (isObject(options)) {
		var separator = 'separator' in options ? options.separator : separator;
		length = 'length' in options ? toInteger(options.length) : length;
		omission = 'omission' in options ? baseToString(options.omission) : omission;
			}
			string = toString(string);

			var strLength = string.length;
			if (hasUnicode(string)) {
		var strSymbols = stringToArray(string);
		strLength = strSymbols.length;
			}
			if (length >= strLength) {
		return string;
			}
			var end = length - stringSize(omission);
			if (end < 1) {
		return omission;
			}
			var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);

			if (separator === undefined) {
		return result + omission;
			}
			if (strSymbols) {
		end += result.length - end;
			}
			if (isRegExp(separator)) {
		if (string.slice(end).search(separator)) {
					var match,
							substring = result;

					if (!separator.global) {
			separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
					}
					separator.lastIndex = 0;
					while (match = separator.exec(substring)) {
			var newEnd = match.index;
					}
					result = result.slice(0, newEnd === undefined ? end : newEnd);
		}
			} else if (string.indexOf(baseToString(separator), end) != end) {
		var index = result.lastIndexOf(separator);
		if (index > -1) {
					result = result.slice(0, index);
		}
			}
			return result + omission;
	}
	function unescape(string) {
			string = toString(string);
			return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
	}
	var upperCase = createCompounder(function (result, word, index) {
			return result + (index ? ' ' : '') + word.toUpperCase();
	});
	var upperFirst = createCaseFirst('toUpperCase');
	function words(string, pattern, guard) {
			string = toString(string);
			pattern = guard ? undefined : pattern;

			if (pattern === undefined) {
		return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
			}
			return string.match(pattern) || [];
	}
	var attempt = baseRest(function (func, args) {
			try {
		return apply(func, undefined, args);
			} catch (e) {
		return isError(e) ? e : new Error(e);
			}
	});
	var bindAll = flatRest(function (object, methodNames) {
			arrayEach(methodNames, function (key) {
		key = toKey(key);
		baseAssignValue(object, key, bind(object[key], object));
			});
			return object;
	});
	function cond(pairs) {
			var length = pairs == null ? 0 : pairs.length,
					toIteratee = getIteratee();

			pairs = !length ? [] : arrayMap(pairs, function (pair) {
		if (typeof pair[1] != 'function') {
					throw new TypeError(FUNC_ERROR_TEXT);
		}
		return [toIteratee(pair[0]), pair[1]];
			});

			return baseRest(function (args) {
		var index = -1;
		while (++index < length) {
					var pair = pairs[index];
					if (apply(pair[0], this, args)) {
			return apply(pair[1], this, args);
					}
		}
			});
	}
	function conforms(source) {
			return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
	}
	function constant(value) {
			return function () {
		return value;
			};
	}
	function defaultTo(value, defaultValue) {
			return value == null || value !== value ? defaultValue : value;
	}
	var flow = createFlow();
	var flowRight = createFlow(true);
	function identity(value) {
			return value;
	}
	function iteratee(func) {
			return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
	}
	function matches(source) {
			return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
	}
	function matchesProperty(path, srcValue) {
			return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
	}
	var method = baseRest(function (path, args) {
			return function (object) {
		return baseInvoke(object, path, args);
			};
	});
	var methodOf = baseRest(function (object, args) {
			return function (path) {
		return baseInvoke(object, path, args);
			};
	});
	function mixin(object, source, options) {
			var props = keys(source),
					methodNames = baseFunctions(source, props);

			if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
		options = source;
		source = object;
		object = this;
		methodNames = baseFunctions(source, keys(source));
			}
			var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
					isFunc = isFunction(object);

			arrayEach(methodNames, function (methodName) {
		var func = source[methodName];
		object[methodName] = func;
		if (isFunc) {
					object.prototype[methodName] = function () {
			var chainAll = this.__chain__;
			if (chain || chainAll) {
							var result = object(this.__wrapped__),
									actions = result.__actions__ = copyArray(this.__actions__);

							actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
							result.__chain__ = chainAll;
							return result;
			}
			return func.apply(object, arrayPush([this.value()], arguments));
					};
		}
			});

			return object;
	}
	function noConflict() {
			if (root._ === this) {
		root._ = oldDash;
			}
			return this;
	}
	function noop() {}
	function nthArg(n) {
			n = toInteger(n);
			return baseRest(function (args) {
		return baseNth(args, n);
			});
	}
	var over = createOver(arrayMap);
	var overEvery = createOver(arrayEvery);
	var overSome = createOver(arraySome);
	function property(path) {
			return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}
	function propertyOf(object) {
			return function (path) {
		return object == null ? undefined : baseGet(object, path);
			};
	}
	var range = createRange();
	var rangeRight = createRange(true);
	function stubArray() {
			return [];
	}
	function stubFalse() {
			return false;
	}
	function stubObject() {
			return {};
	}
	function stubString() {
			return '';
	}
	function stubTrue() {
			return true;
	}
	function times(n, iteratee) {
			n = toInteger(n);
			if (n < 1 || n > MAX_SAFE_INTEGER) {
		return [];
			}
			var index = MAX_ARRAY_LENGTH,
					length = nativeMin(n, MAX_ARRAY_LENGTH);

			iteratee = getIteratee(iteratee);
			n -= MAX_ARRAY_LENGTH;

			var result = baseTimes(length, iteratee);
			while (++index < n) {
		iteratee(index);
			}
			return result;
	}
	function toPath(value) {
			if (isArray(value)) {
		return arrayMap(value, toKey);
			}
			return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	}
	function uniqueId(prefix) {
			var id = ++idCounter;
			return toString(prefix) + id;
	}
	var add = createMathOperation(function (augend, addend) {
			return augend + addend;
	}, 0);
	var ceil = createRound('ceil');
	var divide = createMathOperation(function (dividend, divisor) {
			return dividend / divisor;
	}, 1);
	var floor = createRound('floor');
	function max(array) {
			return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
	}
	function maxBy(array, iteratee) {
			return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
	}
	function mean(array) {
			return baseMean(array, identity);
	}
	function meanBy(array, iteratee) {
			return baseMean(array, getIteratee(iteratee, 2));
	}
	function min(array) {
			return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
	}
	function minBy(array, iteratee) {
			return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
	}
	var multiply = createMathOperation(function (multiplier, multiplicand) {
			return multiplier * multiplicand;
	}, 1);
	var round = createRound('round');
	var subtract = createMathOperation(function (minuend, subtrahend) {
			return minuend - subtrahend;
	}, 0);
	function sum(array) {
			return array && array.length ? baseSum(array, identity) : 0;
	}
	function sumBy(array, iteratee) {
			return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
	}
	lodash.after = after;
	lodash.ary = ary;
	lodash.assign = assign;
	lodash.assignIn = assignIn;
	lodash.assignInWith = assignInWith;
	lodash.assignWith = assignWith;
	lodash.at = at;
	lodash.before = before;
	lodash.bind = bind;
	lodash.bindAll = bindAll;
	lodash.bindKey = bindKey;
	lodash.castArray = castArray;
	lodash.chain = chain;
	lodash.chunk = chunk;
	lodash.compact = compact;
	lodash.concat = concat;
	lodash.cond = cond;
	lodash.conforms = conforms;
	lodash.constant = constant;
	lodash.countBy = countBy;
	lodash.create = create;
	lodash.curry = curry;
	lodash.curryRight = curryRight;
	lodash.debounce = debounce;
	lodash.defaults = defaults;
	lodash.defaultsDeep = defaultsDeep;
	lodash.defer = defer;
	lodash.delay = delay;
	lodash.difference = difference;
	lodash.differenceBy = differenceBy;
	lodash.differenceWith = differenceWith;
	lodash.drop = drop;
	lodash.dropRight = dropRight;
	lodash.dropRightWhile = dropRightWhile;
	lodash.dropWhile = dropWhile;
	lodash.fill = fill;
	lodash.filter = filter;
	lodash.flatMap = flatMap;
	lodash.flatMapDeep = flatMapDeep;
	lodash.flatMapDepth = flatMapDepth;
	lodash.flatten = flatten;
	lodash.flattenDeep = flattenDeep;
	lodash.flattenDepth = flattenDepth;
	lodash.flip = flip;
	lodash.flow = flow;
	lodash.flowRight = flowRight;
	lodash.fromPairs = fromPairs;
	lodash.functions = functions;
	lodash.functionsIn = functionsIn;
	lodash.groupBy = groupBy;
	lodash.initial = initial;
	lodash.intersection = intersection;
	lodash.intersectionBy = intersectionBy;
	lodash.intersectionWith = intersectionWith;
	lodash.invert = invert;
	lodash.invertBy = invertBy;
	lodash.invokeMap = invokeMap;
	lodash.iteratee = iteratee;
	lodash.keyBy = keyBy;
	lodash.keys = keys;
	lodash.keysIn = keysIn;
	lodash.map = map;
	lodash.mapKeys = mapKeys;
	lodash.mapValues = mapValues;
	lodash.matches = matches;
	lodash.matchesProperty = matchesProperty;
	lodash.memoize = memoize;
	lodash.merge = merge;
	lodash.mergeWith = mergeWith;
	lodash.method = method;
	lodash.methodOf = methodOf;
	lodash.mixin = mixin;
	lodash.negate = negate;
	lodash.nthArg = nthArg;
	lodash.omit = omit;
	lodash.omitBy = omitBy;
	lodash.once = once;
	lodash.orderBy = orderBy;
	lodash.over = over;
	lodash.overArgs = overArgs;
	lodash.overEvery = overEvery;
	lodash.overSome = overSome;
	lodash.partial = partial;
	lodash.partialRight = partialRight;
	lodash.partition = partition;
	lodash.pick = pick;
	lodash.pickBy = pickBy;
	lodash.property = property;
	lodash.propertyOf = propertyOf;
	lodash.pull = pull;
	lodash.pullAll = pullAll;
	lodash.pullAllBy = pullAllBy;
	lodash.pullAllWith = pullAllWith;
	lodash.pullAt = pullAt;
	lodash.range = range;
	lodash.rangeRight = rangeRight;
	lodash.rearg = rearg;
	lodash.reject = reject;
	lodash.remove = remove;
	lodash.rest = rest;
	lodash.reverse = reverse;
	lodash.sampleSize = sampleSize;
	lodash.set = set;
	lodash.setWith = setWith;
	lodash.shuffle = shuffle;
	lodash.slice = slice;
	lodash.sortBy = sortBy;
	lodash.sortedUniq = sortedUniq;
	lodash.sortedUniqBy = sortedUniqBy;
	lodash.split = split;
	lodash.spread = spread;
	lodash.tail = tail;
	lodash.take = take;
	lodash.takeRight = takeRight;
	lodash.takeRightWhile = takeRightWhile;
	lodash.takeWhile = takeWhile;
	lodash.tap = tap;
	lodash.throttle = throttle;
	lodash.thru = thru;
	lodash.toArray = toArray;
	lodash.toPairs = toPairs;
	lodash.toPairsIn = toPairsIn;
	lodash.toPath = toPath;
	lodash.toPlainObject = toPlainObject;
	lodash.transform = transform;
	lodash.unary = unary;
	lodash.union = union;
	lodash.unionBy = unionBy;
	lodash.unionWith = unionWith;
	lodash.uniq = uniq;
	lodash.uniqBy = uniqBy;
	lodash.uniqWith = uniqWith;
	lodash.unset = unset;
	lodash.unzip = unzip;
	lodash.unzipWith = unzipWith;
	lodash.update = update;
	lodash.updateWith = updateWith;
	lodash.values = values;
	lodash.valuesIn = valuesIn;
	lodash.without = without;
	lodash.words = words;
	lodash.wrap = wrap;
	lodash.xor = xor;
	lodash.xorBy = xorBy;
	lodash.xorWith = xorWith;
	lodash.zip = zip;
	lodash.zipObject = zipObject;
	lodash.zipObjectDeep = zipObjectDeep;
	lodash.zipWith = zipWith;
	lodash.entries = toPairs;
	lodash.entriesIn = toPairsIn;
	lodash.extend = assignIn;
	lodash.extendWith = assignInWith;
	mixin(lodash, lodash);
	lodash.add = add;
	lodash.attempt = attempt;
	lodash.camelCase = camelCase;
	lodash.capitalize = capitalize;
	lodash.ceil = ceil;
	lodash.clamp = clamp;
	lodash.clone = clone;
	lodash.cloneDeep = cloneDeep;
	lodash.cloneDeepWith = cloneDeepWith;
	lodash.cloneWith = cloneWith;
	lodash.conformsTo = conformsTo;
	lodash.deburr = deburr;
	lodash.defaultTo = defaultTo;
	lodash.divide = divide;
	lodash.endsWith = endsWith;
	lodash.eq = eq;
	lodash.escape = escape;
	lodash.escapeRegExp = escapeRegExp;
	lodash.every = every;
	lodash.find = find;
	lodash.findIndex = findIndex;
	lodash.findKey = findKey;
	lodash.findLast = findLast;
	lodash.findLastIndex = findLastIndex;
	lodash.findLastKey = findLastKey;
	lodash.floor = floor;
	lodash.forEach = forEach;
	lodash.forEachRight = forEachRight;
	lodash.forIn = forIn;
	lodash.forInRight = forInRight;
	lodash.forOwn = forOwn;
	lodash.forOwnRight = forOwnRight;
	lodash.get = get;
	lodash.gt = gt;
	lodash.gte = gte;
	lodash.has = has;
	lodash.hasIn = hasIn;
	lodash.head = head;
	lodash.identity = identity;
	lodash.includes = includes;
	lodash.indexOf = indexOf;
	lodash.inRange = inRange;
	lodash.invoke = invoke;
	lodash.isArguments = isArguments;
	lodash.isArray = isArray;
	lodash.isArrayBuffer = isArrayBuffer;
	lodash.isArrayLike = isArrayLike;
	lodash.isArrayLikeObject = isArrayLikeObject;
	lodash.isBoolean = isBoolean;
	lodash.isBuffer = isBuffer;
	lodash.isDate = isDate;
	lodash.isElement = isElement;
	lodash.isEmpty = isEmpty;
	lodash.isEqual = isEqual;
	lodash.isEqualWith = isEqualWith;
	lodash.isError = isError;
	lodash.isFinite = isFinite;
	lodash.isFunction = isFunction;
	lodash.isInteger = isInteger;
	lodash.isLength = isLength;
	lodash.isMap = isMap;
	lodash.isMatch = isMatch;
	lodash.isMatchWith = isMatchWith;
	lodash.isNaN = isNaN;
	lodash.isNative = isNative;
	lodash.isNil = isNil;
	lodash.isNull = isNull;
	lodash.isNumber = isNumber;
	lodash.isObject = isObject;
	lodash.isObjectLike = isObjectLike;
	lodash.isPlainObject = isPlainObject;
	lodash.isRegExp = isRegExp;
	lodash.isSafeInteger = isSafeInteger;
	lodash.isSet = isSet;
	lodash.isString = isString;
	lodash.isSymbol = isSymbol;
	lodash.isTypedArray = isTypedArray;
	lodash.isUndefined = isUndefined;
	lodash.isWeakMap = isWeakMap;
	lodash.isWeakSet = isWeakSet;
	lodash.join = join;
	lodash.kebabCase = kebabCase;
	lodash.last = last;
	lodash.lastIndexOf = lastIndexOf;
	lodash.lowerCase = lowerCase;
	lodash.lowerFirst = lowerFirst;
	lodash.lt = lt;
	lodash.lte = lte;
	lodash.max = max;
	lodash.maxBy = maxBy;
	lodash.mean = mean;
	lodash.meanBy = meanBy;
	lodash.min = min;
	lodash.minBy = minBy;
	lodash.stubArray = stubArray;
	lodash.stubFalse = stubFalse;
	lodash.stubObject = stubObject;
	lodash.stubString = stubString;
	lodash.stubTrue = stubTrue;
	lodash.multiply = multiply;
	lodash.nth = nth;
	lodash.noConflict = noConflict;
	lodash.noop = noop;
	lodash.now = now;
	lodash.pad = pad;
	lodash.padEnd = padEnd;
	lodash.padStart = padStart;
	lodash.parseInt = parseInt;
	lodash.random = random;
	lodash.reduce = reduce;
	lodash.reduceRight = reduceRight;
	lodash.repeat = repeat;
	lodash.replace = replace;
	lodash.result = result;
	lodash.round = round;
	lodash.runInContext = runInContext;
	lodash.sample = sample;
	lodash.size = size;
	lodash.snakeCase = snakeCase;
	lodash.some = some;
	lodash.sortedIndex = sortedIndex;
	lodash.sortedIndexBy = sortedIndexBy;
	lodash.sortedIndexOf = sortedIndexOf;
	lodash.sortedLastIndex = sortedLastIndex;
	lodash.sortedLastIndexBy = sortedLastIndexBy;
	lodash.sortedLastIndexOf = sortedLastIndexOf;
	lodash.startCase = startCase;
	lodash.startsWith = startsWith;
	lodash.subtract = subtract;
	lodash.sum = sum;
	lodash.sumBy = sumBy;
	lodash.template = template;
	lodash.times = times;
	lodash.toFinite = toFinite;
	lodash.toInteger = toInteger;
	lodash.toLength = toLength;
	lodash.toLower = toLower;
	lodash.toNumber = toNumber;
	lodash.toSafeInteger = toSafeInteger;
	lodash.toString = toString;
	lodash.toUpper = toUpper;
	lodash.trim = trim;
	lodash.trimEnd = trimEnd;
	lodash.trimStart = trimStart;
	lodash.truncate = truncate;
	lodash.unescape = unescape;
	lodash.uniqueId = uniqueId;
	lodash.upperCase = upperCase;
	lodash.upperFirst = upperFirst;
	lodash.each = forEach;
	lodash.eachRight = forEachRight;
	lodash.first = head;

	mixin(lodash, function () {
			var source = {};
			baseForOwn(lodash, function (func, methodName) {
		if (!hasOwnProperty.call(lodash.prototype, methodName)) {
					source[methodName] = func;
		}
			});
			return source;
	}(), { 'chain': false });
	lodash.VERSION = VERSION;
	arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
			lodash[methodName].placeholder = lodash;
	});
	arrayEach(['drop', 'take'], function (methodName, index) {
			LazyWrapper.prototype[methodName] = function (n) {
		n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

		var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();

		if (result.__filtered__) {
					result.__takeCount__ = nativeMin(n, result.__takeCount__);
		} else {
					result.__views__.push({
			'size': nativeMin(n, MAX_ARRAY_LENGTH),
			'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
					});
		}
		return result;
			};

			LazyWrapper.prototype[methodName + 'Right'] = function (n) {
		return this.reverse()[methodName](n).reverse();
			};
	});
	arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
			var type = index + 1,
					isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

			LazyWrapper.prototype[methodName] = function (iteratee) {
		var result = this.clone();
		result.__iteratees__.push({
					'iteratee': getIteratee(iteratee, 3),
					'type': type
		});
		result.__filtered__ = result.__filtered__ || isFilter;
		return result;
			};
	});
	arrayEach(['head', 'last'], function (methodName, index) {
			var takeName = 'take' + (index ? 'Right' : '');

			LazyWrapper.prototype[methodName] = function () {
		return this[takeName](1).value()[0];
			};
	});
	arrayEach(['initial', 'tail'], function (methodName, index) {
			var dropName = 'drop' + (index ? '' : 'Right');

			LazyWrapper.prototype[methodName] = function () {
		return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
			};
	});

	LazyWrapper.prototype.compact = function () {
			return this.filter(identity);
	};

	LazyWrapper.prototype.find = function (predicate) {
			return this.filter(predicate).head();
	};

	LazyWrapper.prototype.findLast = function (predicate) {
			return this.reverse().find(predicate);
	};

	LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
			if (typeof path == 'function') {
		return new LazyWrapper(this);
			}
			return this.map(function (value) {
		return baseInvoke(value, path, args);
			});
	});

	LazyWrapper.prototype.reject = function (predicate) {
			return this.filter(negate(getIteratee(predicate)));
	};

	LazyWrapper.prototype.slice = function (start, end) {
			start = toInteger(start);

			var result = this;
			if (result.__filtered__ && (start > 0 || end < 0)) {
		return new LazyWrapper(result);
			}
			if (start < 0) {
		result = result.takeRight(-start);
			} else if (start) {
		result = result.drop(start);
			}
			if (end !== undefined) {
		end = toInteger(end);
		result = end < 0 ? result.dropRight(-end) : result.take(end - start);
			}
			return result;
	};

	LazyWrapper.prototype.takeRightWhile = function (predicate) {
			return this.reverse().takeWhile(predicate).reverse();
	};

	LazyWrapper.prototype.toArray = function () {
			return this.take(MAX_ARRAY_LENGTH);
	};
	baseForOwn(LazyWrapper.prototype, function (func, methodName) {
			var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
					isTaker = /^(?:head|last)$/.test(methodName),
					lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName],
					retUnwrapped = isTaker || /^find/.test(methodName);

			if (!lodashFunc) {
		return;
			}
			lodash.prototype[methodName] = function () {
		var value = this.__wrapped__,
			args = isTaker ? [1] : arguments,
			isLazy = value instanceof LazyWrapper,
			iteratee = args[0],
			useLazy = isLazy || isArray(value);

		var interceptor = function interceptor(value) {
					var result = lodashFunc.apply(lodash, arrayPush([value], args));
					return isTaker && chainAll ? result[0] : result;
		};

		if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
					isLazy = useLazy = false;
		}
		var chainAll = this.__chain__,
			isHybrid = !!this.__actions__.length,
			isUnwrapped = retUnwrapped && !chainAll,
			onlyLazy = isLazy && !isHybrid;

		if (!retUnwrapped && useLazy) {
					value = onlyLazy ? value : new LazyWrapper(this);
					var result = func.apply(value, args);
					result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
					return new LodashWrapper(result, chainAll);
		}
		if (isUnwrapped && onlyLazy) {
					return func.apply(this, args);
		}
		result = this.thru(interceptor);
		return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
			};
	});
	arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
			var func = arrayProto[methodName],
					chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
					retUnwrapped = /^(?:pop|shift)$/.test(methodName);

			lodash.prototype[methodName] = function () {
		var args = arguments;
		if (retUnwrapped && !this.__chain__) {
					var value = this.value();
					return func.apply(isArray(value) ? value : [], args);
		}
		return this[chainName](function (value) {
					return func.apply(isArray(value) ? value : [], args);
		});
			};
	});
	baseForOwn(LazyWrapper.prototype, function (func, methodName) {
			var lodashFunc = lodash[methodName];
			if (lodashFunc) {
		var key = lodashFunc.name + '',
			names = realNames[key] || (realNames[key] = []);

		names.push({ 'name': methodName, 'func': lodashFunc });
			}
	});

	realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
			'name': 'wrapper',
			'func': undefined
	}];
	LazyWrapper.prototype.clone = lazyClone;
	LazyWrapper.prototype.reverse = lazyReverse;
	LazyWrapper.prototype.value = lazyValue;
	lodash.prototype.at = wrapperAt;
	lodash.prototype.chain = wrapperChain;
	lodash.prototype.commit = wrapperCommit;
	lodash.prototype.next = wrapperNext;
	lodash.prototype.plant = wrapperPlant;
	lodash.prototype.reverse = wrapperReverse;
	lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
	lodash.prototype.first = lodash.prototype.head;

	if (symIterator) {
			lodash.prototype[symIterator] = wrapperToIterator;
	}
	return lodash;
  };
  var _ = runInContext();
  if ("function" == 'function' && _typeof(__webpack_require__(157)) == 'object' && __webpack_require__(157)) {
	root._ = _;
	!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return _;
	}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  else if (freeModule) {
			(freeModule.exports = _)._ = _;
			freeExports._ = _;
	} else {
			root._ = _;
	}
}).call(undefined);
}.call(exports, __webpack_require__(101), __webpack_require__(150)(module)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = !__webpack_require__(2)(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
			return 7;
	} }).a != 7;
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var toInteger = __webpack_require__(29);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var core = module.exports = { version: '2.5.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var hide = __webpack_require__(17);
var has = __webpack_require__(14);
var SRC = __webpack_require__(36)('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(13).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
	O[key] = val;
  } else if (!safe) {
	delete O[key];
	hide(O, key, val);
  } else if (O[key]) {
	O[key] = val;
  } else {
	hide(O, key, val);
  }
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var fails = __webpack_require__(2);
var defined = __webpack_require__(34);
var quot = /"/g;
var createHTML = function createHTML(string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
	var test = ''[NAME]('"');
	return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(9);
var createDesc = __webpack_require__(35);
module.exports = __webpack_require__(11) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var defined = __webpack_require__(34);
module.exports = function (it) {
  return Object(defined(it));
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(2);

module.exports = function (method, arg) {
  return !!method && fails(function () {
	arg ? method.call(null, function () {/* empty */}, 1) : method.call(null);
  });
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var process = module.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
	throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
	throw new Error('clearTimeout has not been defined');
}
(function () {
	try {
		if (typeof setTimeout === 'function') {
			cachedSetTimeout = setTimeout;
		} else {
			cachedSetTimeout = defaultSetTimout;
		}
	} catch (e) {
		cachedSetTimeout = defaultSetTimout;
	}
	try {
		if (typeof clearTimeout === 'function') {
			cachedClearTimeout = clearTimeout;
		} else {
			cachedClearTimeout = defaultClearTimeout;
		}
	} catch (e) {
		cachedClearTimeout = defaultClearTimeout;
	}
})();
function runTimeout(fun) {
	if (cachedSetTimeout === setTimeout) {
		return setTimeout(fun, 0);
	}
	if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
		cachedSetTimeout = setTimeout;
		return setTimeout(fun, 0);
	}
	try {
		return cachedSetTimeout(fun, 0);
	} catch (e) {
		try {
			return cachedSetTimeout.call(null, fun, 0);
		} catch (e) {
			return cachedSetTimeout.call(this, fun, 0);
		}
	}
}
function runClearTimeout(marker) {
	if (cachedClearTimeout === clearTimeout) {
		return clearTimeout(marker);
	}
	if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
		cachedClearTimeout = clearTimeout;
		return clearTimeout(marker);
	}
	try {
		return cachedClearTimeout(marker);
	} catch (e) {
		try {
			return cachedClearTimeout.call(null, marker);
		} catch (e) {
			return cachedClearTimeout.call(this, marker);
		}
	}
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
	if (!draining || !currentQueue) {
		return;
	}
	draining = false;
	if (currentQueue.length) {
		queue = currentQueue.concat(queue);
	} else {
		queueIndex = -1;
	}
	if (queue.length) {
		drainQueue();
	}
}

function drainQueue() {
	if (draining) {
		return;
	}
	var timeout = runTimeout(cleanUpNextTick);
	draining = true;

	var len = queue.length;
	while (len) {
		currentQueue = queue;
		queue = [];
		while (++queueIndex < len) {
			if (currentQueue) {
				currentQueue[queueIndex].run();
			}
		}
		queueIndex = -1;
		len = queue.length;
	}
	currentQueue = null;
	draining = false;
	runClearTimeout(timeout);
}

process.nextTick = function (fun) {
	var args = new Array(arguments.length - 1);
	if (arguments.length > 1) {
		for (var i = 1; i < arguments.length; i++) {
			args[i - 1] = arguments[i];
		}
	}
	queue.push(new Item(fun, args));
	if (queue.length === 1 && !draining) {
		runTimeout(drainQueue);
	}
};
function Item(fun, array) {
	this.fun = fun;
	this.array = array;
}
Item.prototype.run = function () {
	this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
	return [];
};

process.binding = function (name) {
	throw new Error('process.binding is not supported');
};

process.cwd = function () {
	return '/';
};
process.chdir = function (dir) {
	throw new Error('process.chdir is not supported');
};
process.umask = function () {
	return 0;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extract;
exports.extractLiteral = extractLiteral;

var _Literal = __webpack_require__(166);

var _Literal2 = _interopRequireDefault(_Literal);

var _JSXElement = __webpack_require__(167);

var _JSXElement2 = _interopRequireDefault(_JSXElement);

var _Identifier = __webpack_require__(685);

var _Identifier2 = _interopRequireDefault(_Identifier);

var _TaggedTemplateExpression = __webpack_require__(686);

var _TaggedTemplateExpression2 = _interopRequireDefault(_TaggedTemplateExpression);

var _TemplateLiteral = __webpack_require__(168);

var _TemplateLiteral2 = _interopRequireDefault(_TemplateLiteral);

var _FunctionExpression = __webpack_require__(687);

var _FunctionExpression2 = _interopRequireDefault(_FunctionExpression);

var _LogicalExpression = __webpack_require__(688);

var _LogicalExpression2 = _interopRequireDefault(_LogicalExpression);

var _MemberExpression = __webpack_require__(689);

var _MemberExpression2 = _interopRequireDefault(_MemberExpression);

var _CallExpression = __webpack_require__(690);

var _CallExpression2 = _interopRequireDefault(_CallExpression);

var _UnaryExpression = __webpack_require__(691);

var _UnaryExpression2 = _interopRequireDefault(_UnaryExpression);

var _ThisExpression = __webpack_require__(692);

var _ThisExpression2 = _interopRequireDefault(_ThisExpression);

var _ConditionalExpression = __webpack_require__(693);

var _ConditionalExpression2 = _interopRequireDefault(_ConditionalExpression);

var _BinaryExpression = __webpack_require__(694);

var _BinaryExpression2 = _interopRequireDefault(_BinaryExpression);

var _ObjectExpression = __webpack_require__(695);

var _ObjectExpression2 = _interopRequireDefault(_ObjectExpression);

var _NewExpression = __webpack_require__(696);

var _NewExpression2 = _interopRequireDefault(_NewExpression);

var _UpdateExpression = __webpack_require__(697);

var _UpdateExpression2 = _interopRequireDefault(_UpdateExpression);

var _ArrayExpression = __webpack_require__(698);

var _ArrayExpression2 = _interopRequireDefault(_ArrayExpression);

var _BindExpression = __webpack_require__(699);

var _BindExpression2 = _interopRequireDefault(_BindExpression);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var TYPES = {
  Identifier: _Identifier2.default,
  Literal: _Literal2.default,
  JSXElement: _JSXElement2.default,
  TaggedTemplateExpression: _TaggedTemplateExpression2.default,
  TemplateLiteral: _TemplateLiteral2.default,
  ArrowFunctionExpression: _FunctionExpression2.default,
  FunctionExpression: _FunctionExpression2.default,
  LogicalExpression: _LogicalExpression2.default,
  MemberExpression: _MemberExpression2.default,
  CallExpression: _CallExpression2.default,
  UnaryExpression: _UnaryExpression2.default,
  ThisExpression: _ThisExpression2.default,
  ConditionalExpression: _ConditionalExpression2.default,
  BinaryExpression: _BinaryExpression2.default,
  ObjectExpression: _ObjectExpression2.default,
  NewExpression: _NewExpression2.default,
  UpdateExpression: _UpdateExpression2.default,
  ArrayExpression: _ArrayExpression2.default,
  BindExpression: _BindExpression2.default
};

var noop = function noop() {
  return null;
};
var LITERAL_TYPES = Object.assign({}, TYPES, {
  Literal: function Literal(value) {
	var extractedVal = TYPES.Literal.call(undefined, value);
	var isNull = extractedVal === null;
	return isNull ? 'null' : extractedVal;
  },
  Identifier: function Identifier(value) {
	var isUndefined = TYPES.Identifier.call(undefined, value) === undefined;
	return isUndefined ? undefined : null;
  },
  JSXElement: noop,
  ArrowFunctionExpression: noop,
  FunctionExpression: noop,
  LogicalExpression: noop,
  MemberExpression: noop,
  CallExpression: noop,
  UnaryExpression: function UnaryExpression(value) {
	var extractedVal = TYPES.UnaryExpression.call(undefined, value);
	return extractedVal === undefined ? null : extractedVal;
  },
  UpdateExpression: function UpdateExpression(value) {
	var extractedVal = TYPES.UpdateExpression.call(undefined, value);
	return extractedVal === undefined ? null : extractedVal;
  },
  ThisExpression: noop,
  ConditionalExpression: noop,
  BinaryExpression: noop,
  ObjectExpression: noop,
  NewExpression: noop,
  ArrayExpression: function ArrayExpression(value) {
	var extractedVal = TYPES.ArrayExpression.call(undefined, value);
	return extractedVal.filter(function (val) {
			return val !== null;
	});
  },
  BindExpression: noop
});

var errorMessage = function errorMessage(expression) {
  return 'The prop value with an expression type of ' + expression + ' could not be resolved.\n  Please file issue to get this fixed immediately.';
};
function extract(value) {
  var expression = void 0;
  if (typeof value.expression !== 'boolean' && value.expression) {
	expression = value.expression;
  } else {
	expression = value;
  }
  var _expression = expression,
			type = _expression.type;

  if (TYPES[type] === undefined) {
	throw new Error(errorMessage(type));
  }

  return TYPES[type](expression);
}
function extractLiteral(value) {
  var expression = value.expression || value;
  var type = expression.type;

  if (LITERAL_TYPES[type] === undefined) {
	throw new Error(errorMessage(type));
  }

  return LITERAL_TYPES[type](expression);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var aFunction = __webpack_require__(23);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
	case 1:
			return function (a) {
		return fn.call(that, a);
			};
	case 2:
			return function (a, b) {
		return fn.call(that, a, b);
			};
	case 3:
			return function (a, b, c) {
		return fn.call(that, a, b, c);
			};
  }
  return function () /* ...args */{
	return fn.apply(that, arguments);
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var IObject = __webpack_require__(51);
var defined = __webpack_require__(34);
module.exports = function (it) {
  return IObject(defined(it));
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var core = __webpack_require__(13);
var fails = __webpack_require__(2);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
	fn(1);
  }), 'Object', exp);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var ctx = __webpack_require__(22);
var IObject = __webpack_require__(51);
var toObject = __webpack_require__(18);
var toLength = __webpack_require__(12);
var asc = __webpack_require__(261);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
	var O = toObject($this);
	var self = IObject(O);
	var f = ctx(callbackfn, that, 3);
	var length = toLength(self.length);
	var index = 0;
	var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	var val, res;
	for (; length > index; index++) {
			if (NO_HOLES || index in self) {
		val = self[index];
		res = f(val, index, O);
		if (TYPE) {
					if (IS_MAP) result[index] = res; // map
					else if (res) switch (TYPE) {
							case 3:
				return true; // some
							case 5:
				return val; // find
							case 6:
				return index; // findIndex
							case 2:
				result.push(val); // filter
			} else if (IS_EVERY) return false; // every
		}
			}
	}return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function findVariable(variables, name) {
  return variables.some(function (variable) {
	return variable.name === name;
  });
}
function getVariable(variables, name) {
  return variables.find(function (variable) {
	return variable.name === name;
  });
}
function variablesInScope(context) {
  var scope = context.getScope();
  var variables = scope.variables;

  while (scope.type !== 'global') {
	scope = scope.upper;
	variables = scope.variables.concat(variables);
  }
  if (scope.childScopes.length) {
	variables = scope.childScopes[0].variables.concat(variables);
	if (scope.childScopes[0].childScopes.length) {
			variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
	}
  }
  variables.reverse();

  return variables;
}

module.exports = {
  findVariable: findVariable,
  getVariable: getVariable,
  variablesInScope: variablesInScope
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var pIE = __webpack_require__(59);
var createDesc = __webpack_require__(35);
var toIObject = __webpack_require__(24);
var toPrimitive = __webpack_require__(32);
var has = __webpack_require__(14);
var IE8_DOM_DEFINE = __webpack_require__(116);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(11) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
	return gOPD(O, P);
  } catch (e) {/* empty */}
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (__webpack_require__(11)) {
  var LIBRARY = __webpack_require__(42);
  var global = __webpack_require__(4);
  var fails = __webpack_require__(2);
  var $export = __webpack_require__(1);
  var $typed = __webpack_require__(65);
  var $buffer = __webpack_require__(96);
  var ctx = __webpack_require__(22);
  var anInstance = __webpack_require__(46);
  var propertyDesc = __webpack_require__(35);
  var hide = __webpack_require__(17);
  var redefineAll = __webpack_require__(48);
  var toInteger = __webpack_require__(29);
  var toLength = __webpack_require__(12);
  var toIndex = __webpack_require__(148);
  var toAbsoluteIndex = __webpack_require__(37);
  var toPrimitive = __webpack_require__(32);
  var has = __webpack_require__(14);
  var classof = __webpack_require__(53);
  var isObject = __webpack_require__(3);
  var toObject = __webpack_require__(18);
  var isArrayIter = __webpack_require__(90);
  var create = __webpack_require__(38);
  var getPrototypeOf = __webpack_require__(40);
  var gOPN = __webpack_require__(39).f;
  var getIterFn = __webpack_require__(91);
  var uid = __webpack_require__(36);
  var wks = __webpack_require__(6);
  var createArrayMethod = __webpack_require__(26);
  var createArrayIncludes = __webpack_require__(76);
  var speciesConstructor = __webpack_require__(95);
  var ArrayIterators = __webpack_require__(93);
  var Iterators = __webpack_require__(44);
  var $iterDetect = __webpack_require__(62);
  var setSpecies = __webpack_require__(45);
  var arrayFill = __webpack_require__(92);
  var arrayCopyWithin = __webpack_require__(137);
  var $DP = __webpack_require__(9);
  var $GOPD = __webpack_require__(30);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
	return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
	return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	new Uint8Array(1).set({});
  });

  var toOffset = function toOffset(it, BYTES) {
	var offset = toInteger(it);
	if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
	return offset;
  };

  var validate = function validate(it) {
	if (isObject(it) && TYPED_ARRAY in it) return it;
	throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function allocate(C, length) {
	if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
			throw TypeError('It is not a typed array constructor!');
	}return new C(length);
  };

  var speciesFromList = function speciesFromList(O, list) {
	return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function fromList(C, list) {
	var index = 0;
	var length = list.length;
	var result = allocate(C, length);
	while (length > index) {
			result[index] = list[index++];
	}return result;
  };

  var addGetter = function addGetter(it, key, internal) {
	dP(it, key, { get: function get() {
		return this._d[internal];
			} });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
	var O = toObject(source);
	var aLen = arguments.length;
	var mapfn = aLen > 1 ? arguments[1] : undefined;
	var mapping = mapfn !== undefined;
	var iterFn = getIterFn(O);
	var i, length, values, result, step, iterator;
	if (iterFn != undefined && !isArrayIter(iterFn)) {
			for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
		values.push(step.value);
			}O = values;
	}
	if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
	for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
			result[i] = mapping ? mapfn(O[i], i) : O[i];
	}
	return result;
  };

  var $of = function of() /* ...items */{
	var index = 0;
	var length = arguments.length;
	var result = allocate(this, length);
	while (length > index) {
			result[index] = arguments[index++];
	}return result;
  };
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
	arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
	return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
	copyWithin: function copyWithin(target, start /* , end */) {
			return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	},
	every: function every(callbackfn /* , thisArg */) {
			return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	},
	fill: function fill(value /* , start, end */) {
			return arrayFill.apply(validate(this), arguments);
	},
	filter: function filter(callbackfn /* , thisArg */) {
			return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
	},
	find: function find(predicate /* , thisArg */) {
			return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	},
	findIndex: function findIndex(predicate /* , thisArg */) {
			return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	},
	forEach: function forEach(callbackfn /* , thisArg */) {
			arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	},
	indexOf: function indexOf(searchElement /* , fromIndex */) {
			return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	},
	includes: function includes(searchElement /* , fromIndex */) {
			return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	},
	join: function join(separator) {
			return arrayJoin.apply(validate(this), arguments);
	},
	lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) {
			return arrayLastIndexOf.apply(validate(this), arguments);
	},
	map: function map(mapfn /* , thisArg */) {
			return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	},
	reduce: function reduce(callbackfn /* , initialValue */) {
			return arrayReduce.apply(validate(this), arguments);
	},
	reduceRight: function reduceRight(callbackfn /* , initialValue */) {
			return arrayReduceRight.apply(validate(this), arguments);
	},
	reverse: function reverse() {
			var that = this;
			var length = validate(that).length;
			var middle = Math.floor(length / 2);
			var index = 0;
			var value;
			while (index < middle) {
		value = that[index];
		that[index++] = that[--length];
		that[length] = value;
			}return that;
	},
	some: function some(callbackfn /* , thisArg */) {
			return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	},
	sort: function sort(comparefn) {
			return arraySort.call(validate(this), comparefn);
	},
	subarray: function subarray(begin, end) {
			var O = validate(this);
			var length = O.length;
			var $begin = toAbsoluteIndex(begin, length);
			return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
	}
  };

  var $slice = function slice(start, end) {
	return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
	validate(this);
	var offset = toOffset(arguments[1], 1);
	var length = this.length;
	var src = toObject(arrayLike);
	var len = toLength(src.length);
	var index = 0;
	if (len + offset > length) throw RangeError(WRONG_LENGTH);
	while (index < len) {
			this[offset + index] = src[index++];
	}
  };

  var $iterators = {
	entries: function entries() {
			return arrayEntries.call(validate(this));
	},
	keys: function keys() {
			return arrayKeys.call(validate(this));
	},
	values: function values() {
			return arrayValues.call(validate(this));
	}
  };

  var isTAIndex = function isTAIndex(target, key) {
	return isObject(target) && target[TYPED_ARRAY] && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) != 'symbol' && key in target && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
	return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
	if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set')
	&& !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
			target[key] = desc.value;
			return target;
	}return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
	$GOPD.f = $getDesc;
	$DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	getOwnPropertyDescriptor: $getDesc,
	defineProperty: $setDesc
  });

  if (fails(function () {
	arrayToString.call({});
  })) {
	arrayToString = arrayToLocaleString = function toString() {
			return arrayJoin.call(this);
	};
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
	slice: $slice,
	set: $set,
	constructor: function constructor() {/* noop */},
	toString: arrayToString,
	toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
	get: function get() {
			return this[TYPED_ARRAY];
	}
  });
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	CLAMPED = !!CLAMPED;
	var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
	var GETTER = 'get' + KEY;
	var SETTER = 'set' + KEY;
	var TypedArray = global[NAME];
	var Base = TypedArray || {};
	var TAC = TypedArray && getPrototypeOf(TypedArray);
	var FORCED = !TypedArray || !$typed.ABV;
	var O = {};
	var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	var getter = function getter(that, index) {
			var data = that._d;
			return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	};
	var setter = function setter(that, index, value) {
			var data = that._d;
			if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
			data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	};
	var addElement = function addElement(that, index) {
			dP(that, index, {
		get: function get() {
					return getter(this, index);
		},
		set: function set(value) {
					return setter(this, index, value);
		},
		enumerable: true
			});
	};
	if (FORCED) {
			TypedArray = wrapper(function (that, data, $offset, $length) {
		anInstance(that, TypedArray, NAME, '_d');
		var index = 0;
		var offset = 0;
		var buffer, byteLength, length, klass;
		if (!isObject(data)) {
					length = toIndex(data);
					byteLength = length * BYTES;
					buffer = new $ArrayBuffer(byteLength);
		} else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
					buffer = data;
					offset = toOffset($offset, BYTES);
					var $len = data.byteLength;
					if ($length === undefined) {
			if ($len % BYTES) throw RangeError(WRONG_LENGTH);
			byteLength = $len - offset;
			if (byteLength < 0) throw RangeError(WRONG_LENGTH);
					} else {
			byteLength = toLength($length) * BYTES;
			if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
					}
					length = byteLength / BYTES;
		} else if (TYPED_ARRAY in data) {
					return fromList(TypedArray, data);
		} else {
					return $from.call(TypedArray, data);
		}
		hide(that, '_d', {
					b: buffer,
					o: offset,
					l: byteLength,
					e: length,
					v: new $DataView(buffer)
		});
		while (index < length) {
					addElement(that, index++);
		}
			});
			TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
			hide(TypedArrayPrototype, 'constructor', TypedArray);
	} else if (!fails(function () {
			TypedArray(1);
	}) || !fails(function () {
			new TypedArray(-1); // eslint-disable-line no-new
	}) || !$iterDetect(function (iter) {
			new TypedArray(); // eslint-disable-line no-new
			new TypedArray(null); // eslint-disable-line no-new
			new TypedArray(1.5); // eslint-disable-line no-new
			new TypedArray(iter); // eslint-disable-line no-new
	}, true)) {
			TypedArray = wrapper(function (that, data, $offset, $length) {
		anInstance(that, TypedArray, NAME);
		var klass;
		if (!isObject(data)) return new Base(toIndex(data));
		if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
					return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
		}
		if (TYPED_ARRAY in data) return fromList(TypedArray, data);
		return $from.call(TypedArray, data);
			});
			arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
		if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
			});
			TypedArray[PROTOTYPE] = TypedArrayPrototype;
			if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
	}
	var $nativeIterator = TypedArrayPrototype[ITERATOR];
	var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
	var $iterator = $iterators.values;
	hide(TypedArray, TYPED_CONSTRUCTOR, true);
	hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	hide(TypedArrayPrototype, VIEW, true);
	hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

	if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
			dP(TypedArrayPrototype, TAG, {
		get: function get() {
					return NAME;
		}
			});
	}

	O[NAME] = TypedArray;

	$export($export.G + $export.W + $export.F * (TypedArray != Base), O);

	$export($export.S, NAME, {
			BYTES_PER_ELEMENT: BYTES
	});

	$export($export.S + $export.F * fails(function () {
			Base.of.call(TypedArray, 1);
	}), NAME, {
			from: $from,
			of: $of
	});

	if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

	$export($export.P, NAME, proto);

	setSpecies(NAME);

	$export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

	$export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

	if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

	$export($export.P + $export.F * fails(function () {
			new TypedArray(1).slice();
	}), NAME, { slice: $slice });

	$export($export.P + $export.F * (fails(function () {
			return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	}) || !fails(function () {
			TypedArrayPrototype.toLocaleString.call([1, 2]);
	})), NAME, { toLocaleString: $toLocaleString });

	Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {/* empty */};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var META = __webpack_require__(36)('meta');
var isObject = __webpack_require__(3);
var has = __webpack_require__(14);
var setDesc = __webpack_require__(9).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(2)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function setMeta(it) {
  setDesc(it, META, { value: {
			i: 'O' + ++id, // object ID
			w: {} // weak collections IDs
	} });
};
var fastKey = function fastKey(it, create) {
  if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
	if (!isExtensible(it)) return 'F';
	if (!create) return 'E';
	setMeta(it);
  }return it[META].i;
};
var getWeak = function getWeak(it, create) {
  if (!has(it, META)) {
	if (!isExtensible(it)) return true;
	if (!create) return false;
	setMeta(it);
  }return it[META].w;
};
var onFreeze = function onFreeze(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (bitmap, value) {
  return {
	enumerable: !(bitmap & 1),
	configurable: !(bitmap & 2),
	writable: !(bitmap & 4),
	value: value
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(29);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var anObject = __webpack_require__(5);
var dPs = __webpack_require__(119);
var enumBugKeys = __webpack_require__(78);
var IE_PROTO = __webpack_require__(77)('IE_PROTO');
var Empty = function Empty() {/* empty */};
var PROTOTYPE = 'prototype';
var _createDict = function createDict() {
  var iframe = __webpack_require__(73)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(80).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;
  while (i--) {
	delete _createDict[PROTOTYPE][enumBugKeys[i]];
  }return _createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
	Empty[PROTOTYPE] = anObject(O);
	result = new Empty();
	Empty[PROTOTYPE] = null;
	result[IE_PROTO] = O;
  } else result = _createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $keys = __webpack_require__(118);
var hiddenKeys = __webpack_require__(78).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var has = __webpack_require__(14);
var toObject = __webpack_require__(18);
var IE_PROTO = __webpack_require__(77)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	return O.constructor.prototype;
  }return O instanceof Object ? ObjectProto : null;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var def = __webpack_require__(9).f;
var has = __webpack_require__(14);
var TAG = __webpack_require__(6)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = false;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $keys = __webpack_require__(118);
var enumBugKeys = __webpack_require__(78);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var dP = __webpack_require__(9);
var DESCRIPTORS = __webpack_require__(11);
var SPECIES = __webpack_require__(6)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
	configurable: true,
	get: function get() {
			return this;
	}
  });
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
	throw TypeError(name + ': incorrect invocation!');
  }return it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(22);
var call = __webpack_require__(134);
var isArrayIter = __webpack_require__(90);
var anObject = __webpack_require__(5);
var toLength = __webpack_require__(12);
var getIterFn = __webpack_require__(91);
var BREAK = {};
var RETURN = {};
var _exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
	return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
	result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	result = call(iterator, f, step.value, entries);
	if (result === BREAK || result === RETURN) return result;
  }
};
_exports.BREAK = BREAK;
_exports.RETURN = RETURN;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var redefine = __webpack_require__(15);
module.exports = function (target, src, safe) {
  for (var key in src) {
	redefine(target, key, src[key], safe);
  }return target;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(3);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
(function clone(exports) {
	'use strict';

	var Syntax, isArray, VisitorOption, VisitorKeys, objectCreate, objectKeys, BREAK, SKIP, REMOVE;

	function ignoreJSHintError() {}

	isArray = Array.isArray;
	if (!isArray) {
		isArray = function isArray(array) {
			return Object.prototype.toString.call(array) === '[object Array]';
		};
	}

	function deepCopy(obj) {
		var ret = {},
			key,
			val;
		for (key in obj) {
			if (obj.hasOwnProperty(key)) {
				val = obj[key];
				if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val !== null) {
					ret[key] = deepCopy(val);
				} else {
					ret[key] = val;
				}
			}
		}
		return ret;
	}

	function shallowCopy(obj) {
		var ret = {},
			key;
		for (key in obj) {
			if (obj.hasOwnProperty(key)) {
				ret[key] = obj[key];
			}
		}
		return ret;
	}
	ignoreJSHintError(shallowCopy);
	function upperBound(array, func) {
		var diff, len, i, current;

		len = array.length;
		i = 0;

		while (len) {
			diff = len >>> 1;
			current = i + diff;
			if (func(array[current])) {
				len = diff;
			} else {
				i = current + 1;
				len -= diff + 1;
			}
		}
		return i;
	}

	function lowerBound(array, func) {
		var diff, len, i, current;

		len = array.length;
		i = 0;

		while (len) {
			diff = len >>> 1;
			current = i + diff;
			if (func(array[current])) {
				i = current + 1;
				len -= diff + 1;
			} else {
				len = diff;
			}
		}
		return i;
	}
	ignoreJSHintError(lowerBound);

	objectCreate = Object.create || function () {
		function F() {}

		return function (o) {
			F.prototype = o;
			return new F();
		};
	}();

	objectKeys = Object.keys || function (o) {
		var keys = [],
			key;
		for (key in o) {
			keys.push(key);
		}
		return keys;
	};

	function extend(to, from) {
		var keys = objectKeys(from),
			key,
			i,
			len;
		for (i = 0, len = keys.length; i < len; i += 1) {
			key = keys[i];
			to[key] = from[key];
		}
		return to;
	}

	Syntax = {
		AssignmentExpression: 'AssignmentExpression',
		AssignmentPattern: 'AssignmentPattern',
		ArrayExpression: 'ArrayExpression',
		ArrayPattern: 'ArrayPattern',
		ArrowFunctionExpression: 'ArrowFunctionExpression',
		AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
		BlockStatement: 'BlockStatement',
		BinaryExpression: 'BinaryExpression',
		BreakStatement: 'BreakStatement',
		CallExpression: 'CallExpression',
		CatchClause: 'CatchClause',
		ClassBody: 'ClassBody',
		ClassDeclaration: 'ClassDeclaration',
		ClassExpression: 'ClassExpression',
		ComprehensionBlock: 'ComprehensionBlock', // CAUTION: It's deferred to ES7.
		ComprehensionExpression: 'ComprehensionExpression', // CAUTION: It's deferred to ES7.
		ConditionalExpression: 'ConditionalExpression',
		ContinueStatement: 'ContinueStatement',
		DebuggerStatement: 'DebuggerStatement',
		DirectiveStatement: 'DirectiveStatement',
		DoWhileStatement: 'DoWhileStatement',
		EmptyStatement: 'EmptyStatement',
		ExportAllDeclaration: 'ExportAllDeclaration',
		ExportDefaultDeclaration: 'ExportDefaultDeclaration',
		ExportNamedDeclaration: 'ExportNamedDeclaration',
		ExportSpecifier: 'ExportSpecifier',
		ExpressionStatement: 'ExpressionStatement',
		ForStatement: 'ForStatement',
		ForInStatement: 'ForInStatement',
		ForOfStatement: 'ForOfStatement',
		FunctionDeclaration: 'FunctionDeclaration',
		FunctionExpression: 'FunctionExpression',
		GeneratorExpression: 'GeneratorExpression', // CAUTION: It's deferred to ES7.
		Identifier: 'Identifier',
		IfStatement: 'IfStatement',
		ImportDeclaration: 'ImportDeclaration',
		ImportDefaultSpecifier: 'ImportDefaultSpecifier',
		ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
		ImportSpecifier: 'ImportSpecifier',
		Literal: 'Literal',
		LabeledStatement: 'LabeledStatement',
		LogicalExpression: 'LogicalExpression',
		MemberExpression: 'MemberExpression',
		MetaProperty: 'MetaProperty',
		MethodDefinition: 'MethodDefinition',
		ModuleSpecifier: 'ModuleSpecifier',
		NewExpression: 'NewExpression',
		ObjectExpression: 'ObjectExpression',
		ObjectPattern: 'ObjectPattern',
		Program: 'Program',
		Property: 'Property',
		RestElement: 'RestElement',
		ReturnStatement: 'ReturnStatement',
		SequenceExpression: 'SequenceExpression',
		SpreadElement: 'SpreadElement',
		Super: 'Super',
		SwitchStatement: 'SwitchStatement',
		SwitchCase: 'SwitchCase',
		TaggedTemplateExpression: 'TaggedTemplateExpression',
		TemplateElement: 'TemplateElement',
		TemplateLiteral: 'TemplateLiteral',
		ThisExpression: 'ThisExpression',
		ThrowStatement: 'ThrowStatement',
		TryStatement: 'TryStatement',
		UnaryExpression: 'UnaryExpression',
		UpdateExpression: 'UpdateExpression',
		VariableDeclaration: 'VariableDeclaration',
		VariableDeclarator: 'VariableDeclarator',
		WhileStatement: 'WhileStatement',
		WithStatement: 'WithStatement',
		YieldExpression: 'YieldExpression'
	};

	VisitorKeys = {
		AssignmentExpression: ['left', 'right'],
		AssignmentPattern: ['left', 'right'],
		ArrayExpression: ['elements'],
		ArrayPattern: ['elements'],
		ArrowFunctionExpression: ['params', 'body'],
		AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
		BlockStatement: ['body'],
		BinaryExpression: ['left', 'right'],
		BreakStatement: ['label'],
		CallExpression: ['callee', 'arguments'],
		CatchClause: ['param', 'body'],
		ClassBody: ['body'],
		ClassDeclaration: ['id', 'superClass', 'body'],
		ClassExpression: ['id', 'superClass', 'body'],
		ComprehensionBlock: ['left', 'right'], // CAUTION: It's deferred to ES7.
		ComprehensionExpression: ['blocks', 'filter', 'body'], // CAUTION: It's deferred to ES7.
		ConditionalExpression: ['test', 'consequent', 'alternate'],
		ContinueStatement: ['label'],
		DebuggerStatement: [],
		DirectiveStatement: [],
		DoWhileStatement: ['body', 'test'],
		EmptyStatement: [],
		ExportAllDeclaration: ['source'],
		ExportDefaultDeclaration: ['declaration'],
		ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
		ExportSpecifier: ['exported', 'local'],
		ExpressionStatement: ['expression'],
		ForStatement: ['init', 'test', 'update', 'body'],
		ForInStatement: ['left', 'right', 'body'],
		ForOfStatement: ['left', 'right', 'body'],
		FunctionDeclaration: ['id', 'params', 'body'],
		FunctionExpression: ['id', 'params', 'body'],
		GeneratorExpression: ['blocks', 'filter', 'body'], // CAUTION: It's deferred to ES7.
		Identifier: [],
		IfStatement: ['test', 'consequent', 'alternate'],
		ImportDeclaration: ['specifiers', 'source'],
		ImportDefaultSpecifier: ['local'],
		ImportNamespaceSpecifier: ['local'],
		ImportSpecifier: ['imported', 'local'],
		Literal: [],
		LabeledStatement: ['label', 'body'],
		LogicalExpression: ['left', 'right'],
		MemberExpression: ['object', 'property'],
		MetaProperty: ['meta', 'property'],
		MethodDefinition: ['key', 'value'],
		ModuleSpecifier: [],
		NewExpression: ['callee', 'arguments'],
		ObjectExpression: ['properties'],
		ObjectPattern: ['properties'],
		Program: ['body'],
		Property: ['key', 'value'],
		RestElement: ['argument'],
		ReturnStatement: ['argument'],
		SequenceExpression: ['expressions'],
		SpreadElement: ['argument'],
		Super: [],
		SwitchStatement: ['discriminant', 'cases'],
		SwitchCase: ['test', 'consequent'],
		TaggedTemplateExpression: ['tag', 'quasi'],
		TemplateElement: [],
		TemplateLiteral: ['quasis', 'expressions'],
		ThisExpression: [],
		ThrowStatement: ['argument'],
		TryStatement: ['block', 'handler', 'finalizer'],
		UnaryExpression: ['argument'],
		UpdateExpression: ['argument'],
		VariableDeclaration: ['declarations'],
		VariableDeclarator: ['id', 'init'],
		WhileStatement: ['test', 'body'],
		WithStatement: ['object', 'body'],
		YieldExpression: ['argument']
	};
	BREAK = {};
	SKIP = {};
	REMOVE = {};

	VisitorOption = {
		Break: BREAK,
		Skip: SKIP,
		Remove: REMOVE
	};

	function Reference(parent, key) {
		this.parent = parent;
		this.key = key;
	}

	Reference.prototype.replace = function replace(node) {
		this.parent[this.key] = node;
	};

	Reference.prototype.remove = function remove() {
		if (isArray(this.parent)) {
			this.parent.splice(this.key, 1);
			return true;
		} else {
			this.replace(null);
			return false;
		}
	};

	function Element(node, path, wrap, ref) {
		this.node = node;
		this.path = path;
		this.wrap = wrap;
		this.ref = ref;
	}

	function Controller() {}
	Controller.prototype.path = function path() {
		var i, iz, j, jz, result, element;

		function addToPath(result, path) {
			if (isArray(path)) {
				for (j = 0, jz = path.length; j < jz; ++j) {
					result.push(path[j]);
				}
			} else {
				result.push(path);
			}
		}
		if (!this.__current.path) {
			return null;
		}
		result = [];
		for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
			element = this.__leavelist[i];
			addToPath(result, element.path);
		}
		addToPath(result, this.__current.path);
		return result;
	};
	Controller.prototype.type = function () {
		var node = this.current();
		return node.type || this.__current.wrap;
	};
	Controller.prototype.parents = function parents() {
		var i, iz, result;
		result = [];
		for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
			result.push(this.__leavelist[i].node);
		}

		return result;
	};
	Controller.prototype.current = function current() {
		return this.__current.node;
	};

	Controller.prototype.__execute = function __execute(callback, element) {
		var previous, result;

		result = undefined;

		previous = this.__current;
		this.__current = element;
		this.__state = null;
		if (callback) {
			result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
		}
		this.__current = previous;

		return result;
	};
	Controller.prototype.notify = function notify(flag) {
		this.__state = flag;
	};
	Controller.prototype.skip = function () {
		this.notify(SKIP);
	};
	Controller.prototype['break'] = function () {
		this.notify(BREAK);
	};
	Controller.prototype.remove = function () {
		this.notify(REMOVE);
	};

	Controller.prototype.__initialize = function (root, visitor) {
		this.visitor = visitor;
		this.root = root;
		this.__worklist = [];
		this.__leavelist = [];
		this.__current = null;
		this.__state = null;
		this.__fallback = null;
		if (visitor.fallback === 'iteration') {
			this.__fallback = objectKeys;
		} else if (typeof visitor.fallback === 'function') {
			this.__fallback = visitor.fallback;
		}

		this.__keys = VisitorKeys;
		if (visitor.keys) {
			this.__keys = extend(objectCreate(this.__keys), visitor.keys);
		}
	};

	function isNode(node) {
		if (node == null) {
			return false;
		}
		return (typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && typeof node.type === 'string';
	}

	function isProperty(nodeType, key) {
		return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
	}

	Controller.prototype.traverse = function traverse(root, visitor) {
		var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;

		this.__initialize(root, visitor);

		sentinel = {};
		worklist = this.__worklist;
		leavelist = this.__leavelist;
		worklist.push(new Element(root, null, null, null));
		leavelist.push(new Element(null, null, null, null));

		while (worklist.length) {
			element = worklist.pop();

			if (element === sentinel) {
				element = leavelist.pop();

				ret = this.__execute(visitor.leave, element);

				if (this.__state === BREAK || ret === BREAK) {
					return;
				}
				continue;
			}

			if (element.node) {

				ret = this.__execute(visitor.enter, element);

				if (this.__state === BREAK || ret === BREAK) {
					return;
				}

				worklist.push(sentinel);
				leavelist.push(element);

				if (this.__state === SKIP || ret === SKIP) {
					continue;
				}

				node = element.node;
				nodeType = node.type || element.wrap;
				candidates = this.__keys[nodeType];
				if (!candidates) {
					if (this.__fallback) {
						candidates = this.__fallback(node);
					} else {
						throw new Error('Unknown node type ' + nodeType + '.');
					}
				}

				current = candidates.length;
				while ((current -= 1) >= 0) {
					key = candidates[current];
					candidate = node[key];
					if (!candidate) {
						continue;
					}

					if (isArray(candidate)) {
						current2 = candidate.length;
						while ((current2 -= 1) >= 0) {
							if (!candidate[current2]) {
								continue;
							}
							if (isProperty(nodeType, candidates[current])) {
								element = new Element(candidate[current2], [key, current2], 'Property', null);
							} else if (isNode(candidate[current2])) {
								element = new Element(candidate[current2], [key, current2], null, null);
							} else {
								continue;
							}
							worklist.push(element);
						}
					} else if (isNode(candidate)) {
						worklist.push(new Element(candidate, key, null, null));
					}
				}
			}
		}
	};

	Controller.prototype.replace = function replace(root, visitor) {
		var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;

		function removeElem(element) {
			var i, key, nextElem, parent;

			if (element.ref.remove()) {
				key = element.ref.key;
				parent = element.ref.parent;
				i = worklist.length;
				while (i--) {
					nextElem = worklist[i];
					if (nextElem.ref && nextElem.ref.parent === parent) {
						if (nextElem.ref.key < key) {
							break;
						}
						--nextElem.ref.key;
					}
				}
			}
		}

		this.__initialize(root, visitor);

		sentinel = {};
		worklist = this.__worklist;
		leavelist = this.__leavelist;
		outer = {
			root: root
		};
		element = new Element(root, null, null, new Reference(outer, 'root'));
		worklist.push(element);
		leavelist.push(element);

		while (worklist.length) {
			element = worklist.pop();

			if (element === sentinel) {
				element = leavelist.pop();

				target = this.__execute(visitor.leave, element);
				if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
					element.ref.replace(target);
				}

				if (this.__state === REMOVE || target === REMOVE) {
					removeElem(element);
				}

				if (this.__state === BREAK || target === BREAK) {
					return outer.root;
				}
				continue;
			}

			target = this.__execute(visitor.enter, element);
			if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
				element.ref.replace(target);
				element.node = target;
			}

			if (this.__state === REMOVE || target === REMOVE) {
				removeElem(element);
				element.node = null;
			}

			if (this.__state === BREAK || target === BREAK) {
				return outer.root;
			}
			node = element.node;
			if (!node) {
				continue;
			}

			worklist.push(sentinel);
			leavelist.push(element);

			if (this.__state === SKIP || target === SKIP) {
				continue;
			}

			nodeType = node.type || element.wrap;
			candidates = this.__keys[nodeType];
			if (!candidates) {
				if (this.__fallback) {
					candidates = this.__fallback(node);
				} else {
					throw new Error('Unknown node type ' + nodeType + '.');
				}
			}

			current = candidates.length;
			while ((current -= 1) >= 0) {
				key = candidates[current];
				candidate = node[key];
				if (!candidate) {
					continue;
				}

				if (isArray(candidate)) {
					current2 = candidate.length;
					while ((current2 -= 1) >= 0) {
						if (!candidate[current2]) {
							continue;
						}
						if (isProperty(nodeType, candidates[current])) {
							element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
						} else if (isNode(candidate[current2])) {
							element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
						} else {
							continue;
						}
						worklist.push(element);
					}
				} else if (isNode(candidate)) {
					worklist.push(new Element(candidate, key, null, new Reference(node, key)));
				}
			}
		}

		return outer.root;
	};

	function traverse(root, visitor) {
		var controller = new Controller();
		return controller.traverse(root, visitor);
	}

	function replace(root, visitor) {
		var controller = new Controller();
		return controller.replace(root, visitor);
	}

	function extendCommentRange(comment, tokens) {
		var target;

		target = upperBound(tokens, function search(token) {
			return token.range[0] > comment.range[0];
		});

		comment.extendedRange = [comment.range[0], comment.range[1]];

		if (target !== tokens.length) {
			comment.extendedRange[1] = tokens[target].range[0];
		}

		target -= 1;
		if (target >= 0) {
			comment.extendedRange[0] = tokens[target].range[1];
		}

		return comment;
	}

	function attachComments(tree, providedComments, tokens) {
		var comments = [],
			comment,
			len,
			i,
			cursor;

		if (!tree.range) {
			throw new Error('attachComments needs range information');
		}
		if (!tokens.length) {
			if (providedComments.length) {
				for (i = 0, len = providedComments.length; i < len; i += 1) {
					comment = deepCopy(providedComments[i]);
					comment.extendedRange = [0, tree.range[0]];
					comments.push(comment);
				}
				tree.leadingComments = comments;
			}
			return tree;
		}

		for (i = 0, len = providedComments.length; i < len; i += 1) {
			comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
		}
		cursor = 0;
		traverse(tree, {
			enter: function enter(node) {
				var comment;

				while (cursor < comments.length) {
					comment = comments[cursor];
					if (comment.extendedRange[1] > node.range[0]) {
						break;
					}

					if (comment.extendedRange[1] === node.range[0]) {
						if (!node.leadingComments) {
							node.leadingComments = [];
						}
						node.leadingComments.push(comment);
						comments.splice(cursor, 1);
					} else {
						cursor += 1;
					}
				}
				if (cursor === comments.length) {
					return VisitorOption.Break;
				}

				if (comments[cursor].extendedRange[0] > node.range[1]) {
					return VisitorOption.Skip;
				}
			}
		});

		cursor = 0;
		traverse(tree, {
			leave: function leave(node) {
				var comment;

				while (cursor < comments.length) {
					comment = comments[cursor];
					if (node.range[1] < comment.extendedRange[0]) {
						break;
					}

					if (node.range[1] === comment.extendedRange[0]) {
						if (!node.trailingComments) {
							node.trailingComments = [];
						}
						node.trailingComments.push(comment);
						comments.splice(cursor, 1);
					} else {
						cursor += 1;
					}
				}
				if (cursor === comments.length) {
					return VisitorOption.Break;
				}

				if (comments[cursor].extendedRange[0] > node.range[1]) {
					return VisitorOption.Skip;
				}
			}
		});

		return tree;
	}

	exports.version = __webpack_require__(333).version;
	exports.Syntax = Syntax;
	exports.traverse = traverse;
	exports.replace = replace;
	exports.attachComments = attachComments;
	exports.VisitorKeys = VisitorKeys;
	exports.VisitorOption = VisitorOption;
	exports.Controller = Controller;
	exports.cloneEnvironment = function () {
		return clone({});
	};

	return exports;
})(exports);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var cof = __webpack_require__(28);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var classof = __webpack_require__(53);
var test = {};
test[__webpack_require__(6)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(15)(Object.prototype, 'toString', function toString() {
	return '[object ' + classof(this) + ']';
  }, true);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var cof = __webpack_require__(28);
var TAG = __webpack_require__(6)('toStringTag');
var ARG = cof(function () {
  return arguments;
}()) == 'Arguments';
var tryGet = function tryGet(it, key) {
  try {
	return it[key];
  } catch (e) {/* empty */}
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
  : ARG ? cof(O)
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var UNSCOPABLES = __webpack_require__(6)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(17)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function Cursor() {
	_classCallCheck(this, Cursor);

	this.current = null;
  }


  _createClass(Cursor, [{
	key: "getOneToken",
	value: function getOneToken() {
			return this.moveNext() ? this.current : null;
	}

  }, {
	key: "getAllTokens",
	value: function getAllTokens() {
			var tokens = [];

			while (this.moveNext()) {
		tokens.push(this.current);
			}

			return tokens;
	}

  }, {
	key: "moveNext",
	value: function moveNext() {
			throw new Error("Not implemented.");
	}
  }]);

  return Cursor;
}();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10);
function getStartLocation(token) {
	return token.range[0];
}
exports.search = function search(tokens, location) {
	return lodash.sortedIndexBy(tokens, { range: [location] }, getStartLocation);
};
exports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {
	if (startLoc in indexMap) {
		return indexMap[startLoc];
	}
	if (startLoc - 1 in indexMap) {
		var index = indexMap[startLoc - 1];
		var token = index >= 0 && index < tokens.length ? tokens[index] : null;
		if (token && token.range[0] >= startLoc) {
			return index;
		}
		return index + 1;
	}
	return 0;
};
exports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {
	if (endLoc in indexMap) {
		return indexMap[endLoc] - 1;
	}
	if (endLoc - 1 in indexMap) {
		var index = indexMap[endLoc - 1];
		var token = index >= 0 && index < tokens.length ? tokens[index] : null;
		if (token && token.range[1] > endLoc) {
			return index - 1;
		}
		return index;
	}
	return tokens.length - 1;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


function getReactVersionFromContext(context) {
  var confVer = '999.999.999';
  if (context.settings.react && context.settings.react.version) {
	confVer = context.settings.react.version;
  }
  confVer = /^[0-9]+\.[0-9]+$/.test(confVer) ? confVer + '.0' : confVer;
  return confVer.split('.').map(function (part) {
	return Number(part);
  });
}

function getFlowVersionFromContext(context) {
  var confVer = '999.999.999';
  if (context.settings.react && context.settings.react.flowVersion) {
	confVer = context.settings.react.flowVersion;
  } else {
	throw 'Could not retrieve flowVersion from settings';
  }
  confVer = /^[0-9]+\.[0-9]+$/.test(confVer) ? confVer + '.0' : confVer;
  return confVer.split('.').map(function (part) {
	return Number(part);
  });
}

function test(context, methodVer, confVer) {
  methodVer = methodVer.split('.').map(function (part) {
	return Number(part);
  });
  var higherMajor = methodVer[0] < confVer[0];
  var higherMinor = methodVer[0] === confVer[0] && methodVer[1] < confVer[1];
  var higherOrEqualPatch = methodVer[0] === confVer[0] && methodVer[1] === confVer[1] && methodVer[2] <= confVer[2];

  return higherMajor || higherMinor || higherOrEqualPatch;
}

function testReactVersion(context, methodVer) {
  return test(context, methodVer, getReactVersionFromContext(context));
}

function testFlowVersion(context, methodVer) {
  return test(context, methodVer, getFlowVersionFromContext(context));
}

module.exports = {
  testReactVersion: testReactVersion,
  testFlowVersion: testFlowVersion
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


exports.f = Object.getOwnPropertySymbols;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


exports.f = {}.propertyIsEnumerable;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var defined = __webpack_require__(34);
var fails = __webpack_require__(2);
var spaces = __webpack_require__(82);
var space = '[' + spaces + ']';
var non = '\u200B\x85';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function exporter(KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
	return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(131)(true);
__webpack_require__(86)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0; // next index
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var ITERATOR = __webpack_require__(6)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () {
	SAFE_CLOSING = true;
  };
  Array.from(riter, function () {
	throw 2;
  });
} catch (e) {/* empty */}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
	var arr = [7];
	var iter = arr[ITERATOR]();
	iter.next = function () {
			return { done: safe = true };
	};
	arr[ITERATOR] = function () {
			return iter;
	};
	exec(arr);
  } catch (e) {/* empty */}
  return safe;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var hide = __webpack_require__(17);
var redefine = __webpack_require__(15);
var fails = __webpack_require__(2);
var defined = __webpack_require__(34);
var wks = __webpack_require__(6);

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
	var O = {};
	O[SYMBOL] = function () {
			return 7;
	};
	return ''[KEY](O) != 7;
  })) {
	redefine(String.prototype, KEY, strfn);
	hide(RegExp.prototype, SYMBOL, length == 2
	? function (string, arg) {
			return rxfn.call(string, this, arg);
	}
	: function (string) {
			return rxfn.call(string, this);
	});
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(15);
var redefineAll = __webpack_require__(48);
var meta = __webpack_require__(33);
var forOf = __webpack_require__(47);
var anInstance = __webpack_require__(46);
var isObject = __webpack_require__(3);
var fails = __webpack_require__(2);
var $iterDetect = __webpack_require__(62);
var setToStringTag = __webpack_require__(41);
var inheritIfRequired = __webpack_require__(83);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function fixMethod(KEY) {
	var fn = proto[KEY];
	redefine(proto, KEY, KEY == 'delete' ? function (a) {
			return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	} : KEY == 'has' ? function has(a) {
			return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	} : KEY == 'get' ? function get(a) {
			return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	} : KEY == 'add' ? function add(a) {
			fn.call(this, a === 0 ? 0 : a);return this;
	} : function set(a, b) {
			fn.call(this, a === 0 ? 0 : a, b);return this;
	});
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
	new C().entries().next();
  }))) {
	C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	redefineAll(C.prototype, methods);
	meta.NEED = true;
  } else {
	var instance = new C();
	var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	var THROWS_ON_PRIMITIVES = fails(function () {
			instance.has(1);
	});
	var ACCEPT_ITERABLES = $iterDetect(function (iter) {
			new C(iter);
	}); // eslint-disable-line no-new
	var BUGGY_ZERO = !IS_WEAK && fails(function () {
			var $instance = new C();
			var index = 5;
			while (index--) {
		$instance[ADDER](index, index);
			}return !$instance.has(-0);
	});
	if (!ACCEPT_ITERABLES) {
			C = wrapper(function (target, iterable) {
		anInstance(target, C, NAME);
		var that = inheritIfRequired(new Base(), target, C);
		if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
		return that;
			});
			C.prototype = proto;
			proto.constructor = C;
	}
	if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
			fixMethod('delete');
			fixMethod('has');
			IS_MAP && fixMethod('get');
	}
	if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
	if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var hide = __webpack_require__(17);
var uid = __webpack_require__(36);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
	hide(Typed.prototype, TYPED, true);
	hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Variable = function Variable(name, scope) {
  _classCallCheck(this, Variable);
  this.name = name;
  this.identifiers = [];
  this.references = [];
  this.defs = [];

  this.tainted = false;
  this.stack = true;
  this.scope = scope;
};

Variable.CatchClause = "CatchClause";
Variable.Parameter = "Parameter";
Variable.FunctionName = "FunctionName";
Variable.ClassName = "ClassName";
Variable.Variable = "Variable";
Variable.ImportBinding = "ImportBinding";
Variable.TDZ = "TDZ";
Variable.ImplicitGlobalVariable = "ImplicitGlobalVariable";

module.exports = Variable;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports = module.exports = __webpack_require__(353);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

function useColors() {
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	return true;
  }
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
	return false;
  }
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

exports.formatters.j = function (v) {
  try {
	return JSON.stringify(v);
  } catch (err) {
	return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
	if ('%%' === match) return;
	index++;
	if ('%c' === match) {
			lastC = index;
	}
  });

  args.splice(lastC, 0, c);
}

function log() {
  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

function save(namespaces) {
  try {
	if (null == namespaces) {
			exports.storage.removeItem('debug');
	} else {
			exports.storage.debug = namespaces;
	}
  } catch (e) {}
}

function load() {
  var r;
  try {
	r = exports.storage.debug;
  } catch (e) {}
  if (!r && typeof process !== 'undefined' && 'env' in process) {
	r = process.env.DEBUG;
  }

  return r;
}

exports.enable(load());

function localstorage() {
  try {
	return window.localStorage;
  } catch (e) {}
}
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

(function () {
  'use strict';

  exports.ast = __webpack_require__(356);
  exports.code = __webpack_require__(160);
  exports.keyword = __webpack_require__(357);
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astNodeTypes = __webpack_require__(161),
	commentAttachment = __webpack_require__(358),
	TokenTranslator = __webpack_require__(359),
	acornJSX = __webpack_require__(360),
	rawAcorn = __webpack_require__(362);

var acorn = acornJSX(rawAcorn);
var DEFAULT_ECMA_VERSION = 5;
var lookahead, extra, lastToken;
var assign = Object.assign || function assign(target) {
	for (var argIndex = 1; argIndex < arguments.length; argIndex++) {
		if (arguments[argIndex] !== null && _typeof(arguments[argIndex]) === "object") {
			var keys = Object.keys(arguments[argIndex]);

			for (var keyIndex = 0; keyIndex < keys.length; keyIndex++) {
				target[keys[keyIndex]] = arguments[argIndex][keys[keyIndex]];
			}
		}
	}

	return target;
};
function resetExtra() {
	extra = {
		tokens: null,
		range: false,
		loc: false,
		comment: false,
		comments: [],
		tolerant: false,
		errors: [],
		strict: false,
		ecmaFeatures: {},
		ecmaVersion: DEFAULT_ECMA_VERSION,
		isModule: false
	};
}

var tt = acorn.tokTypes,
	getLineInfo = acorn.getLineInfo;
tt.jsxAttrValueToken = {};
function normalizeEcmaVersion(ecmaVersion) {
	if (typeof ecmaVersion === "number") {
		var version = ecmaVersion;
		if (version >= 2015) {
			version -= 2009;
		}

		switch (version) {
			case 3:
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
				return version;

			default:
				throw new Error("Invalid ecmaVersion.");
		}
	} else {
		return DEFAULT_ECMA_VERSION;
	}
}
function isValidNode(node) {
	return true;
	var ecma = extra.ecmaFeatures;

	switch (node.type) {
		case "ExperimentalSpreadProperty":
		case "ExperimentalRestProperty":
			return ecma.experimentalObjectRestSpread;

		case "ImportDeclaration":
		case "ExportNamedDeclaration":
		case "ExportDefaultDeclaration":
		case "ExportAllDeclaration":
			return extra.isModule;

		default:
			return true;
	}
}
function esprimaFinishNode(result) {
	if (!isValidNode(result)) {
		this.unexpected(result.start);
	}
	if (result.type === "TryStatement") {
		delete result.guardedHandlers;
	} else if (result.type === "CatchClause") {
		delete result.guard;
	}
	if (result.type === "TemplateElement") {
		var terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === "${";

		if (result.range) {
			result.range[0]--;
			result.range[1] += terminalDollarBraceL ? 2 : 1;
		}

		if (result.loc) {
			result.loc.start.column--;
			result.loc.end.column += terminalDollarBraceL ? 2 : 1;
		}
	}
	if (result.type === "Literal" && result.value === undefined) {
		result.value = null;
	}

	if (extra.attachComment) {
		commentAttachment.processComment(result);
	}

	if (result.type.indexOf("Function") > -1 && !result.generator) {
		result.generator = false;
	}

	return result;
}
function isValidToken(parser) {
	return true;
	var ecma = extra.ecmaFeatures;
	var type = parser.type;

	switch (type) {
		case tt.jsxName:
		case tt.jsxText:
		case tt.jsxTagStart:
		case tt.jsxTagEnd:
			return ecma.jsx;
		case tt.regexp:
			if (extra.ecmaVersion < 6 && parser.value.flags && parser.value.flags.indexOf("y") > -1) {
				return false;
			}

			return true;

		default:
			return true;
	}
}
function wrapFinishNode(finishNode) {
	return (/** @this acorn.Parser */function (node, type, pos, loc) {
			var result = finishNode.call(this, node, type, pos, loc);
			return esprimaFinishNode.call(this, result);
		}
	);
}

acorn.plugins.espree = function (instance) {

	instance.extend("finishNode", wrapFinishNode);

	instance.extend("finishNodeAt", wrapFinishNode);

	instance.extend("next", function (next) {
		return (/** @this acorn.Parser */function () {
				if (!isValidToken(this)) {
					this.unexpected();
				}
				return next.call(this);
			}
		);
	});
	instance.extend("checkLVal", function (checkLVal) {

		return (/** @this acorn.Parser */function (expr, isBinding, checkClashes) {

				if (extra.ecmaFeatures.experimentalObjectRestSpread && expr.type === "ObjectPattern") {
					for (var i = 0; i < expr.properties.length; i++) {
						if (expr.properties[i].type.indexOf("Experimental") === -1) {
							this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
						}
					}
					return undefined;
				}

				return checkLVal.call(this, expr, isBinding, checkClashes);
			}
		);
	});

	instance.extend("parseTopLevel", function (parseTopLevel) {
		return (/** @this acorn.Parser */function (node) {
				if (extra.ecmaFeatures.impliedStrict && this.options.ecmaVersion >= 5) {
					this.strict = true;
				}
				return parseTopLevel.call(this, node);
			}
		);
	});

	instance.extend("toAssignable", function (toAssignable) {

		return (/** @this acorn.Parser */function (node, isBinding) {

				if (extra.ecmaFeatures.experimentalObjectRestSpread && node.type === "ObjectExpression") {
					node.type = "ObjectPattern";

					for (var i = 0; i < node.properties.length; i++) {
						var prop = node.properties[i];

						if (prop.type === "ExperimentalSpreadProperty") {
							prop.type = "ExperimentalRestProperty";
						} else if (prop.kind !== "init") {
							this.raise(prop.key.start, "Object pattern can't contain getter or setter");
						} else {
							this.toAssignable(prop.value, isBinding);
						}
					}

					return node;
				} else {
					return toAssignable.call(this, node, isBinding);
				}
			}
		);
	});
	instance.parseObjectRest = function () {
		var node = this.startNode();
		this.next();
		node.argument = this.parseIdent();

		if (this.type === tt.comma) {
			this.raise(this.start, "Unexpected trailing comma after rest property");
		}

		return this.finishNode(node, "ExperimentalRestProperty");
	};

	instance.extend("parseProperty", function (parseProperty) {
		return function (isPattern, refDestructuringErrors) {
			if (extra.ecmaFeatures.experimentalObjectRestSpread && this.type === tt.ellipsis) {
				var prop;

				if (isPattern) {
					prop = this.parseObjectRest();
				} else {
					prop = this.parseSpread();
					prop.type = "ExperimentalSpreadProperty";
				}

				return prop;
			}

			return parseProperty.call(this, isPattern, refDestructuringErrors);
		};
	});

	instance.extend("checkPropClash", function (checkPropClash) {
		return function (prop, propHash) {
			if (prop.type === "ExperimentalRestProperty" || prop.type === "ExperimentalSpreadProperty") {
				return;
			}
			checkPropClash.call(this, prop, propHash);
		};
	});
	instance.raise = instance.raiseRecoverable = function (pos, message) {
		var loc = getLineInfo(this.input, pos);
		var err = new SyntaxError(message);
		err.index = pos;
		err.lineNumber = loc.line;
		err.column = loc.column + 1; // acorn uses 0-based columns
		throw err;
	};
	instance.unexpected = function (pos) {
		var message = "Unexpected token";

		if (pos !== null && pos !== undefined) {
			this.pos = pos;

			if (this.options.locations) {
				while (this.pos < this.lineStart) {
					this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
					--this.curLine;
				}
			}

			this.nextToken();
		}

		if (this.end > this.start) {
			message += " " + this.input.slice(this.start, this.end);
		}

		this.raise(this.start, message);
	};
	instance.extend("jsx_readString", function (jsxReadString) {
		return (/** @this acorn.Parser */function (quote) {
				var result = jsxReadString.call(this, quote);
				if (this.type === tt.string) {
					extra.jsxAttrValueToken = true;
				}

				return result;
			}
		);
	});
};
function tokenize(code, options) {
	var toString,
		tokens,
		impliedStrict,
		translator = new TokenTranslator(tt, code);

	toString = String;
	if (typeof code !== "string" && !(code instanceof String)) {
		code = toString(code);
	}

	lookahead = null;
	options = assign({}, options);

	var acornOptions = { allowImportExportEverywhere: true,
		ecmaVersion: DEFAULT_ECMA_VERSION,
		plugins: {
			espree: true
		}
	};

	resetExtra();
	options.tokens = true;
	extra.tokens = [];

	extra.range = typeof options.range === "boolean" && options.range;
	acornOptions.ranges = extra.range;

	extra.loc = typeof options.loc === "boolean" && options.loc;
	acornOptions.locations = extra.loc;

	extra.comment = typeof options.comment === "boolean" && options.comment;

	if (extra.comment) {
		acornOptions.onComment = function () {
			var comment = convertAcornCommentToEsprimaComment.apply(this, arguments);
			extra.comments.push(comment);
		};
	}

	extra.tolerant = typeof options.tolerant === "boolean" && options.tolerant;

	acornOptions.ecmaVersion = extra.ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);
	if (options.ecmaFeatures && _typeof(options.ecmaFeatures) === "object") {
		extra.ecmaFeatures = assign({}, options.ecmaFeatures);
		impliedStrict = extra.ecmaFeatures.impliedStrict;
		extra.ecmaFeatures.impliedStrict = typeof impliedStrict === "boolean" && impliedStrict;
	}

	try {
		var tokenizer = acorn.tokenizer(code, acornOptions);
		while ((lookahead = tokenizer.getToken()).type !== tt.eof) {
			translator.onToken(lookahead, extra);
		}
		tokens = extra.tokens;

		if (extra.comment) {
			tokens.comments = extra.comments;
		}
		if (extra.tolerant) {
			tokens.errors = extra.errors;
		}
	} catch (e) {
		throw e;
	}
	return tokens;
}
function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {
	var comment = {
		type: block ? "Block" : "Line",
		value: text
	};

	if (typeof start === "number") {
		comment.start = start;
		comment.end = end;
		comment.range = [start, end];
	}

	if ((typeof startLoc === "undefined" ? "undefined" : _typeof(startLoc)) === "object") {
		comment.loc = {
			start: startLoc,
			end: endLoc
		};
	}

	return comment;
}
function parse(code, options) {
	var program,
		toString = String,
		translator,
		impliedStrict,
		acornOptions = { allowImportExportEverywhere: true,
		ecmaVersion: DEFAULT_ECMA_VERSION,
		plugins: {
			espree: true
		}
	};

	lastToken = null;

	if (typeof code !== "string" && !(code instanceof String)) {
		code = toString(code);
	}

	resetExtra();
	commentAttachment.reset();

	if (typeof options !== "undefined") {
		extra.range = typeof options.range === "boolean" && options.range;
		extra.loc = typeof options.loc === "boolean" && options.loc;
		extra.attachComment = typeof options.attachComment === "boolean" && options.attachComment;

		if (extra.loc && options.source !== null && options.source !== undefined) {
			extra.source = toString(options.source);
		}

		if (typeof options.tokens === "boolean" && options.tokens) {
			extra.tokens = [];
			translator = new TokenTranslator(tt, code);
		}
		if (typeof options.comment === "boolean" && options.comment) {
			extra.comment = true;
			extra.comments = [];
		}
		if (typeof options.tolerant === "boolean" && options.tolerant) {
			extra.errors = [];
		}
		if (extra.attachComment) {
			extra.range = true;
			extra.comments = [];
			commentAttachment.reset();
		}

		acornOptions.ecmaVersion = extra.ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);

		if (options.sourceType === "module") {
			extra.isModule = true;
			if (acornOptions.ecmaVersion < 6) {
				acornOptions.ecmaVersion = 6;
				extra.ecmaVersion = 6;
			}

			acornOptions.sourceType = "module";
		}
		if (options.ecmaFeatures && _typeof(options.ecmaFeatures) === "object") {
			extra.ecmaFeatures = assign({}, options.ecmaFeatures);
			impliedStrict = extra.ecmaFeatures.impliedStrict;
			extra.ecmaFeatures.impliedStrict = typeof impliedStrict === "boolean" && impliedStrict;
			if (options.ecmaFeatures.globalReturn) {
				acornOptions.allowReturnOutsideFunction = true;
			}
		}

		acornOptions.onToken = function (token) {
			if (extra.tokens) {
				translator.onToken(token, extra);
			}
			if (token.type !== tt.eof) {
				lastToken = token;
			}
		};

		if (extra.attachComment || extra.comment) {
			acornOptions.onComment = function () {
				var comment = convertAcornCommentToEsprimaComment.apply(this, arguments);
				extra.comments.push(comment);

				if (extra.attachComment) {
					commentAttachment.addComment(comment);
				}
			};
		}

		if (extra.range) {
			acornOptions.ranges = true;
		}

		if (extra.loc) {
			acornOptions.locations = true;
		}

		if (extra.ecmaFeatures.jsx) {
			acornOptions.plugins = {
				jsx: true,
				espree: true
			};
		}
	}

	program = acorn.parse(code, acornOptions);
	program.sourceType = extra.isModule ? "module" : "script";

	if (extra.comment || extra.attachComment) {
		program.comments = extra.comments;
	}

	if (extra.tokens) {
		program.tokens = extra.tokens;
	}
	if (program.range) {
		program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];
		program.range[1] = lastToken ? lastToken.range[1] : program.range[1];
	}

	if (program.loc) {
		program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;
		program.loc.end = lastToken ? lastToken.loc.end : program.loc.end;
	}

	return program;
}
exports.version = __webpack_require__(363).version;

exports.tokenize = tokenize;

exports.parse = parse;
exports.Syntax = function () {
	var name,
		types = {};

	if (typeof Object.create === "function") {
		types = Object.create(null);
	}

	for (name in astNodeTypes) {
		if (astNodeTypes.hasOwnProperty(name)) {
			types[name] = astNodeTypes[name];
		}
	}

	if (typeof Object.freeze === "function") {
		Object.freeze(types);
	}

	return types;
}();
exports.VisitorKeys = function () {
	var visitorKeys = __webpack_require__(364);
	var name,
		keys = {};

	if (typeof Object.create === "function") {
		keys = Object.create(null);
	}

	for (name in visitorKeys) {
		if (visitorKeys.hasOwnProperty(name)) {
			keys[name] = visitorKeys[name];
		}
	}

	if (typeof Object.freeze === "function") {
		Object.freeze(keys);
	}

	return keys;
}();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var astUtils = __webpack_require__(0);

var FixTracker = function () {
	function FixTracker(fixer, sourceCode) {
		_classCallCheck(this, FixTracker);

		this.fixer = fixer;
		this.sourceCode = sourceCode;
		this.retainedRange = null;
	}


	_createClass(FixTracker, [{
		key: "retainRange",
		value: function retainRange(range) {
			this.retainedRange = range;
			return this;
		}

	}, {
		key: "retainEnclosingFunction",
		value: function retainEnclosingFunction(node) {
			var functionNode = astUtils.getUpperFunction(node);

			return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);
		}

	}, {
		key: "retainSurroundingTokens",
		value: function retainSurroundingTokens(nodeOrToken) {
			var tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;
			var tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;

			return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);
		}

	}, {
		key: "replaceTextRange",
		value: function replaceTextRange(range, text) {
			var actualRange = void 0;

			if (this.retainedRange) {
				actualRange = [Math.min(this.retainedRange[0], range[0]), Math.max(this.retainedRange[1], range[1])];
			} else {
				actualRange = range;
			}

			return this.fixer.replaceTextRange(actualRange, this.sourceCode.text.slice(actualRange[0], range[0]) + text + this.sourceCode.text.slice(range[1], actualRange[1]));
		}

	}, {
		key: "remove",
		value: function remove(nodeOrToken) {
			return this.replaceTextRange(nodeOrToken.range, "");
		}
	}]);

	return FixTracker;
}();

module.exports = FixTracker;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var JSX_ANNOTATION_REGEX = /^\*\s*@jsx\s+([^\s]+)/;
var JS_IDENTIFIER_REGEX = /^[_$a-zA-Z][_$a-zA-Z0-9]*$/;

function getCreateClassFromContext(context) {
  var pragma = 'createReactClass';
  if (context.settings.react && context.settings.react.createClass) {
	pragma = context.settings.react.createClass;
  }
  if (!JS_IDENTIFIER_REGEX.test(pragma)) {
	throw new Error('createClass pragma ' + pragma + ' is not a valid function name');
  }
  return pragma;
}

function getFromContext(context) {
  var pragma = 'React';

  var sourceCode = context.getSourceCode();
  var pragmaNode = sourceCode.getAllComments().find(function (node) {
	return JSX_ANNOTATION_REGEX.test(node.value);
  });

  if (pragmaNode) {
	var matches = JSX_ANNOTATION_REGEX.exec(pragmaNode.value);
	pragma = matches[1].split('.')[0];
  } else if (context.settings.react && context.settings.react.pragma) {
	pragma = context.settings.react.pragma;
  }

  if (!JS_IDENTIFIER_REGEX.test(pragma)) {
	throw new Error('React pragma ' + pragma + ' is not a valid identifier');
  }
  return pragma;
}

module.exports = {
  getCreateClassFromContext: getCreateClassFromContext,
  getFromContext: getFromContext
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isAnnotatedFunctionPropsDeclaration(node, context) {
  if (!node || !node.params || !node.params.length) {
	return false;
  }

  var tokens = context.getFirstTokens(node.params[0], 2);
  var isAnnotated = node.params[0].typeAnnotation;
  var isDestructuredProps = node.params[0].type === 'ObjectPattern';
  var isProps = tokens[0].value === 'props' || tokens[1] && tokens[1].value === 'props';

  return isAnnotated && (isDestructuredProps || isProps);
}

module.exports = {
  isAnnotatedFunctionPropsDeclaration: isAnnotatedFunctionPropsDeclaration
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(3);
var document = __webpack_require__(4).document;
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var core = __webpack_require__(13);
var LIBRARY = __webpack_require__(42);
var wksExt = __webpack_require__(117);
var defineProperty = __webpack_require__(9).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var toIObject = __webpack_require__(24);
var toLength = __webpack_require__(12);
var toAbsoluteIndex = __webpack_require__(37);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
	var O = toIObject($this);
	var length = toLength(O.length);
	var index = toAbsoluteIndex(fromIndex, length);
	var value;
	if (IS_INCLUDES && el != el) while (length > index) {
			value = O[index++];
			if (value != value) return true;
	} else for (; length > index; index++) {
			if (IS_INCLUDES || index in O) {
		if (O[index] === el) return IS_INCLUDES || index || 0;
			}
	}return !IS_INCLUDES && -1;
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var shared = __webpack_require__(74)('keys');
var uid = __webpack_require__(36);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var cof = __webpack_require__(28);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var document = __webpack_require__(4).document;
module.exports = document && document.documentElement;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
var anObject = __webpack_require__(5);
var check = function check(O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
	try {
			set = __webpack_require__(22)(Function.call, __webpack_require__(30).f(Object.prototype, '__proto__').set, 2);
			set(test, []);
			buggy = !(test instanceof Array);
	} catch (e) {
			buggy = true;
	}
	return function setPrototypeOf(O, proto) {
			check(O, proto);
			if (buggy) O.__proto__ = proto;else set(O, proto);
			return O;
	};
  }({}, false) : undefined),
  check: check
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(3);
var setPrototypeOf = __webpack_require__(81).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
	setPrototypeOf(that, P);
  }return that;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = Math.sign || function sign(x) {
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $expm1 = Math.expm1;
module.exports = !$expm1
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(42);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(15);
var hide = __webpack_require__(17);
var has = __webpack_require__(14);
var Iterators = __webpack_require__(44);
var $iterCreate = __webpack_require__(132);
var setToStringTag = __webpack_require__(41);
var getPrototypeOf = __webpack_require__(40);
var ITERATOR = __webpack_require__(6)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function getMethod(kind) {
	if (!BUGGY && kind in proto) return proto[kind];
	switch (kind) {
			case KEYS:
		return function keys() {
					return new Constructor(this, kind);
		};
			case VALUES:
		return function values() {
					return new Constructor(this, kind);
		};
	}return function entries() {
			return new Constructor(this, kind);
	};
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = !BUGGY && $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  if ($anyNative) {
	IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
	if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
			setToStringTag(IteratorPrototype, TAG, true);
			if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
	}
  }
  if (DEF_VALUES && $native && $native.name !== VALUES) {
	VALUES_BUG = true;
	$default = function values() {
			return $native.call(this);
	};
  }
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	hide(proto, ITERATOR, $default);
  }
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
	methods = {
			values: DEF_VALUES ? $default : getMethod(VALUES),
			keys: IS_SET ? $default : getMethod(KEYS),
			entries: $entries
	};
	if (FORCED) for (key in methods) {
			if (!(key in proto)) redefine(proto, key, methods[key]);
	} else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isRegExp = __webpack_require__(88);
var defined = __webpack_require__(34);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
var cof = __webpack_require__(28);
var MATCH = __webpack_require__(6)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var MATCH = __webpack_require__(6)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
	'/./'[KEY](re);
  } catch (e) {
	try {
			re[MATCH] = false;
			return !'/./'[KEY](re);
	} catch (f) {/* empty */}
  }return true;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var Iterators = __webpack_require__(44);
var ITERATOR = __webpack_require__(6)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(53);
var ITERATOR = __webpack_require__(6)('iterator');
var Iterators = __webpack_require__(44);
module.exports = __webpack_require__(13).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(18);
var toAbsoluteIndex = __webpack_require__(37);
var toLength = __webpack_require__(12);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) {
	O[index++] = value;
  }return O;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(54);
var step = __webpack_require__(139);
var Iterators = __webpack_require__(44);
var toIObject = __webpack_require__(24);
module.exports = __webpack_require__(86)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0; // next index
  this._k = kind; // kind
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
	this._t = undefined;
	return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var anObject = __webpack_require__(5);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var anObject = __webpack_require__(5);
var aFunction = __webpack_require__(23);
var SPECIES = __webpack_require__(6)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var DESCRIPTORS = __webpack_require__(11);
var LIBRARY = __webpack_require__(42);
var $typed = __webpack_require__(65);
var hide = __webpack_require__(17);
var redefineAll = __webpack_require__(48);
var fails = __webpack_require__(2);
var anInstance = __webpack_require__(46);
var toInteger = __webpack_require__(29);
var toLength = __webpack_require__(12);
var toIndex = __webpack_require__(148);
var gOPN = __webpack_require__(39).f;
var dP = __webpack_require__(9).f;
var arrayFill = __webpack_require__(92);
var setToStringTag = __webpack_require__(41);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  if (value != value || value === Infinity) {
	m = value != value ? 1 : 0;
	e = eMax;
  } else {
	e = floor(log(value) / LN2);
	if (value * (c = pow(2, -e)) < 1) {
			e--;
			c *= 2;
	}
	if (e + eBias >= 1) {
			value += rt / c;
	} else {
			value += rt * pow(2, 1 - eBias);
	}
	if (value * c >= 2) {
			e++;
			c /= 2;
	}
	if (e + eBias >= eMax) {
			m = 0;
			e = eMax;
	} else if (e + eBias >= 1) {
			m = (value * c - 1) * pow(2, mLen);
			e = e + eBias;
	} else {
			m = value * pow(2, eBias - 1) * pow(2, mLen);
			e = 0;
	}
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {}
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {}
  if (e === 0) {
	e = 1 - eBias;
  } else if (e === eMax) {
	return m ? NaN : s ? -Infinity : Infinity;
  } else {
	m = m + pow(2, mLen);
	e = e - eBias;
  }return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function get() {
			return this[internal];
	} });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) {
	store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
  }
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
	anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	var byteLength = toIndex(length);
	this._b = arrayFill.call(new Array(byteLength), 0);
	this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
	anInstance(this, $DataView, DATA_VIEW);
	anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	var bufferLength = buffer[$LENGTH];
	var offset = toInteger(byteOffset);
	if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
	byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
	this[$BUFFER] = buffer;
	this[$OFFSET] = offset;
	this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
	addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	addGetter($DataView, BUFFER, '_b');
	addGetter($DataView, BYTE_LENGTH, '_l');
	addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
	getInt8: function getInt8(byteOffset) {
			return get(this, 1, byteOffset)[0] << 24 >> 24;
	},
	getUint8: function getUint8(byteOffset) {
			return get(this, 1, byteOffset)[0];
	},
	getInt16: function getInt16(byteOffset /* , littleEndian */) {
			var bytes = get(this, 2, byteOffset, arguments[1]);
			return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	},
	getUint16: function getUint16(byteOffset /* , littleEndian */) {
			var bytes = get(this, 2, byteOffset, arguments[1]);
			return bytes[1] << 8 | bytes[0];
	},
	getInt32: function getInt32(byteOffset /* , littleEndian */) {
			return unpackI32(get(this, 4, byteOffset, arguments[1]));
	},
	getUint32: function getUint32(byteOffset /* , littleEndian */) {
			return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	},
	getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
			return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	},
	getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
			return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	},
	setInt8: function setInt8(byteOffset, value) {
			set(this, 1, byteOffset, packI8, value);
	},
	setUint8: function setUint8(byteOffset, value) {
			set(this, 1, byteOffset, packI8, value);
	},
	setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
			set(this, 2, byteOffset, packI16, value, arguments[2]);
	},
	setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
			set(this, 2, byteOffset, packI16, value, arguments[2]);
	},
	setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
			set(this, 4, byteOffset, packI32, value, arguments[2]);
	},
	setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
			set(this, 4, byteOffset, packI32, value, arguments[2]);
	},
	setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
			set(this, 4, byteOffset, packF32, value, arguments[2]);
	},
	setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
			set(this, 8, byteOffset, packF64, value, arguments[2]);
	}
  });
} else {
  if (!fails(function () {
	$ArrayBuffer(1);
  }) || !fails(function () {
	new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
	new $ArrayBuffer(); // eslint-disable-line no-new
	new $ArrayBuffer(1.5); // eslint-disable-line no-new
	new $ArrayBuffer(NaN); // eslint-disable-line no-new
	return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
	$ArrayBuffer = function ArrayBuffer(length) {
			anInstance(this, $ArrayBuffer);
			return new BaseBuffer(toIndex(length));
	};
	var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
			if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
	}
	if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
	setInt8: function setInt8(byteOffset, value) {
			$setInt8.call(this, byteOffset, value << 24 >> 24);
	},
	setUint8: function setUint8(byteOffset, value) {
			$setInt8.call(this, byteOffset, value << 24 >> 24);
	}
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $iterators = __webpack_require__(93);
var getKeys = __webpack_require__(43);
var redefine = __webpack_require__(15);
var global = __webpack_require__(4);
var hide = __webpack_require__(17);
var Iterators = __webpack_require__(44);
var wks = __webpack_require__(6);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
	if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
	if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
	Iterators[NAME] = ArrayValues;
	if (explicit) for (key in $iterators) {
			if (!proto[key]) redefine(proto, key, $iterators[key], true);
	}
  }
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
			var length = arguments.length;
			var A = new Array(length);
			while (length--) {
		A[length] = arguments[length];
			}return new this(A);
	} });
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var aFunction = __webpack_require__(23);
var ctx = __webpack_require__(22);
var forOf = __webpack_require__(47);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
			var mapFn = arguments[1];
			var mapping, A, n, cb;
			aFunction(this);
			mapping = mapFn !== undefined;
			if (mapping) aFunction(mapFn);
			if (source == undefined) return new this();
			A = [];
			if (mapping) {
		n = 0;
		cb = ctx(mapFn, arguments[2], 2);
		forOf(source, false, function (nextItem) {
					A.push(cb(nextItem, n++));
		});
			} else {
		forOf(source, false, A.push, A);
			}
			return new this(A);
	} });
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var READ = 0x1;
var WRITE = 0x2;
var RW = READ | WRITE;

var Reference = function () {
  function Reference(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
	_classCallCheck(this, Reference);
	this.identifier = ident;
	this.from = scope;
	this.tainted = false;
	this.resolved = null;
	this.flag = flag;
	if (this.isWrite()) {
			this.writeExpr = writeExpr;
			this.partial = partial;
			this.init = init;
	}
	this.__maybeImplicitGlobal = maybeImplicitGlobal;
  }


  _createClass(Reference, [{
	key: "isStatic",
	value: function isStatic() {
			return !this.tainted && this.resolved && this.resolved.scope.isStatic();
	}

  }, {
	key: "isWrite",
	value: function isWrite() {
			return !!(this.flag & Reference.WRITE);
	}

  }, {
	key: "isRead",
	value: function isRead() {
			return !!(this.flag & Reference.READ);
	}

  }, {
	key: "isReadOnly",
	value: function isReadOnly() {
			return this.flag === Reference.READ;
	}

  }, {
	key: "isWriteOnly",
	value: function isWriteOnly() {
			return this.flag === Reference.WRITE;
	}

  }, {
	key: "isReadWrite",
	value: function isReadWrite() {
			return this.flag === Reference.RW;
	}
  }]);

  return Reference;
}();


Reference.READ = READ;
Reference.WRITE = WRITE;
Reference.RW = RW;

module.exports = Reference;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;
g = function () {
	return this;
}();

try {
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}
module.exports = g;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = __webpack_require__(158);
function isReachable(segment) {
	return segment.reachable;
}

var CodePathSegment = function () {
	function CodePathSegment(id, allPrevSegments, reachable) {
		_classCallCheck(this, CodePathSegment);
		this.id = id;
		this.nextSegments = [];
		this.prevSegments = allPrevSegments.filter(isReachable);
		this.allNextSegments = [];
		this.allPrevSegments = allPrevSegments;
		this.reachable = reachable;
		Object.defineProperty(this, "internal", {
			value: {
				used: false,
				loopedPrevSegments: []
			}
		});
		if (debug.enabled) {
			this.internal.nodes = [];
			this.internal.exitNodes = [];
		}
	}


	_createClass(CodePathSegment, [{
		key: "isLoopedPrevSegment",
		value: function isLoopedPrevSegment(segment) {
			return this.internal.loopedPrevSegments.indexOf(segment) !== -1;
		}

	}], [{
		key: "newRoot",
		value: function newRoot(id) {
			return new CodePathSegment(id, [], true);
		}

	}, {
		key: "newNext",
		value: function newNext(id, allPrevSegments) {
			return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable));
		}

	}, {
		key: "newUnreachable",
		value: function newUnreachable(id, allPrevSegments) {
			var segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);
			CodePathSegment.markUsed(segment);

			return segment;
		}

	}, {
		key: "newDisconnected",
		value: function newDisconnected(id, allPrevSegments) {
			return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
		}

	}, {
		key: "markUsed",
		value: function markUsed(segment) {
			if (segment.internal.used) {
				return;
			}
			segment.internal.used = true;

			var i = void 0;

			if (segment.reachable) {
				for (i = 0; i < segment.allPrevSegments.length; ++i) {
					var prevSegment = segment.allPrevSegments[i];

					prevSegment.allNextSegments.push(segment);
					prevSegment.nextSegments.push(segment);
				}
			} else {
				for (i = 0; i < segment.allPrevSegments.length; ++i) {
					segment.allPrevSegments[i].allNextSegments.push(segment);
				}
			}
		}

	}, {
		key: "markPrevSegmentAsLooped",
		value: function markPrevSegmentAsLooped(segment, prevSegment) {
			segment.internal.loopedPrevSegments.push(prevSegment);
		}

	}, {
		key: "flattenUnusedSegments",
		value: function flattenUnusedSegments(segments) {
			var done = Object.create(null);
			var retv = [];

			for (var i = 0; i < segments.length; ++i) {
				var segment = segments[i];
				if (done[segment.id]) {
					continue;
				}
				if (!segment.internal.used) {
					for (var j = 0; j < segment.allPrevSegments.length; ++j) {
						var prevSegment = segment.allPrevSegments[j];

						if (!done[prevSegment.id]) {
							done[prevSegment.id] = true;
							retv.push(prevSegment);
						}
					}
				} else {
					done[segment.id] = true;
					retv.push(segment);
				}
			}

			return retv;
		}
	}]);

	return CodePathSegment;
}();

module.exports = CodePathSegment;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {
//
//
//
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
	var last = parts[i];
	if (last === '.') {
			parts.splice(i, 1);
	} else if (last === '..') {
			parts.splice(i, 1);
			up++;
	} else if (up) {
			parts.splice(i, 1);
			up--;
	}
  }
  if (allowAboveRoot) {
	for (; up--; up) {
			parts.unshift('..');
	}
  }

  return parts;
}
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function splitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
};
exports.resolve = function () {
  var resolvedPath = '',
			resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	var path = i >= 0 ? arguments[i] : process.cwd();
	if (typeof path !== 'string') {
			throw new TypeError('Arguments to path.resolve must be strings');
	} else if (!path) {
			continue;
	}

	resolvedPath = path + '/' + resolvedPath;
	resolvedAbsolute = path.charAt(0) === '/';
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
	return !!p;
  }), !resolvedAbsolute).join('/');

  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
};
exports.normalize = function (path) {
  var isAbsolute = exports.isAbsolute(path),
			trailingSlash = substr(path, -1) === '/';
  path = normalizeArray(filter(path.split('/'), function (p) {
	return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
	path = '.';
  }
  if (path && trailingSlash) {
	path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};
exports.isAbsolute = function (path) {
  return path.charAt(0) === '/';
};
exports.join = function () {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function (p, index) {
	if (typeof p !== 'string') {
			throw new TypeError('Arguments to path.join must be strings');
	}
	return p;
  }).join('/'));
};
exports.relative = function (from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
	var start = 0;
	for (; start < arr.length; start++) {
			if (arr[start] !== '') break;
	}

	var end = arr.length - 1;
	for (; end >= 0; end--) {
			if (arr[end] !== '') break;
	}

	if (start > end) return [];
	return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
	if (fromParts[i] !== toParts[i]) {
			samePartsLength = i;
			break;
	}
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
	outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  var result = splitPath(path),
			root = result[0],
			dir = result[1];

  if (!root && !dir) {
	return '.';
  }

  if (dir) {
	dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};

exports.basename = function (path, ext) {
  var f = splitPath(path)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
	f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  return splitPath(path)[3];
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
	if (f(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
}
var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cursor = __webpack_require__(55);
module.exports = function (_Cursor) {
  _inherits(DecorativeCursor, _Cursor);
  function DecorativeCursor(cursor) {
	_classCallCheck(this, DecorativeCursor);

	var _this = _possibleConstructorReturn(this, (DecorativeCursor.__proto__ || Object.getPrototypeOf(DecorativeCursor)).call(this));

	_this.cursor = cursor;
	return _this;
  }


  _createClass(DecorativeCursor, [{
	key: "moveNext",
	value: function moveNext() {
			var retv = this.cursor.moveNext();

			this.current = this.cursor.current;

			return retv;
	}
  }]);

  return DecorativeCursor;
}(Cursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cursor = __webpack_require__(55);
var utils = __webpack_require__(56);
module.exports = function (_Cursor) {
	_inherits(ForwardTokenCursor, _Cursor);
	function ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc) {
		_classCallCheck(this, ForwardTokenCursor);

		var _this = _possibleConstructorReturn(this, (ForwardTokenCursor.__proto__ || Object.getPrototypeOf(ForwardTokenCursor)).call(this));

		_this.tokens = tokens;
		_this.index = utils.getFirstIndex(tokens, indexMap, startLoc);
		_this.indexEnd = utils.getLastIndex(tokens, indexMap, endLoc);
		return _this;
	}


	_createClass(ForwardTokenCursor, [{
		key: "moveNext",
		value: function moveNext() {
			if (this.index <= this.indexEnd) {
				this.current = this.tokens[this.index];
				this.index += 1;
				return true;
			}
			return false;
		}

	}, {
		key: "getOneToken",
		value: function getOneToken() {
			return this.index <= this.indexEnd ? this.tokens[this.index] : null;
		}

	}, {
		key: "getAllTokens",
		value: function getAllTokens() {
			return this.tokens.slice(this.index, this.indexEnd + 1);
		}
	}]);

	return ForwardTokenCursor;
}(Cursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var estraverse = __webpack_require__(50);
var KEY_BLACKLIST = new Set(["parent", "leadingComments", "trailingComments"]);

var Traverser = function (_estraverse$Controlle) {
	_inherits(Traverser, _estraverse$Controlle);

	function Traverser() {
		_classCallCheck(this, Traverser);

		return _possibleConstructorReturn(this, (Traverser.__proto__ || Object.getPrototypeOf(Traverser)).apply(this, arguments));
	}

	_createClass(Traverser, [{
		key: "traverse",
		value: function traverse(node, visitor) {
			visitor.fallback = Traverser.getKeys;
			return _get(Traverser.prototype.__proto__ || Object.getPrototypeOf(Traverser.prototype), "traverse", this).call(this, node, visitor);
		}

	}], [{
		key: "getKeys",
		value: function getKeys(node) {
			return Object.keys(node).filter(function (key) {
				return !KEY_BLACKLIST.has(key);
			});
		}
	}]);

	return Traverser;
}(estraverse.Controller);

module.exports = Traverser;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ["abstract", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "debugger", "default", "delete", "do", "double", "else", "enum", "export", "extends", "false", "final", "finally", "float", "for", "function", "goto", "if", "implements", "import", "in", "instanceof", "int", "interface", "long", "native", "new", "null", "package", "private", "protected", "public", "return", "short", "static", "super", "switch", "synchronized", "this", "throw", "throws", "transient", "true", "try", "typeof", "var", "void", "volatile", "while", "with"];
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(global, process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
//
//
//
var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  if (!isString(f)) {
	var objects = [];
	for (var i = 0; i < arguments.length; i++) {
			objects.push(inspect(arguments[i]));
	}
	return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
	if (x === '%%') return '%';
	if (i >= len) return x;
	switch (x) {
			case '%s':
		return String(args[i++]);
			case '%d':
		return Number(args[i++]);
			case '%j':
		try {
					return JSON.stringify(args[i++]);
		} catch (_) {
					return '[Circular]';
		}
			default:
		return x;
	}
  });
  for (var x = args[i]; i < len; x = args[++i]) {
	if (isNull(x) || !isObject(x)) {
			str += ' ' + x;
	} else {
			str += ' ' + inspect(x);
	}
  }
  return str;
};
exports.deprecate = function (fn, msg) {
  if (isUndefined(global.process)) {
	return function () {
			return exports.deprecate(fn, msg).apply(this, arguments);
	};
  }

  if (process.noDeprecation === true) {
	return fn;
  }

  var warned = false;
  function deprecated() {
	if (!warned) {
			if (process.throwDeprecation) {
		throw new Error(msg);
			} else if (process.traceDeprecation) {
		console.trace(msg);
			} else {
		console.error(msg);
			}
			warned = true;
	}
	return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;
exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
	if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
			var pid = process.pid;
			debugs[set] = function () {
		var msg = exports.format.apply(exports, arguments);
		console.error('%s %d: %s', set, pid, msg);
			};
	} else {
			debugs[set] = function () {};
	}
  }
  return debugs[set];
};
function inspect(obj, opts) {
  var ctx = {
	seen: [],
	stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
	ctx.showHidden = opts;
  } else if (opts) {
	exports._extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
	return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm';
  } else {
	return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};

  array.forEach(function (val, idx) {
	hash[val] = true;
  });

  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  value.inspect !== exports.inspect &&
  !(value.constructor && value.constructor.prototype === value)) {
	var ret = value.inspect(recurseTimes, ctx);
	if (!isString(ret)) {
			ret = formatValue(ctx, ret, recurseTimes);
	}
	return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
	return primitive;
  }
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
	keys = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	return formatError(value);
  }
  if (keys.length === 0) {
	if (isFunction(value)) {
			var name = value.name ? ': ' + value.name : '';
			return ctx.stylize('[Function' + name + ']', 'special');
	}
	if (isRegExp(value)) {
			return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	}
	if (isDate(value)) {
			return ctx.stylize(Date.prototype.toString.call(value), 'date');
	}
	if (isError(value)) {
			return formatError(value);
	}
  }

  var base = '',
			array = false,
			braces = ['{', '}'];
  if (isArray(value)) {
	array = true;
	braces = ['[', ']'];
  }
  if (isFunction(value)) {
	var n = value.name ? ': ' + value.name : '';
	base = ' [Function' + n + ']';
  }
  if (isRegExp(value)) {
	base = ' ' + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
	base = ' ' + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
	base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
	return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
	if (isRegExp(value)) {
			return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	} else {
			return ctx.stylize('[Object]', 'special');
	}
  }

  ctx.seen.push(value);

  var output;
  if (array) {
	output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
	output = keys.map(function (key) {
			return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	});
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
	var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
	return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
	if (hasOwnProperty(value, String(i))) {
			output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
	} else {
			output.push('');
	}
  }
  keys.forEach(function (key) {
	if (!key.match(/^\d+$/)) {
			output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
	}
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
	if (desc.set) {
			str = ctx.stylize('[Getter/Setter]', 'special');
	} else {
			str = ctx.stylize('[Getter]', 'special');
	}
  } else {
	if (desc.set) {
			str = ctx.stylize('[Setter]', 'special');
	}
  }
  if (!hasOwnProperty(visibleKeys, key)) {
	name = '[' + key + ']';
  }
  if (!str) {
	if (ctx.seen.indexOf(desc.value) < 0) {
			if (isNull(recurseTimes)) {
		str = formatValue(ctx, desc.value, null);
			} else {
		str = formatValue(ctx, desc.value, recurseTimes - 1);
			}
			if (str.indexOf('\n') > -1) {
		if (array) {
					str = str.split('\n').map(function (line) {
			return '  ' + line;
					}).join('\n').substr(2);
		} else {
					str = '\n' + str.split('\n').map(function (line) {
			return '   ' + line;
					}).join('\n');
		}
			}
	} else {
			str = ctx.stylize('[Circular]', 'special');
	}
  }
  if (isUndefined(name)) {
	if (array && key.match(/^\d+$/)) {
			return str;
	}
	name = JSON.stringify('' + key);
	if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
			name = name.substr(1, name.length - 2);
			name = ctx.stylize(name, 'name');
	} else {
			name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
			name = ctx.stylize(name, 'string');
	}
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
	numLinesEst++;
	if (cur.indexOf('\n') >= 0) numLinesEst++;
	return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
	return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(649);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
exports.inherits = __webpack_require__(650);

exports._extend = function (origin, add) {
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
	origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
}.call(exports, __webpack_require__(101), __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _hasProp = __webpack_require__(679);

var _hasProp2 = _interopRequireDefault(_hasProp);

var _elementType = __webpack_require__(680);

var _elementType2 = _interopRequireDefault(_elementType);

var _eventHandlers = __webpack_require__(681);

var _eventHandlers2 = _interopRequireDefault(_eventHandlers);

var _getProp = __webpack_require__(682);

var _getProp2 = _interopRequireDefault(_getProp);

var _getPropValue = __webpack_require__(683);

var _getPropValue2 = _interopRequireDefault(_getPropValue);

var _propName = __webpack_require__(110);

var _propName2 = _interopRequireDefault(_propName);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

module.exports = {
  hasProp: _hasProp2.default,
  hasAnyProp: _hasProp.hasAnyProp,
  hasEveryProp: _hasProp.hasEveryProp,
  elementType: _elementType2.default,
  eventHandlers: _eventHandlers2.default,
  eventHandlersByType: _eventHandlers.eventHandlersByType,
  getProp: _getProp2.default,
  getPropValue: _getPropValue2.default,
  getLiteralPropValue: _getPropValue.getLiteralPropValue,
  propName: _propName2.default
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = propName;
function propName() {
  var prop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (!prop.type || prop.type !== 'JSXAttribute') {
	throw new Error('The prop must be a JSXAttribute collected by the AST parser.');
  }

  if (prop.name.type === 'JSXNamespacedName') {
	return prop.name.namespace.name + ':' + prop.name.name.name;
  }

  return prop.name.name;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function makeNoMethodSetStateRule(methodName) {
  return {
	meta: {
			docs: {
		description: 'Prevent usage of setState in ' + methodName,
		category: 'Best Practices',
		recommended: false
			},

			schema: [{
		enum: ['disallow-in-func']
			}]
	},

	create: function create(context) {
			var mode = context.options[0] || 'allow-in-func';
			return {

		CallExpression: function CallExpression(node) {
					var callee = node.callee;
					if (callee.type !== 'MemberExpression' || callee.object.type !== 'ThisExpression' || callee.property.name !== 'setState') {
			return;
					}
					var ancestors = context.getAncestors(callee).reverse();
					var depth = 0;
					for (var i = 0, j = ancestors.length; i < j; i++) {
			if (/Function(Expression|Declaration)$/.test(ancestors[i].type)) {
							depth++;
			}
			if (ancestors[i].type !== 'Property' && ancestors[i].type !== 'MethodDefinition' || ancestors[i].key.name !== methodName || mode !== 'disallow-in-func' && depth > 1) {
							continue;
			}
			context.report({
							node: callee,
							message: 'Do not use setState in ' + methodName
			});
			break;
					}
		}
			};
	}
  };
}

module.exports = makeNoMethodSetStateRule;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function makeEmptyFunction(arg) {
  return function () {
	return arg;
  };
}
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
	if (format === undefined) {
			throw new Error('invariant requires an error message argument');
	}
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
	var error;
	if (format === undefined) {
			error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	} else {
			var args = [a, b, c, d, e, f];
			var argIndex = 0;
			error = new Error(format.replace(/%s/g, function () {
		return args[argIndex++];
			}));
			error.name = 'Invariant Violation';
	}

	error.framesToPop = 1; // we don't care about invariant's own frame
	throw error;
  }
}

module.exports = invariant;
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var global = __webpack_require__(4);
var has = __webpack_require__(14);
var DESCRIPTORS = __webpack_require__(11);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(15);
var META = __webpack_require__(33).KEY;
var $fails = __webpack_require__(2);
var shared = __webpack_require__(74);
var setToStringTag = __webpack_require__(41);
var uid = __webpack_require__(36);
var wks = __webpack_require__(6);
var wksExt = __webpack_require__(117);
var wksDefine = __webpack_require__(75);
var enumKeys = __webpack_require__(175);
var isArray = __webpack_require__(79);
var anObject = __webpack_require__(5);
var isObject = __webpack_require__(3);
var toIObject = __webpack_require__(24);
var toPrimitive = __webpack_require__(32);
var createDesc = __webpack_require__(35);
var _create = __webpack_require__(38);
var gOPNExt = __webpack_require__(120);
var $GOPD = __webpack_require__(30);
var $DP = __webpack_require__(9);
var $keys = __webpack_require__(43);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
	get: function get() {
			return dP(this, 'a', { value: 7 }).a;
	}
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function wrap(tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && _typeof($Symbol.iterator) == 'symbol' ? function (it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
	if (!D.enumerable) {
			if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
			it[HIDDEN][key] = true;
	} else {
			if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
			D = _create(D, { enumerable: createDesc(0, false) });
	}return setSymbolDesc(it, key, D);
  }return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) {
	$defineProperty(it, key = keys[i++], P[key]);
  }return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
	if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
	if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }return result;
};
if (!USE_NATIVE) {
  $Symbol = function _Symbol() {
	if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	var $set = function $set(value) {
			if (this === ObjectProto) $set.call(OPSymbols, value);
			if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
			setSymbolDesc(this, tag, createDesc(1, value));
	};
	if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
	return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(39).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(59).f = $propertyIsEnumerable;
  __webpack_require__(58).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(42)) {
	redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
	return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols =
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
  wks(es6Symbols[j++]);
}for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) {
  wksDefine(wellKnownSymbols[k++]);
}$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  'for': function _for(key) {
	return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  keyFor: function keyFor(sym) {
	if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	for (var key in SymbolRegistry) {
			if (SymbolRegistry[key] === sym) return key;
	}
  },
  useSetter: function useSetter() {
	setter = true;
  },
  useSimple: function useSimple() {
	setter = false;
  }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  create: $create,
  defineProperty: $defineProperty,
  defineProperties: $defineProperties,
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  getOwnPropertyNames: $getOwnPropertyNames,
  getOwnPropertySymbols: $getOwnPropertySymbols
});
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
	var args = [it];
	var i = 1;
	var replacer, $replacer;
	while (arguments.length > i) {
			args.push(arguments[i++]);
	}$replacer = replacer = args[1];
	if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	if (!isArray(replacer)) replacer = function replacer(key, value) {
			if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
			if (!isSymbol(value)) return value;
	};
	args[1] = replacer;
	return _stringify.apply($JSON, args);
  }
});
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(17)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
setToStringTag($Symbol, 'Symbol');
setToStringTag(Math, 'Math', true);
setToStringTag(global.JSON, 'JSON', true);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = !__webpack_require__(11) && !__webpack_require__(2)(function () {
  return Object.defineProperty(__webpack_require__(73)('div'), 'a', { get: function get() {
			return 7;
	} }).a != 7;
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


exports.f = __webpack_require__(6);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(14);
var toIObject = __webpack_require__(24);
var arrayIndexOf = __webpack_require__(76)(false);
var IE_PROTO = __webpack_require__(77)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) {
	if (key != IE_PROTO) has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys
  while (names.length > i) {
	if (has(O, key = names[i++])) {
			~arrayIndexOf(result, key) || result.push(key);
	}
  }return result;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(9);
var anObject = __webpack_require__(5);
var getKeys = __webpack_require__(43);

module.exports = __webpack_require__(11) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) {
	dP.f(O, P = keys[i++], Properties[P]);
  }return O;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
var toIObject = __webpack_require__(24);
var gOPN = __webpack_require__(39).f;
var toString = {}.toString;

var windowNames = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
	return gOPN(it);
  } catch (e) {
	return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var getKeys = __webpack_require__(43);
var gOPS = __webpack_require__(58);
var pIE = __webpack_require__(59);
var toObject = __webpack_require__(18);
var IObject = __webpack_require__(51);
var $assign = Object.assign;
module.exports = !$assign || __webpack_require__(2)(function () {
  var A = {};
  var B = {};
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
	B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
	var S = IObject(arguments[index++]);
	var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	var length = keys.length;
	var j = 0;
	var key;
	while (length > j) {
			if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	}
  }return T;
} : $assign;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(23);
var isObject = __webpack_require__(3);
var invoke = __webpack_require__(123);
var arraySlice = [].slice;
var factories = {};

var construct = function construct(F, len, args) {
  if (!(len in factories)) {
	for (var n = [], i = 0; i < len; i++) {
			n[i] = 'a[' + i + ']';
	} // eslint-disable-next-line no-new-func
	factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function bound() /* args... */{
	var args = partArgs.concat(arraySlice.call(arguments));
	return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = function (fn, args, that) {
									var un = that === undefined;
									switch (args.length) {
									case 0:
																											return un ? fn() : fn.call(that);
									case 1:
																											return un ? fn(args[0]) : fn.call(that, args[0]);
									case 2:
																											return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
									case 3:
																											return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
									case 4:
																											return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
									}return fn.apply(that, args);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $parseInt = __webpack_require__(4).parseInt;
var $trim = __webpack_require__(60).trim;
var ws = __webpack_require__(82);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $parseFloat = __webpack_require__(4).parseFloat;
var $trim = __webpack_require__(60).trim;

module.exports = 1 / $parseFloat(__webpack_require__(82) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var cof = __webpack_require__(28);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(29);
var defined = __webpack_require__(34);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (; n > 0; (n >>>= 1) && (str += str)) {
	if (n & 1) res += str;
  }return res;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toIObject = __webpack_require__(24);
var toLength = __webpack_require__(12);

$export($export.S, 'String', {
  raw: function raw(callSite) {
	var tpl = toIObject(callSite.raw);
	var len = toLength(tpl.length);
	var aLen = arguments.length;
	var res = [];
	var i = 0;
	while (len > i) {
			res.push(String(tpl[i++]));
			if (i < aLen) res.push(String(arguments[i]));
	}return res.join('');
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(29);
var defined = __webpack_require__(34);
module.exports = function (TO_STRING) {
  return function (that, pos) {
	var s = String(defined(that));
	var i = toInteger(pos);
	var l = s.length;
	var a, b;
	if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	a = s.charCodeAt(i);
	return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(38);
var descriptor = __webpack_require__(35);
var setToStringTag = __webpack_require__(41);
var IteratorPrototype = {};
__webpack_require__(17)(IteratorPrototype, __webpack_require__(6)('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(22);
var $export = __webpack_require__(1);
var toObject = __webpack_require__(18);
var call = __webpack_require__(134);
var isArrayIter = __webpack_require__(90);
var toLength = __webpack_require__(12);
var createProperty = __webpack_require__(135);
var getIterFn = __webpack_require__(91);

$export($export.S + $export.F * !__webpack_require__(62)(function (iter) {
  Array.from(iter);
}), 'Array', {
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	var O = toObject(arrayLike);
	var C = typeof this == 'function' ? this : Array;
	var aLen = arguments.length;
	var mapfn = aLen > 1 ? arguments[1] : undefined;
	var mapping = mapfn !== undefined;
	var index = 0;
	var iterFn = getIterFn(O);
	var length, result, step, iterator;
	if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
			for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
		createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
			}
	} else {
			length = toLength(O.length);
			for (result = new C(length); length > index; index++) {
		createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
			}
	}
	result.length = index;
	return result;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var anObject = __webpack_require__(5);
module.exports = function (iterator, fn, value, entries) {
  try {
	return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (e) {
	var ret = iterator['return'];
	if (ret !== undefined) anObject(ret.call(iterator));
	throw e;
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(9);
var createDesc = __webpack_require__(35);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(23);
var toObject = __webpack_require__(18);
var IObject = __webpack_require__(51);
var toLength = __webpack_require__(12);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
	if (index in self) {
			memo = self[index];
			index += i;
			break;
	}
	index += i;
	if (isRight ? index < 0 : length <= index) {
			throw TypeError('Reduce of empty array with no initial value');
	}
  }
  for (; isRight ? index >= 0 : length > index; index += i) {
	if (index in self) {
			memo = callbackfn(memo, self[index], index, O);
	}
  }return memo;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(18);
var toAbsoluteIndex = __webpack_require__(37);
var toLength = __webpack_require__(12);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
	inc = -1;
	from += count - 1;
	to += count - 1;
  }
  while (count-- > 0) {
	if (from in O) O[to] = O[from];else delete O[to];
	to += inc;
	from += inc;
  }return O;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var $find = __webpack_require__(26)(6);
var KEY = 'findIndex';
var forced = true;
if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(54)(KEY);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (done, value) {
  return { value: value, done: !!done };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
if (__webpack_require__(11) && /./g.flags != 'g') __webpack_require__(9).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(94)
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(22);
var invoke = __webpack_require__(123);
var html = __webpack_require__(80);
var cel = __webpack_require__(73);
var global = __webpack_require__(4);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function run() {
  var id = +this;
  if (queue.hasOwnProperty(id)) {
	var fn = queue[id];
	delete queue[id];
	fn();
  }
};
var listener = function listener(event) {
  run.call(event.data);
};
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
	var args = [];
	var i = 1;
	while (arguments.length > i) {
			args.push(arguments[i++]);
	}queue[++counter] = function () {
			invoke(typeof fn == 'function' ? fn : Function(fn), args);
	};
	defer(counter);
	return counter;
  };
  clearTask = function clearImmediate(id) {
	delete queue[id];
  };
  if (__webpack_require__(28)(process) == 'process') {
	defer = function defer(id) {
			process.nextTick(ctx(run, id, 1));
	};
  } else if (Dispatch && Dispatch.now) {
	defer = function defer(id) {
			Dispatch.now(ctx(run, id, 1));
	};
  } else if (MessageChannel) {
	channel = new MessageChannel();
	port = channel.port2;
	channel.port1.onmessage = listener;
	defer = ctx(port.postMessage, port, 1);
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
	defer = function defer(id) {
			global.postMessage(id + '', '*');
	};
	global.addEventListener('message', listener, false);
  } else if (ONREADYSTATECHANGE in cel('script')) {
	defer = function defer(id) {
			html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
		html.removeChild(this);
		run.call(id);
			};
	};
  } else {
	defer = function defer(id) {
			setTimeout(ctx(run, id, 1), 0);
	};
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var aFunction = __webpack_require__(23);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
	if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	resolve = $$resolve;
	reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(144);
var validate = __webpack_require__(49);
var MAP = 'Map';
module.exports = __webpack_require__(64)(MAP, function (get) {
  return function Map() {
	return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  get: function get(key) {
	var entry = strong.getEntry(validate(this, MAP), key);
	return entry && entry.v;
  },
  set: function set(key, value) {
	return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(9).f;
var create = __webpack_require__(38);
var redefineAll = __webpack_require__(48);
var ctx = __webpack_require__(22);
var anInstance = __webpack_require__(46);
var forOf = __webpack_require__(47);
var $iterDefine = __webpack_require__(86);
var step = __webpack_require__(139);
var setSpecies = __webpack_require__(45);
var DESCRIPTORS = __webpack_require__(11);
var fastKey = __webpack_require__(33).fastKey;
var validate = __webpack_require__(49);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function getEntry(that, key) {
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  for (entry = that._f; entry; entry = entry.n) {
	if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
	var C = wrapper(function (that, iterable) {
			anInstance(that, C, NAME, '_i');
			that._t = NAME; // collection type
			that._i = create(null); // index
			that._f = undefined; // first entry
			that._l = undefined; // last entry
			that[SIZE] = 0; // size
			if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	});
	redefineAll(C.prototype, {
			clear: function clear() {
		for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
					entry.r = true;
					if (entry.p) entry.p = entry.p.n = undefined;
					delete data[entry.i];
		}
		that._f = that._l = undefined;
		that[SIZE] = 0;
			},
			'delete': function _delete(key) {
		var that = validate(this, NAME);
		var entry = getEntry(that, key);
		if (entry) {
					var next = entry.n;
					var prev = entry.p;
					delete that._i[entry.i];
					entry.r = true;
					if (prev) prev.n = next;
					if (next) next.p = prev;
					if (that._f == entry) that._f = next;
					if (that._l == entry) that._l = prev;
					that[SIZE]--;
		}return !!entry;
			},
			forEach: function forEach(callbackfn /* , that = undefined */) {
		validate(this, NAME);
		var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
		var entry;
		while (entry = entry ? entry.n : this._f) {
					f(entry.v, entry.k, this);
					while (entry && entry.r) {
			entry = entry.p;
					}
		}
			},
			has: function has(key) {
		return !!getEntry(validate(this, NAME), key);
			}
	});
	if (DESCRIPTORS) dP(C.prototype, 'size', {
			get: function get() {
		return validate(this, NAME)[SIZE];
			}
	});
	return C;
  },
  def: function def(that, key, value) {
	var entry = getEntry(that, key);
	var prev, index;
	if (entry) {
			entry.v = value;
	} else {
			that._l = entry = {
		i: index = fastKey(key, true), // <- index
		k: key, // <- key
		v: value, // <- value
		p: prev = that._l, // <- previous entry
		n: undefined, // <- next entry
		r: false // <- removed
			};
			if (!that._f) that._f = entry;
			if (prev) prev.n = entry;
			that[SIZE]++;
			if (index !== 'F') that._i[index] = entry;
	}return that;
  },
  getEntry: getEntry,
  setStrong: function setStrong(C, NAME, IS_MAP) {
	$iterDefine(C, NAME, function (iterated, kind) {
			this._t = validate(iterated, NAME); // target
			this._k = kind; // kind
			this._l = undefined; // previous
	}, function () {
			var that = this;
			var kind = that._k;
			var entry = that._l;
			while (entry && entry.r) {
		entry = entry.p;
			} // get next entry
			if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
		that._t = undefined;
		return step(1);
			}
			if (kind == 'keys') return step(0, entry.k);
			if (kind == 'values') return step(0, entry.v);
			return step(0, [entry.k, entry.v]);
	}, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
	setSpecies(NAME);
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(144);
var validate = __webpack_require__(49);
var SET = 'Set';
module.exports = __webpack_require__(64)(SET, function (get) {
  return function Set() {
	return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  add: function add(value) {
	return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var each = __webpack_require__(26)(0);
var redefine = __webpack_require__(15);
var meta = __webpack_require__(33);
var assign = __webpack_require__(121);
var weak = __webpack_require__(147);
var isObject = __webpack_require__(3);
var fails = __webpack_require__(2);
var validate = __webpack_require__(49);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function wrapper(get) {
  return function WeakMap() {
	return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  get: function get(key) {
	if (isObject(key)) {
			var data = getWeak(key);
			if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
			return data ? data[this._i] : undefined;
	}
  },
  set: function set(key, value) {
	return weak.def(validate(this, WEAK_MAP), key, value);
  }
};
var $WeakMap = module.exports = __webpack_require__(64)(WEAK_MAP, wrapper, methods, weak, true, true);
if (fails(function () {
  return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
})) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
	var proto = $WeakMap.prototype;
	var method = proto[key];
	redefine(proto, key, function (a, b) {
			if (isObject(a) && !isExtensible(a)) {
		if (!this._f) this._f = new InternalMap();
		var result = this._f[key](a, b);
		return key == 'set' ? this : result;
			}return method.call(this, a, b);
	});
  });
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__(48);
var getWeak = __webpack_require__(33).getWeak;
var anObject = __webpack_require__(5);
var isObject = __webpack_require__(3);
var anInstance = __webpack_require__(46);
var forOf = __webpack_require__(47);
var createArrayMethod = __webpack_require__(26);
var $has = __webpack_require__(14);
var validate = __webpack_require__(49);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;
var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.a = [];
};
var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return arrayFind(store.a, function (it) {
	return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function get(key) {
	var entry = findUncaughtFrozen(this, key);
	if (entry) return entry[1];
  },
  has: function has(key) {
	return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
	var entry = findUncaughtFrozen(this, key);
	if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function _delete(key) {
	var index = arrayFindIndex(this.a, function (it) {
			return it[0] === key;
	});
	if (~index) this.a.splice(index, 1);
	return !!~index;
  }
};

module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
	var C = wrapper(function (that, iterable) {
			anInstance(that, C, NAME, '_i');
			that._t = NAME; // collection type
			that._i = id++; // collection id
			that._l = undefined; // leak store for uncaught frozen objects
			if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	});
	redefineAll(C.prototype, {
			'delete': function _delete(key) {
		if (!isObject(key)) return false;
		var data = getWeak(key);
		if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
		return data && $has(data, this._i) && delete data[this._i];
			},
			has: function has(key) {
		if (!isObject(key)) return false;
		var data = getWeak(key);
		if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
		return data && $has(data, this._i);
			}
	});
	return C;
  },
  def: function def(that, key, value) {
	var data = getWeak(anObject(key), true);
	if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
	return that;
  },
  ufstore: uncaughtFrozenStore
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var toInteger = __webpack_require__(29);
var toLength = __webpack_require__(12);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var classof = __webpack_require__(53);
var from = __webpack_require__(317);
module.exports = function (NAME) {
  return function toJSON() {
	if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
	return from(this);
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Syntax = __webpack_require__(50).Syntax;

var Reference = __webpack_require__(100);
var Variable = __webpack_require__(66);
var Definition = __webpack_require__(152).Definition;
function isStrictScope(scope, block, isMethodDefinition, useDirective) {
	var body = void 0;
	if (scope.upper && scope.upper.isStrict) {
		return true;
	}
	if (block.type === Syntax.ArrowFunctionExpression) {
		return true;
	}

	if (isMethodDefinition) {
		return true;
	}

	if (scope.type === "class" || scope.type === "module") {
		return true;
	}

	if (scope.type === "block" || scope.type === "switch") {
		return false;
	}

	if (scope.type === "function") {
		if (block.type === Syntax.Program) {
			body = block;
		} else {
			body = block.body;
		}

		if (!body) {
			return false;
		}
	} else if (scope.type === "global") {
		body = block;
	} else {
		return false;
	}
	if (useDirective) {
		for (var i = 0, iz = body.body.length; i < iz; ++i) {
			var stmt = body.body[i];

			if (stmt.type !== Syntax.DirectiveStatement) {
				break;
			}
			if (stmt.raw === "\"use strict\"" || stmt.raw === "'use strict'") {
				return true;
			}
		}
	} else {
		for (var _i = 0, _iz = body.body.length; _i < _iz; ++_i) {
			var _stmt = body.body[_i];

			if (_stmt.type !== Syntax.ExpressionStatement) {
				break;
			}
			var expr = _stmt.expression;

			if (expr.type !== Syntax.Literal || typeof expr.value !== "string") {
				break;
			}
			if (expr.raw !== null && expr.raw !== undefined) {
				if (expr.raw === "\"use strict\"" || expr.raw === "'use strict'") {
					return true;
				}
			} else {
				if (expr.value === "use strict") {
					return true;
				}
			}
		}
	}
	return false;
}
function registerScope(scopeManager, scope) {
	scopeManager.scopes.push(scope);

	var scopes = scopeManager.__nodeToScope.get(scope.block);

	if (scopes) {
		scopes.push(scope);
	} else {
		scopeManager.__nodeToScope.set(scope.block, [scope]);
	}
}
function shouldBeStatically(def) {
	return def.type === Variable.ClassName || def.type === Variable.Variable && def.parent.kind !== "var";
}

var Scope = function () {
	function Scope(scopeManager, type, upperScope, block, isMethodDefinition) {
		_classCallCheck(this, Scope);
		this.type = type;
		this.set = new Map();
		this.taints = new Map();
		this.dynamic = this.type === "global" || this.type === "with";
		this.block = block;
		this.through = [];
		this.variables = [];
		this.references = [];
		this.variableScope = this.type === "global" || this.type === "function" || this.type === "module" ? this : upperScope.variableScope;
		this.functionExpressionScope = false;
		this.directCallToEvalScope = false;
		this.thisFound = false;

		this.__left = [];
		this.upper = upperScope;
		this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());
		this.childScopes = [];
		if (this.upper) {
			this.upper.childScopes.push(this);
		}

		this.__declaredVariables = scopeManager.__declaredVariables;

		registerScope(scopeManager, this);
	}

	_createClass(Scope, [{
		key: "__shouldStaticallyClose",
		value: function __shouldStaticallyClose(scopeManager) {
			return !this.dynamic || scopeManager.__isOptimistic();
		}
	}, {
		key: "__shouldStaticallyCloseForGlobal",
		value: function __shouldStaticallyCloseForGlobal(ref) {
			var name = ref.identifier.name;

			if (!this.set.has(name)) {
				return false;
			}

			var variable = this.set.get(name);
			var defs = variable.defs;

			return defs.length > 0 && defs.every(shouldBeStatically);
		}
	}, {
		key: "__staticCloseRef",
		value: function __staticCloseRef(ref) {
			if (!this.__resolve(ref)) {
				this.__delegateToUpperScope(ref);
			}
		}
	}, {
		key: "__dynamicCloseRef",
		value: function __dynamicCloseRef(ref) {
			var current = this;

			do {
				current.through.push(ref);
				current = current.upper;
			} while (current);
		}
	}, {
		key: "__globalCloseRef",
		value: function __globalCloseRef(ref) {
			if (this.__shouldStaticallyCloseForGlobal(ref)) {
				this.__staticCloseRef(ref);
			} else {
				this.__dynamicCloseRef(ref);
			}
		}
	}, {
		key: "__close",
		value: function __close(scopeManager) {
			var closeRef = void 0;

			if (this.__shouldStaticallyClose(scopeManager)) {
				closeRef = this.__staticCloseRef;
			} else if (this.type !== "global") {
				closeRef = this.__dynamicCloseRef;
			} else {
				closeRef = this.__globalCloseRef;
			}
			for (var i = 0, iz = this.__left.length; i < iz; ++i) {
				var ref = this.__left[i];

				closeRef.call(this, ref);
			}
			this.__left = null;

			return this.upper;
		}
	}, {
		key: "__resolve",
		value: function __resolve(ref) {
			var name = ref.identifier.name;

			if (this.set.has(name)) {
				var variable = this.set.get(name);

				variable.references.push(ref);
				variable.stack = variable.stack && ref.from.variableScope === this.variableScope;
				if (ref.tainted) {
					variable.tainted = true;
					this.taints.set(variable.name, true);
				}
				ref.resolved = variable;
				return true;
			}
			return false;
		}
	}, {
		key: "__delegateToUpperScope",
		value: function __delegateToUpperScope(ref) {
			if (this.upper) {
				this.upper.__left.push(ref);
			}
			this.through.push(ref);
		}
	}, {
		key: "__addDeclaredVariablesOfNode",
		value: function __addDeclaredVariablesOfNode(variable, node) {
			if (node === null || node === undefined) {
				return;
			}

			var variables = this.__declaredVariables.get(node);

			if (variables === null || variables === undefined) {
				variables = [];
				this.__declaredVariables.set(node, variables);
			}
			if (variables.indexOf(variable) === -1) {
				variables.push(variable);
			}
		}
	}, {
		key: "__defineGeneric",
		value: function __defineGeneric(name, set, variables, node, def) {
			var variable = void 0;

			variable = set.get(name);
			if (!variable) {
				variable = new Variable(name, this);
				set.set(name, variable);
				variables.push(variable);
			}

			if (def) {
				variable.defs.push(def);
				if (def.type !== Variable.TDZ) {
					this.__addDeclaredVariablesOfNode(variable, def.node);
					this.__addDeclaredVariablesOfNode(variable, def.parent);
				}
			}
			if (node) {
				variable.identifiers.push(node);
			}
		}
	}, {
		key: "__define",
		value: function __define(node, def) {
			if (node && node.type === Syntax.Identifier) {
				this.__defineGeneric(node.name, this.set, this.variables, node, def);
			}
		}
	}, {
		key: "__referencing",
		value: function __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
			if (!node || node.type !== Syntax.Identifier) {
				return;
			}
			if (node.name === "super") {
				return;
			}

			var ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);

			this.references.push(ref);
			this.__left.push(ref);
		}
	}, {
		key: "__detectEval",
		value: function __detectEval() {
			var current = this;

			this.directCallToEvalScope = true;
			do {
				current.dynamic = true;
				current = current.upper;
			} while (current);
		}
	}, {
		key: "__detectThis",
		value: function __detectThis() {
			this.thisFound = true;
		}
	}, {
		key: "__isClosed",
		value: function __isClosed() {
			return this.__left === null;
		}

	}, {
		key: "resolve",
		value: function resolve(ident) {
			var ref = void 0,
				i = void 0,
				iz = void 0;

			for (i = 0, iz = this.references.length; i < iz; ++i) {
				ref = this.references[i];
				if (ref.identifier === ident) {
					return ref;
				}
			}
			return null;
		}

	}, {
		key: "isStatic",
		value: function isStatic() {
			return !this.dynamic;
		}

	}, {
		key: "isArgumentsMaterialized",
		value: function isArgumentsMaterialized() {
			return true;
		}

	}, {
		key: "isThisMaterialized",
		value: function isThisMaterialized() {
			return true;
		}
	}, {
		key: "isUsedName",
		value: function isUsedName(name) {
			if (this.set.has(name)) {
				return true;
			}
			for (var i = 0, iz = this.through.length; i < iz; ++i) {
				if (this.through[i].identifier.name === name) {
					return true;
				}
			}
			return false;
		}
	}]);

	return Scope;
}();

var GlobalScope = function (_Scope) {
	_inherits(GlobalScope, _Scope);

	function GlobalScope(scopeManager, block) {
		_classCallCheck(this, GlobalScope);

		var _this = _possibleConstructorReturn(this, (GlobalScope.__proto__ || Object.getPrototypeOf(GlobalScope)).call(this, scopeManager, "global", null, block, false));

		_this.implicit = {
			set: new Map(),
			variables: [],
			left: []
		};
		return _this;
	}

	_createClass(GlobalScope, [{
		key: "__close",
		value: function __close(scopeManager) {
			var implicit = [];

			for (var i = 0, iz = this.__left.length; i < iz; ++i) {
				var ref = this.__left[i];

				if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
					implicit.push(ref.__maybeImplicitGlobal);
				}
			}
			for (var _i2 = 0, _iz2 = implicit.length; _i2 < _iz2; ++_i2) {
				var info = implicit[_i2];

				this.__defineImplicit(info.pattern, new Definition(Variable.ImplicitGlobalVariable, info.pattern, info.node, null, null, null));
			}

			this.implicit.left = this.__left;

			return _get(GlobalScope.prototype.__proto__ || Object.getPrototypeOf(GlobalScope.prototype), "__close", this).call(this, scopeManager);
		}
	}, {
		key: "__defineImplicit",
		value: function __defineImplicit(node, def) {
			if (node && node.type === Syntax.Identifier) {
				this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);
			}
		}
	}]);

	return GlobalScope;
}(Scope);

var ModuleScope = function (_Scope2) {
	_inherits(ModuleScope, _Scope2);

	function ModuleScope(scopeManager, upperScope, block) {
		_classCallCheck(this, ModuleScope);

		return _possibleConstructorReturn(this, (ModuleScope.__proto__ || Object.getPrototypeOf(ModuleScope)).call(this, scopeManager, "module", upperScope, block, false));
	}

	return ModuleScope;
}(Scope);

var FunctionExpressionNameScope = function (_Scope3) {
	_inherits(FunctionExpressionNameScope, _Scope3);

	function FunctionExpressionNameScope(scopeManager, upperScope, block) {
		_classCallCheck(this, FunctionExpressionNameScope);

		var _this3 = _possibleConstructorReturn(this, (FunctionExpressionNameScope.__proto__ || Object.getPrototypeOf(FunctionExpressionNameScope)).call(this, scopeManager, "function-expression-name", upperScope, block, false));

		_this3.__define(block.id, new Definition(Variable.FunctionName, block.id, block, null, null, null));
		_this3.functionExpressionScope = true;
		return _this3;
	}

	return FunctionExpressionNameScope;
}(Scope);

var CatchScope = function (_Scope4) {
	_inherits(CatchScope, _Scope4);

	function CatchScope(scopeManager, upperScope, block) {
		_classCallCheck(this, CatchScope);

		return _possibleConstructorReturn(this, (CatchScope.__proto__ || Object.getPrototypeOf(CatchScope)).call(this, scopeManager, "catch", upperScope, block, false));
	}

	return CatchScope;
}(Scope);

var WithScope = function (_Scope5) {
	_inherits(WithScope, _Scope5);

	function WithScope(scopeManager, upperScope, block) {
		_classCallCheck(this, WithScope);

		return _possibleConstructorReturn(this, (WithScope.__proto__ || Object.getPrototypeOf(WithScope)).call(this, scopeManager, "with", upperScope, block, false));
	}

	_createClass(WithScope, [{
		key: "__close",
		value: function __close(scopeManager) {
			if (this.__shouldStaticallyClose(scopeManager)) {
				return _get(WithScope.prototype.__proto__ || Object.getPrototypeOf(WithScope.prototype), "__close", this).call(this, scopeManager);
			}

			for (var i = 0, iz = this.__left.length; i < iz; ++i) {
				var ref = this.__left[i];

				ref.tainted = true;
				this.__delegateToUpperScope(ref);
			}
			this.__left = null;

			return this.upper;
		}
	}]);

	return WithScope;
}(Scope);

var TDZScope = function (_Scope6) {
	_inherits(TDZScope, _Scope6);

	function TDZScope(scopeManager, upperScope, block) {
		_classCallCheck(this, TDZScope);

		return _possibleConstructorReturn(this, (TDZScope.__proto__ || Object.getPrototypeOf(TDZScope)).call(this, scopeManager, "TDZ", upperScope, block, false));
	}

	return TDZScope;
}(Scope);

var BlockScope = function (_Scope7) {
	_inherits(BlockScope, _Scope7);

	function BlockScope(scopeManager, upperScope, block) {
		_classCallCheck(this, BlockScope);

		return _possibleConstructorReturn(this, (BlockScope.__proto__ || Object.getPrototypeOf(BlockScope)).call(this, scopeManager, "block", upperScope, block, false));
	}

	return BlockScope;
}(Scope);

var SwitchScope = function (_Scope8) {
	_inherits(SwitchScope, _Scope8);

	function SwitchScope(scopeManager, upperScope, block) {
		_classCallCheck(this, SwitchScope);

		return _possibleConstructorReturn(this, (SwitchScope.__proto__ || Object.getPrototypeOf(SwitchScope)).call(this, scopeManager, "switch", upperScope, block, false));
	}

	return SwitchScope;
}(Scope);

var FunctionScope = function (_Scope9) {
	_inherits(FunctionScope, _Scope9);

	function FunctionScope(scopeManager, upperScope, block, isMethodDefinition) {
		_classCallCheck(this, FunctionScope);
		var _this9 = _possibleConstructorReturn(this, (FunctionScope.__proto__ || Object.getPrototypeOf(FunctionScope)).call(this, scopeManager, "function", upperScope, block, isMethodDefinition));

		if (_this9.block.type !== Syntax.ArrowFunctionExpression) {
			_this9.__defineArguments();
		}
		return _this9;
	}

	_createClass(FunctionScope, [{
		key: "isArgumentsMaterialized",
		value: function isArgumentsMaterialized() {
			//
			if (this.block.type === Syntax.ArrowFunctionExpression) {
				return false;
			}

			if (!this.isStatic()) {
				return true;
			}

			var variable = this.set.get("arguments");

			return variable.tainted || variable.references.length !== 0;
		}
	}, {
		key: "isThisMaterialized",
		value: function isThisMaterialized() {
			if (!this.isStatic()) {
				return true;
			}
			return this.thisFound;
		}
	}, {
		key: "__defineArguments",
		value: function __defineArguments() {
			this.__defineGeneric("arguments", this.set, this.variables, null, null);
			this.taints.set("arguments", true);
		}
	}]);

	return FunctionScope;
}(Scope);

var ForScope = function (_Scope10) {
	_inherits(ForScope, _Scope10);

	function ForScope(scopeManager, upperScope, block) {
		_classCallCheck(this, ForScope);

		return _possibleConstructorReturn(this, (ForScope.__proto__ || Object.getPrototypeOf(ForScope)).call(this, scopeManager, "for", upperScope, block, false));
	}

	return ForScope;
}(Scope);

var ClassScope = function (_Scope11) {
	_inherits(ClassScope, _Scope11);

	function ClassScope(scopeManager, upperScope, block) {
		_classCallCheck(this, ClassScope);

		return _possibleConstructorReturn(this, (ClassScope.__proto__ || Object.getPrototypeOf(ClassScope)).call(this, scopeManager, "class", upperScope, block, false));
	}

	return ClassScope;
}(Scope);

module.exports = {
	Scope: Scope,
	GlobalScope: GlobalScope,
	ModuleScope: ModuleScope,
	FunctionExpressionNameScope: FunctionExpressionNameScope,
	CatchScope: CatchScope,
	WithScope: WithScope,
	TDZScope: TDZScope,
	BlockScope: BlockScope,
	SwitchScope: SwitchScope,
	FunctionScope: FunctionScope,
	ForScope: ForScope,
	ClassScope: ClassScope
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Variable = __webpack_require__(66);

var Definition = function Definition(type, name, node, parent, index, kind) {
  _classCallCheck(this, Definition);
  this.type = type;
  this.name = name;
  this.node = node;
  this.parent = parent;
  this.index = index;
  this.kind = kind;
};


var ParameterDefinition = function (_Definition) {
  _inherits(ParameterDefinition, _Definition);

  function ParameterDefinition(name, node, index, rest) {
	_classCallCheck(this, ParameterDefinition);
	var _this = _possibleConstructorReturn(this, (ParameterDefinition.__proto__ || Object.getPrototypeOf(ParameterDefinition)).call(this, Variable.Parameter, name, node, null, index, null));

	_this.rest = rest;
	return _this;
  }

  return ParameterDefinition;
}(Definition);

module.exports = {
  ParameterDefinition: ParameterDefinition,
  Definition: Definition
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
(function () {
	'use strict';

	var assign, estraverse, isArray, objectKeys;

	assign = __webpack_require__(154);
	estraverse = __webpack_require__(50);

	isArray = Array.isArray || function isArray(array) {
		return Object.prototype.toString.call(array) === '[object Array]';
	};

	objectKeys = Object.keys || function (o) {
		var keys = [],
			key;
		for (key in o) {
			keys.push(key);
		}
		return keys;
	};

	function isNode(node) {
		if (node == null) {
			return false;
		}
		return (typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && typeof node.type === 'string';
	}

	function isProperty(nodeType, key) {
		return (nodeType === estraverse.Syntax.ObjectExpression || nodeType === estraverse.Syntax.ObjectPattern) && key === 'properties';
	}

	function Visitor(visitor, options) {
		options = options || {};

		this.__visitor = visitor || this;
		this.__childVisitorKeys = options.childVisitorKeys ? assign({}, estraverse.VisitorKeys, options.childVisitorKeys) : estraverse.VisitorKeys;
		if (options.fallback === 'iteration') {
			this.__fallback = objectKeys;
		} else if (typeof options.fallback === 'function') {
			this.__fallback = options.fallback;
		}
	}
	Visitor.prototype.visitChildren = function (node) {
		var type, children, i, iz, j, jz, child;

		if (node == null) {
			return;
		}

		type = node.type || estraverse.Syntax.Property;

		children = this.__childVisitorKeys[type];
		if (!children) {
			if (this.__fallback) {
				children = this.__fallback(node);
			} else {
				throw new Error('Unknown node type ' + type + '.');
			}
		}

		for (i = 0, iz = children.length; i < iz; ++i) {
			child = node[children[i]];
			if (child) {
				if (isArray(child)) {
					for (j = 0, jz = child.length; j < jz; ++j) {
						if (child[j]) {
							if (isNode(child[j]) || isProperty(type, children[i])) {
								this.visit(child[j]);
							}
						}
					}
				} else if (isNode(child)) {
					this.visit(child);
				}
			}
		}
	};
	Visitor.prototype.visit = function (node) {
		var type;

		if (node == null) {
			return;
		}

		type = node.type || estraverse.Syntax.Property;
		if (this.__visitor[type]) {
			this.__visitor[type].call(this, node);
			return;
		}
		this.visitChildren(node);
	};

	exports.version = __webpack_require__(335).version;
	exports.Visitor = Visitor;
	exports.visit = function (node, visitor, options) {
		var v = new Visitor(visitor, options);
		v.visit(node);
	};
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var Func,
	List,
	Obj,
	Str,
	Num,
	id,
	isType,
	replicate,
	prelude,
	toString$ = {}.toString;
Func = __webpack_require__(340);
List = __webpack_require__(341);
Obj = __webpack_require__(342);
Str = __webpack_require__(343);
Num = __webpack_require__(344);
id = function id(x) {
  return x;
};
isType = curry$(function (type, x) {
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function (n, x) {
  var i$,
			results$ = [];
  for (i$ = 0; i$ < n; ++i$) {
	results$.push(x);
  }
  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.uniqueBy = List.uniqueBy;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.maximumBy = List.maximumBy;
prelude.minimumBy = List.minimumBy;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.at = List.at;
prelude.elemIndex = List.elemIndex;
prelude.elemIndices = List.elemIndices;
prelude.findIndex = List.findIndex;
prelude.findIndices = List.findIndices;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.over = Func.over;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.repeat = Str.repeat;
prelude.capitalize = Str.capitalize;
prelude.camelize = Str.camelize;
prelude.dasherize = Str.dasherize;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.1.2';
module.exports = prelude;
function curry$(f, bound) {
  var context,
			_curry = function _curry(args) {
	return f.length > 1 ? function () {
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
	} : f;
  };
  return _curry();
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
  var VERSION, parseType, parsedTypeCheck, typeCheck;
  VERSION = '0.3.2';
  parseType = __webpack_require__(346);
  parsedTypeCheck = __webpack_require__(347);
  typeCheck = function typeCheck(type, input, options) {
	return parsedTypeCheck(parseType(type), input, options);
  };
  module.exports = {
	VERSION: VERSION,
	typeCheck: typeCheck,
	parsedTypeCheck: parsedTypeCheck,
	parseType: parseType
  };
}).call(undefined);
 }),
 (function(module, exports) {
(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;}.call(exports, {}))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var debug = __webpack_require__(67)("eslint:code-path");
function getId(segment) {
	return segment.id + (segment.reachable ? "" : "!");
}
module.exports = {
	enabled: debug.enabled,
	dump: debug,
	dumpState: !debug.enabled ? debug : /* istanbul ignore next */function (node, state, leaving) {
		for (var i = 0; i < state.currentSegments.length; ++i) {
			var segInternal = state.currentSegments[i].internal;

			if (leaving) {
				segInternal.exitNodes.push(node);
			} else {
				segInternal.nodes.push(node);
			}
		}

		debug([state.currentSegments.map(getId).join(",") + ")", "" + node.type + (leaving ? ":exit" : "")].join(" "));
	},
	dumpDot: !debug.enabled ? debug : /* istanbul ignore next */function (codePath) {
		var text = "\n" + "digraph {\n" + "node[shape=box,style=\"rounded,filled\",fillcolor=white];\n" + "initial[label=\"\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";

		if (codePath.returnedSegments.length > 0) {
			text += "final[label=\"\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
		}
		if (codePath.thrownSegments.length > 0) {
			text += "thrown[label=\"✘\",shape=circle,width=0.3,height=0.3,fixedsize];\n";
		}

		var traceMap = Object.create(null);
		var arrows = this.makeDotArrows(codePath, traceMap);

		for (var id in traceMap) {
			var segment = traceMap[id];

			text += id + "[";

			if (segment.reachable) {
				text += "label=\"";
			} else {
				text += "style=\"rounded,dashed,filled\",fillcolor=\"#FF9800\",label=\"<<unreachable>>\\n";
			}

			if (segment.internal.nodes.length > 0 || segment.internal.exitNodes.length > 0) {
				text += [].concat(segment.internal.nodes.map(function (node) {
					switch (node.type) {
						case "Identifier":
							return node.type + " (" + node.name + ")";
						case "Literal":
							return node.type + " (" + node.value + ")";
						default:
							return node.type;
					}
				}), segment.internal.exitNodes.map(function (node) {
					switch (node.type) {
						case "Identifier":
							return node.type + ":exit (" + node.name + ")";
						case "Literal":
							return node.type + ":exit (" + node.value + ")";
						default:
							return node.type + ":exit";
					}
				})).join("\\n");
			} else {
				text += "????";
			}

			text += "\"];\n";
		}

		text += arrows + "\n";
		text += "}";
		debug("DOT", text);
	},
	makeDotArrows: function makeDotArrows(codePath, traceMap) {
		var stack = [[codePath.initialSegment, 0]];
		var done = traceMap || Object.create(null);
		var lastId = codePath.initialSegment.id;
		var text = "initial->" + codePath.initialSegment.id;

		while (stack.length > 0) {
			var item = stack.pop();
			var segment = item[0];
			var index = item[1];

			if (done[segment.id] && index === 0) {
				continue;
			}
			done[segment.id] = segment;

			var nextSegment = segment.allNextSegments[index];

			if (!nextSegment) {
				continue;
			}

			if (lastId === segment.id) {
				text += "->" + nextSegment.id;
			} else {
				text += ";\n" + segment.id + "->" + nextSegment.id;
			}
			lastId = nextSegment.id;

			stack.unshift([segment, 1 + index]);
			stack.push([nextSegment, 0]);
		}

		codePath.returnedSegments.forEach(function (finalSegment) {
			if (lastId === finalSegment.id) {
				text += "->final";
			} else {
				text += ";\n" + finalSegment.id + "->final";
			}
			lastId = null;
		});

		codePath.thrownSegments.forEach(function (finalSegment) {
			if (lastId === finalSegment.id) {
				text += "->thrown";
			} else {
				text += ";\n" + finalSegment.id + "->thrown";
			}
			lastId = null;
		});

		return text + ";";
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IdGenerator = function () {
  function IdGenerator(prefix) {
	_classCallCheck(this, IdGenerator);

	this.prefix = String(prefix);
	this.n = 0;
  }


  _createClass(IdGenerator, [{
	key: "next",
	value: function next() {
			this.n = 1 + this.n | 0;
			if (this.n < 0) {
		this.n = 1;
			}

			return this.prefix + this.n;
	}
  }]);

  return IdGenerator;
}();

module.exports = IdGenerator;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

(function () {
	'use strict';

	var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
	ES5Regex = {
		NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
		NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
	};

	ES6Regex = {
		NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
		NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};

	function isDecimalDigit(ch) {
		return 0x30 <= ch && ch <= 0x39; // 0..9
	}

	function isHexDigit(ch) {
		return 0x30 <= ch && ch <= 0x39 || // 0..9
		0x61 <= ch && ch <= 0x66 || // a..f
		0x41 <= ch && ch <= 0x46; // A..F
	}

	function isOctalDigit(ch) {
		return ch >= 0x30 && ch <= 0x37; // 0..7
	}
	NON_ASCII_WHITESPACES = [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];

	function isWhiteSpace(ch) {
		return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
	}
	function isLineTerminator(ch) {
		return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
	}
	function fromCodePoint(cp) {
		if (cp <= 0xFFFF) {
			return String.fromCharCode(cp);
		}
		var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
		var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
		return cu1 + cu2;
	}

	IDENTIFIER_START = new Array(0x80);
	for (ch = 0; ch < 0x80; ++ch) {
		IDENTIFIER_START[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
		ch >= 0x41 && ch <= 0x5A || // A..Z
		ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
	}

	IDENTIFIER_PART = new Array(0x80);
	for (ch = 0; ch < 0x80; ++ch) {
		IDENTIFIER_PART[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
		ch >= 0x41 && ch <= 0x5A || // A..Z
		ch >= 0x30 && ch <= 0x39 || // 0..9
		ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
	}

	function isIdentifierStartES5(ch) {
		return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	}

	function isIdentifierPartES5(ch) {
		return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	}

	function isIdentifierStartES6(ch) {
		return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	}

	function isIdentifierPartES6(ch) {
		return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	}

	module.exports = {
		isDecimalDigit: isDecimalDigit,
		isHexDigit: isHexDigit,
		isOctalDigit: isOctalDigit,
		isWhiteSpace: isWhiteSpace,
		isLineTerminator: isLineTerminator,
		isIdentifierStartES5: isIdentifierStartES5,
		isIdentifierPartES5: isIdentifierPartES5,
		isIdentifierStartES6: isIdentifierStartES6,
		isIdentifierPartES6: isIdentifierPartES6
	};
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	AssignmentExpression: "AssignmentExpression",
	AssignmentPattern: "AssignmentPattern",
	ArrayExpression: "ArrayExpression",
	ArrayPattern: "ArrayPattern",
	ArrowFunctionExpression: "ArrowFunctionExpression",
	AwaitExpression: "AwaitExpression",
	BlockStatement: "BlockStatement",
	BinaryExpression: "BinaryExpression",
	BreakStatement: "BreakStatement",
	CallExpression: "CallExpression",
	CatchClause: "CatchClause",
	ClassBody: "ClassBody",
	ClassDeclaration: "ClassDeclaration",
	ClassExpression: "ClassExpression",
	ConditionalExpression: "ConditionalExpression",
	ContinueStatement: "ContinueStatement",
	DoWhileStatement: "DoWhileStatement",
	DebuggerStatement: "DebuggerStatement",
	EmptyStatement: "EmptyStatement",
	ExperimentalRestProperty: "ExperimentalRestProperty",
	ExperimentalSpreadProperty: "ExperimentalSpreadProperty",
	ExpressionStatement: "ExpressionStatement",
	ForStatement: "ForStatement",
	ForInStatement: "ForInStatement",
	ForOfStatement: "ForOfStatement",
	FunctionDeclaration: "FunctionDeclaration",
	FunctionExpression: "FunctionExpression",
	Identifier: "Identifier",
	IfStatement: "IfStatement",
	Literal: "Literal",
	LabeledStatement: "LabeledStatement",
	LogicalExpression: "LogicalExpression",
	MemberExpression: "MemberExpression",
	MetaProperty: "MetaProperty",
	MethodDefinition: "MethodDefinition",
	NewExpression: "NewExpression",
	ObjectExpression: "ObjectExpression",
	ObjectPattern: "ObjectPattern",
	Program: "Program",
	Property: "Property",
	RestElement: "RestElement",
	ReturnStatement: "ReturnStatement",
	SequenceExpression: "SequenceExpression",
	SpreadElement: "SpreadElement",
	Super: "Super",
	SwitchCase: "SwitchCase",
	SwitchStatement: "SwitchStatement",
	TaggedTemplateExpression: "TaggedTemplateExpression",
	TemplateElement: "TemplateElement",
	TemplateLiteral: "TemplateLiteral",
	ThisExpression: "ThisExpression",
	ThrowStatement: "ThrowStatement",
	TryStatement: "TryStatement",
	UnaryExpression: "UnaryExpression",
	UpdateExpression: "UpdateExpression",
	VariableDeclaration: "VariableDeclaration",
	VariableDeclarator: "VariableDeclarator",
	WhileStatement: "WhileStatement",
	WithStatement: "WithStatement",
	YieldExpression: "YieldExpression",
	JSXIdentifier: "JSXIdentifier",
	JSXNamespacedName: "JSXNamespacedName",
	JSXMemberExpression: "JSXMemberExpression",
	JSXEmptyExpression: "JSXEmptyExpression",
	JSXExpressionContainer: "JSXExpressionContainer",
	JSXElement: "JSXElement",
	JSXClosingElement: "JSXClosingElement",
	JSXOpeningElement: "JSXOpeningElement",
	JSXAttribute: "JSXAttribute",
	JSXSpreadAttribute: "JSXSpreadAttribute",
	JSXText: "JSXText",
	ExportDefaultDeclaration: "ExportDefaultDeclaration",
	ExportNamedDeclaration: "ExportNamedDeclaration",
	ExportAllDeclaration: "ExportAllDeclaration",
	ExportSpecifier: "ExportSpecifier",
	ImportDeclaration: "ImportDeclaration",
	ImportSpecifier: "ImportSpecifier",
	ImportDefaultSpecifier: "ImportDefaultSpecifier",
	ImportNamespaceSpecifier: "ImportNamespaceSpecifier"
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(372);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {

var _createClass = function () {
  function defineProperties(target, props) {
	for (var i = 0; i < props.length; i++) {
			var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	}
  }return function (Constructor, protoProps, staticProps) {
	if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
	throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = function () {
  return new IgnoreBase();
};
function make_array(subject) {
  return Array.isArray(subject) ? subject : [subject];
}

var REGEX_BLANK_LINE = /^\s+$/;
var REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\\!/;
var REGEX_LEADING_EXCAPED_HASH = /^\\#/;
var SLASH = '/';
var KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('node-ignore')
: 'node-ignore';

var IgnoreBase = function () {
  function IgnoreBase() {
	_classCallCheck(this, IgnoreBase);

	this._rules = [];
	this[KEY_IGNORE] = true;
	this._initCache();
  }

  _createClass(IgnoreBase, [{
	key: '_initCache',
	value: function _initCache() {
			this._cache = {};
	}
  }, {
	key: 'add',
	value: function add(pattern) {
			this._added = false;

			if (typeof pattern === 'string') {
		pattern = pattern.split(/\r?\n/g);
			}

			make_array(pattern).forEach(this._addPattern, this);
			if (this._added) {
		this._initCache();
			}

			return this;
	}
  }, {
	key: 'addPattern',
	value: function addPattern(pattern) {
			return this.add(pattern);
	}
  }, {
	key: '_addPattern',
	value: function _addPattern(pattern) {
			if (pattern && pattern[KEY_IGNORE]) {
		this._rules = this._rules.concat(pattern._rules);
		this._added = true;
		return;
			}

			if (this._checkPattern(pattern)) {
		var rule = this._createRule(pattern);
		this._added = true;
		this._rules.push(rule);
			}
	}
  }, {
	key: '_checkPattern',
	value: function _checkPattern(pattern) {
			return pattern && typeof pattern === 'string' && !REGEX_BLANK_LINE.test(pattern)
			&& pattern.indexOf('#') !== 0;
	}
  }, {
	key: 'filter',
	value: function filter(paths) {
			var _this = this;

			return make_array(paths).filter(function (path) {
		return _this._filter(path);
			});
	}
  }, {
	key: 'createFilter',
	value: function createFilter() {
			var _this2 = this;

			return function (path) {
		return _this2._filter(path);
			};
	}
  }, {
	key: 'ignores',
	value: function ignores(path) {
			return !this._filter(path);
	}
  }, {
	key: '_createRule',
	value: function _createRule(pattern) {
			var origin = pattern;
			var negative = false;
			if (pattern.indexOf('!') === 0) {
		negative = true;
		pattern = pattern.substr(1);
			}

			pattern = pattern
			.replace(REGEX_LEADING_EXCAPED_EXCLAMATION, '!')
			.replace(REGEX_LEADING_EXCAPED_HASH, '#');

			var regex = make_regex(pattern, negative);

			return {
		origin: origin,
		pattern: pattern,
		negative: negative,
		regex: regex
			};
	}
  }, {
	key: '_filter',
	value: function _filter(path, slices) {
			if (!path) {
		return false;
			}

			if (path in this._cache) {
		return this._cache[path];
			}

			if (!slices) {
		slices = path.split(SLASH);
			}

			slices.pop();

			return this._cache[path] = slices.length
			? this._filter(slices.join(SLASH) + SLASH, slices) && this._test(path)
			: this._test(path);
	}
  }, {
	key: '_test',
	value: function _test(path) {
			var matched = 0;

			this._rules.forEach(function (rule) {
		if (!(matched ^ rule.negative)) {
					matched = rule.negative ^ rule.regex.test(path);
		}
			});

			return !matched;
	}
  }]);

  return IgnoreBase;
}();

var DEFAULT_REPLACER_PREFIX = [
[
/\\?\s+$/, function (match) {
  return match.indexOf('\\') === 0 ? ' ' : '';
}],
[/\\\s/g, function () {
  return ' ';
}],
[/[\\\^$.|?*+()\[{]/g, function (match) {
  return '\\' + match;
}],
[
/^\//, function () {
  return '^';
}],
[/\//g, function () {
  return '\\/';
}], [
/^\^*\\\*\\\*\\\//,
function () {
  return '^(?:.*\\/)?';
}]];

var DEFAULT_REPLACER_SUFFIX = [
[
/^(?=[^\^])/, function () {
  return !/\/(?!$)/.test(this)
  ? '(?:^|\\/)'
  : '^';
}],
[
/\\\/\\\*\\\*(?=\\\/|$)/g,
function (match, index, str) {
  return index + 6 < str.length
  ? '(?:\\/[^\\/]+)*'
  : '\\/.+';
}],
[
/(^|[^\\]+)\\\*(?=.+)/g,
function (match, p1) {
  return p1 + '[^\\/]*';
}],
[/(\^|\\\/)?\\\*$/, function (match, p1) {
  return (p1
  ? p1 + '[^/]+'
  : '[^/]*') + '(?=$|\\/$)';
}], [
/\\\\\\/g, function () {
  return '\\';
}]];

var POSITIVE_REPLACERS = [].concat(DEFAULT_REPLACER_PREFIX, [
[
/(?:[^*\/])$/,
function (match) {
  return match + '(?=$|\\/)';
}]], DEFAULT_REPLACER_SUFFIX);

var NEGATIVE_REPLACERS = [].concat(DEFAULT_REPLACER_PREFIX, [
[/(?:[^*\/])$/, function (match) {
  return match + '(?=$|\\/$)';
}]], DEFAULT_REPLACER_SUFFIX);
var cache = {};
function make_regex(pattern, negative) {
  var r = cache[pattern];
  if (r) {
	return r;
  }

  var replacers = negative ? NEGATIVE_REPLACERS : POSITIVE_REPLACERS;

  var source = replacers.reduce(function (prev, current) {
	return prev.replace(current[0], current[1].bind(pattern));
  }, pattern);

  return cache[pattern] = new RegExp(source, 'i');
}
if (
typeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {

  var filter = IgnoreBase.prototype._filter;
  var make_posix = function make_posix(str) {
	return (/^\\\\\?\\/.test(str) || /[^\x00-\x80]+/.test(str) ? str : str.replace(/\\/g, '/')
	);
  };

  IgnoreBase.prototype._filter = function (path, slices) {
	path = make_posix(path);
	return filter.call(this, path, slices);
  };
}
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

(function () {
	'use strict';

	var typed, utility, jsdoc, esutils, hasOwnProperty;

	esutils = __webpack_require__(68);
	typed = __webpack_require__(646);
	utility = __webpack_require__(165);

	function sliceSource(source, index, last) {
		return source.slice(index, last);
	}

	hasOwnProperty = function () {
		var func = Object.prototype.hasOwnProperty;
		return function hasOwnProperty(obj, name) {
			return func.call(obj, name);
		};
	}();

	function shallowCopy(obj) {
		var ret = {},
			key;
		for (key in obj) {
			if (obj.hasOwnProperty(key)) {
				ret[key] = obj[key];
			}
		}
		return ret;
	}

	function isASCIIAlphanumeric(ch) {
		return ch >= 0x61 /* 'a' */ && ch <= 0x7A /* 'z' */ || ch >= 0x41 /* 'A' */ && ch <= 0x5A /* 'Z' */ || ch >= 0x30 /* '0' */ && ch <= 0x39 /* '9' */;
	}

	function isParamTitle(title) {
		return title === 'param' || title === 'argument' || title === 'arg';
	}

	function isReturnTitle(title) {
		return title === 'return' || title === 'returns';
	}

	function isProperty(title) {
		return title === 'property' || title === 'prop';
	}

	function isNameParameterRequired(title) {
		return isParamTitle(title) || isProperty(title) || title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';
	}

	function isAllowedName(title) {
		return isNameParameterRequired(title) || title === 'const' || title === 'constant';
	}

	function isAllowedNested(title) {
		return isProperty(title) || isParamTitle(title);
	}

	function isAllowedOptional(title) {
		return isProperty(title) || isParamTitle(title);
	}

	function isTypeParameterRequired(title) {
		return isParamTitle(title) || isReturnTitle(title) || title === 'define' || title === 'enum' || title === 'implements' || title === 'this' || title === 'type' || title === 'typedef' || isProperty(title);
	}
	function isAllowedType(title) {
		return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' || title === 'namespace' || title === 'member' || title === 'var' || title === 'module' || title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' || title === 'public' || title === 'private' || title === 'protected';
	}

	function unwrapComment(doc) {
		var BEFORE_STAR = 0,
			STAR = 1,
			AFTER_STAR = 2,
			index,
			len,
			mode,
			result,
			ch;

		doc = doc.replace(/^\/\*\*?/, '').replace(/\*\/$/, '');
		index = 0;
		len = doc.length;
		mode = BEFORE_STAR;
		result = '';

		while (index < len) {
			ch = doc.charCodeAt(index);
			switch (mode) {
				case BEFORE_STAR:
					if (esutils.code.isLineTerminator(ch)) {
						result += String.fromCharCode(ch);
					} else if (ch === 0x2A /* '*' */) {
							mode = STAR;
						} else if (!esutils.code.isWhiteSpace(ch)) {
						result += String.fromCharCode(ch);
						mode = AFTER_STAR;
					}
					break;

				case STAR:
					if (!esutils.code.isWhiteSpace(ch)) {
						result += String.fromCharCode(ch);
					}
					mode = esutils.code.isLineTerminator(ch) ? BEFORE_STAR : AFTER_STAR;
					break;

				case AFTER_STAR:
					result += String.fromCharCode(ch);
					if (esutils.code.isLineTerminator(ch)) {
						mode = BEFORE_STAR;
					}
					break;
			}
			index += 1;
		}

		return result.replace(/\s+$/, '');
	}
	(function (exports) {
		var Rules, index, lineNumber, length, source, recoverable, sloppy, strict;

		function advance() {
			var ch = source.charCodeAt(index);
			index += 1;
			if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D /* '\r' */ && source.charCodeAt(index) === 0x0A /* '\n' */)) {
				lineNumber += 1;
			}
			return String.fromCharCode(ch);
		}

		function scanTitle() {
			var title = '';
			advance();

			while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {
				title += advance();
			}

			return title;
		}

		function seekContent() {
			var ch,
				waiting,
				last = index;

			waiting = false;
			while (last < length) {
				ch = source.charCodeAt(last);
				if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D /* '\r' */ && source.charCodeAt(last + 1) === 0x0A /* '\n' */)) {
					waiting = true;
				} else if (waiting) {
					if (ch === 0x40 /* '@' */) {
							break;
						}
					if (!esutils.code.isWhiteSpace(ch)) {
						waiting = false;
					}
				}
				last += 1;
			}
			return last;
		}
		//
		function parseType(title, last) {
			var ch,
				brace,
				type,
				direct = false;
			while (index < last) {
				ch = source.charCodeAt(index);
				if (esutils.code.isWhiteSpace(ch)) {
					advance();
				} else if (ch === 0x7B /* '{' */) {
						advance();
						break;
					} else {
					direct = true;
					break;
				}
			}

			if (direct) {
				return null;
			}
			brace = 1;
			type = '';
			while (index < last) {
				ch = source.charCodeAt(index);
				if (esutils.code.isLineTerminator(ch)) {
					advance();
				} else {
					if (ch === 0x7D /* '}' */) {
							brace -= 1;
							if (brace === 0) {
								advance();
								break;
							}
						} else if (ch === 0x7B /* '{' */) {
							brace += 1;
						}
					type += advance();
				}
			}

			if (brace !== 0) {
				return utility.throwError('Braces are not balanced');
			}

			if (isAllowedOptional(title)) {
				return typed.parseParamType(type);
			}

			return typed.parseType(type);
		}

		function scanIdentifier(last) {
			var identifier;
			if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {
				return null;
			}
			identifier = advance();
			while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {
				identifier += advance();
			}
			return identifier;
		}

		function skipWhiteSpace(last) {
			while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
				advance();
			}
		}

		function parseName(last, allowBrackets, allowNestedParams) {
			var name = '',
				useBrackets,
				insideString;

			skipWhiteSpace(last);

			if (index >= last) {
				return null;
			}

			if (source.charCodeAt(index) === 0x5B /* '[' */) {
					if (allowBrackets) {
						useBrackets = true;
						name = advance();
					} else {
						return null;
					}
				}

			name += scanIdentifier(last);

			if (allowNestedParams) {
				if (source.charCodeAt(index) === 0x3A /* ':' */ && (name === 'module' || name === 'external' || name === 'event')) {
					name += advance();
					name += scanIdentifier(last);
				}
				if (source.charCodeAt(index) === 0x5B /* '[' */ && source.charCodeAt(index + 1) === 0x5D /* ']' */) {
						name += advance();
						name += advance();
					}
				while (source.charCodeAt(index) === 0x2E /* '.' */ || source.charCodeAt(index) === 0x2F /* '/' */ || source.charCodeAt(index) === 0x23 /* '#' */ || source.charCodeAt(index) === 0x2D /* '-' */ || source.charCodeAt(index) === 0x7E /* '~' */) {
					name += advance();
					name += scanIdentifier(last);
				}
			}

			if (useBrackets) {
				skipWhiteSpace(last);
				if (source.charCodeAt(index) === 0x3D /* '=' */) {
						name += advance();
						skipWhiteSpace(last);

						var ch;
						var bracketDepth = 1;
						while (index < last) {
							ch = source.charCodeAt(index);

							if (esutils.code.isWhiteSpace(ch)) {
								if (!insideString) {
									skipWhiteSpace(last);
									ch = source.charCodeAt(index);
								}
							}

							if (ch === 0x27 /* ''' */) {
									if (!insideString) {
										insideString = '\'';
									} else {
										if (insideString === '\'') {
											insideString = '';
										}
									}
								}

							if (ch === 0x22 /* '"' */) {
									if (!insideString) {
										insideString = '"';
									} else {
										if (insideString === '"') {
											insideString = '';
										}
									}
								}

							if (ch === 0x5B /* '[' */) {
									bracketDepth++;
								} else if (ch === 0x5D /* ']' */ && --bracketDepth === 0) {
								break;
							}

							name += advance();
						}
					}

				skipWhiteSpace(last);

				if (index >= last || source.charCodeAt(index) !== 0x5D /* ']' */) {
						return null;
					}
				name += advance();
			}

			return name;
		}

		function skipToTag() {
			while (index < length && source.charCodeAt(index) !== 0x40 /* '@' */) {
				advance();
			}
			if (index >= length) {
				return false;
			}
			utility.assert(source.charCodeAt(index) === 0x40 /* '@' */);
			return true;
		}

		function TagParser(options, title) {
			this._options = options;
			this._title = title.toLowerCase();
			this._tag = {
				title: title,
				description: null
			};
			if (this._options.lineNumbers) {
				this._tag.lineNumber = lineNumber;
			}
			this._last = 0;
			this._extra = {};
		}
		TagParser.prototype.addError = function addError(errorText) {
			var args = Array.prototype.slice.call(arguments, 1),
				msg = errorText.replace(/%(\d)/g, function (whole, index) {
				utility.assert(index < args.length, 'Message reference must be in range');
				return args[index];
			});

			if (!this._tag.errors) {
				this._tag.errors = [];
			}
			if (strict) {
				utility.throwError(msg);
			}
			this._tag.errors.push(msg);
			return recoverable;
		};

		TagParser.prototype.parseType = function () {
			if (isTypeParameterRequired(this._title)) {
				try {
					this._tag.type = parseType(this._title, this._last);
					if (!this._tag.type) {
						if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {
							if (!this.addError('Missing or invalid tag type')) {
								return false;
							}
						}
					}
				} catch (error) {
					this._tag.type = null;
					if (!this.addError(error.message)) {
						return false;
					}
				}
			} else if (isAllowedType(this._title)) {
				try {
					this._tag.type = parseType(this._title, this._last);
				} catch (e) {
				}
			}
			return true;
		};

		TagParser.prototype._parseNamePath = function (optional) {
			var name;
			name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);
			if (!name) {
				if (!optional) {
					if (!this.addError('Missing or invalid tag name')) {
						return false;
					}
				}
			}
			this._tag.name = name;
			return true;
		};

		TagParser.prototype.parseNamePath = function () {
			return this._parseNamePath(false);
		};

		TagParser.prototype.parseNamePathOptional = function () {
			return this._parseNamePath(true);
		};

		TagParser.prototype.parseName = function () {
			var assign, name;
			if (isAllowedName(this._title)) {
				this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));
				if (!this._tag.name) {
					if (!isNameParameterRequired(this._title)) {
						return true;
					}
					if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {
						this._extra.name = this._tag.type;
						this._tag.name = this._tag.type.name;
						this._tag.type = null;
					} else {
						if (!this.addError('Missing or invalid tag name')) {
							return false;
						}
					}
				} else {
					name = this._tag.name;
					if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {
						assign = name.substring(1, name.length - 1).split('=');
						if (assign.length > 1) {
							this._tag['default'] = assign.slice(1).join('=');
						}
						this._tag.name = assign[0];
						if (this._tag.type && this._tag.type.type !== 'OptionalType') {
							this._tag.type = {
								type: 'OptionalType',
								expression: this._tag.type
							};
						}
					}
				}
			}

			return true;
		};

		TagParser.prototype.parseDescription = function parseDescription() {
			var description = sliceSource(source, index, this._last).trim();
			if (description) {
				if (/^-\s+/.test(description)) {
					description = description.substring(2);
				}
				this._tag.description = description;
			}
			return true;
		};

		TagParser.prototype.parseCaption = function parseDescription() {
			var description = sliceSource(source, index, this._last).trim();
			var captionStartTag = '<caption>';
			var captionEndTag = '</caption>';
			var captionStart = description.indexOf(captionStartTag);
			var captionEnd = description.indexOf(captionEndTag);
			if (captionStart >= 0 && captionEnd >= 0) {
				this._tag.caption = description.substring(captionStart + captionStartTag.length, captionEnd).trim();
				this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();
			} else {
				this._tag.description = description;
			}
			return true;
		};

		TagParser.prototype.parseKind = function parseKind() {
			var kind, kinds;
			kinds = {
				'class': true,
				'constant': true,
				'event': true,
				'external': true,
				'file': true,
				'function': true,
				'member': true,
				'mixin': true,
				'module': true,
				'namespace': true,
				'typedef': true
			};
			kind = sliceSource(source, index, this._last).trim();
			this._tag.kind = kind;
			if (!hasOwnProperty(kinds, kind)) {
				if (!this.addError('Invalid kind name \'%0\'', kind)) {
					return false;
				}
			}
			return true;
		};

		TagParser.prototype.parseAccess = function parseAccess() {
			var access;
			access = sliceSource(source, index, this._last).trim();
			this._tag.access = access;
			if (access !== 'private' && access !== 'protected' && access !== 'public') {
				if (!this.addError('Invalid access name \'%0\'', access)) {
					return false;
				}
			}
			return true;
		};

		TagParser.prototype.parseThis = function parseThis() {
			var value = sliceSource(source, index, this._last).trim();
			if (value && value.charAt(0) === '{') {
				var gotType = this.parseType();
				if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {
					this._tag.name = this._tag.type.name;
					return true;
				} else {
					return this.addError('Invalid name for this');
				}
			} else {
				return this.parseNamePath();
			}
		};

		TagParser.prototype.parseVariation = function parseVariation() {
			var variation, text;
			text = sliceSource(source, index, this._last).trim();
			variation = parseFloat(text, 10);
			this._tag.variation = variation;
			if (isNaN(variation)) {
				if (!this.addError('Invalid variation \'%0\'', text)) {
					return false;
				}
			}
			return true;
		};

		TagParser.prototype.ensureEnd = function () {
			var shouldBeEmpty = sliceSource(source, index, this._last).trim();
			if (shouldBeEmpty) {
				if (!this.addError('Unknown content \'%0\'', shouldBeEmpty)) {
					return false;
				}
			}
			return true;
		};

		TagParser.prototype.epilogue = function epilogue() {
			var description;

			description = this._tag.description;
			if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {
				this._tag.type = this._extra.name;
				if (!this._tag.name) {
					this._tag.name = undefined;
				}

				if (!sloppy) {
					if (!this.addError('Missing or invalid tag name')) {
						return false;
					}
				}
			}

			return true;
		};

		Rules = {
			'access': ['parseAccess'],
			'alias': ['parseNamePath', 'ensureEnd'],
			'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'example': ['parseCaption'],
			'deprecated': ['parseDescription'],
			'global': ['ensureEnd'],
			'inner': ['ensureEnd'],
			'instance': ['ensureEnd'],
			'kind': ['parseKind'],
			'mixes': ['parseNamePath', 'ensureEnd'],
			'mixin': ['parseNamePathOptional', 'ensureEnd'],
			'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'method': ['parseNamePathOptional', 'ensureEnd'],
			'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'func': ['parseNamePathOptional', 'ensureEnd'],
			'function': ['parseNamePathOptional', 'ensureEnd'],
			'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'name': ['parseNamePath', 'ensureEnd'],
			'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'private': ['parseType', 'parseDescription'],
			'protected': ['parseType', 'parseDescription'],
			'public': ['parseType', 'parseDescription'],
			'readonly': ['ensureEnd'],
			'requires': ['parseNamePath', 'ensureEnd'],
			'since': ['parseDescription'],
			'static': ['ensureEnd'],
			'summary': ['parseDescription'],
			'this': ['parseThis', 'ensureEnd'],
			'todo': ['parseDescription'],
			'typedef': ['parseType', 'parseNamePathOptional'],
			'variation': ['parseVariation'],
			'version': ['parseDescription']
		};

		TagParser.prototype.parse = function parse() {
			var i, iz, sequences, method;
			if (!this._title) {
				if (!this.addError('Missing or invalid title')) {
					return null;
				}
			}
			this._last = seekContent(this._title);

			if (hasOwnProperty(Rules, this._title)) {
				sequences = Rules[this._title];
			} else {
				sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];
			}

			for (i = 0, iz = sequences.length; i < iz; ++i) {
				method = sequences[i];
				if (!this[method]()) {
					return null;
				}
			}

			return this._tag;
		};

		function parseTag(options) {
			var title, parser, tag;
			if (!skipToTag()) {
				return null;
			}
			title = scanTitle();
			parser = new TagParser(options, title);
			tag = parser.parse();
			while (index < parser._last) {
				advance();
			}

			return tag;
		}

		//
		//

		function scanJSDocDescription(preserveWhitespace) {
			var description = '',
				ch,
				atAllowed;

			atAllowed = true;
			while (index < length) {
				ch = source.charCodeAt(index);

				if (atAllowed && ch === 0x40 /* '@' */) {
						break;
					}

				if (esutils.code.isLineTerminator(ch)) {
					atAllowed = true;
				} else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {
					atAllowed = false;
				}

				description += advance();
			}

			return preserveWhitespace ? description : description.trim();
		}

		function parse(comment, options) {
			var tags = [],
				tag,
				description,
				interestingTags,
				i,
				iz;

			if (options === undefined) {
				options = {};
			}

			if (typeof options.unwrap === 'boolean' && options.unwrap) {
				source = unwrapComment(comment);
			} else {
				source = comment;
			}
			if (options.tags) {
				if (Array.isArray(options.tags)) {
					interestingTags = {};
					for (i = 0, iz = options.tags.length; i < iz; i++) {
						if (typeof options.tags[i] === 'string') {
							interestingTags[options.tags[i]] = true;
						} else {
							utility.throwError('Invalid "tags" parameter: ' + options.tags);
						}
					}
				} else {
					utility.throwError('Invalid "tags" parameter: ' + options.tags);
				}
			}

			length = source.length;
			index = 0;
			lineNumber = 0;
			recoverable = options.recoverable;
			sloppy = options.sloppy;
			strict = options.strict;

			description = scanJSDocDescription(options.preserveWhitespace);

			while (true) {
				tag = parseTag(options);
				if (!tag) {
					break;
				}
				if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
					tags.push(tag);
				}
			}

			return {
				description: description,
				tags: tags
			};
		}
		exports.parse = parse;
	})(jsdoc = {});

	exports.version = utility.VERSION;
	exports.parse = jsdoc.parse;
	exports.parseType = typed.parseType;
	exports.parseParamType = typed.parseParamType;
	exports.unwrapComment = unwrapComment;
	exports.Syntax = shallowCopy(typed.Syntax);
	exports.Error = utility.DoctrineError;
	exports.type = {
		Syntax: exports.Syntax,
		parseType: typed.parseType,
		parseParamType: typed.parseParamType,
		stringify: typed.stringify
	};
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

(function () {
	'use strict';

	var VERSION;

	VERSION = __webpack_require__(647).version;
	exports.VERSION = VERSION;

	function DoctrineError(message) {
		this.name = 'DoctrineError';
		this.message = message;
	}
	DoctrineError.prototype = function () {
		var Middle = function Middle() {};
		Middle.prototype = Error.prototype;
		return new Middle();
	}();
	DoctrineError.prototype.constructor = DoctrineError;
	exports.DoctrineError = DoctrineError;

	function throwError(message) {
		throw new DoctrineError(message);
	}
	exports.throwError = throwError;

	exports.assert = __webpack_require__(648);
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromLiteral;
function extractValueFromLiteral(value) {
  var extractedValue = value.value;

  var normalizedStringValue = typeof extractedValue === 'string' && extractedValue.toLowerCase();
  if (normalizedStringValue === 'true') {
	return true;
  } else if (normalizedStringValue === 'false') {
	return false;
  }

  return extractedValue;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromJSXElement;
function extractValueFromJSXElement(value) {
  return "<" + value.openingElement.name.name + " />";
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromTemplateLiteral;
function extractValueFromTemplateLiteral(value) {
  var quasis = value.quasis,
			expressions = value.expressions;

  var partitions = quasis.concat(expressions);

  return partitions.sort(function (a, b) {
	return a.start - b.start;
  }).reduce(function (raw, part) {
	var type = part.type;

	if (type === 'TemplateElement') {
			return raw + part.value.raw;
	} else if (type === 'Identifier') {
			return part.name === 'undefined' ? raw : raw + '{' + part.name + '}';
	} else if (type.indexOf('Expression') > -1) {
			return raw + '{' + type + '}';
	}

	return raw;
  }, '');
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(109).propName; // eslint-disable-line import/no-unresolved
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(109).elementType; // eslint-disable-line import/no-unresolved
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function getTokenBeforeClosingBracket(node) {
  var attributes = node.attributes;
  if (attributes.length === 0) {
	return node.name;
  }
  return attributes[attributes.length - 1];
}

module.exports = getTokenBeforeClosingBracket;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(112);

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
	}

	var argIndex = 0;
	var message = 'Warning: ' + format.replace(/%s/g, function () {
			return args[argIndex++];
	});
	if (typeof console !== 'undefined') {
			console.error(message);
	}
	try {
			throw new Error(message);
	} catch (x) {}
  };

  warning = function warning(condition, format) {
	if (format === undefined) {
			throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	}

	if (format.indexOf('Failed Composite propType: ') === 0) {
			return; // Ignore CompositeComponent proptype check.
	}

	if (!condition) {
			for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
		args[_key2 - 2] = arguments[_key2];
			}

			printWarning.apply(undefined, [format].concat(args));
	}
  };
}

module.exports = warning;
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
__webpack_require__(174);
__webpack_require__(312);
__webpack_require__(315);
__webpack_require__(320);
__webpack_require__(321);
__webpack_require__(322);
__webpack_require__(323);
__webpack_require__(327);
__webpack_require__(330);

"use strict";
var eslintScope = __webpack_require__(331),
	levn = __webpack_require__(338),
	lodash = __webpack_require__(10),
	blankScriptAST = __webpack_require__(348),
	defaultConfig = __webpack_require__(349),
	CodePathAnalyzer = __webpack_require__(350),
	ConfigOps = __webpack_require__(365),
	validator = { validateRuleOptions: function validateRuleOptions(x) {
		return x;
	} },
	Environments = __webpack_require__(370),
	applyDisableDirectives = __webpack_require__(373),
	createEmitter = __webpack_require__(374),
	NodeEventGenerator = __webpack_require__(375),
	SourceCode = __webpack_require__(378),
	Traverser = __webpack_require__(106),
	createReportTranslator = __webpack_require__(388),
	Rules = __webpack_require__(390),
	timing = __webpack_require__(754),
	astUtils = __webpack_require__(0),
	pkg = __webpack_require__(755),
	SourceCodeFixer = __webpack_require__(756);

var debug = __webpack_require__(67)("eslint:linter");
var MAX_AUTOFIX_PASSES = 10;
function parseBooleanConfig(string, comment) {
	var items = {};
	string = string.replace(/\s*([:,])\s*/g, "$1");

	string.split(/\s|,+/).forEach(function (name) {
		if (!name) {
			return;
		}
		var pos = name.indexOf(":");
		var value = void 0;

		if (pos !== -1) {
			value = name.slice(pos + 1);
			name = name.slice(0, pos);
		}

		items[name] = {
			value: value === "true",
			comment: comment
		};
	});
	return items;
}
function parseJsonConfig(string, location) {
	var items = {};
	try {
		items = levn.parse("Object", string) || {};
		if (ConfigOps.isEverySeverityValid(items)) {
			return {
				success: true,
				config: items
			};
		}
	} catch (ex) {}
	items = {};
	string = string.replace(/([a-zA-Z0-9\-/]+):/g, "\"$1\":").replace(/(]|[0-9])\s+(?=")/, "$1,");
	try {
		items = JSON.parse('{' + string + '}');
	} catch (ex) {
		return {
			success: false,
			error: {
				ruleId: null,
				fatal: true,
				severity: 2,
				source: null,
				message: 'Failed to parse JSON from \'' + string + '\': ' + ex.message,
				line: location.start.line,
				column: location.start.column + 1
			}
		};
	}

	return {
		success: true,
		config: items
	};
}
function parseListConfig(string) {
	var items = {};
	string = string.replace(/\s*,\s*/g, ",");

	string.split(/,+/).forEach(function (name) {
		name = name.trim();
		if (!name) {
			return;
		}
		items[name] = true;
	});
	return items;
}
function addDeclaredGlobals(globalScope, config, envContext) {
	var declaredGlobals = {},
		exportedGlobals = {},
		explicitGlobals = {},
		builtin = envContext.get("builtin");

	Object.assign(declaredGlobals, builtin);

	Object.keys(config.env).filter(function (name) {
		return config.env[name];
	}).forEach(function (name) {
		var env = envContext.get(name),
			environmentGlobals = env && env.globals;

		if (environmentGlobals) {
			Object.assign(declaredGlobals, environmentGlobals);
		}
	});

	Object.assign(exportedGlobals, config.exported);
	Object.assign(declaredGlobals, config.globals);
	Object.assign(explicitGlobals, config.astGlobals);

	Object.keys(declaredGlobals).forEach(function (name) {
		var variable = globalScope.set.get(name);

		if (!variable) {
			variable = new eslintScope.Variable(name, globalScope);
			variable.eslintExplicitGlobal = false;
			globalScope.variables.push(variable);
			globalScope.set.set(name, variable);
		}
		variable.writeable = declaredGlobals[name];
	});

	Object.keys(explicitGlobals).forEach(function (name) {
		var variable = globalScope.set.get(name);

		if (!variable) {
			variable = new eslintScope.Variable(name, globalScope);
			variable.eslintExplicitGlobal = true;
			variable.eslintExplicitGlobalComment = explicitGlobals[name].comment;
			globalScope.variables.push(variable);
			globalScope.set.set(name, variable);
		}
		variable.writeable = explicitGlobals[name].value;
	});
	Object.keys(exportedGlobals).forEach(function (name) {
		var variable = globalScope.set.get(name);

		if (variable) {
			variable.eslintUsed = true;
		}
	});
	globalScope.through = globalScope.through.filter(function (reference) {
		var name = reference.identifier.name;
		var variable = globalScope.set.get(name);

		if (variable) {
			reference.resolved = variable;
			variable.references.push(reference);

			return false;
		}

		return true;
	});
}
function createDisableDirectives(type, loc, value) {
	var ruleIds = Object.keys(parseListConfig(value));
	var directiveRules = ruleIds.length ? ruleIds : [null];

	return directiveRules.map(function (ruleId) {
		return { type: type, line: loc.line, column: loc.column + 1, ruleId: ruleId };
	});
}
function modifyConfigsFromComments(filename, ast, config, ruleMapper) {

	var commentConfig = {
		exported: {},
		astGlobals: {},
		rules: {},
		env: {}
	};
	var commentRules = {};
	var problems = [];
	var disableDirectives = [];

	ast.comments.filter(function (token) {
		return token.type !== "Shebang";
	}).forEach(function (comment) {

		var value = comment.value.trim();
		var match = /^(eslint(-\w+){0,3}|exported|globals?)(\s|$)/.exec(value);

		if (match) {
			value = value.slice(match.index + match[1].length);

			if (comment.type === "Block") {
				switch (match[1]) {
					case "exported":
						Object.assign(commentConfig.exported, parseBooleanConfig(value, comment));
						break;

					case "globals":
					case "global":
						Object.assign(commentConfig.astGlobals, parseBooleanConfig(value, comment));
						break;

					case "eslint-disable":
						[].push.apply(disableDirectives, createDisableDirectives("disable", comment.loc.start, value));
						break;

					case "eslint-enable":
						[].push.apply(disableDirectives, createDisableDirectives("enable", comment.loc.start, value));
						break;

					case "eslint":
						{
							var parseResult = parseJsonConfig(value, comment.loc);

							if (parseResult.success) {
								Object.keys(parseResult.config).forEach(function (name) {
									var ruleValue = parseResult.config[name];

									validator.validateRuleOptions(ruleMapper(name), name, ruleValue, filename + ' line ' + comment.loc.start.line);
									commentRules[name] = ruleValue;
								});
							} else {
								problems.push(parseResult.error);
							}

							break;
						}
				}
			} else {
				if (match[1] === "eslint-disable-line") {
					[].push.apply(disableDirectives, createDisableDirectives("disable-line", comment.loc.start, value));
				} else if (match[1] === "eslint-disable-next-line") {
					[].push.apply(disableDirectives, createDisableDirectives("disable-next-line", comment.loc.start, value));
				}
			}
		}
	});

	Object.assign(commentConfig.rules, commentRules);

	return {
		config: ConfigOps.merge(config, commentConfig),
		problems: problems,
		disableDirectives: disableDirectives
	};
}
function normalizeEcmaVersion(ecmaVersion, isModule) {
	if (isModule && (!ecmaVersion || ecmaVersion < 6)) {
		ecmaVersion = 6;
	}
	if (ecmaVersion >= 2015) {
		ecmaVersion -= 2009;
	}

	return ecmaVersion;
}
function prepareConfig(config, envContext) {
	config.globals = config.globals || {};
	var copiedRules = {};
	var parserOptions = {};

	if (_typeof(config.rules) === "object") {
		Object.keys(config.rules).forEach(function (k) {
			var rule = config.rules[k];

			if (rule === null) {
				throw new Error('Invalid config for rule \'' + k + '\'.');
			}
			if (Array.isArray(rule)) {
				copiedRules[k] = rule.slice();
			} else {
				copiedRules[k] = rule;
			}
		});
	}
	if (_typeof(config.env) === "object") {
		Object.keys(config.env).forEach(function (envName) {
			var env = envContext.get(envName);

			if (config.env[envName] && env && env.parserOptions) {
				parserOptions = ConfigOps.merge(parserOptions, env.parserOptions);
			}
		});
	}

	var preparedConfig = {
		rules: copiedRules,
		parser: config.parser || defaultConfig.parser,
		globals: ConfigOps.merge(defaultConfig.globals, config.globals),
		env: ConfigOps.merge(defaultConfig.env, config.env || {}),
		settings: ConfigOps.merge(defaultConfig.settings, config.settings || {}),
		parserOptions: ConfigOps.merge(parserOptions, config.parserOptions || {})
	};
	var isModule = preparedConfig.parserOptions.sourceType === "module";

	if (isModule) {
		preparedConfig.parserOptions.ecmaFeatures = Object.assign({}, preparedConfig.parserOptions.ecmaFeatures, { globalReturn: false });
	}

	preparedConfig.parserOptions.ecmaVersion = normalizeEcmaVersion(preparedConfig.parserOptions.ecmaVersion, isModule);

	return preparedConfig;
}

var eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)\*\//g;
function findEslintEnv(text) {
	var match = void 0,
		retv = void 0;

	eslintEnvPattern.lastIndex = 0;

	while (match = eslintEnvPattern.exec(text)) {
		retv = Object.assign(retv || {}, parseListConfig(match[1]));
	}

	return retv;
}
function stripUnicodeBOM(text) {
	if (text.charCodeAt(0) === 0xFEFF) {
		return text.slice(1);
	}
	return text;
}
function getRuleOptions(ruleConfig) {
	if (Array.isArray(ruleConfig)) {
		return ruleConfig.slice(1);
	}
	return [];
}
function parse(text, providedParserOptions, parser, filePath) {

	var parserOptions = Object.assign({}, providedParserOptions, {
		loc: true,
		range: true,
		raw: true,
		tokens: true,
		comment: true,
		filePath: filePath
	});
	try {
		if (typeof parser.parseForESLint === "function") {
			var parseResult = parser.parseForESLint(text, parserOptions);

			return {
				success: true,
				ast: parseResult.ast,
				services: parseResult.services || {}
			};
		}

		return {
			success: true,
			ast: parser.parse(text, parserOptions),
			services: {}
		};
	} catch (ex) {
		var message = 'Parsing error: ' + ex.message.replace(/^line \d+:/i, "").trim();
		var source = ex.lineNumber ? SourceCode.splitLines(text)[ex.lineNumber - 1] : null;

		return {
			success: false,
			error: {
				ruleId: null,
				fatal: true,
				severity: 2,
				source: source,
				message: message,
				line: ex.lineNumber,
				column: ex.column
			}
		};
	}
}
function _getScope(scopeManager, currentNode, ecmaVersion) {
	var initialNode = void 0;
	if (["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(currentNode.type) >= 0 || ecmaVersion >= 6 && ["BlockStatement", "SwitchStatement", "CatchClause"].indexOf(currentNode.type) >= 0) {
		initialNode = currentNode;
	} else {
		initialNode = currentNode.parent;
	}
	for (var node = initialNode; node; node = node.parent) {
		var scope = scopeManager.acquire(node, true);

		if (scope) {
			if (scope.type === "function-expression-name") {
				return scope.childScopes[0];
			}
			return scope;
		}
	}

	return scopeManager.scopes[0];
}
function _markVariableAsUsed(scopeManager, currentNode, parserOptions, name) {
	var hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;
	var specialScope = hasGlobalReturn || parserOptions.sourceType === "module";
	var currentScope = _getScope(scopeManager, currentNode, parserOptions.ecmaVersion);
	var initialScope = currentScope.type === "global" && specialScope ? currentScope.childScopes[0] : currentScope;

	for (var scope = initialScope; scope; scope = scope.upper) {
		var variable = scope.variables.find(function (scopeVar) {
			return scopeVar.name === name;
		});

		if (variable) {
			variable.eslintUsed = true;
			return true;
		}
	}

	return false;
}
var DEPRECATED_SOURCECODE_PASSTHROUGHS = {
	getSource: "getText",
	getSourceLines: "getLines",
	getAllComments: "getAllComments",
	getNodeByRangeIndex: "getNodeByRangeIndex",
	getComments: "getComments",
	getCommentsBefore: "getCommentsBefore",
	getCommentsAfter: "getCommentsAfter",
	getCommentsInside: "getCommentsInside",
	getJSDocComment: "getJSDocComment",
	getFirstToken: "getFirstToken",
	getFirstTokens: "getFirstTokens",
	getLastToken: "getLastToken",
	getLastTokens: "getLastTokens",
	getTokenAfter: "getTokenAfter",
	getTokenBefore: "getTokenBefore",
	getTokenByRangeStart: "getTokenByRangeStart",
	getTokens: "getTokens",
	getTokensAfter: "getTokensAfter",
	getTokensBefore: "getTokensBefore",
	getTokensBetween: "getTokensBetween"
};

var BASE_TRAVERSAL_CONTEXT = Object.freeze(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(function (contextInfo, methodName) {
	return Object.assign(contextInfo, _defineProperty({}, methodName, function () {
		var sourceCode = this.getSourceCode();

		return sourceCode[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]].apply(sourceCode, arguments);
	}));
}, {}));

var lastSourceCodes = new WeakMap();
module.exports = function () {
	function Linter() {
		_classCallCheck(this, Linter);

		lastSourceCodes.set(this, null);
		this.version = pkg.version;

		this.rules = new Rules();
		this._parsers = new Map();
		this.environments = new Environments();
	}


	_createClass(Linter, [{
		key: '_verifyWithoutProcessors',
		value: function _verifyWithoutProcessors(textOrSourceCode, config, filenameOrOptions) {
			var _this = this;

			var text = void 0,
				parserServices = void 0,
				allowInlineConfig = void 0,
				providedFilename = void 0,
				reportUnusedDisableDirectives = void 0;
			if ((typeof filenameOrOptions === 'undefined' ? 'undefined' : _typeof(filenameOrOptions)) === "object") {
				providedFilename = filenameOrOptions.filename;
				allowInlineConfig = filenameOrOptions.allowInlineConfig;
				reportUnusedDisableDirectives = filenameOrOptions.reportUnusedDisableDirectives;
			} else {
				providedFilename = filenameOrOptions;
			}

			var filename = typeof providedFilename === "string" ? providedFilename : "<input>";

			if (typeof textOrSourceCode === "string") {
				lastSourceCodes.set(this, null);
				text = textOrSourceCode;
			} else {
				lastSourceCodes.set(this, textOrSourceCode);
				text = textOrSourceCode.text;
			}
			var envInFile = findEslintEnv(text);

			config = Object.assign({}, config);

			if (envInFile) {
				if (config.env) {
					config.env = Object.assign({}, config.env, envInFile);
				} else {
					config.env = envInFile;
				}
			}
			config = prepareConfig(config, this.environments);

			if (lastSourceCodes.get(this)) {
				parserServices = {};
			} else {
				if (text.trim().length === 0) {
					lastSourceCodes.set(this, new SourceCode(text, blankScriptAST));
					return [];
				}

				var parser = void 0;

				try {
					parser = this._parsers.get(config.parser) || __webpack_require__(69);
				} catch (ex) {
					return [{
						ruleId: null,
						fatal: true,
						severity: 2,
						source: null,
						message: ex.message,
						line: 0,
						column: 0
					}];
				}
				var parseResult = parse(stripUnicodeBOM(text).replace(astUtils.SHEBANG_MATCHER, function (match, captured) {
					return '//' + captured;
				}), config.parserOptions, parser, filename);

				if (!parseResult.success) {
					return [parseResult.error];
				}

				parserServices = parseResult.services;
				lastSourceCodes.set(this, new SourceCode(text, parseResult.ast));
			}

			var problems = [];
			var sourceCode = lastSourceCodes.get(this);
			var disableDirectives = void 0;
			if (allowInlineConfig !== false) {
				var modifyConfigResult = modifyConfigsFromComments(filename, sourceCode.ast, config, function (ruleId) {
					return _this.rules.get(ruleId);
				});

				config = modifyConfigResult.config;
				modifyConfigResult.problems.forEach(function (problem) {
					return problems.push(problem);
				});
				disableDirectives = modifyConfigResult.disableDirectives;
			} else {
				disableDirectives = [];
			}

			var emitter = createEmitter();
			var traverser = new Traverser();
			var ecmaFeatures = config.parserOptions.ecmaFeatures || {};
			var ecmaVersion = config.parserOptions.ecmaVersion || 5;
			var scopeManager = eslintScope.analyze(sourceCode.ast, {
				ignoreEval: true,
				nodejsScope: ecmaFeatures.globalReturn,
				impliedStrict: ecmaFeatures.impliedStrict,
				ecmaVersion: ecmaVersion,
				sourceType: config.parserOptions.sourceType || "script",
				fallback: Traverser.getKeys
			});
			var sharedTraversalContext = Object.freeze(Object.assign(Object.create(BASE_TRAVERSAL_CONTEXT), {
				getAncestors: function getAncestors() {
					return traverser.parents();
				},
				getDeclaredVariables: scopeManager.getDeclaredVariables.bind(scopeManager),
				getFilename: function getFilename() {
					return filename;
				},
				getScope: function getScope() {
					return _getScope(scopeManager, traverser.current(), config.parserOptions.ecmaVersion);
				},
				getSourceCode: function getSourceCode() {
					return sourceCode;
				},
				markVariableAsUsed: function markVariableAsUsed(name) {
					return _markVariableAsUsed(scopeManager, traverser.current(), config.parserOptions, name);
				},
				parserOptions: config.parserOptions,
				parserPath: config.parser,
				parserServices: parserServices,
				settings: config.settings,
				_linter: {
					report: function report() {},

					on: emitter.on
				}
			}));
			Object.keys(config.rules).forEach(function (ruleId) {
				var severity = ConfigOps.getRuleSeverity(config.rules[ruleId]);

				if (severity === 0) {
					return;
				}

				var rule = _this.rules.get(ruleId);
				var reportTranslator = null;
				var ruleContext = Object.freeze(Object.assign(Object.create(sharedTraversalContext), {
					id: ruleId,
					options: getRuleOptions(config.rules[ruleId]),
					report: function report() {
						if (reportTranslator === null) {
							reportTranslator = createReportTranslator({ ruleId: ruleId, severity: severity, sourceCode: sourceCode });
						}
						var problem = reportTranslator.apply(null, arguments);

						if (problem.fix && rule.meta && !rule.meta.fixable) {
							throw new Error("Fixable rules should export a `meta.fixable` property.");
						}
						problems.push(problem);
						sharedTraversalContext._linter.report( // eslint-disable-line no-underscore-dangle
						problem.ruleId, problem.severity, { loc: { start: { line: problem.line, column: problem.column - 1 } } }, problem.message);
					}
				}));

				try {
					var ruleListeners = rule.create(ruleContext);
					Object.keys(ruleListeners).forEach(function (selector) {
						emitter.on(selector, timing.enabled ? timing.time(ruleId, ruleListeners[selector]) : ruleListeners[selector]);
					});
				} catch (ex) {
					ex.message = 'Error while loading rule \'' + ruleId + '\': ' + ex.message;
					throw ex;
				}
			});
			addDeclaredGlobals(scopeManager.scopes[0], config, this.environments);

			var eventGenerator = new CodePathAnalyzer(new NodeEventGenerator(emitter));
			traverser.traverse(sourceCode.ast, {
				enter: function enter(node, parent) {
					node.parent = parent;
					eventGenerator.enterNode(node);
				},
				leave: function leave(node) {
					eventGenerator.leaveNode(node);
				}
			});

			return applyDisableDirectives({
				directives: disableDirectives,
				problems: problems.sort(function (problemA, problemB) {
					return problemA.line - problemB.line || problemA.column - problemB.column;
				}),
				reportUnusedDisableDirectives: reportUnusedDisableDirectives
			});
		}

	}, {
		key: 'verify',
		value: function verify(textOrSourceCode, config, filenameOrOptions) {
			var _this2 = this;

			var preprocess = filenameOrOptions && filenameOrOptions.preprocess || function (rawText) {
				return [rawText];
			};
			var postprocess = filenameOrOptions && filenameOrOptions.postprocess || lodash.flatten;

			return postprocess(preprocess(textOrSourceCode).map(function (textBlock) {
				return _this2._verifyWithoutProcessors(textBlock, config, filenameOrOptions);
			}));
		}

	}, {
		key: 'getSourceCode',
		value: function getSourceCode() {
			return lastSourceCodes.get(this);
		}

	}, {
		key: 'defineRule',
		value: function defineRule(ruleId, ruleModule) {
			this.rules.define(ruleId, ruleModule);
		}

	}, {
		key: 'defineRules',
		value: function defineRules(rulesToDefine) {
			var _this3 = this;

			Object.getOwnPropertyNames(rulesToDefine).forEach(function (ruleId) {
				_this3.defineRule(ruleId, rulesToDefine[ruleId]);
			});
		}

	}, {
		key: 'getRules',
		value: function getRules() {
			return this.rules.getAllLoadedRules();
		}

	}, {
		key: 'defineParser',
		value: function defineParser(parserId, parserModule) {
			this._parsers.set(parserId, parserModule);
		}

	}, {
		key: 'verifyAndFix',
		value: function verifyAndFix(text, config, options) {
			var messages = [],
				fixedResult = void 0,
				fixed = false,
				passNumber = 0;
			var debugTextDescription = options && options.filename || text.slice(0, 10) + '...';
			var shouldFix = options && typeof options.fix !== "undefined" ? options.fix : true;
			do {
				passNumber++;

				debug('Linting code for ' + debugTextDescription + ' (pass ' + passNumber + ')');
				messages = this.verify(text, config, options);

				debug('Generating fixed text for ' + debugTextDescription + ' (pass ' + passNumber + ')');
				fixedResult = SourceCodeFixer.applyFixes(text, messages, shouldFix);
				if (messages.length === 1 && messages[0].fatal) {
					break;
				}
				fixed = fixed || fixedResult.fixed;
				text = fixedResult.output;
			} while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);
			if (fixedResult.fixed) {
				fixedResult.messages = this.verify(text, config, options);
			}
			fixedResult.fixed = fixed;
			fixedResult.output = text;

			return fixedResult;
		}
	}]);

	return Linter;
}();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(115);
__webpack_require__(176);
__webpack_require__(177);
__webpack_require__(178);
__webpack_require__(179);
__webpack_require__(180);
__webpack_require__(181);
__webpack_require__(182);
__webpack_require__(183);
__webpack_require__(184);
__webpack_require__(185);
__webpack_require__(186);
__webpack_require__(187);
__webpack_require__(188);
__webpack_require__(189);
__webpack_require__(190);
__webpack_require__(192);
__webpack_require__(52);
__webpack_require__(193);
__webpack_require__(194);
__webpack_require__(195);
__webpack_require__(196);
__webpack_require__(197);
__webpack_require__(198);
__webpack_require__(199);
__webpack_require__(200);
__webpack_require__(201);
__webpack_require__(202);
__webpack_require__(203);
__webpack_require__(204);
__webpack_require__(205);
__webpack_require__(206);
__webpack_require__(207);
__webpack_require__(208);
__webpack_require__(209);
__webpack_require__(210);
__webpack_require__(211);
__webpack_require__(212);
__webpack_require__(213);
__webpack_require__(214);
__webpack_require__(215);
__webpack_require__(216);
__webpack_require__(217);
__webpack_require__(219);
__webpack_require__(220);
__webpack_require__(221);
__webpack_require__(222);
__webpack_require__(223);
__webpack_require__(224);
__webpack_require__(225);
__webpack_require__(226);
__webpack_require__(227);
__webpack_require__(228);
__webpack_require__(130);
__webpack_require__(229);
__webpack_require__(61);
__webpack_require__(230);
__webpack_require__(231);
__webpack_require__(232);
__webpack_require__(233);
__webpack_require__(234);
__webpack_require__(235);
__webpack_require__(236);
__webpack_require__(237);
__webpack_require__(238);
__webpack_require__(239);
__webpack_require__(240);
__webpack_require__(241);
__webpack_require__(242);
__webpack_require__(243);
__webpack_require__(244);
__webpack_require__(245);
__webpack_require__(246);
__webpack_require__(247);
__webpack_require__(248);
__webpack_require__(249);
__webpack_require__(250);
__webpack_require__(252);
__webpack_require__(253);
__webpack_require__(255);
__webpack_require__(133);
__webpack_require__(256);
__webpack_require__(257);
__webpack_require__(258);
__webpack_require__(259);
__webpack_require__(260);
__webpack_require__(263);
__webpack_require__(264);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(267);
__webpack_require__(268);
__webpack_require__(269);
__webpack_require__(270);
__webpack_require__(271);
__webpack_require__(272);
__webpack_require__(273);
__webpack_require__(138);
__webpack_require__(274);
__webpack_require__(93);
__webpack_require__(275);
__webpack_require__(276);
__webpack_require__(140);
__webpack_require__(277);
__webpack_require__(278);
__webpack_require__(279);
__webpack_require__(280);
__webpack_require__(281);
__webpack_require__(143);
__webpack_require__(145);
__webpack_require__(146);
__webpack_require__(285);
__webpack_require__(286);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(292);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(297);
__webpack_require__(298);
__webpack_require__(299);
__webpack_require__(300);
__webpack_require__(301);
__webpack_require__(302);
__webpack_require__(303);
__webpack_require__(304);
__webpack_require__(305);
__webpack_require__(306);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(310);
__webpack_require__(311);
module.exports = __webpack_require__(13);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var getKeys = __webpack_require__(43);
var gOPS = __webpack_require__(58);
var pIE = __webpack_require__(59);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
	var symbols = getSymbols(it);
	var isEnum = pIE.f;
	var i = 0;
	var key;
	while (symbols.length > i) {
			if (isEnum.call(it, key = symbols[i++])) result.push(key);
	}
  }return result;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
$export($export.S, 'Object', { create: __webpack_require__(38) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
$export($export.S + $export.F * !__webpack_require__(11), 'Object', { defineProperty: __webpack_require__(9).f });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
$export($export.S + $export.F * !__webpack_require__(11), 'Object', { defineProperties: __webpack_require__(119) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var toIObject = __webpack_require__(24);
var $getOwnPropertyDescriptor = __webpack_require__(30).f;

__webpack_require__(25)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
	return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var toObject = __webpack_require__(18);
var $getPrototypeOf = __webpack_require__(40);

__webpack_require__(25)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
	return $getPrototypeOf(toObject(it));
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var toObject = __webpack_require__(18);
var $keys = __webpack_require__(43);

__webpack_require__(25)('keys', function () {
  return function keys(it) {
	return $keys(toObject(it));
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(25)('getOwnPropertyNames', function () {
  return __webpack_require__(120).f;
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
var meta = __webpack_require__(33).onFreeze;

__webpack_require__(25)('freeze', function ($freeze) {
  return function freeze(it) {
	return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
var meta = __webpack_require__(33).onFreeze;

__webpack_require__(25)('seal', function ($seal) {
  return function seal(it) {
	return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
var meta = __webpack_require__(33).onFreeze;

__webpack_require__(25)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
	return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);

__webpack_require__(25)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
	return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);

__webpack_require__(25)('isSealed', function ($isSealed) {
  return function isSealed(it) {
	return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);

__webpack_require__(25)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
	return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(121) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
$export($export.S, 'Object', { is: __webpack_require__(191) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = Object.is || function is(x, y) {
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(81).set });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.P, 'Function', { bind: __webpack_require__(122) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(9).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';
NAME in FProto || __webpack_require__(11) && dP(FProto, NAME, {
  configurable: true,
  get: function get() {
	try {
			return ('' + this).match(nameRE)[1];
	} catch (e) {
			return '';
	}
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(3);
var getPrototypeOf = __webpack_require__(40);
var HAS_INSTANCE = __webpack_require__(6)('hasInstance');
var FunctionProto = Function.prototype;
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(9).f(FunctionProto, HAS_INSTANCE, { value: function value(O) {
	if (typeof this != 'function' || !isObject(O)) return false;
	if (!isObject(this.prototype)) return O instanceof this;
	while (O = getPrototypeOf(O)) {
			if (this.prototype === O) return true;
	}return false;
  } });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $parseInt = __webpack_require__(124);
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $parseFloat = __webpack_require__(125);
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var has = __webpack_require__(14);
var cof = __webpack_require__(28);
var inheritIfRequired = __webpack_require__(83);
var toPrimitive = __webpack_require__(32);
var fails = __webpack_require__(2);
var gOPN = __webpack_require__(39).f;
var gOPD = __webpack_require__(30).f;
var dP = __webpack_require__(9).f;
var $trim = __webpack_require__(60).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
var BROKEN_COF = cof(__webpack_require__(38)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;
var toNumber = function toNumber(argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
	it = TRIM ? it.trim() : $trim(it, 3);
	var first = it.charCodeAt(0);
	var third, radix, maxCode;
	if (first === 43 || first === 45) {
			third = it.charCodeAt(2);
			if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	} else if (first === 48) {
			switch (it.charCodeAt(1)) {
		case 66:case 98:
					radix = 2;maxCode = 49;break; // fast equal /^0b[01]+$/i
		case 79:case 111:
					radix = 8;maxCode = 55;break; // fast equal /^0o[0-7]+$/i
		default:
					return +it;
			}
			for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
		code = digits.charCodeAt(i);
		if (code < 48 || code > maxCode) return NaN;
			}return parseInt(digits, radix);
	}
  }return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
	var it = arguments.length < 1 ? 0 : value;
	var that = this;
	return that instanceof $Number
	&& (BROKEN_COF ? fails(function () {
			proto.valueOf.call(that);
	}) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(11) ? gOPN(Base) : (
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
	if (has(Base, key = keys[j]) && !has($Number, key)) {
			dP($Number, key, gOPD(Base, key));
	}
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(15)(global, NUMBER, $Number);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toInteger = __webpack_require__(29);
var aNumberValue = __webpack_require__(126);
var repeat = __webpack_require__(127);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function multiply(n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
	c2 += n * data[i];
	data[i] = c2 % 1e7;
	c2 = floor(c2 / 1e7);
  }
};
var divide = function divide(n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
	c += data[i];
	data[i] = floor(c / n);
	c = c % n * 1e7;
  }
};
var numToString = function numToString() {
  var i = 6;
  var s = '';
  while (--i >= 0) {
	if (s !== '' || i === 0 || data[i] !== 0) {
			var t = String(data[i]);
			s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	}
  }return s;
};
var pow = function pow(x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function log(x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
	n += 12;
	x2 /= 4096;
  }
  while (x2 >= 2) {
	n += 1;
	x2 /= 2;
  }return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__(2)(function () {
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
	var x = aNumberValue(this, ERROR);
	var f = toInteger(fractionDigits);
	var s = '';
	var m = ZERO;
	var e, z, j, k;
	if (f < 0 || f > 20) throw RangeError(ERROR);
	if (x != x) return 'NaN';
	if (x <= -1e21 || x >= 1e21) return String(x);
	if (x < 0) {
			s = '-';
			x = -x;
	}
	if (x > 1e-21) {
			e = log(x * pow(2, 69, 1)) - 69;
			z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
			z *= 0x10000000000000;
			e = 52 - e;
			if (e > 0) {
		multiply(0, z);
		j = f;
		while (j >= 7) {
					multiply(1e7, 0);
					j -= 7;
		}
		multiply(pow(10, j, 1), 0);
		j = e - 1;
		while (j >= 23) {
					divide(1 << 23);
					j -= 23;
		}
		divide(1 << j);
		multiply(1, 1);
		divide(2);
		m = numToString();
			} else {
		multiply(0, z);
		multiply(1 << -e, 0);
		m = numToString() + repeat.call(ZERO, f);
			}
	}
	if (f > 0) {
			k = m.length;
			m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	} else {
			m = s + m;
	}return m;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $fails = __webpack_require__(2);
var aNumberValue = __webpack_require__(126);
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
	var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var _isFinite = __webpack_require__(4).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
	return typeof it == 'number' && _isFinite(it);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Number', { isInteger: __webpack_require__(128) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
	return number != number;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var isInteger = __webpack_require__(128);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
	return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $parseFloat = __webpack_require__(125);
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $parseInt = __webpack_require__(124);
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var log1p = __webpack_require__(129);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
&& Math.floor($acosh(Number.MAX_VALUE)) == 710
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
	return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var $atanh = Math.atanh;
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
	return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var sign = __webpack_require__(84);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
	return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
	return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
	return (exp(x = +x) + exp(-x)) / 2;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var $expm1 = __webpack_require__(85);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', { fround: __webpack_require__(218) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var sign = __webpack_require__(84);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function roundTiesToEven(n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
	var sum = 0;
	var i = 0;
	var aLen = arguments.length;
	var larg = 0;
	var arg, div;
	while (i < aLen) {
			arg = abs(arguments[i++]);
			if (larg < arg) {
		div = larg / arg;
		sum = sum * div * div + 1;
		larg = arg;
			} else if (arg > 0) {
		div = arg / larg;
		sum += div * div;
			} else sum += arg;
	}
	return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var $imul = Math.imul;
$export($export.S + $export.F * __webpack_require__(2)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
	var UINT16 = 0xffff;
	var xn = +x;
	var yn = +y;
	var xl = UINT16 & xn;
	var yl = UINT16 & yn;
	return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  log10: function log10(x) {
	return Math.log(x) * Math.LOG10E;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', { log1p: __webpack_require__(129) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  log2: function log2(x) {
	return Math.log(x) / Math.LN2;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', { sign: __webpack_require__(84) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var expm1 = __webpack_require__(85);
var exp = Math.exp;
$export($export.S + $export.F * __webpack_require__(2)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
	return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var expm1 = __webpack_require__(85);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
	var a = expm1(x = +x);
	var b = expm1(-x);
	return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
	return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toAbsoluteIndex = __webpack_require__(37);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  fromCodePoint: function fromCodePoint(x) {
	var res = [];
	var aLen = arguments.length;
	var i = 0;
	var code;
	while (aLen > i) {
			code = +arguments[i++];
			if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
			res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
	}return res.join('');
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(60)('trim', function ($trim) {
  return function trim() {
	return $trim(this, 3);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $at = __webpack_require__(131)(false);
$export($export.P, 'String', {
  codePointAt: function codePointAt(pos) {
	return $at(this, pos);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(1);
var toLength = __webpack_require__(12);
var context = __webpack_require__(87);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(89)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	var that = context(this, searchString, ENDS_WITH);
	var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	var len = toLength(that.length);
	var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
	var search = String(searchString);
	return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(1);
var context = __webpack_require__(87);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(89)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
	return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

$export($export.P, 'String', {
  repeat: __webpack_require__(127)
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(1);
var toLength = __webpack_require__(12);
var context = __webpack_require__(87);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(89)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
	var that = context(this, searchString, STARTS_WITH);
	var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	var search = String(searchString);
	return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('anchor', function (createHTML) {
  return function anchor(name) {
	return createHTML(this, 'a', 'name', name);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('big', function (createHTML) {
  return function big() {
	return createHTML(this, 'big', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('blink', function (createHTML) {
  return function blink() {
	return createHTML(this, 'blink', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('bold', function (createHTML) {
  return function bold() {
	return createHTML(this, 'b', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('fixed', function (createHTML) {
  return function fixed() {
	return createHTML(this, 'tt', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
	return createHTML(this, 'font', 'color', color);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('fontsize', function (createHTML) {
  return function fontsize(size) {
	return createHTML(this, 'font', 'size', size);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('italics', function (createHTML) {
  return function italics() {
	return createHTML(this, 'i', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('link', function (createHTML) {
  return function link(url) {
	return createHTML(this, 'a', 'href', url);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('small', function (createHTML) {
  return function small() {
	return createHTML(this, 'small', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('strike', function (createHTML) {
  return function strike() {
	return createHTML(this, 'strike', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('sub', function (createHTML) {
  return function sub() {
	return createHTML(this, 'sub', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('sup', function (createHTML) {
  return function sup() {
	return createHTML(this, 'sup', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Date', { now: function now() {
	return new Date().getTime();
  } });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toObject = __webpack_require__(18);
var toPrimitive = __webpack_require__(32);

$export($export.P + $export.F * __webpack_require__(2)(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function toISOString() {
			return 1;
	} }) !== 1;
}), 'Date', {
  toJSON: function toJSON(key) {
	var O = toObject(this);
	var pv = toPrimitive(O);
	return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var toISOString = __webpack_require__(251);
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var fails = __webpack_require__(2);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function lz(num) {
  return num > 9 ? num : '0' + num;
};
module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(15)(DateProto, TO_STRING, function toString() {
	var value = getTime.call(this);
	return value === value ? $toString.call(this) : INVALID_DATE;
  });
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var TO_PRIMITIVE = __webpack_require__(6)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(17)(proto, TO_PRIMITIVE, __webpack_require__(254));
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(5);
var toPrimitive = __webpack_require__(32);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Array', { isArray: __webpack_require__(79) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var createProperty = __webpack_require__(135);
$export($export.S + $export.F * __webpack_require__(2)(function () {
  function F() {/* empty */}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  of: function of() /* ...args */{
	var index = 0;
	var aLen = arguments.length;
	var result = new (typeof this == 'function' ? this : Array)(aLen);
	while (aLen > index) {
			createProperty(result, index, arguments[index++]);
	}result.length = aLen;
	return result;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var toIObject = __webpack_require__(24);
var arrayJoin = [].join;
$export($export.P + $export.F * (__webpack_require__(51) != Object || !__webpack_require__(19)(arrayJoin)), 'Array', {
  join: function join(separator) {
	return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var html = __webpack_require__(80);
var cof = __webpack_require__(28);
var toAbsoluteIndex = __webpack_require__(37);
var toLength = __webpack_require__(12);
var arraySlice = [].slice;
$export($export.P + $export.F * __webpack_require__(2)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
	var len = toLength(this.length);
	var klass = cof(this);
	end = end === undefined ? len : end;
	if (klass == 'Array') return arraySlice.call(this, begin, end);
	var start = toAbsoluteIndex(begin, len);
	var upTo = toAbsoluteIndex(end, len);
	var size = toLength(upTo - start);
	var cloned = new Array(size);
	var i = 0;
	for (; i < size; i++) {
			cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
	}return cloned;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var aFunction = __webpack_require__(23);
var toObject = __webpack_require__(18);
var fails = __webpack_require__(2);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  test.sort(undefined);
}) || !fails(function () {
  test.sort(null);
}) || !__webpack_require__(19)($sort)), 'Array', {
  sort: function sort(comparefn) {
	return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $forEach = __webpack_require__(26)(0);
var STRICT = __webpack_require__(19)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  forEach: function forEach(callbackfn /* , thisArg */) {
	return $forEach(this, callbackfn, arguments[1]);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var speciesConstructor = __webpack_require__(262);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(3);
var isArray = __webpack_require__(79);
var SPECIES = __webpack_require__(6)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
	C = original.constructor;
	if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	if (isObject(C)) {
			C = C[SPECIES];
			if (C === null) C = undefined;
	}
  }return C === undefined ? Array : C;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $map = __webpack_require__(26)(1);

$export($export.P + $export.F * !__webpack_require__(19)([].map, true), 'Array', {
  map: function map(callbackfn /* , thisArg */) {
	return $map(this, callbackfn, arguments[1]);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $filter = __webpack_require__(26)(2);

$export($export.P + $export.F * !__webpack_require__(19)([].filter, true), 'Array', {
  filter: function filter(callbackfn /* , thisArg */) {
	return $filter(this, callbackfn, arguments[1]);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $some = __webpack_require__(26)(3);

$export($export.P + $export.F * !__webpack_require__(19)([].some, true), 'Array', {
  some: function some(callbackfn /* , thisArg */) {
	return $some(this, callbackfn, arguments[1]);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $every = __webpack_require__(26)(4);

$export($export.P + $export.F * !__webpack_require__(19)([].every, true), 'Array', {
  every: function every(callbackfn /* , thisArg */) {
	return $every(this, callbackfn, arguments[1]);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $reduce = __webpack_require__(136);

$export($export.P + $export.F * !__webpack_require__(19)([].reduce, true), 'Array', {
  reduce: function reduce(callbackfn /* , initialValue */) {
	return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $reduce = __webpack_require__(136);

$export($export.P + $export.F * !__webpack_require__(19)([].reduceRight, true), 'Array', {
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $indexOf = __webpack_require__(76)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(19)($native)), 'Array', {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	return NEGATIVE_ZERO
	? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toIObject = __webpack_require__(24);
var toInteger = __webpack_require__(29);
var toLength = __webpack_require__(12);
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(19)($native)), 'Array', {
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
	var O = toIObject(this);
	var length = toLength(O.length);
	var index = length - 1;
	if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
	if (index < 0) index = length + index;
	for (; index >= 0; index--) {
			if (index in O) if (O[index] === searchElement) return index || 0;
	}return -1;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.P, 'Array', { copyWithin: __webpack_require__(137) });

__webpack_require__(54)('copyWithin');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.P, 'Array', { fill: __webpack_require__(92) });

__webpack_require__(54)('fill');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var $find = __webpack_require__(26)(5);
var KEY = 'find';
var forced = true;
if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
	return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(54)(KEY);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(45)('Array');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var inheritIfRequired = __webpack_require__(83);
var dP = __webpack_require__(9).f;
var gOPN = __webpack_require__(39).f;
var isRegExp = __webpack_require__(88);
var $flags = __webpack_require__(94);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(11) && (!CORRECT_NEW || __webpack_require__(2)(function () {
  re2[__webpack_require__(6)('match')] = false;
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
	var tiRE = this instanceof $RegExp;
	var piRE = isRegExp(p);
	var fiU = f === undefined;
	return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };
  var proxy = function proxy(key) {
	key in $RegExp || dP($RegExp, key, {
			configurable: true,
			get: function get() {
		return Base[key];
			},
			set: function set(it) {
		Base[key] = it;
			}
	});
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) {
	proxy(keys[i++]);
  }proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(15)(global, 'RegExp', $RegExp);
}

__webpack_require__(45)('RegExp');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(140);
var anObject = __webpack_require__(5);
var $flags = __webpack_require__(94);
var DESCRIPTORS = __webpack_require__(11);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function define(fn) {
  __webpack_require__(15)(RegExp.prototype, TO_STRING, fn, true);
};
if (__webpack_require__(2)(function () {
  return $toString.call({ source: 'a', flags: 'b' }) != '/a/b';
})) {
  define(function toString() {
	var R = anObject(this);
	return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
} else if ($toString.name != TO_STRING) {
  define(function toString() {
	return $toString.call(this);
  });
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(63)('match', 1, function (defined, MATCH, $match) {
  return [function match(regexp) {
	'use strict';

	var O = defined(this);
	var fn = regexp == undefined ? undefined : regexp[MATCH];
	return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(63)('replace', 2, function (defined, REPLACE, $replace) {
  return [function replace(searchValue, replaceValue) {
	'use strict';

	var O = defined(this);
	var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(63)('search', 1, function (defined, SEARCH, $search) {
  return [function search(regexp) {
	'use strict';

	var O = defined(this);
	var fn = regexp == undefined ? undefined : regexp[SEARCH];
	return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(63)('split', 2, function (defined, SPLIT, $split) {
  'use strict';

  var isRegExp = __webpack_require__(88);
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
	var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	$split = function $split(separator, limit) {
			var string = String(this);
			if (separator === undefined && limit === 0) return [];
			if (!isRegExp(separator)) return _split.call(string, separator, limit);
			var output = [];
			var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
			var lastLastIndex = 0;
			var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
			var separatorCopy = new RegExp(separator.source, flags + 'g');
			var separator2, match, lastIndex, lastLength, i;
			if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
			while (match = separatorCopy.exec(string)) {
		lastIndex = match.index + match[0][LENGTH];
		if (lastIndex > lastLastIndex) {
					output.push(string.slice(lastLastIndex, match.index));
					if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
			for (i = 1; i < arguments[LENGTH] - 2; i++) {
							if (arguments[i] === undefined) match[i] = undefined;
			}
					});
					if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
					lastLength = match[0][LENGTH];
					lastLastIndex = lastIndex;
					if (output[LENGTH] >= splitLimit) break;
		}
		if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
			}
			if (lastLastIndex === string[LENGTH]) {
		if (lastLength || !separatorCopy.test('')) output.push('');
			} else output.push(string.slice(lastLastIndex));
			return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	};
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	$split = function $split(separator, limit) {
			return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	};
  }
  return [function split(separator, limit) {
	var O = defined(this);
	var fn = separator == undefined ? undefined : separator[SPLIT];
	return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(42);
var global = __webpack_require__(4);
var ctx = __webpack_require__(22);
var classof = __webpack_require__(53);
var $export = __webpack_require__(1);
var isObject = __webpack_require__(3);
var aFunction = __webpack_require__(23);
var anInstance = __webpack_require__(46);
var forOf = __webpack_require__(47);
var speciesConstructor = __webpack_require__(95);
var task = __webpack_require__(141).set;
var microtask = __webpack_require__(282)();
var newPromiseCapabilityModule = __webpack_require__(142);
var perform = __webpack_require__(283);
var promiseResolve = __webpack_require__(284);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function empty() {/* empty */};
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
	var promise = $Promise.resolve(1);
	var FakePromise = (promise.constructor = {})[__webpack_require__(6)('species')] = function (exec) {
			exec(empty, empty);
	};
	return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) {/* empty */}
}();
var isThenable = function isThenable(it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function notify(promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
	var value = promise._v;
	var ok = promise._s == 1;
	var i = 0;
	var run = function run(reaction) {
			var handler = ok ? reaction.ok : reaction.fail;
			var resolve = reaction.resolve;
			var reject = reaction.reject;
			var domain = reaction.domain;
			var result, then;
			try {
		if (handler) {
					if (!ok) {
			if (promise._h == 2) onHandleUnhandled(promise);
			promise._h = 1;
					}
					if (handler === true) result = value;else {
			if (domain) domain.enter();
			result = handler(value);
			if (domain) domain.exit();
					}
					if (result === reaction.promise) {
			reject(TypeError('Promise-chain cycle'));
					} else if (then = isThenable(result)) {
			then.call(result, resolve, reject);
					} else resolve(result);
		} else reject(value);
			} catch (e) {
		reject(e);
			}
	};
	while (chain.length > i) {
			run(chain[i++]);
	} // variable length - can't use forEach
	promise._c = [];
	promise._n = false;
	if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function onUnhandled(promise) {
  task.call(global, function () {
	var value = promise._v;
	var unhandled = isUnhandled(promise);
	var result, handler, console;
	if (unhandled) {
			result = perform(function () {
		if (isNode) {
					process.emit('unhandledRejection', value, promise);
		} else if (handler = global.onunhandledrejection) {
					handler({ promise: promise, reason: value });
		} else if ((console = global.console) && console.error) {
					console.error('Unhandled promise rejection', value);
		}
			});
			promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	}promise._a = undefined;
	if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function isUnhandled(promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function onHandleUnhandled(promise) {
  task.call(global, function () {
	var handler;
	if (isNode) {
			process.emit('rejectionHandled', promise);
	} else if (handler = global.onrejectionhandled) {
			handler({ promise: promise, reason: promise._v });
	}
  });
};
var $reject = function $reject(value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function $resolve(value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
	if (promise === value) throw TypeError("Promise can't be resolved itself");
	if (then = isThenable(value)) {
			microtask(function () {
		var wrapper = { _w: promise, _d: false }; // wrap
		try {
					then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
		} catch (e) {
					$reject.call(wrapper, e);
		}
			});
	} else {
			promise._v = value;
			promise._s = 1;
			notify(promise, false);
	}
  } catch (e) {
	$reject.call({ _w: promise, _d: false }, e); // wrap
  }
};
if (!USE_NATIVE) {
  $Promise = function Promise(executor) {
	anInstance(this, $Promise, PROMISE, '_h');
	aFunction(executor);
	Internal.call(this);
	try {
			executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	} catch (err) {
			$reject.call(this, err);
	}
  };
  Internal = function Promise(executor) {
	this._c = []; // <- awaiting reactions
	this._a = undefined; // <- checked in isUnhandled reactions
	this._s = 0; // <- state
	this._d = false; // <- done
	this._v = undefined; // <- value
	this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	this._n = false; // <- notify
  };
  Internal.prototype = __webpack_require__(48)($Promise.prototype, {
	then: function then(onFulfilled, onRejected) {
			var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
			reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
			reaction.fail = typeof onRejected == 'function' && onRejected;
			reaction.domain = isNode ? process.domain : undefined;
			this._c.push(reaction);
			if (this._a) this._a.push(reaction);
			if (this._s) notify(this, false);
			return reaction.promise;
	},
	'catch': function _catch(onRejected) {
			return this.then(undefined, onRejected);
	}
  });
  OwnPromiseCapability = function OwnPromiseCapability() {
	var promise = new Internal();
	this.promise = promise;
	this.resolve = ctx($resolve, promise, 1);
	this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
	return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(41)($Promise, PROMISE);
__webpack_require__(45)(PROMISE);
Wrapper = __webpack_require__(13)[PROMISE];
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  reject: function reject(r) {
	var capability = newPromiseCapability(this);
	var $$reject = capability.reject;
	$$reject(r);
	return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  resolve: function resolve(x) {
	return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(62)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  all: function all(iterable) {
	var C = this;
	var capability = newPromiseCapability(C);
	var resolve = capability.resolve;
	var reject = capability.reject;
	var result = perform(function () {
			var values = [];
			var index = 0;
			var remaining = 1;
			forOf(iterable, false, function (promise) {
		var $index = index++;
		var alreadyCalled = false;
		values.push(undefined);
		remaining++;
		C.resolve(promise).then(function (value) {
					if (alreadyCalled) return;
					alreadyCalled = true;
					values[$index] = value;
					--remaining || resolve(values);
		}, reject);
			});
			--remaining || resolve(values);
	});
	if (result.e) reject(result.v);
	return capability.promise;
  },
  race: function race(iterable) {
	var C = this;
	var capability = newPromiseCapability(C);
	var reject = capability.reject;
	var result = perform(function () {
			forOf(iterable, false, function (promise) {
		C.resolve(promise).then(capability.resolve, reject);
			});
	});
	if (result.e) reject(result.v);
	return capability.promise;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var macrotask = __webpack_require__(141).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(28)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function flush() {
	var parent, fn;
	if (isNode && (parent = process.domain)) parent.exit();
	while (head) {
			fn = head.fn;
			head = head.next;
			try {
		fn();
			} catch (e) {
		if (head) notify();else last = undefined;
		throw e;
			}
	}last = undefined;
	if (parent) parent.enter();
  };
  if (isNode) {
	notify = function notify() {
			process.nextTick(flush);
	};
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
	var toggle = true;
	var node = document.createTextNode('');
	new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	notify = function notify() {
			node.data = toggle = !toggle;
	};
  } else if (Promise && Promise.resolve) {
	var promise = Promise.resolve();
	notify = function notify() {
			promise.then(flush);
	};
  } else {
	notify = function notify() {
			macrotask.call(global, flush);
	};
  }

  return function (fn) {
	var task = { fn: fn, next: undefined };
	if (last) last.next = task;
	if (!head) {
			head = task;
			notify();
	}last = task;
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (exec) {
  try {
	return { e: false, v: exec() };
  } catch (e) {
	return { e: true, v: e };
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(5);
var isObject = __webpack_require__(3);
var newPromiseCapability = __webpack_require__(142);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var weak = __webpack_require__(147);
var validate = __webpack_require__(49);
var WEAK_SET = 'WeakSet';
__webpack_require__(64)(WEAK_SET, function (get) {
  return function WeakSet() {
	return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  add: function add(value) {
	return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $typed = __webpack_require__(65);
var buffer = __webpack_require__(96);
var anObject = __webpack_require__(5);
var toAbsoluteIndex = __webpack_require__(37);
var toLength = __webpack_require__(12);
var isObject = __webpack_require__(3);
var ArrayBuffer = __webpack_require__(4).ArrayBuffer;
var speciesConstructor = __webpack_require__(95);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  isView: function isView(it) {
	return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(2)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  slice: function slice(start, end) {
	if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
	var len = anObject(this).byteLength;
	var first = toAbsoluteIndex(start, len);
	var final = toAbsoluteIndex(end === undefined ? len : end, len);
	var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
	var viewS = new $DataView(this);
	var viewT = new $DataView(result);
	var index = 0;
	while (first < final) {
			viewT.setUint8(index++, viewS.getUint8(first++));
	}return result;
  }
});

__webpack_require__(45)(ARRAY_BUFFER);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
$export($export.G + $export.W + $export.F * !__webpack_require__(65).ABV, {
  DataView: __webpack_require__(96).DataView
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
}, true);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var aFunction = __webpack_require__(23);
var anObject = __webpack_require__(5);
var rApply = (__webpack_require__(4).Reflect || {}).apply;
var fApply = Function.apply;
$export($export.S + $export.F * !__webpack_require__(2)(function () {
  rApply(function () {/* empty */});
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
	var T = aFunction(target);
	var L = anObject(argumentsList);
	return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var create = __webpack_require__(38);
var aFunction = __webpack_require__(23);
var anObject = __webpack_require__(5);
var isObject = __webpack_require__(3);
var fails = __webpack_require__(2);
var bind = __webpack_require__(122);
var rConstruct = (__webpack_require__(4).Reflect || {}).construct;
var NEW_TARGET_BUG = fails(function () {
  function F() {/* empty */}
  return !(rConstruct(function () {/* empty */}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {/* empty */});
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
	aFunction(Target);
	anObject(args);
	var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
	if (Target == newTarget) {
			switch (args.length) {
		case 0:
					return new Target();
		case 1:
					return new Target(args[0]);
		case 2:
					return new Target(args[0], args[1]);
		case 3:
					return new Target(args[0], args[1], args[2]);
		case 4:
					return new Target(args[0], args[1], args[2], args[3]);
			}
			var $args = [null];
			$args.push.apply($args, args);
			return new (bind.apply(Target, $args))();
	}
	var proto = newTarget.prototype;
	var instance = create(isObject(proto) ? proto : Object.prototype);
	var result = Function.apply.call(Target, instance, args);
	return isObject(result) ? result : instance;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var dP = __webpack_require__(9);
var $export = __webpack_require__(1);
var anObject = __webpack_require__(5);
var toPrimitive = __webpack_require__(32);
$export($export.S + $export.F * __webpack_require__(2)(function () {
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
	anObject(target);
	propertyKey = toPrimitive(propertyKey, true);
	anObject(attributes);
	try {
			dP.f(target, propertyKey, attributes);
			return true;
	} catch (e) {
			return false;
	}
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var gOPD = __webpack_require__(30).f;
var anObject = __webpack_require__(5);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
	var desc = gOPD(anObject(target), propertyKey);
	return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var anObject = __webpack_require__(5);
var Enumerate = function Enumerate(iterated) {
  this._t = anObject(iterated); // target
  this._i = 0; // next index
  var keys = this._k = []; // keys
  var key;
  for (key in iterated) {
	keys.push(key);
  }
};
__webpack_require__(132)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
	if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
	return new Enumerate(target);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var gOPD = __webpack_require__(30);
var getPrototypeOf = __webpack_require__(40);
var has = __webpack_require__(14);
var $export = __webpack_require__(1);
var isObject = __webpack_require__(3);
var anObject = __webpack_require__(5);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var gOPD = __webpack_require__(30);
var $export = __webpack_require__(1);
var anObject = __webpack_require__(5);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	return gOPD.f(anObject(target), propertyKey);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var getProto = __webpack_require__(40);
var anObject = __webpack_require__(5);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
	return getProto(anObject(target));
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
	return propertyKey in target;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var anObject = __webpack_require__(5);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
	anObject(target);
	return $isExtensible ? $isExtensible(target) : true;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(308) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var gOPN = __webpack_require__(39);
var gOPS = __webpack_require__(58);
var anObject = __webpack_require__(5);
var Reflect = __webpack_require__(4).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var anObject = __webpack_require__(5);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
	anObject(target);
	try {
			if ($preventExtensions) $preventExtensions(target);
			return true;
	} catch (e) {
			return false;
	}
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var dP = __webpack_require__(9);
var gOPD = __webpack_require__(30);
var getPrototypeOf = __webpack_require__(40);
var has = __webpack_require__(14);
var $export = __webpack_require__(1);
var createDesc = __webpack_require__(35);
var anObject = __webpack_require__(5);
var isObject = __webpack_require__(3);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
	if (isObject(proto = getPrototypeOf(target))) {
			return set(proto, propertyKey, V, receiver);
	}
	ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
	if (ownDesc.writable === false || !isObject(receiver)) return false;
	existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	existingDescriptor.value = V;
	dP.f(receiver, propertyKey, existingDescriptor);
	return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var setProto = __webpack_require__(81);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
	setProto.check(target, proto);
	try {
			setProto.set(target, proto);
			return true;
	} catch (e) {
			return false;
	}
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(115);
__webpack_require__(52);
__webpack_require__(313);
__webpack_require__(314);
module.exports = __webpack_require__(13).Symbol;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(75)('asyncIterator');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(75)('observable');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(52);
__webpack_require__(61);
__webpack_require__(97);
__webpack_require__(145);
__webpack_require__(316);
__webpack_require__(318);
__webpack_require__(319);
module.exports = __webpack_require__(13).Set;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(149)('Set') });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var forOf = __webpack_require__(47);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(98)('Set');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(99)('Set');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(61);
__webpack_require__(133);
module.exports = __webpack_require__(13).Array.from;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(138);
module.exports = __webpack_require__(13).Array.findIndex;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(130);
module.exports = __webpack_require__(13).String.raw;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(52);
__webpack_require__(61);
__webpack_require__(97);
__webpack_require__(143);
__webpack_require__(324);
__webpack_require__(325);
__webpack_require__(326);
module.exports = __webpack_require__(13).Map;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(149)('Map') });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(98)('Map');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(99)('Map');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(52);
__webpack_require__(97);
__webpack_require__(146);
__webpack_require__(328);
__webpack_require__(329);
module.exports = __webpack_require__(13).WeakMap;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(98)('WeakMap');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(99)('WeakMap');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = ( false ? "undefined" : _typeof(module)) === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
	if (inModule) {
			module.exports = runtime;
	}
	return;
  }
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
	var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	var generator = Object.create(protoGenerator.prototype);
	var context = new Context(tryLocsList || []);
	generator._invoke = makeInvokeMethod(innerFn, self, context);

	return generator;
  }
  runtime.wrap = wrap;
  function tryCatch(fn, obj, arg) {
	try {
			return { type: "normal", arg: fn.call(obj, arg) };
	} catch (err) {
			return { type: "throw", arg: err };
	}
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
	return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
  function defineIteratorMethods(prototype) {
	["next", "throw", "return"].forEach(function (method) {
			prototype[method] = function (arg) {
		return this._invoke(method, arg);
			};
	});
  }

  runtime.isGeneratorFunction = function (genFun) {
	var ctor = typeof genFun === "function" && genFun.constructor;
	return ctor ? ctor === GeneratorFunction ||
	(ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
	if (Object.setPrototypeOf) {
			Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	} else {
			genFun.__proto__ = GeneratorFunctionPrototype;
			if (!(toStringTagSymbol in genFun)) {
		genFun[toStringTagSymbol] = "GeneratorFunction";
			}
	}
	genFun.prototype = Object.create(Gp);
	return genFun;
  };
  runtime.awrap = function (arg) {
	return { __await: arg };
  };

  function AsyncIterator(generator) {
	function invoke(method, arg, resolve, reject) {
			var record = tryCatch(generator[method], generator, arg);
			if (record.type === "throw") {
		reject(record.arg);
			} else {
		var result = record.arg;
		var value = result.value;
		if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && hasOwn.call(value, "__await")) {
					return Promise.resolve(value.__await).then(function (value) {
			invoke("next", value, resolve, reject);
					}, function (err) {
			invoke("throw", err, resolve, reject);
					});
		}

		return Promise.resolve(value).then(function (unwrapped) {
					result.value = unwrapped;
					resolve(result);
		}, reject);
			}
	}

	var previousPromise;

	function enqueue(method, arg) {
			function callInvokeWithMethodAndArg() {
		return new Promise(function (resolve, reject) {
					invoke(method, arg, resolve, reject);
		});
			}

			return previousPromise =
			previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
			callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	}
	this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	return this;
  };
  runtime.AsyncIterator = AsyncIterator;
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
	var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

	return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
	: iter.next().then(function (result) {
			return result.done ? result.value : iter.next();
	});
  };

  function makeInvokeMethod(innerFn, self, context) {
	var state = GenStateSuspendedStart;

	return function invoke(method, arg) {
			if (state === GenStateExecuting) {
		throw new Error("Generator is already running");
			}

			if (state === GenStateCompleted) {
		if (method === "throw") {
					throw arg;
		}
		return doneResult();
			}

			context.method = method;
			context.arg = arg;

			while (true) {
		var delegate = context.delegate;
		if (delegate) {
					var delegateResult = maybeInvokeDelegate(delegate, context);
					if (delegateResult) {
			if (delegateResult === ContinueSentinel) continue;
			return delegateResult;
					}
		}

		if (context.method === "next") {
					context.sent = context._sent = context.arg;
		} else if (context.method === "throw") {
					if (state === GenStateSuspendedStart) {
			state = GenStateCompleted;
			throw context.arg;
					}

					context.dispatchException(context.arg);
		} else if (context.method === "return") {
					context.abrupt("return", context.arg);
		}

		state = GenStateExecuting;

		var record = tryCatch(innerFn, self, context);
		if (record.type === "normal") {
					state = context.done ? GenStateCompleted : GenStateSuspendedYield;

					if (record.arg === ContinueSentinel) {
			continue;
					}

					return {
			value: record.arg,
			done: context.done
					};
		} else if (record.type === "throw") {
					state = GenStateCompleted;
					context.method = "throw";
					context.arg = record.arg;
		}
			}
	};
  }
  function maybeInvokeDelegate(delegate, context) {
	var method = delegate.iterator[context.method];
	if (method === undefined) {
			context.delegate = null;

			if (context.method === "throw") {
		if (delegate.iterator.return) {
					context.method = "return";
					context.arg = undefined;
					maybeInvokeDelegate(delegate, context);

					if (context.method === "throw") {
			return ContinueSentinel;
					}
		}

		context.method = "throw";
		context.arg = new TypeError("The iterator does not provide a 'throw' method");
			}

			return ContinueSentinel;
	}

	var record = tryCatch(method, delegate.iterator, context.arg);

	if (record.type === "throw") {
			context.method = "throw";
			context.arg = record.arg;
			context.delegate = null;
			return ContinueSentinel;
	}

	var info = record.arg;

	if (!info) {
			context.method = "throw";
			context.arg = new TypeError("iterator result is not an object");
			context.delegate = null;
			return ContinueSentinel;
	}

	if (info.done) {
			context[delegate.resultName] = info.value;
			context.next = delegate.nextLoc;
			if (context.method !== "return") {
		context.method = "next";
		context.arg = undefined;
			}
	} else {
			return info;
	}
	context.delegate = null;
	return ContinueSentinel;
  }
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";
  Gp[iteratorSymbol] = function () {
	return this;
  };

  Gp.toString = function () {
	return "[object Generator]";
  };

  function pushTryEntry(locs) {
	var entry = { tryLoc: locs[0] };

	if (1 in locs) {
			entry.catchLoc = locs[1];
	}

	if (2 in locs) {
			entry.finallyLoc = locs[2];
			entry.afterLoc = locs[3];
	}

	this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
	var record = entry.completion || {};
	record.type = "normal";
	delete record.arg;
	entry.completion = record;
  }

  function Context(tryLocsList) {
	this.tryEntries = [{ tryLoc: "root" }];
	tryLocsList.forEach(pushTryEntry, this);
	this.reset(true);
  }

  runtime.keys = function (object) {
	var keys = [];
	for (var key in object) {
			keys.push(key);
	}
	keys.reverse();
	return function next() {
			while (keys.length) {
		var key = keys.pop();
		if (key in object) {
					next.value = key;
					next.done = false;
					return next;
		}
			}
			next.done = true;
			return next;
	};
  };

  function values(iterable) {
	if (iterable) {
			var iteratorMethod = iterable[iteratorSymbol];
			if (iteratorMethod) {
		return iteratorMethod.call(iterable);
			}

			if (typeof iterable.next === "function") {
		return iterable;
			}

			if (!isNaN(iterable.length)) {
		var i = -1,
			next = function next() {
					while (++i < iterable.length) {
			if (hasOwn.call(iterable, i)) {
							next.value = iterable[i];
							next.done = false;
							return next;
			}
					}

					next.value = undefined;
					next.done = true;

					return next;
		};

		return next.next = next;
			}
	}
	return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
	return { value: undefined, done: true };
  }

  Context.prototype = {
	constructor: Context,

	reset: function reset(skipTempReset) {
			this.prev = 0;
			this.next = 0;
			this.sent = this._sent = undefined;
			this.done = false;
			this.delegate = null;

			this.method = "next";
			this.arg = undefined;

			this.tryEntries.forEach(resetTryEntry);

			if (!skipTempReset) {
		for (var name in this) {
					if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
			this[name] = undefined;
					}
		}
			}
	},

	stop: function stop() {
			this.done = true;

			var rootEntry = this.tryEntries[0];
			var rootRecord = rootEntry.completion;
			if (rootRecord.type === "throw") {
		throw rootRecord.arg;
			}

			return this.rval;
	},

	dispatchException: function dispatchException(exception) {
			if (this.done) {
		throw exception;
			}

			var context = this;
			function handle(loc, caught) {
		record.type = "throw";
		record.arg = exception;
		context.next = loc;

		if (caught) {
					context.method = "next";
					context.arg = undefined;
		}

		return !!caught;
			}

			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
		var entry = this.tryEntries[i];
		var record = entry.completion;

		if (entry.tryLoc === "root") {
					return handle("end");
		}

		if (entry.tryLoc <= this.prev) {
					var hasCatch = hasOwn.call(entry, "catchLoc");
					var hasFinally = hasOwn.call(entry, "finallyLoc");

					if (hasCatch && hasFinally) {
			if (this.prev < entry.catchLoc) {
							return handle(entry.catchLoc, true);
			} else if (this.prev < entry.finallyLoc) {
							return handle(entry.finallyLoc);
			}
					} else if (hasCatch) {
			if (this.prev < entry.catchLoc) {
							return handle(entry.catchLoc, true);
			}
					} else if (hasFinally) {
			if (this.prev < entry.finallyLoc) {
							return handle(entry.finallyLoc);
			}
					} else {
			throw new Error("try statement without catch or finally");
					}
		}
			}
	},

	abrupt: function abrupt(type, arg) {
			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
		var entry = this.tryEntries[i];
		if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
					var finallyEntry = entry;
					break;
		}
			}

			if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
		finallyEntry = null;
			}

			var record = finallyEntry ? finallyEntry.completion : {};
			record.type = type;
			record.arg = arg;

			if (finallyEntry) {
		this.method = "next";
		this.next = finallyEntry.finallyLoc;
		return ContinueSentinel;
			}

			return this.complete(record);
	},

	complete: function complete(record, afterLoc) {
			if (record.type === "throw") {
		throw record.arg;
			}

			if (record.type === "break" || record.type === "continue") {
		this.next = record.arg;
			} else if (record.type === "return") {
		this.rval = this.arg = record.arg;
		this.method = "return";
		this.next = "end";
			} else if (record.type === "normal" && afterLoc) {
		this.next = afterLoc;
			}

			return ContinueSentinel;
	},

	finish: function finish(finallyLoc) {
			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
		var entry = this.tryEntries[i];
		if (entry.finallyLoc === finallyLoc) {
					this.complete(entry.completion, entry.afterLoc);
					resetTryEntry(entry);
					return ContinueSentinel;
		}
			}
	},

	"catch": function _catch(tryLoc) {
			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
		var entry = this.tryEntries[i];
		if (entry.tryLoc === tryLoc) {
					var record = entry.completion;
					if (record.type === "throw") {
			var thrown = record.arg;
			resetTryEntry(entry);
					}
					return thrown;
		}
			}
			throw new Error("illegal catch attempt");
	},

	delegateYield: function delegateYield(iterable, resultName, nextLoc) {
			this.delegate = {
		iterator: values(iterable),
		resultName: resultName,
		nextLoc: nextLoc
			};

			if (this.method === "next") {
		this.arg = undefined;
			}

			return ContinueSentinel;
	}
  };
}(
function () {
  return this;
}() || Function("return this")());
}.call(exports, __webpack_require__(150)(module)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var ScopeManager = __webpack_require__(332);
var Referencer = __webpack_require__(334);
var Reference = __webpack_require__(100);
var Variable = __webpack_require__(66);
var Scope = __webpack_require__(151).Scope;
var version = __webpack_require__(337).version;
function defaultOptions() {
	return {
		optimistic: false,
		directive: false,
		nodejsScope: false,
		impliedStrict: false,
		sourceType: "script", // one of ['script', 'module']
		ecmaVersion: 5,
		childVisitorKeys: null,
		fallback: "iteration"
	};
}
function updateDeeply(target, override) {
	function isHashObject(value) {
		return (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);
	}

	for (var key in override) {
		if (override.hasOwnProperty(key)) {
			var val = override[key];

			if (isHashObject(val)) {
				if (isHashObject(target[key])) {
					updateDeeply(target[key], val);
				} else {
					target[key] = updateDeeply({}, val);
				}
			} else {
				target[key] = val;
			}
		}
	}
	return target;
}
function analyze(tree, providedOptions) {
	var options = updateDeeply(defaultOptions(), providedOptions);
	var scopeManager = new ScopeManager(options);
	var referencer = new Referencer(options, scopeManager);

	referencer.visit(tree);

	return scopeManager;
}

module.exports = {
	version: version,
	Reference: Reference,
	Variable: Variable,
	Scope: Scope,
	ScopeManager: ScopeManager,
	analyze: analyze
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Scope = __webpack_require__(151);


var GlobalScope = Scope.GlobalScope;
var CatchScope = Scope.CatchScope;
var WithScope = Scope.WithScope;
var ModuleScope = Scope.ModuleScope;
var ClassScope = Scope.ClassScope;
var SwitchScope = Scope.SwitchScope;
var FunctionScope = Scope.FunctionScope;
var ForScope = Scope.ForScope;
var TDZScope = Scope.TDZScope;
var FunctionExpressionNameScope = Scope.FunctionExpressionNameScope;
var BlockScope = Scope.BlockScope;

var ScopeManager = function () {
	function ScopeManager(options) {
		_classCallCheck(this, ScopeManager);

		this.scopes = [];
		this.globalScope = null;
		this.__nodeToScope = new WeakMap();
		this.__currentScope = null;
		this.__options = options;
		this.__declaredVariables = new WeakMap();
	}

	_createClass(ScopeManager, [{
		key: "__useDirective",
		value: function __useDirective() {
			return this.__options.directive;
		}
	}, {
		key: "__isOptimistic",
		value: function __isOptimistic() {
			return this.__options.optimistic;
		}
	}, {
		key: "__ignoreEval",
		value: function __ignoreEval() {
			return this.__options.ignoreEval;
		}
	}, {
		key: "__isNodejsScope",
		value: function __isNodejsScope() {
			return this.__options.nodejsScope;
		}
	}, {
		key: "isModule",
		value: function isModule() {
			return this.__options.sourceType === "module";
		}
	}, {
		key: "isImpliedStrict",
		value: function isImpliedStrict() {
			return this.__options.impliedStrict;
		}
	}, {
		key: "isStrictModeSupported",
		value: function isStrictModeSupported() {
			return this.__options.ecmaVersion >= 5;
		}
	}, {
		key: "__get",
		value: function __get(node) {
			return this.__nodeToScope.get(node);
		}

	}, {
		key: "getDeclaredVariables",
		value: function getDeclaredVariables(node) {
			return this.__declaredVariables.get(node) || [];
		}

	}, {
		key: "acquire",
		value: function acquire(node, inner) {
			function predicate(testScope) {
				if (testScope.type === "function" && testScope.functionExpressionScope) {
					return false;
				}
				if (testScope.type === "TDZ") {
					return false;
				}
				return true;
			}

			var scopes = this.__get(node);

			if (!scopes || scopes.length === 0) {
				return null;
			}
			if (scopes.length === 1) {
				return scopes[0];
			}

			if (inner) {
				for (var i = scopes.length - 1; i >= 0; --i) {
					var scope = scopes[i];

					if (predicate(scope)) {
						return scope;
					}
				}
			} else {
				for (var _i = 0, iz = scopes.length; _i < iz; ++_i) {
					var _scope = scopes[_i];

					if (predicate(_scope)) {
						return _scope;
					}
				}
			}

			return null;
		}

	}, {
		key: "acquireAll",
		value: function acquireAll(node) {
			return this.__get(node);
		}

	}, {
		key: "release",
		value: function release(node, inner) {
			var scopes = this.__get(node);

			if (scopes && scopes.length) {
				var scope = scopes[0].upper;

				if (!scope) {
					return null;
				}
				return this.acquire(scope.block, inner);
			}
			return null;
		}
	}, {
		key: "attach",
		value: function attach() {} // eslint-disable-line class-methods-use-this

	}, {
		key: "detach",
		value: function detach() {} // eslint-disable-line class-methods-use-this

	}, {
		key: "__nestScope",
		value: function __nestScope(scope) {
			if (scope instanceof GlobalScope) {
				this.globalScope = scope;
			}
			this.__currentScope = scope;
			return scope;
		}
	}, {
		key: "__nestGlobalScope",
		value: function __nestGlobalScope(node) {
			return this.__nestScope(new GlobalScope(this, node));
		}
	}, {
		key: "__nestBlockScope",
		value: function __nestBlockScope(node) {
			return this.__nestScope(new BlockScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestFunctionScope",
		value: function __nestFunctionScope(node, isMethodDefinition) {
			return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));
		}
	}, {
		key: "__nestForScope",
		value: function __nestForScope(node) {
			return this.__nestScope(new ForScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestCatchScope",
		value: function __nestCatchScope(node) {
			return this.__nestScope(new CatchScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestWithScope",
		value: function __nestWithScope(node) {
			return this.__nestScope(new WithScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestClassScope",
		value: function __nestClassScope(node) {
			return this.__nestScope(new ClassScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestSwitchScope",
		value: function __nestSwitchScope(node) {
			return this.__nestScope(new SwitchScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestModuleScope",
		value: function __nestModuleScope(node) {
			return this.__nestScope(new ModuleScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestTDZScope",
		value: function __nestTDZScope(node) {
			return this.__nestScope(new TDZScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestFunctionExpressionNameScope",
		value: function __nestFunctionExpressionNameScope(node) {
			return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));
		}
	}, {
		key: "__isES6",
		value: function __isES6() {
			return this.__options.ecmaVersion >= 6;
		}
	}]);

	return ScopeManager;
}();

module.exports = ScopeManager;
 }),
 (function(module, exports) {

module.exports = {"_from":"estraverse@^4.2.0","_id":"estraverse@4.2.0","_inBundle":false,"_integrity":"sha1-De4/7TH81GlhjOc0IJn8GvoL2xM=","_location":"/estraverse","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"estraverse@^4.2.0","name":"estraverse","escapedName":"estraverse","rawSpec":"^4.2.0","saveSpec":null,"fetchSpec":"^4.2.0"},"_requiredBy":["/escope","/eslint","/eslint-scope","/esquery","/esrecurse"],"_resolved":"https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz","_shasum":"0dee3fed31fcd469618ce7342099fc1afa0bdb13","_spec":"estraverse@^4.2.0","_where":"J:\\Chromium\\newclient\\plugins\\c9.ide.language.javascript.eslint\\packager\\node_modules\\eslint","bugs":{"url":"https://github.com/estools/estraverse/issues"},"bundleDependencies":false,"deprecated":false,"description":"ECMAScript JS AST traversal functions","devDependencies":{"babel-preset-es2015":"^6.3.13","babel-register":"^6.3.13","chai":"^2.1.1","espree":"^1.11.0","gulp":"^3.8.10","gulp-bump":"^0.2.2","gulp-filter":"^2.0.0","gulp-git":"^1.0.1","gulp-tag-version":"^1.2.1","jshint":"^2.5.6","mocha":"^2.1.0"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/estools/estraverse","license":"BSD-2-Clause","main":"estraverse.js","maintainers":[{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","url":"http://github.com/Constellation"}],"name":"estraverse","repository":{"type":"git","url":"git+ssh://git@github.com/estools/estraverse.git"},"scripts":{"lint":"jshint estraverse.js","test":"npm run-script lint && npm run-script unit-test","unit-test":"mocha --compilers js:babel-register"},"version":"4.2.0"}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Syntax = __webpack_require__(50).Syntax;
var esrecurse = __webpack_require__(153);
var Reference = __webpack_require__(100);
var Variable = __webpack_require__(66);
var PatternVisitor = __webpack_require__(336);
var definition = __webpack_require__(152);


var ParameterDefinition = definition.ParameterDefinition;
var Definition = definition.Definition;
function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
	var visitor = new PatternVisitor(options, rootPattern, callback);

	visitor.visit(rootPattern);
	if (referencer !== null && referencer !== undefined) {
		visitor.rightHandNodes.forEach(referencer.visit, referencer);
	}
}
var Importer = function (_esrecurse$Visitor) {
	_inherits(Importer, _esrecurse$Visitor);

	function Importer(declaration, referencer) {
		_classCallCheck(this, Importer);

		var _this = _possibleConstructorReturn(this, (Importer.__proto__ || Object.getPrototypeOf(Importer)).call(this, null, referencer.options));

		_this.declaration = declaration;
		_this.referencer = referencer;
		return _this;
	}

	_createClass(Importer, [{
		key: "visitImport",
		value: function visitImport(id, specifier) {
			var _this2 = this;

			this.referencer.visitPattern(id, function (pattern) {
				_this2.referencer.currentScope().__define(pattern, new Definition(Variable.ImportBinding, pattern, specifier, _this2.declaration, null, null));
			});
		}
	}, {
		key: "ImportNamespaceSpecifier",
		value: function ImportNamespaceSpecifier(node) {
			var local = node.local || node.id;

			if (local) {
				this.visitImport(local, node);
			}
		}
	}, {
		key: "ImportDefaultSpecifier",
		value: function ImportDefaultSpecifier(node) {
			var local = node.local || node.id;

			this.visitImport(local, node);
		}
	}, {
		key: "ImportSpecifier",
		value: function ImportSpecifier(node) {
			var local = node.local || node.id;

			if (node.name) {
				this.visitImport(node.name, node);
			} else {
				this.visitImport(local, node);
			}
		}
	}]);

	return Importer;
}(esrecurse.Visitor);

var Referencer = function (_esrecurse$Visitor2) {
	_inherits(Referencer, _esrecurse$Visitor2);

	function Referencer(options, scopeManager) {
		_classCallCheck(this, Referencer);

		var _this3 = _possibleConstructorReturn(this, (Referencer.__proto__ || Object.getPrototypeOf(Referencer)).call(this, null, options));

		_this3.options = options;
		_this3.scopeManager = scopeManager;
		_this3.parent = null;
		_this3.isInnerMethodDefinition = false;
		return _this3;
	}

	_createClass(Referencer, [{
		key: "currentScope",
		value: function currentScope() {
			return this.scopeManager.__currentScope;
		}
	}, {
		key: "close",
		value: function close(node) {
			while (this.currentScope() && node === this.currentScope().block) {
				this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
			}
		}
	}, {
		key: "pushInnerMethodDefinition",
		value: function pushInnerMethodDefinition(isInnerMethodDefinition) {
			var previous = this.isInnerMethodDefinition;

			this.isInnerMethodDefinition = isInnerMethodDefinition;
			return previous;
		}
	}, {
		key: "popInnerMethodDefinition",
		value: function popInnerMethodDefinition(isInnerMethodDefinition) {
			this.isInnerMethodDefinition = isInnerMethodDefinition;
		}
	}, {
		key: "materializeTDZScope",
		value: function materializeTDZScope(node, iterationNode) {
			this.scopeManager.__nestTDZScope(node, iterationNode);
			this.visitVariableDeclaration(this.currentScope(), Variable.TDZ, iterationNode.left, 0, true);
		}
	}, {
		key: "materializeIterationScope",
		value: function materializeIterationScope(node) {
			var _this4 = this;
			var letOrConstDecl = node.left;

			this.scopeManager.__nestForScope(node);
			this.visitVariableDeclaration(this.currentScope(), Variable.Variable, letOrConstDecl, 0);
			this.visitPattern(letOrConstDecl.declarations[0].id, function (pattern) {
				_this4.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);
			});
		}
	}, {
		key: "referencingDefaultValue",
		value: function referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
			var scope = this.currentScope();

			assignments.forEach(function (assignment) {
				scope.__referencing(pattern, Reference.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);
			});
		}
	}, {
		key: "visitPattern",
		value: function visitPattern(node, options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = { processRightHandNodes: false };
			}
			traverseIdentifierInPattern(this.options, node, options.processRightHandNodes ? this : null, callback);
		}
	}, {
		key: "visitFunction",
		value: function visitFunction(node) {
			var _this5 = this;

			var i = void 0,
				iz = void 0;
			if (node.type === Syntax.FunctionDeclaration) {
				this.currentScope().__define(node.id, new Definition(Variable.FunctionName, node.id, node, null, null, null));
			}
			if (node.type === Syntax.FunctionExpression && node.id) {
				this.scopeManager.__nestFunctionExpressionNameScope(node);
			}
			this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);

			var that = this;
			function visitPatternCallback(pattern, info) {
				that.currentScope().__define(pattern, new ParameterDefinition(pattern, node, i, info.rest));

				that.referencingDefaultValue(pattern, info.assignments, null, true);
			}
			for (i = 0, iz = node.params.length; i < iz; ++i) {
				this.visitPattern(node.params[i], { processRightHandNodes: true }, visitPatternCallback);
			}
			if (node.rest) {
				this.visitPattern({
					type: "RestElement",
					argument: node.rest
				}, function (pattern) {
					_this5.currentScope().__define(pattern, new ParameterDefinition(pattern, node, node.params.length, true));
				});
			}
			if (node.body) {
				if (node.body.type === Syntax.BlockStatement) {
					this.visitChildren(node.body);
				} else {
					this.visit(node.body);
				}
			}

			this.close(node);
		}
	}, {
		key: "visitClass",
		value: function visitClass(node) {
			if (node.type === Syntax.ClassDeclaration) {
				this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node, null, null, null));
			}
			this.visit(node.superClass);

			this.scopeManager.__nestClassScope(node);

			if (node.id) {
				this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node));
			}
			this.visit(node.body);

			this.close(node);
		}
	}, {
		key: "visitProperty",
		value: function visitProperty(node) {
			var previous = void 0;

			if (node.computed) {
				this.visit(node.key);
			}

			var isMethodDefinition = node.type === Syntax.MethodDefinition;

			if (isMethodDefinition) {
				previous = this.pushInnerMethodDefinition(true);
			}
			this.visit(node.value);
			if (isMethodDefinition) {
				this.popInnerMethodDefinition(previous);
			}
		}
	}, {
		key: "visitForIn",
		value: function visitForIn(node) {
			var _this6 = this;

			if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== "var") {
				this.materializeTDZScope(node.right, node);
				this.visit(node.right);
				this.close(node.right);

				this.materializeIterationScope(node);
				this.visit(node.body);
				this.close(node);
			} else {
				if (node.left.type === Syntax.VariableDeclaration) {
					this.visit(node.left);
					this.visitPattern(node.left.declarations[0].id, function (pattern) {
						_this6.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);
					});
				} else {
					this.visitPattern(node.left, { processRightHandNodes: true }, function (pattern, info) {
						var maybeImplicitGlobal = null;

						if (!_this6.currentScope().isStrict) {
							maybeImplicitGlobal = {
								pattern: pattern,
								node: node
							};
						}
						_this6.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
						_this6.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, true, false);
					});
				}
				this.visit(node.right);
				this.visit(node.body);
			}
		}
	}, {
		key: "visitVariableDeclaration",
		value: function visitVariableDeclaration(variableTargetScope, type, node, index, fromTDZ) {
			var _this7 = this;
			var decl = node.declarations[index];
			var init = decl.init;

			this.visitPattern(decl.id, { processRightHandNodes: !fromTDZ }, function (pattern, info) {
				variableTargetScope.__define(pattern, new Definition(type, pattern, decl, node, index, node.kind));

				if (!fromTDZ) {
					_this7.referencingDefaultValue(pattern, info.assignments, null, true);
				}
				if (init) {
					_this7.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, true);
				}
			});
		}
	}, {
		key: "AssignmentExpression",
		value: function AssignmentExpression(node) {
			var _this8 = this;

			if (PatternVisitor.isPattern(node.left)) {
				if (node.operator === "=") {
					this.visitPattern(node.left, { processRightHandNodes: true }, function (pattern, info) {
						var maybeImplicitGlobal = null;

						if (!_this8.currentScope().isStrict) {
							maybeImplicitGlobal = {
								pattern: pattern,
								node: node
							};
						}
						_this8.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
						_this8.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);
					});
				} else {
					this.currentScope().__referencing(node.left, Reference.RW, node.right);
				}
			} else {
				this.visit(node.left);
			}
			this.visit(node.right);
		}
	}, {
		key: "CatchClause",
		value: function CatchClause(node) {
			var _this9 = this;

			this.scopeManager.__nestCatchScope(node);

			this.visitPattern(node.param, { processRightHandNodes: true }, function (pattern, info) {
				_this9.currentScope().__define(pattern, new Definition(Variable.CatchClause, node.param, node, null, null, null));
				_this9.referencingDefaultValue(pattern, info.assignments, null, true);
			});
			this.visit(node.body);

			this.close(node);
		}
	}, {
		key: "Program",
		value: function Program(node) {
			this.scopeManager.__nestGlobalScope(node);

			if (this.scopeManager.__isNodejsScope()) {
				this.currentScope().isStrict = false;
				this.scopeManager.__nestFunctionScope(node, false);
			}

			if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {
				this.scopeManager.__nestModuleScope(node);
			}

			if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
				this.currentScope().isStrict = true;
			}

			this.visitChildren(node);
			this.close(node);
		}
	}, {
		key: "Identifier",
		value: function Identifier(node) {
			this.currentScope().__referencing(node);
		}
	}, {
		key: "UpdateExpression",
		value: function UpdateExpression(node) {
			if (PatternVisitor.isPattern(node.argument)) {
				this.currentScope().__referencing(node.argument, Reference.RW, null);
			} else {
				this.visitChildren(node);
			}
		}
	}, {
		key: "MemberExpression",
		value: function MemberExpression(node) {
			this.visit(node.object);
			if (node.computed) {
				this.visit(node.property);
			}
		}
	}, {
		key: "Property",
		value: function Property(node) {
			this.visitProperty(node);
		}
	}, {
		key: "MethodDefinition",
		value: function MethodDefinition(node) {
			this.visitProperty(node);
		}
	}, {
		key: "BreakStatement",
		value: function BreakStatement() {} // eslint-disable-line class-methods-use-this

	}, {
		key: "ContinueStatement",
		value: function ContinueStatement() {} // eslint-disable-line class-methods-use-this

	}, {
		key: "LabeledStatement",
		value: function LabeledStatement(node) {
			this.visit(node.body);
		}
	}, {
		key: "ForStatement",
		value: function ForStatement(node) {
			if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== "var") {
				this.scopeManager.__nestForScope(node);
			}

			this.visitChildren(node);

			this.close(node);
		}
	}, {
		key: "ClassExpression",
		value: function ClassExpression(node) {
			this.visitClass(node);
		}
	}, {
		key: "ClassDeclaration",
		value: function ClassDeclaration(node) {
			this.visitClass(node);
		}
	}, {
		key: "CallExpression",
		value: function CallExpression(node) {
			if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === "eval") {
				this.currentScope().variableScope.__detectEval();
			}
			this.visitChildren(node);
		}
	}, {
		key: "BlockStatement",
		value: function BlockStatement(node) {
			if (this.scopeManager.__isES6()) {
				this.scopeManager.__nestBlockScope(node);
			}

			this.visitChildren(node);

			this.close(node);
		}
	}, {
		key: "ThisExpression",
		value: function ThisExpression() {
			this.currentScope().variableScope.__detectThis();
		}
	}, {
		key: "WithStatement",
		value: function WithStatement(node) {
			this.visit(node.object);
			this.scopeManager.__nestWithScope(node);

			this.visit(node.body);

			this.close(node);
		}
	}, {
		key: "VariableDeclaration",
		value: function VariableDeclaration(node) {
			var variableTargetScope = node.kind === "var" ? this.currentScope().variableScope : this.currentScope();

			for (var i = 0, iz = node.declarations.length; i < iz; ++i) {
				var decl = node.declarations[i];

				this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i);
				if (decl.init) {
					this.visit(decl.init);
				}
			}
		}
	}, {
		key: "SwitchStatement",
		value: function SwitchStatement(node) {
			this.visit(node.discriminant);

			if (this.scopeManager.__isES6()) {
				this.scopeManager.__nestSwitchScope(node);
			}

			for (var i = 0, iz = node.cases.length; i < iz; ++i) {
				this.visit(node.cases[i]);
			}

			this.close(node);
		}
	}, {
		key: "FunctionDeclaration",
		value: function FunctionDeclaration(node) {
			this.visitFunction(node);
		}
	}, {
		key: "FunctionExpression",
		value: function FunctionExpression(node) {
			this.visitFunction(node);
		}
	}, {
		key: "ForOfStatement",
		value: function ForOfStatement(node) {
			this.visitForIn(node);
		}
	}, {
		key: "ForInStatement",
		value: function ForInStatement(node) {
			this.visitForIn(node);
		}
	}, {
		key: "ArrowFunctionExpression",
		value: function ArrowFunctionExpression(node) {
			this.visitFunction(node);
		}
	}, {
		key: "ImportDeclaration",
		value: function ImportDeclaration(node) {

			var importer = new Importer(node, this);

			importer.visit(node);
		}
	}, {
		key: "visitExportDeclaration",
		value: function visitExportDeclaration(node) {
			if (node.source) {
				return;
			}
			if (node.declaration) {
				this.visit(node.declaration);
				return;
			}

			this.visitChildren(node);
		}
	}, {
		key: "ExportDeclaration",
		value: function ExportDeclaration(node) {
			this.visitExportDeclaration(node);
		}
	}, {
		key: "ExportNamedDeclaration",
		value: function ExportNamedDeclaration(node) {
			this.visitExportDeclaration(node);
		}
	}, {
		key: "ExportSpecifier",
		value: function ExportSpecifier(node) {
			var local = node.id || node.local;

			this.visit(local);
		}
	}, {
		key: "MetaProperty",
		value: function MetaProperty() {// eslint-disable-line class-methods-use-this
		}
	}]);

	return Referencer;
}(esrecurse.Visitor);

module.exports = Referencer;
 }),
 (function(module, exports) {

module.exports = {"_from":"esrecurse@^4.1.0","_id":"esrecurse@4.2.0","_inBundle":false,"_integrity":"sha1-+pVo2Y04I/mkHZHpAtyrnqblsWM=","_location":"/esrecurse","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"esrecurse@^4.1.0","name":"esrecurse","escapedName":"esrecurse","rawSpec":"^4.1.0","saveSpec":null,"fetchSpec":"^4.1.0"},"_requiredBy":["/escope","/eslint-scope"],"_resolved":"https://registry.npmjs.org/esrecurse/-/esrecurse-4.2.0.tgz","_shasum":"fa9568d98d3823f9a41d91e902dcab9ea6e5b163","_spec":"esrecurse@^4.1.0","_where":"J:\\Chromium\\newclient\\plugins\\c9.ide.language.javascript.eslint\\packager\\node_modules\\eslint-scope","babel":{"presets":["es2015"]},"bugs":{"url":"https://github.com/estools/esrecurse/issues"},"bundleDependencies":false,"dependencies":{"estraverse":"^4.1.0","object-assign":"^4.0.1"},"deprecated":false,"description":"ECMAScript AST recursive visitor","devDependencies":{"babel-cli":"^6.24.1","babel-eslint":"^7.2.3","babel-preset-es2015":"^6.24.1","babel-register":"^6.24.1","chai":"^4.0.2","esprima":"^4.0.0","gulp":"^3.9.0","gulp-bump":"^2.7.0","gulp-eslint":"^4.0.0","gulp-filter":"^5.0.0","gulp-git":"^2.4.1","gulp-mocha":"^4.3.1","gulp-tag-version":"^1.2.1","jsdoc":"^3.3.0-alpha10","minimist":"^1.1.0"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/estools/esrecurse","license":"BSD-2-Clause","main":"esrecurse.js","maintainers":[{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","url":"https://github.com/Constellation"}],"name":"esrecurse","repository":{"type":"git","url":"git+https://github.com/estools/esrecurse.git"},"scripts":{"lint":"gulp lint","test":"gulp travis","unit-test":"gulp test"},"version":"4.2.0"}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Syntax = __webpack_require__(50).Syntax;
var esrecurse = __webpack_require__(153);
function getLast(xs) {
	return xs[xs.length - 1] || null;
}

var PatternVisitor = function (_esrecurse$Visitor) {
	_inherits(PatternVisitor, _esrecurse$Visitor);

	_createClass(PatternVisitor, null, [{
		key: "isPattern",
		value: function isPattern(node) {
			var nodeType = node.type;

			return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement || nodeType === Syntax.RestElement || nodeType === Syntax.AssignmentPattern;
		}
	}]);

	function PatternVisitor(options, rootPattern, callback) {
		_classCallCheck(this, PatternVisitor);

		var _this = _possibleConstructorReturn(this, (PatternVisitor.__proto__ || Object.getPrototypeOf(PatternVisitor)).call(this, null, options));

		_this.rootPattern = rootPattern;
		_this.callback = callback;
		_this.assignments = [];
		_this.rightHandNodes = [];
		_this.restElements = [];
		return _this;
	}

	_createClass(PatternVisitor, [{
		key: "Identifier",
		value: function Identifier(pattern) {
			var lastRestElement = getLast(this.restElements);

			this.callback(pattern, {
				topLevel: pattern === this.rootPattern,
				rest: lastRestElement !== null && lastRestElement !== undefined && lastRestElement.argument === pattern,
				assignments: this.assignments
			});
		}
	}, {
		key: "Property",
		value: function Property(property) {
			if (property.computed) {
				this.rightHandNodes.push(property.key);
			}
			this.visit(property.value);
		}
	}, {
		key: "ArrayPattern",
		value: function ArrayPattern(pattern) {
			for (var i = 0, iz = pattern.elements.length; i < iz; ++i) {
				var element = pattern.elements[i];

				this.visit(element);
			}
		}
	}, {
		key: "AssignmentPattern",
		value: function AssignmentPattern(pattern) {
			this.assignments.push(pattern);
			this.visit(pattern.left);
			this.rightHandNodes.push(pattern.right);
			this.assignments.pop();
		}
	}, {
		key: "RestElement",
		value: function RestElement(pattern) {
			this.restElements.push(pattern);
			this.visit(pattern.argument);
			this.restElements.pop();
		}
	}, {
		key: "MemberExpression",
		value: function MemberExpression(node) {
			if (node.computed) {
				this.rightHandNodes.push(node.property);
			}
			this.rightHandNodes.push(node.object);
		}

		//
		//

	}, {
		key: "SpreadElement",
		value: function SpreadElement(node) {
			this.visit(node.argument);
		}
	}, {
		key: "ArrayExpression",
		value: function ArrayExpression(node) {
			node.elements.forEach(this.visit, this);
		}
	}, {
		key: "AssignmentExpression",
		value: function AssignmentExpression(node) {
			this.assignments.push(node);
			this.visit(node.left);
			this.rightHandNodes.push(node.right);
			this.assignments.pop();
		}
	}, {
		key: "CallExpression",
		value: function CallExpression(node) {
			var _this2 = this;
			node.arguments.forEach(function (a) {
				_this2.rightHandNodes.push(a);
			});
			this.visit(node.callee);
		}
	}]);

	return PatternVisitor;
}(esrecurse.Visitor);

module.exports = PatternVisitor;
 }),
 (function(module, exports) {

module.exports = {"_from":"eslint-scope@^3.7.1","_id":"eslint-scope@3.7.1","_inBundle":false,"_integrity":"sha1-PWPD7f2gLgbgGkUq2IyqzHzctug=","_location":"/eslint-scope","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"eslint-scope@^3.7.1","name":"eslint-scope","escapedName":"eslint-scope","rawSpec":"^3.7.1","saveSpec":null,"fetchSpec":"^3.7.1"},"_requiredBy":["/eslint"],"_resolved":"https://registry.npmjs.org/eslint-scope/-/eslint-scope-3.7.1.tgz","_shasum":"3d63c3edfda02e06e01a452ad88caacc7cdcb6e8","_spec":"eslint-scope@^3.7.1","_where":"J:\\Chromium\\newclient\\plugins\\c9.ide.language.javascript.eslint\\packager\\node_modules\\eslint","bugs":{"url":"https://github.com/eslint/eslint-scope/issues"},"bundleDependencies":false,"dependencies":{"esrecurse":"^4.1.0","estraverse":"^4.1.1"},"deprecated":false,"description":"ECMAScript scope analyzer for ESLint","devDependencies":{"chai":"^3.4.1","eslint":"^3.15.0","eslint-config-eslint":"^4.0.0","eslint-release":"^0.10.1","espree":"^3.1.1","istanbul":"^0.4.5","mocha":"^3.2.0","npm-license":"^0.3.3","shelljs":"^0.7.6","typescript":"~2.0.10","typescript-eslint-parser":"^1.0.0"},"engines":{"node":">=4.0.0"},"files":["LICENSE","README.md","lib"],"homepage":"http://github.com/eslint/eslint-scope","license":"BSD-2-Clause","main":"lib/index.js","name":"eslint-scope","repository":{"type":"git","url":"git+https://github.com/eslint/eslint-scope.git"},"scripts":{"alpharelease":"eslint-prerelease alpha","betarelease":"eslint-prerelease beta","ci-release":"eslint-ci-release","gh-release":"eslint-gh-release","lint":"node Makefile.js lint","release":"eslint-release","test":"node Makefile.js test"},"version":"3.7.1"}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
  var parseString, cast, parseType, VERSION, parsedTypeParse, parse;
  parseString = __webpack_require__(339);
  cast = __webpack_require__(345);
  parseType = __webpack_require__(156).parseType;
  VERSION = '0.3.0';
  parsedTypeParse = function parsedTypeParse(parsedType, string, options) {
	options == null && (options = {});
	options.explicit == null && (options.explicit = false);
	options.customTypes == null && (options.customTypes = {});
	return cast(parseString(parsedType, string, options), parsedType, options);
  };
  parse = function parse(type, string, options) {
	return parsedTypeParse(parseType(type), string, options);
  };
  module.exports = {
	VERSION: VERSION,
	parse: parse,
	parsedTypeParse: parsedTypeParse
  };
}).call(undefined);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
  var reject, special, tokenRegex;
  reject = __webpack_require__(155).reject;
  function consumeOp(tokens, op) {
	if (tokens[0] === op) {
			return tokens.shift();
	} else {
			throw new Error("Expected '" + op + "', but got '" + tokens[0] + "' instead in " + JSON.stringify(tokens) + ".");
	}
  }
  function maybeConsumeOp(tokens, op) {
	if (tokens[0] === op) {
			return tokens.shift();
	}
  }
  function consumeList(tokens, arg$, hasDelimiters) {
	var open, close, result, untilTest;
	open = arg$[0], close = arg$[1];
	if (hasDelimiters) {
			consumeOp(tokens, open);
	}
	result = [];
	untilTest = "," + (hasDelimiters ? close : '');
	while (tokens.length && hasDelimiters && tokens[0] !== close) {
			result.push(consumeElement(tokens, untilTest));
			maybeConsumeOp(tokens, ',');
	}
	if (hasDelimiters) {
			consumeOp(tokens, close);
	}
	return result;
  }
  function consumeArray(tokens, hasDelimiters) {
	return consumeList(tokens, ['[', ']'], hasDelimiters);
  }
  function consumeTuple(tokens, hasDelimiters) {
	return consumeList(tokens, ['(', ')'], hasDelimiters);
  }
  function consumeFields(tokens, hasDelimiters) {
	var result, untilTest, key;
	if (hasDelimiters) {
			consumeOp(tokens, '{');
	}
	result = {};
	untilTest = "," + (hasDelimiters ? '}' : '');
	while (tokens.length && (!hasDelimiters || tokens[0] !== '}')) {
			key = consumeValue(tokens, ':');
			consumeOp(tokens, ':');
			result[key] = consumeElement(tokens, untilTest);
			maybeConsumeOp(tokens, ',');
	}
	if (hasDelimiters) {
			consumeOp(tokens, '}');
	}
	return result;
  }
  function consumeValue(tokens, untilTest) {
	var out;
	untilTest == null && (untilTest = '');
	out = '';
	while (tokens.length && -1 === untilTest.indexOf(tokens[0])) {
			out += tokens.shift();
	}
	return out;
  }
  function consumeElement(tokens, untilTest) {
	switch (tokens[0]) {
			case '[':
		return consumeArray(tokens, true);
			case '(':
		return consumeTuple(tokens, true);
			case '{':
		return consumeFields(tokens, true);
			default:
		return consumeValue(tokens, untilTest);
	}
  }
  function consumeTopLevel(tokens, types, options) {
	var ref$, type, structure, origTokens, result, finalResult, x$, y$;
	ref$ = types[0], type = ref$.type, structure = ref$.structure;
	origTokens = tokens.concat();
	if (!options.explicit && types.length === 1 && (!type && structure || type === 'Array' || type === 'Object')) {
			result = structure === 'array' || type === 'Array' ? consumeArray(tokens, tokens[0] === '[') : structure === 'tuple' ? consumeTuple(tokens, tokens[0] === '(') : consumeFields(tokens, tokens[0] === '{');
			finalResult = tokens.length ? consumeElement(structure === 'array' || type === 'Array' ? (x$ = origTokens, x$.unshift('['), x$.push(']'), x$) : (y$ = origTokens, y$.unshift('('), y$.push(')'), y$)) : result;
	} else {
			finalResult = consumeElement(tokens);
	}
	return finalResult;
  }
  special = /\[\]\(\)}{:,/.source;
  tokenRegex = RegExp('("(?:\\\\"|[^"])*")|(\'(?:\\\\\'|[^\'])*\')|(/(?:\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([' + special + '])|([^\\s' + special + '](?:\\s*[^\\s' + special + ']+)*)|\\s*');
  module.exports = function (types, string, options) {
	var tokens, node;
	options == null && (options = {});
	if (!options.explicit && types.length === 1 && types[0].type === 'String') {
			return "'" + string.replace(/\\'/g, "\\\\'") + "'";
	}
	tokens = reject(not$, string.split(tokenRegex));
	node = consumeTopLevel(tokens, types, options);
	if (!node) {
			throw new Error("Error parsing '" + string + "'.");
	}
	return node;
  };
  function not$(x) {
	return !x;
  }
}).call(undefined);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var apply,
	curry,
	flip,
	fix,
	over,
	memoize,
	slice$ = [].slice,
	toString$ = {}.toString;
apply = curry$(function (f, list) {
  return f.apply(null, list);
});
curry = function curry(f) {
  return curry$(f);
};
flip = curry$(function (f, x, y) {
  return f(y, x);
});
fix = function fix(f) {
  return function (g) {
	return function () {
			return f(g(g)).apply(null, arguments);
	};
  }(function (g) {
	return function () {
			return f(g(g)).apply(null, arguments);
	};
  });
};
over = curry$(function (f, g, x, y) {
  return f(g(x), g(y));
});
memoize = function memoize(f) {
  var memo;
  memo = {};
  return function () {
	var args, key, arg;
	args = slice$.call(arguments);
	key = function () {
			var i$,
					ref$,
					len$,
					results$ = [];
			for (i$ = 0, len$ = (ref$ = args).length; i$ < len$; ++i$) {
		arg = ref$[i$];
		results$.push(arg + toString$.call(arg).slice(8, -1));
			}
			return results$;
	}().join('');
	return memo[key] = key in memo ? memo[key] : f.apply(null, args);
  };
};
module.exports = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply,
  over: over,
  memoize: memoize
};
function curry$(f, bound) {
  var context,
			_curry = function _curry(args) {
	return f.length > 1 ? function () {
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
	} : f;
  };
  return _curry();
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var each,
	map,
	compact,
	filter,
	reject,
	partition,
	find,
	head,
	first,
	tail,
	last,
	initial,
	empty,
	reverse,
	unique,
	uniqueBy,
	fold,
	foldl,
	fold1,
	foldl1,
	foldr,
	foldr1,
	unfoldr,
	concat,
	concatMap,
	_flatten,
	difference,
	intersection,
	union,
	countBy,
	groupBy,
	andList,
	orList,
	any,
	all,
	sort,
	sortWith,
	sortBy,
	sum,
	product,
	mean,
	average,
	maximum,
	minimum,
	maximumBy,
	minimumBy,
	scan,
	scanl,
	scan1,
	scanl1,
	scanr,
	scanr1,
	slice,
	take,
	drop,
	splitAt,
	takeWhile,
	dropWhile,
	span,
	breakList,
	zip,
	zipWith,
	zipAll,
	zipAllWith,
	at,
	elemIndex,
	elemIndices,
	findIndex,
	findIndices,
	toString$ = {}.toString,
	slice$ = [].slice;
each = curry$(function (f, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	f(x);
  }
  return xs;
});
map = curry$(function (f, xs) {
  var i$,
			len$,
			x,
			results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	results$.push(f(x));
  }
  return results$;
});
compact = function compact(xs) {
  var i$,
			len$,
			x,
			results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (x) {
			results$.push(x);
	}
  }
  return results$;
};
filter = curry$(function (f, xs) {
  var i$,
			len$,
			x,
			results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (f(x)) {
			results$.push(x);
	}
  }
  return results$;
});
reject = curry$(function (f, xs) {
  var i$,
			len$,
			x,
			results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (!f(x)) {
			results$.push(x);
	}
  }
  return results$;
});
partition = curry$(function (f, xs) {
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	(f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function (f, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (f(x)) {
			return x;
	}
  }
});
head = first = function first(xs) {
  return xs[0];
};
tail = function tail(xs) {
  if (!xs.length) {
	return;
  }
  return xs.slice(1);
};
last = function last(xs) {
  return xs[xs.length - 1];
};
initial = function initial(xs) {
  if (!xs.length) {
	return;
  }
  return xs.slice(0, -1);
};
empty = function empty(xs) {
  return !xs.length;
};
reverse = function reverse(xs) {
  return xs.concat().reverse();
};
unique = function unique(xs) {
  var result, i$, len$, x;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (!in$(x, result)) {
			result.push(x);
	}
  }
  return result;
};
uniqueBy = curry$(function (f, xs) {
  var seen,
			i$,
			len$,
			x,
			val,
			results$ = [];
  seen = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	val = f(x);
	if (in$(val, seen)) {
			continue;
	}
	seen.push(val);
	results$.push(x);
  }
  return results$;
});
fold = foldl = curry$(function (f, memo, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function (f, xs) {
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function (f, memo, xs) {
  var i$, x;
  for (i$ = xs.length - 1; i$ >= 0; --i$) {
	x = xs[i$];
	memo = f(x, memo);
  }
  return memo;
});
foldr1 = curry$(function (f, xs) {
  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
});
unfoldr = curry$(function (f, b) {
  var result, x, that;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
	result.push(that[0]);
	x = that[1];
  }
  return result;
});
concat = function concat(xss) {
  return [].concat.apply([], xss);
};
concatMap = curry$(function (f, xs) {
  var x;
  return [].concat.apply([], function () {
	var i$,
		ref$,
		len$,
		results$ = [];
	for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
			x = ref$[i$];
			results$.push(f(x));
	}
	return results$;
  }());
});
_flatten = function flatten(xs) {
  var x;
  return [].concat.apply([], function () {
	var i$,
		ref$,
		len$,
		results$ = [];
	for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
			x = ref$[i$];
			if (toString$.call(x).slice(8, -1) === 'Array') {
		results$.push(_flatten(x));
			} else {
		results$.push(x);
			}
	}
	return results$;
  }());
};
difference = function difference(xs) {
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
			ys = yss[j$];
			if (in$(x, ys)) {
		continue outer;
			}
	}
	results.push(x);
  }
  return results;
};
intersection = function intersection(xs) {
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
			ys = yss[j$];
			if (!in$(x, ys)) {
		continue outer;
			}
	}
	results.push(x);
  }
  return results;
};
union = function union() {
  var xss, results, i$, len$, xs, j$, len1$, x;
  xss = slice$.call(arguments);
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
	xs = xss[i$];
	for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
			x = xs[j$];
			if (!in$(x, results)) {
		results.push(x);
			}
	}
  }
  return results;
};
countBy = curry$(function (f, xs) {
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	key = f(x);
	if (key in results) {
			results[key] += 1;
	} else {
			results[key] = 1;
	}
  }
  return results;
});
groupBy = curry$(function (f, xs) {
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	key = f(x);
	if (key in results) {
			results[key].push(x);
	} else {
			results[key] = [x];
	}
  }
  return results;
});
andList = function andList(xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (!x) {
			return false;
	}
  }
  return true;
};
orList = function orList(xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (x) {
			return true;
	}
  }
  return false;
};
any = curry$(function (f, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (f(x)) {
			return true;
	}
  }
  return false;
});
all = curry$(function (f, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (!f(x)) {
			return false;
	}
  }
  return true;
});
sort = function sort(xs) {
  return xs.concat().sort(function (x, y) {
	if (x > y) {
			return 1;
	} else if (x < y) {
			return -1;
	} else {
			return 0;
	}
  });
};
sortWith = curry$(function (f, xs) {
  return xs.concat().sort(f);
});
sortBy = curry$(function (f, xs) {
  return xs.concat().sort(function (x, y) {
	if (f(x) > f(y)) {
			return 1;
	} else if (f(x) < f(y)) {
			return -1;
	} else {
			return 0;
	}
  });
});
sum = function sum(xs) {
  var result, i$, len$, x;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	result += x;
  }
  return result;
};
product = function product(xs) {
  var result, i$, len$, x;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	result *= x;
  }
  return result;
};
mean = average = function average(xs) {
  var sum, i$, len$, x;
  sum = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	sum += x;
  }
  return sum / xs.length;
};
maximum = function maximum(xs) {
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
	x = ref$[i$];
	if (x > max) {
			max = x;
	}
  }
  return max;
};
minimum = function minimum(xs) {
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
	x = ref$[i$];
	if (x < min) {
			min = x;
	}
  }
  return min;
};
maximumBy = curry$(function (f, xs) {
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
	x = ref$[i$];
	if (f(x) > f(max)) {
			max = x;
	}
  }
  return max;
});
minimumBy = curry$(function (f, xs) {
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
	x = ref$[i$];
	if (f(x) < f(min)) {
			min = x;
	}
  }
  return min;
});
scan = scanl = curry$(function (f, memo, xs) {
  var last, x;
  last = memo;
  return [memo].concat(function () {
	var i$,
		ref$,
		len$,
		results$ = [];
	for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
			x = ref$[i$];
			results$.push(last = f(last, x));
	}
	return results$;
  }());
});
scan1 = scanl1 = curry$(function (f, xs) {
  if (!xs.length) {
	return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function (f, memo, xs) {
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function (f, xs) {
  if (!xs.length) {
	return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function (x, y, xs) {
  return xs.slice(x, y);
});
take = curry$(function (n, xs) {
  if (n <= 0) {
	return xs.slice(0, 0);
  } else {
	return xs.slice(0, n);
  }
});
drop = curry$(function (n, xs) {
  if (n <= 0) {
	return xs;
  } else {
	return xs.slice(n);
  }
});
splitAt = curry$(function (n, xs) {
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function (p, xs) {
  var len, i;
  len = xs.length;
  if (!len) {
	return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
	i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function (p, xs) {
  var len, i;
  len = xs.length;
  if (!len) {
	return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
	i += 1;
  }
  return xs.slice(i);
});
span = curry$(function (p, xs) {
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function (p, xs) {
  return span(compose$(p, not$), xs);
});
zip = curry$(function (xs, ys) {
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	i = i$;
	x = xs[i$];
	if (i === len) {
			break;
	}
	result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function (f, xs, ys) {
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	i = i$;
	x = xs[i$];
	if (i === len) {
			break;
	}
	result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function zipAll() {
  var xss,
			minLength,
			i$,
			len$,
			xs,
			ref$,
			i,
			lresult$,
			j$,
			results$ = [];
  xss = slice$.call(arguments);
  minLength = undefined;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
	xs = xss[i$];
	minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
	i = i$;
	lresult$ = [];
	for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
			xs = xss[j$];
			lresult$.push(xs[i]);
	}
	results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function zipAllWith(f) {
  var xss,
			minLength,
			i$,
			len$,
			xs,
			ref$,
			i,
			results$ = [];
  xss = slice$.call(arguments, 1);
  minLength = undefined;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
	xs = xss[i$];
	minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
	i = i$;
	results$.push(f.apply(null, fn$()));
  }
  return results$;
  function fn$() {
	var i$,
		ref$,
		len$,
		results$ = [];
	for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
			xs = ref$[i$];
			results$.push(xs[i]);
	}
	return results$;
  }
};
at = curry$(function (n, xs) {
  if (n < 0) {
	return xs[xs.length + n];
  } else {
	return xs[n];
  }
});
elemIndex = curry$(function (el, xs) {
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	i = i$;
	x = xs[i$];
	if (x === el) {
			return i;
	}
  }
});
elemIndices = curry$(function (el, xs) {
  var i$,
			len$,
			i,
			x,
			results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	i = i$;
	x = xs[i$];
	if (x === el) {
			results$.push(i);
	}
  }
  return results$;
});
findIndex = curry$(function (f, xs) {
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	i = i$;
	x = xs[i$];
	if (f(x)) {
			return i;
	}
  }
});
findIndices = curry$(function (f, xs) {
  var i$,
			len$,
			i,
			x,
			results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	i = i$;
	x = xs[i$];
	if (f(x)) {
			results$.push(i);
	}
  }
  return results$;
});
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  uniqueBy: uniqueBy,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: _flatten,
  maximum: maximum,
  minimum: minimum,
  maximumBy: maximumBy,
  minimumBy: minimumBy,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith,
  at: at,
  elemIndex: elemIndex,
  elemIndices: elemIndices,
  findIndex: findIndex,
  findIndices: findIndices
};
function curry$(f, bound) {
  var context,
			_curry = function _curry(args) {
	return f.length > 1 ? function () {
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
	} : f;
  };
  return _curry();
}
function in$(x, xs) {
  var i = -1,
			l = xs.length >>> 0;
  while (++i < l) {
	if (x === xs[i]) return true;
  }return false;
}
function compose$() {
  var functions = arguments;
  return function () {
	var i, result;
	result = functions[0].apply(this, arguments);
	for (i = 1; i < functions.length; ++i) {
			result = functions[i](result);
	}
	return result;
  };
}
function not$(x) {
  return !x;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
values = function values(object) {
  var i$,
			x,
			results$ = [];
  for (i$ in object) {
	x = object[i$];
	results$.push(x);
  }
  return results$;
};
keys = function keys(object) {
  var x,
			results$ = [];
  for (x in object) {
	results$.push(x);
  }
  return results$;
};
pairsToObj = function pairsToObj(object) {
  var i$,
			len$,
			x,
			resultObj$ = {};
  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
	x = object[i$];
	resultObj$[x[0]] = x[1];
  }
  return resultObj$;
};
objToPairs = function objToPairs(object) {
  var key,
			value,
			results$ = [];
  for (key in object) {
	value = object[key];
	results$.push([key, value]);
  }
  return results$;
};
listsToObj = curry$(function (keys, values) {
  var i$,
			len$,
			i,
			key,
			resultObj$ = {};
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
	i = i$;
	key = keys[i$];
	resultObj$[key] = values[i];
  }
  return resultObj$;
});
objToLists = function objToLists(object) {
  var keys, values, key, value;
  keys = [];
  values = [];
  for (key in object) {
	value = object[key];
	keys.push(key);
	values.push(value);
  }
  return [keys, values];
};
empty = function empty(object) {
  var x;
  for (x in object) {
	return false;
  }
  return true;
};
each = curry$(function (f, object) {
  var i$, x;
  for (i$ in object) {
	x = object[i$];
	f(x);
  }
  return object;
});
map = curry$(function (f, object) {
  var k,
			x,
			resultObj$ = {};
  for (k in object) {
	x = object[k];
	resultObj$[k] = f(x);
  }
  return resultObj$;
});
compact = function compact(object) {
  var k,
			x,
			resultObj$ = {};
  for (k in object) {
	x = object[k];
	if (x) {
			resultObj$[k] = x;
	}
  }
  return resultObj$;
};
filter = curry$(function (f, object) {
  var k,
			x,
			resultObj$ = {};
  for (k in object) {
	x = object[k];
	if (f(x)) {
			resultObj$[k] = x;
	}
  }
  return resultObj$;
});
reject = curry$(function (f, object) {
  var k,
			x,
			resultObj$ = {};
  for (k in object) {
	x = object[k];
	if (!f(x)) {
			resultObj$[k] = x;
	}
  }
  return resultObj$;
});
partition = curry$(function (f, object) {
  var passed, failed, k, x;
  passed = {};
  failed = {};
  for (k in object) {
	x = object[k];
	(f(x) ? passed : failed)[k] = x;
  }
  return [passed, failed];
});
find = curry$(function (f, object) {
  var i$, x;
  for (i$ in object) {
	x = object[i$];
	if (f(x)) {
			return x;
	}
  }
});
module.exports = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};
function curry$(f, bound) {
  var context,
			_curry = function _curry(args) {
	return f.length > 1 ? function () {
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
	} : f;
  };
  return _curry();
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
split = curry$(function (sep, str) {
  return str.split(sep);
});
join = curry$(function (sep, xs) {
  return xs.join(sep);
});
lines = function lines(str) {
  if (!str.length) {
	return [];
  }
  return str.split('\n');
};
unlines = function unlines(it) {
  return it.join('\n');
};
words = function words(str) {
  if (!str.length) {
	return [];
  }
  return str.split(/[ ]+/);
};
unwords = function unwords(it) {
  return it.join(' ');
};
chars = function chars(it) {
  return it.split('');
};
unchars = function unchars(it) {
  return it.join('');
};
reverse = function reverse(str) {
  return str.split('').reverse().join('');
};
repeat = curry$(function (n, str) {
  var result, i$;
  result = '';
  for (i$ = 0; i$ < n; ++i$) {
	result += str;
  }
  return result;
});
capitalize = function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};
camelize = function camelize(it) {
  return it.replace(/[-_]+(.)?/g, function (arg$, c) {
	return (c != null ? c : '').toUpperCase();
  });
};
dasherize = function dasherize(str) {
  return str.replace(/([^-A-Z])([A-Z]+)/g, function (arg$, lower, upper) {
	return lower + "-" + (upper.length > 1 ? upper : upper.toLowerCase());
  }).replace(/^([A-Z]+)/, function (arg$, upper) {
	if (upper.length > 1) {
			return upper + "-";
	} else {
			return upper.toLowerCase();
	}
  });
};
module.exports = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat,
  capitalize: capitalize,
  camelize: camelize,
  dasherize: dasherize
};
function curry$(f, bound) {
  var context,
			_curry = function _curry(args) {
	return f.length > 1 ? function () {
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
	} : f;
  };
  return _curry();
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$(function (x$, y$) {
  return x$ > y$ ? x$ : y$;
});
min = curry$(function (x$, y$) {
  return x$ < y$ ? x$ : y$;
});
negate = function negate(x) {
  return -x;
};
abs = Math.abs;
signum = function signum(x) {
  if (x < 0) {
	return -1;
  } else if (x > 0) {
	return 1;
  } else {
	return 0;
  }
};
quot = curry$(function (x, y) {
  return ~~(x / y);
});
rem = curry$(function (x$, y$) {
  return x$ % y$;
});
div = curry$(function (x, y) {
  return Math.floor(x / y);
});
mod = curry$(function (x$, y$) {
  var ref$;
  return (x$ % (ref$ = y$) + ref$) % ref$;
});
recip = function recip(it) {
  return 1 / it;
};
pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$(function (x$, y$) {
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$(function (x, y) {
  return Math.atan2(x, y);
});
truncate = function truncate(x) {
  return ~~x;
};
round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;
isItNaN = function isItNaN(x) {
  return x !== x;
};
even = function even(x) {
  return x % 2 === 0;
};
odd = function odd(x) {
  return x % 2 !== 0;
};
gcd = curry$(function (x, y) {
  var z;
  x = Math.abs(x);
  y = Math.abs(y);
  while (y !== 0) {
	z = x % y;
	x = y;
	y = z;
  }
  return x;
});
lcm = curry$(function (x, y) {
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
module.exports = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};
function curry$(f, bound) {
  var context,
			_curry = function _curry(args) {
	return f.length > 1 ? function () {
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
	} : f;
  };
  return _curry();
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
  var parsedTypeCheck,
			types,
			toString$ = {}.toString;
  parsedTypeCheck = __webpack_require__(156).parsedTypeCheck;
  types = {
	'*': function _(value, options) {
			switch (toString$.call(value).slice(8, -1)) {
		case 'Array':
					return typeCast(value, {
			type: 'Array'
					}, options);
		case 'Object':
					return typeCast(value, {
			type: 'Object'
					}, options);
		default:
					return {
			type: 'Just',
			value: typesCast(value, [{
							type: 'Undefined'
			}, {
							type: 'Null'
			}, {
							type: 'NaN'
			}, {
							type: 'Boolean'
			}, {
							type: 'Number'
			}, {
							type: 'Date'
			}, {
							type: 'RegExp'
			}, {
							type: 'Array'
			}, {
							type: 'Object'
			}, {
							type: 'String'
			}], (options.explicit = true, options))
					};
			}
	},
	Undefined: function Undefined(it) {
			if (it === 'undefined' || it === void 8) {
		return {
					type: 'Just',
					value: void 8
		};
			} else {
		return {
					type: 'Nothing'
		};
			}
	},
	Null: function Null(it) {
			if (it === 'null') {
		return {
					type: 'Just',
					value: null
		};
			} else {
		return {
					type: 'Nothing'
		};
			}
	},
	NaN: function (_NaN) {
			function NaN(_x) {
		return _NaN.apply(this, arguments);
			}

			NaN.toString = function () {
		return _NaN.toString();
			};

			return NaN;
	}(function (it) {
			if (it === 'NaN') {
		return {
					type: 'Just',
					value: NaN
		};
			} else {
		return {
					type: 'Nothing'
		};
			}
	}),
	Boolean: function Boolean(it) {
			if (it === 'true') {
		return {
					type: 'Just',
					value: true
		};
			} else if (it === 'false') {
		return {
					type: 'Just',
					value: false
		};
			} else {
		return {
					type: 'Nothing'
		};
			}
	},
	Number: function Number(it) {
			return {
		type: 'Just',
		value: +it
			};
	},
	Int: function Int(it) {
			return {
		type: 'Just',
		value: +it
			};
	},
	Float: function Float(it) {
			return {
		type: 'Just',
		value: +it
			};
	},
	Date: function (_Date) {
			function Date(_x2, _x3) {
		return _Date.apply(this, arguments);
			}

			Date.toString = function () {
		return _Date.toString();
			};

			return Date;
	}(function (value, options) {
			var that;
			if (that = /^\#([\s\S]*)\#$/.exec(value)) {
		return {
					type: 'Just',
					value: new Date(+that[1] || that[1])
		};
			} else if (options.explicit) {
		return {
					type: 'Nothing'
		};
			} else {
		return {
					type: 'Just',
					value: new Date(+value || value)
		};
			}
	}),
	RegExp: function (_RegExp) {
			function RegExp(_x4, _x5) {
		return _RegExp.apply(this, arguments);
			}

			RegExp.toString = function () {
		return _RegExp.toString();
			};

			return RegExp;
	}(function (value, options) {
			var that;
			if (that = /^\/([\s\S]*)\/([gimy]*)$/.exec(value)) {
		return {
					type: 'Just',
					value: new RegExp(that[1], that[2])
		};
			} else if (options.explicit) {
		return {
					type: 'Nothing'
		};
			} else {
		return {
					type: 'Just',
					value: new RegExp(value)
		};
			}
	}),
	Array: function Array(value, options) {
			return castArray(value, {
		of: [{
					type: '*'
		}]
			}, options);
	},
	Object: function Object(value, options) {
			return castFields(value, {
		of: {}
			}, options);
	},
	String: function String(it) {
			var that;
			if (toString$.call(it).slice(8, -1) !== 'String') {
		return {
					type: 'Nothing'
		};
			}
			if (that = it.match(/^'([\s\S]*)'$/)) {
		return {
					type: 'Just',
					value: that[1].replace(/\\'/g, "'")
		};
			} else if (that = it.match(/^"([\s\S]*)"$/)) {
		return {
					type: 'Just',
					value: that[1].replace(/\\"/g, '"')
		};
			} else {
		return {
					type: 'Just',
					value: it
		};
			}
	}
  };
  function castArray(node, type, options) {
	var typeOf, element;
	if (toString$.call(node).slice(8, -1) !== 'Array') {
			return {
		type: 'Nothing'
			};
	}
	typeOf = type.of;
	return {
			type: 'Just',
			value: function () {
		var i$,
			ref$,
			len$,
			results$ = [];
		for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {
					element = ref$[i$];
					results$.push(typesCast(element, typeOf, options));
		}
		return results$;
			}()
	};
  }
  function castTuple(node, type, options) {
	var result, i, i$, ref$, len$, types, cast;
	if (toString$.call(node).slice(8, -1) !== 'Array') {
			return {
		type: 'Nothing'
			};
	}
	result = [];
	i = 0;
	for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
			types = ref$[i$];
			cast = typesCast(node[i], types, options);
			if (toString$.call(cast).slice(8, -1) !== 'Undefined') {
		result.push(cast);
			}
			i++;
	}
	if (node.length <= i) {
			return {
		type: 'Just',
		value: result
			};
	} else {
			return {
		type: 'Nothing'
			};
	}
  }
  function castFields(node, type, options) {
	var typeOf, key, value;
	if (toString$.call(node).slice(8, -1) !== 'Object') {
			return {
		type: 'Nothing'
			};
	}
	typeOf = type.of;
	return {
			type: 'Just',
			value: function () {
		var ref$,
			resultObj$ = {};
		for (key in ref$ = node) {
					value = ref$[key];
					resultObj$[typesCast(key, [{
			type: 'String'
					}], options)] = typesCast(value, typeOf[key] || [{
			type: '*'
					}], options);
		}
		return resultObj$;
			}()
	};
  }
  function typeCast(node, typeObj, options) {
	var type, structure, castFunc, ref$;
	type = typeObj.type, structure = typeObj.structure;
	if (type) {
			castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 8) || types[type];
			if (!castFunc) {
		throw new Error("Type not defined: " + type + ".");
			}
			return castFunc(node, options, typesCast);
	} else {
			switch (structure) {
		case 'array':
					return castArray(node, typeObj, options);
		case 'tuple':
					return castTuple(node, typeObj, options);
		case 'fields':
					return castFields(node, typeObj, options);
			}
	}
  }
  function typesCast(node, types, options) {
	var i$, len$, type, ref$, valueType, value;
	for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {
			type = types[i$];
			ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;
			if (valueType === 'Nothing') {
		continue;
			}
			if (parsedTypeCheck([type], value, {
		customTypes: options.customTypes
			})) {
		return value;
			}
	}
	throw new Error("Value " + JSON.stringify(node) + " does not type check against " + JSON.stringify(types) + ".");
  }
  module.exports = typesCast;
}).call(undefined);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
  var identifierRegex, tokenRegex;
  identifierRegex = /[\$\w]+/;
  function peek(tokens) {
	var token;
	token = tokens[0];
	if (token == null) {
			throw new Error('Unexpected end of input.');
	}
	return token;
  }
  function consumeIdent(tokens) {
	var token;
	token = peek(tokens);
	if (!identifierRegex.test(token)) {
			throw new Error("Expected text, got '" + token + "' instead.");
	}
	return tokens.shift();
  }
  function consumeOp(tokens, op) {
	var token;
	token = peek(tokens);
	if (token !== op) {
			throw new Error("Expected '" + op + "', got '" + token + "' instead.");
	}
	return tokens.shift();
  }
  function maybeConsumeOp(tokens, op) {
	var token;
	token = tokens[0];
	if (token === op) {
			return tokens.shift();
	} else {
			return null;
	}
  }
  function consumeArray(tokens) {
	var types;
	consumeOp(tokens, '[');
	if (peek(tokens) === ']') {
			throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
	}
	types = consumeTypes(tokens);
	consumeOp(tokens, ']');
	return {
			structure: 'array',
			of: types
	};
  }
  function consumeTuple(tokens) {
	var components;
	components = [];
	consumeOp(tokens, '(');
	if (peek(tokens) === ')') {
			throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
	}
	for (;;) {
			components.push(consumeTypes(tokens));
			maybeConsumeOp(tokens, ',');
			if (')' === peek(tokens)) {
		break;
			}
	}
	consumeOp(tokens, ')');
	return {
			structure: 'tuple',
			of: components
	};
  }
  function consumeFields(tokens) {
	var fields, subset, ref$, key, types;
	fields = {};
	consumeOp(tokens, '{');
	subset = false;
	for (;;) {
			if (maybeConsumeOp(tokens, '...')) {
		subset = true;
		break;
			}
			ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];
			fields[key] = types;
			maybeConsumeOp(tokens, ',');
			if ('}' === peek(tokens)) {
		break;
			}
	}
	consumeOp(tokens, '}');
	return {
			structure: 'fields',
			of: fields,
			subset: subset
	};
  }
  function consumeField(tokens) {
	var key, types;
	key = consumeIdent(tokens);
	consumeOp(tokens, ':');
	types = consumeTypes(tokens);
	return [key, types];
  }
  function maybeConsumeStructure(tokens) {
	switch (tokens[0]) {
			case '[':
		return consumeArray(tokens);
			case '(':
		return consumeTuple(tokens);
			case '{':
		return consumeFields(tokens);
	}
  }
  function consumeType(tokens) {
	var token, wildcard, type, structure;
	token = peek(tokens);
	wildcard = token === '*';
	if (wildcard || identifierRegex.test(token)) {
			type = wildcard ? consumeOp(tokens, '*') : consumeIdent(tokens);
			structure = maybeConsumeStructure(tokens);
			if (structure) {
		return structure.type = type, structure;
			} else {
		return {
					type: type
		};
			}
	} else {
			structure = maybeConsumeStructure(tokens);
			if (!structure) {
		throw new Error("Unexpected character: " + token);
			}
			return structure;
	}
  }
  function consumeTypes(tokens) {
	var lookahead, types, typesSoFar, typeObj, type;
	if ('::' === peek(tokens)) {
			throw new Error("No comment before comment separator '::' found.");
	}
	lookahead = tokens[1];
	if (lookahead != null && lookahead === '::') {
			tokens.shift();
			tokens.shift();
	}
	types = [];
	typesSoFar = {};
	if ('Maybe' === peek(tokens)) {
			tokens.shift();
			types = [{
		type: 'Undefined'
			}, {
		type: 'Null'
			}];
			typesSoFar = {
		Undefined: true,
		Null: true
			};
	}
	for (;;) {
			typeObj = consumeType(tokens), type = typeObj.type;
			if (!typesSoFar[type]) {
		types.push(typeObj);
			}
			typesSoFar[type] = true;
			if (!maybeConsumeOp(tokens, '|')) {
		break;
			}
	}
	return types;
  }
  tokenRegex = RegExp('\\.\\.\\.|::|->|' + identifierRegex.source + '|\\S', 'g');
  module.exports = function (input) {
	var tokens, e;
	if (!input.length) {
			throw new Error('No type specified.');
	}
	tokens = input.match(tokenRegex) || [];
	if (in$('->', tokens)) {
			throw new Error("Function types are not supported.\ To validate that something is a function, you may use 'Function'.");
	}
	try {
			return consumeTypes(tokens);
	} catch (e$) {
			e = e$;
			throw new Error(e.message + " - Remaining tokens: " + JSON.stringify(tokens) + " - Initial input: '" + input + "'");
	}
  };
  function in$(x, xs) {
	var i = -1,
		l = xs.length >>> 0;
	while (++i < l) {
			if (x === xs[i]) return true;
	}return false;
  }
}).call(undefined);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
  var ref$,
			any,
			all,
			isItNaN,
			types,
			defaultType,
			customTypes,
			toString$ = {}.toString;
  ref$ = __webpack_require__(155), any = ref$.any, all = ref$.all, isItNaN = ref$.isItNaN;
  types = {
	Number: {
			typeOf: 'Number',
			validate: function validate(it) {
		return !isItNaN(it);
			}
	},
	NaN: {
			typeOf: 'Number',
			validate: isItNaN
	},
	Int: {
			typeOf: 'Number',
			validate: function validate(it) {
		return !isItNaN(it) && it % 1 === 0;
			}
	},
	Float: {
			typeOf: 'Number',
			validate: function validate(it) {
		return !isItNaN(it);
			}
	},
	Date: {
			typeOf: 'Date',
			validate: function validate(it) {
		return !isItNaN(it.getTime());
			}
	}
  };
  defaultType = {
	array: 'Array',
	tuple: 'Array'
  };
  function checkArray(input, type) {
	return all(function (it) {
			return checkMultiple(it, type.of);
	}, input);
  }
  function checkTuple(input, type) {
	var i, i$, ref$, len$, types;
	i = 0;
	for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
			types = ref$[i$];
			if (!checkMultiple(input[i], types)) {
		return false;
			}
			i++;
	}
	return input.length <= i;
  }
  function checkFields(input, type) {
	var inputKeys, numInputKeys, k, numOfKeys, key, ref$, types;
	inputKeys = {};
	numInputKeys = 0;
	for (k in input) {
			inputKeys[k] = true;
			numInputKeys++;
	}
	numOfKeys = 0;
	for (key in ref$ = type.of) {
			types = ref$[key];
			if (!checkMultiple(input[key], types)) {
		return false;
			}
			if (inputKeys[key]) {
		numOfKeys++;
			}
	}
	return type.subset || numInputKeys === numOfKeys;
  }
  function checkStructure(input, type) {
	if (!(input instanceof Object)) {
			return false;
	}
	switch (type.structure) {
			case 'fields':
		return checkFields(input, type);
			case 'array':
		return checkArray(input, type);
			case 'tuple':
		return checkTuple(input, type);
	}
  }
  function check(input, typeObj) {
	var type, structure, setting, that;
	type = typeObj.type, structure = typeObj.structure;
	if (type) {
			if (type === '*') {
		return true;
			}
			setting = customTypes[type] || types[type];
			if (setting) {
		return setting.typeOf === toString$.call(input).slice(8, -1) && setting.validate(input);
			} else {
		return type === toString$.call(input).slice(8, -1) && (!structure || checkStructure(input, typeObj));
			}
	} else if (structure) {
			if (that = defaultType[structure]) {
		if (that !== toString$.call(input).slice(8, -1)) {
					return false;
		}
			}
			return checkStructure(input, typeObj);
	} else {
			throw new Error("No type defined. Input: " + input + ".");
	}
  }
  function checkMultiple(input, types) {
	if (toString$.call(types).slice(8, -1) !== 'Array') {
			throw new Error("Types must be in an array. Input: " + input + ".");
	}
	return any(function (it) {
			return check(input, it);
	}, types);
  }
  module.exports = function (parsedType, input, options) {
	options == null && (options = {});
	customTypes = options.customTypes || {};
	return checkMultiple(input, parsedType);
  };
}).call(undefined);
 }),
 (function(module, exports) {

module.exports = {"type":"Program","body":[],"sourceType":"script","range":[0,0],"loc":{"start":{"line":0,"column":0},"end":{"line":0,"column":0}},"comments":[],"tokens":[]}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function deepFreeze(obj) {
	if (obj === null || (typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== "object") {
		return obj;
	}

	Object.keys(obj).map(function (key) {
		return obj[key];
	}).forEach(deepFreeze);
	return Object.freeze(obj);
}

module.exports = deepFreeze({
	env: {},
	globals: {},
	rules: {},
	settings: {},
	parser: "espree",
	parserOptions: {}
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CodePath = __webpack_require__(351),
	CodePathSegment = __webpack_require__(102),
	IdGenerator = __webpack_require__(159),
	debug = __webpack_require__(158),
	astUtils = __webpack_require__(0);
function isCaseNode(node) {
	return Boolean(node.test);
}
function isForkingByTrueOrFalse(node) {
	var parent = node.parent;

	switch (parent.type) {
		case "ConditionalExpression":
		case "IfStatement":
		case "WhileStatement":
		case "DoWhileStatement":
		case "ForStatement":
			return parent.test === node;

		case "LogicalExpression":
			return true;

		default:
			return false;
	}
}
function getBooleanValueIfSimpleConstant(node) {
	if (node.type === "Literal") {
		return Boolean(node.value);
	}
	return void 0;
}
function isIdentifierReference(node) {
	var parent = node.parent;

	switch (parent.type) {
		case "LabeledStatement":
		case "BreakStatement":
		case "ContinueStatement":
		case "ArrayPattern":
		case "RestElement":
		case "ImportSpecifier":
		case "ImportDefaultSpecifier":
		case "ImportNamespaceSpecifier":
		case "CatchClause":
			return false;

		case "FunctionDeclaration":
		case "FunctionExpression":
		case "ArrowFunctionExpression":
		case "ClassDeclaration":
		case "ClassExpression":
		case "VariableDeclarator":
			return parent.id !== node;

		case "Property":
		case "MethodDefinition":
			return parent.key !== node || parent.computed || parent.shorthand;

		case "AssignmentPattern":
			return parent.key !== node;

		default:
			return true;
	}
}
function forwardCurrentToHead(analyzer, node) {
	var codePath = analyzer.codePath;
	var state = CodePath.getState(codePath);
	var currentSegments = state.currentSegments;
	var headSegments = state.headSegments;
	var end = Math.max(currentSegments.length, headSegments.length);
	var i = void 0,
		currentSegment = void 0,
		headSegment = void 0;
	for (i = 0; i < end; ++i) {
		currentSegment = currentSegments[i];
		headSegment = headSegments[i];

		if (currentSegment !== headSegment && currentSegment) {
			debug.dump("onCodePathSegmentEnd " + currentSegment.id);

			if (currentSegment.reachable) {
				analyzer.emitter.emit("onCodePathSegmentEnd", currentSegment, node);
			}
		}
	}
	state.currentSegments = headSegments;
	for (i = 0; i < end; ++i) {
		currentSegment = currentSegments[i];
		headSegment = headSegments[i];

		if (currentSegment !== headSegment && headSegment) {
			debug.dump("onCodePathSegmentStart " + headSegment.id);

			CodePathSegment.markUsed(headSegment);
			if (headSegment.reachable) {
				analyzer.emitter.emit("onCodePathSegmentStart", headSegment, node);
			}
		}
	}
}
function leaveFromCurrentSegment(analyzer, node) {
	var state = CodePath.getState(analyzer.codePath);
	var currentSegments = state.currentSegments;

	for (var i = 0; i < currentSegments.length; ++i) {
		var currentSegment = currentSegments[i];

		debug.dump("onCodePathSegmentEnd " + currentSegment.id);
		if (currentSegment.reachable) {
			analyzer.emitter.emit("onCodePathSegmentEnd", currentSegment, node);
		}
	}

	state.currentSegments = [];
}
function preprocess(analyzer, node) {
	var codePath = analyzer.codePath;
	var state = CodePath.getState(codePath);
	var parent = node.parent;

	switch (parent.type) {
		case "LogicalExpression":
			if (parent.right === node) {
				state.makeLogicalRight();
			}
			break;

		case "ConditionalExpression":
		case "IfStatement":
			if (parent.consequent === node) {
				state.makeIfConsequent();
			} else if (parent.alternate === node) {
				state.makeIfAlternate();
			}
			break;

		case "SwitchCase":
			if (parent.consequent[0] === node) {
				state.makeSwitchCaseBody(false, !parent.test);
			}
			break;

		case "TryStatement":
			if (parent.handler === node) {
				state.makeCatchBlock();
			} else if (parent.finalizer === node) {
				state.makeFinallyBlock();
			}
			break;

		case "WhileStatement":
			if (parent.test === node) {
				state.makeWhileTest(getBooleanValueIfSimpleConstant(node));
			} else {
				state.makeWhileBody();
			}
			break;

		case "DoWhileStatement":
			if (parent.body === node) {
				state.makeDoWhileBody();
			} else {
				state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));
			}
			break;

		case "ForStatement":
			if (parent.test === node) {
				state.makeForTest(getBooleanValueIfSimpleConstant(node));
			} else if (parent.update === node) {
				state.makeForUpdate();
			} else if (parent.body === node) {
				state.makeForBody();
			}
			break;

		case "ForInStatement":
		case "ForOfStatement":
			if (parent.left === node) {
				state.makeForInOfLeft();
			} else if (parent.right === node) {
				state.makeForInOfRight();
			} else {
				state.makeForInOfBody();
			}
			break;

		case "AssignmentPattern":
			if (parent.right === node) {
				state.pushForkContext();
				state.forkBypassPath();
				state.forkPath();
			}
			break;

		default:
			break;
	}
}
function processCodePathToEnter(analyzer, node) {
	var codePath = analyzer.codePath;
	var state = codePath && CodePath.getState(codePath);
	var parent = node.parent;

	switch (node.type) {
		case "Program":
		case "FunctionDeclaration":
		case "FunctionExpression":
		case "ArrowFunctionExpression":
			if (codePath) {
				forwardCurrentToHead(analyzer, node);
				debug.dumpState(node, state, false);
			}
			codePath = analyzer.codePath = new CodePath(analyzer.idGenerator.next(), codePath, analyzer.onLooped);
			state = CodePath.getState(codePath);
			debug.dump("onCodePathStart " + codePath.id);
			analyzer.emitter.emit("onCodePathStart", codePath, node);
			break;

		case "LogicalExpression":
			state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));
			break;

		case "ConditionalExpression":
		case "IfStatement":
			state.pushChoiceContext("test", false);
			break;

		case "SwitchStatement":
			state.pushSwitchContext(node.cases.some(isCaseNode), astUtils.getLabel(node));
			break;

		case "TryStatement":
			state.pushTryContext(Boolean(node.finalizer));
			break;

		case "SwitchCase":
			if (parent.discriminant !== node && parent.cases[0] !== node) {
				state.forkPath();
			}
			break;

		case "WhileStatement":
		case "DoWhileStatement":
		case "ForStatement":
		case "ForInStatement":
		case "ForOfStatement":
			state.pushLoopContext(node.type, astUtils.getLabel(node));
			break;

		case "LabeledStatement":
			if (!astUtils.isBreakableStatement(node.body)) {
				state.pushBreakContext(false, node.label.name);
			}
			break;

		default:
			break;
	}
	forwardCurrentToHead(analyzer, node);
	debug.dumpState(node, state, false);
}
function processCodePathToExit(analyzer, node) {
	var codePath = analyzer.codePath;
	var state = CodePath.getState(codePath);
	var dontForward = false;

	switch (node.type) {
		case "IfStatement":
		case "ConditionalExpression":
		case "LogicalExpression":
			state.popChoiceContext();
			break;

		case "SwitchStatement":
			state.popSwitchContext();
			break;

		case "SwitchCase":
			if (node.consequent.length === 0) {
				state.makeSwitchCaseBody(true, !node.test);
			}
			if (state.forkContext.reachable) {
				dontForward = true;
			}
			break;

		case "TryStatement":
			state.popTryContext();
			break;

		case "BreakStatement":
			forwardCurrentToHead(analyzer, node);
			state.makeBreak(node.label && node.label.name);
			dontForward = true;
			break;

		case "ContinueStatement":
			forwardCurrentToHead(analyzer, node);
			state.makeContinue(node.label && node.label.name);
			dontForward = true;
			break;

		case "ReturnStatement":
			forwardCurrentToHead(analyzer, node);
			state.makeReturn();
			dontForward = true;
			break;

		case "ThrowStatement":
			forwardCurrentToHead(analyzer, node);
			state.makeThrow();
			dontForward = true;
			break;

		case "Identifier":
			if (isIdentifierReference(node)) {
				state.makeFirstThrowablePathInTryBlock();
				dontForward = true;
			}
			break;

		case "CallExpression":
		case "MemberExpression":
		case "NewExpression":
			state.makeFirstThrowablePathInTryBlock();
			break;

		case "WhileStatement":
		case "DoWhileStatement":
		case "ForStatement":
		case "ForInStatement":
		case "ForOfStatement":
			state.popLoopContext();
			break;

		case "AssignmentPattern":
			state.popForkContext();
			break;

		case "LabeledStatement":
			if (!astUtils.isBreakableStatement(node.body)) {
				state.popBreakContext();
			}
			break;

		default:
			break;
	}
	if (!dontForward) {
		forwardCurrentToHead(analyzer, node);
	}
	debug.dumpState(node, state, true);
}
function postprocess(analyzer, node) {
	switch (node.type) {
		case "Program":
		case "FunctionDeclaration":
		case "FunctionExpression":
		case "ArrowFunctionExpression":
			{
				var codePath = analyzer.codePath;
				CodePath.getState(codePath).makeFinal();
				leaveFromCurrentSegment(analyzer, node);
				debug.dump("onCodePathEnd " + codePath.id);
				analyzer.emitter.emit("onCodePathEnd", codePath, node);
				debug.dumpDot(codePath);

				codePath = analyzer.codePath = analyzer.codePath.upper;
				if (codePath) {
					debug.dumpState(node, CodePath.getState(codePath), true);
				}
				break;
			}

		default:
			break;
	}
}

var CodePathAnalyzer = function () {
	function CodePathAnalyzer(eventGenerator) {
		_classCallCheck(this, CodePathAnalyzer);

		this.original = eventGenerator;
		this.emitter = eventGenerator.emitter;
		this.codePath = null;
		this.idGenerator = new IdGenerator("s");
		this.currentNode = null;
		this.onLooped = this.onLooped.bind(this);
	}


	_createClass(CodePathAnalyzer, [{
		key: "enterNode",
		value: function enterNode(node) {
			this.currentNode = node;
			if (node.parent) {
				preprocess(this, node);
			}
			processCodePathToEnter(this, node);
			this.original.enterNode(node);

			this.currentNode = null;
		}

	}, {
		key: "leaveNode",
		value: function leaveNode(node) {
			this.currentNode = node;
			processCodePathToExit(this, node);
			this.original.leaveNode(node);
			postprocess(this, node);

			this.currentNode = null;
		}

	}, {
		key: "onLooped",
		value: function onLooped(fromSegment, toSegment) {
			if (fromSegment.reachable && toSegment.reachable) {
				debug.dump("onCodePathSegmentLoop " + fromSegment.id + " -> " + toSegment.id);
				this.emitter.emit("onCodePathSegmentLoop", fromSegment, toSegment, this.currentNode);
			}
		}
	}]);

	return CodePathAnalyzer;
}();

module.exports = CodePathAnalyzer;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CodePathState = __webpack_require__(352);
var IdGenerator = __webpack_require__(159);

var CodePath = function () {
	function CodePath(id, upper, onLooped) {
		_classCallCheck(this, CodePath);
		this.id = id;
		this.upper = upper;
		this.childCodePaths = [];
		Object.defineProperty(this, "internal", { value: new CodePathState(new IdGenerator(id + "_"), onLooped) });
		if (upper) {
			upper.childCodePaths.push(this);
		}
	}


	_createClass(CodePath, [{
		key: "traverseSegments",
		value: function traverseSegments(options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = null;
			}

			options = options || {};
			var startSegment = options.first || this.internal.initialSegment;
			var lastSegment = options.last;

			var item = null;
			var index = 0;
			var end = 0;
			var segment = null;
			var visited = Object.create(null);
			var stack = [[startSegment, 0]];
			var skippedSegment = null;
			var broken = false;
			var controller = {
				skip: function skip() {
					if (stack.length <= 1) {
						broken = true;
					} else {
						skippedSegment = stack[stack.length - 2][0];
					}
				},
				break: function _break() {
					broken = true;
				}
			};
			function isVisited(prevSegment) {
				return visited[prevSegment.id] || segment.isLoopedPrevSegment(prevSegment);
			}

			while (stack.length > 0) {
				item = stack[stack.length - 1];
				segment = item[0];
				index = item[1];

				if (index === 0) {
					if (visited[segment.id]) {
						stack.pop();
						continue;
					}
					if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {
						stack.pop();
						continue;
					}
					if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {
						skippedSegment = null;
					}
					visited[segment.id] = true;
					if (!skippedSegment) {
						callback.call(this, segment, controller);
						if (segment === lastSegment) {
							controller.skip();
						}
						if (broken) {
							break;
						}
					}
				}
				end = segment.nextSegments.length - 1;
				if (index < end) {
					item[1] += 1;
					stack.push([segment.nextSegments[index], 0]);
				} else if (index === end) {
					item[0] = segment.nextSegments[index];
					item[1] = 0;
				} else {
					stack.pop();
				}
			}
		}
	}, {
		key: "initialSegment",
		get: function get() {
			return this.internal.initialSegment;
		}

	}, {
		key: "finalSegments",
		get: function get() {
			return this.internal.finalSegments;
		}

	}, {
		key: "returnedSegments",
		get: function get() {
			return this.internal.returnedForkContext;
		}

	}, {
		key: "thrownSegments",
		get: function get() {
			return this.internal.thrownForkContext;
		}

	}, {
		key: "currentSegments",
		get: function get() {
			return this.internal.currentSegments;
		}
	}], [{
		key: "getState",
		value: function getState(codePath) {
			return codePath.internal;
		}
	}]);

	return CodePath;
}();

module.exports = CodePath;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CodePathSegment = __webpack_require__(102),
	ForkContext = __webpack_require__(355);
function addToReturnedOrThrown(dest, others, all, segments) {
	for (var i = 0; i < segments.length; ++i) {
		var segment = segments[i];

		dest.push(segment);
		if (others.indexOf(segment) === -1) {
			all.push(segment);
		}
	}
}
function getContinueContext(state, label) {
	if (!label) {
		return state.loopContext;
	}

	var context = state.loopContext;

	while (context) {
		if (context.label === label) {
			return context;
		}
		context = context.upper;
	}
	return null;
}
function getBreakContext(state, label) {
	var context = state.breakContext;

	while (context) {
		if (label ? context.label === label : context.breakable) {
			return context;
		}
		context = context.upper;
	}
	return null;
}
function getReturnContext(state) {
	var context = state.tryContext;

	while (context) {
		if (context.hasFinalizer && context.position !== "finally") {
			return context;
		}
		context = context.upper;
	}

	return state;
}
function getThrowContext(state) {
	var context = state.tryContext;

	while (context) {
		if (context.position === "try" || context.hasFinalizer && context.position === "catch") {
			return context;
		}
		context = context.upper;
	}

	return state;
}
function remove(xs, x) {
	xs.splice(xs.indexOf(x), 1);
}
function removeConnection(prevSegments, nextSegments) {
	for (var i = 0; i < prevSegments.length; ++i) {
		var prevSegment = prevSegments[i];
		var nextSegment = nextSegments[i];

		remove(prevSegment.nextSegments, nextSegment);
		remove(prevSegment.allNextSegments, nextSegment);
		remove(nextSegment.prevSegments, prevSegment);
		remove(nextSegment.allPrevSegments, prevSegment);
	}
}
function makeLooped(state, fromSegments, toSegments) {
	fromSegments = CodePathSegment.flattenUnusedSegments(fromSegments);
	toSegments = CodePathSegment.flattenUnusedSegments(toSegments);

	var end = Math.min(fromSegments.length, toSegments.length);

	for (var i = 0; i < end; ++i) {
		var fromSegment = fromSegments[i];
		var toSegment = toSegments[i];

		if (toSegment.reachable) {
			fromSegment.nextSegments.push(toSegment);
		}
		if (fromSegment.reachable) {
			toSegment.prevSegments.push(fromSegment);
		}
		fromSegment.allNextSegments.push(toSegment);
		toSegment.allPrevSegments.push(fromSegment);

		if (toSegment.allPrevSegments.length >= 2) {
			CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
		}

		state.notifyLooped(fromSegment, toSegment);
	}
}
function finalizeTestSegmentsOfFor(context, choiceContext, head) {
	if (!choiceContext.processed) {
		choiceContext.trueForkContext.add(head);
		choiceContext.falseForkContext.add(head);
	}

	if (context.test !== true) {
		context.brokenForkContext.addAll(choiceContext.falseForkContext);
	}
	context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
}

var CodePathState = function () {
	function CodePathState(idGenerator, onLooped) {
		_classCallCheck(this, CodePathState);

		this.idGenerator = idGenerator;
		this.notifyLooped = onLooped;
		this.forkContext = ForkContext.newRoot(idGenerator);
		this.choiceContext = null;
		this.switchContext = null;
		this.tryContext = null;
		this.loopContext = null;
		this.breakContext = null;

		this.currentSegments = [];
		this.initialSegment = this.forkContext.head[0];
		var final = this.finalSegments = [];
		var returned = this.returnedForkContext = [];
		var thrown = this.thrownForkContext = [];

		returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
		thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
	}


	_createClass(CodePathState, [{
		key: "pushForkContext",
		value: function pushForkContext(forkLeavingPath) {
			this.forkContext = ForkContext.newEmpty(this.forkContext, forkLeavingPath);

			return this.forkContext;
		}

	}, {
		key: "popForkContext",
		value: function popForkContext() {
			var lastContext = this.forkContext;

			this.forkContext = lastContext.upper;
			this.forkContext.replaceHead(lastContext.makeNext(0, -1));

			return lastContext;
		}

	}, {
		key: "forkPath",
		value: function forkPath() {
			this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
		}

	}, {
		key: "forkBypassPath",
		value: function forkBypassPath() {
			this.forkContext.add(this.parentForkContext.head);
		}

	}, {
		key: "pushChoiceContext",
		value: function pushChoiceContext(kind, isForkingAsResult) {
			this.choiceContext = {
				upper: this.choiceContext,
				kind: kind,
				isForkingAsResult: isForkingAsResult,
				trueForkContext: ForkContext.newEmpty(this.forkContext),
				falseForkContext: ForkContext.newEmpty(this.forkContext),
				processed: false
			};
		}

	}, {
		key: "popChoiceContext",
		value: function popChoiceContext() {
			var context = this.choiceContext;

			this.choiceContext = context.upper;

			var forkContext = this.forkContext;
			var headSegments = forkContext.head;

			switch (context.kind) {
				case "&&":
				case "||":
					if (!context.processed) {
						context.trueForkContext.add(headSegments);
						context.falseForkContext.add(headSegments);
					}
					if (context.isForkingAsResult) {
						var parentContext = this.choiceContext;

						parentContext.trueForkContext.addAll(context.trueForkContext);
						parentContext.falseForkContext.addAll(context.falseForkContext);
						parentContext.processed = true;

						return context;
					}

					break;

				case "test":
					if (!context.processed) {
						context.trueForkContext.clear();
						context.trueForkContext.add(headSegments);
					} else {
						context.falseForkContext.clear();
						context.falseForkContext.add(headSegments);
					}

					break;

				case "loop":
					return context;
				default:
					throw new Error("unreachable");
			}
			var prevForkContext = context.trueForkContext;

			prevForkContext.addAll(context.falseForkContext);
			forkContext.replaceHead(prevForkContext.makeNext(0, -1));

			return context;
		}

	}, {
		key: "makeLogicalRight",
		value: function makeLogicalRight() {
			var context = this.choiceContext;
			var forkContext = this.forkContext;

			if (context.processed) {
				var prevForkContext = context.kind === "&&" ? context.trueForkContext
 : context.falseForkContext;

				forkContext.replaceHead(prevForkContext.makeNext(0, -1));
				prevForkContext.clear();

				context.processed = false;
			} else {
				if (context.kind === "&&") {
					context.falseForkContext.add(forkContext.head);
				} else {
					context.trueForkContext.add(forkContext.head);
				}

				forkContext.replaceHead(forkContext.makeNext(-1, -1));
			}
		}

	}, {
		key: "makeIfConsequent",
		value: function makeIfConsequent() {
			var context = this.choiceContext;
			var forkContext = this.forkContext;
			if (!context.processed) {
				context.trueForkContext.add(forkContext.head);
				context.falseForkContext.add(forkContext.head);
			}

			context.processed = false;
			forkContext.replaceHead(context.trueForkContext.makeNext(0, -1));
		}

	}, {
		key: "makeIfAlternate",
		value: function makeIfAlternate() {
			var context = this.choiceContext;
			var forkContext = this.forkContext;
			context.trueForkContext.clear();
			context.trueForkContext.add(forkContext.head);
			context.processed = true;
			forkContext.replaceHead(context.falseForkContext.makeNext(0, -1));
		}

	}, {
		key: "pushSwitchContext",
		value: function pushSwitchContext(hasCase, label) {
			this.switchContext = {
				upper: this.switchContext,
				hasCase: hasCase,
				defaultSegments: null,
				defaultBodySegments: null,
				foundDefault: false,
				lastIsDefault: false,
				countForks: 0
			};

			this.pushBreakContext(true, label);
		}

	}, {
		key: "popSwitchContext",
		value: function popSwitchContext() {
			var context = this.switchContext;

			this.switchContext = context.upper;

			var forkContext = this.forkContext;
			var brokenForkContext = this.popBreakContext().brokenForkContext;

			if (context.countForks === 0) {
				if (!brokenForkContext.empty) {
					brokenForkContext.add(forkContext.makeNext(-1, -1));
					forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
				}

				return;
			}

			var lastSegments = forkContext.head;

			this.forkBypassPath();
			var lastCaseSegments = forkContext.head;
			brokenForkContext.add(lastSegments);
			if (!context.lastIsDefault) {
				if (context.defaultBodySegments) {
					removeConnection(context.defaultSegments, context.defaultBodySegments);
					makeLooped(this, lastCaseSegments, context.defaultBodySegments);
				} else {
					brokenForkContext.add(lastCaseSegments);
				}
			}
			for (var i = 0; i < context.countForks; ++i) {
				this.forkContext = this.forkContext.upper;
			}
			this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
		}

	}, {
		key: "makeSwitchCaseBody",
		value: function makeSwitchCaseBody(isEmpty, isDefault) {
			var context = this.switchContext;

			if (!context.hasCase) {
				return;
			}
			var parentForkContext = this.forkContext;
			var forkContext = this.pushForkContext();

			forkContext.add(parentForkContext.makeNext(0, -1));
			if (isDefault) {
				context.defaultSegments = parentForkContext.head;
				if (isEmpty) {
					context.foundDefault = true;
				} else {
					context.defaultBodySegments = forkContext.head;
				}
			} else {
				if (!isEmpty && context.foundDefault) {
					context.foundDefault = false;
					context.defaultBodySegments = forkContext.head;
				}
			}

			context.lastIsDefault = isDefault;
			context.countForks += 1;
		}

	}, {
		key: "pushTryContext",
		value: function pushTryContext(hasFinalizer) {
			this.tryContext = {
				upper: this.tryContext,
				position: "try",
				hasFinalizer: hasFinalizer,

				returnedForkContext: hasFinalizer ? ForkContext.newEmpty(this.forkContext) : null,

				thrownForkContext: ForkContext.newEmpty(this.forkContext),
				lastOfTryIsReachable: false,
				lastOfCatchIsReachable: false
			};
		}

	}, {
		key: "popTryContext",
		value: function popTryContext() {
			var context = this.tryContext;

			this.tryContext = context.upper;

			if (context.position === "catch") {
				this.popForkContext();
				return;
			}

			var returned = context.returnedForkContext;
			var thrown = context.thrownForkContext;

			if (returned.empty && thrown.empty) {
				return;
			}
			var headSegments = this.forkContext.head;

			this.forkContext = this.forkContext.upper;
			var normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);
			var leavingSegments = headSegments.slice(headSegments.length / 2 | 0);
			if (!returned.empty) {
				getReturnContext(this).returnedForkContext.add(leavingSegments);
			}
			if (!thrown.empty) {
				getThrowContext(this).thrownForkContext.add(leavingSegments);
			}
			this.forkContext.replaceHead(normalSegments);
			if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {
				this.forkContext.makeUnreachable();
			}
		}

	}, {
		key: "makeCatchBlock",
		value: function makeCatchBlock() {
			var context = this.tryContext;
			var forkContext = this.forkContext;
			var thrown = context.thrownForkContext;
			context.position = "catch";
			context.thrownForkContext = ForkContext.newEmpty(forkContext);
			context.lastOfTryIsReachable = forkContext.reachable;
			thrown.add(forkContext.head);
			var thrownSegments = thrown.makeNext(0, -1);
			this.pushForkContext();
			this.forkBypassPath();
			this.forkContext.add(thrownSegments);
		}

	}, {
		key: "makeFinallyBlock",
		value: function makeFinallyBlock() {
			var context = this.tryContext;
			var forkContext = this.forkContext;
			var returned = context.returnedForkContext;
			var thrown = context.thrownForkContext;
			var headOfLeavingSegments = forkContext.head;
			if (context.position === "catch") {
				this.popForkContext();
				forkContext = this.forkContext;

				context.lastOfCatchIsReachable = forkContext.reachable;
			} else {
				context.lastOfTryIsReachable = forkContext.reachable;
			}
			context.position = "finally";

			if (returned.empty && thrown.empty) {
				return;
			}
			var segments = forkContext.makeNext(-1, -1);

			for (var i = 0; i < forkContext.count; ++i) {
				var prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];

				for (var j = 0; j < returned.segmentsList.length; ++j) {
					prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);
				}
				for (var _j = 0; _j < thrown.segmentsList.length; ++_j) {
					prevSegsOfLeavingSegment.push(thrown.segmentsList[_j][i]);
				}

				segments.push(CodePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));
			}

			this.pushForkContext(true);
			this.forkContext.add(segments);
		}

	}, {
		key: "makeFirstThrowablePathInTryBlock",
		value: function makeFirstThrowablePathInTryBlock() {
			var forkContext = this.forkContext;

			if (!forkContext.reachable) {
				return;
			}

			var context = getThrowContext(this);

			if (context === this || context.position !== "try" || !context.thrownForkContext.empty) {
				return;
			}

			context.thrownForkContext.add(forkContext.head);
			forkContext.replaceHead(forkContext.makeNext(-1, -1));
		}

	}, {
		key: "pushLoopContext",
		value: function pushLoopContext(type, label) {
			var forkContext = this.forkContext;
			var breakContext = this.pushBreakContext(true, label);

			switch (type) {
				case "WhileStatement":
					this.pushChoiceContext("loop", false);
					this.loopContext = {
						upper: this.loopContext,
						type: type,
						label: label,
						test: void 0,
						continueDestSegments: null,
						brokenForkContext: breakContext.brokenForkContext
					};
					break;

				case "DoWhileStatement":
					this.pushChoiceContext("loop", false);
					this.loopContext = {
						upper: this.loopContext,
						type: type,
						label: label,
						test: void 0,
						entrySegments: null,
						continueForkContext: ForkContext.newEmpty(forkContext),
						brokenForkContext: breakContext.brokenForkContext
					};
					break;

				case "ForStatement":
					this.pushChoiceContext("loop", false);
					this.loopContext = {
						upper: this.loopContext,
						type: type,
						label: label,
						test: void 0,
						endOfInitSegments: null,
						testSegments: null,
						endOfTestSegments: null,
						updateSegments: null,
						endOfUpdateSegments: null,
						continueDestSegments: null,
						brokenForkContext: breakContext.brokenForkContext
					};
					break;

				case "ForInStatement":
				case "ForOfStatement":
					this.loopContext = {
						upper: this.loopContext,
						type: type,
						label: label,
						prevSegments: null,
						leftSegments: null,
						endOfLeftSegments: null,
						continueDestSegments: null,
						brokenForkContext: breakContext.brokenForkContext
					};
					break;
				default:
					throw new Error("unknown type: \"" + type + "\"");
			}
		}

	}, {
		key: "popLoopContext",
		value: function popLoopContext() {
			var context = this.loopContext;

			this.loopContext = context.upper;

			var forkContext = this.forkContext;
			var brokenForkContext = this.popBreakContext().brokenForkContext;
			switch (context.type) {
				case "WhileStatement":
				case "ForStatement":
					this.popChoiceContext();
					makeLooped(this, forkContext.head, context.continueDestSegments);
					break;

				case "DoWhileStatement":
					{
						var choiceContext = this.popChoiceContext();

						if (!choiceContext.processed) {
							choiceContext.trueForkContext.add(forkContext.head);
							choiceContext.falseForkContext.add(forkContext.head);
						}
						if (context.test !== true) {
							brokenForkContext.addAll(choiceContext.falseForkContext);
						}
						var segmentsList = choiceContext.trueForkContext.segmentsList;

						for (var i = 0; i < segmentsList.length; ++i) {
							makeLooped(this, segmentsList[i], context.entrySegments);
						}
						break;
					}

				case "ForInStatement":
				case "ForOfStatement":
					brokenForkContext.add(forkContext.head);
					makeLooped(this, forkContext.head, context.leftSegments);
					break;
				default:
					throw new Error("unreachable");
			}
			if (brokenForkContext.empty) {
				forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
			} else {
				forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
			}
		}

	}, {
		key: "makeWhileTest",
		value: function makeWhileTest(test) {
			var context = this.loopContext;
			var forkContext = this.forkContext;
			var testSegments = forkContext.makeNext(0, -1);
			context.test = test;
			context.continueDestSegments = testSegments;
			forkContext.replaceHead(testSegments);
		}

	}, {
		key: "makeWhileBody",
		value: function makeWhileBody() {
			var context = this.loopContext;
			var choiceContext = this.choiceContext;
			var forkContext = this.forkContext;

			if (!choiceContext.processed) {
				choiceContext.trueForkContext.add(forkContext.head);
				choiceContext.falseForkContext.add(forkContext.head);
			}
			if (context.test !== true) {
				context.brokenForkContext.addAll(choiceContext.falseForkContext);
			}
			forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
		}

	}, {
		key: "makeDoWhileBody",
		value: function makeDoWhileBody() {
			var context = this.loopContext;
			var forkContext = this.forkContext;
			var bodySegments = forkContext.makeNext(-1, -1);
			context.entrySegments = bodySegments;
			forkContext.replaceHead(bodySegments);
		}

	}, {
		key: "makeDoWhileTest",
		value: function makeDoWhileTest(test) {
			var context = this.loopContext;
			var forkContext = this.forkContext;

			context.test = test;
			if (!context.continueForkContext.empty) {
				context.continueForkContext.add(forkContext.head);
				var testSegments = context.continueForkContext.makeNext(0, -1);

				forkContext.replaceHead(testSegments);
			}
		}

	}, {
		key: "makeForTest",
		value: function makeForTest(test) {
			var context = this.loopContext;
			var forkContext = this.forkContext;
			var endOfInitSegments = forkContext.head;
			var testSegments = forkContext.makeNext(-1, -1);
			context.test = test;
			context.endOfInitSegments = endOfInitSegments;
			context.continueDestSegments = context.testSegments = testSegments;
			forkContext.replaceHead(testSegments);
		}

	}, {
		key: "makeForUpdate",
		value: function makeForUpdate() {
			var context = this.loopContext;
			var choiceContext = this.choiceContext;
			var forkContext = this.forkContext;
			if (context.testSegments) {
				finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);
			} else {
				context.endOfInitSegments = forkContext.head;
			}
			var updateSegments = forkContext.makeDisconnected(-1, -1);

			context.continueDestSegments = context.updateSegments = updateSegments;
			forkContext.replaceHead(updateSegments);
		}

	}, {
		key: "makeForBody",
		value: function makeForBody() {
			var context = this.loopContext;
			var choiceContext = this.choiceContext;
			var forkContext = this.forkContext;
			if (context.updateSegments) {
				context.endOfUpdateSegments = forkContext.head;
				if (context.testSegments) {
					makeLooped(this, context.endOfUpdateSegments, context.testSegments);
				}
			} else if (context.testSegments) {
				finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);
			} else {
				context.endOfInitSegments = forkContext.head;
			}

			var bodySegments = context.endOfTestSegments;

			if (!bodySegments) {
				var prevForkContext = ForkContext.newEmpty(forkContext);

				prevForkContext.add(context.endOfInitSegments);
				if (context.endOfUpdateSegments) {
					prevForkContext.add(context.endOfUpdateSegments);
				}

				bodySegments = prevForkContext.makeNext(0, -1);
			}
			context.continueDestSegments = context.continueDestSegments || bodySegments;
			forkContext.replaceHead(bodySegments);
		}

	}, {
		key: "makeForInOfLeft",
		value: function makeForInOfLeft() {
			var context = this.loopContext;
			var forkContext = this.forkContext;
			var leftSegments = forkContext.makeDisconnected(-1, -1);
			context.prevSegments = forkContext.head;
			context.leftSegments = context.continueDestSegments = leftSegments;
			forkContext.replaceHead(leftSegments);
		}

	}, {
		key: "makeForInOfRight",
		value: function makeForInOfRight() {
			var context = this.loopContext;
			var forkContext = this.forkContext;
			var temp = ForkContext.newEmpty(forkContext);

			temp.add(context.prevSegments);
			var rightSegments = temp.makeNext(-1, -1);
			context.endOfLeftSegments = forkContext.head;
			forkContext.replaceHead(rightSegments);
		}

	}, {
		key: "makeForInOfBody",
		value: function makeForInOfBody() {
			var context = this.loopContext;
			var forkContext = this.forkContext;
			var temp = ForkContext.newEmpty(forkContext);

			temp.add(context.endOfLeftSegments);
			var bodySegments = temp.makeNext(-1, -1);
			makeLooped(this, forkContext.head, context.leftSegments);
			context.brokenForkContext.add(forkContext.head);
			forkContext.replaceHead(bodySegments);
		}

	}, {
		key: "pushBreakContext",
		value: function pushBreakContext(breakable, label) {
			this.breakContext = {
				upper: this.breakContext,
				breakable: breakable,
				label: label,
				brokenForkContext: ForkContext.newEmpty(this.forkContext)
			};
			return this.breakContext;
		}

	}, {
		key: "popBreakContext",
		value: function popBreakContext() {
			var context = this.breakContext;
			var forkContext = this.forkContext;

			this.breakContext = context.upper;
			if (!context.breakable) {
				var brokenForkContext = context.brokenForkContext;

				if (!brokenForkContext.empty) {
					brokenForkContext.add(forkContext.head);
					forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
				}
			}

			return context;
		}

	}, {
		key: "makeBreak",
		value: function makeBreak(label) {
			var forkContext = this.forkContext;

			if (!forkContext.reachable) {
				return;
			}

			var context = getBreakContext(this, label);
			if (context) {
				context.brokenForkContext.add(forkContext.head);
			}

			forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
		}

	}, {
		key: "makeContinue",
		value: function makeContinue(label) {
			var forkContext = this.forkContext;

			if (!forkContext.reachable) {
				return;
			}

			var context = getContinueContext(this, label);
			if (context) {
				if (context.continueDestSegments) {
					makeLooped(this, forkContext.head, context.continueDestSegments);
					if (context.type === "ForInStatement" || context.type === "ForOfStatement") {
						context.brokenForkContext.add(forkContext.head);
					}
				} else {
					context.continueForkContext.add(forkContext.head);
				}
			}
			forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
		}

	}, {
		key: "makeReturn",
		value: function makeReturn() {
			var forkContext = this.forkContext;

			if (forkContext.reachable) {
				getReturnContext(this).returnedForkContext.add(forkContext.head);
				forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
			}
		}

	}, {
		key: "makeThrow",
		value: function makeThrow() {
			var forkContext = this.forkContext;

			if (forkContext.reachable) {
				getThrowContext(this).thrownForkContext.add(forkContext.head);
				forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
			}
		}

	}, {
		key: "makeFinal",
		value: function makeFinal() {
			var segments = this.currentSegments;

			if (segments.length > 0 && segments[0].reachable) {
				this.returnedForkContext.add(segments);
			}
		}
	}, {
		key: "headSegments",
		get: function get() {
			return this.forkContext.head;
		}

	}, {
		key: "parentForkContext",
		get: function get() {
			var current = this.forkContext;

			return current && current.upper;
		}
	}]);

	return CodePathState;
}();

module.exports = CodePathState;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(354);
exports.instances = [];

exports.names = [];
exports.skips = [];

exports.formatters = {};

function selectColor(namespace) {
  var hash = 0,
			i;

  for (i in namespace) {
	hash = (hash << 5) - hash + namespace.charCodeAt(i);
	hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

function createDebug(namespace) {

  var prevTime;

  function debug() {
	if (!debug.enabled) return;

	var self = debug;
	var curr = +new Date();
	var ms = curr - (prevTime || curr);
	self.diff = ms;
	self.prev = prevTime;
	self.curr = curr;
	prevTime = curr;
	var args = new Array(arguments.length);
	for (var i = 0; i < args.length; i++) {
			args[i] = arguments[i];
	}

	args[0] = exports.coerce(args[0]);

	if ('string' !== typeof args[0]) {
			args.unshift('%O');
	}
	var index = 0;
	args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
			if (match === '%%') return match;
			index++;
			var formatter = exports.formatters[format];
			if ('function' === typeof formatter) {
		var val = args[index];
		match = formatter.call(self, val);
		args.splice(index, 1);
		index--;
			}
			return match;
	});
	exports.formatArgs.call(self, args);

	var logFn = debug.log || exports.log || console.log.bind(console);
	logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;
  if ('function' === typeof exports.init) {
	exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy() {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
	exports.instances.splice(index, 1);
	return true;
  } else {
	return false;
  }
}

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
	if (!split[i]) continue; // ignore empty strings
	namespaces = split[i].replace(/\*/g, '.*?');
	if (namespaces[0] === '-') {
			exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	} else {
			exports.names.push(new RegExp('^' + namespaces + '$'));
	}
  }

  for (i = 0; i < exports.instances.length; i++) {
	var instance = exports.instances[i];
	instance.enabled = exports.enabled(instance.namespace);
  }
}

function disable() {
  exports.enable('');
}

function enabled(name) {
  if (name[name.length - 1] === '*') {
	return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
	if (exports.skips[i].test(name)) {
			return false;
	}
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
	if (exports.names[i].test(name)) {
			return true;
	}
  }
  return false;
}

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  if (type === 'string' && val.length > 0) {
	return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
	return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

function parse(str) {
  str = String(str);
  if (str.length > 100) {
	return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
	return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
	case 'years':
	case 'year':
	case 'yrs':
	case 'yr':
	case 'y':
			return n * y;
	case 'days':
	case 'day':
	case 'd':
			return n * d;
	case 'hours':
	case 'hour':
	case 'hrs':
	case 'hr':
	case 'h':
			return n * h;
	case 'minutes':
	case 'minute':
	case 'mins':
	case 'min':
	case 'm':
			return n * m;
	case 'seconds':
	case 'second':
	case 'secs':
	case 'sec':
	case 's':
			return n * s;
	case 'milliseconds':
	case 'millisecond':
	case 'msecs':
	case 'msec':
	case 'ms':
			return n;
	default:
			return undefined;
  }
}

function fmtShort(ms) {
  if (ms >= d) {
	return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
	return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
	return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
	return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

function fmtLong(ms) {
  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
}

function plural(ms, n, name) {
  if (ms < n) {
	return;
  }
  if (ms < n * 1.5) {
	return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CodePathSegment = __webpack_require__(102);
function isReachable(segment) {
	return segment.reachable;
}
function makeSegments(context, begin, end, create) {
	var list = context.segmentsList;

	if (begin < 0) {
		begin = list.length + begin;
	}
	if (end < 0) {
		end = list.length + end;
	}

	var segments = [];

	for (var i = 0; i < context.count; ++i) {
		var allPrevSegments = [];

		for (var j = begin; j <= end; ++j) {
			allPrevSegments.push(list[j][i]);
		}

		segments.push(create(context.idGenerator.next(), allPrevSegments));
	}

	return segments;
}
function mergeExtraSegments(context, segments) {
	while (segments.length > context.count) {
		var merged = [];

		for (var i = 0, length = segments.length / 2 | 0; i < length; ++i) {
			merged.push(CodePathSegment.newNext(context.idGenerator.next(), [segments[i], segments[i + length]]));
		}
		segments = merged;
	}
	return segments;
}

var ForkContext = function () {
	function ForkContext(idGenerator, upper, count) {
		_classCallCheck(this, ForkContext);

		this.idGenerator = idGenerator;
		this.upper = upper;
		this.count = count;
		this.segmentsList = [];
	}


	_createClass(ForkContext, [{
		key: "makeNext",
		value: function makeNext(begin, end) {
			return makeSegments(this, begin, end, CodePathSegment.newNext);
		}

	}, {
		key: "makeUnreachable",
		value: function makeUnreachable(begin, end) {
			return makeSegments(this, begin, end, CodePathSegment.newUnreachable);
		}

	}, {
		key: "makeDisconnected",
		value: function makeDisconnected(begin, end) {
			return makeSegments(this, begin, end, CodePathSegment.newDisconnected);
		}

	}, {
		key: "add",
		value: function add(segments) {

			this.segmentsList.push(mergeExtraSegments(this, segments));
		}

	}, {
		key: "replaceHead",
		value: function replaceHead(segments) {

			this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));
		}

	}, {
		key: "addAll",
		value: function addAll(context) {

			var source = context.segmentsList;

			for (var i = 0; i < source.length; ++i) {
				this.segmentsList.push(source[i]);
			}
		}

	}, {
		key: "clear",
		value: function clear() {
			this.segmentsList = [];
		}

	}, {
		key: "head",
		get: function get() {
			var list = this.segmentsList;

			return list.length === 0 ? [] : list[list.length - 1];
		}

	}, {
		key: "empty",
		get: function get() {
			return this.segmentsList.length === 0;
		}

	}, {
		key: "reachable",
		get: function get() {
			var segments = this.head;

			return segments.length > 0 && segments.some(isReachable);
		}
	}], [{
		key: "newRoot",
		value: function newRoot(idGenerator) {
			var context = new ForkContext(idGenerator, null, 1);

			context.add([CodePathSegment.newRoot(idGenerator.next())]);

			return context;
		}

	}, {
		key: "newEmpty",
		value: function newEmpty(parentContext, forkLeavingPath) {
			return new ForkContext(parentContext.idGenerator, parentContext, (forkLeavingPath ? 2 : 1) * parentContext.count);
		}
	}]);

	return ForkContext;
}();

module.exports = ForkContext;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

(function () {
	'use strict';

	function isExpression(node) {
		if (node == null) {
			return false;
		}
		switch (node.type) {
			case 'ArrayExpression':
			case 'AssignmentExpression':
			case 'BinaryExpression':
			case 'CallExpression':
			case 'ConditionalExpression':
			case 'FunctionExpression':
			case 'Identifier':
			case 'Literal':
			case 'LogicalExpression':
			case 'MemberExpression':
			case 'NewExpression':
			case 'ObjectExpression':
			case 'SequenceExpression':
			case 'ThisExpression':
			case 'UnaryExpression':
			case 'UpdateExpression':
				return true;
		}
		return false;
	}

	function isIterationStatement(node) {
		if (node == null) {
			return false;
		}
		switch (node.type) {
			case 'DoWhileStatement':
			case 'ForInStatement':
			case 'ForStatement':
			case 'WhileStatement':
				return true;
		}
		return false;
	}

	function isStatement(node) {
		if (node == null) {
			return false;
		}
		switch (node.type) {
			case 'BlockStatement':
			case 'BreakStatement':
			case 'ContinueStatement':
			case 'DebuggerStatement':
			case 'DoWhileStatement':
			case 'EmptyStatement':
			case 'ExpressionStatement':
			case 'ForInStatement':
			case 'ForStatement':
			case 'IfStatement':
			case 'LabeledStatement':
			case 'ReturnStatement':
			case 'SwitchStatement':
			case 'ThrowStatement':
			case 'TryStatement':
			case 'VariableDeclaration':
			case 'WhileStatement':
			case 'WithStatement':
				return true;
		}
		return false;
	}

	function isSourceElement(node) {
		return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
	}

	function trailingStatement(node) {
		switch (node.type) {
			case 'IfStatement':
				if (node.alternate != null) {
					return node.alternate;
				}
				return node.consequent;

			case 'LabeledStatement':
			case 'ForStatement':
			case 'ForInStatement':
			case 'WhileStatement':
			case 'WithStatement':
				return node.body;
		}
		return null;
	}

	function isProblematicIfStatement(node) {
		var current;

		if (node.type !== 'IfStatement') {
			return false;
		}
		if (node.alternate == null) {
			return false;
		}
		current = node.consequent;
		do {
			if (current.type === 'IfStatement') {
				if (current.alternate == null) {
					return true;
				}
			}
			current = trailingStatement(current);
		} while (current);

		return false;
	}

	module.exports = {
		isExpression: isExpression,
		isStatement: isStatement,
		isIterationStatement: isIterationStatement,
		isSourceElement: isSourceElement,
		isProblematicIfStatement: isProblematicIfStatement,

		trailingStatement: trailingStatement
	};
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

(function () {
	'use strict';

	var code = __webpack_require__(160);

	function isStrictModeReservedWordES6(id) {
		switch (id) {
			case 'implements':
			case 'interface':
			case 'package':
			case 'private':
			case 'protected':
			case 'public':
			case 'static':
			case 'let':
				return true;
			default:
				return false;
		}
	}

	function isKeywordES5(id, strict) {
		if (!strict && id === 'yield') {
			return false;
		}
		return isKeywordES6(id, strict);
	}

	function isKeywordES6(id, strict) {
		if (strict && isStrictModeReservedWordES6(id)) {
			return true;
		}

		switch (id.length) {
			case 2:
				return id === 'if' || id === 'in' || id === 'do';
			case 3:
				return id === 'var' || id === 'for' || id === 'new' || id === 'try';
			case 4:
				return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
			case 5:
				return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
			case 6:
				return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
			case 7:
				return id === 'default' || id === 'finally' || id === 'extends';
			case 8:
				return id === 'function' || id === 'continue' || id === 'debugger';
			case 10:
				return id === 'instanceof';
			default:
				return false;
		}
	}

	function isReservedWordES5(id, strict) {
		return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
	}

	function isReservedWordES6(id, strict) {
		return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
	}

	function isRestrictedWord(id) {
		return id === 'eval' || id === 'arguments';
	}

	function isIdentifierNameES5(id) {
		var i, iz, ch;

		if (id.length === 0) {
			return false;
		}

		ch = id.charCodeAt(0);
		if (!code.isIdentifierStartES5(ch)) {
			return false;
		}

		for (i = 1, iz = id.length; i < iz; ++i) {
			ch = id.charCodeAt(i);
			if (!code.isIdentifierPartES5(ch)) {
				return false;
			}
		}
		return true;
	}

	function decodeUtf16(lead, trail) {
		return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	}

	function isIdentifierNameES6(id) {
		var i, iz, ch, lowCh, check;

		if (id.length === 0) {
			return false;
		}

		check = code.isIdentifierStartES6;
		for (i = 0, iz = id.length; i < iz; ++i) {
			ch = id.charCodeAt(i);
			if (0xD800 <= ch && ch <= 0xDBFF) {
				++i;
				if (i >= iz) {
					return false;
				}
				lowCh = id.charCodeAt(i);
				if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
					return false;
				}
				ch = decodeUtf16(ch, lowCh);
			}
			if (!check(ch)) {
				return false;
			}
			check = code.isIdentifierPartES6;
		}
		return true;
	}

	function isIdentifierES5(id, strict) {
		return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
	}

	function isIdentifierES6(id, strict) {
		return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
	}

	module.exports = {
		isKeywordES5: isKeywordES5,
		isKeywordES6: isKeywordES6,
		isReservedWordES5: isReservedWordES5,
		isReservedWordES6: isReservedWordES6,
		isRestrictedWord: isRestrictedWord,
		isIdentifierNameES5: isIdentifierNameES5,
		isIdentifierNameES6: isIdentifierNameES6,
		isIdentifierES5: isIdentifierES5,
		isIdentifierES6: isIdentifierES6
	};
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astNodeTypes = __webpack_require__(161);
var extra = {
	trailingComments: [],
	leadingComments: [],
	bottomRightStack: [],
	previousNode: null
};
module.exports = {

	reset: function reset() {
		extra.trailingComments = [];
		extra.leadingComments = [];
		extra.bottomRightStack = [];
		extra.previousNode = null;
	},

	addComment: function addComment(comment) {
		extra.trailingComments.push(comment);
		extra.leadingComments.push(comment);
	},

	processComment: function processComment(node) {
		var lastChild, trailingComments, i, j;

		if (node.type === astNodeTypes.Program) {
			if (node.body.length > 0) {
				return;
			}
		}

		if (extra.trailingComments.length > 0) {
			if (extra.trailingComments[0].range[0] >= node.range[1]) {
				trailingComments = extra.trailingComments;
				extra.trailingComments = [];
			} else {
				extra.trailingComments.length = 0;
			}
		} else {
			if (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
				trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
				delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
			}
		}
		while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
			lastChild = extra.bottomRightStack.pop();
		}

		if (lastChild) {
			if (lastChild.leadingComments) {
				if (lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
					node.leadingComments = lastChild.leadingComments;
					delete lastChild.leadingComments;
				} else {
					for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
						if (lastChild.leadingComments[i].range[1] <= node.range[0]) {
							node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
							break;
						}
					}
				}
			}
		} else if (extra.leadingComments.length > 0) {
			if (extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
				if (extra.previousNode) {
					for (j = 0; j < extra.leadingComments.length; j++) {
						if (extra.leadingComments[j].end < extra.previousNode.end) {
							extra.leadingComments.splice(j, 1);
							j--;
						}
					}
				}
				if (extra.leadingComments.length > 0) {
					node.leadingComments = extra.leadingComments;
					extra.leadingComments = [];
				}
			} else {
				for (i = 0; i < extra.leadingComments.length; i++) {
					if (extra.leadingComments[i].range[1] > node.range[0]) {
						break;
					}
				}
				node.leadingComments = extra.leadingComments.slice(0, i);
				if (node.leadingComments.length === 0) {
					delete node.leadingComments;
				}
				trailingComments = extra.leadingComments.slice(i);
				if (trailingComments.length === 0) {
					trailingComments = null;
				}
			}
		}

		extra.previousNode = node;

		if (trailingComments) {
			node.trailingComments = trailingComments;
		}

		extra.bottomRightStack.push(node);
	}

};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var Token = {
	Boolean: "Boolean",
	EOF: "<end>",
	Identifier: "Identifier",
	Keyword: "Keyword",
	Null: "Null",
	Numeric: "Numeric",
	Punctuator: "Punctuator",
	String: "String",
	RegularExpression: "RegularExpression",
	Template: "Template",
	JSXIdentifier: "JSXIdentifier",
	JSXText: "JSXText"
};
function convertTemplatePart(tokens, code) {
	var firstToken = tokens[0],
		lastTemplateToken = tokens[tokens.length - 1];

	var token = {
		type: Token.Template,
		value: code.slice(firstToken.start, lastTemplateToken.end)
	};

	if (firstToken.loc) {
		token.loc = {
			start: firstToken.loc.start,
			end: lastTemplateToken.loc.end
		};
	}

	if (firstToken.range) {
		token.start = firstToken.range[0];
		token.end = lastTemplateToken.range[1];
		token.range = [token.start, token.end];
	}

	return token;
}
function TokenTranslator(acornTokTypes, code) {
	this._acornTokTypes = acornTokTypes;
	this._tokens = [];
	this._curlyBrace = null;
	this._code = code;
}

TokenTranslator.prototype = {
	constructor: TokenTranslator,
	translate: function translate(token, extra) {

		var type = token.type,
			tt = this._acornTokTypes;

		if (type === tt.name) {
			token.type = Token.Identifier;
			if (token.value === "static") {
				token.type = Token.Keyword;
			}

			if (extra.ecmaVersion > 5 && (token.value === "yield" || token.value === "let")) {
				token.type = Token.Keyword;
			}
		} else if (type === tt.semi || type === tt.comma || type === tt.parenL || type === tt.parenR || type === tt.braceL || type === tt.braceR || type === tt.dot || type === tt.bracketL || type === tt.colon || type === tt.question || type === tt.bracketR || type === tt.ellipsis || type === tt.arrow || type === tt.jsxTagStart || type === tt.incDec || type === tt.starstar || type === tt.jsxTagEnd || type === tt.prefix || type.binop && !type.keyword || type.isAssign) {

			token.type = Token.Punctuator;
			token.value = this._code.slice(token.start, token.end);
		} else if (type === tt.jsxName) {
			token.type = Token.JSXIdentifier;
		} else if (type.label === "jsxText" || type === tt.jsxAttrValueToken) {
			token.type = Token.JSXText;
		} else if (type.keyword) {
			if (type.keyword === "true" || type.keyword === "false") {
				token.type = Token.Boolean;
			} else if (type.keyword === "null") {
				token.type = Token.Null;
			} else {
				token.type = Token.Keyword;
			}
		} else if (type === tt.num) {
			token.type = Token.Numeric;
			token.value = this._code.slice(token.start, token.end);
		} else if (type === tt.string) {

			if (extra.jsxAttrValueToken) {
				extra.jsxAttrValueToken = false;
				token.type = Token.JSXText;
			} else {
				token.type = Token.String;
			}

			token.value = this._code.slice(token.start, token.end);
		} else if (type === tt.regexp) {
			token.type = Token.RegularExpression;
			var value = token.value;
			token.regex = {
				flags: value.flags,
				pattern: value.pattern
			};
			token.value = "/" + value.pattern + "/" + value.flags;
		}

		return token;
	},
	onToken: function onToken(token, extra) {

		var that = this,
			tt = this._acornTokTypes,
			tokens = extra.tokens,
			templateTokens = this._tokens;
		function translateTemplateTokens() {
			tokens.push(convertTemplatePart(that._tokens, that._code));
			that._tokens = [];
		}

		if (token.type === tt.eof) {
			if (this._curlyBrace) {
				tokens.push(this.translate(this._curlyBrace, extra));
			}

			return;
		}

		if (token.type === tt.backQuote) {
			if (this._curlyBrace) {
				tokens.push(this.translate(this._curlyBrace, extra));
				this._curlyBrace = null;
			}

			templateTokens.push(token);
			if (templateTokens.length > 1) {
				translateTemplateTokens();
			}

			return;
		} else if (token.type === tt.dollarBraceL) {
			templateTokens.push(token);
			translateTemplateTokens();
			return;
		} else if (token.type === tt.braceR) {
			if (this._curlyBrace) {
				tokens.push(this.translate(this._curlyBrace, extra));
			}
			this._curlyBrace = token;
			return;
		} else if (token.type === tt.template || token.type === tt.invalidTemplate) {
			if (this._curlyBrace) {
				templateTokens.push(this._curlyBrace);
				this._curlyBrace = null;
			}

			templateTokens.push(token);
			return;
		}

		if (this._curlyBrace) {
			tokens.push(this.translate(this._curlyBrace, extra));
			this._curlyBrace = null;
		}

		tokens.push(this.translate(token, extra));
	}
};
module.exports = TokenTranslator;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var XHTMLEntities = __webpack_require__(361);

var hexNumber = /^[\da-fA-F]+$/;
var decimalNumber = /^\d+$/;

module.exports = function (acorn) {
  var tt = acorn.tokTypes;
  var tc = acorn.tokContexts;

  tc.j_oTag = new acorn.TokContext('<tag', false);
  tc.j_cTag = new acorn.TokContext('</tag', false);
  tc.j_expr = new acorn.TokContext('<tag>...</tag>', true, true);

  tt.jsxName = new acorn.TokenType('jsxName');
  tt.jsxText = new acorn.TokenType('jsxText', { beforeExpr: true });
  tt.jsxTagStart = new acorn.TokenType('jsxTagStart');
  tt.jsxTagEnd = new acorn.TokenType('jsxTagEnd');

  tt.jsxTagStart.updateContext = function () {
	this.context.push(tc.j_expr); // treat as beginning of JSX expression
	this.context.push(tc.j_oTag); // start opening tag context
	this.exprAllowed = false;
  };
  tt.jsxTagEnd.updateContext = function (prevType) {
	var out = this.context.pop();
	if (out === tc.j_oTag && prevType === tt.slash || out === tc.j_cTag) {
			this.context.pop();
			this.exprAllowed = this.curContext() === tc.j_expr;
	} else {
			this.exprAllowed = true;
	}
  };

  var pp = acorn.Parser.prototype;
  pp.jsx_readToken = function () {
	var out = '',
		chunkStart = this.pos;
	for (;;) {
			if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated JSX contents');
			var ch = this.input.charCodeAt(this.pos);

			switch (ch) {
		case 60: // '<'
		case 123:
					if (this.pos === this.start) {
			if (ch === 60 && this.exprAllowed) {
							++this.pos;
							return this.finishToken(tt.jsxTagStart);
			}
			return this.getTokenFromCode(ch);
					}
					out += this.input.slice(chunkStart, this.pos);
					return this.finishToken(tt.jsxText, out);

		case 38:
					out += this.input.slice(chunkStart, this.pos);
					out += this.jsx_readEntity();
					chunkStart = this.pos;
					break;

		default:
					if (acorn.isNewLine(ch)) {
			out += this.input.slice(chunkStart, this.pos);
			out += this.jsx_readNewLine(true);
			chunkStart = this.pos;
					} else {
			++this.pos;
					}
			}
	}
  };

  pp.jsx_readNewLine = function (normalizeCRLF) {
	var ch = this.input.charCodeAt(this.pos);
	var out;
	++this.pos;
	if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
			++this.pos;
			out = normalizeCRLF ? '\n' : '\r\n';
	} else {
			out = String.fromCharCode(ch);
	}
	if (this.options.locations) {
			++this.curLine;
			this.lineStart = this.pos;
	}

	return out;
  };

  pp.jsx_readString = function (quote) {
	var out = '',
		chunkStart = ++this.pos;
	for (;;) {
			if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated string constant');
			var ch = this.input.charCodeAt(this.pos);
			if (ch === quote) break;
			if (ch === 38) {
		out += this.input.slice(chunkStart, this.pos);
		out += this.jsx_readEntity();
		chunkStart = this.pos;
			} else if (acorn.isNewLine(ch)) {
		out += this.input.slice(chunkStart, this.pos);
		out += this.jsx_readNewLine(false);
		chunkStart = this.pos;
			} else {
		++this.pos;
			}
	}
	out += this.input.slice(chunkStart, this.pos++);
	return this.finishToken(tt.string, out);
  };

  pp.jsx_readEntity = function () {
	var str = '',
		count = 0,
		entity;
	var ch = this.input[this.pos];
	if (ch !== '&') this.raise(this.pos, 'Entity must start with an ampersand');
	var startPos = ++this.pos;
	while (this.pos < this.input.length && count++ < 10) {
			ch = this.input[this.pos++];
			if (ch === ';') {
		if (str[0] === '#') {
					if (str[1] === 'x') {
			str = str.substr(2);
			if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));
					} else {
			str = str.substr(1);
			if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));
					}
		} else {
					entity = XHTMLEntities[str];
		}
		break;
			}
			str += ch;
	}
	if (!entity) {
			this.pos = startPos;
			return '&';
	}
	return entity;
  };
  //
  pp.jsx_readWord = function () {
	var ch,
		start = this.pos;
	do {
			ch = this.input.charCodeAt(++this.pos);
	} while (acorn.isIdentifierChar(ch) || ch === 45); // '-'
	return this.finishToken(tt.jsxName, this.input.slice(start, this.pos));
  };
  function getQualifiedJSXName(object) {
	if (object.type === 'JSXIdentifier') return object.name;

	if (object.type === 'JSXNamespacedName') return object.namespace.name + ':' + object.name.name;

	if (object.type === 'JSXMemberExpression') return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);
  }
  pp.jsx_parseIdentifier = function () {
	var node = this.startNode();
	if (this.type === tt.jsxName) node.name = this.value;else if (this.type.keyword) node.name = this.type.keyword;else this.unexpected();
	this.next();
	return this.finishNode(node, 'JSXIdentifier');
  };
  pp.jsx_parseNamespacedName = function () {
	var startPos = this.start,
		startLoc = this.startLoc;
	var name = this.jsx_parseIdentifier();
	if (!this.options.plugins.jsx.allowNamespaces || !this.eat(tt.colon)) return name;
	var node = this.startNodeAt(startPos, startLoc);
	node.namespace = name;
	node.name = this.jsx_parseIdentifier();
	return this.finishNode(node, 'JSXNamespacedName');
  };
  pp.jsx_parseElementName = function () {
	var startPos = this.start,
		startLoc = this.startLoc;
	var node = this.jsx_parseNamespacedName();
	if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !this.options.plugins.jsx.allowNamespacedObjects) {
			this.unexpected();
	}
	while (this.eat(tt.dot)) {
			var newNode = this.startNodeAt(startPos, startLoc);
			newNode.object = node;
			newNode.property = this.jsx_parseIdentifier();
			node = this.finishNode(newNode, 'JSXMemberExpression');
	}
	return node;
  };
  pp.jsx_parseAttributeValue = function () {
	switch (this.type) {
			case tt.braceL:
		var node = this.jsx_parseExpressionContainer();
		if (node.expression.type === 'JSXEmptyExpression') this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');
		return node;

			case tt.jsxTagStart:
			case tt.string:
		return this.parseExprAtom();

			default:
		this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');
	}
  };
  pp.jsx_parseEmptyExpression = function () {
	var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
	return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);
  };

  pp.jsx_parseExpressionContainer = function () {
	var node = this.startNode();
	this.next();
	node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
	this.expect(tt.braceR);
	return this.finishNode(node, 'JSXExpressionContainer');
  };
  pp.jsx_parseAttribute = function () {
	var node = this.startNode();
	if (this.eat(tt.braceL)) {
			this.expect(tt.ellipsis);
			node.argument = this.parseMaybeAssign();
			this.expect(tt.braceR);
			return this.finishNode(node, 'JSXSpreadAttribute');
	}
	node.name = this.jsx_parseNamespacedName();
	node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
	return this.finishNode(node, 'JSXAttribute');
  };
  pp.jsx_parseOpeningElementAt = function (startPos, startLoc) {
	var node = this.startNodeAt(startPos, startLoc);
	node.attributes = [];
	node.name = this.jsx_parseElementName();
	while (this.type !== tt.slash && this.type !== tt.jsxTagEnd) {
			node.attributes.push(this.jsx_parseAttribute());
	}node.selfClosing = this.eat(tt.slash);
	this.expect(tt.jsxTagEnd);
	return this.finishNode(node, 'JSXOpeningElement');
  };
  pp.jsx_parseClosingElementAt = function (startPos, startLoc) {
	var node = this.startNodeAt(startPos, startLoc);
	node.name = this.jsx_parseElementName();
	this.expect(tt.jsxTagEnd);
	return this.finishNode(node, 'JSXClosingElement');
  };
  pp.jsx_parseElementAt = function (startPos, startLoc) {
	var node = this.startNodeAt(startPos, startLoc);
	var children = [];
	var openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
	var closingElement = null;

	if (!openingElement.selfClosing) {
			contents: for (;;) {
		switch (this.type) {
					case tt.jsxTagStart:
			startPos = this.start;startLoc = this.startLoc;
			this.next();
			if (this.eat(tt.slash)) {
							closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
							break contents;
			}
			children.push(this.jsx_parseElementAt(startPos, startLoc));
			break;

					case tt.jsxText:
			children.push(this.parseExprAtom());
			break;

					case tt.braceL:
			children.push(this.jsx_parseExpressionContainer());
			break;

					default:
			this.unexpected();
		}
			}
			if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
		this.raise(closingElement.start, 'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');
			}
	}

	node.openingElement = openingElement;
	node.closingElement = closingElement;
	node.children = children;
	if (this.type === tt.relational && this.value === "<") {
			this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
	}
	return this.finishNode(node, 'JSXElement');
  };
  pp.jsx_parseElement = function () {
	var startPos = this.start,
		startLoc = this.startLoc;
	this.next();
	return this.jsx_parseElementAt(startPos, startLoc);
  };

  acorn.plugins.jsx = function (instance, opts) {
	if (!opts) {
			return;
	}

	if ((typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
			opts = {};
	}

	instance.options.plugins.jsx = {
			allowNamespaces: opts.allowNamespaces !== false,
			allowNamespacedObjects: !!opts.allowNamespacedObjects
	};

	instance.extend('parseExprAtom', function (inner) {
			return function (refShortHandDefaultPos) {
		if (this.type === tt.jsxText) return this.parseLiteral(this.value);else if (this.type === tt.jsxTagStart) return this.jsx_parseElement();else return inner.call(this, refShortHandDefaultPos);
			};
	});

	instance.extend('readToken', function (inner) {
			return function (code) {
		var context = this.curContext();

		if (context === tc.j_expr) return this.jsx_readToken();

		if (context === tc.j_oTag || context === tc.j_cTag) {
					if (acorn.isIdentifierStart(code)) return this.jsx_readWord();

					if (code == 62) {
			++this.pos;
			return this.finishToken(tt.jsxTagEnd);
					}

					if ((code === 34 || code === 39) && context == tc.j_oTag) return this.jsx_readString(code);
		}

		if (code === 60 && this.exprAllowed) {
					++this.pos;
					return this.finishToken(tt.jsxTagStart);
		}
		return inner.call(this, code);
			};
	});

	instance.extend('updateContext', function (inner) {
			return function (prevType) {
		if (this.type == tt.braceL) {
					var curContext = this.curContext();
					if (curContext == tc.j_oTag) this.context.push(tc.b_expr);else if (curContext == tc.j_expr) this.context.push(tc.b_tmpl);else inner.call(this, prevType);
					this.exprAllowed = true;
		} else if (this.type === tt.slash && prevType === tt.jsxTagStart) {
					this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
					this.context.push(tc.j_cTag); // reconsider as closing tag context
					this.exprAllowed = false;
		} else {
					return inner.call(this, prevType);
		}
			};
	});
  };

  return acorn;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  quot: '"',
  amp: '&',
  apos: '\'',
  lt: '<',
  gt: '>',
  nbsp: '\xA0',
  iexcl: '\xA1',
  cent: '\xA2',
  pound: '\xA3',
  curren: '\xA4',
  yen: '\xA5',
  brvbar: '\xA6',
  sect: '\xA7',
  uml: '\xA8',
  copy: '\xA9',
  ordf: '\xAA',
  laquo: '\xAB',
  not: '\xAC',
  shy: '\xAD',
  reg: '\xAE',
  macr: '\xAF',
  deg: '\xB0',
  plusmn: '\xB1',
  sup2: '\xB2',
  sup3: '\xB3',
  acute: '\xB4',
  micro: '\xB5',
  para: '\xB6',
  middot: '\xB7',
  cedil: '\xB8',
  sup1: '\xB9',
  ordm: '\xBA',
  raquo: '\xBB',
  frac14: '\xBC',
  frac12: '\xBD',
  frac34: '\xBE',
  iquest: '\xBF',
  Agrave: '\xC0',
  Aacute: '\xC1',
  Acirc: '\xC2',
  Atilde: '\xC3',
  Auml: '\xC4',
  Aring: '\xC5',
  AElig: '\xC6',
  Ccedil: '\xC7',
  Egrave: '\xC8',
  Eacute: '\xC9',
  Ecirc: '\xCA',
  Euml: '\xCB',
  Igrave: '\xCC',
  Iacute: '\xCD',
  Icirc: '\xCE',
  Iuml: '\xCF',
  ETH: '\xD0',
  Ntilde: '\xD1',
  Ograve: '\xD2',
  Oacute: '\xD3',
  Ocirc: '\xD4',
  Otilde: '\xD5',
  Ouml: '\xD6',
  times: '\xD7',
  Oslash: '\xD8',
  Ugrave: '\xD9',
  Uacute: '\xDA',
  Ucirc: '\xDB',
  Uuml: '\xDC',
  Yacute: '\xDD',
  THORN: '\xDE',
  szlig: '\xDF',
  agrave: '\xE0',
  aacute: '\xE1',
  acirc: '\xE2',
  atilde: '\xE3',
  auml: '\xE4',
  aring: '\xE5',
  aelig: '\xE6',
  ccedil: '\xE7',
  egrave: '\xE8',
  eacute: '\xE9',
  ecirc: '\xEA',
  euml: '\xEB',
  igrave: '\xEC',
  iacute: '\xED',
  icirc: '\xEE',
  iuml: '\xEF',
  eth: '\xF0',
  ntilde: '\xF1',
  ograve: '\xF2',
  oacute: '\xF3',
  ocirc: '\xF4',
  otilde: '\xF5',
  ouml: '\xF6',
  divide: '\xF7',
  oslash: '\xF8',
  ugrave: '\xF9',
  uacute: '\xFA',
  ucirc: '\xFB',
  uuml: '\xFC',
  yacute: '\xFD',
  thorn: '\xFE',
  yuml: '\xFF',
  OElig: '\u0152',
  oelig: '\u0153',
  Scaron: '\u0160',
  scaron: '\u0161',
  Yuml: '\u0178',
  fnof: '\u0192',
  circ: '\u02C6',
  tilde: '\u02DC',
  Alpha: '\u0391',
  Beta: '\u0392',
  Gamma: '\u0393',
  Delta: '\u0394',
  Epsilon: '\u0395',
  Zeta: '\u0396',
  Eta: '\u0397',
  Theta: '\u0398',
  Iota: '\u0399',
  Kappa: '\u039A',
  Lambda: '\u039B',
  Mu: '\u039C',
  Nu: '\u039D',
  Xi: '\u039E',
  Omicron: '\u039F',
  Pi: '\u03A0',
  Rho: '\u03A1',
  Sigma: '\u03A3',
  Tau: '\u03A4',
  Upsilon: '\u03A5',
  Phi: '\u03A6',
  Chi: '\u03A7',
  Psi: '\u03A8',
  Omega: '\u03A9',
  alpha: '\u03B1',
  beta: '\u03B2',
  gamma: '\u03B3',
  delta: '\u03B4',
  epsilon: '\u03B5',
  zeta: '\u03B6',
  eta: '\u03B7',
  theta: '\u03B8',
  iota: '\u03B9',
  kappa: '\u03BA',
  lambda: '\u03BB',
  mu: '\u03BC',
  nu: '\u03BD',
  xi: '\u03BE',
  omicron: '\u03BF',
  pi: '\u03C0',
  rho: '\u03C1',
  sigmaf: '\u03C2',
  sigma: '\u03C3',
  tau: '\u03C4',
  upsilon: '\u03C5',
  phi: '\u03C6',
  chi: '\u03C7',
  psi: '\u03C8',
  omega: '\u03C9',
  thetasym: '\u03D1',
  upsih: '\u03D2',
  piv: '\u03D6',
  ensp: '\u2002',
  emsp: '\u2003',
  thinsp: '\u2009',
  zwnj: '\u200C',
  zwj: '\u200D',
  lrm: '\u200E',
  rlm: '\u200F',
  ndash: '\u2013',
  mdash: '\u2014',
  lsquo: '\u2018',
  rsquo: '\u2019',
  sbquo: '\u201A',
  ldquo: '\u201C',
  rdquo: '\u201D',
  bdquo: '\u201E',
  dagger: '\u2020',
  Dagger: '\u2021',
  bull: '\u2022',
  hellip: '\u2026',
  permil: '\u2030',
  prime: '\u2032',
  Prime: '\u2033',
  lsaquo: '\u2039',
  rsaquo: '\u203A',
  oline: '\u203E',
  frasl: '\u2044',
  euro: '\u20AC',
  image: '\u2111',
  weierp: '\u2118',
  real: '\u211C',
  trade: '\u2122',
  alefsym: '\u2135',
  larr: '\u2190',
  uarr: '\u2191',
  rarr: '\u2192',
  darr: '\u2193',
  harr: '\u2194',
  crarr: '\u21B5',
  lArr: '\u21D0',
  uArr: '\u21D1',
  rArr: '\u21D2',
  dArr: '\u21D3',
  hArr: '\u21D4',
  forall: '\u2200',
  part: '\u2202',
  exist: '\u2203',
  empty: '\u2205',
  nabla: '\u2207',
  isin: '\u2208',
  notin: '\u2209',
  ni: '\u220B',
  prod: '\u220F',
  sum: '\u2211',
  minus: '\u2212',
  lowast: '\u2217',
  radic: '\u221A',
  prop: '\u221D',
  infin: '\u221E',
  ang: '\u2220',
  and: '\u2227',
  or: '\u2228',
  cap: '\u2229',
  cup: '\u222A',
  'int': '\u222B',
  there4: '\u2234',
  sim: '\u223C',
  cong: '\u2245',
  asymp: '\u2248',
  ne: '\u2260',
  equiv: '\u2261',
  le: '\u2264',
  ge: '\u2265',
  sub: '\u2282',
  sup: '\u2283',
  nsub: '\u2284',
  sube: '\u2286',
  supe: '\u2287',
  oplus: '\u2295',
  otimes: '\u2297',
  perp: '\u22A5',
  sdot: '\u22C5',
  lceil: '\u2308',
  rceil: '\u2309',
  lfloor: '\u230A',
  rfloor: '\u230B',
  lang: '\u2329',
  rang: '\u232A',
  loz: '\u25CA',
  spades: '\u2660',
  clubs: '\u2663',
  hearts: '\u2665',
  diams: '\u2666'
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;
function isIdentifierStart(code, astral) {
  if (code < 65) {
	return code === 36;
  }
  if (code < 91) {
	return true;
  }
  if (code < 97) {
	return code === 95;
  }
  if (code < 123) {
	return true;
  }
  return code >= 0xaa;
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
	return code === 36;
  }
  if (code < 58) {
	return true;
  }
  if (code < 65) {
	return false;
  }
  if (code < 91) {
	return true;
  }
  if (code < 97) {
	return code === 95;
  }
  if (code < 123) {
	return true;
  }
  return code >= 0xaa;
}
//
//
var TokenType = function TokenType(label, conf) {
  if (conf === void 0) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords$1 = {};
function kw(name, options) {
  if (options === void 0) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options);
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

  at: new TokenType("@", { beforeExpr: true, startsExpr: true }),
  //
  //
  //
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import"),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
function has(obj, propName) {
  return hasOwnProperty.call(obj, propName);
}

var isArray = Array.isArray || function (obj) {
  return toString.call(obj) === "[object Array]";
};
var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset(n) {
  return new Position(this.line, this.column + n);
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) {
	this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
	lineBreakG.lastIndex = cur;
	var match = lineBreakG.exec(input);
	if (match && match.index < offset) {
			++line;
			cur = match.index + match[0].length;
	} else {
			return new Position(line, offset - cur);
	}
  }
}
var defaultOptions = {
  ecmaVersion: 7,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowHashBang: false,
  locations: false,
  onToken: null,
  onComment: null,
  //
  ranges: false,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: false,
  plugins: {}
};
function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions) {
	options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }

  if (options.ecmaVersion >= 2015) {
	options.ecmaVersion -= 2009;
  }

  if (options.allowReserved == null) {
	options.allowReserved = options.ecmaVersion < 5;
  }

  if (isArray(options.onToken)) {
	var tokens = options.onToken;
	options.onToken = function (token) {
			return tokens.push(token);
	};
  }
  if (isArray(options.onComment)) {
	options.onComment = pushComment(options, options.onComment);
  }

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
	var comment = {
			type: block ? "Block" : "Line",
			value: text,
			start: start,
			end: end
	};
	if (options.locations) {
			comment.loc = new SourceLocation(this, startLoc, endLoc);
	}
	if (options.ranges) {
			comment.range = [start, end];
	}
	array.push(comment);
  };
}
var plugins = {};

function keywordRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
  var reserved = "";
  if (!options.allowReserved) {
	for (var v = options.ecmaVersion;; v--) {
			if (reserved = reservedWords[v]) {
		break;
			}
	}
	if (options.sourceType == "module") {
			reserved += " await";
	}
  }
  this.reservedWords = keywordRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = keywordRegexp(reservedStrict);
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  this.loadPlugins(options.plugins);
  if (startPos) {
	this.pos = startPos;
	this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
	this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
	this.pos = this.lineStart = 0;
	this.curLine = 1;
  }
  this.type = types.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.inFunction = this.inGenerator = this.inAsync = false;
  this.yieldPos = this.awaitPos = 0;
  this.labels = [];
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
	this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterFunctionScope();
};
Parser.prototype.isKeyword = function isKeyword(word) {
  return this.keywords.test(word);
};
Parser.prototype.isReservedWord = function isReservedWord(word) {
  return this.reservedWords.test(word);
};

Parser.prototype.extend = function extend(name, f) {
  this[name] = f(this[name]);
};

Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
  var this$1 = this;

  for (var name in pluginConfigs) {
	var plugin = plugins[name];
	if (!plugin) {
			throw new Error("Plugin '" + name + "' not found");
	}
	plugin(this$1, pluginConfigs[name]);
  }
};

Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};

var pp = Parser.prototype;
var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/;
pp.strictDirective = function (start) {
  var this$1 = this;

  for (;;) {
	skipWhiteSpace.lastIndex = start;
	start += skipWhiteSpace.exec(this$1.input)[0].length;
	var match = literal.exec(this$1.input.slice(start));
	if (!match) {
			return false;
	}
	if ((match[1] || match[2]) == "use strict") {
			return true;
	}
	start += match[0].length;
  }
};
pp.eat = function (type) {
  if (this.type === type) {
	this.next();
	return true;
  } else {
	return false;
  }
};
pp.isContextual = function (name) {
  return this.type === types.name && this.value === name;
};
pp.eatContextual = function (name) {
  return this.value === name && this.eat(types.name);
};
pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) {
	this.unexpected();
  }
};
pp.canInsertSemicolon = function () {
  return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
	if (this.options.onInsertedSemicolon) {
			this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
	}
	return true;
  }
};
pp.semicolon = function () {
  if (!this.eat(types.semi) && !this.insertSemicolon()) {
	this.unexpected();
  }
};

pp.afterTrailingComma = function (tokType, notNext) {
  if (this.type == tokType) {
	if (this.options.onTrailingComma) {
			this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
	}
	if (!notNext) {
			this.next();
	}
	return true;
  }
};
pp.expect = function (type) {
  this.eat(type) || this.unexpected();
};
pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1;
}

pp.checkPatternErrors = function (refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
	return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
	this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
	this.raiseRecoverable(parens, "Parenthesized pattern");
  }
};

pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1;
  if (!andThrow) {
	return pos >= 0;
  }
  if (pos > -1) {
	this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
  }
};

pp.checkYieldAwaitInDefaultParams = function () {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
	this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
	this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};

pp.isSimpleAssignTarget = function (expr) {
  if (expr.type === "ParenthesizedExpression") {
	return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};

var pp$1 = Parser.prototype;
pp$1.parseTopLevel = function (node) {
  var this$1 = this;

  var exports = {};
  if (!node.body) {
	node.body = [];
  }
  while (this.type !== types.eof) {
	var stmt = this$1.parseStatement(true, true, exports);
	node.body.push(stmt);
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  if (this.options.ecmaVersion >= 6) {
	node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };

pp$1.isLet = function () {
  if (this.type !== types.name || this.options.ecmaVersion < 6 || this.value != "let") {
	return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length,
			nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh == 123) {
	return true;
  } // '{' and '['
  if (isIdentifierStart(nextCh, true)) {
	var pos = next + 1;
	while (isIdentifierChar(this.input.charCodeAt(pos), true)) {
			++pos;
	}
	var ident = this.input.slice(next, pos);
	if (!keywordRelationalOperator.test(ident)) {
			return true;
	}
  }
  return false;
};
pp$1.isAsyncFunction = function () {
  if (this.type !== types.name || this.options.ecmaVersion < 8 || this.value != "async") {
	return false;
  }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));
};
//
pp$1.parseStatement = function (declaration, topLevel, exports) {
  var starttype = this.type,
			node = this.startNode(),
			kind;

  if (this.isLet()) {
	starttype = types._var;
	kind = "let";
  }
  switch (starttype) {
	case types._break:case types._continue:
			return this.parseBreakContinueStatement(node, starttype.keyword);
	case types._debugger:
			return this.parseDebuggerStatement(node);
	case types._do:
			return this.parseDoStatement(node);
	case types._for:
			return this.parseForStatement(node);
	case types._function:
			if (!declaration && this.options.ecmaVersion >= 6) {
		this.unexpected();
			}
			return this.parseFunctionStatement(node, false);
	case types._class:
			if (!declaration) {
		this.unexpected();
			}
			return this.parseClass(node, true);
	case types._if:
			return this.parseIfStatement(node);
	case types._return:
			return this.parseReturnStatement(node);
	case types._switch:
			return this.parseSwitchStatement(node);
	case types._throw:
			return this.parseThrowStatement(node);
	case types._try:
			return this.parseTryStatement(node);
	case types._const:case types._var:
			kind = kind || this.value;
			if (!declaration && kind != "var") {
		this.unexpected();
			}
			return this.parseVarStatement(node, kind);
	case types._while:
			return this.parseWhileStatement(node);
	case types._with:
			return this.parseWithStatement(node);
	case types.braceL:
			return this.parseBlock();
	case types.semi:
			return this.parseEmptyStatement(node);
	case types._export:
	case types._import:
			if (!this.options.allowImportExportEverywhere) {
		if (!topLevel) {
					this.raise(this.start, "'import' and 'export' may only appear at the top level");
		}
		if (!this.inModule) {
					this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
		}
			}
			return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);
	case types.at:
			this.next();
			return this.parseExpression();
	default:
			if (this.isAsyncFunction() && declaration) {
		this.next();
		return this.parseFunctionStatement(node, true);
			}

			var maybeName = this.value,
					expr = this.parseExpression();
			if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
		return this.parseLabeledStatement(node, maybeName, expr);
			} else {
		return this.parseExpressionStatement(node, expr);
			}
  }
};

pp$1.parseBreakContinueStatement = function (node, keyword) {
  var this$1 = this;

  var isBreak = keyword == "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) {
	node.label = null;
  } else if (this.type !== types.name) {
	this.unexpected();
  } else {
	node.label = this.parseIdent();
	this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
	var lab = this$1.labels[i];
	if (node.label == null || lab.name === node.label.name) {
			if (lab.kind != null && (isBreak || lab.kind === "loop")) {
		break;
			}
			if (node.label && isBreak) {
		break;
			}
	}
  }
  if (i === this.labels.length) {
	this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp$1.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp$1.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
	this.eat(types.semi);
  } else {
	this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$1.parseForStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  this.enterLexicalScope();
  this.expect(types.parenL);
  if (this.type === types.semi) {
	return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
	var init$1 = this.startNode(),
		kind = isLet ? "let" : this.value;
	this.next();
	this.parseVar(init$1, true, kind);
	this.finishNode(init$1, "VariableDeclaration");
	if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1 && !(kind !== "var" && init$1.declarations[0].init)) {
			return this.parseForIn(node, init$1);
	}
	return this.parseFor(node, init$1);
  }
  var refDestructuringErrors = new DestructuringErrors();
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
	this.toAssignable(init);
	this.checkLVal(init);
	this.checkPatternErrors(refDestructuringErrors, true);
	return this.parseForIn(node, init);
  } else {
	this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return this.parseFor(node, init);
};

pp$1.parseFunctionStatement = function (node, isAsync) {
  this.next();
  return this.parseFunction(node, true, false, isAsync);
};

pp$1.isFunction = function () {
  return this.type === types._function || this.isAsyncFunction();
};

pp$1.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(!this.strict && this.isFunction());
  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.isFunction()) : null;
  return this.finishNode(node, "IfStatement");
};

pp$1.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
	this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) {
	node.argument = null;
  } else {
	node.argument = this.parseExpression();this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};

pp$1.parseSwitchStatement = function (node) {
  var this$1 = this;

  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterLexicalScope();
  var cur;
  for (var sawDefault = false; this.type != types.braceR;) {
	if (this$1.type === types._case || this$1.type === types._default) {
			var isCase = this$1.type === types._case;
			if (cur) {
		this$1.finishNode(cur, "SwitchCase");
			}
			node.cases.push(cur = this$1.startNode());
			cur.consequent = [];
			this$1.next();
			if (isCase) {
		cur.test = this$1.parseExpression();
			} else {
		if (sawDefault) {
					this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses");
		}
		sawDefault = true;
		cur.test = null;
			}
			this$1.expect(types.colon);
	} else {
			if (!cur) {
		this$1.unexpected();
			}
			cur.consequent.push(this$1.parseStatement(true));
	}
  }
  this.exitLexicalScope();
  if (cur) {
	this.finishNode(cur, "SwitchCase");
  }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp$1.parseThrowStatement = function (node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
	this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty = [];

pp$1.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
	var clause = this.startNode();
	this.next();
	this.expect(types.parenL);
	clause.param = this.parseBindingAtom();
	this.enterLexicalScope();
	this.checkLVal(clause.param, "let");
	this.expect(types.parenR);
	clause.body = this.parseBlock(false);
	this.exitLexicalScope();
	node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
	this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};

pp$1.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp$1.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp$1.parseWithStatement = function (node) {
  if (this.strict) {
	this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp$1.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp$1.parseLabeledStatement = function (node, maybeName, expr) {
  var this$1 = this;

  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1) {
	var label = list[i$1];

	if (label.name === maybeName) {
			this$1.raise(expr.start, "Label '" + maybeName + "' is already declared");
	}
  }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
	var label$1 = this$1.labels[i];
	if (label$1.statementStart == node.start) {
			label$1.statementStart = this$1.start;
			label$1.kind = kind;
	} else {
			break;
	}
  }
  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
  node.body = this.parseStatement(true);
  if (node.body.type == "ClassDeclaration" || node.body.type == "VariableDeclaration" && node.body.kind != "var" || node.body.type == "FunctionDeclaration" && (this.strict || node.body.generator)) {
	this.raiseRecoverable(node.body.start, "Invalid labeled declaration");
  }
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp$1.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$1.parseBlock = function (createNewLexicalScope) {
  var this$1 = this;
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;

  var node = this.startNode();
  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) {
	this.enterLexicalScope();
  }
  while (!this.eat(types.braceR)) {
	var stmt = this$1.parseStatement(true);
	node.body.push(stmt);
  }
  if (createNewLexicalScope) {
	this.exitLexicalScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$1.parseFor = function (node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$1.parseForIn = function (node, init) {
  var type = this.type === types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type);
};
pp$1.parseVar = function (node, isFor, kind) {
  var this$1 = this;

  node.declarations = [];
  node.kind = kind;
  for (;;) {
	var decl = this$1.startNode();
	this$1.parseVarId(decl, kind);
	if (this$1.eat(types.eq)) {
			decl.init = this$1.parseMaybeAssign(isFor);
	} else if (kind === "const" && !(this$1.type === types._in || this$1.options.ecmaVersion >= 6 && this$1.isContextual("of"))) {
			this$1.unexpected();
	} else if (decl.id.type != "Identifier" && !(isFor && (this$1.type === types._in || this$1.isContextual("of")))) {
			this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value");
	} else {
			decl.init = null;
	}
	node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"));
	if (!this$1.eat(types.comma)) {
			break;
	}
  }
  return node;
};

pp$1.parseVarId = function (decl, kind) {
  decl.id = this.parseBindingAtom(kind);
  this.checkLVal(decl.id, kind, false);
};
pp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6 && !isAsync) {
	node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion >= 8) {
	node.async = !!isAsync;
  }

  if (isStatement) {
	node.id = isStatement === "nullableID" && this.type != types.name ? null : this.parseIdent();
	if (node.id) {
			this.checkLVal(node.id, "var");
	}
  }

  var oldInGen = this.inGenerator,
			oldInAsync = this.inAsync,
			oldYieldPos = this.yieldPos,
			oldAwaitPos = this.awaitPos,
			oldInFunc = this.inFunction;
  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  if (!isStatement) {
	node.id = this.type == types.name ? this.parseIdent() : null;
  }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp$1.parseFunctionParams = function (node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$1.parseClass = function (node, isStatement) {
  var this$1 = this;

  this.next();

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  var decorators = [];
  while (!this.eat(types.braceR)) {
	if (this$1.eat(types.semi)) {
			continue;
	}
	if (this$1.type == types.at) {
			this$1.next();
			var expr = this$1.parseMaybeAssign(true);
			decorators.push(expr);
			continue;
	}
	var method = this$1.startNode();
	var isGenerator = this$1.eat(types.star);
	var isAsync = false;
	var isMaybeStatic = this$1.type === types.name && this$1.value === "static";
	this$1.parsePropertyName(method);
	method.static = isMaybeStatic && this$1.type !== types.parenL;
	if (method.static) {
			if (isGenerator) {
		this$1.unexpected();
			}
			isGenerator = this$1.eat(types.star);
			this$1.parsePropertyName(method);
	}
	if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed && method.key.type === "Identifier" && method.key.name === "async" && this$1.type !== types.parenL && !this$1.canInsertSemicolon()) {
			isAsync = true;
			this$1.parsePropertyName(method);
	}
	method.kind = "method";
	var isGetSet = false;
	if (!method.computed) {
			var key = method.key;
			if (!isGenerator && !isAsync && key.type === "Identifier" && this$1.type !== types.parenL && (key.name === "get" || key.name === "set")) {
		isGetSet = true;
		method.kind = key.name;
		key = this$1.parsePropertyName(method);
			}
			if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
		if (hadConstructor) {
					this$1.raise(key.start, "Duplicate constructor in the same class");
		}
		if (isGetSet) {
					this$1.raise(key.start, "Constructor can't have get/set modifier");
		}
		if (isGenerator) {
					this$1.raise(key.start, "Constructor can't be a generator");
		}
		if (isAsync) {
					this$1.raise(key.start, "Constructor can't be an async method");
		}
		method.kind = "constructor";
		hadConstructor = true;
			} else if (method.static && key.type === "Identifier" && key.name === "prototype") {
		this$1.raise(key.start, "Classes may not have a static property named prototype");
			}
	}

	if (this$1.type == types.eq) {
			this$1.next();
			method.value = this$1.parseExpression();
	} else if (this$1.type == types.semi || this$1.canInsertSemicolon()) {
			if (this$1.type == types.semi) {
		this$1.next();
			}
			var node$1 = this$1.startNode();
			node$1.body = [];
			method.value = this$1.finishNode(node$1, "BlockStatement");
	}
	if (method.value) {
			method.kind = 'class';
			classBody.body.push(this$1.finishNode(method, "Property"));
			continue;
	}

	this$1.parseClassMethod(classBody, method, isGenerator, isAsync);
	if (decorators.length) {
			var body = method.value.body.body;
			if (body) {
		body.unshift.apply(body, decorators);
			}
			decorators = [];
	}
	if (isGetSet) {
			var paramCount = method.kind === "get" ? 0 : 1;
			if (method.value.params.length !== paramCount) {
		var start = method.value.start;
		if (method.kind === "get") {
					this$1.raiseRecoverable(start, "getter should have no params");
		} else {
					this$1.raiseRecoverable(start, "setter should have exactly one param");
		}
			} else {
		if (method.kind === "set" && method.value.params[0].type === "RestElement") {
					this$1.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
		}
			}
	}
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {
  method.value = this.parseMethod(isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp$1.parseClassId = function (node, isStatement) {
  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;
};

pp$1.parseClassSuper = function (node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};
pp$1.parseExport = function (node, exports) {
  var this$1 = this;

  this.next();
  if (this.eat(types.star)) {
	this.expectContextual("from");
	if (this.type !== types.string) {
			this.unexpected();
	}
	node.source = this.parseExprAtom();
	this.semicolon();
	return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(types._default)) {
	this.checkExport(exports, "default", this.lastTokStart);
	var isAsync;
	if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
			var fNode = this.startNode();
			this.next();
			if (isAsync) {
		this.next();
			}
			node.declaration = this.parseFunction(fNode, "nullableID", false, isAsync);
	} else if (this.type === types._class) {
			var cNode = this.startNode();
			node.declaration = this.parseClass(cNode, "nullableID");
	} else {
			node.declaration = this.parseMaybeAssign();
			this.semicolon();
	}
	return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
	node.declaration = this.parseStatement(true);
	if (node.declaration.type === "VariableDeclaration") {
			this.checkVariableExport(exports, node.declaration.declarations);
	} else {
			this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
	}
	node.specifiers = [];
	node.source = null;
  } else {
	node.declaration = null;
	node.specifiers = this.parseExportSpecifiers(exports);
	if (this.eatContextual("from")) {
			if (this.type !== types.string) {
		this.unexpected();
			}
			node.source = this.parseExprAtom();
	} else {
			for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
		var spec = list[i];

		this$1.checkUnreserved(spec.local);
			}

			node.source = null;
	}
	this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp$1.checkExport = function (exports, name, pos) {
  if (!exports) {
	return;
  }
  if (has(exports, name)) {
	this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports[name] = true;
};

pp$1.checkPatternExport = function (exports, pat) {
  var this$1 = this;

  var type = pat.type;
  if (type == "Identifier") {
	this.checkExport(exports, pat.name, pat.start);
  } else if (type == "ObjectPattern") {
	for (var i = 0, list = pat.properties; i < list.length; i += 1) {
			var prop = list[i];

			this$1.checkPatternExport(exports, prop.value);
	}
  } else if (type == "ArrayPattern") {
	for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
			var elt = list$1[i$1];

			if (elt) {
		this$1.checkPatternExport(exports, elt);
			}
	}
  } else if (type == "AssignmentPattern") {
	this.checkPatternExport(exports, pat.left);
  } else if (type == "ParenthesizedExpression") {
	this.checkPatternExport(exports, pat.expression);
  }
};

pp$1.checkVariableExport = function (exports, decls) {
  var this$1 = this;

  if (!exports) {
	return;
  }
  for (var i = 0, list = decls; i < list.length; i += 1) {
	var decl = list[i];

	this$1.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function () {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$1.parseExportSpecifiers = function (exports) {
  var this$1 = this;

  var nodes = [],
			first = true;
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
	if (!first) {
			this$1.expect(types.comma);
			if (this$1.afterTrailingComma(types.braceR)) {
		break;
			}
	} else {
			first = false;
	}

	var node = this$1.startNode();
	node.local = this$1.parseIdent(true);
	node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local;
	this$1.checkExport(exports, node.exported.name, node.exported.start);
	nodes.push(this$1.finishNode(node, "ExportSpecifier"));
  }
  return nodes;
};
pp$1.parseImport = function (node) {
  this.next();
  if (this.type === types.string) {
	node.specifiers = empty;
	node.source = this.parseExprAtom();
  } else {
	node.specifiers = this.parseImportSpecifiers();
	this.expectContextual("from");
	node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$1.parseImportSpecifiers = function () {
  var this$1 = this;

  var nodes = [],
			first = true;
  if (this.type === types.name) {
	var node = this.startNode();
	node.local = this.parseIdent();
	this.checkLVal(node.local, "let");
	nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
	if (!this.eat(types.comma)) {
			return nodes;
	}
  }
  if (this.type === types.star) {
	var node$1 = this.startNode();
	this.next();
	this.expectContextual("as");
	node$1.local = this.parseIdent();
	this.checkLVal(node$1.local, "let");
	nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
	return nodes;
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
	if (!first) {
			this$1.expect(types.comma);
			if (this$1.afterTrailingComma(types.braceR)) {
		break;
			}
	} else {
			first = false;
	}

	var node$2 = this$1.startNode();
	node$2.imported = this$1.parseIdent(true);
	if (this$1.eatContextual("as")) {
			node$2.local = this$1.parseIdent();
	} else {
			this$1.checkUnreserved(node$2.imported);
			node$2.local = node$2.imported;
	}
	this$1.checkLVal(node$2.local, "let");
	nodes.push(this$1.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes;
};
pp$1.adaptDirectivePrologue = function (statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
	statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function (statement) {
  return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (
  this.input[statement.start] === "\"" || this.input[statement.start] === "'");
};

var pp$2 = Parser.prototype;
pp$2.toAssignable = function (node, isBinding) {
  var this$1 = this;

  if (this.options.ecmaVersion >= 6 && node) {
	switch (node.type) {
			case "Identifier":
		if (this.inAsync && node.name === "await") {
					this.raise(node.start, "Can not use 'await' as identifier inside an async function");
		}
		break;

			case "ObjectPattern":
			case "ArrayPattern":
			case "RestElement":
		break;

			case "ObjectExpression":
		node.type = "ObjectPattern";
		for (var i = 0, list = node.properties; i < list.length; i += 1) {
					var prop = list[i];

					this$1.toAssignable(prop, isBinding);
		}
		break;

			case "Property":
		if (node.kind !== "init") {
					this.raise(node.key.start, "Object pattern can't contain getter or setter");
		}
		this.toAssignable(node.value, isBinding);
		break;

			case "ArrayExpression":
		node.type = "ArrayPattern";
		this.toAssignableList(node.elements, isBinding);
		break;

			case "SpreadElement":
		node.type = "RestElement";
		this.toAssignable(node.argument, isBinding);
		if (node.argument.type === "AssignmentPattern") {
					this.raise(node.argument.start, "Rest elements cannot have a default value");
		}
		break;

			case "AssignmentExpression":
		if (node.operator !== "=") {
					this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
		}
		node.type = "AssignmentPattern";
		delete node.operator;
		this.toAssignable(node.left, isBinding);
			case "AssignmentPattern":
		break;

			case "ParenthesizedExpression":
		this.toAssignable(node.expression, isBinding);
		break;

			case "MemberExpression":
		if (!isBinding) {
					break;
		}

			default:
		this.raise(node.start, "Assigning to rvalue");
	}
  }
  return node;
};
pp$2.toAssignableList = function (exprList, isBinding) {
  var this$1 = this;

  var end = exprList.length;
  for (var i = 0; i < end; i++) {
	var elt = exprList[i];
	if (elt) {
			this$1.toAssignable(elt, isBinding);
	}
  }
  if (end) {
	var last = exprList[end - 1];
	if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
			this.unexpected(last.argument.start);
	}
  }
  return exprList;
};
pp$2.parseSpread = function (refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};

pp$2.parseRestBinding = function () {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types.name) {
	this.unexpected();
  }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement");
};
pp$2.parseBindingAtom = function () {
  if (this.options.ecmaVersion >= 6) {
	switch (this.type) {
			case types.bracketL:
		var node = this.startNode();
		this.next();
		node.elements = this.parseBindingList(types.bracketR, true, true);
		return this.finishNode(node, "ArrayPattern");

			case types.braceL:
		return this.parseObj(true);
	}
  }
  return this.parseIdent();
};

pp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
  var this$1 = this;

  var elts = [],
			first = true;
  while (!this.eat(close)) {
	if (first) {
			first = false;
	} else {
			this$1.expect(types.comma);
	}
	if (allowEmpty && this$1.type === types.comma) {
			elts.push(null);
	} else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
			break;
	} else if (this$1.type === types.ellipsis) {
			var rest = this$1.parseRestBinding();
			this$1.parseBindingListItem(rest);
			elts.push(rest);
			if (this$1.type === types.comma) {
		this$1.raise(this$1.start, "Comma is not permitted after the rest element");
			}
			this$1.expect(close);
			break;
	} else {
			var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
			this$1.parseBindingListItem(elem);
			elts.push(elem);
	}
  }
  return elts;
};

pp$2.parseBindingListItem = function (param) {
  return param;
};
pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {
	return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$2.checkLVal = function (expr, bindingType, checkClashes) {
  var this$1 = this;

  switch (expr.type) {
	case "Identifier":
			if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
		this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
			}
			if (checkClashes) {
		if (has(checkClashes, expr.name)) {
					this.raiseRecoverable(expr.start, "Argument name clash");
		}
		checkClashes[expr.name] = true;
			}
			if (bindingType && bindingType !== "none") {
		if (bindingType === "var" && !this.canDeclareVarName(expr.name) || bindingType !== "var" && !this.canDeclareLexicalName(expr.name)) {
					this.raiseRecoverable(expr.start, "Identifier '" + expr.name + "' has already been declared");
		}
		if (bindingType === "var") {
					this.declareVarName(expr.name);
		} else {
					this.declareLexicalName(expr.name);
		}
			}
			break;

	case "MemberExpression":
			if (bindingType) {
		this.raiseRecoverable(expr.start, "Binding member expression");
			}
			break;

	case "ObjectPattern":
			for (var i = 0, list = expr.properties; i < list.length; i += 1) {
		var prop = list[i];

		this$1.checkLVal(prop, bindingType, checkClashes);
			}
			break;

	case "Property":
			this.checkLVal(expr.value, bindingType, checkClashes);
			break;

	case "ArrayPattern":
			for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
		var elem = list$1[i$1];

		if (elem) {
					this$1.checkLVal(elem, bindingType, checkClashes);
		}
			}
			break;

	case "AssignmentPattern":
			this.checkLVal(expr.left, bindingType, checkClashes);
			break;

	case "RestElement":
			this.checkLVal(expr.argument, bindingType, checkClashes);
			break;

	case "ParenthesizedExpression":
			this.checkLVal(expr.expression, bindingType, checkClashes);
			break;

	default:
			this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};
//
//
var pp$3 = Parser.prototype;
pp$3.checkPropClash = function (prop, propHash) {
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
	return;
  }
  var key = prop.key;
  var name;
  switch (key.type) {
	case "Identifier":
			name = key.name;break;
	case "Literal":
			name = String(key.value);break;
	default:
			return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
	if (name === "__proto__" && kind === "init") {
			if (propHash.proto) {
		this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
			}
			propHash.proto = true;
	}
	return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
	var redefinition;
	if (kind === "init") {
			redefinition = this.strict && other.init || other.get || other.set;
	} else {
			redefinition = other.init || other[kind];
	}
	if (redefinition) {
			this.raiseRecoverable(key.start, "Redefinition of property");
	}
  } else {
	other = propHash[name] = {
			init: false,
			get: false,
			set: false
	};
  }
  other[kind] = true;
};
pp$3.parseExpression = function (noIn, refDestructuringErrors) {
  var this$1 = this;

  var startPos = this.start,
			startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
	var node = this.startNodeAt(startPos, startLoc);
	node.expressions = [expr];
	while (this.eat(types.comma)) {
			node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors));
	}
	return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) {
	return this.parseYield();
  }

  var ownDestructuringErrors = false,
			oldParenAssign = -1,
			oldTrailingComma = -1;
  if (refDestructuringErrors) {
	oldParenAssign = refDestructuringErrors.parenthesizedAssign;
	oldTrailingComma = refDestructuringErrors.trailingComma;
	refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
	refDestructuringErrors = new DestructuringErrors();
	ownDestructuringErrors = true;
  }

  var startPos = this.start,
			startLoc = this.startLoc;
  if (this.type == types.parenL || this.type == types.name) {
	this.potentialArrowAt = this.start;
  }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) {
	left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
	this.checkPatternErrors(refDestructuringErrors, true);
	if (!ownDestructuringErrors) {
			DestructuringErrors.call(refDestructuringErrors);
	}
	var node = this.startNodeAt(startPos, startLoc);
	node.operator = this.value;
	node.left = this.type === types.eq ? this.toAssignable(left) : left;
	refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
	this.checkLVal(left);
	this.next();
	node.right = this.parseMaybeAssign(noIn);
	return this.finishNode(node, "AssignmentExpression");
  } else {
	if (ownDestructuringErrors) {
			this.checkExpressionErrors(refDestructuringErrors, true);
	}
  }
  if (oldParenAssign > -1) {
	refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
	refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
			startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
	return expr;
  }
  if (this.eat(types.question)) {
	var node = this.startNodeAt(startPos, startLoc);
	node.test = expr;
	node.consequent = this.parseMaybeAssign();
	this.expect(types.colon);
	node.alternate = this.parseMaybeAssign(noIn);
	return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$3.parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
			startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
	return expr;
  }
  return expr.start == startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
};
pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
	if (prec > minPrec) {
			var logical = this.type === types.logicalOR || this.type === types.logicalAND;
			var op = this.value;
			this.next();
			var startPos = this.start,
					startLoc = this.startLoc;
			var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
			var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
			return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
	}
  }
  return left;
};

pp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
  var this$1 = this;

  var startPos = this.start,
			startLoc = this.startLoc,
			expr;
  if (this.inAsync && this.isContextual("await")) {
	expr = this.parseAwait();
	sawUnary = true;
  } else if (this.type.prefix) {
	var node = this.startNode(),
		update = this.type === types.incDec;
	node.operator = this.value;
	node.prefix = true;
	this.next();
	node.argument = this.parseMaybeUnary(null, true);
	this.checkExpressionErrors(refDestructuringErrors, true);
	if (update) {
			this.checkLVal(node.argument);
	} else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
			this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
	} else {
			sawUnary = true;
	}
	expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
	expr = this.parseExprSubscripts(refDestructuringErrors);
	if (this.checkExpressionErrors(refDestructuringErrors)) {
			return expr;
	}
	while (this.type.postfix && !this.canInsertSemicolon()) {
			var node$1 = this$1.startNodeAt(startPos, startLoc);
			node$1.operator = this$1.value;
			node$1.prefix = false;
			node$1.argument = expr;
			this$1.checkLVal(expr);
			this$1.next();
			expr = this$1.finishNode(node$1, "UpdateExpression");
	}
  }

  if (!sawUnary && this.eat(types.starstar)) {
	return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
  } else {
	return expr;
  }
};
pp$3.parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start,
			startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) {
	return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
	if (refDestructuringErrors.parenthesizedAssign >= result.start) {
			refDestructuringErrors.parenthesizedAssign = -1;
	}
	if (refDestructuringErrors.parenthesizedBind >= result.start) {
			refDestructuringErrors.parenthesizedBind = -1;
	}
  }
  return result;
};

pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  var this$1 = this;

  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd == base.end && !this.canInsertSemicolon();
  for (var computed = void 0;;) {
	if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {
			var node$1 = this$1.startNodeAt(startPos, startLoc);
			node$1.object = base;
			node$1.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);
			node$1.computed = !!computed;
			if (computed) {
		this$1.expect(types.bracketR);
			}
			base = this$1.finishNode(node$1, "MemberExpression");
	} else if (!noCalls && this$1.eat(types.parenL)) {
			var refDestructuringErrors = new DestructuringErrors(),
					oldYieldPos = this$1.yieldPos,
					oldAwaitPos = this$1.awaitPos;
			this$1.yieldPos = 0;
			this$1.awaitPos = 0;
			var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);
			if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {
		this$1.checkPatternErrors(refDestructuringErrors, false);
		this$1.checkYieldAwaitInDefaultParams();
		this$1.yieldPos = oldYieldPos;
		this$1.awaitPos = oldAwaitPos;
		return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true);
			}
			this$1.checkExpressionErrors(refDestructuringErrors, true);
			this$1.yieldPos = oldYieldPos || this$1.yieldPos;
			this$1.awaitPos = oldAwaitPos || this$1.awaitPos;
			var node$2 = this$1.startNodeAt(startPos, startLoc);
			node$2.callee = base;
			node$2.arguments = exprList;
			base = this$1.finishNode(node$2, "CallExpression");
	} else if (this$1.type === types.backQuote) {
			var node$3 = this$1.startNodeAt(startPos, startLoc);
			node$3.tag = base;
			node$3.quasi = this$1.parseTemplate({ isTagged: true });
			base = this$1.finishNode(node$3, "TaggedTemplateExpression");
	} else if (this$1.type == types.colon && this$1.input[this$1.end] == ":" && this$1.options.ecmaVersion >= 7) {
			this$1.next();
			this$1.next();
			var node = this$1.startNodeAt(startPos, startLoc);
			node.expressions = [base];
			var e2 = this$1.parseExpression();
			node.expressions.push(e2);
			base = this$1.finishNode(node, "SequenceExpression");
	} else {
			return base;
	}
  }
};
pp$3.parseExprAtom = function (refDestructuringErrors) {
  var node,
			canBeArrow = this.potentialArrowAt == this.start;
  switch (this.type) {
	case types._super:
			if (!this.inFunction) {
		this.raise(this.start, "'super' outside of function or class");
			}
			node = this.startNode();
			this.next();
			if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {
		this.unexpected();
			}
			return this.finishNode(node, "Super");

	case types._this:
			node = this.startNode();
			this.next();
			return this.finishNode(node, "ThisExpression");

	case types.name:
			var startPos = this.start,
					startLoc = this.startLoc;
			var id = this.parseIdent(this.type !== types.name);
			if (this.options.ecmaVersion >= 8 && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
		return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true);
			}
			if (canBeArrow && !this.canInsertSemicolon()) {
		if (this.eat(types.arrow)) {
					return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);
		}
		if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name) {
					id = this.parseIdent();
					if (this.canInsertSemicolon() || !this.eat(types.arrow)) {
			this.unexpected();
					}
					return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);
		}
			}
			return id;

	case types.regexp:
			var value = this.value;
			node = this.parseLiteral(value.value);
			node.regex = { pattern: value.pattern, flags: value.flags };
			return node;

	case types.num:case types.string:
			return this.parseLiteral(this.value);

	case types._null:case types._true:case types._false:
			node = this.startNode();
			node.value = this.type === types._null ? null : this.type === types._true;
			node.raw = this.type.keyword;
			this.next();
			return this.finishNode(node, "Literal");

	case types.parenL:
			var start = this.start,
					expr = this.parseParenAndDistinguishExpression(canBeArrow);
			if (refDestructuringErrors) {
		if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
					refDestructuringErrors.parenthesizedAssign = start;
		}
		if (refDestructuringErrors.parenthesizedBind < 0) {
					refDestructuringErrors.parenthesizedBind = start;
		}
			}
			return expr;

	case types.bracketL:
			node = this.startNode();
			this.next();
			node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
			return this.finishNode(node, "ArrayExpression");

	case types.braceL:
			return this.parseObj(false, refDestructuringErrors);

	case types._function:
			node = this.startNode();
			this.next();
			return this.parseFunction(node, false);

	case types._class:
			return this.parseClass(this.startNode(), false);

	case types._new:
			return this.parseNew();

	case types.backQuote:
			return this.parseTemplate();

	case types._do:
			this.next();
			return this.parseStatement();
	case types.at:
			this.next();
			return this.parseExprAtom();
	case types.colon:
			if (this.input[this.end] == ":") {
		this.next();
		this.next();
		return this.parseExprSubscripts(refDestructuringErrors);
			}

	default:
			this.unexpected();
  }
};

pp$3.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal");
};

pp$3.parseParenExpression = function () {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val;
};

pp$3.parseParenAndDistinguishExpression = function (canBeArrow) {
  var this$1 = this;

  var startPos = this.start,
			startLoc = this.startLoc,
			val,
			allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
	this.next();

	var innerStartPos = this.start,
		innerStartLoc = this.startLoc;
	var exprList = [],
		first = true,
		lastIsComma = false;
	var refDestructuringErrors = new DestructuringErrors(),
		oldYieldPos = this.yieldPos,
		oldAwaitPos = this.awaitPos,
		spreadStart;
	this.yieldPos = 0;
	this.awaitPos = 0;
	while (this.type !== types.parenR) {
			first ? first = false : this$1.expect(types.comma);
			if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {
		lastIsComma = true;
		break;
			} else if (this$1.type === types.ellipsis) {
		spreadStart = this$1.start;
		exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));
		if (this$1.type === types.comma) {
					this$1.raise(this$1.start, "Comma is not permitted after the rest element");
		}
		break;
			} else {
		exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
			}
	}
	var innerEndPos = this.start,
		innerEndLoc = this.startLoc;
	this.expect(types.parenR);

	if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
			this.checkPatternErrors(refDestructuringErrors, false);
			this.checkYieldAwaitInDefaultParams();
			this.yieldPos = oldYieldPos;
			this.awaitPos = oldAwaitPos;
			return this.parseParenArrowList(startPos, startLoc, exprList);
	}

	if (!exprList.length || lastIsComma) {
			this.unexpected(this.lastTokStart);
	}
	if (spreadStart) {
			this.unexpected(spreadStart);
	}
	this.checkExpressionErrors(refDestructuringErrors, true);
	this.yieldPos = oldYieldPos || this.yieldPos;
	this.awaitPos = oldAwaitPos || this.awaitPos;

	if (exprList.length > 1) {
			val = this.startNodeAt(innerStartPos, innerStartLoc);
			val.expressions = exprList;
			this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
	} else {
			val = exprList[0];
	}
  } else {
	val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
	var par = this.startNodeAt(startPos, startLoc);
	par.expression = val;
	return this.finishNode(par, "ParenthesizedExpression");
  } else {
	return val;
  }
};

pp$3.parseParenItem = function (item) {
  return item;
};

pp$3.parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
};
var empty$1 = [];

pp$3.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
	node.meta = meta;
	node.property = this.parseIdent(true);
	if (node.property.name !== "target") {
			this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
	}
	if (!this.inFunction) {
			this.raiseRecoverable(node.start, "new.target can only be used in functions");
	}
	return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start,
			startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(types.parenL)) {
	node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);
  } else {
	node.arguments = empty$1;
  }
  return this.finishNode(node, "NewExpression");
};
pp$3.parseTemplateElement = function (ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
	if (!isTagged) {
			this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
	}
	elem.value = {
			raw: this.value,
			cooked: null
	};
  } else {
	elem.value = {
			raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
			cooked: this.value
	};
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp$3.parseTemplate = function (ref) {
  var this$1 = this;
  if (ref === void 0) ref = {};
  var isTagged = ref.isTagged;if (isTagged === void 0) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged: isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
	this$1.expect(types.dollarBraceL);
	node.expressions.push(this$1.parseExpression());
	this$1.expect(types.braceR);
	node.quasis.push(curElt = this$1.parseTemplateElement({ isTagged: isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

pp$3.isAsyncProp = function (prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$3.parseObj = function (isPattern, refDestructuringErrors) {
  var this$1 = this;

  var node = this.startNode(),
			first = true,
			propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
	if (!first) {
			this$1.expect(types.comma);
			if (this$1.afterTrailingComma(types.braceR)) {
		break;
			}
	} else {
			first = false;
	}

	var prop = this$1.parseProperty(isPattern, refDestructuringErrors);
	if (!isPattern) {
			this$1.checkPropClash(prop, propHash);
	}
	node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp$3.parseProperty = function (isPattern, refDestructuringErrors) {
  var prop = this.startNode(),
			isGenerator,
			isAsync,
			startPos,
			startLoc;
  if (this.options.ecmaVersion >= 6) {
	prop.method = false;
	prop.shorthand = false;
	if (isPattern || refDestructuringErrors) {
			startPos = this.start;
			startLoc = this.startLoc;
	}
	if (!isPattern) {
			isGenerator = this.eat(types.star);
	}
  }
  this.parsePropertyName(prop);
  if (!isPattern && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
	isAsync = true;
	this.parsePropertyName(prop, refDestructuringErrors);
  } else {
	isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors);
  return this.finishNode(prop, "Property");
};

pp$3.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {
  if ((isGenerator || isAsync) && this.type === types.colon) {
	this.unexpected();
  }

  if (this.eat(types.colon)) {
	prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
	prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
	if (isPattern) {
			this.unexpected();
	}
	prop.kind = "init";
	prop.method = true;
	prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type != types.comma && this.type != types.braceR) {
	if (isGenerator || isAsync) {
			this.unexpected();
	}
	prop.kind = prop.key.name;
	this.parsePropertyName(prop);
	prop.value = this.parseMethod(false);
	var paramCount = prop.kind === "get" ? 0 : 1;
	if (prop.value.params.length !== paramCount) {
			var start = prop.value.start;
			if (prop.kind === "get") {
		this.raiseRecoverable(start, "getter should have no params");
			} else {
		this.raiseRecoverable(start, "setter should have exactly one param");
			}
	} else {
			if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
		this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
			}
	}
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	this.checkUnreserved(prop.key);
	prop.kind = "init";
	if (isPattern) {
			prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	} else if (this.type === types.eq && refDestructuringErrors) {
			if (refDestructuringErrors.shorthandAssign < 0) {
		refDestructuringErrors.shorthandAssign = this.start;
			}
			prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	} else {
			prop.value = prop.key;
	}
	prop.shorthand = true;
  } else {
	this.unexpected();
  }
};

pp$3.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
	if (this.eat(types.bracketL)) {
			prop.computed = true;
			prop.key = this.parseMaybeAssign();
			this.expect(types.bracketR);
			return prop.key;
	} else {
			prop.computed = false;
	}
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true);
};
pp$3.initFunction = function (node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
	node.generator = false;
	node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
	node.async = false;
  }
};
pp$3.parseMethod = function (isGenerator, isAsync) {
  var node = this.startNode(),
			oldInGen = this.inGenerator,
			oldInAsync = this.inAsync,
			oldYieldPos = this.yieldPos,
			oldAwaitPos = this.awaitPos,
			oldInFunc = this.inFunction;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
	node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
	node.async = !!isAsync;
  }

  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "FunctionExpression");
};
pp$3.parseArrowExpression = function (node, params, isAsync) {
  var oldInGen = this.inGenerator,
			oldInAsync = this.inAsync,
			oldYieldPos = this.yieldPos,
			oldAwaitPos = this.awaitPos,
			oldInFunc = this.inFunction;

  this.enterFunctionScope();
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
	node.async = !!isAsync;
  }

  this.inGenerator = false;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$3.parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict,
			useStrict = false;

  if (isExpression) {
	node.body = this.parseMaybeAssign();
	node.expression = true;
	this.checkParams(node, false);
  } else {
	var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
	if (!oldStrict || nonSimple) {
			useStrict = this.strictDirective(this.end);
			if (useStrict && nonSimple) {
		this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
			}
	}
	var oldLabels = this.labels;
	this.labels = [];
	if (useStrict) {
			this.strict = true;
	}
	this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));
	node.body = this.parseBlock(false);
	node.expression = false;
	this.adaptDirectivePrologue(node.body.body);
	this.labels = oldLabels;
  }
  this.exitFunctionScope();

  if (this.strict && node.id) {
	this.checkLVal(node.id, "none");
  }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function (params) {
  for (var i = 0, list = params; i < list.length; i += 1) {
	var param = list[i];

	if (param.type !== "Identifier") {
			return false;
	}
  }
  return true;
};
pp$3.checkParams = function (node, allowDuplicates) {
  var this$1 = this;

  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1) {
	var param = list[i];

	this$1.checkLVal(param, "var", allowDuplicates ? null : nameHash);
  }
};
pp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var this$1 = this;

  var elts = [],
			first = true;
  while (!this.eat(close)) {
	if (!first) {
			this$1.expect(types.comma);
			if (allowTrailingComma && this$1.afterTrailingComma(close)) {
		break;
			}
	} else {
			first = false;
	}

	var elt = void 0;
	if (allowEmpty && this$1.type === types.comma) {
			elt = null;
	} else if (this$1.type === types.ellipsis) {
			elt = this$1.parseSpread(refDestructuringErrors);
			if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0) {
		refDestructuringErrors.trailingComma = this$1.start;
			}
	} else {
			elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
	}
	elts.push(elt);
  }
  return elts;
};

pp$3.checkUnreserved = function (ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield") {
	this.raiseRecoverable(start, "Can not use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
	this.raiseRecoverable(start, "Can not use 'await' as identifier inside an async function");
  }
  if (this.isKeyword(name)) {
	this.raise(start, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") != -1) {
	return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
	this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
};
pp$3.parseIdent = function (liberal, isBinding) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved == "never") {
	liberal = false;
  }
  if (this.type === types.name) {
	node.name = this.value;
  } else if (this.type.keyword) {
	node.name = this.type.keyword;
	if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
			this.context.pop();
	}
  } else {
	this.unexpected();
  }
  this.next();
  this.finishNode(node, "Identifier");
  if (!liberal) {
	this.checkUnreserved(node);
  }
  return node;
};
pp$3.parseYield = function () {
  if (!this.yieldPos) {
	this.yieldPos = this.start;
  }

  var node = this.startNode();
  this.next();
  if (this.type == types.semi || this.canInsertSemicolon() || this.type != types.star && !this.type.startsExpr) {
	node.delegate = false;
	node.argument = null;
  } else {
	node.delegate = this.eat(types.star);
	node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

pp$3.parseAwait = function () {
  if (!this.awaitPos) {
	this.awaitPos = this.start;
  }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression");
};

var pp$4 = Parser.prototype;
pp$4.raise = function (pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
  throw err;
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function () {
  if (this.options.locations) {
	return new Position(this.curLine, this.pos - this.lineStart);
  }
};

var pp$5 = Parser.prototype;
var assign = Object.assign || function (target) {
  var sources = [],
			len = arguments.length - 1;
  while (len-- > 0) {
	sources[len] = arguments[len + 1];
  }for (var i = 0, list = sources; i < list.length; i += 1) {
	var source = list[i];

	for (var key in source) {
			if (has(source, key)) {
		target[key] = source[key];
			}
	}
  }
  return target;
};
pp$5.enterFunctionScope = function () {
  this.scopeStack.push({ var: {}, lexical: {}, childVar: {}, parentLexical: {} });
};

pp$5.exitFunctionScope = function () {
  this.scopeStack.pop();
};

pp$5.enterLexicalScope = function () {
  var parentScope = this.scopeStack[this.scopeStack.length - 1];
  var childScope = { var: {}, lexical: {}, childVar: {}, parentLexical: {} };

  this.scopeStack.push(childScope);
  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);
};

pp$5.exitLexicalScope = function () {
  var childScope = this.scopeStack.pop();
  var parentScope = this.scopeStack[this.scopeStack.length - 1];

  assign(parentScope.childVar, childScope.var, childScope.childVar);
};
pp$5.canDeclareVarName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name);
};
pp$5.canDeclareLexicalName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name);
};

pp$5.declareVarName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].var[name] = true;
};

pp$5.declareLexicalName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
	this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
	this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
	this.range = [pos, 0];
  }
};
var pp$6 = Parser.prototype;

pp$6.startNode = function () {
  return new Node(this, this.start, this.startLoc);
};

pp$6.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
	node.loc.end = loc;
  }
  if (this.options.ranges) {
	node.range[1] = pos;
  }
  return node;
}

pp$6.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$6.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};
var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
	return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function () {
  return [types$1.b_stat];
};

pp$7.braceIsBlock = function (prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat) {
	return true;
  }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {
	return !parent.isExpr;
  }
  if (prevType === types._return || prevType == types.name && this.exprAllowed) {
	return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType == types.arrow) {
	return true;
  }
  if (prevType == types.braceL) {
	return parent === types$1.b_stat;
  }
  if (prevType == types._var || prevType == types.name) {
	return false;
  }
  return !this.exprAllowed;
};

pp$7.inGeneratorContext = function () {
  var this$1 = this;

  for (var i = this.context.length - 1; i >= 1; i--) {
	var context = this$1.context[i];
	if (context.token === "function") {
			return context.generator;
	}
  }
  return false;
};

pp$7.updateContext = function (prevType) {
  var update,
			type = this.type;
  if (type.keyword && prevType == types.dot) {
	this.exprAllowed = false;
  } else if (update = type.updateContext) {
	update.call(this, prevType);
  } else {
	this.exprAllowed = type.beforeExpr;
  }
};
types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.context.length == 1) {
	this.exprAllowed = true;
	return;
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
	out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function () {
};

types._function.updateContext = types._class.updateContext = function (prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
	this.context.push(types$1.f_expr);
  } else {
	this.context.push(types$1.f_stat);
  }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.q_tmpl) {
	this.context.pop();
  } else {
	this.context.push(types$1.q_tmpl);
  }
  this.exprAllowed = false;
};

types.star.updateContext = function (prevType) {
  if (prevType == types._function) {
	var index = this.context.length - 1;
	if (this.context[index] === types$1.f_expr) {
			this.context[index] = types$1.f_expr_gen;
	} else {
			this.context[index] = types$1.f_gen;
	}
  }
  this.exprAllowed = true;
};

types.name.updateContext = function (prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6) {
	if (this.value == "of" && !this.exprAllowed || this.value == "yield" && this.inGeneratorContext()) {
			allowed = true;
	}
  }
  this.exprAllowed = allowed;
};
var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
	this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
	this.range = [p.start, p.end];
  }
};
var pp$8 = Parser.prototype;
var isRhino = (typeof Packages === "undefined" ? "undefined" : _typeof(Packages)) == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";
pp$8.next = function () {
  if (this.options.onToken) {
	this.options.onToken(new Token(this));
  }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$8.getToken = function () {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp$8[Symbol.iterator] = function () {
	var this$1 = this;

	return {
			next: function next() {
		var token = this$1.getToken();
		return {
					done: token.type === types.eof,
					value: token
		};
			}
	};
  };
}
pp$8.curContext = function () {
  return this.context[this.context.length - 1];
};
pp$8.nextToken = function () {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
	this.skipSpace();
  }

  this.start = this.pos;
  if (this.options.locations) {
	this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
	return this.finishToken(types.eof);
  }

  if (curContext.override) {
	return curContext.override(this);
  } else {
	this.readToken(this.fullCharCodeAtPos());
  }
};

pp$8.readToken = function (code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) {
			return this.readWord();
	}

  return this.getTokenFromCode(code);
};

pp$8.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) {
	return code;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00;
};

pp$8.skipBlockComment = function () {
  var this$1 = this;

  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos,
			end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
	this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
	lineBreakG.lastIndex = start;
	var match;
	while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
			++this$1.curLine;
			this$1.lineStart = match.index + match[0].length;
	}
  }
  if (this.options.onComment) {
	this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
  }
};

pp$8.skipLineComment = function (startSkip) {
  var this$1 = this;

  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
	ch = this$1.input.charCodeAt(++this$1.pos);
  }
  if (this.options.onComment) {
	this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
  }
};
pp$8.skipSpace = function () {
  var this$1 = this;

  loop: while (this.pos < this.input.length) {
	var ch = this$1.input.charCodeAt(this$1.pos);
	switch (ch) {
			case 32:case 160:
		++this$1.pos;
		break;
			case 13:
		if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
					++this$1.pos;
		}
			case 10:case 8232:case 8233:
		++this$1.pos;
		if (this$1.options.locations) {
					++this$1.curLine;
					this$1.lineStart = this$1.pos;
		}
		break;
			case 47:
		switch (this$1.input.charCodeAt(this$1.pos + 1)) {
					case 42:
			this$1.skipBlockComment();
			break;
					case 47:
			this$1.skipLineComment(2);
			break;
					default:
			break loop;
		}
		break;
			default:
		if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
					++this$1.pos;
		} else {
					break loop;
		}
	}
  }
};
pp$8.finishToken = function (type, val) {
  this.end = this.pos;
  if (this.options.locations) {
	this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};
//
//
pp$8.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
	return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
	this.pos += 3;
	return this.finishToken(types.ellipsis);
  } else {
	++this.pos;
	return this.finishToken(types.dot);
  }
};

pp$8.readToken_slash = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
	++this.pos;return this.readRegexp();
  }
  if (next === 61) {
	return this.finishOp(types.assign, 2);
  }
  return this.finishOp(types.slash, 1);
};

pp$8.readToken_mult_modulo_exp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;
  if (this.options.ecmaVersion >= 7 && code == 42 && next === 42) {
	++size;
	tokentype = types.starstar;
	next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) {
	return this.finishOp(types.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};

pp$8.readToken_pipe_amp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
	return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
  }
  if (next === 61) {
	return this.finishOp(types.assign, 2);
  }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
};

pp$8.readToken_caret = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
	return this.finishOp(types.assign, 2);
  }
  return this.finishOp(types.bitwiseXOR, 1);
};

pp$8.readToken_plus_min = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
	if (next == 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) == 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
			this.skipLineComment(3);
			this.skipSpace();
			return this.nextToken();
	}
	return this.finishOp(types.incDec, 2);
  }
  if (next === 61) {
	return this.finishOp(types.assign, 2);
  }
  return this.finishOp(types.plusMin, 1);
};

pp$8.readToken_lt_gt = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
	size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
	if (this.input.charCodeAt(this.pos + size) === 61) {
			return this.finishOp(types.assign, size + 1);
	}
	return this.finishOp(types.bitShift, size);
  }
  if (next == 33 && code == 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
	this.skipLineComment(4);
	this.skipSpace();
	return this.nextToken();
  }
  if (next === 61) {
	size = 2;
  }
  return this.finishOp(types.relational, size);
};

pp$8.readToken_eq_excl = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
	return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
	this.pos += 2;
	return this.finishToken(types.arrow);
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
};

pp$8.getTokenFromCode = function (code) {
  switch (code) {
	case 46:
			return this.readToken_dot();
	case 40:
			++this.pos;return this.finishToken(types.parenL);
	case 41:
			++this.pos;return this.finishToken(types.parenR);
	case 59:
			++this.pos;return this.finishToken(types.semi);
	case 44:
			++this.pos;return this.finishToken(types.comma);
	case 91:
			++this.pos;return this.finishToken(types.bracketL);
	case 93:
			++this.pos;return this.finishToken(types.bracketR);
	case 123:
			++this.pos;return this.finishToken(types.braceL);
	case 125:
			++this.pos;return this.finishToken(types.braceR);
	case 58:
			++this.pos;return this.finishToken(types.colon);
	case 63:
			++this.pos;return this.finishToken(types.question);

	case 96:
			if (this.options.ecmaVersion < 6) {
		break;
			}
			++this.pos;
			return this.finishToken(types.backQuote);

	case 48:
			var next = this.input.charCodeAt(this.pos + 1);
			if (next === 120 || next === 88) {
		return this.readRadixNumber(16);
			} // '0x', '0X' - hex number
			if (this.options.ecmaVersion >= 6) {
		if (next === 111 || next === 79) {
					return this.readRadixNumber(8);
		} // '0o', '0O' - octal number
		if (next === 98 || next === 66) {
					return this.readRadixNumber(2);
		} // '0b', '0B' - binary number
			}
	case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
			return this.readNumber(false);
	case 34:case 39:
			return this.readString(code);
	case 47:
			return this.readToken_slash();

	case 37:case 42:
			return this.readToken_mult_modulo_exp(code);

	case 124:case 38:
			return this.readToken_pipe_amp(code);

	case 94:
			return this.readToken_caret();

	case 43:case 45:
			return this.readToken_plus_min(code);

	case 60:case 62:
			return this.readToken_lt_gt(code);

	case 61:case 33:
			return this.readToken_eq_excl(code);

	case 126:
			return this.finishOp(types.prefix, 1);
	case 64:
			++this.pos;return this.finishToken(types.at);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp$8.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
function tryCreateRegexp(src, flags, throwErrorAt, parser) {
  try {
	return new RegExp(src, flags);
  } catch (e) {
	if (throwErrorAt !== undefined) {
			if (e instanceof SyntaxError) {
		parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
			}
			throw e;
	}
  }
}

var regexpUnicodeSupport = !!tryCreateRegexp("\uFFFF", "u");

pp$8.readRegexp = function () {
  var this$1 = this;

  var escaped,
			inClass,
			start = this.pos;
  for (;;) {
	if (this$1.pos >= this$1.input.length) {
			this$1.raise(start, "Unterminated regular expression");
	}
	var ch = this$1.input.charAt(this$1.pos);
	if (lineBreak.test(ch)) {
			this$1.raise(start, "Unterminated regular expression");
	}
	if (!escaped) {
			if (ch === "[") {
		inClass = true;
			} else if (ch === "]" && inClass) {
		inClass = false;
			} else if (ch === "/" && !inClass) {
		break;
			}
			escaped = ch === "\\";
	} else {
			escaped = false;
	}
	++this$1.pos;
  }
  var content = this.input.slice(start, this.pos);
  ++this.pos;
  var mods = this.readWord1();
  var tmp = content,
			tmpFlags = "";
  if (mods) {
	var validFlags = /^[gim]*$/;
	if (this.options.ecmaVersion >= 6) {
			validFlags = /^[gimuy]*$/;
	}
	if (!validFlags.test(mods)) {
			this.raise(start, "Invalid regular expression flag");
	}
	if (mods.indexOf("u") >= 0) {
			if (regexpUnicodeSupport) {
		tmpFlags = "u";
			} else {
		tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
					code = Number("0x" + code);
					if (code > 0x10FFFF) {
			this$1.raise(start + offset + 3, "Code point out of bounds");
					}
					return "x";
		});
		tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
		tmpFlags = tmpFlags.replace("u", "");
			}
	}
  }
  var value = null;
  if (!isRhino) {
	tryCreateRegexp(tmp, tmpFlags, start, this);
	value = tryCreateRegexp(content, mods);
  }
  return this.finishToken(types.regexp, { pattern: content, flags: mods, value: value });
};
pp$8.readInt = function (radix, len) {
  var this$1 = this;

  var start = this.pos,
			total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	var code = this$1.input.charCodeAt(this$1.pos),
		val = void 0;
	if (code >= 97) {
			val = code - 97 + 10;
	} // a
	else if (code >= 65) {
		val = code - 65 + 10;
			} // A
			else if (code >= 48 && code <= 57) {
					val = code - 48;
		} // 0-9
		else {
			val = Infinity;
					}
	if (val >= radix) {
			break;
	}
	++this$1.pos;
	total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
	return null;
  }

  return total;
};

pp$8.readRadixNumber = function (radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) {
	this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
	this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types.num, val);
};
pp$8.readNumber = function (startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10) === null) {
	this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
	this.raise(start, "Invalid number");
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
	octal = false;
  }
  var next = this.input.charCodeAt(this.pos);
  if (next === 46 && !octal) {
	++this.pos;
	this.readInt(10);
	next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
	next = this.input.charCodeAt(++this.pos);
	if (next === 43 || next === 45) {
			++this.pos;
	} // '+-'
	if (this.readInt(10) === null) {
			this.raise(start, "Invalid number");
	}
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
	this.raise(this.pos, "Identifier directly after number");
  }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val);
};
pp$8.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
			code;

  if (ch === 123) {
	if (this.options.ecmaVersion < 6) {
			this.unexpected();
	}
	var codePos = ++this.pos;
	code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
	++this.pos;
	if (code > 0x10FFFF) {
			this.invalidStringToken(codePos, "Code point out of bounds");
	}
  } else {
	code = this.readHexChar(4);
  }
  return code;
};

function codePointToString(code) {
  if (code <= 0xFFFF) {
	return String.fromCharCode(code);
  }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}

pp$8.readString = function (quote) {
  var this$1 = this;

  var out = "",
			chunkStart = ++this.pos;
  for (;;) {
	if (this$1.pos >= this$1.input.length) {
			this$1.raise(this$1.start, "Unterminated string constant");
	}
	var ch = this$1.input.charCodeAt(this$1.pos);
	if (ch === quote) {
			break;
	}
	if (ch === 92) {
			out += this$1.input.slice(chunkStart, this$1.pos);
			out += this$1.readEscapedChar(false);
			chunkStart = this$1.pos;
	} else {
			if (isNewLine(ch)) {
		this$1.raise(this$1.start, "Unterminated string constant");
			}
			++this$1.pos;
	}
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$8.tryReadTemplateToken = function () {
  this.inTemplateElement = true;
  try {
	this.readTmplToken();
  } catch (err) {
	if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
			this.readInvalidTemplateToken();
	} else {
			throw err;
	}
  }

  this.inTemplateElement = false;
};

pp$8.invalidStringToken = function (position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
	throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
	this.raise(position, message);
  }
};

pp$8.readTmplToken = function () {
  var this$1 = this;

  var out = "",
			chunkStart = this.pos;
  for (;;) {
	if (this$1.pos >= this$1.input.length) {
			this$1.raise(this$1.start, "Unterminated template");
	}
	var ch = this$1.input.charCodeAt(this$1.pos);
	if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) {
			if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {
		if (ch === 36) {
					this$1.pos += 2;
					return this$1.finishToken(types.dollarBraceL);
		} else {
					++this$1.pos;
					return this$1.finishToken(types.backQuote);
		}
			}
			out += this$1.input.slice(chunkStart, this$1.pos);
			return this$1.finishToken(types.template, out);
	}
	if (ch === 92) {
			out += this$1.input.slice(chunkStart, this$1.pos);
			out += this$1.readEscapedChar(true);
			chunkStart = this$1.pos;
	} else if (isNewLine(ch)) {
			out += this$1.input.slice(chunkStart, this$1.pos);
			++this$1.pos;
			switch (ch) {
		case 13:
					if (this$1.input.charCodeAt(this$1.pos) === 10) {
			++this$1.pos;
					}
		case 10:
					out += "\n";
					break;
		default:
					out += String.fromCharCode(ch);
					break;
			}
			if (this$1.options.locations) {
		++this$1.curLine;
		this$1.lineStart = this$1.pos;
			}
			chunkStart = this$1.pos;
	} else {
			++this$1.pos;
	}
  }
};
pp$8.readInvalidTemplateToken = function () {
  var this$1 = this;

  for (; this.pos < this.input.length; this.pos++) {
	switch (this$1.input[this$1.pos]) {
			case "\\":
		++this$1.pos;
		break;

			case "$":
		if (this$1.input[this$1.pos + 1] !== "{") {
					break;
		}
			case "`":
		return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos));
	}
  }
  this.raise(this.start, "Unterminated template");
};
pp$8.readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
	case 110:
			return "\n"; // 'n' -> '\n'
	case 114:
			return "\r"; // 'r' -> '\r'
	case 120:
			return String.fromCharCode(this.readHexChar(2)); // 'x'
	case 117:
			return codePointToString(this.readCodePoint()); // 'u'
	case 116:
			return "\t"; // 't' -> '\t'
	case 98:
			return "\b"; // 'b' -> '\b'
	case 118:
			return "\x0B"; // 'v' -> '\u000b'
	case 102:
			return "\f"; // 'f' -> '\f'
	case 13:
			if (this.input.charCodeAt(this.pos) === 10) {
		++this.pos;
			} // '\r\n'
	case 10:
			if (this.options.locations) {
		this.lineStart = this.pos;++this.curLine;
			}
			return "";
	default:
			if (ch >= 48 && ch <= 55) {
		var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
		var octal = parseInt(octalStr, 8);
		if (octal > 255) {
					octalStr = octalStr.slice(0, -1);
					octal = parseInt(octalStr, 8);
		}
		if (octalStr !== "0" && (this.strict || inTemplate)) {
					this.invalidStringToken(this.pos - 2, "Octal literal in strict mode");
		}
		this.pos += octalStr.length - 1;
		return String.fromCharCode(octal);
			}
			return String.fromCharCode(ch);
  }
};
pp$8.readHexChar = function (len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) {
	this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n;
};
//
pp$8.readWord1 = function () {
  var this$1 = this;

  this.containsEsc = false;
  var word = "",
			first = true,
			chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
	var ch = this$1.fullCharCodeAtPos();
	if (isIdentifierChar(ch, astral)) {
			this$1.pos += ch <= 0xffff ? 1 : 2;
	} else if (ch === 92) {
			this$1.containsEsc = true;
			word += this$1.input.slice(chunkStart, this$1.pos);
			var escStart = this$1.pos;
			if (this$1.input.charCodeAt(++this$1.pos) != 117) // "u"
		{
					this$1.invalidStringToken(this$1.pos, "Expecting Unicode escape sequence \\uXXXX");
		}
			++this$1.pos;
			var esc = this$1.readCodePoint();
			if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
		this$1.invalidStringToken(escStart, "Invalid Unicode escape");
			}
			word += codePointToString(esc);
			chunkStart = this$1.pos;
	} else {
			break;
	}
	first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp$8.readWord = function () {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
	if (this.containsEsc) {
			this.raiseRecoverable(this.start, "Escape sequence in keyword " + word);
	}
	type = keywords$1[word];
  }
  return this.finishToken(type, word);
};
//
//
//
//
//
//
//
var version = "5.2.1";
//
function parse(input, options) {
  return new Parser(options, input).parse();
}
function parseExpressionAt(input, pos, options) {
  var p = new Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression();
}
function tokenizer(input, options) {
  return new Parser(options, input);
}
var parse_dammit;
var LooseParser;
var pluginsLoose; // eslint-disable-line camelcase
function addLooseExports(parse, Parser$$1, plugins$$1) {
  exports.parse_dammit = parse_dammit = parse; // eslint-disable-line camelcase
  exports.LooseParser = LooseParser = Parser$$1;
  exports.pluginsLoose = pluginsLoose = plugins$$1;
}

exports.version = version;
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;
exports.parse_dammit = parse_dammit;
exports.LooseParser = LooseParser;
exports.pluginsLoose = pluginsLoose;
exports.addLooseExports = addLooseExports;
exports.Parser = Parser;
exports.plugins = plugins;
exports.defaultOptions = defaultOptions;
exports.Position = Position;
exports.SourceLocation = SourceLocation;
exports.getLineInfo = getLineInfo;
exports.Node = Node;
exports.TokenType = TokenType;
exports.tokTypes = types;
exports.keywordTypes = keywords$1;
exports.TokContext = TokContext;
exports.tokContexts = types$1;
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierStart = isIdentifierStart;
exports.Token = Token;
exports.isNewLine = isNewLine;
exports.lineBreak = lineBreak;
exports.lineBreakG = lineBreakG;
exports.nonASCIIwhitespace = nonASCIIwhitespace;
 }),
 (function(module, exports) {

module.exports = {"_from":"espree@^3.5.2","_id":"espree@3.5.2","_inBundle":false,"_integrity":"sha512-sadKeYwaR/aJ3stC2CdvgXu1T16TdYN+qwCpcWbMnGJ8s0zNWemzrvb2GbD4OhmJ/fwpJjudThAlLobGbWZbCQ==","_location":"/espree","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"espree@^3.5.2","name":"espree","escapedName":"espree","rawSpec":"^3.5.2","saveSpec":null,"fetchSpec":"^3.5.2"},"_requiredBy":["/eslint"],"_resolved":"https://registry.npmjs.org/espree/-/espree-3.5.2.tgz","_shasum":"756ada8b979e9dcfcdb30aad8d1a9304a905e1ca","_spec":"espree@^3.5.2","_where":"J:\\Chromium\\newclient\\plugins\\c9.ide.language.javascript.eslint\\packager\\node_modules\\eslint","author":{"name":"Nicholas C. Zakas","email":"nicholas+npm@nczconsulting.com"},"bugs":{"url":"http://github.com/eslint/espree.git"},"bundleDependencies":false,"dependencies":{"acorn":"^5.2.1","acorn-jsx":"^3.0.0"},"deprecated":false,"description":"An Esprima-compatible JavaScript parser built on Acorn","devDependencies":{"browserify":"^7.0.0","chai":"^1.10.0","eslint":"^2.13.1","eslint-config-eslint":"^3.0.0","eslint-release":"^0.10.0","esprima":"latest","esprima-fb":"^8001.2001.0-dev-harmony-fb","istanbul":"~0.2.6","json-diff":"~0.3.1","leche":"^1.0.1","mocha":"^2.0.1","regenerate":"~0.5.4","shelljs":"^0.3.0","shelljs-nodecli":"^0.1.1","unicode-6.3.0":"~0.1.0"},"engines":{"node":">=0.10.0"},"files":["lib","espree.js"],"homepage":"https://github.com/eslint/espree","keywords":["ast","ecmascript","javascript","parser","syntax","acorn"],"license":"BSD-2-Clause","main":"espree.js","name":"espree","repository":{"type":"git","url":"git+https://github.com/eslint/espree.git"},"scripts":{"alpharelease":"eslint-prelease alpha","betarelease":"eslint-prelease beta","browserify":"node Makefile.js browserify","ci-release":"eslint-ci-release","generate-regex":"node tools/generate-identifier-regex.js","gh-release":"eslint-gh-release","lint":"node Makefile.js lint","release":"eslint-release","test":"npm run-script lint && node Makefile.js test"},"version":"3.5.2"}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	AssignmentExpression: ["left", "right"],
	AssignmentPattern: ["left", "right"],
	ArrayExpression: ["elements"],
	ArrayPattern: ["elements"],
	ArrowFunctionExpression: ["params", "body"],
	BlockStatement: ["body"],
	BinaryExpression: ["left", "right"],
	BreakStatement: ["label"],
	CallExpression: ["callee", "arguments"],
	CatchClause: ["param", "body"],
	ClassBody: ["body"],
	ClassDeclaration: ["id", "superClass", "body"],
	ClassExpression: ["id", "superClass", "body"],
	ConditionalExpression: ["test", "consequent", "alternate"],
	ContinueStatement: ["label"],
	DebuggerStatement: [],
	DirectiveStatement: [],
	DoWhileStatement: ["body", "test"],
	EmptyStatement: [],
	ExportAllDeclaration: ["source"],
	ExportDefaultDeclaration: ["declaration"],
	ExportNamedDeclaration: ["declaration", "specifiers", "source"],
	ExportSpecifier: ["exported", "local"],
	ExpressionStatement: ["expression"],
	ForStatement: ["init", "test", "update", "body"],
	ForInStatement: ["left", "right", "body"],
	ForOfStatement: ["left", "right", "body"],
	FunctionDeclaration: ["id", "params", "body"],
	FunctionExpression: ["id", "params", "body"],
	Identifier: [],
	IfStatement: ["test", "consequent", "alternate"],
	ImportDeclaration: ["specifiers", "source"],
	ImportDefaultSpecifier: ["local"],
	ImportNamespaceSpecifier: ["local"],
	ImportSpecifier: ["imported", "local"],
	Literal: [],
	LabeledStatement: ["label", "body"],
	LogicalExpression: ["left", "right"],
	MemberExpression: ["object", "property"],
	MetaProperty: ["meta", "property"],
	MethodDefinition: ["key", "value"],
	ModuleSpecifier: [],
	NewExpression: ["callee", "arguments"],
	ObjectExpression: ["properties"],
	ObjectPattern: ["properties"],
	Program: ["body"],
	Property: ["key", "value"],
	RestElement: ["argument"],
	ReturnStatement: ["argument"],
	SequenceExpression: ["expressions"],
	SpreadElement: ["argument"],
	Super: [],
	SwitchStatement: ["discriminant", "cases"],
	SwitchCase: ["test", "consequent"],
	TaggedTemplateExpression: ["tag", "quasi"],
	TemplateElement: [],
	TemplateLiteral: ["quasis", "expressions"],
	ThisExpression: [],
	ThrowStatement: ["argument"],
	TryStatement: ["block", "handler", "finalizer"],
	UnaryExpression: ["argument"],
	UpdateExpression: ["argument"],
	VariableDeclaration: ["declarations"],
	VariableDeclarator: ["id", "init"],
	WhileStatement: ["test", "body"],
	WithStatement: ["object", "body"],
	YieldExpression: ["argument"],
	JSXIdentifier: [],
	JSXNamespacedName: ["namespace", "name"],
	JSXMemberExpression: ["object", "property"],
	JSXEmptyExpression: [],
	JSXExpressionContainer: ["expression"],
	JSXElement: ["openingElement", "closingElement", "children"],
	JSXClosingElement: ["name"],
	JSXOpeningElement: ["name", "attributes"],
	JSXAttribute: ["name", "value"],
	JSXText: null,
	JSXSpreadAttribute: ["argument"],
	ExperimentalRestProperty: ["argument"],
	ExperimentalSpreadProperty: ["argument"]
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var minimatch = __webpack_require__(366),
	path = __webpack_require__(103);

var debug = __webpack_require__(67)("eslint:config-ops");
var RULE_SEVERITY_STRINGS = ["off", "warn", "error"],
	RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce(function (map, value, index) {
	map[value] = index;
	return map;
}, {}),
	VALID_SEVERITIES = [0, 1, 2, "off", "warn", "error"];
module.exports = {
	createEmptyConfig: function createEmptyConfig() {
		return {
			globals: {},
			env: {},
			rules: {},
			parserOptions: {}
		};
	},
	createEnvironmentConfig: function createEnvironmentConfig(env, envContext) {

		var envConfig = this.createEmptyConfig();

		if (env) {

			envConfig.env = env;

			Object.keys(env).filter(function (name) {
				return env[name];
			}).forEach(function (name) {
				var environment = envContext.get(name);

				if (environment) {
					debug("Creating config for environment " + name);
					if (environment.globals) {
						Object.assign(envConfig.globals, environment.globals);
					}

					if (environment.parserOptions) {
						Object.assign(envConfig.parserOptions, environment.parserOptions);
					}
				}
			});
		}

		return envConfig;
	},
	applyEnvironments: function applyEnvironments(config, envContent) {
		if (config.env && _typeof(config.env) === "object") {
			debug("Apply environment settings to config");
			return this.merge(this.createEnvironmentConfig(config.env, envContent), config);
		}

		return config;
	},
	merge: function deepmerge(target, src, combine, isRule) {
		var array = Array.isArray(src) || Array.isArray(target);
		var dst = array && [] || {};

		combine = !!combine;
		isRule = !!isRule;
		if (array) {
			target = target || [];
			if (isRule && Array.isArray(src) && src.length > 1) {
				dst = dst.concat(src);
			} else {
				dst = dst.concat(target);
			}
			if ((typeof src === "undefined" ? "undefined" : _typeof(src)) !== "object" && !Array.isArray(src)) {
				src = [src];
			}
			Object.keys(src).forEach(function (e, i) {
				e = src[i];
				if (typeof dst[i] === "undefined") {
					dst[i] = e;
				} else if ((typeof e === "undefined" ? "undefined" : _typeof(e)) === "object") {
					if (isRule) {
						dst[i] = e;
					} else {
						dst[i] = deepmerge(target[i], e, combine, isRule);
					}
				} else {
					if (!combine) {
						dst[i] = e;
					} else {
						if (dst.indexOf(e) === -1) {
							dst.push(e);
						}
					}
				}
			});
		} else {
			if (target && (typeof target === "undefined" ? "undefined" : _typeof(target)) === "object") {
				Object.keys(target).forEach(function (key) {
					dst[key] = target[key];
				});
			}
			Object.keys(src).forEach(function (key) {
				if (key === "overrides") {
					dst[key] = (target[key] || []).concat(src[key] || []);
				} else if (Array.isArray(src[key]) || Array.isArray(target[key])) {
					dst[key] = deepmerge(target[key], src[key], key === "plugins" || key === "extends", isRule);
				} else if (_typeof(src[key]) !== "object" || !src[key] || key === "exported" || key === "astGlobals") {
					dst[key] = src[key];
				} else {
					dst[key] = deepmerge(target[key] || {}, src[key], combine, key === "rules");
				}
			});
		}

		return dst;
	},
	getRuleSeverity: function getRuleSeverity(ruleConfig) {
		var severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;

		if (typeof severityValue === 'number') {
			return severityValue;
		}

		if (typeof severityValue === "string") {
			return RULE_SEVERITY[severityValue.toLowerCase()] || 0;
		}

		return 0;
	},
	normalizeToStrings: function normalizeToStrings(config) {

		if (config.rules) {
			Object.keys(config.rules).forEach(function (ruleId) {
				var ruleConfig = config.rules[ruleId];

				if (typeof ruleConfig === "number") {
					config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];
				} else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "number") {
					ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];
				}
			});
		}
	},
	isErrorSeverity: function isErrorSeverity(ruleConfig) {

		var severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;

		if (typeof severity === "string") {
			severity = RULE_SEVERITY[severity.toLowerCase()] || 0;
		}

		return typeof severity === "number" && severity === 2;
	},
	isValidSeverity: function isValidSeverity(ruleConfig) {
		var severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;

		if (typeof severity === "string") {
			severity = severity.toLowerCase();
		}
		return VALID_SEVERITIES.indexOf(severity) !== -1;
	},
	isEverySeverityValid: function isEverySeverityValid(config) {
		var _this = this;

		return Object.keys(config).every(function (ruleId) {
			return _this.isValidSeverity(config[ruleId]);
		});
	},
	getConfigFromVector: function getConfigFromVector(vector, configCache) {

		var cachedConfig = configCache.getMergedVectorConfig(vector);

		if (cachedConfig) {
			return cachedConfig;
		}

		debug("Using config from partial cache");

		var subvector = Array.from(vector);
		var nearestCacheIndex = subvector.length - 1,
			partialCachedConfig = void 0;

		while (nearestCacheIndex >= 0) {
			partialCachedConfig = configCache.getMergedVectorConfig(subvector);
			if (partialCachedConfig) {
				break;
			}
			subvector.pop();
			nearestCacheIndex--;
		}

		if (!partialCachedConfig) {
			partialCachedConfig = {};
		}

		var finalConfig = partialCachedConfig;
		for (var i = nearestCacheIndex + 1; i < vector.length; i++) {
			finalConfig = this.mergeVectorEntry(finalConfig, vector[i], configCache);
			configCache.setMergedVectorConfig(vector.slice(0, i + 1), finalConfig);
		}

		return finalConfig;
	},
	mergeVectorEntry: function mergeVectorEntry(config, vectorEntry, configCache) {
		var _this2 = this;

		var vectorEntryConfig = Object.assign({}, configCache.getConfig(vectorEntry.filePath));
		var mergedConfig = Object.assign({}, config),
			overrides = void 0;

		if (vectorEntryConfig.overrides) {
			overrides = vectorEntryConfig.overrides.filter(function (override, overrideIndex) {
				return vectorEntry.matchingOverrides.indexOf(overrideIndex) !== -1;
			});
		} else {
			overrides = [];
		}

		mergedConfig = this.merge(mergedConfig, vectorEntryConfig);

		delete mergedConfig.overrides;

		mergedConfig = overrides.reduce(function (lastConfig, override) {
			return _this2.merge(lastConfig, override);
		}, mergedConfig);

		if (mergedConfig.filePath) {
			delete mergedConfig.filePath;
			delete mergedConfig.baseDirectory;
		} else if (mergedConfig.files) {
			delete mergedConfig.files;
		}

		return mergedConfig;
	},
	pathMatchesGlobs: function pathMatchesGlobs(filePath, patterns, excludedPatterns) {
		var patternList = [].concat(patterns);
		var excludedPatternList = [].concat(excludedPatterns || []);

		patternList.concat(excludedPatternList).forEach(function (pattern) {
			if (path.isAbsolute(pattern) || pattern.includes("..")) {
				throw new Error("Invalid override pattern (expected relative path not containing '..'): " + pattern);
			}
		});

		var opts = { matchBase: true };

		return patternList.some(function (pattern) {
			return minimatch(filePath, pattern, opts);
		}) && !excludedPatternList.some(function (excludedPattern) {
			return minimatch(filePath, excludedPattern, opts);
		});
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = minimatch;
minimatch.Minimatch = Minimatch;

var path = { sep: '/' };
try {
  path = __webpack_require__(103);
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
var expand = __webpack_require__(367);

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)' },
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
};var qmark = '[^/]';
var star = qmark + '*?';
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';
var reSpecials = charSet('().*{}+?[]^$\\!');
function charSet(s) {
  return s.split('').reduce(function (set, c) {
	set[c] = true;
	return set;
  }, {});
}
var slashSplit = /\/+/;

minimatch.filter = filter;
function filter(pattern, options) {
  options = options || {};
  return function (p, i, list) {
	return minimatch(p, pattern, options);
  };
}

function ext(a, b) {
  a = a || {};
  b = b || {};
  var t = {};
  Object.keys(b).forEach(function (k) {
	t[k] = b[k];
  });
  Object.keys(a).forEach(function (k) {
	t[k] = a[k];
  });
  return t;
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch;

  var orig = minimatch;

  var m = function minimatch(p, pattern, options) {
	return orig.minimatch(p, pattern, ext(def, options));
  };

  m.Minimatch = function Minimatch(pattern, options) {
	return new orig.Minimatch(pattern, ext(def, options));
  };

  return m;
};

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch;
  return minimatch.defaults(def).Minimatch;
};

function minimatch(p, pattern, options) {
  if (typeof pattern !== 'string') {
	throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};
  if (!options.nocomment && pattern.charAt(0) === '#') {
	return false;
  }
  if (pattern.trim() === '') return p === '';

  return new Minimatch(pattern, options).match(p);
}

function Minimatch(pattern, options) {
  if (!(this instanceof Minimatch)) {
	return new Minimatch(pattern, options);
  }

  if (typeof pattern !== 'string') {
	throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};
  pattern = pattern.trim();
  if (path.sep !== '/') {
	pattern = pattern.split(path.sep).join('/');
  }

  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;
  this.make();
}

Minimatch.prototype.debug = function () {};

Minimatch.prototype.make = make;
function make() {
  if (this._made) return;

  var pattern = this.pattern;
  var options = this.options;
  if (!options.nocomment && pattern.charAt(0) === '#') {
	this.comment = true;
	return;
  }
  if (!pattern) {
	this.empty = true;
	return;
  }
  this.parseNegate();
  var set = this.globSet = this.braceExpand();

  if (options.debug) this.debug = console.error;

  this.debug(this.pattern, set);
  set = this.globParts = set.map(function (s) {
	return s.split(slashSplit);
  });

  this.debug(this.pattern, set);
  set = set.map(function (s, si, set) {
	return s.map(this.parse, this);
  }, this);

  this.debug(this.pattern, set);
  set = set.filter(function (s) {
	return s.indexOf(false) === -1;
  });

  this.debug(this.pattern, set);

  this.set = set;
}

Minimatch.prototype.parseNegate = parseNegate;
function parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;

  if (options.nonegate) return;

  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
	negate = !negate;
	negateOffset++;
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}
//
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options);
};

Minimatch.prototype.braceExpand = braceExpand;

function braceExpand(pattern, options) {
  if (!options) {
	if (this instanceof Minimatch) {
			options = this.options;
	} else {
			options = {};
	}
  }

  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;

  if (typeof pattern === 'undefined') {
	throw new TypeError('undefined pattern');
  }

  if (options.nobrace || !pattern.match(/\{.*\}/)) {
	return [pattern];
  }

  return expand(pattern);
}
//
Minimatch.prototype.parse = parse;
var SUBPARSE = {};
function parse(pattern, isSub) {
  if (pattern.length > 1024 * 64) {
	throw new TypeError('pattern is too long');
  }

  var options = this.options;
  if (!options.noglobstar && pattern === '**') return GLOBSTAR;
  if (pattern === '') return '';

  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
  var self = this;

  function clearStateChar() {
	if (stateChar) {
			switch (stateChar) {
		case '*':
					re += star;
					hasMagic = true;
					break;
		case '?':
					re += qmark;
					hasMagic = true;
					break;
		default:
					re += '\\' + stateChar;
					break;
			}
			self.debug('clearStateChar %j %j', stateChar, re);
			stateChar = false;
	}
  }

  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
	this.debug('%s\t%s %s %j', pattern, i, re, c);
	if (escaping && reSpecials[c]) {
			re += '\\' + c;
			escaping = false;
			continue;
	}

	switch (c) {
			case '/':
		return false;

			case '\\':
		clearStateChar();
		escaping = true;
		continue;
			case '?':
			case '*':
			case '+':
			case '@':
			case '!':
		this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);
		if (inClass) {
					this.debug('  in class');
					if (c === '!' && i === classStart + 1) c = '^';
					re += c;
					continue;
		}
		self.debug('call clearStateChar %j', stateChar);
		clearStateChar();
		stateChar = c;
		if (options.noext) clearStateChar();
		continue;

			case '(':
		if (inClass) {
					re += '(';
					continue;
		}

		if (!stateChar) {
					re += '\\(';
					continue;
		}

		patternListStack.push({
					type: stateChar,
					start: i - 1,
					reStart: re.length,
					open: plTypes[stateChar].open,
					close: plTypes[stateChar].close
		});
		re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
		this.debug('plType %j %j', stateChar, re);
		stateChar = false;
		continue;

			case ')':
		if (inClass || !patternListStack.length) {
					re += '\\)';
					continue;
		}

		clearStateChar();
		hasMagic = true;
		var pl = patternListStack.pop();
		re += pl.close;
		if (pl.type === '!') {
					negativeLists.push(pl);
		}
		pl.reEnd = re.length;
		continue;

			case '|':
		if (inClass || !patternListStack.length || escaping) {
					re += '\\|';
					escaping = false;
					continue;
		}

		clearStateChar();
		re += '|';
		continue;
			case '[':
		clearStateChar();

		if (inClass) {
					re += '\\' + c;
					continue;
		}

		inClass = true;
		classStart = i;
		reClassStart = re.length;
		re += c;
		continue;

			case ']':
		if (i === classStart + 1 || !inClass) {
					re += '\\' + c;
					escaping = false;
					continue;
		}
		if (inClass) {
					var cs = pattern.substring(classStart + 1, i);
					try {
			RegExp('[' + cs + ']');
					} catch (er) {
			var sp = this.parse(cs, SUBPARSE);
			re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
			hasMagic = hasMagic || sp[1];
			inClass = false;
			continue;
					}
		}
		hasMagic = true;
		inClass = false;
		re += c;
		continue;

			default:
		clearStateChar();

		if (escaping) {
					escaping = false;
		} else if (reSpecials[c] && !(c === '^' && inClass)) {
					re += '\\';
		}

		re += c;

	} // switch
  } // for
  if (inClass) {
	cs = pattern.substr(classStart + 1);
	sp = this.parse(cs, SUBPARSE);
	re = re.substr(0, reClassStart) + '\\[' + sp[0];
	hasMagic = hasMagic || sp[1];
  }
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
	var tail = re.slice(pl.reStart + pl.open.length);
	this.debug('setting tail', re, pl);
	tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
			if (!$2) {
		$2 = '\\';
			}
			//
			return $1 + $1 + $2 + '|';
	});

	this.debug('tail=%j\n   %s', tail, tail, pl, re);
	var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;

	hasMagic = true;
	re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }
  clearStateChar();
  if (escaping) {
	re += '\\\\';
  }
  var addPatternStart = false;
  switch (re.charAt(0)) {
	case '.':
	case '[':
	case '(':
			addPatternStart = true;
  }
  for (var n = negativeLists.length - 1; n > -1; n--) {
	var nl = negativeLists[n];

	var nlBefore = re.slice(0, nl.reStart);
	var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
	var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
	var nlAfter = re.slice(nl.reEnd);

	nlLast += nlAfter;
	var openParensBefore = nlBefore.split('(').length - 1;
	var cleanAfter = nlAfter;
	for (i = 0; i < openParensBefore; i++) {
			cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
	}
	nlAfter = cleanAfter;

	var dollar = '';
	if (nlAfter === '' && isSub !== SUBPARSE) {
			dollar = '$';
	}
	var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
	re = newRe;
  }
  if (re !== '' && hasMagic) {
	re = '(?=.)' + re;
  }

  if (addPatternStart) {
	re = patternStart + re;
  }
  if (isSub === SUBPARSE) {
	return [re, hasMagic];
  }
  if (!hasMagic) {
	return globUnescape(pattern);
  }

  var flags = options.nocase ? 'i' : '';
  try {
	var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) {
	return new RegExp('$.');
  }

  regExp._glob = pattern;
  regExp._src = re;

  return regExp;
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe();
};

Minimatch.prototype.makeRe = makeRe;
function makeRe() {
  if (this.regexp || this.regexp === false) return this.regexp;
  //
  var set = this.set;

  if (!set.length) {
	this.regexp = false;
	return this.regexp;
  }
  var options = this.options;

  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
  var flags = options.nocase ? 'i' : '';

  var re = set.map(function (pattern) {
	return pattern.map(function (p) {
			return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;
	}).join('\\\/');
  }).join('|');
  re = '^(?:' + re + ')$';
  if (this.negate) re = '^(?!' + re + ').*$';

  try {
	this.regexp = new RegExp(re, flags);
  } catch (ex) {
	this.regexp = false;
  }
  return this.regexp;
}

minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new Minimatch(pattern, options);
  list = list.filter(function (f) {
	return mm.match(f);
  });
  if (mm.options.nonull && !list.length) {
	list.push(pattern);
  }
  return list;
};

Minimatch.prototype.match = match;
function match(f, partial) {
  this.debug('match', f, this.pattern);
  if (this.comment) return false;
  if (this.empty) return f === '';

  if (f === '/' && partial) return true;

  var options = this.options;
  if (path.sep !== '/') {
	f = f.split(path.sep).join('/');
  }
  f = f.split(slashSplit);
  this.debug(this.pattern, 'split', f);
  var set = this.set;
  this.debug(this.pattern, 'set', set);
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
	filename = f[i];
	if (filename) break;
  }

  for (i = 0; i < set.length; i++) {
	var pattern = set[i];
	var file = f;
	if (options.matchBase && pattern.length === 1) {
			file = [filename];
	}
	var hit = this.matchOne(file, pattern, partial);
	if (hit) {
			if (options.flipNegate) return true;
			return !this.negate;
	}
  }
  if (options.flipNegate) return false;
  return this.negate;
}
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;

  this.debug('matchOne', { 'this': this, file: file, pattern: pattern });

  this.debug('matchOne', file.length, pattern.length);

  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
	this.debug('matchOne loop');
	var p = pattern[pi];
	var f = file[fi];

	this.debug(pattern, p, f);
	if (p === false) return false;

	if (p === GLOBSTAR) {
			this.debug('GLOBSTAR', [pattern, p, f]);
			//
			var fr = fi;
			var pr = pi + 1;
			if (pr === pl) {
		this.debug('** at the end');
		for (; fi < fl; fi++) {
					if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
		}
		return true;
			}
			while (fr < fl) {
		var swallowee = file[fr];

		this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
		if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
					this.debug('globstar found match!', fr, fl, swallowee);
					return true;
		} else {
					if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
			this.debug('dot detected!', file, fr, pattern, pr);
			break;
					}
					this.debug('globstar swallow a segment, and continue');
					fr++;
		}
			}
			if (partial) {
		this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
		if (fr === fl) return true;
			}
			return false;
	}
	var hit;
	if (typeof p === 'string') {
			if (options.nocase) {
		hit = f.toLowerCase() === p.toLowerCase();
			} else {
		hit = f === p;
			}
			this.debug('string match', p, f, hit);
	} else {
			hit = f.match(p);
			this.debug('pattern match', p, f, hit);
	}

	if (!hit) return false;
  }
  if (fi === fl && pi === pl) {
	return true;
  } else if (fi === fl) {
	return partial;
  } else if (pi === pl) {
	var emptyFileEnd = fi === fl - 1 && file[fi] === '';
	return emptyFileEnd;
  }
  throw new Error('wtf?');
};
function globUnescape(s) {
  return s.replace(/\\(.)/g, '$1');
}

function regExpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var concatMap = __webpack_require__(368);
var balanced = __webpack_require__(369);

module.exports = expandTop;

var escSlash = '\0SLASH' + Math.random() + '\0';
var escOpen = '\0OPEN' + Math.random() + '\0';
var escClose = '\0CLOSE' + Math.random() + '\0';
var escComma = '\0COMMA' + Math.random() + '\0';
var escPeriod = '\0PERIOD' + Math.random() + '\0';

function numeric(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash).split('\\{').join(escOpen).split('\\}').join(escClose).split('\\,').join(escComma).split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
}
function parseCommaParts(str) {
  if (!str) return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m) return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length - 1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
	p[p.length - 1] += postParts.shift();
	p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str) return [];
  if (str.substr(0, 2) === '{}') {
	str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return (/^-?0\d/.test(el)
  );
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
	if (m.post.match(/,.*\}/)) {
			str = m.pre + '{' + m.body + escClose + m.post;
			return expand(str);
	}
	return [str];
  }

  var n;
  if (isSequence) {
	n = m.body.split(/\.\./);
  } else {
	n = parseCommaParts(m.body);
	if (n.length === 1) {
			n = expand(n[0], false).map(embrace);
			if (n.length === 1) {
		var post = m.post.length ? expand(m.post, false) : [''];
		return post.map(function (p) {
					return m.pre + n[0] + p;
		});
			}
	}
  }
  var pre = m.pre;
  var post = m.post.length ? expand(m.post, false) : [''];

  var N;

  if (isSequence) {
	var x = numeric(n[0]);
	var y = numeric(n[1]);
	var width = Math.max(n[0].length, n[1].length);
	var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
	var test = lte;
	var reverse = y < x;
	if (reverse) {
			incr *= -1;
			test = gte;
	}
	var pad = n.some(isPadded);

	N = [];

	for (var i = x; test(i, y); i += incr) {
			var c;
			if (isAlphaSequence) {
		c = String.fromCharCode(i);
		if (c === '\\') c = '';
			} else {
		c = String(i);
		if (pad) {
					var need = width - c.length;
					if (need > 0) {
			var z = new Array(need + 1).join('0');
			if (i < 0) c = '-' + z + c.slice(1);else c = z + c;
					}
		}
			}
			N.push(c);
	}
  } else {
	N = concatMap(n, function (el) {
			return expand(el, false);
	});
  }

  for (var j = 0; j < N.length; j++) {
	for (var k = 0; k < post.length; k++) {
			var expansion = pre + N[j] + post[k];
			if (!isTop || isSequence || expansion) expansions.push(expansion);
	}
  }

  return expansions;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (xs, fn) {
	var res = [];
	for (var i = 0; i < xs.length; i++) {
		var x = fn(xs[i], i);
		if (isArray(x)) res.push.apply(res, x);else res.push(x);
	}
	return res;
};

var isArray = Array.isArray || function (xs) {
	return Object.prototype.toString.call(xs) === '[object Array]';
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
	start: r[0],
	end: r[1],
	pre: str.slice(0, r[0]),
	body: str.slice(r[0] + a.length, r[1]),
	post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
	begs = [];
	left = str.length;

	while (i >= 0 && !result) {
			if (i == ai) {
		begs.push(i);
		ai = str.indexOf(a, i + 1);
			} else if (begs.length == 1) {
		result = [begs.pop(), bi];
			} else {
		beg = begs.pop();
		if (beg < left) {
					left = beg;
					right = bi;
		}

		bi = str.indexOf(b, i + 1);
			}

			i = ai < bi && ai >= 0 ? ai : bi;
	}

	if (begs.length) {
			result = [left, right];
	}
  }

  return result;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var envs = __webpack_require__(371);
var Environments = function () {
	function Environments() {
		_classCallCheck(this, Environments);

		this._environments = new Map();

		this.load();
	}


	_createClass(Environments, [{
		key: "load",
		value: function load() {
			var _this = this;

			Object.keys(envs).forEach(function (envName) {
				_this._environments.set(envName, envs[envName]);
			});
		}

	}, {
		key: "get",
		value: function get(name) {
			return this._environments.get(name) || null;
		}

	}, {
		key: "getAll",
		value: function getAll() {
			return Array.from(this._environments).reduce(function (coll, env) {
				coll[env[0]] = env[1];
				return coll;
			}, {});
		}

	}, {
		key: "define",
		value: function define(name, env) {
			this._environments.set(name, env);
		}

	}, {
		key: "importPlugin",
		value: function importPlugin(plugin, pluginName) {
			var _this2 = this;

			if (plugin.environments) {
				Object.keys(plugin.environments).forEach(function (envName) {
					_this2.define(pluginName + "/" + envName, plugin.environments[envName]);
				});
			}
		}
	}]);

	return Environments;
}();

module.exports = Environments;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var globals = __webpack_require__(162);
module.exports = {
	builtin: globals.es5,
	browser: {
		globals: Object.assign({
			AutocompleteErrorEvent: false,
			CDATASection: false,
			ClientRect: false,
			ClientRectList: false,
			CSSAnimation: false,
			CSSTransition: false,
			CSSUnknownRule: false,
			CSSViewportRule: false,
			Debug: false,
			DocumentTimeline: false,
			DOMSettableTokenList: false,
			ElementTimeControl: false,
			FederatedCredential: false,
			FileError: false,
			HTMLAppletElement: false,
			HTMLBlockquoteElement: false,
			HTMLIsIndexElement: false,
			HTMLKeygenElement: false,
			HTMLLayerElement: false,
			IDBEnvironment: false,
			InputMethodContext: false,
			MediaKeyError: false,
			MediaKeyEvent: false,
			MediaKeys: false,
			opera: false,
			PasswordCredential: false,
			ReadableByteStream: false,
			SharedKeyframeList: false,
			showModalDialog: false,
			SiteBoundCredential: false,
			SVGAltGlyphDefElement: false,
			SVGAltGlyphElement: false,
			SVGAltGlyphItemElement: false,
			SVGAnimateColorElement: false,
			SVGAnimatedPathData: false,
			SVGAnimatedPoints: false,
			SVGColor: false,
			SVGColorProfileElement: false,
			SVGColorProfileRule: false,
			SVGCSSRule: false,
			SVGCursorElement: false,
			SVGDocument: false,
			SVGElementInstance: false,
			SVGElementInstanceList: false,
			SVGEvent: false,
			SVGExternalResourcesRequired: false,
			SVGFilterPrimitiveStandardAttributes: false,
			SVGFitToViewBox: false,
			SVGFontElement: false,
			SVGFontFaceElement: false,
			SVGFontFaceFormatElement: false,
			SVGFontFaceNameElement: false,
			SVGFontFaceSrcElement: false,
			SVGFontFaceUriElement: false,
			SVGGlyphElement: false,
			SVGGlyphRefElement: false,
			SVGHKernElement: false,
			SVGICCColor: false,
			SVGLangSpace: false,
			SVGLocatable: false,
			SVGMissingGlyphElement: false,
			SVGPaint: false,
			SVGPathSeg: false,
			SVGPathSegArcAbs: false,
			SVGPathSegArcRel: false,
			SVGPathSegClosePath: false,
			SVGPathSegCurvetoCubicAbs: false,
			SVGPathSegCurvetoCubicRel: false,
			SVGPathSegCurvetoCubicSmoothAbs: false,
			SVGPathSegCurvetoCubicSmoothRel: false,
			SVGPathSegCurvetoQuadraticAbs: false,
			SVGPathSegCurvetoQuadraticRel: false,
			SVGPathSegCurvetoQuadraticSmoothAbs: false,
			SVGPathSegCurvetoQuadraticSmoothRel: false,
			SVGPathSegLinetoAbs: false,
			SVGPathSegLinetoHorizontalAbs: false,
			SVGPathSegLinetoHorizontalRel: false,
			SVGPathSegLinetoRel: false,
			SVGPathSegLinetoVerticalAbs: false,
			SVGPathSegLinetoVerticalRel: false,
			SVGPathSegList: false,
			SVGPathSegMovetoAbs: false,
			SVGPathSegMovetoRel: false,
			SVGRenderingIntent: false,
			SVGStylable: false,
			SVGTests: false,
			SVGTransformable: false,
			SVGTRefElement: false,
			SVGURIReference: false,
			SVGViewSpec: false,
			SVGVKernElement: false,
			SVGZoomAndPan: false,
			SVGZoomEvent: false,
			TimeEvent: false,
			XDomainRequest: false,
			XMLHttpRequestProgressEvent: false,
			XPathException: false,
			XPathNamespace: false,
			XPathNSResolver: false
		}, globals.browser)
	},
	node: {
		globals: Object.assign({ arguments: false, GLOBAL: false, root: false }, globals.node),
		parserOptions: {
			ecmaFeatures: {
				globalReturn: true
			}
		}
	},
	commonjs: {
		globals: globals.commonjs,
		parserOptions: {
			ecmaFeatures: {
				globalReturn: true
			}
		}
	},
	"shared-node-browser": {
		globals: globals["shared-node-browser"]
	},
	worker: {
		globals: globals.worker
	},
	amd: {
		globals: globals.amd
	},
	mocha: {
		globals: globals.mocha
	},
	jasmine: {
		globals: globals.jasmine
	},
	jest: {
		globals: Object.assign({ check: false, gen: false }, globals.jest)
	},
	phantomjs: {
		globals: globals.phantomjs
	},
	jquery: {
		globals: globals.jquery
	},
	qunit: {
		globals: globals.qunit
	},
	prototypejs: {
		globals: globals.prototypejs
	},
	shelljs: {
		globals: globals.shelljs
	},
	meteor: {
		globals: globals.meteor
	},
	mongo: {
		globals: globals.mongo
	},
	protractor: {
		globals: globals.protractor
	},
	applescript: {
		globals: globals.applescript
	},
	nashorn: {
		globals: globals.nashorn
	},
	serviceworker: {
		globals: globals.serviceworker
	},
	atomtest: {
		globals: globals.atomtest
	},
	embertest: {
		globals: globals.embertest
	},
	webextensions: {
		globals: globals.webextensions
	},
	es6: {
		globals: globals.es2015,
		parserOptions: {
			ecmaVersion: 6
		}
	},
	greasemonkey: {
		globals: globals.greasemonkey
	}
};
 }),
 (function(module, exports) {

module.exports = {"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":false,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCIceCandidate":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCSessionDescription":false,"RTCStatsReport":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"Y":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"Cache":false,"caches":false,"CacheStorage":false,"Client":false,"clients":false,"Clients":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"FetchEvent":false,"importScripts":false,"registration":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"skipWaiting":false,"WindowClient":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var lodash = __webpack_require__(10);
function compareLocations(itemA, itemB) {
	return itemA.line - itemB.line || itemA.column - itemB.column;
}
function applyDirectives(options) {
	var problems = [];
	var nextDirectiveIndex = 0;
	var currentGlobalDisableDirective = null;
	var disabledRuleMap = new Map();
	var enabledRules = new Set();
	var usedDisableDirectives = new Set();

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = options.problems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var problem = _step.value;

			while (nextDirectiveIndex < options.directives.length && compareLocations(options.directives[nextDirectiveIndex], problem) <= 0) {
				var directive = options.directives[nextDirectiveIndex++];

				switch (directive.type) {
					case "disable":
						if (directive.ruleId === null) {
							currentGlobalDisableDirective = directive;
							disabledRuleMap.clear();
							enabledRules.clear();
						} else if (currentGlobalDisableDirective) {
							enabledRules.delete(directive.ruleId);
							disabledRuleMap.set(directive.ruleId, directive);
						} else {
							disabledRuleMap.set(directive.ruleId, directive);
						}
						break;

					case "enable":
						if (directive.ruleId === null) {
							currentGlobalDisableDirective = null;
							disabledRuleMap.clear();
						} else if (currentGlobalDisableDirective) {
							enabledRules.add(directive.ruleId);
							disabledRuleMap.delete(directive.ruleId);
						} else {
							disabledRuleMap.delete(directive.ruleId);
						}
						break;
				}
			}

			if (disabledRuleMap.has(problem.ruleId)) {
				usedDisableDirectives.add(disabledRuleMap.get(problem.ruleId));
			} else if (currentGlobalDisableDirective && !enabledRules.has(problem.ruleId)) {
				usedDisableDirectives.add(currentGlobalDisableDirective);
			} else {
				problems.push(problem);
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var unusedDisableDirectives = options.directives.filter(function (directive) {
		return directive.type === "disable" && !usedDisableDirectives.has(directive);
	}).map(function (directive) {
		return {
			ruleId: null,
			message: directive.ruleId ? "Unused eslint-disable directive (no problems were reported from '" + directive.ruleId + "')." : "Unused eslint-disable directive (no problems were reported).",
			line: directive.unprocessedDirective.line,
			column: directive.unprocessedDirective.column,
			severity: 2,
			source: null,
			nodeType: null
		};
	});

	return { problems: problems, unusedDisableDirectives: unusedDisableDirectives };
}
module.exports = function (options) {
	var blockDirectives = options.directives.filter(function (directive) {
		return directive.type === "disable" || directive.type === "enable";
	}).map(function (directive) {
		return Object.assign({}, directive, { unprocessedDirective: directive });
	}).sort(compareLocations);

	var lineDirectives = lodash.flatMap(options.directives, function (directive) {
		switch (directive.type) {
			case "disable":
			case "enable":
				return [];

			case "disable-line":
				return [{ type: "disable", line: directive.line, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive }, { type: "enable", line: directive.line + 1, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }];

			case "disable-next-line":
				return [{ type: "disable", line: directive.line + 1, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive }, { type: "enable", line: directive.line + 2, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }];

			default:
				throw new TypeError("Unrecognized directive type '" + directive.type + "'");
		}
	}).sort(compareLocations);

	var blockDirectivesResult = applyDirectives({ problems: options.problems, directives: blockDirectives });
	var lineDirectivesResult = applyDirectives({ problems: blockDirectivesResult.problems, directives: lineDirectives });

	return options.reportUnusedDisableDirectives ? lineDirectivesResult.problems.concat(blockDirectivesResult.unusedDisableDirectives).concat(lineDirectivesResult.unusedDisableDirectives).sort(compareLocations) : lineDirectivesResult.problems;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	var listeners = Object.create(null);

	return Object.freeze({
		on: function on(eventName, listener) {
			if (eventName in listeners) {
				listeners[eventName].push(listener);
			} else {
				listeners[eventName] = [listener];
			}
		},
		emit: function emit(eventName, a, b, c) {
			if (eventName in listeners) {
				listeners[eventName].forEach(function (listener) {
					return listener(a, b, c);
				});
			}
		},
		eventNames: function eventNames() {
			return Object.keys(listeners);
		}
	});
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var esquery = __webpack_require__(376);
var lodash = __webpack_require__(10);
function getPossibleTypes(parsedSelector) {
	switch (parsedSelector.type) {
		case "identifier":
			return [parsedSelector.value];

		case "matches":
			{
				var typesForComponents = parsedSelector.selectors.map(getPossibleTypes);

				if (typesForComponents.every(function (typesForComponent) {
					return typesForComponent;
				})) {
					return lodash.union.apply(null, typesForComponents);
				}
				return null;
			}

		case "compound":
			{
				var _typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(function (typesForComponent) {
					return typesForComponent;
				});
				if (!_typesForComponents.length) {
					return null;
				}
				return lodash.intersection.apply(null, _typesForComponents);
			}

		case "child":
		case "descendant":
		case "sibling":
		case "adjacent":
			return getPossibleTypes(parsedSelector.right);

		default:
			return null;

	}
}
function countClassAttributes(parsedSelector) {
	switch (parsedSelector.type) {
		case "child":
		case "descendant":
		case "sibling":
		case "adjacent":
			return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);

		case "compound":
		case "not":
		case "matches":
			return parsedSelector.selectors.reduce(function (sum, childSelector) {
				return sum + countClassAttributes(childSelector);
			}, 0);

		case "attribute":
		case "field":
		case "nth-child":
		case "nth-last-child":
			return 1;

		default:
			return 0;
	}
}
function countIdentifiers(parsedSelector) {
	switch (parsedSelector.type) {
		case "child":
		case "descendant":
		case "sibling":
		case "adjacent":
			return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);

		case "compound":
		case "not":
		case "matches":
			return parsedSelector.selectors.reduce(function (sum, childSelector) {
				return sum + countIdentifiers(childSelector);
			}, 0);

		case "identifier":
			return 1;

		default:
			return 0;
	}
}
function compareSpecificity(selectorA, selectorB) {
	return selectorA.attributeCount - selectorB.attributeCount || selectorA.identifierCount - selectorB.identifierCount || (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);
}
function tryParseSelector(rawSelector) {
	try {
		return esquery.parse(rawSelector.replace(/:exit$/, ""));
	} catch (err) {
		if (typeof err.offset === "number") {
			throw new SyntaxError("Syntax error in selector \"" + rawSelector + "\" at position " + err.offset + ": " + err.message);
		}
		throw err;
	}
}
var parseSelector = lodash.memoize(function (rawSelector) {
	var parsedSelector = tryParseSelector(rawSelector);

	return {
		rawSelector: rawSelector,
		isExit: rawSelector.endsWith(":exit"),
		parsedSelector: parsedSelector,
		listenerTypes: getPossibleTypes(parsedSelector),
		attributeCount: countClassAttributes(parsedSelector),
		identifierCount: countIdentifiers(parsedSelector)
	};
});

var NodeEventGenerator = function () {
	function NodeEventGenerator(emitter) {
		var _this = this;

		_classCallCheck(this, NodeEventGenerator);

		this.emitter = emitter;
		this.currentAncestry = [];
		this.enterSelectorsByNodeType = new Map();
		this.exitSelectorsByNodeType = new Map();
		this.anyTypeEnterSelectors = [];
		this.anyTypeExitSelectors = [];

		emitter.eventNames().forEach(function (rawSelector) {
			var selector = parseSelector(rawSelector);

			if (selector.listenerTypes) {
				selector.listenerTypes.forEach(function (nodeType) {
					var typeMap = selector.isExit ? _this.exitSelectorsByNodeType : _this.enterSelectorsByNodeType;

					if (!typeMap.has(nodeType)) {
						typeMap.set(nodeType, []);
					}
					typeMap.get(nodeType).push(selector);
				});
			} else {
				(selector.isExit ? _this.anyTypeExitSelectors : _this.anyTypeEnterSelectors).push(selector);
			}
		});

		this.anyTypeEnterSelectors.sort(compareSpecificity);
		this.anyTypeExitSelectors.sort(compareSpecificity);
		this.enterSelectorsByNodeType.forEach(function (selectorList) {
			return selectorList.sort(compareSpecificity);
		});
		this.exitSelectorsByNodeType.forEach(function (selectorList) {
			return selectorList.sort(compareSpecificity);
		});
	}


	_createClass(NodeEventGenerator, [{
		key: "applySelector",
		value: function applySelector(node, selector) {
			if (esquery.matches(node, selector.parsedSelector, this.currentAncestry)) {
				this.emitter.emit(selector.rawSelector, node);
			}
		}

	}, {
		key: "applySelectors",
		value: function applySelectors(node, isExit) {
			var selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];
			var anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
			var selectorsByTypeIndex = 0;
			var anyTypeSelectorsIndex = 0;

			while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {
				if (selectorsByTypeIndex >= selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length && compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0) {
					this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);
				} else {
					this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);
				}
			}
		}

	}, {
		key: "enterNode",
		value: function enterNode(node) {
			if (node.parent) {
				this.currentAncestry.unshift(node.parent);
			}
			this.applySelectors(node, false);
		}

	}, {
		key: "leaveNode",
		value: function leaveNode(node) {
			this.applySelectors(node, true);
			this.currentAncestry.shift();
		}
	}]);

	return NodeEventGenerator;
}();

module.exports = NodeEventGenerator;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
(function () {

	var estraverse = __webpack_require__(50);
	var parser = __webpack_require__(377);

	var isArray = Array.isArray || function isArray(array) {
		return {}.toString.call(array) === '[object Array]';
	};

	var LEFT_SIDE = {};
	var RIGHT_SIDE = {};

	function esqueryModule() {
		function getPath(obj, key) {
			var i,
				keys = key.split(".");
			for (i = 0; i < keys.length; i++) {
				if (obj == null) {
					return obj;
				}
				obj = obj[keys[i]];
			}
			return obj;
		}
		function inPath(node, ancestor, path) {
			var field, remainingPath, i;
			if (path.length === 0) {
				return node === ancestor;
			}
			if (ancestor == null) {
				return false;
			}
			field = ancestor[path[0]];
			remainingPath = path.slice(1);
			if (isArray(field)) {
				for (i = 0, l = field.length; i < l; ++i) {
					if (inPath(node, field[i], remainingPath)) {
						return true;
					}
				}
				return false;
			} else {
				return inPath(node, field, remainingPath);
			}
		}
		function matches(node, selector, ancestry) {
			var path, ancestor, i, l, p;
			if (!selector) {
				return true;
			}
			if (!node) {
				return false;
			}
			if (!ancestry) {
				ancestry = [];
			}

			switch (selector.type) {
				case 'wildcard':
					return true;

				case 'identifier':
					return selector.value.toLowerCase() === node.type.toLowerCase();

				case 'field':
					path = selector.name.split('.');
					ancestor = ancestry[path.length - 1];
					return inPath(node, ancestor, path);

				case 'matches':
					for (i = 0, l = selector.selectors.length; i < l; ++i) {
						if (matches(node, selector.selectors[i], ancestry)) {
							return true;
						}
					}
					return false;

				case 'compound':
					for (i = 0, l = selector.selectors.length; i < l; ++i) {
						if (!matches(node, selector.selectors[i], ancestry)) {
							return false;
						}
					}
					return true;

				case 'not':
					for (i = 0, l = selector.selectors.length; i < l; ++i) {
						if (matches(node, selector.selectors[i], ancestry)) {
							return false;
						}
					}
					return true;

				case 'child':
					if (matches(node, selector.right, ancestry)) {
						return matches(ancestry[0], selector.left, ancestry.slice(1));
					}
					return false;

				case 'descendant':
					if (matches(node, selector.right, ancestry)) {
						for (i = 0, l = ancestry.length; i < l; ++i) {
							if (matches(ancestry[i], selector.left, ancestry.slice(i + 1))) {
								return true;
							}
						}
					}
					return false;

				case 'attribute':
					p = getPath(node, selector.name);
					switch (selector.operator) {
						case null:
						case void 0:
							return p != null;
						case '=':
							switch (selector.value.type) {
								case 'regexp':
									return selector.value.value.test(p);
								case 'literal':
									return '' + selector.value.value === '' + p;
								case 'type':
									return selector.value.value === (typeof p === 'undefined' ? 'undefined' : _typeof(p));
							}
						case '!=':
							switch (selector.value.type) {
								case 'regexp':
									return !selector.value.value.test(p);
								case 'literal':
									return '' + selector.value.value !== '' + p;
								case 'type':
									return selector.value.value !== (typeof p === 'undefined' ? 'undefined' : _typeof(p));
							}
						case '<=':
							return p <= selector.value.value;
						case '<':
							return p < selector.value.value;
						case '>':
							return p > selector.value.value;
						case '>=':
							return p >= selector.value.value;
					}

				case 'sibling':
					return matches(node, selector.right, ancestry) && sibling(node, selector.left, ancestry, LEFT_SIDE) || selector.left.subject && matches(node, selector.left, ancestry) && sibling(node, selector.right, ancestry, RIGHT_SIDE);

				case 'adjacent':
					return matches(node, selector.right, ancestry) && adjacent(node, selector.left, ancestry, LEFT_SIDE) || selector.right.subject && matches(node, selector.left, ancestry) && adjacent(node, selector.right, ancestry, RIGHT_SIDE);

				case 'nth-child':
					return matches(node, selector.right, ancestry) && nthChild(node, ancestry, function (length) {
						return selector.index.value - 1;
					});

				case 'nth-last-child':
					return matches(node, selector.right, ancestry) && nthChild(node, ancestry, function (length) {
						return length - selector.index.value;
					});

				case 'class':
					if (!node.type) return false;
					switch (selector.name.toLowerCase()) {
						case 'statement':
							if (node.type.slice(-9) === 'Statement') return true;
						case 'declaration':
							return node.type.slice(-11) === 'Declaration';
						case 'pattern':
							if (node.type.slice(-7) === 'Pattern') return true;
						case 'expression':
							return node.type.slice(-10) === 'Expression' || node.type === 'Literal' || node.type === 'Identifier';
						case 'function':
							return node.type.slice(0, 8) === 'Function' || node.type === 'ArrowFunctionExpression';
					}
					throw new Error('Unknown class name: ' + selector.name);
			}

			throw new Error('Unknown selector type: ' + selector.type);
		}
		function sibling(node, selector, ancestry, side) {
			var parent = ancestry[0],
				listProp,
				startIndex,
				keys,
				i,
				l,
				k,
				lowerBound,
				upperBound;
			if (!parent) {
				return false;
			}
			keys = estraverse.VisitorKeys[parent.type];
			for (i = 0, l = keys.length; i < l; ++i) {
				listProp = parent[keys[i]];
				if (isArray(listProp)) {
					startIndex = listProp.indexOf(node);
					if (startIndex < 0) {
						continue;
					}
					if (side === LEFT_SIDE) {
						lowerBound = 0;
						upperBound = startIndex;
					} else {
						lowerBound = startIndex + 1;
						upperBound = listProp.length;
					}
					for (k = lowerBound; k < upperBound; ++k) {
						if (matches(listProp[k], selector, ancestry)) {
							return true;
						}
					}
				}
			}
			return false;
		}
		function adjacent(node, selector, ancestry, side) {
			var parent = ancestry[0],
				listProp,
				keys,
				i,
				l,
				idx;
			if (!parent) {
				return false;
			}
			keys = estraverse.VisitorKeys[parent.type];
			for (i = 0, l = keys.length; i < l; ++i) {
				listProp = parent[keys[i]];
				if (isArray(listProp)) {
					idx = listProp.indexOf(node);
					if (idx < 0) {
						continue;
					}
					if (side === LEFT_SIDE && idx > 0 && matches(listProp[idx - 1], selector, ancestry)) {
						return true;
					}
					if (side === RIGHT_SIDE && idx < listProp.length - 1 && matches(listProp[idx + 1], selector, ancestry)) {
						return true;
					}
				}
			}
			return false;
		}
		function nthChild(node, ancestry, idxFn) {
			var parent = ancestry[0],
				listProp,
				keys,
				i,
				l,
				idx;
			if (!parent) {
				return false;
			}
			keys = estraverse.VisitorKeys[parent.type];
			for (i = 0, l = keys.length; i < l; ++i) {
				listProp = parent[keys[i]];
				if (isArray(listProp)) {
					idx = listProp.indexOf(node);
					if (idx >= 0 && idx === idxFn(listProp.length)) {
						return true;
					}
				}
			}
			return false;
		}
		function subjects(selector, ancestor) {
			var results, p;
			if (selector == null || (typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) != 'object') {
				return [];
			}
			if (ancestor == null) {
				ancestor = selector;
			}
			results = selector.subject ? [ancestor] : [];
			for (p in selector) {
				if (!{}.hasOwnProperty.call(selector, p)) {
					continue;
				}
				[].push.apply(results, subjects(selector[p], p === 'left' ? selector[p] : ancestor));
			}
			return results;
		}
		function match(ast, selector) {
			var ancestry = [],
				results = [],
				altSubjects,
				i,
				l,
				k,
				m;
			if (!selector) {
				return results;
			}
			altSubjects = subjects(selector);
			estraverse.traverse(ast, {
				enter: function enter(node, parent) {
					if (parent != null) {
						ancestry.unshift(parent);
					}
					if (matches(node, selector, ancestry)) {
						if (altSubjects.length) {
							for (i = 0, l = altSubjects.length; i < l; ++i) {
								if (matches(node, altSubjects[i], ancestry)) {
									results.push(node);
								}
								for (k = 0, m = ancestry.length; k < m; ++k) {
									if (matches(ancestry[k], altSubjects[i], ancestry.slice(k + 1))) {
										results.push(ancestry[k]);
									}
								}
							}
						} else {
							results.push(node);
						}
					}
				},
				leave: function leave() {
					ancestry.shift();
				}
			});
			return results;
		}
		function parse(selector) {
			return parser.parse(selector);
		}
		function query(ast, selector) {
			return match(ast, parse(selector));
		}

		query.parse = parse;
		query.match = match;
		query.matches = matches;
		return query.query = query;
	}

	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (esqueryModule),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = esqueryModule();
	} else {
		this.esquery = esqueryModule();
	}
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

var result = function () {

  function quote(s) {
	return '"' + s.replace(/\\/g, '\\\\') // backslash
	.replace(/"/g, '\\"') // closing quote character
	.replace(/\x08/g, '\\b') // backspace
	.replace(/\t/g, '\\t') // horizontal tab
	.replace(/\n/g, '\\n') // line feed
	.replace(/\f/g, '\\f') // form feed
	.replace(/\r/g, '\\r') // carriage return
	.replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"';
  }

  var result = {
	parse: function parse(input, startRule) {
			var parseFunctions = {
		"start": parse_start,
		"_": parse__,
		"identifierName": parse_identifierName,
		"binaryOp": parse_binaryOp,
		"selectors": parse_selectors,
		"selector": parse_selector,
		"sequence": parse_sequence,
		"atom": parse_atom,
		"wildcard": parse_wildcard,
		"identifier": parse_identifier,
		"attr": parse_attr,
		"attrOps": parse_attrOps,
		"attrEqOps": parse_attrEqOps,
		"attrName": parse_attrName,
		"attrValue": parse_attrValue,
		"string": parse_string,
		"number": parse_number,
		"path": parse_path,
		"type": parse_type,
		"regex": parse_regex,
		"field": parse_field,
		"negation": parse_negation,
		"matches": parse_matches,
		"firstChild": parse_firstChild,
		"lastChild": parse_lastChild,
		"nthChild": parse_nthChild,
		"nthLastChild": parse_nthLastChild,
		"class": parse_class
			};

			if (startRule !== undefined) {
		if (parseFunctions[startRule] === undefined) {
					throw new Error("Invalid rule name: " + quote(startRule) + ".");
		}
			} else {
		startRule = "start";
			}

			var pos = 0;
			var reportFailures = 0;
			var rightmostFailuresPos = 0;
			var rightmostFailuresExpected = [];
			var cache = {};

			function padLeft(input, padding, length) {
		var result = input;

		var padLength = length - input.length;
		for (var i = 0; i < padLength; i++) {
					result = padding + result;
		}

		return result;
			}

			function escape(ch) {
		var charCode = ch.charCodeAt(0);
		var escapeChar;
		var length;

		if (charCode <= 0xFF) {
					escapeChar = 'x';
					length = 2;
		} else {
					escapeChar = 'u';
					length = 4;
		}

		return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
			}

			function matchFailed(failure) {
		if (pos < rightmostFailuresPos) {
					return;
		}

		if (pos > rightmostFailuresPos) {
					rightmostFailuresPos = pos;
					rightmostFailuresExpected = [];
		}

		rightmostFailuresExpected.push(failure);
			}

			function parse_start() {
		var cacheKey = "start@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		result0 = parse__();
		if (result0 !== null) {
					result1 = parse_selectors();
					if (result1 !== null) {
			result2 = parse__();
			if (result2 !== null) {
							result0 = [result0, result1, result2];
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, ss) {
			return ss.length === 1 ? ss[0] : { type: 'matches', selectors: ss };
					}(pos0, result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}
		if (result0 === null) {
					pos0 = pos;
					result0 = parse__();
					if (result0 !== null) {
			result0 = function (offset) {
							return void 0;
			}(pos0);
					}
					if (result0 === null) {
			pos = pos0;
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse__() {
		var cacheKey = "_@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;

		result0 = [];
		if (input.charCodeAt(pos) === 32) {
					result1 = " ";
					pos++;
		} else {
					result1 = null;
					if (reportFailures === 0) {
			matchFailed("\" \"");
					}
		}
		while (result1 !== null) {
					result0.push(result1);
					if (input.charCodeAt(pos) === 32) {
			result1 = " ";
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\" \"");
			}
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_identifierName() {
		var cacheKey = "identifierName@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;
		var pos0;

		pos0 = pos;
		if (/^[^ [\],():#!=><~+.]/.test(input.charAt(pos))) {
					result1 = input.charAt(pos);
					pos++;
		} else {
					result1 = null;
					if (reportFailures === 0) {
			matchFailed("[^ [\\],():#!=><~+.]");
					}
		}
		if (result1 !== null) {
					result0 = [];
					while (result1 !== null) {
			result0.push(result1);
			if (/^[^ [\],():#!=><~+.]/.test(input.charAt(pos))) {
							result1 = input.charAt(pos);
							pos++;
			} else {
							result1 = null;
							if (reportFailures === 0) {
				matchFailed("[^ [\\],():#!=><~+.]");
							}
			}
					}
		} else {
					result0 = null;
		}
		if (result0 !== null) {
					result0 = function (offset, i) {
			return i.join('');
					}(pos0, result0);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_binaryOp() {
		var cacheKey = "binaryOp@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		result0 = parse__();
		if (result0 !== null) {
					if (input.charCodeAt(pos) === 62) {
			result1 = ">";
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\">\"");
			}
					}
					if (result1 !== null) {
			result2 = parse__();
			if (result2 !== null) {
							result0 = [result0, result1, result2];
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset) {
			return 'child';
					}(pos0);
		}
		if (result0 === null) {
					pos = pos0;
		}
		if (result0 === null) {
					pos0 = pos;
					pos1 = pos;
					result0 = parse__();
					if (result0 !== null) {
			if (input.charCodeAt(pos) === 126) {
							result1 = "~";
							pos++;
			} else {
							result1 = null;
							if (reportFailures === 0) {
				matchFailed("\"~\"");
							}
			}
			if (result1 !== null) {
							result2 = parse__();
							if (result2 !== null) {
				result0 = [result0, result1, result2];
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
					if (result0 !== null) {
			result0 = function (offset) {
							return 'sibling';
			}(pos0);
					}
					if (result0 === null) {
			pos = pos0;
					}
					if (result0 === null) {
			pos0 = pos;
			pos1 = pos;
			result0 = parse__();
			if (result0 !== null) {
							if (input.charCodeAt(pos) === 43) {
				result1 = "+";
				pos++;
							} else {
				result1 = null;
				if (reportFailures === 0) {
									matchFailed("\"+\"");
				}
							}
							if (result1 !== null) {
				result2 = parse__();
				if (result2 !== null) {
									result0 = [result0, result1, result2];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
			if (result0 !== null) {
							result0 = function (offset) {
				return 'adjacent';
							}(pos0);
			}
			if (result0 === null) {
							pos = pos0;
			}
			if (result0 === null) {
							pos0 = pos;
							pos1 = pos;
							if (input.charCodeAt(pos) === 32) {
				result0 = " ";
				pos++;
							} else {
				result0 = null;
				if (reportFailures === 0) {
									matchFailed("\" \"");
				}
							}
							if (result0 !== null) {
				result1 = parse__();
				if (result1 !== null) {
									result0 = [result0, result1];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
							if (result0 !== null) {
				result0 = function (offset) {
									return 'descendant';
				}(pos0);
							}
							if (result0 === null) {
				pos = pos0;
							}
			}
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_selectors() {
		var cacheKey = "selectors@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4, result5;
		var pos0, pos1, pos2;

		pos0 = pos;
		pos1 = pos;
		result0 = parse_selector();
		if (result0 !== null) {
					result1 = [];
					pos2 = pos;
					result2 = parse__();
					if (result2 !== null) {
			if (input.charCodeAt(pos) === 44) {
							result3 = ",";
							pos++;
			} else {
							result3 = null;
							if (reportFailures === 0) {
				matchFailed("\",\"");
							}
			}
			if (result3 !== null) {
							result4 = parse__();
							if (result4 !== null) {
				result5 = parse_selector();
				if (result5 !== null) {
									result2 = [result2, result3, result4, result5];
				} else {
									result2 = null;
									pos = pos2;
				}
							} else {
				result2 = null;
				pos = pos2;
							}
			} else {
							result2 = null;
							pos = pos2;
			}
					} else {
			result2 = null;
			pos = pos2;
					}
					while (result2 !== null) {
			result1.push(result2);
			pos2 = pos;
			result2 = parse__();
			if (result2 !== null) {
							if (input.charCodeAt(pos) === 44) {
				result3 = ",";
				pos++;
							} else {
				result3 = null;
				if (reportFailures === 0) {
									matchFailed("\",\"");
				}
							}
							if (result3 !== null) {
				result4 = parse__();
				if (result4 !== null) {
									result5 = parse_selector();
									if (result5 !== null) {
					result2 = [result2, result3, result4, result5];
									} else {
					result2 = null;
					pos = pos2;
									}
				} else {
									result2 = null;
									pos = pos2;
				}
							} else {
				result2 = null;
				pos = pos2;
							}
			} else {
							result2 = null;
							pos = pos2;
			}
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, s, ss) {
			return [s].concat(ss.map(function (s) {
							return s[3];
			}));
					}(pos0, result0[0], result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_selector() {
		var cacheKey = "selector@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3;
		var pos0, pos1, pos2;

		pos0 = pos;
		pos1 = pos;
		result0 = parse_sequence();
		if (result0 !== null) {
					result1 = [];
					pos2 = pos;
					result2 = parse_binaryOp();
					if (result2 !== null) {
			result3 = parse_sequence();
			if (result3 !== null) {
							result2 = [result2, result3];
			} else {
							result2 = null;
							pos = pos2;
			}
					} else {
			result2 = null;
			pos = pos2;
					}
					while (result2 !== null) {
			result1.push(result2);
			pos2 = pos;
			result2 = parse_binaryOp();
			if (result2 !== null) {
							result3 = parse_sequence();
							if (result3 !== null) {
				result2 = [result2, result3];
							} else {
				result2 = null;
				pos = pos2;
							}
			} else {
							result2 = null;
							pos = pos2;
			}
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, a, ops) {
			return ops.reduce(function (memo, rhs) {
							return { type: rhs[0], left: memo, right: rhs[1] };
			}, a);
					}(pos0, result0[0], result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_sequence() {
		var cacheKey = "sequence@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 33) {
					result0 = "!";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"!\"");
					}
		}
		result0 = result0 !== null ? result0 : "";
		if (result0 !== null) {
					result2 = parse_atom();
					if (result2 !== null) {
			result1 = [];
			while (result2 !== null) {
							result1.push(result2);
							result2 = parse_atom();
			}
					} else {
			result1 = null;
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, subject, as) {
			var b = as.length === 1 ? as[0] : { type: 'compound', selectors: as };
			if (subject) b.subject = true;
			return b;
					}(pos0, result0[0], result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_atom() {
		var cacheKey = "atom@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0;

		result0 = parse_wildcard();
		if (result0 === null) {
					result0 = parse_identifier();
					if (result0 === null) {
			result0 = parse_attr();
			if (result0 === null) {
							result0 = parse_field();
							if (result0 === null) {
				result0 = parse_negation();
				if (result0 === null) {
									result0 = parse_matches();
									if (result0 === null) {
					result0 = parse_firstChild();
					if (result0 === null) {
											result0 = parse_lastChild();
											if (result0 === null) {
						result0 = parse_nthChild();
						if (result0 === null) {
													result0 = parse_nthLastChild();
													if (result0 === null) {
							result0 = parse_class();
													}
						}
											}
					}
									}
				}
							}
			}
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_wildcard() {
		var cacheKey = "wildcard@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0;
		var pos0;

		pos0 = pos;
		if (input.charCodeAt(pos) === 42) {
					result0 = "*";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"*\"");
					}
		}
		if (result0 !== null) {
					result0 = function (offset, a) {
			return { type: 'wildcard', value: a };
					}(pos0, result0);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_identifier() {
		var cacheKey = "identifier@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 35) {
					result0 = "#";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"#\"");
					}
		}
		result0 = result0 !== null ? result0 : "";
		if (result0 !== null) {
					result1 = parse_identifierName();
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, i) {
			return { type: 'identifier', value: i };
					}(pos0, result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_attr() {
		var cacheKey = "attr@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 91) {
					result0 = "[";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"[\"");
					}
		}
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			result2 = parse_attrValue();
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				if (input.charCodeAt(pos) === 93) {
									result4 = "]";
									pos++;
				} else {
									result4 = null;
									if (reportFailures === 0) {
					matchFailed("\"]\"");
									}
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, v) {
			return v;
					}(pos0, result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_attrOps() {
		var cacheKey = "attrOps@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (/^[><!]/.test(input.charAt(pos))) {
					result0 = input.charAt(pos);
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("[><!]");
					}
		}
		result0 = result0 !== null ? result0 : "";
		if (result0 !== null) {
					if (input.charCodeAt(pos) === 61) {
			result1 = "=";
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\"=\"");
			}
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, a) {
			return a + '=';
					}(pos0, result0[0]);
		}
		if (result0 === null) {
					pos = pos0;
		}
		if (result0 === null) {
					if (/^[><]/.test(input.charAt(pos))) {
			result0 = input.charAt(pos);
			pos++;
					} else {
			result0 = null;
			if (reportFailures === 0) {
							matchFailed("[><]");
			}
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_attrEqOps() {
		var cacheKey = "attrEqOps@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 33) {
					result0 = "!";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"!\"");
					}
		}
		result0 = result0 !== null ? result0 : "";
		if (result0 !== null) {
					if (input.charCodeAt(pos) === 61) {
			result1 = "=";
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\"=\"");
			}
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, a) {
			return a + '=';
					}(pos0, result0[0]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_attrName() {
		var cacheKey = "attrName@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;
		var pos0;

		pos0 = pos;
		result1 = parse_identifierName();
		if (result1 === null) {
					if (input.charCodeAt(pos) === 46) {
			result1 = ".";
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\".\"");
			}
					}
		}
		if (result1 !== null) {
					result0 = [];
					while (result1 !== null) {
			result0.push(result1);
			result1 = parse_identifierName();
			if (result1 === null) {
							if (input.charCodeAt(pos) === 46) {
				result1 = ".";
				pos++;
							} else {
				result1 = null;
				if (reportFailures === 0) {
									matchFailed("\".\"");
				}
							}
			}
					}
		} else {
					result0 = null;
		}
		if (result0 !== null) {
					result0 = function (offset, i) {
			return i.join('');
					}(pos0, result0);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_attrValue() {
		var cacheKey = "attrValue@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		result0 = parse_attrName();
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			result2 = parse_attrEqOps();
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				result4 = parse_type();
				if (result4 === null) {
									result4 = parse_regex();
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, name, op, value) {
			return { type: 'attribute', name: name, operator: op, value: value };
					}(pos0, result0[0], result0[2], result0[4]);
		}
		if (result0 === null) {
					pos = pos0;
		}
		if (result0 === null) {
					pos0 = pos;
					pos1 = pos;
					result0 = parse_attrName();
					if (result0 !== null) {
			result1 = parse__();
			if (result1 !== null) {
							result2 = parse_attrOps();
							if (result2 !== null) {
				result3 = parse__();
				if (result3 !== null) {
									result4 = parse_string();
									if (result4 === null) {
					result4 = parse_number();
					if (result4 === null) {
											result4 = parse_path();
					}
									}
									if (result4 !== null) {
					result0 = [result0, result1, result2, result3, result4];
									} else {
					result0 = null;
					pos = pos1;
									}
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
					if (result0 !== null) {
			result0 = function (offset, name, op, value) {
							return { type: 'attribute', name: name, operator: op, value: value };
			}(pos0, result0[0], result0[2], result0[4]);
					}
					if (result0 === null) {
			pos = pos0;
					}
					if (result0 === null) {
			pos0 = pos;
			result0 = parse_attrName();
			if (result0 !== null) {
							result0 = function (offset, name) {
				return { type: 'attribute', name: name };
							}(pos0, result0);
			}
			if (result0 === null) {
							pos = pos0;
			}
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_string() {
		var cacheKey = "string@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3;
		var pos0, pos1, pos2, pos3;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 34) {
					result0 = "\"";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"\\\"\"");
					}
		}
		if (result0 !== null) {
					result1 = [];
					if (/^[^\\"]/.test(input.charAt(pos))) {
			result2 = input.charAt(pos);
			pos++;
					} else {
			result2 = null;
			if (reportFailures === 0) {
							matchFailed("[^\\\\\"]");
			}
					}
					if (result2 === null) {
			pos2 = pos;
			pos3 = pos;
			if (input.charCodeAt(pos) === 92) {
							result2 = "\\";
							pos++;
			} else {
							result2 = null;
							if (reportFailures === 0) {
				matchFailed("\"\\\\\"");
							}
			}
			if (result2 !== null) {
							if (input.length > pos) {
				result3 = input.charAt(pos);
				pos++;
							} else {
				result3 = null;
				if (reportFailures === 0) {
									matchFailed("any character");
				}
							}
							if (result3 !== null) {
				result2 = [result2, result3];
							} else {
				result2 = null;
				pos = pos3;
							}
			} else {
							result2 = null;
							pos = pos3;
			}
			if (result2 !== null) {
							result2 = function (offset, a, b) {
				return a + b;
							}(pos2, result2[0], result2[1]);
			}
			if (result2 === null) {
							pos = pos2;
			}
					}
					while (result2 !== null) {
			result1.push(result2);
			if (/^[^\\"]/.test(input.charAt(pos))) {
							result2 = input.charAt(pos);
							pos++;
			} else {
							result2 = null;
							if (reportFailures === 0) {
				matchFailed("[^\\\\\"]");
							}
			}
			if (result2 === null) {
							pos2 = pos;
							pos3 = pos;
							if (input.charCodeAt(pos) === 92) {
				result2 = "\\";
				pos++;
							} else {
				result2 = null;
				if (reportFailures === 0) {
									matchFailed("\"\\\\\"");
				}
							}
							if (result2 !== null) {
				if (input.length > pos) {
									result3 = input.charAt(pos);
									pos++;
				} else {
									result3 = null;
									if (reportFailures === 0) {
					matchFailed("any character");
									}
				}
				if (result3 !== null) {
									result2 = [result2, result3];
				} else {
									result2 = null;
									pos = pos3;
				}
							} else {
				result2 = null;
				pos = pos3;
							}
							if (result2 !== null) {
				result2 = function (offset, a, b) {
									return a + b;
				}(pos2, result2[0], result2[1]);
							}
							if (result2 === null) {
				pos = pos2;
							}
			}
					}
					if (result1 !== null) {
			if (input.charCodeAt(pos) === 34) {
							result2 = "\"";
							pos++;
			} else {
							result2 = null;
							if (reportFailures === 0) {
				matchFailed("\"\\\"\"");
							}
			}
			if (result2 !== null) {
							result0 = [result0, result1, result2];
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, d) {
			return { type: 'literal', value: strUnescape(d.join('')) };
					}(pos0, result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}
		if (result0 === null) {
					pos0 = pos;
					pos1 = pos;
					if (input.charCodeAt(pos) === 39) {
			result0 = "'";
			pos++;
					} else {
			result0 = null;
			if (reportFailures === 0) {
							matchFailed("\"'\"");
			}
					}
					if (result0 !== null) {
			result1 = [];
			if (/^[^\\']/.test(input.charAt(pos))) {
							result2 = input.charAt(pos);
							pos++;
			} else {
							result2 = null;
							if (reportFailures === 0) {
				matchFailed("[^\\\\']");
							}
			}
			if (result2 === null) {
							pos2 = pos;
							pos3 = pos;
							if (input.charCodeAt(pos) === 92) {
				result2 = "\\";
				pos++;
							} else {
				result2 = null;
				if (reportFailures === 0) {
									matchFailed("\"\\\\\"");
				}
							}
							if (result2 !== null) {
				if (input.length > pos) {
									result3 = input.charAt(pos);
									pos++;
				} else {
									result3 = null;
									if (reportFailures === 0) {
					matchFailed("any character");
									}
				}
				if (result3 !== null) {
									result2 = [result2, result3];
				} else {
									result2 = null;
									pos = pos3;
				}
							} else {
				result2 = null;
				pos = pos3;
							}
							if (result2 !== null) {
				result2 = function (offset, a, b) {
									return a + b;
				}(pos2, result2[0], result2[1]);
							}
							if (result2 === null) {
				pos = pos2;
							}
			}
			while (result2 !== null) {
							result1.push(result2);
							if (/^[^\\']/.test(input.charAt(pos))) {
				result2 = input.charAt(pos);
				pos++;
							} else {
				result2 = null;
				if (reportFailures === 0) {
									matchFailed("[^\\\\']");
				}
							}
							if (result2 === null) {
				pos2 = pos;
				pos3 = pos;
				if (input.charCodeAt(pos) === 92) {
									result2 = "\\";
									pos++;
				} else {
									result2 = null;
									if (reportFailures === 0) {
					matchFailed("\"\\\\\"");
									}
				}
				if (result2 !== null) {
									if (input.length > pos) {
					result3 = input.charAt(pos);
					pos++;
									} else {
					result3 = null;
					if (reportFailures === 0) {
											matchFailed("any character");
					}
									}
									if (result3 !== null) {
					result2 = [result2, result3];
									} else {
					result2 = null;
					pos = pos3;
									}
				} else {
									result2 = null;
									pos = pos3;
				}
				if (result2 !== null) {
									result2 = function (offset, a, b) {
					return a + b;
									}(pos2, result2[0], result2[1]);
				}
				if (result2 === null) {
									pos = pos2;
				}
							}
			}
			if (result1 !== null) {
							if (input.charCodeAt(pos) === 39) {
				result2 = "'";
				pos++;
							} else {
				result2 = null;
				if (reportFailures === 0) {
									matchFailed("\"'\"");
				}
							}
							if (result2 !== null) {
				result0 = [result0, result1, result2];
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
					if (result0 !== null) {
			result0 = function (offset, d) {
							return { type: 'literal', value: strUnescape(d.join('')) };
			}(pos0, result0[1]);
					}
					if (result0 === null) {
			pos = pos0;
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_number() {
		var cacheKey = "number@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2;
		var pos0, pos1, pos2;

		pos0 = pos;
		pos1 = pos;
		pos2 = pos;
		result0 = [];
		if (/^[0-9]/.test(input.charAt(pos))) {
					result1 = input.charAt(pos);
					pos++;
		} else {
					result1 = null;
					if (reportFailures === 0) {
			matchFailed("[0-9]");
					}
		}
		while (result1 !== null) {
					result0.push(result1);
					if (/^[0-9]/.test(input.charAt(pos))) {
			result1 = input.charAt(pos);
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("[0-9]");
			}
					}
		}
		if (result0 !== null) {
					if (input.charCodeAt(pos) === 46) {
			result1 = ".";
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\".\"");
			}
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos2;
					}
		} else {
					result0 = null;
					pos = pos2;
		}
		result0 = result0 !== null ? result0 : "";
		if (result0 !== null) {
					if (/^[0-9]/.test(input.charAt(pos))) {
			result2 = input.charAt(pos);
			pos++;
					} else {
			result2 = null;
			if (reportFailures === 0) {
							matchFailed("[0-9]");
			}
					}
					if (result2 !== null) {
			result1 = [];
			while (result2 !== null) {
							result1.push(result2);
							if (/^[0-9]/.test(input.charAt(pos))) {
				result2 = input.charAt(pos);
				pos++;
							} else {
				result2 = null;
				if (reportFailures === 0) {
									matchFailed("[0-9]");
				}
							}
			}
					} else {
			result1 = null;
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, a, b) {
			return { type: 'literal', value: parseFloat((a ? a.join('') : '') + b.join('')) };
					}(pos0, result0[0], result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_path() {
		var cacheKey = "path@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0;
		var pos0;

		pos0 = pos;
		result0 = parse_identifierName();
		if (result0 !== null) {
					result0 = function (offset, i) {
			return { type: 'literal', value: i };
					}(pos0, result0);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_type() {
		var cacheKey = "type@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.substr(pos, 5) === "type(") {
					result0 = "type(";
					pos += 5;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"type(\"");
					}
		}
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			if (/^[^ )]/.test(input.charAt(pos))) {
							result3 = input.charAt(pos);
							pos++;
			} else {
							result3 = null;
							if (reportFailures === 0) {
				matchFailed("[^ )]");
							}
			}
			if (result3 !== null) {
							result2 = [];
							while (result3 !== null) {
				result2.push(result3);
				if (/^[^ )]/.test(input.charAt(pos))) {
									result3 = input.charAt(pos);
									pos++;
				} else {
									result3 = null;
									if (reportFailures === 0) {
					matchFailed("[^ )]");
									}
				}
							}
			} else {
							result2 = null;
			}
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				if (input.charCodeAt(pos) === 41) {
									result4 = ")";
									pos++;
				} else {
									result4 = null;
									if (reportFailures === 0) {
					matchFailed("\")\"");
									}
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, t) {
			return { type: 'type', value: t.join('') };
					}(pos0, result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_regex() {
		var cacheKey = "regex@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 47) {
					result0 = "/";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"/\"");
					}
		}
		if (result0 !== null) {
					if (/^[^\/]/.test(input.charAt(pos))) {
			result2 = input.charAt(pos);
			pos++;
					} else {
			result2 = null;
			if (reportFailures === 0) {
							matchFailed("[^\\/]");
			}
					}
					if (result2 !== null) {
			result1 = [];
			while (result2 !== null) {
							result1.push(result2);
							if (/^[^\/]/.test(input.charAt(pos))) {
				result2 = input.charAt(pos);
				pos++;
							} else {
				result2 = null;
				if (reportFailures === 0) {
									matchFailed("[^\\/]");
				}
							}
			}
					} else {
			result1 = null;
					}
					if (result1 !== null) {
			if (input.charCodeAt(pos) === 47) {
							result2 = "/";
							pos++;
			} else {
							result2 = null;
							if (reportFailures === 0) {
				matchFailed("\"/\"");
							}
			}
			if (result2 !== null) {
							result0 = [result0, result1, result2];
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, d) {
			return { type: 'regexp', value: new RegExp(d.join('')) };
					}(pos0, result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_field() {
		var cacheKey = "field@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1, pos2;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 46) {
					result0 = ".";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\".\"");
					}
		}
		if (result0 !== null) {
					result1 = parse_identifierName();
					if (result1 !== null) {
			result2 = [];
			pos2 = pos;
			if (input.charCodeAt(pos) === 46) {
							result3 = ".";
							pos++;
			} else {
							result3 = null;
							if (reportFailures === 0) {
				matchFailed("\".\"");
							}
			}
			if (result3 !== null) {
							result4 = parse_identifierName();
							if (result4 !== null) {
				result3 = [result3, result4];
							} else {
				result3 = null;
				pos = pos2;
							}
			} else {
							result3 = null;
							pos = pos2;
			}
			while (result3 !== null) {
							result2.push(result3);
							pos2 = pos;
							if (input.charCodeAt(pos) === 46) {
				result3 = ".";
				pos++;
							} else {
				result3 = null;
				if (reportFailures === 0) {
									matchFailed("\".\"");
				}
							}
							if (result3 !== null) {
				result4 = parse_identifierName();
				if (result4 !== null) {
									result3 = [result3, result4];
				} else {
									result3 = null;
									pos = pos2;
				}
							} else {
				result3 = null;
				pos = pos2;
							}
			}
			if (result2 !== null) {
							result0 = [result0, result1, result2];
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, i, is) {
			return { type: 'field', name: is.reduce(function (memo, p) {
				return memo + p[0] + p[1];
							}, i) };
					}(pos0, result0[1], result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_negation() {
		var cacheKey = "negation@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.substr(pos, 5) === ":not(") {
					result0 = ":not(";
					pos += 5;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":not(\"");
					}
		}
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			result2 = parse_selectors();
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				if (input.charCodeAt(pos) === 41) {
									result4 = ")";
									pos++;
				} else {
									result4 = null;
									if (reportFailures === 0) {
					matchFailed("\")\"");
									}
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, ss) {
			return { type: 'not', selectors: ss };
					}(pos0, result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_matches() {
		var cacheKey = "matches@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.substr(pos, 9) === ":matches(") {
					result0 = ":matches(";
					pos += 9;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":matches(\"");
					}
		}
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			result2 = parse_selectors();
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				if (input.charCodeAt(pos) === 41) {
									result4 = ")";
									pos++;
				} else {
									result4 = null;
									if (reportFailures === 0) {
					matchFailed("\")\"");
									}
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, ss) {
			return { type: 'matches', selectors: ss };
					}(pos0, result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_firstChild() {
		var cacheKey = "firstChild@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0;
		var pos0;

		pos0 = pos;
		if (input.substr(pos, 12) === ":first-child") {
					result0 = ":first-child";
					pos += 12;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":first-child\"");
					}
		}
		if (result0 !== null) {
					result0 = function (offset) {
			return nth(1);
					}(pos0);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_lastChild() {
		var cacheKey = "lastChild@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0;
		var pos0;

		pos0 = pos;
		if (input.substr(pos, 11) === ":last-child") {
					result0 = ":last-child";
					pos += 11;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":last-child\"");
					}
		}
		if (result0 !== null) {
					result0 = function (offset) {
			return nthLast(1);
					}(pos0);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_nthChild() {
		var cacheKey = "nthChild@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.substr(pos, 11) === ":nth-child(") {
					result0 = ":nth-child(";
					pos += 11;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":nth-child(\"");
					}
		}
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			if (/^[0-9]/.test(input.charAt(pos))) {
							result3 = input.charAt(pos);
							pos++;
			} else {
							result3 = null;
							if (reportFailures === 0) {
				matchFailed("[0-9]");
							}
			}
			if (result3 !== null) {
							result2 = [];
							while (result3 !== null) {
				result2.push(result3);
				if (/^[0-9]/.test(input.charAt(pos))) {
									result3 = input.charAt(pos);
									pos++;
				} else {
									result3 = null;
									if (reportFailures === 0) {
					matchFailed("[0-9]");
									}
				}
							}
			} else {
							result2 = null;
			}
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				if (input.charCodeAt(pos) === 41) {
									result4 = ")";
									pos++;
				} else {
									result4 = null;
									if (reportFailures === 0) {
					matchFailed("\")\"");
									}
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, n) {
			return nth(parseInt(n.join(''), 10));
					}(pos0, result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_nthLastChild() {
		var cacheKey = "nthLastChild@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.substr(pos, 16) === ":nth-last-child(") {
					result0 = ":nth-last-child(";
					pos += 16;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":nth-last-child(\"");
					}
		}
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			if (/^[0-9]/.test(input.charAt(pos))) {
							result3 = input.charAt(pos);
							pos++;
			} else {
							result3 = null;
							if (reportFailures === 0) {
				matchFailed("[0-9]");
							}
			}
			if (result3 !== null) {
							result2 = [];
							while (result3 !== null) {
				result2.push(result3);
				if (/^[0-9]/.test(input.charAt(pos))) {
									result3 = input.charAt(pos);
									pos++;
				} else {
									result3 = null;
									if (reportFailures === 0) {
					matchFailed("[0-9]");
									}
				}
							}
			} else {
							result2 = null;
			}
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				if (input.charCodeAt(pos) === 41) {
									result4 = ")";
									pos++;
				} else {
									result4 = null;
									if (reportFailures === 0) {
					matchFailed("\")\"");
									}
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, n) {
			return nthLast(parseInt(n.join(''), 10));
					}(pos0, result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_class() {
		var cacheKey = "class@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 58) {
					result0 = ":";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":\"");
					}
		}
		if (result0 !== null) {
					if (input.substr(pos, 9).toLowerCase() === "statement") {
			result1 = input.substr(pos, 9);
			pos += 9;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\"statement\"");
			}
					}
					if (result1 === null) {
			if (input.substr(pos, 10).toLowerCase() === "expression") {
							result1 = input.substr(pos, 10);
							pos += 10;
			} else {
							result1 = null;
							if (reportFailures === 0) {
				matchFailed("\"expression\"");
							}
			}
			if (result1 === null) {
							if (input.substr(pos, 11).toLowerCase() === "declaration") {
				result1 = input.substr(pos, 11);
				pos += 11;
							} else {
				result1 = null;
				if (reportFailures === 0) {
									matchFailed("\"declaration\"");
				}
							}
							if (result1 === null) {
				if (input.substr(pos, 8).toLowerCase() === "function") {
									result1 = input.substr(pos, 8);
									pos += 8;
				} else {
									result1 = null;
									if (reportFailures === 0) {
					matchFailed("\"function\"");
									}
				}
				if (result1 === null) {
									if (input.substr(pos, 7).toLowerCase() === "pattern") {
					result1 = input.substr(pos, 7);
					pos += 7;
									} else {
					result1 = null;
					if (reportFailures === 0) {
											matchFailed("\"pattern\"");
					}
									}
				}
							}
			}
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, c) {
			return { type: 'class', name: c };
					}(pos0, result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function cleanupExpected(expected) {
		expected.sort();

		var lastExpected = null;
		var cleanExpected = [];
		for (var i = 0; i < expected.length; i++) {
					if (expected[i] !== lastExpected) {
			cleanExpected.push(expected[i]);
			lastExpected = expected[i];
					}
		}
		return cleanExpected;
			}

			function computeErrorPosition() {

		var line = 1;
		var column = 1;
		var seenCR = false;

		for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
					var ch = input.charAt(i);
					if (ch === "\n") {
			if (!seenCR) {
							line++;
			}
			column = 1;
			seenCR = false;
					} else if (ch === "\r" || ch === '\u2028' || ch === '\u2029') {
			line++;
			column = 1;
			seenCR = true;
					} else {
			column++;
			seenCR = false;
					}
		}

		return { line: line, column: column };
			}

			function nth(n) {
		return { type: 'nth-child', index: { type: 'literal', value: n } };
			}
			function nthLast(n) {
		return { type: 'nth-last-child', index: { type: 'literal', value: n } };
			}
			function strUnescape(s) {
		return s.replace(/\\(.)/g, function (match, ch) {
					switch (ch) {
			case 'a':
							return '\a';
			case 'b':
							return '\b';
			case 'f':
							return '\f';
			case 'n':
							return '\n';
			case 'r':
							return '\r';
			case 't':
							return '\t';
			case 'v':
							return '\v';
			default:
							return ch;
					}
		});
			}

			var result = parseFunctions[startRule]();
			if (result === null || pos !== input.length) {
		var offset = Math.max(pos, rightmostFailuresPos);
		var found = offset < input.length ? input.charAt(offset) : null;
		var errorPosition = computeErrorPosition();

		throw new this.SyntaxError(cleanupExpected(rightmostFailuresExpected), found, offset, errorPosition.line, errorPosition.column);
			}

			return result;
	},
	toSource: function toSource() {
			return this._source;
	}
  };

  result.SyntaxError = function (expected, found, offset, line, column) {
	function buildMessage(expected, found) {
			var expectedHumanized, foundHumanized;

			switch (expected.length) {
		case 0:
					expectedHumanized = "end of input";
					break;
		case 1:
					expectedHumanized = expected[0];
					break;
		default:
					expectedHumanized = expected.slice(0, expected.length - 1).join(", ") + " or " + expected[expected.length - 1];
			}

			foundHumanized = found ? quote(found) : "end of input";

			return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
	}

	this.name = "SyntaxError";
	this.expected = expected;
	this.found = found;
	this.message = buildMessage(expected, found);
	this.offset = offset;
	this.line = line;
	this.column = column;
  };

  result.SyntaxError.prototype = Error.prototype;

  return result;
}();
if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
	return result;
  }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else if (typeof module !== "undefined" && module.exports) {
  module.exports = result;
} else {
  undefined.esquery = result;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TokenStore = __webpack_require__(379),
	Traverser = __webpack_require__(106),
	astUtils = __webpack_require__(0),
	lodash = __webpack_require__(10);
function validate(ast) {
	if (!ast.tokens) {
		throw new Error("AST is missing the tokens array.");
	}

	if (!ast.comments) {
		throw new Error("AST is missing the comments array.");
	}

	if (!ast.loc) {
		throw new Error("AST is missing location information.");
	}

	if (!ast.range) {
		throw new Error("AST is missing range information");
	}
}
function looksLikeExport(astNode) {
	return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" || astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
}
function sortedMerge(tokens, comments) {
	var result = [];
	var tokenIndex = 0;
	var commentIndex = 0;

	while (tokenIndex < tokens.length || commentIndex < comments.length) {
		if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {
			result.push(tokens[tokenIndex++]);
		} else {
			result.push(comments[commentIndex++]);
		}
	}

	return result;
}
var SourceCode = function (_TokenStore) {
	_inherits(SourceCode, _TokenStore);
	function SourceCode(text, ast) {
		_classCallCheck(this, SourceCode);

		validate(ast);
		var _this = _possibleConstructorReturn(this, (SourceCode.__proto__ || Object.getPrototypeOf(SourceCode)).call(this, ast.tokens, ast.comments));

		_this.hasBOM = text.charCodeAt(0) === 0xFEFF;
		_this.text = _this.hasBOM ? text.slice(1) : text;
		_this.ast = ast;
		var shebangMatched = _this.text.match(astUtils.SHEBANG_MATCHER);
		var hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];

		if (hasShebang) {
			ast.comments[0].type = "Shebang";
		}

		_this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);
		_this.lines = [];
		_this.lineStartIndices = [0];

		var lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
		var match = void 0;
		while (match = lineEndingPattern.exec(_this.text)) {
			_this.lines.push(_this.text.slice(_this.lineStartIndices[_this.lineStartIndices.length - 1], match.index));
			_this.lineStartIndices.push(match.index + match[0].length);
		}
		_this.lines.push(_this.text.slice(_this.lineStartIndices[_this.lineStartIndices.length - 1]));
		_this._commentCache = new WeakMap();
		Object.freeze(_this);
		Object.freeze(_this.lines);
		return _this;
	}


	_createClass(SourceCode, [{
		key: "getText",
		value: function getText(node, beforeCount, afterCount) {
			if (node) {
				return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0), node.range[1] + (afterCount || 0));
			}
			return this.text;
		}

	}, {
		key: "getLines",
		value: function getLines() {
			return this.lines;
		}

	}, {
		key: "getAllComments",
		value: function getAllComments() {
			return this.ast.comments;
		}

	}, {
		key: "getComments",
		value: function getComments(node) {
			if (this._commentCache.has(node)) {
				return this._commentCache.get(node);
			}

			var comments = {
				leading: [],
				trailing: []
			};
			if (node.type === "Program") {
				if (node.body.length === 0) {
					comments.leading = node.comments;
				}
			} else {
				if ((node.type === "BlockStatement" || node.type === "ClassBody") && node.body.length === 0 || node.type === "ObjectExpression" && node.properties.length === 0 || node.type === "ArrayExpression" && node.elements.length === 0 || node.type === "SwitchStatement" && node.cases.length === 0) {
					comments.trailing = this.getTokens(node, {
						includeComments: true,
						filter: astUtils.isCommentToken
					});
				}
				var currentToken = this.getTokenBefore(node, { includeComments: true });

				while (currentToken && astUtils.isCommentToken(currentToken)) {
					if (node.parent && currentToken.start < node.parent.start) {
						break;
					}
					comments.leading.push(currentToken);
					currentToken = this.getTokenBefore(currentToken, { includeComments: true });
				}

				comments.leading.reverse();

				currentToken = this.getTokenAfter(node, { includeComments: true });

				while (currentToken && astUtils.isCommentToken(currentToken)) {
					if (node.parent && currentToken.end > node.parent.end) {
						break;
					}
					comments.trailing.push(currentToken);
					currentToken = this.getTokenAfter(currentToken, { includeComments: true });
				}
			}

			this._commentCache.set(node, comments);
			return comments;
		}

	}, {
		key: "getJSDocComment",
		value: function getJSDocComment(node) {
			var _this2 = this;
			var findJSDocComment = function findJSDocComment(astNode) {
				var tokenBefore = _this2.getTokenBefore(astNode, { includeComments: true });

				if (tokenBefore && astUtils.isCommentToken(tokenBefore) && tokenBefore.type === "Block" && tokenBefore.value.charAt(0) === "*" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {
					return tokenBefore;
				}

				return null;
			};
			var parent = node.parent;

			switch (node.type) {
				case "ClassDeclaration":
				case "FunctionDeclaration":
					return findJSDocComment(looksLikeExport(parent) ? parent : node);

				case "ClassExpression":
					return findJSDocComment(parent.parent);

				case "ArrowFunctionExpression":
				case "FunctionExpression":
					if (parent.type !== "CallExpression" && parent.type !== "NewExpression") {
						while (!this.getCommentsBefore(parent).length && !/Function/.test(parent.type) && parent.type !== "MethodDefinition" && parent.type !== "Property") {
							parent = parent.parent;

							if (!parent) {
								break;
							}
						}

						if (parent && parent.type !== "FunctionDeclaration" && parent.type !== "Program") {
							return findJSDocComment(parent);
						}
					}

					return findJSDocComment(node);
				default:
					return null;
			}
		}

	}, {
		key: "getNodeByRangeIndex",
		value: function getNodeByRangeIndex(index) {
			var result = null,
				resultParent = null;
			var traverser = new Traverser();

			traverser.traverse(this.ast, {
				enter: function enter(node, parent) {
					if (node.range[0] <= index && index < node.range[1]) {
						result = node;
						resultParent = parent;
					} else {
						this.skip();
					}
				},
				leave: function leave(node) {
					if (node === result) {
						this.break();
					}
				}
			});

			return result ? Object.assign({ parent: resultParent }, result) : null;
		}

	}, {
		key: "isSpaceBetweenTokens",
		value: function isSpaceBetweenTokens(first, second) {
			var text = this.text.slice(first.range[1], second.range[0]);

			return (/\s/.test(text.replace(/\/\*.*?\*\//g, ""))
			);
		}

	}, {
		key: "getLocFromIndex",
		value: function getLocFromIndex(index) {
			if (typeof index !== "number") {
				throw new TypeError("Expected `index` to be a number.");
			}

			if (index < 0 || index > this.text.length) {
				throw new RangeError("Index out of range (requested index " + index + ", but source text has length " + this.text.length + ").");
			}
			if (index === this.text.length) {
				return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };
			}
			var lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);

			return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };
		}

	}, {
		key: "getIndexFromLoc",
		value: function getIndexFromLoc(loc) {
			if ((typeof loc === "undefined" ? "undefined" : _typeof(loc)) !== "object" || typeof loc.line !== "number" || typeof loc.column !== "number") {
				throw new TypeError("Expected `loc` to be an object with numeric `line` and `column` properties.");
			}

			if (loc.line <= 0) {
				throw new RangeError("Line number out of range (line " + loc.line + " requested). Line numbers should be 1-based.");
			}

			if (loc.line > this.lineStartIndices.length) {
				throw new RangeError("Line number out of range (line " + loc.line + " requested, but only " + this.lineStartIndices.length + " lines present).");
			}

			var lineStartIndex = this.lineStartIndices[loc.line - 1];
			var lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];
			var positionIndex = lineStartIndex + loc.column;
			if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {
				throw new RangeError("Column number out of range (column " + loc.column + " requested, but the length of line " + loc.line + " is " + (lineEndIndex - lineStartIndex) + ").");
			}

			return positionIndex;
		}
	}], [{
		key: "splitLines",
		value: function splitLines(text) {
			return text.split(astUtils.createGlobalLinebreakMatcher());
		}
	}]);

	return SourceCode;
}(TokenStore);

module.exports = SourceCode;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cursors = __webpack_require__(380);
var ForwardTokenCursor = __webpack_require__(105);
var PaddedTokenCursor = __webpack_require__(387);
var utils = __webpack_require__(56);
var astUtils = __webpack_require__(0);
var TOKENS = Symbol("tokens");
var COMMENTS = Symbol("comments");
var INDEX_MAP = Symbol("indexMap");
function createIndexMap(tokens, comments) {
	var map = Object.create(null);
	var tokenIndex = 0;
	var commentIndex = 0;
	var nextStart = 0;
	var range = null;

	while (tokenIndex < tokens.length || commentIndex < comments.length) {
		nextStart = commentIndex < comments.length ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;
		while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {
			map[range[0]] = tokenIndex;
			map[range[1] - 1] = tokenIndex;
			tokenIndex += 1;
		}

		nextStart = tokenIndex < tokens.length ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;
		while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {
			map[range[0]] = tokenIndex;
			map[range[1] - 1] = tokenIndex;
			commentIndex += 1;
		}
	}

	return map;
}
function createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
	var includeComments = false;
	var skip = 0;
	var filter = null;

	if (typeof opts === "number") {
		skip = opts | 0;
	} else if (typeof opts === "function") {
		filter = opts;
	} else if (opts) {
		includeComments = !!opts.includeComments;
		skip = opts.skip | 0;
		filter = opts.filter || null;
	}


	return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);
}
function createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
	var includeComments = false;
	var count = 0;
	var countExists = false;
	var filter = null;

	if (typeof opts === "number") {
		count = opts | 0;
		countExists = true;
	} else if (typeof opts === "function") {
		filter = opts;
	} else if (opts) {
		includeComments = !!opts.includeComments;
		count = opts.count | 0;
		countExists = typeof opts.count === "number";
		filter = opts.filter || null;
	}


	return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);
}
function createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
	if (typeof beforeCount === "undefined" && typeof afterCount === "undefined") {
		return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);
	}
	if (typeof beforeCount === "number" || typeof beforeCount === "undefined") {
		return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);
	}
	return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);
}
function getAdjacentCommentTokensFromCursor(cursor) {
	var tokens = [];
	var currentToken = cursor.getOneToken();

	while (currentToken && astUtils.isCommentToken(currentToken)) {
		tokens.push(currentToken);
		currentToken = cursor.getOneToken();
	}

	return tokens;
}
module.exports = function () {
	function TokenStore(tokens, comments) {
		_classCallCheck(this, TokenStore);

		this[TOKENS] = tokens;
		this[COMMENTS] = comments;
		this[INDEX_MAP] = createIndexMap(tokens, comments);
	}


	_createClass(TokenStore, [{
		key: "getTokenByRangeStart",
		value: function getTokenByRangeStart(offset, options) {
			var includeComments = options && options.includeComments;
			var token = cursors.forward.createBaseCursor(this[TOKENS], this[COMMENTS], this[INDEX_MAP], offset, -1, includeComments).getOneToken();

			if (token && token.range[0] === offset) {
				return token;
			}
			return null;
		}

	}, {
		key: "getFirstToken",
		value: function getFirstToken(node, options) {
			return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();
		}

	}, {
		key: "getLastToken",
		value: function getLastToken(node, options) {
			return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();
		}

	}, {
		key: "getTokenBefore",
		value: function getTokenBefore(node, options) {
			return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getOneToken();
		}

	}, {
		key: "getTokenAfter",
		value: function getTokenAfter(node, options) {
			return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getOneToken();
		}

	}, {
		key: "getFirstTokenBetween",
		value: function getFirstTokenBetween(left, right, options) {
			return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();
		}

	}, {
		key: "getLastTokenBetween",
		value: function getLastTokenBetween(left, right, options) {
			return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();
		}

	}, {
		key: "getTokenOrCommentBefore",
		value: function getTokenOrCommentBefore(node, skip) {
			return this.getTokenBefore(node, { includeComments: true, skip: skip });
		}

	}, {
		key: "getTokenOrCommentAfter",
		value: function getTokenOrCommentAfter(node, skip) {
			return this.getTokenAfter(node, { includeComments: true, skip: skip });
		}

	}, {
		key: "getFirstTokens",
		value: function getFirstTokens(node, options) {
			return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens();
		}

	}, {
		key: "getLastTokens",
		value: function getLastTokens(node, options) {
			return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens().reverse();
		}

	}, {
		key: "getTokensBefore",
		value: function getTokensBefore(node, options) {
			return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getAllTokens().reverse();
		}

	}, {
		key: "getTokensAfter",
		value: function getTokensAfter(node, options) {
			return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getAllTokens();
		}

	}, {
		key: "getFirstTokensBetween",
		value: function getFirstTokensBetween(left, right, options) {
			return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens();
		}

	}, {
		key: "getLastTokensBetween",
		value: function getLastTokensBetween(left, right, options) {
			return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens().reverse();
		}

	}, {
		key: "getTokens",
		value: function getTokens(node, beforeCount, afterCount) {
			return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], beforeCount, afterCount).getAllTokens();
		}

	}, {
		key: "getTokensBetween",
		value: function getTokensBetween(left, right, padding) {
			return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], padding, padding).getAllTokens();
		}

	}, {
		key: "commentsExistBetween",
		value: function commentsExistBetween(left, right) {
			var index = utils.search(this[COMMENTS], left.range[1]);

			return index < this[COMMENTS].length && this[COMMENTS][index].range[1] <= right.range[0];
		}

	}, {
		key: "getCommentsBefore",
		value: function getCommentsBefore(nodeOrToken) {
			var cursor = createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, nodeOrToken.range[0], { includeComments: true });

			return getAdjacentCommentTokensFromCursor(cursor).reverse();
		}

	}, {
		key: "getCommentsAfter",
		value: function getCommentsAfter(nodeOrToken) {
			var cursor = createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], nodeOrToken.range[1], -1, { includeComments: true });

			return getAdjacentCommentTokensFromCursor(cursor);
		}

	}, {
		key: "getCommentsInside",
		value: function getCommentsInside(node) {
			return this.getTokens(node, {
				includeComments: true,
				filter: astUtils.isCommentToken
			});
		}
	}]);

	return TokenStore;
}();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BackwardTokenCommentCursor = __webpack_require__(381);
var BackwardTokenCursor = __webpack_require__(382);
var FilterCursor = __webpack_require__(383);
var ForwardTokenCommentCursor = __webpack_require__(384);
var ForwardTokenCursor = __webpack_require__(105);
var LimitCursor = __webpack_require__(385);
var SkipCursor = __webpack_require__(386);

var CursorFactory = function () {
	function CursorFactory(TokenCursor, TokenCommentCursor) {
		_classCallCheck(this, CursorFactory);

		this.TokenCursor = TokenCursor;
		this.TokenCommentCursor = TokenCommentCursor;
	}


	_createClass(CursorFactory, [{
		key: "createBaseCursor",
		value: function createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {
			var Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;

			return new Cursor(tokens, comments, indexMap, startLoc, endLoc);
		}

	}, {
		key: "createCursor",
		value: function createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {
			var cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);

			if (filter) {
				cursor = new FilterCursor(cursor, filter);
			}
			if (skip >= 1) {
				cursor = new SkipCursor(cursor, skip);
			}
			if (count >= 0) {
				cursor = new LimitCursor(cursor, count);
			}

			return cursor;
		}
	}]);

	return CursorFactory;
}();
exports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);
exports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cursor = __webpack_require__(55);
var utils = __webpack_require__(56);
module.exports = function (_Cursor) {
	_inherits(BackwardTokenCommentCursor, _Cursor);
	function BackwardTokenCommentCursor(tokens, comments, indexMap, startLoc, endLoc) {
		_classCallCheck(this, BackwardTokenCommentCursor);

		var _this = _possibleConstructorReturn(this, (BackwardTokenCommentCursor.__proto__ || Object.getPrototypeOf(BackwardTokenCommentCursor)).call(this));

		_this.tokens = tokens;
		_this.comments = comments;
		_this.tokenIndex = utils.getLastIndex(tokens, indexMap, endLoc);
		_this.commentIndex = utils.search(comments, endLoc) - 1;
		_this.border = startLoc;
		return _this;
	}


	_createClass(BackwardTokenCommentCursor, [{
		key: "moveNext",
		value: function moveNext() {
			var token = this.tokenIndex >= 0 ? this.tokens[this.tokenIndex] : null;
			var comment = this.commentIndex >= 0 ? this.comments[this.commentIndex] : null;

			if (token && (!comment || token.range[1] > comment.range[1])) {
				this.current = token;
				this.tokenIndex -= 1;
			} else if (comment) {
				this.current = comment;
				this.commentIndex -= 1;
			} else {
				this.current = null;
			}

			return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);
		}
	}]);

	return BackwardTokenCommentCursor;
}(Cursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cursor = __webpack_require__(55);
var utils = __webpack_require__(56);
module.exports = function (_Cursor) {
	_inherits(BackwardTokenCursor, _Cursor);
	function BackwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc) {
		_classCallCheck(this, BackwardTokenCursor);

		var _this = _possibleConstructorReturn(this, (BackwardTokenCursor.__proto__ || Object.getPrototypeOf(BackwardTokenCursor)).call(this));

		_this.tokens = tokens;
		_this.index = utils.getLastIndex(tokens, indexMap, endLoc);
		_this.indexEnd = utils.getFirstIndex(tokens, indexMap, startLoc);
		return _this;
	}


	_createClass(BackwardTokenCursor, [{
		key: "moveNext",
		value: function moveNext() {
			if (this.index >= this.indexEnd) {
				this.current = this.tokens[this.index];
				this.index -= 1;
				return true;
			}
			return false;
		}

	}, {
		key: "getOneToken",
		value: function getOneToken() {
			return this.index >= this.indexEnd ? this.tokens[this.index] : null;
		}
	}]);

	return BackwardTokenCursor;
}(Cursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DecorativeCursor = __webpack_require__(104);
module.exports = function (_DecorativeCursor) {
	_inherits(FilterCursor, _DecorativeCursor);
	function FilterCursor(cursor, predicate) {
		_classCallCheck(this, FilterCursor);

		var _this = _possibleConstructorReturn(this, (FilterCursor.__proto__ || Object.getPrototypeOf(FilterCursor)).call(this, cursor));

		_this.predicate = predicate;
		return _this;
	}


	_createClass(FilterCursor, [{
		key: "moveNext",
		value: function moveNext() {
			var predicate = this.predicate;

			while (_get(FilterCursor.prototype.__proto__ || Object.getPrototypeOf(FilterCursor.prototype), "moveNext", this).call(this)) {
				if (predicate(this.current)) {
					return true;
				}
			}
			return false;
		}
	}]);

	return FilterCursor;
}(DecorativeCursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cursor = __webpack_require__(55);
var utils = __webpack_require__(56);
module.exports = function (_Cursor) {
	_inherits(ForwardTokenCommentCursor, _Cursor);
	function ForwardTokenCommentCursor(tokens, comments, indexMap, startLoc, endLoc) {
		_classCallCheck(this, ForwardTokenCommentCursor);

		var _this = _possibleConstructorReturn(this, (ForwardTokenCommentCursor.__proto__ || Object.getPrototypeOf(ForwardTokenCommentCursor)).call(this));

		_this.tokens = tokens;
		_this.comments = comments;
		_this.tokenIndex = utils.getFirstIndex(tokens, indexMap, startLoc);
		_this.commentIndex = utils.search(comments, startLoc);
		_this.border = endLoc;
		return _this;
	}


	_createClass(ForwardTokenCommentCursor, [{
		key: "moveNext",
		value: function moveNext() {
			var token = this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex] : null;
			var comment = this.commentIndex < this.comments.length ? this.comments[this.commentIndex] : null;

			if (token && (!comment || token.range[0] < comment.range[0])) {
				this.current = token;
				this.tokenIndex += 1;
			} else if (comment) {
				this.current = comment;
				this.commentIndex += 1;
			} else {
				this.current = null;
			}

			return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);
		}
	}]);

	return ForwardTokenCommentCursor;
}(Cursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DecorativeCursor = __webpack_require__(104);
module.exports = function (_DecorativeCursor) {
	_inherits(LimitCursor, _DecorativeCursor);
	function LimitCursor(cursor, count) {
		_classCallCheck(this, LimitCursor);

		var _this = _possibleConstructorReturn(this, (LimitCursor.__proto__ || Object.getPrototypeOf(LimitCursor)).call(this, cursor));

		_this.count = count;
		return _this;
	}


	_createClass(LimitCursor, [{
		key: "moveNext",
		value: function moveNext() {
			if (this.count > 0) {
				this.count -= 1;
				return _get(LimitCursor.prototype.__proto__ || Object.getPrototypeOf(LimitCursor.prototype), "moveNext", this).call(this);
			}
			return false;
		}
	}]);

	return LimitCursor;
}(DecorativeCursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DecorativeCursor = __webpack_require__(104);
module.exports = function (_DecorativeCursor) {
	_inherits(SkipCursor, _DecorativeCursor);
	function SkipCursor(cursor, count) {
		_classCallCheck(this, SkipCursor);

		var _this = _possibleConstructorReturn(this, (SkipCursor.__proto__ || Object.getPrototypeOf(SkipCursor)).call(this, cursor));

		_this.count = count;
		return _this;
	}


	_createClass(SkipCursor, [{
		key: "moveNext",
		value: function moveNext() {
			while (this.count > 0) {
				this.count -= 1;
				if (!_get(SkipCursor.prototype.__proto__ || Object.getPrototypeOf(SkipCursor.prototype), "moveNext", this).call(this)) {
					return false;
				}
			}
			return _get(SkipCursor.prototype.__proto__ || Object.getPrototypeOf(SkipCursor.prototype), "moveNext", this).call(this);
		}
	}]);

	return SkipCursor;
}(DecorativeCursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ForwardTokenCursor = __webpack_require__(105);
module.exports = function (_ForwardTokenCursor) {
  _inherits(PaddedTokenCursor, _ForwardTokenCursor);
  function PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
	_classCallCheck(this, PaddedTokenCursor);

	var _this = _possibleConstructorReturn(this, (PaddedTokenCursor.__proto__ || Object.getPrototypeOf(PaddedTokenCursor)).call(this, tokens, comments, indexMap, startLoc, endLoc));

	_this.index = Math.max(0, _this.index - beforeCount);
	_this.indexEnd = Math.min(tokens.length - 1, _this.indexEnd + afterCount);
	return _this;
  }

  return PaddedTokenCursor;
}(ForwardTokenCursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var ruleFixer = __webpack_require__(389);
function normalizeMultiArgReportCall() {
	if (arguments.length === 1) {
		return arguments[0];
	}
	if (typeof arguments[1] === "string") {
		return {
			node: arguments[0],
			message: arguments[1],
			data: arguments[2],
			fix: arguments[3]
		};
	}
	return {
		node: arguments[0],
		loc: arguments[1],
		message: arguments[2],
		data: arguments[3],
		fix: arguments[4]
	};
}
function assertValidNodeInfo(descriptor) {
	if (descriptor.node) {} else {}
}
function normalizeReportLoc(descriptor) {
	if (descriptor.loc) {
		if (descriptor.loc.start) {
			return descriptor.loc;
		}
		return { start: descriptor.loc, end: null };
	}
	return descriptor.node.loc;
}
function normalizeMessagePlaceholders(descriptor) {
	if (!descriptor.data) {
		return descriptor.message;
	}
	return descriptor.message.replace(/\{\{\s*([^{}]+?)\s*\}\}/g, function (fullMatch, term) {
		if (term in descriptor.data) {
			return descriptor.data[term];
		}

		return fullMatch;
	});
}
function compareFixesByRange(a, b) {
	return a.range[0] - b.range[0] || a.range[1] - b.range[1];
}
function mergeFixes(fixes, sourceCode) {
	if (fixes.length === 0) {
		return null;
	}
	if (fixes.length === 1) {
		return fixes[0];
	}

	fixes.sort(compareFixesByRange);

	var originalText = sourceCode.text;
	var start = fixes[0].range[0];
	var end = fixes[fixes.length - 1].range[1];
	var text = "";
	var lastPos = Number.MIN_SAFE_INTEGER;

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = fixes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var fix = _step.value;


			if (fix.range[0] >= 0) {
				text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);
			}
			text += fix.text;
			lastPos = fix.range[1];
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	text += originalText.slice(Math.max(0, start, lastPos), end);

	return { range: [start, end], text: text };
}
function normalizeFixes(descriptor, sourceCode) {
	if (typeof descriptor.fix !== "function") {
		return null;
	}
	var fix = descriptor.fix(ruleFixer);
	if (fix && Symbol.iterator in fix) {
		return mergeFixes(Array.from(fix), sourceCode);
	}
	return fix;
}
function createProblem(options) {
	var problem = {
		ruleId: options.ruleId,
		severity: options.severity,
		message: options.message,
		line: options.loc.start.line,
		column: options.loc.start.column + 1,
		nodeType: options.node && options.node.type || null,
		source: options.sourceLines[options.loc.start.line - 1] || ""
	};

	if (options.loc.end) {
		problem.endLine = options.loc.end.line;
		problem.endColumn = options.loc.end.column + 1;
	}

	if (options.fix) {
		problem.fix = options.fix;
	}

	return problem;
}

module.exports = function createReportTranslator(metadata) {
	return function () {
		var descriptor = normalizeMultiArgReportCall.apply(null, arguments);

		assertValidNodeInfo(descriptor);

		return createProblem({
			ruleId: metadata.ruleId,
			severity: metadata.severity,
			node: descriptor.node,
			message: normalizeMessagePlaceholders(descriptor),
			loc: normalizeReportLoc(descriptor),
			fix: normalizeFixes(descriptor, metadata.sourceCode),
			sourceLines: metadata.sourceCode.lines
		});
	};
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function insertTextAt(index, text) {
	return {
		range: [index, index],
		text: text
	};
}

var ruleFixer = Object.freeze({
	insertTextAfter: function insertTextAfter(nodeOrToken, text) {
		return this.insertTextAfterRange(nodeOrToken.range, text);
	},
	insertTextAfterRange: function insertTextAfterRange(range, text) {
		return insertTextAt(range[1], text);
	},
	insertTextBefore: function insertTextBefore(nodeOrToken, text) {
		return this.insertTextBeforeRange(nodeOrToken.range, text);
	},
	insertTextBeforeRange: function insertTextBeforeRange(range, text) {
		return insertTextAt(range[0], text);
	},
	replaceText: function replaceText(nodeOrToken, text) {
		return this.replaceTextRange(nodeOrToken.range, text);
	},
	replaceTextRange: function replaceTextRange(range, text) {
		return {
			range: range,
			text: text
		};
	},
	remove: function remove(nodeOrToken) {
		return this.removeRange(nodeOrToken.range);
	},
	removeRange: function removeRange(range) {
		return {
			range: range,
			text: ""
		};
	}
});

module.exports = ruleFixer;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var lodash = __webpack_require__(10);
var loadRules = __webpack_require__(391);
var ruleReplacements = __webpack_require__(752).rules;
var createMissingRule = lodash.memoize(function (ruleId) {
	var message = Object.prototype.hasOwnProperty.call(ruleReplacements, ruleId) ? "Rule '" + ruleId + "' was removed and replaced by: " + ruleReplacements[ruleId].join(", ") : "Definition for rule '" + ruleId + "' was not found";

	return {
		create: function create(context) {
			return {
				Program: function Program() {
					context.report({
						loc: { line: 1, column: 0 },
						message: message
					});
				}
			};
		}
	};
});
function normalizeRule(rule) {
	return typeof rule === "function" ? Object.assign({ create: rule }, rule) : rule;
}
var Rules = function () {
	function Rules() {
		_classCallCheck(this, Rules);

		this._rules = Object.create(null);

		this.load();
	}


	_createClass(Rules, [{
		key: "define",
		value: function define(ruleId, ruleModule) {
			this._rules[ruleId] = normalizeRule(ruleModule);
		}

	}, {
		key: "load",
		value: function load(rulesDir, cwd) {
			var _this = this;

			var newRules = loadRules(rulesDir, cwd);

			Object.keys(newRules).forEach(function (ruleId) {
				_this.define(ruleId, newRules[ruleId]);
			});
		}

	}, {
		key: "importPlugin",
		value: function importPlugin(plugin, pluginName) {
			var _this2 = this;

			if (plugin.rules) {
				Object.keys(plugin.rules).forEach(function (ruleId) {
					var qualifiedRuleId = pluginName + "/" + ruleId,
						rule = plugin.rules[ruleId];

					_this2.define(qualifiedRuleId, rule);
				});
			}
		}

	}, {
		key: "get",
		value: function get(ruleId) {
			if (!Object.prototype.hasOwnProperty.call(this._rules, ruleId)) {
				return createMissingRule(ruleId);
			}
			if (typeof this._rules[ruleId] === "string") {
				return normalizeRule(!(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
			}
			return this._rules[ruleId];
		}

	}, {
		key: "getAllLoadedRules",
		value: function getAllLoadedRules() {
			var _this3 = this;

			var allRules = new Map();

			Object.keys(this._rules).forEach(function (name) {
				var rule = _this3.get(name);

				allRules.set(name, rule);
			});
			return allRules;
		}
	}]);

	return Rules;
}();

module.exports = Rules;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var rules = { "accessor-pairs": __webpack_require__(392),
		"array-bracket-newline": __webpack_require__(393),
		"array-bracket-spacing": __webpack_require__(394),
		"array-callback-return": __webpack_require__(395),
		"array-element-newline": __webpack_require__(396),
		"arrow-body-style": __webpack_require__(397),
		"arrow-parens": __webpack_require__(398),
		"arrow-spacing": __webpack_require__(399),
		"block-scoped-var": __webpack_require__(400),
		"block-spacing": __webpack_require__(401),
		"brace-style": __webpack_require__(402),
		"callback-return": __webpack_require__(403),
		"camelcase": __webpack_require__(404),
		"capitalized-comments": __webpack_require__(405),
		"class-methods-use-this": __webpack_require__(407),
		"comma-dangle": __webpack_require__(408),
		"comma-spacing": __webpack_require__(409),
		"comma-style": __webpack_require__(410),
		"complexity": __webpack_require__(411),
		"computed-property-spacing": __webpack_require__(412),
		"consistent-return": __webpack_require__(413),
		"consistent-this": __webpack_require__(414),
		"constructor-super": __webpack_require__(415),
		"curly": __webpack_require__(416),
		"default-case": __webpack_require__(417),
		"dot-location": __webpack_require__(418),
		"dot-notation": __webpack_require__(419),
		"eol-last": __webpack_require__(420),
		"eqeqeq": __webpack_require__(421),
		"for-direction": __webpack_require__(422),
		"func-call-spacing": __webpack_require__(423),
		"func-name-matching": __webpack_require__(424),
		"func-names": __webpack_require__(425),
		"func-style": __webpack_require__(426),
		"function-paren-newline": __webpack_require__(427),
		"generator-star-spacing": __webpack_require__(428),
		"getter-return": __webpack_require__(429),
		"global-require": __webpack_require__(430),
		"guard-for-in": __webpack_require__(431),
		"handle-callback-err": __webpack_require__(432),
		"id-blacklist": __webpack_require__(433),
		"id-length": __webpack_require__(434),
		"id-match": __webpack_require__(435),
		"implicit-arrow-linebreak": __webpack_require__(436),
		"indent-legacy": __webpack_require__(437),
		"indent": __webpack_require__(438),
		"init-declarations": __webpack_require__(440),
		"jsx-quotes": __webpack_require__(441),
		"key-spacing": __webpack_require__(442),
		"keyword-spacing": __webpack_require__(443),
		"line-comment-position": __webpack_require__(444),
		"linebreak-style": __webpack_require__(445),
		"lines-around-comment": __webpack_require__(446),
		"lines-around-directive": __webpack_require__(447),
		"lines-between-class-members": __webpack_require__(448),
		"max-depth": __webpack_require__(449),
		"max-len": __webpack_require__(450),
		"max-lines": __webpack_require__(451),
		"max-nested-callbacks": __webpack_require__(452),
		"max-params": __webpack_require__(453),
		"max-statements-per-line": __webpack_require__(454),
		"max-statements": __webpack_require__(455),
		"multiline-comment-style": __webpack_require__(456),
		"multiline-ternary": __webpack_require__(457),
		"new-cap": __webpack_require__(458),
		"new-parens": __webpack_require__(459),
		"newline-after-var": __webpack_require__(460),
		"newline-before-return": __webpack_require__(461),
		"newline-per-chained-call": __webpack_require__(462),
		"no-alert": __webpack_require__(463),
		"no-array-constructor": __webpack_require__(464),
		"no-await-in-loop": __webpack_require__(465),
		"no-bitwise": __webpack_require__(466),
		"no-buffer-constructor": __webpack_require__(467),
		"no-caller": __webpack_require__(468),
		"no-case-declarations": __webpack_require__(469),
		"no-catch-shadow": __webpack_require__(470),
		"no-class-assign": __webpack_require__(471),
		"no-compare-neg-zero": __webpack_require__(472),
		"no-cond-assign": __webpack_require__(473),
		"no-confusing-arrow": __webpack_require__(474),
		"no-console": __webpack_require__(475),
		"no-const-assign": __webpack_require__(476),
		"no-constant-condition": __webpack_require__(477),
		"no-continue": __webpack_require__(478),
		"no-control-regex": __webpack_require__(479),
		"no-debugger": __webpack_require__(480),
		"no-delete-var": __webpack_require__(481),
		"no-div-regex": __webpack_require__(482),
		"no-dupe-args": __webpack_require__(483),
		"no-dupe-class-members": __webpack_require__(484),
		"no-dupe-keys": __webpack_require__(485),
		"no-duplicate-case": __webpack_require__(486),
		"no-duplicate-imports": __webpack_require__(487),
		"no-else-return": __webpack_require__(488),
		"no-empty-character-class": __webpack_require__(489),
		"no-empty-function": __webpack_require__(490),
		"no-empty-pattern": __webpack_require__(491),
		"no-empty": __webpack_require__(492),
		"no-eq-null": __webpack_require__(493),
		"no-eval": __webpack_require__(494),
		"no-ex-assign": __webpack_require__(495),
		"no-extend-native": __webpack_require__(496),
		"no-extra-bind": __webpack_require__(497),
		"no-extra-boolean-cast": __webpack_require__(498),
		"no-extra-label": __webpack_require__(499),
		"no-extra-parens": __webpack_require__(500),
		"no-extra-semi": __webpack_require__(501),
		"no-fallthrough": __webpack_require__(502),
		"no-floating-decimal": __webpack_require__(503),
		"no-func-assign": __webpack_require__(504),
		"no-global-assign": __webpack_require__(505),
		"no-implicit-coercion": __webpack_require__(506),
		"no-implicit-globals": __webpack_require__(507),
		"no-implied-eval": __webpack_require__(508),
		"no-inline-comments": __webpack_require__(509),
		"no-inner-declarations": __webpack_require__(510),
		"no-invalid-regexp": __webpack_require__(511),
		"no-invalid-this": __webpack_require__(512),
		"no-irregular-whitespace": __webpack_require__(513),
		"no-iterator": __webpack_require__(514),
		"no-label-var": __webpack_require__(515),
		"no-labels": __webpack_require__(516),
		"no-lone-blocks": __webpack_require__(517),
		"no-lonely-if": __webpack_require__(518),
		"no-loop-func": __webpack_require__(519),
		"no-magic-numbers": __webpack_require__(520),
		"no-mixed-operators": __webpack_require__(521),
		"no-mixed-requires": __webpack_require__(522),
		"no-mixed-spaces-and-tabs": __webpack_require__(523),
		"no-multi-assign": __webpack_require__(524),
		"no-multi-spaces": __webpack_require__(525),
		"no-multi-str": __webpack_require__(526),
		"no-multiple-empty-lines": __webpack_require__(527),
		"no-native-reassign": __webpack_require__(528),
		"no-negated-condition": __webpack_require__(529),
		"no-negated-in-lhs": __webpack_require__(530),
		"no-nested-ternary": __webpack_require__(531),
		"no-new-func": __webpack_require__(532),
		"no-new-object": __webpack_require__(533),
		"no-new-require": __webpack_require__(534),
		"no-new-symbol": __webpack_require__(535),
		"no-new-wrappers": __webpack_require__(536),
		"no-new": __webpack_require__(537),
		"no-obj-calls": __webpack_require__(538),
		"no-octal-escape": __webpack_require__(539),
		"no-octal": __webpack_require__(540),
		"no-param-reassign": __webpack_require__(541),
		"no-path-concat": __webpack_require__(542),
		"no-plusplus": __webpack_require__(543),
		"no-process-env": __webpack_require__(544),
		"no-process-exit": __webpack_require__(545),
		"no-proto": __webpack_require__(546),
		"no-prototype-builtins": __webpack_require__(547),
		"no-redeclare": __webpack_require__(548),
		"no-regex-spaces": __webpack_require__(549),
		"no-restricted-globals": __webpack_require__(550),
		"no-restricted-imports": __webpack_require__(551),
		"no-restricted-modules": __webpack_require__(552),
		"no-restricted-properties": __webpack_require__(553),
		"no-restricted-syntax": __webpack_require__(554),
		"no-return-assign": __webpack_require__(555),
		"no-return-await": __webpack_require__(556),
		"no-script-url": __webpack_require__(557),
		"no-self-assign": __webpack_require__(558),
		"no-self-compare": __webpack_require__(559),
		"no-sequences": __webpack_require__(560),
		"no-shadow-restricted-names": __webpack_require__(561),
		"no-shadow": __webpack_require__(562),
		"no-spaced-func": __webpack_require__(563),
		"no-sparse-arrays": __webpack_require__(564),
		"no-sync": __webpack_require__(565),
		"no-tabs": __webpack_require__(566),
		"no-template-curly-in-string": __webpack_require__(567),
		"no-ternary": __webpack_require__(568),
		"no-this-before-super": __webpack_require__(569),
		"no-throw-literal": __webpack_require__(570),
		"no-trailing-spaces": __webpack_require__(571),
		"no-undef-init": __webpack_require__(572),
		"no-undef": __webpack_require__(573),
		"no-undefined": __webpack_require__(574),
		"no-underscore-dangle": __webpack_require__(575),
		"no-unexpected-multiline": __webpack_require__(576),
		"no-unmodified-loop-condition": __webpack_require__(577),
		"no-unneeded-ternary": __webpack_require__(578),
		"no-unreachable": __webpack_require__(579),
		"no-unsafe-finally": __webpack_require__(580),
		"no-unsafe-negation": __webpack_require__(581),
		"no-unused-expressions": __webpack_require__(582),
		"no-unused-labels": __webpack_require__(583),
		"no-unused-vars": __webpack_require__(584),
		"no-use-before-define": __webpack_require__(585),
		"no-useless-call": __webpack_require__(586),
		"no-useless-computed-key": __webpack_require__(587),
		"no-useless-concat": __webpack_require__(588),
		"no-useless-constructor": __webpack_require__(589),
		"no-useless-escape": __webpack_require__(590),
		"no-useless-rename": __webpack_require__(591),
		"no-useless-return": __webpack_require__(592),
		"no-var": __webpack_require__(593),
		"no-void": __webpack_require__(594),
		"no-warning-comments": __webpack_require__(595),
		"no-whitespace-before-property": __webpack_require__(596),
		"no-with": __webpack_require__(597),
		"nonblock-statement-body-position": __webpack_require__(598),
		"object-curly-newline": __webpack_require__(599),
		"object-curly-spacing": __webpack_require__(600),
		"object-property-newline": __webpack_require__(601),
		"object-shorthand": __webpack_require__(602),
		"one-var-declaration-per-line": __webpack_require__(603),
		"one-var": __webpack_require__(604),
		"operator-assignment": __webpack_require__(605),
		"operator-linebreak": __webpack_require__(606),
		"padded-blocks": __webpack_require__(607),
		"padding-line-between-statements": __webpack_require__(608),
		"prefer-arrow-callback": __webpack_require__(609),
		"prefer-const": __webpack_require__(610),
		"prefer-destructuring": __webpack_require__(611),
		"prefer-numeric-literals": __webpack_require__(612),
		"prefer-promise-reject-errors": __webpack_require__(613),
		"prefer-reflect": __webpack_require__(614),
		"prefer-rest-params": __webpack_require__(615),
		"prefer-spread": __webpack_require__(616),
		"prefer-template": __webpack_require__(617),
		"quote-props": __webpack_require__(618),
		"quotes": __webpack_require__(619),
		"radix": __webpack_require__(620),
		"require-await": __webpack_require__(621),
		"require-jsdoc": __webpack_require__(622),
		"require-yield": __webpack_require__(623),
		"rest-spread-spacing": __webpack_require__(624),
		"semi-spacing": __webpack_require__(625),
		"semi-style": __webpack_require__(626),
		"semi": __webpack_require__(627),
		"sort-imports": __webpack_require__(628),
		"sort-keys": __webpack_require__(629),
		"sort-vars": __webpack_require__(631),
		"space-before-blocks": __webpack_require__(632),
		"space-before-function-paren": __webpack_require__(633),
		"space-in-parens": __webpack_require__(634),
		"space-infix-ops": __webpack_require__(635),
		"space-unary-ops": __webpack_require__(636),
		"spaced-comment": __webpack_require__(637),
		"strict": __webpack_require__(638),
		"switch-colon-spacing": __webpack_require__(639),
		"symbol-description": __webpack_require__(640),
		"template-curly-spacing": __webpack_require__(641),
		"template-tag-spacing": __webpack_require__(642),
		"unicode-bom": __webpack_require__(643),
		"use-isnan": __webpack_require__(644),
		"valid-jsdoc": __webpack_require__(645),
		"valid-typeof": __webpack_require__(651),
		"vars-on-top": __webpack_require__(652),
		"wrap-iife": __webpack_require__(653),
		"wrap-regex": __webpack_require__(654),
		"yield-star-spacing": __webpack_require__(655),
		"yoda": __webpack_require__(656)
	};

	var jsxRules = __webpack_require__(657).rules;
	Object.keys(jsxRules).forEach(function (key) {
		rules["react/" + key] = jsxRules[key];
	});
	return rules;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isIdentifier(node, name) {
	return node.type === "Identifier" && node.name === name;
}
function isArgumentOfMethodCall(node, index, object, property) {
	var parent = node.parent;

	return parent.type === "CallExpression" && parent.callee.type === "MemberExpression" && parent.callee.computed === false && isIdentifier(parent.callee.object, object) && isIdentifier(parent.callee.property, property) && parent.arguments[index] === node;
}
function isPropertyDescriptor(node) {
	if (isArgumentOfMethodCall(node, 2, "Object", "defineProperty") || isArgumentOfMethodCall(node, 2, "Reflect", "defineProperty")) {
		return true;
	}
	node = node.parent.parent;

	return node.type === "ObjectExpression" && (isArgumentOfMethodCall(node, 1, "Object", "create") || isArgumentOfMethodCall(node, 1, "Object", "defineProperties"));
}
module.exports = {
	meta: {
		docs: {
			description: "enforce getter and setter pairs in objects",
			category: "Best Practices",
			recommended: false
		},
		schema: [{
			type: "object",
			properties: {
				getWithoutSet: {
					type: "boolean"
				},
				setWithoutGet: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},
	create: function create(context) {
		var config = context.options[0] || {};
		var checkGetWithoutSet = config.getWithoutSet === true;
		var checkSetWithoutGet = config.setWithoutGet !== false;
		function checkLonelySetGet(node) {
			var isSetPresent = false;
			var isGetPresent = false;
			var isDescriptor = isPropertyDescriptor(node);

			for (var i = 0, end = node.properties.length; i < end; i++) {
				var property = node.properties[i];

				var propToCheck = "";

				if (property.kind === "init") {
					if (isDescriptor && !property.computed) {
						propToCheck = property.key.name;
					}
				} else {
					propToCheck = property.kind;
				}

				switch (propToCheck) {
					case "set":
						isSetPresent = true;
						break;

					case "get":
						isGetPresent = true;
						break;

					default:
				}

				if (isSetPresent && isGetPresent) {
					break;
				}
			}

			if (checkSetWithoutGet && isSetPresent && !isGetPresent) {
				context.report({ node: node, message: "Getter is not present." });
			} else if (checkGetWithoutSet && isGetPresent && !isSetPresent) {
				context.report({ node: node, message: "Setter is not present." });
			}
		}

		return {
			ObjectExpression: function ObjectExpression(node) {
				if (checkSetWithoutGet || checkGetWithoutSet) {
					checkLonelySetGet(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce linebreaks after opening and before closing array brackets",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			oneOf: [{
				enum: ["always", "never", "consistent"]
			}, {
				type: "object",
				properties: {
					multiline: {
						type: "boolean"
					},
					minItems: {
						type: ["integer", "null"],
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function normalizeOptionValue(option) {
			var consistent = false;
			var multiline = false;
			var minItems = 0;

			if (option) {
				if (option === "consistent") {
					consistent = true;
					minItems = Number.POSITIVE_INFINITY;
				} else if (option === "always" || option.minItems === 0) {
					minItems = 0;
				} else if (option === "never") {
					minItems = Number.POSITIVE_INFINITY;
				} else {
					multiline = Boolean(option.multiline);
					minItems = option.minItems || Number.POSITIVE_INFINITY;
				}
			} else {
				consistent = false;
				multiline = true;
				minItems = Number.POSITIVE_INFINITY;
			}

			return { consistent: consistent, multiline: multiline, minItems: minItems };
		}
		function normalizeOptions(options) {
			var value = normalizeOptionValue(options);

			return { ArrayExpression: value, ArrayPattern: value };
		}
		function reportNoBeginningLinebreak(node, token) {
			context.report({
				node: node,
				loc: token.loc,
				message: "There should be no linebreak after '['.",
				fix: function fix(fixer) {
					var nextToken = sourceCode.getTokenAfter(token, { includeComments: true });

					if (astUtils.isCommentToken(nextToken)) {
						return null;
					}

					return fixer.removeRange([token.range[1], nextToken.range[0]]);
				}
			});
		}
		function reportNoEndingLinebreak(node, token) {
			context.report({
				node: node,
				loc: token.loc,
				message: "There should be no linebreak before ']'.",
				fix: function fix(fixer) {
					var previousToken = sourceCode.getTokenBefore(token, { includeComments: true });

					if (astUtils.isCommentToken(previousToken)) {
						return null;
					}

					return fixer.removeRange([previousToken.range[1], token.range[0]]);
				}
			});
		}
		function reportRequiredBeginningLinebreak(node, token) {
			context.report({
				node: node,
				loc: token.loc,
				message: "A linebreak is required after '['.",
				fix: function fix(fixer) {
					return fixer.insertTextAfter(token, "\n");
				}
			});
		}
		function reportRequiredEndingLinebreak(node, token) {
			context.report({
				node: node,
				loc: token.loc,
				message: "A linebreak is required before ']'.",
				fix: function fix(fixer) {
					return fixer.insertTextBefore(token, "\n");
				}
			});
		}
		function check(node) {
			var elements = node.elements;
			var normalizedOptions = normalizeOptions(context.options[0]);
			var options = normalizedOptions[node.type];
			var openBracket = sourceCode.getFirstToken(node);
			var closeBracket = sourceCode.getLastToken(node);
			var firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });
			var lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });
			var first = sourceCode.getTokenAfter(openBracket);
			var last = sourceCode.getTokenBefore(closeBracket);

			var needsLinebreaks = elements.length >= options.minItems || options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line || elements.length === 0 && firstIncComment.type === "Block" && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment || options.consistent && firstIncComment.loc.start.line !== openBracket.loc.end.line;

			if (needsLinebreaks) {
				if (astUtils.isTokenOnSameLine(openBracket, first)) {
					reportRequiredBeginningLinebreak(node, openBracket);
				}
				if (astUtils.isTokenOnSameLine(last, closeBracket)) {
					reportRequiredEndingLinebreak(node, closeBracket);
				}
			} else {
				if (!astUtils.isTokenOnSameLine(openBracket, first)) {
					reportNoBeginningLinebreak(node, openBracket);
				}
				if (!astUtils.isTokenOnSameLine(last, closeBracket)) {
					reportNoEndingLinebreak(node, closeBracket);
				}
			}
		}
		return {
			ArrayPattern: check,
			ArrayExpression: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing inside array brackets",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			enum: ["always", "never"]
		}, {
			type: "object",
			properties: {
				singleValue: {
					type: "boolean"
				},
				objectsInArrays: {
					type: "boolean"
				},
				arraysInArrays: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},
	create: function create(context) {
		var spaced = context.options[0] === "always",
			sourceCode = context.getSourceCode();
		function isOptionSet(option) {
			return context.options[1] ? context.options[1][option] === !spaced : false;
		}

		var options = {
			spaced: spaced,
			singleElementException: isOptionSet("singleValue"),
			objectsInArraysException: isOptionSet("objectsInArrays"),
			arraysInArraysException: isOptionSet("arraysInArrays")
		};
		function reportNoBeginningSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "There should be no space after '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					var nextToken = sourceCode.getTokenAfter(token);

					return fixer.removeRange([token.range[1], nextToken.range[0]]);
				}
			});
		}
		function reportNoEndingSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "There should be no space before '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					var previousToken = sourceCode.getTokenBefore(token);

					return fixer.removeRange([previousToken.range[1], token.range[0]]);
				}
			});
		}
		function reportRequiredBeginningSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "A space is required after '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					return fixer.insertTextAfter(token, " ");
				}
			});
		}
		function reportRequiredEndingSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "A space is required before '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					return fixer.insertTextBefore(token, " ");
				}
			});
		}
		function isObjectType(node) {
			return node && (node.type === "ObjectExpression" || node.type === "ObjectPattern");
		}
		function isArrayType(node) {
			return node && (node.type === "ArrayExpression" || node.type === "ArrayPattern");
		}
		function validateArraySpacing(node) {
			if (options.spaced && node.elements.length === 0) {
				return;
			}

			var first = sourceCode.getFirstToken(node),
				second = sourceCode.getFirstToken(node, 1),
				last = node.typeAnnotation ? sourceCode.getTokenBefore(node.typeAnnotation) : sourceCode.getLastToken(node),
				penultimate = sourceCode.getTokenBefore(last),
				firstElement = node.elements[0],
				lastElement = node.elements[node.elements.length - 1];

			var openingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(firstElement) || options.arraysInArraysException && isArrayType(firstElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;

			var closingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(lastElement) || options.arraysInArraysException && isArrayType(lastElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;

			if (astUtils.isTokenOnSameLine(first, second)) {
				if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {
					reportRequiredBeginningSpace(node, first);
				}
				if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {
					reportNoBeginningSpace(node, first);
				}
			}

			if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {
				if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {
					reportRequiredEndingSpace(node, last);
				}
				if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {
					reportNoEndingSpace(node, last);
				}
			}
		}
		return {
			ArrayPattern: validateArraySpacing,
			ArrayExpression: validateArraySpacing
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10);

var astUtils = __webpack_require__(0);
var TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;
var TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/;
function isReachable(segment) {
	return segment.reachable;
}
function getLocation(node, sourceCode) {
	if (node.type === "ArrowFunctionExpression") {
		return sourceCode.getTokenBefore(node.body);
	}
	return node.id || node;
}
function isTargetMethod(node) {
	return node.type === "MemberExpression" && TARGET_METHODS.test(astUtils.getStaticPropertyName(node) || "");
}
function isCallbackOfArrayMethod(node) {
	while (node) {
		var parent = node.parent;

		switch (parent.type) {
			case "LogicalExpression":
			case "ConditionalExpression":
				node = parent;
				break;
			case "ReturnStatement":
				{
					var func = astUtils.getUpperFunction(parent);

					if (func === null || !astUtils.isCallee(func)) {
						return false;
					}
					node = func.parent;
					break;
				}
			case "CallExpression":
				if (astUtils.isArrayFromMethod(parent.callee)) {
					return parent.arguments.length >= 2 && parent.arguments[1] === node;
				}
				if (isTargetMethod(parent.callee)) {
					return parent.arguments.length >= 1 && parent.arguments[0] === node;
				}
				return false;
			default:
				return false;
		}
	}
	return false;
}
module.exports = {
	meta: {
		docs: {
			description: "enforce `return` statements in callbacks of array methods",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var funcInfo = {
			upper: null,
			codePath: null,
			hasReturn: false,
			shouldCheck: false,
			node: null
		};
		function checkLastSegment(node) {
			if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {
				context.report({
					node: node,
					loc: getLocation(node, context.getSourceCode()).loc.start,
					message: funcInfo.hasReturn ? "Expected to return a value at the end of {{name}}." : "Expected to return a value in {{name}}.",
					data: {
						name: astUtils.getFunctionNameWithKind(funcInfo.node)
					}
				});
			}
		}

		return {
			onCodePathStart: function onCodePathStart(codePath, node) {
				funcInfo = {
					upper: funcInfo,
					codePath: codePath,
					hasReturn: false,
					shouldCheck: TARGET_NODE_TYPE.test(node.type) && node.body.type === "BlockStatement" && isCallbackOfArrayMethod(node) && !node.async && !node.generator,
					node: node
				};
			},
			onCodePathEnd: function onCodePathEnd() {
				funcInfo = funcInfo.upper;
			},
			ReturnStatement: function ReturnStatement(node) {
				if (funcInfo.shouldCheck) {
					funcInfo.hasReturn = true;

					if (!node.argument) {
						context.report({
							node: node,
							message: "{{name}} expected a return value.",
							data: {
								name: lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))
							}
						});
					}
				}
			},
			"FunctionExpression:exit": checkLastSegment,
			"ArrowFunctionExpression:exit": checkLastSegment
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce line breaks after each array element",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			oneOf: [{
				enum: ["always", "never"]
			}, {
				type: "object",
				properties: {
					multiline: {
						type: "boolean"
					},
					minItems: {
						type: ["integer", "null"],
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function normalizeOptionValue(option) {
			var multiline = false;
			var minItems = void 0;

			option = option || "always";

			if (option === "always" || option.minItems === 0) {
				minItems = 0;
			} else if (option === "never") {
				minItems = Number.POSITIVE_INFINITY;
			} else {
				multiline = Boolean(option.multiline);
				minItems = option.minItems || Number.POSITIVE_INFINITY;
			}

			return { multiline: multiline, minItems: minItems };
		}
		function normalizeOptions(options) {
			var value = normalizeOptionValue(options);

			return { ArrayExpression: value, ArrayPattern: value };
		}
		function reportNoLineBreak(token) {
			var tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });

			context.report({
				loc: {
					start: tokenBefore.loc.end,
					end: token.loc.start
				},
				message: "There should be no linebreak here.",
				fix: function fix(fixer) {
					if (astUtils.isCommentToken(tokenBefore)) {
						return null;
					}

					if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {
						return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ");
					}
					var twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });

					if (astUtils.isCommentToken(twoTokensBefore)) {
						return null;
					}

					return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], "");
				}
			});
		}
		function reportRequiredLineBreak(token) {
			var tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });

			context.report({
				loc: {
					start: tokenBefore.loc.end,
					end: token.loc.start
				},
				message: "There should be a linebreak after this element.",
				fix: function fix(fixer) {
					return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n");
				}
			});
		}
		function check(node) {
			var elements = node.elements;
			var normalizedOptions = normalizeOptions(context.options[0]);
			var options = normalizedOptions[node.type];

			var elementBreak = false;
			if (options.multiline) {
				elementBreak = elements.filter(function (element) {
					return element !== null;
				}).some(function (element) {
					return element.loc.start.line !== element.loc.end.line;
				});
			}

			var needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak;

			elements.forEach(function (element, i) {
				var previousElement = elements[i - 1];

				if (i === 0 || element === null || previousElement === null) {
					return;
				}

				var commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
				var lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
				var firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);

				if (needsLinebreaks) {
					if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
						reportRequiredLineBreak(firstTokenOfCurrentElement);
					}
				} else {
					if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
						reportNoLineBreak(firstTokenOfCurrentElement);
					}
				}
			});
		}
		return {
			ArrayPattern: check,
			ArrayExpression: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require braces around arrow function bodies",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["always", "never"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["as-needed"]
				}, {
					type: "object",
					properties: {
						requireReturnForObjectLiteral: { type: "boolean" }
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		},

		fixable: "code"
	},

	create: function create(context) {
		var options = context.options;
		var always = options[0] === "always";
		var asNeeded = !options[0] || options[0] === "as-needed";
		var never = options[0] === "never";
		var requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;
		var sourceCode = context.getSourceCode();
		function hasASIProblem(token) {
			return token && token.type === "Punctuator" && /^[([/`+-]/.test(token.value);
		}
		function findClosingParen(token) {
			var node = sourceCode.getNodeByRangeIndex(token.range[1]);

			while (!astUtils.isParenthesised(sourceCode, node)) {
				node = node.parent;
			}
			return sourceCode.getTokenAfter(node);
		}
		function validate(node) {
			var arrowBody = node.body;

			if (arrowBody.type === "BlockStatement") {
				var blockBody = arrowBody.body;

				if (blockBody.length !== 1 && !never) {
					return;
				}

				if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === "ReturnStatement" && blockBody[0].argument && blockBody[0].argument.type === "ObjectExpression") {
					return;
				}

				if (never || asNeeded && blockBody[0].type === "ReturnStatement") {
					context.report({
						node: node,
						loc: arrowBody.loc.start,
						message: "Unexpected block statement surrounding arrow body.",
						fix: function fix(fixer) {
							var fixes = [];

							if (blockBody.length !== 1 || blockBody[0].type !== "ReturnStatement" || !blockBody[0].argument || hasASIProblem(sourceCode.getTokenAfter(arrowBody))) {
								return fixes;
							}

							var openingBrace = sourceCode.getFirstToken(arrowBody);
							var closingBrace = sourceCode.getLastToken(arrowBody);
							var firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);
							var lastValueToken = sourceCode.getLastToken(blockBody[0]);
							var commentsExist = sourceCode.commentsExistBetween(openingBrace, firstValueToken) || sourceCode.commentsExistBetween(lastValueToken, closingBrace);
							if (commentsExist) {
								fixes.push(fixer.remove(openingBrace), fixer.remove(closingBrace), fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword
								);
							} else {
								fixes.push(fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]), fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]]));
							}
							if (astUtils.isOpeningBraceToken(firstValueToken)) {
								fixes.push(fixer.insertTextBefore(firstValueToken, "("), fixer.insertTextAfter(lastValueToken, ")"));
							}
							if (astUtils.isSemicolonToken(lastValueToken)) {
								fixes.push(fixer.remove(lastValueToken));
							}

							return fixes;
						}
					});
				}
			} else {
				if (always || asNeeded && requireReturnForObjectLiteral && arrowBody.type === "ObjectExpression") {
					context.report({
						node: node,
						loc: arrowBody.loc.start,
						message: "Expected block statement surrounding arrow body.",
						fix: function fix(fixer) {
							var fixes = [];
							var arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);
							var firstBodyToken = sourceCode.getTokenAfter(arrowToken);
							var lastBodyToken = sourceCode.getLastToken(node);
							var isParenthesisedObjectLiteral = astUtils.isOpeningParenToken(firstBodyToken) && astUtils.isOpeningBraceToken(sourceCode.getTokenAfter(firstBodyToken));
							fixes.push(fixer.insertTextBefore(firstBodyToken, "{return "), fixer.insertTextAfter(lastBodyToken, "}"));
							if (isParenthesisedObjectLiteral) {
								fixes.push(fixer.remove(firstBodyToken), fixer.remove(findClosingParen(firstBodyToken)));
							}

							return fixes;
						}
					});
				}
			}
		}

		return {
			"ArrowFunctionExpression:exit": validate
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require parentheses around arrow function arguments",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "code",

		schema: [{
			enum: ["always", "as-needed"]
		}, {
			type: "object",
			properties: {
				requireForBlockBody: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var message = "Expected parentheses around arrow function argument.";
		var asNeededMessage = "Unexpected parentheses around single function argument.";
		var asNeeded = context.options[0] === "as-needed";
		var requireForBlockBodyMessage = "Unexpected parentheses around single function argument having a body with no curly braces";
		var requireForBlockBodyNoParensMessage = "Expected parentheses around arrow function argument having a body with curly braces.";
		var requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;

		var sourceCode = context.getSourceCode();
		function parens(node) {
			var isAsync = node.async;
			var firstTokenOfParam = sourceCode.getFirstToken(node, isAsync ? 1 : 0);
			function fixParamsWithParenthesis(fixer) {
				var paramToken = sourceCode.getTokenAfter(firstTokenOfParam);
				var closingParenToken = sourceCode.getTokenAfter(paramToken, astUtils.isClosingParenToken);
				var asyncToken = isAsync ? sourceCode.getTokenBefore(firstTokenOfParam) : null;
				var shouldAddSpaceForAsync = asyncToken && asyncToken.range[1] === firstTokenOfParam.range[0];

				return fixer.replaceTextRange([firstTokenOfParam.range[0], closingParenToken.range[1]], "" + (shouldAddSpaceForAsync ? " " : "") + paramToken.value);
			}
			if (requireForBlockBody && node.params.length === 1 && node.params[0].type === "Identifier" && !node.params[0].typeAnnotation && node.body.type !== "BlockStatement" && !node.returnType) {
				if (astUtils.isOpeningParenToken(firstTokenOfParam)) {
					context.report({
						node: node,
						message: requireForBlockBodyMessage,
						fix: fixParamsWithParenthesis
					});
				}
				return;
			}

			if (requireForBlockBody && node.body.type === "BlockStatement") {
				if (!astUtils.isOpeningParenToken(firstTokenOfParam)) {
					context.report({
						node: node,
						message: requireForBlockBodyNoParensMessage,
						fix: function fix(fixer) {
							return fixer.replaceText(firstTokenOfParam, "(" + firstTokenOfParam.value + ")");
						}
					});
				}
				return;
			}
			if (asNeeded && node.params.length === 1 && node.params[0].type === "Identifier" && !node.params[0].typeAnnotation && !node.returnType) {
				if (astUtils.isOpeningParenToken(firstTokenOfParam)) {
					context.report({
						node: node,
						message: asNeededMessage,
						fix: fixParamsWithParenthesis
					});
				}
				return;
			}

			if (firstTokenOfParam.type === "Identifier") {
				var after = sourceCode.getTokenAfter(firstTokenOfParam);
				if (after.value !== ")") {
					context.report({
						node: node,
						message: message,
						fix: function fix(fixer) {
							return fixer.replaceText(firstTokenOfParam, "(" + firstTokenOfParam.value + ")");
						}
					});
				}
			}
		}

		return {
			ArrowFunctionExpression: parens
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before and after the arrow in arrow functions",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				before: {
					type: "boolean"
				},
				after: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var rule = { before: true, after: true },
			option = context.options[0] || {};

		rule.before = option.before !== false;
		rule.after = option.after !== false;

		var sourceCode = context.getSourceCode();
		function getTokens(node) {
			var arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);

			return {
				before: sourceCode.getTokenBefore(arrow),
				arrow: arrow,
				after: sourceCode.getTokenAfter(arrow)
			};
		}
		function countSpaces(tokens) {
			var before = tokens.arrow.range[0] - tokens.before.range[1];
			var after = tokens.after.range[0] - tokens.arrow.range[1];

			return { before: before, after: after };
		}
		function spaces(node) {
			var tokens = getTokens(node);
			var countSpace = countSpaces(tokens);

			if (rule.before) {
				if (countSpace.before === 0) {
					context.report({
						node: tokens.before,
						message: "Missing space before =>.",
						fix: function fix(fixer) {
							return fixer.insertTextBefore(tokens.arrow, " ");
						}
					});
				}
			} else {
				if (countSpace.before > 0) {
					context.report({
						node: tokens.before,
						message: "Unexpected space before =>.",
						fix: function fix(fixer) {
							return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);
						}
					});
				}
			}

			if (rule.after) {
				if (countSpace.after === 0) {
					context.report({
						node: tokens.after,
						message: "Missing space after =>.",
						fix: function fix(fixer) {
							return fixer.insertTextAfter(tokens.arrow, " ");
						}
					});
				}
			} else {
				if (countSpace.after > 0) {
					context.report({
						node: tokens.after,
						message: "Unexpected space after =>.",
						fix: function fix(fixer) {
							return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);
						}
					});
				}
			}
		}

		return {
			ArrowFunctionExpression: spaces
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce the use of variables within the scope they are defined",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var stack = [];
		function enterScope(node) {
			stack.push(node.range);
		}
		function exitScope() {
			stack.pop();
		}
		function report(reference) {
			var identifier = reference.identifier;

			context.report({ node: identifier, message: "'{{name}}' used outside of binding context.", data: { name: identifier.name } });
		}
		function checkForVariables(node) {
			if (node.kind !== "var") {
				return;
			}
			var scopeRange = stack[stack.length - 1];
			function isOutsideOfScope(reference) {
				var idRange = reference.identifier.range;

				return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
			}
			var variables = context.getDeclaredVariables(node);

			for (var i = 0; i < variables.length; ++i) {
				variables[i].references.filter(isOutsideOfScope).forEach(report);
			}
		}

		return {
			Program: function Program(node) {
				stack = [node.range];
			},
			BlockStatement: enterScope,
			"BlockStatement:exit": exitScope,
			ForStatement: enterScope,
			"ForStatement:exit": exitScope,
			ForInStatement: enterScope,
			"ForInStatement:exit": exitScope,
			ForOfStatement: enterScope,
			"ForOfStatement:exit": exitScope,
			SwitchStatement: enterScope,
			"SwitchStatement:exit": exitScope,
			CatchClause: enterScope,
			"CatchClause:exit": exitScope,
			VariableDeclaration: checkForVariables
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var util = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow or enforce spaces inside of blocks after opening block and before closing block",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{ enum: ["always", "never"] }]
	},

	create: function create(context) {
		var always = context.options[0] !== "never",
			message = always ? "Requires a space" : "Unexpected space(s)",
			sourceCode = context.getSourceCode();
		function getOpenBrace(node) {
			if (node.type === "SwitchStatement") {
				if (node.cases.length > 0) {
					return sourceCode.getTokenBefore(node.cases[0]);
				}
				return sourceCode.getLastToken(node, 1);
			}
			return sourceCode.getFirstToken(node);
		}
		function isValid(left, right) {
			return !util.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === always;
		}
		function checkSpacingInsideBraces(node) {
			var openBrace = getOpenBrace(node);
			var closeBrace = sourceCode.getLastToken(node);
			var firstToken = sourceCode.getTokenAfter(openBrace, { includeComments: true });
			var lastToken = sourceCode.getTokenBefore(closeBrace, { includeComments: true });
			if (openBrace.type !== "Punctuator" || openBrace.value !== "{" || closeBrace.type !== "Punctuator" || closeBrace.value !== "}" || firstToken === closeBrace) {
				return;
			}
			if (!always && firstToken.type === "Line") {
				return;
			}
			if (!isValid(openBrace, firstToken)) {
				context.report({
					node: node,
					loc: openBrace.loc.start,
					message: "{{message}} after '{'.",
					data: {
						message: message
					},
					fix: function fix(fixer) {
						if (always) {
							return fixer.insertTextBefore(firstToken, " ");
						}

						return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
					}
				});
			}
			if (!isValid(lastToken, closeBrace)) {
				context.report({
					node: node,
					loc: closeBrace.loc.start,
					message: "{{message}} before '}'.",
					data: {
						message: message
					},
					fix: function fix(fixer) {
						if (always) {
							return fixer.insertTextAfter(lastToken, " ");
						}

						return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
					}
				});
			}
		}

		return {
			BlockStatement: checkSpacingInsideBraces,
			SwitchStatement: checkSpacingInsideBraces
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent brace style for blocks",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			enum: ["1tbs", "stroustrup", "allman"]
		}, {
			type: "object",
			properties: {
				allowSingleLine: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "whitespace"
	},

	create: function create(context) {
		var style = context.options[0] || "1tbs",
			params = context.options[1] || {},
			sourceCode = context.getSourceCode();

		var OPEN_MESSAGE = "Opening curly brace does not appear on the same line as controlling statement.",
			OPEN_MESSAGE_ALLMAN = "Opening curly brace appears on the same line as controlling statement.",
			BODY_MESSAGE = "Statement inside of curly braces should be on next line.",
			CLOSE_MESSAGE = "Closing curly brace does not appear on the same line as the subsequent block.",
			CLOSE_MESSAGE_SINGLE = "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
			CLOSE_MESSAGE_STROUSTRUP_ALLMAN = "Closing curly brace appears on the same line as the subsequent block.";
		function removeNewlineBetween(firstToken, secondToken) {
			var textRange = [firstToken.range[1], secondToken.range[0]];
			var textBetween = sourceCode.text.slice(textRange[0], textRange[1]);
			if (textBetween.trim()) {
				return null;
			}
			return function (fixer) {
				return fixer.replaceTextRange(textRange, " ");
			};
		}
		function validateCurlyPair(openingCurly, closingCurly) {
			var tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);
			var tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);
			var tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);
			var singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);

			if (style !== "allman" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {
				context.report({
					node: openingCurly,
					message: OPEN_MESSAGE,
					fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)
				});
			}

			if (style === "allman" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {
				context.report({
					node: openingCurly,
					message: OPEN_MESSAGE_ALLMAN,
					fix: function fix(fixer) {
						return fixer.insertTextBefore(openingCurly, "\n");
					}
				});
			}

			if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {
				context.report({
					node: openingCurly,
					message: BODY_MESSAGE,
					fix: function fix(fixer) {
						return fixer.insertTextAfter(openingCurly, "\n");
					}
				});
			}

			if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {
				context.report({
					node: closingCurly,
					message: CLOSE_MESSAGE_SINGLE,
					fix: function fix(fixer) {
						return fixer.insertTextBefore(closingCurly, "\n");
					}
				});
			}
		}
		function validateCurlyBeforeKeyword(curlyToken) {
			var keywordToken = sourceCode.getTokenAfter(curlyToken);

			if (style === "1tbs" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
				context.report({
					node: curlyToken,
					message: CLOSE_MESSAGE,
					fix: removeNewlineBetween(curlyToken, keywordToken)
				});
			}

			if (style !== "1tbs" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
				context.report({
					node: curlyToken,
					message: CLOSE_MESSAGE_STROUSTRUP_ALLMAN,
					fix: function fix(fixer) {
						return fixer.insertTextAfter(curlyToken, "\n");
					}
				});
			}
		}
		return {
			BlockStatement: function BlockStatement(node) {
				if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
					validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
				}
			},
			ClassBody: function ClassBody(node) {
				validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
			},
			SwitchStatement: function SwitchStatement(node) {
				var closingCurly = sourceCode.getLastToken(node);
				var openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);

				validateCurlyPair(openingCurly, closingCurly);
			},
			IfStatement: function IfStatement(node) {
				if (node.consequent.type === "BlockStatement" && node.alternate) {
					validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));
				}
			},
			TryStatement: function TryStatement(node) {
				validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));

				if (node.handler && node.finalizer) {
					validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require `return` statements after callbacks",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: [{
			type: "array",
			items: { type: "string" }
		}]
	},

	create: function create(context) {

		var callbacks = context.options[0] || ["callback", "cb", "next"],
			sourceCode = context.getSourceCode();
		function findClosestParentOfType(node, types) {
			if (!node.parent) {
				return null;
			}
			if (types.indexOf(node.parent.type) === -1) {
				return findClosestParentOfType(node.parent, types);
			}
			return node.parent;
		}
		function containsOnlyIdentifiers(node) {
			if (node.type === "Identifier") {
				return true;
			}

			if (node.type === "MemberExpression") {
				if (node.object.type === "Identifier") {
					return true;
				}
				if (node.object.type === "MemberExpression") {
					return containsOnlyIdentifiers(node.object);
				}
			}

			return false;
		}
		function isCallback(node) {
			return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;
		}
		function isCallbackExpression(node, parentNode) {
			if (!parentNode || parentNode.type !== "ExpressionStatement") {
				return false;
			}
			if (parentNode.expression === node) {
				return true;
			}
			if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") {
				if (parentNode.expression.right === node) {
					return true;
				}
			}

			return false;
		}
		return {
			CallExpression: function CallExpression(node) {
				if (!isCallback(node)) {
					return;
				}
				var closestBlock = findClosestParentOfType(node, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {};
				if (closestBlock.type === "ReturnStatement") {
					return;
				}
				if (closestBlock.type === "ArrowFunctionExpression") {
					return;
				}
				if (closestBlock.type === "BlockStatement") {
					var lastItem = closestBlock.body[closestBlock.body.length - 1];
					if (isCallbackExpression(node, lastItem)) {

						var parentType = closestBlock.parent.type;
						if (parentType === "FunctionExpression" || parentType === "FunctionDeclaration" || parentType === "ArrowFunctionExpression") {
							return;
						}
					}
					if (lastItem.type === "ReturnStatement") {
						if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {
							return;
						}
					}
				}
				if (findClosestParentOfType(node, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"])) {
					context.report({ node: node, message: "Expected return with your callback function." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce camelcase naming convention",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				properties: {
					enum: ["always", "never"]
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var reported = [];
		var ALLOWED_PARENT_TYPES = new Set(["CallExpression", "NewExpression"]);
		function isUnderscored(name) {
			return name.indexOf("_") > -1 && name !== name.toUpperCase();
		}
		function report(node) {
			if (reported.indexOf(node) < 0) {
				reported.push(node);
				context.report({ node: node, message: "Identifier '{{name}}' is not in camel case.", data: { name: node.name } });
			}
		}

		var options = context.options[0] || {};
		var properties = options.properties || "";

		if (properties !== "always" && properties !== "never") {
			properties = "always";
		}

		return {
			Identifier: function Identifier(node) {
				var name = node.name.replace(/^_+|_+$/g, ""),
					effectiveParent = node.parent.type === "MemberExpression" ? node.parent.parent : node.parent;
				if (node.parent.type === "MemberExpression") {
					if (properties === "never") {
						return;
					}
					if (node.parent.object.type === "Identifier" && node.parent.object.name === node.name && isUnderscored(name)) {
						report(node);
					} else if (effectiveParent.type === "AssignmentExpression" && isUnderscored(name) && (effectiveParent.right.type !== "MemberExpression" || effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name)) {
						report(node);
					}
				} else if (node.parent.type === "Property" || node.parent.type === "AssignmentPattern") {

					if (node.parent.parent && node.parent.parent.type === "ObjectPattern") {

						if (node.parent.shorthand && node.parent.value.left && isUnderscored(name)) {

							report(node);
						}
						if (node.parent.key === node && node.parent.value !== node) {
							return;
						}

						if (node.parent.value.name && isUnderscored(name)) {
							report(node);
						}
					}
					if (properties === "never") {
						return;
					}
					if (isUnderscored(name) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) {
						report(node);
					}
				} else if (["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"].indexOf(node.parent.type) >= 0) {
					if (node.parent.local && node.parent.local.name === node.name && isUnderscored(name)) {
						report(node);
					}
				} else if (isUnderscored(name) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {
					report(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var LETTER_PATTERN = __webpack_require__(406);
var astUtils = __webpack_require__(0);
var ALWAYS_MESSAGE = "Comments should not begin with a lowercase character",
	NEVER_MESSAGE = "Comments should not begin with an uppercase character",
	DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,
	WHITESPACE = /\s/g,
	MAYBE_URL = /^\s*[^:/?#\s]+:\/\/[^?#]/,
DEFAULTS = {
	ignorePattern: null,
	ignoreInlineComments: false,
	ignoreConsecutiveComments: false
};
var SCHEMA_BODY = {
	type: "object",
	properties: {
		ignorePattern: {
			type: "string"
		},
		ignoreInlineComments: {
			type: "boolean"
		},
		ignoreConsecutiveComments: {
			type: "boolean"
		}
	},
	additionalProperties: false
};
function getNormalizedOptions(rawOptions, which) {
	if (!rawOptions) {
		return Object.assign({}, DEFAULTS);
	}

	return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);
}
function getAllNormalizedOptions(rawOptions) {
	return {
		Line: getNormalizedOptions(rawOptions, "line"),
		Block: getNormalizedOptions(rawOptions, "block")
	};
}
function createRegExpForIgnorePatterns(normalizedOptions) {
	Object.keys(normalizedOptions).forEach(function (key) {
		var ignorePatternStr = normalizedOptions[key].ignorePattern;

		if (ignorePatternStr) {
			var regExp = RegExp("^\\s*(?:" + ignorePatternStr + ")");

			normalizedOptions[key].ignorePatternRegExp = regExp;
		}
	});
}
module.exports = {
	meta: {
		docs: {
			description: "enforce or disallow capitalization of the first letter of a comment",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "code",
		schema: [{ enum: ["always", "never"] }, {
			oneOf: [SCHEMA_BODY, {
				type: "object",
				properties: {
					line: SCHEMA_BODY,
					block: SCHEMA_BODY
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {

		var capitalize = context.options[0] || "always",
			normalizedOptions = getAllNormalizedOptions(context.options[1]),
			sourceCode = context.getSourceCode();

		createRegExpForIgnorePatterns(normalizedOptions);
		function isInlineComment(comment) {
			var previousToken = sourceCode.getTokenBefore(comment, { includeComments: true }),
				nextToken = sourceCode.getTokenAfter(comment, { includeComments: true });

			return Boolean(previousToken && nextToken && comment.loc.start.line === previousToken.loc.end.line && comment.loc.end.line === nextToken.loc.start.line);
		}
		function isConsecutiveComment(comment) {
			var previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });

			return Boolean(previousTokenOrComment && ["Block", "Line"].indexOf(previousTokenOrComment.type) !== -1);
		}
		function isCommentValid(comment, options) {
			if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {
				return true;
			}
			var commentWithoutAsterisks = comment.value.replace(/\*/g, "");

			if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {
				return true;
			}
			if (options.ignoreInlineComments && isInlineComment(comment)) {
				return true;
			}
			if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {
				return true;
			}
			if (MAYBE_URL.test(commentWithoutAsterisks)) {
				return true;
			}
			var commentWordCharsOnly = commentWithoutAsterisks.replace(WHITESPACE, "");

			if (commentWordCharsOnly.length === 0) {
				return true;
			}

			var firstWordChar = commentWordCharsOnly[0];

			if (!LETTER_PATTERN.test(firstWordChar)) {
				return true;
			}
			var isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),
				isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();

			if (capitalize === "always" && isLowercase) {
				return false;
			}
			if (capitalize === "never" && isUppercase) {
				return false;
			}

			return true;
		}
		function processComment(comment) {
			var options = normalizedOptions[comment.type],
				commentValid = isCommentValid(comment, options);

			if (!commentValid) {
				var message = capitalize === "always" ? ALWAYS_MESSAGE : NEVER_MESSAGE;

				context.report({
					node: null, // Intentionally using loc instead
					loc: comment.loc,
					message: message,
					fix: function fix(fixer) {
						var match = comment.value.match(LETTER_PATTERN);

						return fixer.replaceTextRange(
						[comment.range[0] + match.index + 2, comment.range[0] + match.index + 3], capitalize === "always" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase());
					}
				});
			}
		}
		return {
			Program: function Program() {
				var comments = sourceCode.getAllComments();

				comments.filter(function (token) {
					return token.type !== "Shebang";
				}).forEach(processComment);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



module.exports = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce that class methods utilize `this`",
			category: "Best Practices",
			recommended: false
		},
		schema: [{
			type: "object",
			properties: {
				exceptMethods: {
					type: "array",
					items: {
						type: "string"
					}
				}
			},
			additionalProperties: false
		}]
	},
	create: function create(context) {
		var config = context.options[0] ? Object.assign({}, context.options[0]) : {};
		var exceptMethods = new Set(config.exceptMethods || []);

		var stack = [];
		function enterFunction() {
			stack.push(false);
		}
		function isInstanceMethod(node) {
			return !node.static && node.kind !== "constructor" && node.type === "MethodDefinition";
		}
		function isIncludedInstanceMethod(node) {
			return isInstanceMethod(node) && !exceptMethods.has(node.key.name);
		}
		function exitFunction(node) {
			var methodUsesThis = stack.pop();

			if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {
				context.report({
					node: node,
					message: "Expected 'this' to be used by class method '{{classMethod}}'.",
					data: {
						classMethod: node.parent.key.name
					}
				});
			}
		}
		function markThisUsed() {
			if (stack.length) {
				stack[stack.length - 1] = true;
			}
		}

		return {
			FunctionDeclaration: enterFunction,
			"FunctionDeclaration:exit": exitFunction,
			FunctionExpression: enterFunction,
			"FunctionExpression:exit": exitFunction,
			ThisExpression: markThisUsed,
			Super: markThisUsed
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var lodash = __webpack_require__(10);
var astUtils = __webpack_require__(0);
var DEFAULT_OPTIONS = Object.freeze({
	arrays: "never",
	objects: "never",
	imports: "never",
	exports: "never",
	functions: "ignore"
});
function isTrailingCommaAllowed(lastItem) {
	return !(lastItem.type === "RestElement" || lastItem.type === "RestProperty" || lastItem.type === "ExperimentalRestProperty");
}
function normalizeOptions(optionValue) {
	if (typeof optionValue === "string") {
		return {
			arrays: optionValue,
			objects: optionValue,
			imports: optionValue,
			exports: optionValue,
			functions: "ignore"
		};
	}
	if ((typeof optionValue === "undefined" ? "undefined" : _typeof(optionValue)) === "object" && optionValue !== null) {
		return {
			arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,
			objects: optionValue.objects || DEFAULT_OPTIONS.objects,
			imports: optionValue.imports || DEFAULT_OPTIONS.imports,
			exports: optionValue.exports || DEFAULT_OPTIONS.exports,
			functions: optionValue.functions || DEFAULT_OPTIONS.functions
		};
	}

	return DEFAULT_OPTIONS;
}
module.exports = {
	meta: {
		docs: {
			description: "require or disallow trailing commas",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "code",
		schema: {
			definitions: {
				value: {
					enum: ["always-multiline", "always", "never", "only-multiline"]
				},
				valueWithIgnore: {
					enum: ["always-multiline", "always", "ignore", "never", "only-multiline"]
				}
			},
			type: "array",
			items: [{
				oneOf: [{
					$ref: "#/definitions/value"
				}, {
					type: "object",
					properties: {
						arrays: { $ref: "#/definitions/valueWithIgnore" },
						objects: { $ref: "#/definitions/valueWithIgnore" },
						imports: { $ref: "#/definitions/valueWithIgnore" },
						exports: { $ref: "#/definitions/valueWithIgnore" },
						functions: { $ref: "#/definitions/valueWithIgnore" }
					},
					additionalProperties: false
				}]
			}]
		}
	},

	create: function create(context) {
		var options = normalizeOptions(context.options[0]);
		var sourceCode = context.getSourceCode();
		var UNEXPECTED_MESSAGE = "Unexpected trailing comma.";
		var MISSING_MESSAGE = "Missing trailing comma.";
		function getLastItem(node) {
			switch (node.type) {
				case "ObjectExpression":
				case "ObjectPattern":
					return lodash.last(node.properties);
				case "ArrayExpression":
				case "ArrayPattern":
					return lodash.last(node.elements);
				case "ImportDeclaration":
				case "ExportNamedDeclaration":
					return lodash.last(node.specifiers);
				case "FunctionDeclaration":
				case "FunctionExpression":
				case "ArrowFunctionExpression":
					return lodash.last(node.params);
				case "CallExpression":
				case "NewExpression":
					return lodash.last(node.arguments);
				default:
					return null;
			}
		}
		function getTrailingToken(node, lastItem) {
			switch (node.type) {
				case "ObjectExpression":
				case "ArrayExpression":
				case "CallExpression":
				case "NewExpression":
					return sourceCode.getLastToken(node, 1);
				default:
					{
						var nextToken = sourceCode.getTokenAfter(lastItem);

						if (astUtils.isCommaToken(nextToken)) {
							return nextToken;
						}
						return sourceCode.getLastToken(lastItem);
					}
			}
		}
		function isMultiline(node) {
			var lastItem = getLastItem(node);

			if (!lastItem) {
				return false;
			}

			var penultimateToken = getTrailingToken(node, lastItem);
			var lastToken = sourceCode.getTokenAfter(penultimateToken);

			return lastToken.loc.end.line !== penultimateToken.loc.end.line;
		}
		function forbidTrailingComma(node) {
			var lastItem = getLastItem(node);

			if (!lastItem || node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
				return;
			}

			var trailingToken = getTrailingToken(node, lastItem);

			if (astUtils.isCommaToken(trailingToken)) {
				context.report({
					node: lastItem,
					loc: trailingToken.loc.start,
					message: UNEXPECTED_MESSAGE,
					fix: function fix(fixer) {
						return fixer.remove(trailingToken);
					}
				});
			}
		}
		function forceTrailingComma(node) {
			var lastItem = getLastItem(node);

			if (!lastItem || node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
				return;
			}
			if (!isTrailingCommaAllowed(lastItem)) {
				forbidTrailingComma(node);
				return;
			}

			var trailingToken = getTrailingToken(node, lastItem);

			if (trailingToken.value !== ",") {
				context.report({
					node: lastItem,
					loc: trailingToken.loc.end,
					message: MISSING_MESSAGE,
					fix: function fix(fixer) {
						return fixer.insertTextAfter(trailingToken, ",");
					}
				});
			}
		}
		function forceTrailingCommaIfMultiline(node) {
			if (isMultiline(node)) {
				forceTrailingComma(node);
			} else {
				forbidTrailingComma(node);
			}
		}
		function allowTrailingCommaIfMultiline(node) {
			if (!isMultiline(node)) {
				forbidTrailingComma(node);
			}
		}

		var predicate = {
			always: forceTrailingComma,
			"always-multiline": forceTrailingCommaIfMultiline,
			"only-multiline": allowTrailingCommaIfMultiline,
			never: forbidTrailingComma,
			ignore: lodash.noop
		};

		return {
			ObjectExpression: predicate[options.objects],
			ObjectPattern: predicate[options.objects],

			ArrayExpression: predicate[options.arrays],
			ArrayPattern: predicate[options.arrays],

			ImportDeclaration: predicate[options.imports],

			ExportNamedDeclaration: predicate[options.exports],

			FunctionDeclaration: predicate[options.functions],
			FunctionExpression: predicate[options.functions],
			ArrowFunctionExpression: predicate[options.functions],
			CallExpression: predicate[options.functions],
			NewExpression: predicate[options.functions]
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before and after commas",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				before: {
					type: "boolean"
				},
				after: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode();
		var tokensAndComments = sourceCode.tokensAndComments;

		var options = {
			before: context.options[0] ? !!context.options[0].before : false,
			after: context.options[0] ? !!context.options[0].after : true
		};
		var commaTokensToIgnore = [];
		function report(node, dir, otherNode) {
			context.report({
				node: node,
				fix: function fix(fixer) {
					if (options[dir]) {
						if (dir === "before") {
							return fixer.insertTextBefore(node, " ");
						}
						return fixer.insertTextAfter(node, " ");
					}
					var start = void 0,
						end = void 0;
					var newText = "";

					if (dir === "before") {
						start = otherNode.range[1];
						end = node.range[0];
					} else {
						start = node.range[1];
						end = otherNode.range[0];
					}

					return fixer.replaceTextRange([start, end], newText);
				},

				message: options[dir] ? "A space is required {{dir}} ','." : "There should be no space {{dir}} ','.",
				data: {
					dir: dir
				}
			});
		}
		function validateCommaItemSpacing(tokens, reportItem) {
			if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) && options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma)) {
				report(reportItem, "before", tokens.left);
			}

			if (tokens.right && !options.after && tokens.right.type === "Line") {
				return;
			}

			if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) && options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right)) {
				report(reportItem, "after", tokens.right);
			}
		}
		function addNullElementsToIgnoreList(node) {
			var previousToken = sourceCode.getFirstToken(node);

			node.elements.forEach(function (element) {
				var token = void 0;

				if (element === null) {
					token = sourceCode.getTokenAfter(previousToken);

					if (astUtils.isCommaToken(token)) {
						commaTokensToIgnore.push(token);
					}
				} else {
					token = sourceCode.getTokenAfter(element);
				}

				previousToken = token;
			});
		}
		return {
			"Program:exit": function ProgramExit() {
				tokensAndComments.forEach(function (token, i) {

					if (!astUtils.isCommaToken(token)) {
						return;
					}

					if (token && token.type === "JSXText") {
						return;
					}

					var previousToken = tokensAndComments[i - 1];
					var nextToken = tokensAndComments[i + 1];

					validateCommaItemSpacing({
						comma: token,
						left: astUtils.isCommaToken(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,
						right: astUtils.isCommaToken(nextToken) ? null : nextToken
					}, token);
				});
			},

			ArrayExpression: addNullElementsToIgnoreList,
			ArrayPattern: addNullElementsToIgnoreList

		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent comma style",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "code",
		schema: [{
			enum: ["first", "last"]
		}, {
			type: "object",
			properties: {
				exceptions: {
					type: "object",
					additionalProperties: {
						type: "boolean"
					}
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var style = context.options[0] || "last",
			sourceCode = context.getSourceCode();
		var exceptions = {
			ArrayPattern: true,
			ArrowFunctionExpression: true,
			CallExpression: true,
			FunctionDeclaration: true,
			FunctionExpression: true,
			ImportDeclaration: true,
			ObjectPattern: true
		};

		if (context.options.length === 2 && context.options[1].hasOwnProperty("exceptions")) {
			var keys = Object.keys(context.options[1].exceptions);

			for (var i = 0; i < keys.length; i++) {
				exceptions[keys[i]] = context.options[1].exceptions[keys[i]];
			}
		}
		function getReplacedText(styleType, text) {
			switch (styleType) {
				case "between":
					return "," + text.replace("\n", "");

				case "first":
					return text + ",";

				case "last":
					return "," + text;

				default:
					return "";
			}
		}
		function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {
			var text = sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) + sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);
			var range = [previousItemToken.range[1], currentItemToken.range[0]];

			return function (fixer) {
				return fixer.replaceTextRange(range, getReplacedText(styleType, text));
			};
		}
		function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {
			if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) && astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
			} else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) && !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
				context.report({
					node: reportItem,
					loc: {
						line: commaToken.loc.end.line,
						column: commaToken.loc.start.column
					},
					message: "Bad line breaking before and after ','.",
					fix: getFixerFunction("between", previousItemToken, commaToken, currentItemToken)
				});
			} else if (style === "first" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {

				context.report({
					node: reportItem,
					message: "',' should be placed first.",
					fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
				});
			} else if (style === "last" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {

				context.report({
					node: reportItem,
					loc: {
						line: commaToken.loc.end.line,
						column: commaToken.loc.end.column
					},
					message: "',' should be placed last.",
					fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
				});
			}
		}
		function validateComma(node, property) {
			var items = node[property],
				arrayLiteral = node.type === "ArrayExpression" || node.type === "ArrayPattern";

			if (items.length > 1 || arrayLiteral) {
				var previousItemToken = sourceCode.getFirstToken(node);

				items.forEach(function (item) {
					var commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,
						currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),
						reportItem = item || currentItemToken,
						tokenBeforeComma = sourceCode.getTokenBefore(commaToken);
					if (tokenBeforeComma && astUtils.isClosingParenToken(tokenBeforeComma)) {
						previousItemToken = tokenBeforeComma;
					}
					if (astUtils.isCommaToken(commaToken)) {
						validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);
					}

					if (item) {
						var tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);

						previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];
					}
				});
				if (arrayLiteral) {

					var lastToken = sourceCode.getLastToken(node),
						nextToLastToken = sourceCode.getTokenBefore(lastToken);

					if (astUtils.isCommaToken(nextToLastToken)) {
						validateCommaItemSpacing(sourceCode.getTokenBefore(nextToLastToken), nextToLastToken, lastToken, lastToken);
					}
				}
			}
		}
		var nodes = {};

		if (!exceptions.VariableDeclaration) {
			nodes.VariableDeclaration = function (node) {
				validateComma(node, "declarations");
			};
		}
		if (!exceptions.ObjectExpression) {
			nodes.ObjectExpression = function (node) {
				validateComma(node, "properties");
			};
		}
		if (!exceptions.ObjectPattern) {
			nodes.ObjectPattern = function (node) {
				validateComma(node, "properties");
			};
		}
		if (!exceptions.ArrayExpression) {
			nodes.ArrayExpression = function (node) {
				validateComma(node, "elements");
			};
		}
		if (!exceptions.ArrayPattern) {
			nodes.ArrayPattern = function (node) {
				validateComma(node, "elements");
			};
		}
		if (!exceptions.FunctionDeclaration) {
			nodes.FunctionDeclaration = function (node) {
				validateComma(node, "params");
			};
		}
		if (!exceptions.FunctionExpression) {
			nodes.FunctionExpression = function (node) {
				validateComma(node, "params");
			};
		}
		if (!exceptions.ArrowFunctionExpression) {
			nodes.ArrowFunctionExpression = function (node) {
				validateComma(node, "params");
			};
		}
		if (!exceptions.CallExpression) {
			nodes.CallExpression = function (node) {
				validateComma(node, "arguments");
			};
		}
		if (!exceptions.ImportDeclaration) {
			nodes.ImportDeclaration = function (node) {
				validateComma(node, "specifiers");
			};
		}

		return nodes;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var lodash = __webpack_require__(10);

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum cyclomatic complexity allowed in a program",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "integer",
				minimum: 0
			}, {
				type: "object",
				properties: {
					maximum: {
						type: "integer",
						minimum: 0
					},
					max: {
						type: "integer",
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var option = context.options[0];
		var THRESHOLD = 20;

		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
			THRESHOLD = option.maximum;
		}
		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
			THRESHOLD = option.max;
		}
		if (typeof option === "number") {
			THRESHOLD = option;
		}
		var fns = [];
		function startFunction() {
			fns.push(1);
		}
		function endFunction(node) {
			var name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));
			var complexity = fns.pop();

			if (complexity > THRESHOLD) {
				context.report({
					node: node,
					message: "{{name}} has a complexity of {{complexity}}.",
					data: { name: name, complexity: complexity }
				});
			}
		}
		function increaseComplexity() {
			if (fns.length) {
				fns[fns.length - 1]++;
			}
		}
		function increaseSwitchComplexity(node) {
			if (node.test) {
				increaseComplexity();
			}
		}
		function increaseLogicalComplexity(node) {
			if (node.operator === "||") {
				increaseComplexity();
			}
		}
		return {
			FunctionDeclaration: startFunction,
			FunctionExpression: startFunction,
			ArrowFunctionExpression: startFunction,
			"FunctionDeclaration:exit": endFunction,
			"FunctionExpression:exit": endFunction,
			"ArrowFunctionExpression:exit": endFunction,

			CatchClause: increaseComplexity,
			ConditionalExpression: increaseComplexity,
			LogicalExpression: increaseLogicalComplexity,
			ForStatement: increaseComplexity,
			ForInStatement: increaseComplexity,
			ForOfStatement: increaseComplexity,
			IfStatement: increaseComplexity,
			SwitchCase: increaseSwitchComplexity,
			WhileStatement: increaseComplexity,
			DoWhileStatement: increaseComplexity
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing inside computed property brackets",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["always", "never"]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var propertyNameMustBeSpaced = context.options[0] === "always"; // default is "never"
		function reportNoBeginningSpace(node, token, tokenAfter) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "There should be no space after '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
				}
			});
		}
		function reportNoEndingSpace(node, token, tokenBefore) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "There should be no space before '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
				}
			});
		}
		function reportRequiredBeginningSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "A space is required after '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					return fixer.insertTextAfter(token, " ");
				}
			});
		}
		function reportRequiredEndingSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "A space is required before '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					return fixer.insertTextBefore(token, " ");
				}
			});
		}
		function checkSpacing(propertyName) {
			return function (node) {
				if (!node.computed) {
					return;
				}

				var property = node[propertyName];

				var before = sourceCode.getTokenBefore(property),
					first = sourceCode.getFirstToken(property),
					last = sourceCode.getLastToken(property),
					after = sourceCode.getTokenAfter(property);

				if (astUtils.isTokenOnSameLine(before, first)) {
					if (propertyNameMustBeSpaced) {
						if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {
							reportRequiredBeginningSpace(node, before);
						}
					} else {
						if (sourceCode.isSpaceBetweenTokens(before, first)) {
							reportNoBeginningSpace(node, before, first);
						}
					}
				}

				if (astUtils.isTokenOnSameLine(last, after)) {
					if (propertyNameMustBeSpaced) {
						if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {
							reportRequiredEndingSpace(node, after);
						}
					} else {
						if (sourceCode.isSpaceBetweenTokens(last, after)) {
							reportNoEndingSpace(node, after, last);
						}
					}
				}
			};
		}
		return {
			Property: checkSpacing("key"),
			MemberExpression: checkSpacing("property")
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10);

var astUtils = __webpack_require__(0);
function isIdentifier(node, name) {
	return node.type === "Identifier" && node.name === name;
}
function isUnreachable(segment) {
	return !segment.reachable;
}
function isClassConstructor(node) {
	return node.type === "FunctionExpression" && node.parent && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
}
module.exports = {
	meta: {
		docs: {
			description: "require `return` statements to either always or never specify values",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				treatUndefinedAsUnspecified: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;
		var funcInfo = null;
		function checkLastSegment(node) {
			var loc = void 0,
				name = void 0;
			if (!funcInfo.hasReturnValue || funcInfo.codePath.currentSegments.every(isUnreachable) || astUtils.isES5Constructor(node) || isClassConstructor(node)) {
				return;
			}
			if (node.type === "Program") {
				loc = { line: 1, column: 0 };
				name = "program";
			} else if (node.type === "ArrowFunctionExpression") {
				loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;
			} else if (node.parent.type === "MethodDefinition" || node.parent.type === "Property" && node.parent.method) {
				loc = node.parent.key.loc.start;
			} else {
				loc = (node.id || node).loc.start;
			}

			if (!name) {
				name = astUtils.getFunctionNameWithKind(node);
			}
			context.report({
				node: node,
				loc: loc,
				message: "Expected to return a value at the end of {{name}}.",
				data: { name: name }
			});
		}

		return {
			onCodePathStart: function onCodePathStart(codePath, node) {
				funcInfo = {
					upper: funcInfo,
					codePath: codePath,
					hasReturn: false,
					hasReturnValue: false,
					message: "",
					node: node
				};
			},
			onCodePathEnd: function onCodePathEnd() {
				funcInfo = funcInfo.upper;
			},
			ReturnStatement: function ReturnStatement(node) {
				var argument = node.argument;
				var hasReturnValue = Boolean(argument);

				if (treatUndefinedAsUnspecified && hasReturnValue) {
					hasReturnValue = !isIdentifier(argument, "undefined") && argument.operator !== "void";
				}

				if (!funcInfo.hasReturn) {
					funcInfo.hasReturn = true;
					funcInfo.hasReturnValue = hasReturnValue;
					funcInfo.message = "{{name}} expected {{which}} return value.";
					funcInfo.data = {
						name: funcInfo.node.type === "Program" ? "Program" : lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node)),
						which: hasReturnValue ? "a" : "no"
					};
				} else if (funcInfo.hasReturnValue !== hasReturnValue) {
					context.report({
						node: node,
						message: funcInfo.message,
						data: funcInfo.data
					});
				}
			},
			"Program:exit": checkLastSegment,
			"FunctionDeclaration:exit": checkLastSegment,
			"FunctionExpression:exit": checkLastSegment,
			"ArrowFunctionExpression:exit": checkLastSegment
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent naming when capturing the current execution context",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: {
			type: "array",
			items: {
				type: "string",
				minLength: 1
			},
			uniqueItems: true
		}
	},

	create: function create(context) {
		var aliases = [];

		if (context.options.length === 0) {
			aliases.push("that");
		} else {
			aliases = context.options;
		}
		function reportBadAssignment(node, alias) {
			context.report({ node: node, message: "Designated alias '{{alias}}' is not assigned to 'this'.", data: { alias: alias } });
		}
		function checkAssignment(node, name, value) {
			var isThis = value.type === "ThisExpression";

			if (aliases.indexOf(name) !== -1) {
				if (!isThis || node.operator && node.operator !== "=") {
					reportBadAssignment(node, name);
				}
			} else if (isThis) {
				context.report({ node: node, message: "Unexpected alias '{{name}}' for 'this'.", data: { name: name } });
			}
		}
		function checkWasAssigned(alias, scope) {
			var variable = scope.set.get(alias);

			if (!variable) {
				return;
			}

			if (variable.defs.some(function (def) {
				return def.node.type === "VariableDeclarator" && def.node.init !== null;
			})) {
				return;
			}
			if (!variable.references.some(function (reference) {
				var write = reference.writeExpr;

				return reference.from === scope && write && write.type === "ThisExpression" && write.parent.operator === "=";
			})) {
				variable.defs.map(function (def) {
					return def.node;
				}).forEach(function (node) {
					reportBadAssignment(node, alias);
				});
			}
		}
		function ensureWasAssigned() {
			var scope = context.getScope();

			aliases.forEach(function (alias) {
				checkWasAssigned(alias, scope);
			});
		}

		return {
			"Program:exit": ensureWasAssigned,
			"FunctionExpression:exit": ensureWasAssigned,
			"FunctionDeclaration:exit": ensureWasAssigned,

			VariableDeclarator: function VariableDeclarator(node) {
				var id = node.id;
				var isDestructuring = id.type === "ArrayPattern" || id.type === "ObjectPattern";

				if (node.init !== null && !isDestructuring) {
					checkAssignment(node, id.name, node.init);
				}
			},
			AssignmentExpression: function AssignmentExpression(node) {
				if (node.left.type === "Identifier") {
					checkAssignment(node, node.left.name, node.right);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isReachable(segment) {
	return segment.reachable;
}
function isConstructorFunction(node) {
	return node.type === "FunctionExpression" && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
}
function isPossibleConstructor(node) {
	if (!node) {
		return false;
	}

	switch (node.type) {
		case "ClassExpression":
		case "FunctionExpression":
		case "ThisExpression":
		case "MemberExpression":
		case "CallExpression":
		case "NewExpression":
		case "YieldExpression":
		case "TaggedTemplateExpression":
		case "MetaProperty":
			return true;

		case "Identifier":
			return node.name !== "undefined";

		case "AssignmentExpression":
			return isPossibleConstructor(node.right);

		case "LogicalExpression":
			return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);

		case "ConditionalExpression":
			return isPossibleConstructor(node.alternate) || isPossibleConstructor(node.consequent);

		case "SequenceExpression":
			{
				var lastExpression = node.expressions[node.expressions.length - 1];

				return isPossibleConstructor(lastExpression);
			}

		default:
			return false;
	}
}
module.exports = {
	meta: {
		docs: {
			description: "require `super()` calls in constructors",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var funcInfo = null;
		var segInfoMap = Object.create(null);
		function isCalledInSomePath(segment) {
			return segment.reachable && segInfoMap[segment.id].calledInSomePaths;
		}
		function isCalledInEveryPath(segment) {
			if (segment.nextSegments.length === 1 && segment.nextSegments[0].isLoopedPrevSegment(segment)) {
				return true;
			}
			return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;
		}

		return {
			onCodePathStart: function onCodePathStart(codePath, node) {
				if (isConstructorFunction(node)) {
					var classNode = node.parent.parent.parent;
					var superClass = classNode.superClass;

					funcInfo = {
						upper: funcInfo,
						isConstructor: true,
						hasExtends: Boolean(superClass),
						superIsConstructor: isPossibleConstructor(superClass),
						codePath: codePath
					};
				} else {
					funcInfo = {
						upper: funcInfo,
						isConstructor: false,
						hasExtends: false,
						superIsConstructor: false,
						codePath: codePath
					};
				}
			},
			onCodePathEnd: function onCodePathEnd(codePath, node) {
				var hasExtends = funcInfo.hasExtends;
				funcInfo = funcInfo.upper;

				if (!hasExtends) {
					return;
				}
				var segments = codePath.returnedSegments;
				var calledInEveryPaths = segments.every(isCalledInEveryPath);
				var calledInSomePaths = segments.some(isCalledInSomePath);

				if (!calledInEveryPaths) {
					context.report({
						message: calledInSomePaths ? "Lacked a call of 'super()' in some code paths." : "Expected to call 'super()'.",
						node: node.parent
					});
				}
			},
			onCodePathSegmentStart: function onCodePathSegmentStart(segment) {
				if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
					return;
				}
				var info = segInfoMap[segment.id] = {
					calledInSomePaths: false,
					calledInEveryPaths: false,
					validNodes: []
				};
				var prevSegments = segment.prevSegments;

				if (prevSegments.length > 0) {
					info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
					info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
				}
			},
			onCodePathSegmentLoop: function onCodePathSegmentLoop(fromSegment, toSegment) {
				if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
					return;
				}
				var isRealLoop = toSegment.prevSegments.length >= 2;

				funcInfo.codePath.traverseSegments({ first: toSegment, last: fromSegment }, function (segment) {
					var info = segInfoMap[segment.id];
					var prevSegments = segment.prevSegments;
					info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
					info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
					if (info.calledInSomePaths || isRealLoop) {
						var nodes = info.validNodes;

						info.validNodes = [];

						for (var i = 0; i < nodes.length; ++i) {
							var node = nodes[i];

							context.report({
								message: "Unexpected duplicate 'super()'.",
								node: node
							});
						}
					}
				});
			},
			"CallExpression:exit": function CallExpressionExit(node) {
				if (!(funcInfo && funcInfo.isConstructor)) {
					return;
				}
				if (node.callee.type !== "Super") {
					return;
				}
				if (funcInfo.hasExtends) {
					var segments = funcInfo.codePath.currentSegments;
					var duplicate = false;
					var info = null;

					for (var i = 0; i < segments.length; ++i) {
						var segment = segments[i];

						if (segment.reachable) {
							info = segInfoMap[segment.id];

							duplicate = duplicate || info.calledInSomePaths;
							info.calledInSomePaths = info.calledInEveryPaths = true;
						}
					}

					if (info) {
						if (duplicate) {
							context.report({
								message: "Unexpected duplicate 'super()'.",
								node: node
							});
						} else if (!funcInfo.superIsConstructor) {
							context.report({
								message: "Unexpected 'super()' because 'super' is not a constructor.",
								node: node
							});
						} else {
							info.validNodes.push(node);
						}
					}
				} else if (funcInfo.codePath.currentSegments.some(isReachable)) {
					context.report({
						message: "Unexpected 'super()'.",
						node: node
					});
				}
			},
			ReturnStatement: function ReturnStatement(node) {
				if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
					return;
				}
				if (!node.argument) {
					return;
				}
				var segments = funcInfo.codePath.currentSegments;

				for (var i = 0; i < segments.length; ++i) {
					var segment = segments[i];

					if (segment.reachable) {
						var info = segInfoMap[segment.id];

						info.calledInSomePaths = info.calledInEveryPaths = true;
					}
				}
			},
			"Program:exit": function ProgramExit() {
				segInfoMap = Object.create(null);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent brace style for all control statements",
			category: "Best Practices",
			recommended: false
		},

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["all"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["multi", "multi-line", "multi-or-nest"]
				}, {
					enum: ["consistent"]
				}],
				minItems: 0,
				maxItems: 2
			}]
		},

		fixable: "code"
	},

	create: function create(context) {

		var multiOnly = context.options[0] === "multi";
		var multiLine = context.options[0] === "multi-line";
		var multiOrNest = context.options[0] === "multi-or-nest";
		var consistent = context.options[1] === "consistent";

		var sourceCode = context.getSourceCode();
		function isCollapsedOneLiner(node) {
			var before = sourceCode.getTokenBefore(node);
			var last = sourceCode.getLastToken(node);
			var lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;

			return before.loc.start.line === lastExcludingSemicolon.loc.end.line;
		}
		function isOneLiner(node) {
			var first = sourceCode.getFirstToken(node),
				last = sourceCode.getLastToken(node);

			return first.loc.start.line === last.loc.end.line;
		}
		function isElseKeywordToken(token) {
			return token.value === "else" && token.type === "Keyword";
		}
		function getElseKeyword(node) {
			return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);
		}
		function requiresBraceOfConsequent(node) {
			if (node.alternate && node.consequent.type === "BlockStatement") {
				if (node.consequent.body.length >= 2) {
					return true;
				}

				node = node.consequent.body[0];
				while (node) {
					if (node.type === "IfStatement" && !node.alternate) {
						return true;
					}
					node = astUtils.getTrailingStatement(node);
				}
			}

			return false;
		}
		function reportExpectedBraceError(node, bodyNode, name, suffix) {
			context.report({
				node: node,
				loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
				message: "Expected { after '{{name}}'{{suffix}}.",
				data: {
					name: name,
					suffix: suffix ? " " + suffix : ""
				},
				fix: function fix(fixer) {
					return fixer.replaceText(bodyNode, "{" + sourceCode.getText(bodyNode) + "}");
				}
			});
		}
		function needsSemicolon(closingBracket) {
			var tokenBefore = sourceCode.getTokenBefore(closingBracket);
			var tokenAfter = sourceCode.getTokenAfter(closingBracket);
			var lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);

			if (astUtils.isSemicolonToken(tokenBefore)) {
				return false;
			}

			if (!tokenAfter) {
				return false;
			}

			if (lastBlockNode.type === "BlockStatement" && lastBlockNode.parent.type !== "FunctionExpression" && lastBlockNode.parent.type !== "ArrowFunctionExpression") {
				return false;
			}

			if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {
				return true;
			}

			if (/^[([/`+-]/.test(tokenAfter.value)) {
				return true;
			}

			if (tokenBefore.type === "Punctuator" && (tokenBefore.value === "++" || tokenBefore.value === "--")) {
				return true;
			}
			return false;
		}
		function reportUnnecessaryBraceError(node, bodyNode, name, suffix) {
			context.report({
				node: node,
				loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
				message: "Unnecessary { after '{{name}}'{{suffix}}.",
				data: {
					name: name,
					suffix: suffix ? " " + suffix : ""
				},
				fix: function fix(fixer) {
					var needsPrecedingSpace = node.type === "DoWhileStatement" && sourceCode.getTokenBefore(bodyNode).range[1] === bodyNode.range[0] && !astUtils.canTokensBeAdjacent("do", sourceCode.getFirstToken(bodyNode, { skip: 1 }));

					var openingBracket = sourceCode.getFirstToken(bodyNode);
					var closingBracket = sourceCode.getLastToken(bodyNode);
					var lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);

					if (needsSemicolon(closingBracket)) {
						return null;
					}

					var resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) + sourceCode.getText(lastTokenInBlock) + sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);

					return fixer.replaceText(bodyNode, (needsPrecedingSpace ? " " : "") + resultingBodyText);
				}
			});
		}
		function prepareCheck(node, body, name, suffix) {
			var hasBlock = body.type === "BlockStatement";
			var expected = null;

			if (node.type === "IfStatement" && node.consequent === body && requiresBraceOfConsequent(node)) {
				expected = true;
			} else if (multiOnly) {
				if (hasBlock && body.body.length === 1) {
					expected = false;
				}
			} else if (multiLine) {
				if (!isCollapsedOneLiner(body)) {
					expected = true;
				}
			} else if (multiOrNest) {
				if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {
					var leadingComments = sourceCode.getCommentsBefore(body.body[0]);

					expected = leadingComments.length > 0;
				} else if (!isOneLiner(body)) {
					expected = true;
				}
			} else {
				expected = true;
			}

			return {
				actual: hasBlock,
				expected: expected,
				check: function check() {
					if (this.expected !== null && this.expected !== this.actual) {
						if (this.expected) {
							reportExpectedBraceError(node, body, name, suffix);
						} else {
							reportUnnecessaryBraceError(node, body, name, suffix);
						}
					}
				}
			};
		}
		function prepareIfChecks(node) {
			var preparedChecks = [];

			do {
				preparedChecks.push(prepareCheck(node, node.consequent, "if", "condition"));
				if (node.alternate && node.alternate.type !== "IfStatement") {
					preparedChecks.push(prepareCheck(node, node.alternate, "else"));
					break;
				}
				node = node.alternate;
			} while (node);

			if (consistent) {
				var expected = preparedChecks.some(function (preparedCheck) {
					if (preparedCheck.expected !== null) {
						return preparedCheck.expected;
					}
					return preparedCheck.actual;
				});

				preparedChecks.forEach(function (preparedCheck) {
					preparedCheck.expected = expected;
				});
			}

			return preparedChecks;
		}
		return {
			IfStatement: function IfStatement(node) {
				if (node.parent.type !== "IfStatement") {
					prepareIfChecks(node).forEach(function (preparedCheck) {
						preparedCheck.check();
					});
				}
			},
			WhileStatement: function WhileStatement(node) {
				prepareCheck(node, node.body, "while", "condition").check();
			},
			DoWhileStatement: function DoWhileStatement(node) {
				prepareCheck(node, node.body, "do").check();
			},
			ForStatement: function ForStatement(node) {
				prepareCheck(node, node.body, "for", "condition").check();
			},
			ForInStatement: function ForInStatement(node) {
				prepareCheck(node, node.body, "for-in").check();
			},
			ForOfStatement: function ForOfStatement(node) {
				prepareCheck(node, node.body, "for-of").check();
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var DEFAULT_COMMENT_PATTERN = /^no default$/i;
module.exports = {
	meta: {
		docs: {
			description: "require `default` cases in `switch` statements",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				commentPattern: {
					type: "string"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var commentPattern = options.commentPattern ? new RegExp(options.commentPattern) : DEFAULT_COMMENT_PATTERN;

		var sourceCode = context.getSourceCode();
		function last(collection) {
			return collection[collection.length - 1];
		}
		return {
			SwitchStatement: function SwitchStatement(node) {

				if (!node.cases.length) {
					return;
				}

				var hasDefault = node.cases.some(function (v) {
					return v.test === null;
				});

				if (!hasDefault) {

					var comment = void 0;

					var lastCase = last(node.cases);
					var comments = sourceCode.getCommentsAfter(lastCase);

					if (comments.length) {
						comment = last(comments);
					}

					if (!comment || !commentPattern.test(comment.value.trim())) {
						context.report({ node: node, message: "Expected a default case." });
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent newlines before and after dots",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			enum: ["object", "property"]
		}],

		fixable: "code"
	},

	create: function create(context) {

		var config = context.options[0];
		var onObject = config === "object" || !config;

		var sourceCode = context.getSourceCode();
		function checkDotLocation(obj, prop, node) {
			var dot = sourceCode.getTokenBefore(prop);
			var textBeforeDot = sourceCode.getText().slice(obj.range[1], dot.range[0]);
			var textAfterDot = sourceCode.getText().slice(dot.range[1], prop.range[0]);

			if (dot.type === "Punctuator" && dot.value === ".") {
				if (onObject) {
					if (!astUtils.isTokenOnSameLine(obj, dot)) {
						var neededTextAfterObj = astUtils.isDecimalInteger(obj) ? " " : "";

						context.report({
							node: node,
							loc: dot.loc.start,
							message: "Expected dot to be on same line as object.",
							fix: function fix(fixer) {
								return fixer.replaceTextRange([obj.range[1], prop.range[0]], neededTextAfterObj + "." + textBeforeDot + textAfterDot);
							}
						});
					}
				} else if (!astUtils.isTokenOnSameLine(dot, prop)) {
					context.report({
						node: node,
						loc: dot.loc.start,
						message: "Expected dot to be on same line as property.",
						fix: function fix(fixer) {
							return fixer.replaceTextRange([obj.range[1], prop.range[0]], "" + textBeforeDot + textAfterDot + ".");
						}
					});
				}
			}
		}
		function checkNode(node) {
			checkDotLocation(node.object, node.property, node);
		}

		return {
			MemberExpression: checkNode
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
var keywords = __webpack_require__(107);

module.exports = {
	meta: {
		docs: {
			description: "enforce dot notation whenever possible",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowKeywords: {
					type: "boolean"
				},
				allowPattern: {
					type: "string"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var allowKeywords = options.allowKeywords === void 0 || !!options.allowKeywords;
		var sourceCode = context.getSourceCode();

		var allowPattern = void 0;

		if (options.allowPattern) {
			allowPattern = new RegExp(options.allowPattern);
		}
		function checkComputedProperty(node, value) {
			if (validIdentifier.test(value) && (allowKeywords || keywords.indexOf(String(value)) === -1) && !(allowPattern && allowPattern.test(value))) {
				var formattedValue = node.property.type === "Literal" ? JSON.stringify(value) : "`" + value + "`";

				context.report({
					node: node.property,
					message: "[{{propertyValue}}] is better written in dot notation.",
					data: {
						propertyValue: formattedValue
					},
					fix: function fix(fixer) {
						var leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);
						var rightBracket = sourceCode.getLastToken(node);

						if (sourceCode.getFirstTokenBetween(leftBracket, rightBracket, { includeComments: true, filter: astUtils.isCommentToken })) {
							return null;
						}

						var tokenAfterProperty = sourceCode.getTokenAfter(rightBracket);
						var needsSpaceAfterProperty = tokenAfterProperty && rightBracket.range[1] === tokenAfterProperty.range[0] && !astUtils.canTokensBeAdjacent(String(value), tokenAfterProperty);

						var textBeforeDot = astUtils.isDecimalInteger(node.object) ? " " : "";
						var textAfterProperty = needsSpaceAfterProperty ? " " : "";

						return fixer.replaceTextRange([leftBracket.range[0], rightBracket.range[1]], textBeforeDot + "." + value + textAfterProperty);
					}
				});
			}
		}

		return {
			MemberExpression: function MemberExpression(node) {
				if (node.computed && node.property.type === "Literal") {
					checkComputedProperty(node, node.property.value);
				}
				if (node.computed && node.property.type === "TemplateLiteral" && node.property.expressions.length === 0) {
					checkComputedProperty(node, node.property.quasis[0].value.cooked);
				}
				if (!allowKeywords && !node.computed && keywords.indexOf(String(node.property.name)) !== -1) {
					context.report({
						node: node.property,
						message: ".{{propertyName}} is a syntax error.",
						data: {
							propertyName: node.property.name
						},
						fix: function fix(fixer) {
							var dot = sourceCode.getTokenBefore(node.property);
							var textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);

							if (textAfterDot.trim()) {
								return null;
							}

							if (node.object.type === "Identifier" && node.object.name === "let") {
								return null;
							}

							return fixer.replaceTextRange([dot.range[0], node.property.range[1]], "[" + textAfterDot + "\"" + node.property.name + "\"]");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow newline at the end of files",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			enum: ["always", "never", "unix", "windows"]
		}]
	},
	create: function create(context) {
		return {
			Program: function checkBadEOF(node) {
				var sourceCode = context.getSourceCode(),
					src = sourceCode.getText(),
					location = {
					column: lodash.last(sourceCode.lines).length,
					line: sourceCode.lines.length
				},
					LF = "\n",
					CRLF = "\r" + LF,
					endsWithNewline = lodash.endsWith(src, LF);
				if (!src.length) {
					return;
				}

				var mode = context.options[0] || "always",
					appendCRLF = false;

				if (mode === "unix") {
					mode = "always";
				}
				if (mode === "windows") {
					mode = "always";
					appendCRLF = true;
				}
				if (mode === "always" && !endsWithNewline) {
					context.report({
						node: node,
						loc: location,
						message: "Newline required at end of file but not found.",
						fix: function fix(fixer) {
							return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);
						}
					});
				} else if (mode === "never" && endsWithNewline) {
					context.report({
						node: node,
						loc: location,
						message: "Newline not allowed at end of file.",
						fix: function fix(fixer) {
							var finalEOLs = /(?:\r?\n)+$/,
								match = finalEOLs.exec(sourceCode.text),
								start = match.index,
								end = sourceCode.text.length;

							return fixer.replaceTextRange([start, end], "");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require the use of `===` and `!==`",
			category: "Best Practices",
			recommended: false
		},

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["always"]
				}, {
					type: "object",
					properties: {
						null: {
							enum: ["always", "never", "ignore"]
						}
					},
					additionalProperties: false
				}],
				additionalItems: false
			}, {
				type: "array",
				items: [{
					enum: ["smart", "allow-null"]
				}],
				additionalItems: false
			}]
		},

		fixable: "code"
	},

	create: function create(context) {
		var config = context.options[0] || "always";
		var options = context.options[1] || {};
		var sourceCode = context.getSourceCode();

		var nullOption = config === "always" ? options.null || "always" : "ignore";
		var enforceRuleForNull = nullOption === "always";
		var enforceInverseRuleForNull = nullOption === "never";
		function isTypeOf(node) {
			return node.type === "UnaryExpression" && node.operator === "typeof";
		}
		function isTypeOfBinary(node) {
			return isTypeOf(node.left) || isTypeOf(node.right);
		}
		function areLiteralsAndSameType(node) {
			return node.left.type === "Literal" && node.right.type === "Literal" && _typeof(node.left.value) === _typeof(node.right.value);
		}
		function isNullCheck(node) {
			return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);
		}
		function getOperatorLocation(node) {
			var opToken = sourceCode.getTokenAfter(node.left);

			return { line: opToken.loc.start.line, column: opToken.loc.start.column };
		}
		function report(node, expectedOperator) {
			context.report({
				node: node,
				loc: getOperatorLocation(node),
				message: "Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.",
				data: { expectedOperator: expectedOperator, actualOperator: node.operator },
				fix: function fix(fixer) {
					if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {
						var operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, function (token) {
							return token.value === node.operator;
						});

						return fixer.replaceText(operatorToken, expectedOperator);
					}
					return null;
				}
			});
		}

		return {
			BinaryExpression: function BinaryExpression(node) {
				var isNull = isNullCheck(node);

				if (node.operator !== "==" && node.operator !== "!=") {
					if (enforceInverseRuleForNull && isNull) {
						report(node, node.operator.slice(0, -1));
					}
					return;
				}

				if (config === "smart" && (isTypeOfBinary(node) || areLiteralsAndSameType(node) || isNull)) {
					return;
				}

				if (!enforceRuleForNull && isNull) {
					return;
				}

				report(node, node.operator + "=");
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce \"for\" loop update clause moving the counter in the right direction.",
			category: "Possible Errors",
			recommended: false
		},
		fixable: null,
		schema: []
	},

	create: function create(context) {
		function report(node) {
			context.report({
				node: node,
				message: "The update clause in this loop moves the variable in the wrong direction."
			});
		}
		function getUpdateDirection(update, counter) {
			if (update.argument.type === "Identifier" && update.argument.name === counter) {
				if (update.operator === "++") {
					return 1;
				}
				if (update.operator === "--") {
					return -1;
				}
			}
			return 0;
		}
		function getAssignmentDirection(update, counter) {
			if (update.left.name === counter) {
				if (update.operator === "+=") {
					return 1;
				}
				if (update.operator === "-=") {
					return -1;
				}
			}
			return 0;
		}
		return {
			ForStatement: function ForStatement(node) {

				if (node.test && node.test.type === "BinaryExpression" && node.test.left.type === "Identifier" && node.update) {
					var counter = node.test.left.name;
					var operator = node.test.operator;
					var update = node.update;

					if (operator === "<" || operator === "<=") {
						if (update.type === "UpdateExpression" && getUpdateDirection(update, counter) < 0) {
							report(node);
						}

						if (update.type === "AssignmentExpression" && getAssignmentDirection(update, counter) < 0) {
							report(node);
						}
					} else if (operator === ">" || operator === ">=") {
						if (update.type === "UpdateExpression" && getUpdateDirection(update, counter) > 0) {
							report(node);
						}

						if (update.type === "AssignmentExpression" && getAssignmentDirection(update, counter) > 0) {
							report(node);
						}
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow spacing between function identifiers and their invocations",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",
		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["never"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["always"]
				}, {
					type: "object",
					properties: {
						allowNewlines: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		}
	},

	create: function create(context) {

		var never = context.options[0] !== "always";
		var allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;
		var sourceCode = context.getSourceCode();
		var text = sourceCode.getText();
		function checkSpacing(node) {
			var lastToken = sourceCode.getLastToken(node);
			var lastCalleeToken = sourceCode.getLastToken(node.callee);
			var parenToken = sourceCode.getFirstTokenBetween(lastCalleeToken, lastToken, astUtils.isOpeningParenToken);
			var prevToken = parenToken && sourceCode.getTokenBefore(parenToken);
			if (!(parenToken && parenToken.range[1] < node.range[1])) {
				return;
			}

			var textBetweenTokens = text.slice(prevToken.range[1], parenToken.range[0]).replace(/\/\*.*?\*\//g, "");
			var hasWhitespace = /\s/.test(textBetweenTokens);
			var hasNewline = hasWhitespace && astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);

			if (never && hasWhitespace) {
				context.report({
					node: node,
					loc: lastCalleeToken.loc.start,
					message: "Unexpected space between function name and paren.",
					fix: function fix(fixer) {
						if (!hasNewline) {
							return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
						}

						return null;
					}
				});
			} else if (!never && !hasWhitespace) {
				context.report({
					node: node,
					loc: lastCalleeToken.loc.start,
					message: "Missing space between function name and paren.",
					fix: function fix(fixer) {
						return fixer.insertTextBefore(parenToken, " ");
					}
				});
			} else if (!never && !allowNewlines && hasNewline) {
				context.report({
					node: node,
					loc: lastCalleeToken.loc.start,
					message: "Unexpected newline between function name and paren.",
					fix: function fix(fixer) {
						return fixer.replaceTextRange([prevToken.range[1], parenToken.range[0]], " ");
					}
				});
			}
		}

		return {
			CallExpression: checkSpacing,
			NewExpression: checkSpacing
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
var esutils = __webpack_require__(68);
function isModuleExports(pattern) {
	if (pattern.type === "MemberExpression" && pattern.object.type === "Identifier" && pattern.object.name === "module") {
		if (pattern.property.type === "Identifier" && pattern.property.name === "exports") {
			return true;
		}
		if (pattern.property.type === "Literal" && pattern.property.value === "exports") {
			return true;
		}
	}
	return false;
}
function isIdentifier(name, ecmaVersion) {
	if (ecmaVersion >= 6) {
		return esutils.keyword.isIdentifierES6(name);
	}
	return esutils.keyword.isIdentifierES5(name);
}
var alwaysOrNever = { enum: ["always", "never"] };
var optionsObject = {
	type: "object",
	properties: {
		includeCommonJSModuleExports: {
			type: "boolean"
		}
	},
	additionalProperties: false
};

module.exports = {
	meta: {
		docs: {
			description: "require function names to match the name of the variable or property to which they are assigned",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: {
			anyOf: [{
				type: "array",
				additionalItems: false,
				items: [alwaysOrNever, optionsObject]
			}, {
				type: "array",
				additionalItems: false,
				items: [optionsObject]
			}]
		}
	},

	create: function create(context) {
		var options = (_typeof(context.options[0]) === "object" ? context.options[0] : context.options[1]) || {};
		var nameMatches = typeof context.options[0] === "string" ? context.options[0] : "always";
		var includeModuleExports = options.includeCommonJSModuleExports;
		var ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;
		function shouldWarn(x, y) {
			return nameMatches === "always" && x !== y || nameMatches === "never" && x === y;
		}
		function report(node, name, funcName, isProp) {
			var message = void 0;

			if (nameMatches === "always" && isProp) {
				message = "Function name `{{funcName}}` should match property name `{{name}}`";
			} else if (nameMatches === "always") {
				message = "Function name `{{funcName}}` should match variable name `{{name}}`";
			} else if (isProp) {
				message = "Function name `{{funcName}}` should not match property name `{{name}}`";
			} else {
				message = "Function name `{{funcName}}` should not match variable name `{{name}}`";
			}
			context.report({
				node: node,
				message: message,
				data: {
					name: name,
					funcName: funcName
				}
			});
		}
		function isStringLiteral(node) {
			return node.type === "Literal" && typeof node.value === "string";
		}
		return {
			VariableDeclarator: function VariableDeclarator(node) {
				if (!node.init || node.init.type !== "FunctionExpression" || node.id.type !== "Identifier") {
					return;
				}
				if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {
					report(node, node.id.name, node.init.id.name, false);
				}
			},
			AssignmentExpression: function AssignmentExpression(node) {
				if (node.right.type !== "FunctionExpression" || node.left.computed && node.left.property.type !== "Literal" || !includeModuleExports && isModuleExports(node.left) || node.left.type !== "Identifier" && node.left.type !== "MemberExpression") {
					return;
				}

				var isProp = node.left.type === "MemberExpression";
				var name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;

				if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {
					report(node, name, node.right.id.name, isProp);
				}
			},
			Property: function Property(node) {
				if (node.value.type !== "FunctionExpression" || !node.value.id || node.computed && !isStringLiteral(node.key)) {
					return;
				}
				if (node.key.type === "Identifier" && shouldWarn(node.key.name, node.value.id.name)) {
					report(node, node.key.name, node.value.id.name, true);
				} else if (isStringLiteral(node.key) && isIdentifier(node.key.value, ecmaVersion) && shouldWarn(node.key.value, node.value.id.name)) {
					report(node, node.key.value, node.value.id.name, true);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isFunctionName(variable) {
	return variable && variable.defs[0].type === "FunctionName";
}
module.exports = {
	meta: {
		docs: {
			description: "require or disallow named `function` expressions",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			enum: ["always", "as-needed", "never"]
		}]
	},

	create: function create(context) {
		var never = context.options[0] === "never";
		var asNeeded = context.options[0] === "as-needed";
		function isObjectOrClassMethod(node) {
			var parent = node.parent;

			return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.method || parent.kind === "get" || parent.kind === "set");
		}
		function hasInferredName(node) {
			var parent = node.parent;

			return isObjectOrClassMethod(node) || parent.type === "VariableDeclarator" && parent.id.type === "Identifier" && parent.init === node || parent.type === "Property" && parent.value === node || parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node || parent.type === "ExportDefaultDeclaration" && parent.declaration === node || parent.type === "AssignmentPattern" && parent.right === node;
		}

		return {
			"FunctionExpression:exit": function FunctionExpressionExit(node) {
				var nameVar = context.getDeclaredVariables(node)[0];

				if (isFunctionName(nameVar) && nameVar.references.length > 0) {
					return;
				}

				var hasName = Boolean(node.id && node.id.name);
				var name = astUtils.getFunctionNameWithKind(node);

				if (never) {
					if (hasName) {
						context.report({
							node: node,
							message: "Unexpected named {{name}}.",
							data: { name: name }
						});
					}
				} else {
					if (!hasName && (asNeeded ? !hasInferredName(node) : !isObjectOrClassMethod(node))) {
						context.report({
							node: node,
							message: "Unexpected unnamed {{name}}.",
							data: { name: name }
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce the consistent use of either `function` declarations or expressions",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			enum: ["declaration", "expression"]
		}, {
			type: "object",
			properties: {
				allowArrowFunctions: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var style = context.options[0],
			allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions === true,
			enforceDeclarations = style === "declaration",
			stack = [];

		var nodesToCheck = {
			FunctionDeclaration: function FunctionDeclaration(node) {
				stack.push(false);

				if (!enforceDeclarations && node.parent.type !== "ExportDefaultDeclaration") {
					context.report({ node: node, message: "Expected a function expression." });
				}
			},
			"FunctionDeclaration:exit": function FunctionDeclarationExit() {
				stack.pop();
			},
			FunctionExpression: function FunctionExpression(node) {
				stack.push(false);

				if (enforceDeclarations && node.parent.type === "VariableDeclarator") {
					context.report({ node: node.parent, message: "Expected a function declaration." });
				}
			},
			"FunctionExpression:exit": function FunctionExpressionExit() {
				stack.pop();
			},
			ThisExpression: function ThisExpression() {
				if (stack.length > 0) {
					stack[stack.length - 1] = true;
				}
			}
		};

		if (!allowArrowFunctions) {
			nodesToCheck.ArrowFunctionExpression = function () {
				stack.push(false);
			};

			nodesToCheck["ArrowFunctionExpression:exit"] = function (node) {
				var hasThisExpr = stack.pop();

				if (enforceDeclarations && !hasThisExpr && node.parent.type === "VariableDeclarator") {
					context.report({ node: node.parent, message: "Expected a function declaration." });
				}
			};
		}

		return nodesToCheck;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent line breaks inside function parentheses",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			oneOf: [{
				enum: ["always", "never", "consistent", "multiline"]
			}, {
				type: "object",
				properties: {
					minItems: {
						type: "integer",
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var rawOption = context.options[0] || "multiline";
		var multilineOption = rawOption === "multiline";
		var consistentOption = rawOption === "consistent";
		var minItems = void 0;

		if ((typeof rawOption === "undefined" ? "undefined" : _typeof(rawOption)) === "object") {
			minItems = rawOption.minItems;
		} else if (rawOption === "always") {
			minItems = 0;
		} else if (rawOption === "never") {
			minItems = Infinity;
		} else {
			minItems = null;
		}
		function shouldHaveNewlines(elements, hasLeftNewline) {
			if (multilineOption) {
				return elements.some(function (element, index) {
					return index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line;
				});
			}
			if (consistentOption) {
				return hasLeftNewline;
			}
			return elements.length >= minItems;
		}
		function validateParens(parens, elements) {
			var leftParen = parens.leftParen;
			var rightParen = parens.rightParen;
			var tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
			var tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);
			var hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
			var hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);
			var needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);

			if (hasLeftNewline && !needsNewlines) {
				context.report({
					node: leftParen,
					message: "Unexpected newline after '('.",
					fix: function fix(fixer) {
						return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()
						? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);
					}
				});
			} else if (!hasLeftNewline && needsNewlines) {
				context.report({
					node: leftParen,
					message: "Expected a newline after '('.",
					fix: function fix(fixer) {
						return fixer.insertTextAfter(leftParen, "\n");
					}
				});
			}

			if (hasRightNewline && !needsNewlines) {
				context.report({
					node: rightParen,
					message: "Unexpected newline before ')'.",
					fix: function fix(fixer) {
						return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()
						? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);
					}
				});
			} else if (!hasRightNewline && needsNewlines) {
				context.report({
					node: rightParen,
					message: "Expected a newline before ')'.",
					fix: function fix(fixer) {
						return fixer.insertTextBefore(rightParen, "\n");
					}
				});
			}
		}
		function getParenTokens(node) {
			switch (node.type) {
				case "NewExpression":
					if (!node.arguments.length && !(astUtils.isOpeningParenToken(sourceCode.getLastToken(node, { skip: 1 })) && astUtils.isClosingParenToken(sourceCode.getLastToken(node)))) {
						return null;
					}
				case "CallExpression":
					return {
						leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),
						rightParen: sourceCode.getLastToken(node)
					};

				case "FunctionDeclaration":
				case "FunctionExpression":
					{
						var leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
						var rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(leftParen);

						return { leftParen: leftParen, rightParen: rightParen };
					}

				case "ArrowFunctionExpression":
					{
						var firstToken = sourceCode.getFirstToken(node);

						if (!astUtils.isOpeningParenToken(firstToken)) {
							return null;
						}

						return {
							leftParen: firstToken,
							rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)
						};
					}

				default:
					throw new TypeError("unexpected node with type " + node.type);
			}
		}
		function validateNode(node) {
			var parens = getParenTokens(node);

			if (parens) {
				validateParens(parens, astUtils.isFunction(node) ? node.params : node.arguments);
			}
		}
		return {
			ArrowFunctionExpression: validateNode,
			CallExpression: validateNode,
			FunctionDeclaration: validateNode,
			FunctionExpression: validateNode,
			NewExpression: validateNode
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var OVERRIDE_SCHEMA = {
	oneOf: [{
		enum: ["before", "after", "both", "neither"]
	}, {
		type: "object",
		properties: {
			before: { type: "boolean" },
			after: { type: "boolean" }
		},
		additionalProperties: false
	}]
};

module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing around `*` operators in generator functions",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["before", "after", "both", "neither"]
			}, {
				type: "object",
				properties: {
					before: { type: "boolean" },
					after: { type: "boolean" },
					named: OVERRIDE_SCHEMA,
					anonymous: OVERRIDE_SCHEMA,
					method: OVERRIDE_SCHEMA
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {

		var optionDefinitions = {
			before: { before: true, after: false },
			after: { before: false, after: true },
			both: { before: true, after: true },
			neither: { before: false, after: false }
		};
		function optionToDefinition(option, defaults) {
			if (!option) {
				return defaults;
			}

			return typeof option === "string" ? optionDefinitions[option] : Object.assign({}, defaults, option);
		}

		var modes = function (option) {
			option = option || {};
			var defaults = optionToDefinition(option, optionDefinitions.before);

			return {
				named: optionToDefinition(option.named, defaults),
				anonymous: optionToDefinition(option.anonymous, defaults),
				method: optionToDefinition(option.method, defaults)
			};
		}(context.options[0]);

		var sourceCode = context.getSourceCode();
		function isStarToken(token) {
			return token.value === "*" && token.type === "Punctuator";
		}
		function getStarToken(node) {
			return sourceCode.getFirstToken(node.parent.method || node.parent.type === "MethodDefinition" ? node.parent : node, isStarToken);
		}
		function checkSpacing(kind, side, leftToken, rightToken) {
			if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {
				var after = leftToken.value === "*";
				var spaceRequired = modes[kind][side];
				var node = after ? leftToken : rightToken;
				var type = spaceRequired ? "Missing" : "Unexpected";
				var message = "{{type}} space {{side}} *.";
				var data = {
					type: type,
					side: side
				};

				context.report({
					node: node,
					message: message,
					data: data,
					fix: function fix(fixer) {
						if (spaceRequired) {
							if (after) {
								return fixer.insertTextAfter(node, " ");
							}
							return fixer.insertTextBefore(node, " ");
						}
						return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
					}
				});
			}
		}
		function checkFunction(node) {
			if (!node.generator) {
				return;
			}

			var starToken = getStarToken(node);
			var prevToken = sourceCode.getTokenBefore(starToken);
			var nextToken = sourceCode.getTokenAfter(starToken);

			var kind = "named";

			if (node.parent.type === "MethodDefinition" || node.parent.type === "Property" && node.parent.method) {
				kind = "method";
			} else if (!node.id) {
				kind = "anonymous";
			}
			if (!(kind === "method" && starToken === sourceCode.getFirstToken(node.parent))) {
				checkSpacing(kind, "before", prevToken, starToken);
			}

			checkSpacing(kind, "after", starToken, nextToken);
		}

		return {
			FunctionDeclaration: checkFunction,
			FunctionExpression: checkFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;
function isReachable(segment) {
	return segment.reachable;
}
function getId(node) {
	return node.id || node;
}
module.exports = {
	meta: {
		docs: {
			description: "enforce `return` statements in getters",
			category: "Possible Errors",
			recommended: false
		},
		fixable: null,
		schema: [{
			type: "object",
			properties: {
				allowImplicit: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = context.options[0] || { allowImplicit: false };

		var funcInfo = {
			upper: null,
			codePath: null,
			hasReturn: false,
			shouldCheck: false,
			node: null
		};
		function checkLastSegment(node) {
			if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {
				context.report({
					node: node,
					loc: getId(node).loc.start,
					message: funcInfo.hasReturn ? "Expected {{name}} to always return a value." : "Expected to return a value in {{name}}.",
					data: {
						name: astUtils.getFunctionNameWithKind(funcInfo.node)
					}
				});
			}
		}
		function isGetter(node) {
			var parent = node.parent;

			if (TARGET_NODE_TYPE.test(node.type) && node.body.type === "BlockStatement") {
				if (parent.kind === "get") {
					return true;
				}
				if (parent.type === "Property" && astUtils.getStaticPropertyName(parent) === "get" && parent.parent.type === "ObjectExpression") {
					if (parent.parent.parent.type === "CallExpression" && astUtils.getStaticPropertyName(parent.parent.parent.callee) === "defineProperty") {
						return true;
					}
					if (parent.parent.parent.type === "Property" && parent.parent.parent.parent.type === "ObjectExpression" && parent.parent.parent.parent.parent.type === "CallExpression" && astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === "defineProperties") {
						return true;
					}
				}
			}
			return false;
		}
		return {
			onCodePathStart: function onCodePathStart(codePath, node) {
				funcInfo = {
					upper: funcInfo,
					codePath: codePath,
					hasReturn: false,
					shouldCheck: isGetter(node),
					node: node
				};
			},
			onCodePathEnd: function onCodePathEnd() {
				funcInfo = funcInfo.upper;
			},
			ReturnStatement: function ReturnStatement(node) {
				if (funcInfo.shouldCheck) {
					funcInfo.hasReturn = true;
					if (!options.allowImplicit && !node.argument) {
						context.report({
							node: node,
							message: "Expected to return a value in {{name}}.",
							data: {
								name: astUtils.getFunctionNameWithKind(funcInfo.node)
							}
						});
					}
				}
			},
			"FunctionExpression:exit": checkLastSegment,
			"ArrowFunctionExpression:exit": checkLastSegment
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var ACCEPTABLE_PARENTS = ["AssignmentExpression", "VariableDeclarator", "MemberExpression", "ExpressionStatement", "CallExpression", "ConditionalExpression", "Program", "VariableDeclaration"];
function findReference(scope, node) {
	var references = scope.references.filter(function (reference) {
		return reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1];
	});
	if (references.length === 1) {
		return references[0];
	}
	return null;
}
function isShadowed(scope, node) {
	var reference = findReference(scope, node);

	return reference && reference.resolved && reference.resolved.defs.length > 0;
}

module.exports = {
	meta: {
		docs: {
			description: "require `require()` calls to be placed at top-level module scope",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		return {
			CallExpression: function CallExpression(node) {
				var currentScope = context.getScope();

				if (node.callee.name === "require" && !isShadowed(currentScope, node.callee)) {
					var isGoodRequire = context.getAncestors().every(function (parent) {
						return ACCEPTABLE_PARENTS.indexOf(parent.type) > -1;
					});

					if (!isGoodRequire) {
						context.report({ node: node, message: "Unexpected require()." });
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require `for-in` loops to include an `if` statement",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			ForInStatement: function ForInStatement(node) {
				var body = node.body.type === "BlockStatement" ? node.body.body[0] : node.body;

				if (body && body.type !== "IfStatement") {
					context.report({ node: node, message: "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require error handling in callbacks",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: [{
			type: "string"
		}]
	},

	create: function create(context) {

		var errorArgument = context.options[0] || "err";
		function isPattern(stringToCheck) {
			var firstChar = stringToCheck[0];

			return firstChar === "^";
		}
		function matchesConfiguredErrorName(name) {
			if (isPattern(errorArgument)) {
				var regexp = new RegExp(errorArgument);

				return regexp.test(name);
			}
			return name === errorArgument;
		}
		function getParameters(scope) {
			return scope.variables.filter(function (variable) {
				return variable.defs[0] && variable.defs[0].type === "Parameter";
			});
		}
		function checkForError(node) {
			var scope = context.getScope(),
				parameters = getParameters(scope),
				firstParameter = parameters[0];

			if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {
				if (firstParameter.references.length === 0) {
					context.report({ node: node, message: "Expected error to be handled." });
				}
			}
		}

		return {
			FunctionDeclaration: checkForError,
			FunctionExpression: checkForError,
			ArrowFunctionExpression: checkForError
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow specified identifiers",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: {
			type: "array",
			items: {
				type: "string"
			},
			uniqueItems: true
		}
	},

	create: function create(context) {
		var blacklist = context.options;
		function isInvalid(name) {
			return blacklist.indexOf(name) !== -1;
		}
		function shouldReport(effectiveParent, name) {
			return effectiveParent.type !== "CallExpression" && effectiveParent.type !== "NewExpression" && isInvalid(name);
		}
		function report(node) {
			context.report({
				node: node,
				message: "Identifier '{{name}}' is blacklisted.",
				data: {
					name: node.name
				}
			});
		}

		return {
			Identifier: function Identifier(node) {
				var name = node.name,
					effectiveParent = node.parent.type === "MemberExpression" ? node.parent.parent : node.parent;
				if (node.parent.type === "MemberExpression") {
					if (node.parent.object.type === "Identifier" && node.parent.object.name === node.name) {
						if (isInvalid(name)) {
							report(node);
						}
					} else if (effectiveParent.type === "AssignmentExpression" && (effectiveParent.right.type !== "MemberExpression" || effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name)) {
						if (isInvalid(name)) {
							report(node);
						}
					}
				} else if (node.parent.type === "Property") {

					if (shouldReport(effectiveParent, name)) {
						report(node);
					}
				} else if (shouldReport(effectiveParent, name)) {
					report(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce minimum and maximum identifier lengths",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				min: {
					type: "number"
				},
				max: {
					type: "number"
				},
				exceptions: {
					type: "array",
					uniqueItems: true,
					items: {
						type: "string"
					}
				},
				properties: {
					enum: ["always", "never"]
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var minLength = typeof options.min !== "undefined" ? options.min : 2;
		var maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
		var properties = options.properties !== "never";
		var exceptions = (options.exceptions ? options.exceptions : []).reduce(function (obj, item) {
			obj[item] = true;

			return obj;
		}, {});

		var SUPPORTED_EXPRESSIONS = {
			MemberExpression: properties && function (parent) {
				return !parent.computed && (
				parent.parent.left === parent && parent.parent.type === "AssignmentExpression" ||
				parent.parent.type === "Property" && parent.parent.value === parent && parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent);
			},
			AssignmentPattern: function AssignmentPattern(parent, node) {
				return parent.left === node;
			},
			VariableDeclarator: function VariableDeclarator(parent, node) {
				return parent.id === node;
			},

			Property: properties && function (parent, node) {
				return parent.key === node;
			},
			ImportDefaultSpecifier: true,
			RestElement: true,
			FunctionExpression: true,
			ArrowFunctionExpression: true,
			ClassDeclaration: true,
			FunctionDeclaration: true,
			MethodDefinition: true,
			CatchClause: true
		};

		return {
			Identifier: function Identifier(node) {
				var name = node.name;
				var parent = node.parent;

				var isShort = name.length < minLength;
				var isLong = name.length > maxLength;

				if (!(isShort || isLong) || exceptions[name]) {
					return; // Nothing to report
				}

				var isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];

				if (isValidExpression && (isValidExpression === true || isValidExpression(parent, node))) {
					context.report({
						node: node,
						message: isShort ? "Identifier name '{{name}}' is too short (< {{min}})." : "Identifier name '{{name}}' is too long (> {{max}}).",
						data: { name: name, min: minLength, max: maxLength }
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require identifiers to match a specified regular expression",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "string"
		}, {
			type: "object",
			properties: {
				properties: {
					type: "boolean"
				}
			}
		}]
	},

	create: function create(context) {
		var pattern = context.options[0] || "^.+$",
			regexp = new RegExp(pattern);

		var options = context.options[1] || {},
			properties = !!options.properties,
			onlyDeclarations = !!options.onlyDeclarations;
		function isInvalid(name) {
			return !regexp.test(name);
		}
		function shouldReport(effectiveParent, name) {
			return effectiveParent.type !== "CallExpression" && effectiveParent.type !== "NewExpression" && isInvalid(name);
		}
		function report(node) {
			context.report({
				node: node,
				message: "Identifier '{{name}}' does not match the pattern '{{pattern}}'.",
				data: {
					name: node.name,
					pattern: pattern
				}
			});
		}

		return {
			Identifier: function Identifier(node) {
				var name = node.name,
					parent = node.parent,
					effectiveParent = parent.type === "MemberExpression" ? parent.parent : parent;

				if (parent.type === "MemberExpression") {

					if (!properties) {
						return;
					}
					if (parent.object.type === "Identifier" && parent.object.name === name) {
						if (isInvalid(name)) {
							report(node);
						}
					} else if (effectiveParent.type === "AssignmentExpression" && (effectiveParent.right.type !== "MemberExpression" || effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === name)) {
						if (isInvalid(name)) {
							report(node);
						}
					}
				} else if (parent.type === "Property") {

					if (!properties || parent.key.name !== name) {
						return;
					}

					if (shouldReport(effectiveParent, name)) {
						report(node);
					}
				} else {
					var isDeclaration = effectiveParent.type === "FunctionDeclaration" || effectiveParent.type === "VariableDeclarator";

					if (onlyDeclarations && !isDeclaration) {
						return;
					}

					if (shouldReport(effectiveParent, name)) {
						report(node);
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce the location of arrow function bodies",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			enum: ["beside", "below"]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function getOption() {
			return context.options[0] || "beside";
		}
		function validateExpression(node) {
			var option = getOption();

			var tokenBefore = sourceCode.getTokenBefore(node.body);
			var hasParens = tokenBefore.value === "(";

			if (node.type === "BlockStatement") {
				return;
			}

			var fixerTarget = node.body;

			if (hasParens) {
				tokenBefore = sourceCode.getTokenBefore(node.body, function (token) {
					return token.value !== "(";
				});
				fixerTarget = sourceCode.getTokenAfter(tokenBefore);
			}

			if (tokenBefore.loc.end.line === fixerTarget.loc.start.line && option === "below") {
				context.report({
					node: fixerTarget,
					message: "Expected a linebreak before this expression.",
					fix: function fix(fixer) {
						return fixer.insertTextBefore(fixerTarget, "\n");
					}
				});
			} else if (tokenBefore.loc.end.line !== fixerTarget.loc.start.line && option === "beside") {
				context.report({
					node: fixerTarget,
					message: "Expected no linebreak before this expression.",
					fix: function fix(fixer) {
						return fixer.replaceTextRange([tokenBefore.range[1], fixerTarget.range[0]], " ");
					}
				});
			}
		}
		return {
			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
				return validateExpression(node);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent indentation",
			category: "Stylistic Issues",
			recommended: false,
			replacedBy: ["indent"]
		},

		deprecated: true,

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["tab"]
			}, {
				type: "integer",
				minimum: 0
			}]
		}, {
			type: "object",
			properties: {
				SwitchCase: {
					type: "integer",
					minimum: 0
				},
				VariableDeclarator: {
					oneOf: [{
						type: "integer",
						minimum: 0
					}, {
						type: "object",
						properties: {
							var: {
								type: "integer",
								minimum: 0
							},
							let: {
								type: "integer",
								minimum: 0
							},
							const: {
								type: "integer",
								minimum: 0
							}
						}
					}]
				},
				outerIIFEBody: {
					type: "integer",
					minimum: 0
				},
				MemberExpression: {
					type: "integer",
					minimum: 0
				},
				FunctionDeclaration: {
					type: "object",
					properties: {
						parameters: {
							oneOf: [{
								type: "integer",
								minimum: 0
							}, {
								enum: ["first"]
							}]
						},
						body: {
							type: "integer",
							minimum: 0
						}
					}
				},
				FunctionExpression: {
					type: "object",
					properties: {
						parameters: {
							oneOf: [{
								type: "integer",
								minimum: 0
							}, {
								enum: ["first"]
							}]
						},
						body: {
							type: "integer",
							minimum: 0
						}
					}
				},
				CallExpression: {
					type: "object",
					properties: {
						parameters: {
							oneOf: [{
								type: "integer",
								minimum: 0
							}, {
								enum: ["first"]
							}]
						}
					}
				},
				ArrayExpression: {
					oneOf: [{
						type: "integer",
						minimum: 0
					}, {
						enum: ["first"]
					}]
				},
				ObjectExpression: {
					oneOf: [{
						type: "integer",
						minimum: 0
					}, {
						enum: ["first"]
					}]
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var DEFAULT_VARIABLE_INDENT = 1;
		var DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config
		var DEFAULT_FUNCTION_BODY_INDENT = 1;

		var indentType = "space";
		var indentSize = 4;
		var options = {
			SwitchCase: 0,
			VariableDeclarator: {
				var: DEFAULT_VARIABLE_INDENT,
				let: DEFAULT_VARIABLE_INDENT,
				const: DEFAULT_VARIABLE_INDENT
			},
			outerIIFEBody: null,
			FunctionDeclaration: {
				parameters: DEFAULT_PARAMETER_INDENT,
				body: DEFAULT_FUNCTION_BODY_INDENT
			},
			FunctionExpression: {
				parameters: DEFAULT_PARAMETER_INDENT,
				body: DEFAULT_FUNCTION_BODY_INDENT
			},
			CallExpression: {
				arguments: DEFAULT_PARAMETER_INDENT
			},
			ArrayExpression: 1,
			ObjectExpression: 1
		};

		var sourceCode = context.getSourceCode();

		if (context.options.length) {
			if (context.options[0] === "tab") {
				indentSize = 1;
				indentType = "tab";
			} else /* istanbul ignore else : this will be caught by options validation */if (typeof context.options[0] === "number") {
					indentSize = context.options[0];
					indentType = "space";
				}

			if (context.options[1]) {
				var opts = context.options[1];

				options.SwitchCase = opts.SwitchCase || 0;
				var variableDeclaratorRules = opts.VariableDeclarator;

				if (typeof variableDeclaratorRules === "number") {
					options.VariableDeclarator = {
						var: variableDeclaratorRules,
						let: variableDeclaratorRules,
						const: variableDeclaratorRules
					};
				} else if ((typeof variableDeclaratorRules === "undefined" ? "undefined" : _typeof(variableDeclaratorRules)) === "object") {
					Object.assign(options.VariableDeclarator, variableDeclaratorRules);
				}

				if (typeof opts.outerIIFEBody === "number") {
					options.outerIIFEBody = opts.outerIIFEBody;
				}

				if (typeof opts.MemberExpression === "number") {
					options.MemberExpression = opts.MemberExpression;
				}

				if (_typeof(opts.FunctionDeclaration) === "object") {
					Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);
				}

				if (_typeof(opts.FunctionExpression) === "object") {
					Object.assign(options.FunctionExpression, opts.FunctionExpression);
				}

				if (_typeof(opts.CallExpression) === "object") {
					Object.assign(options.CallExpression, opts.CallExpression);
				}

				if (typeof opts.ArrayExpression === "number" || typeof opts.ArrayExpression === "string") {
					options.ArrayExpression = opts.ArrayExpression;
				}

				if (typeof opts.ObjectExpression === "number" || typeof opts.ObjectExpression === "string") {
					options.ObjectExpression = opts.ObjectExpression;
				}
			}
		}

		var caseIndentStore = {};
		function createErrorMessage(expectedAmount, actualSpaces, actualTabs) {
			var expectedStatement = expectedAmount + " " + indentType + (expectedAmount === 1 ? "" : "s"); // e.g. "2 tabs"
			var foundSpacesWord = "space" + (actualSpaces === 1 ? "" : "s"); // e.g. "space"
			var foundTabsWord = "tab" + (actualTabs === 1 ? "" : "s"); // e.g. "tabs"
			var foundStatement = void 0;

			if (actualSpaces > 0 && actualTabs > 0) {
				foundStatement = actualSpaces + " " + foundSpacesWord + " and " + actualTabs + " " + foundTabsWord; // e.g. "1 space and 2 tabs"
			} else if (actualSpaces > 0) {
				foundStatement = indentType === "space" ? actualSpaces : actualSpaces + " " + foundSpacesWord;
			} else if (actualTabs > 0) {
				foundStatement = indentType === "tab" ? actualTabs : actualTabs + " " + foundTabsWord;
			} else {
				foundStatement = "0";
			}

			return "Expected indentation of " + expectedStatement + " but found " + foundStatement + ".";
		}
		function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {
			if (gottenSpaces && gottenTabs) {
				return;
			}

			var desiredIndent = (indentType === "space" ? " " : "\t").repeat(needed);

			var textRange = isLastNodeCheck ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs] : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];

			context.report({
				node: node,
				loc: loc,
				message: createErrorMessage(needed, gottenSpaces, gottenTabs),
				fix: function fix(fixer) {
					return fixer.replaceTextRange(textRange, desiredIndent);
				}
			});
		}
		function getNodeIndent(node, byLastLine) {
			var token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);
			var srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split("");
			var indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(function (char) {
				return char !== " " && char !== "\t";
			}));
			var spaces = indentChars.filter(function (char) {
				return char === " ";
			}).length;
			var tabs = indentChars.filter(function (char) {
				return char === "\t";
			}).length;

			return {
				space: spaces,
				tab: tabs,
				goodChar: indentType === "space" ? spaces : tabs,
				badChar: indentType === "space" ? tabs : spaces
			};
		}
		function isNodeFirstInLine(node, byEndLocation) {
			var firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),
				startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,
				endLine = firstToken ? firstToken.loc.end.line : -1;

			return startLine !== endLine;
		}
		function checkNodeIndent(node, neededIndent) {
			var actualIndent = getNodeIndent(node, false);

			if (node.type !== "ArrayExpression" && node.type !== "ObjectExpression" && (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) && isNodeFirstInLine(node)) {
				report(node, neededIndent, actualIndent.space, actualIndent.tab);
			}

			if (node.type === "IfStatement" && node.alternate) {
				var elseToken = sourceCode.getTokenBefore(node.alternate);

				checkNodeIndent(elseToken, neededIndent);

				if (!isNodeFirstInLine(node.alternate)) {
					checkNodeIndent(node.alternate, neededIndent);
				}
			}

			if (node.type === "TryStatement" && node.handler) {
				var catchToken = sourceCode.getFirstToken(node.handler);

				checkNodeIndent(catchToken, neededIndent);
			}

			if (node.type === "TryStatement" && node.finalizer) {
				var finallyToken = sourceCode.getTokenBefore(node.finalizer);

				checkNodeIndent(finallyToken, neededIndent);
			}

			if (node.type === "DoWhileStatement") {
				var whileToken = sourceCode.getTokenAfter(node.body);

				checkNodeIndent(whileToken, neededIndent);
			}
		}
		function checkNodesIndent(nodes, indent) {
			nodes.forEach(function (node) {
				return checkNodeIndent(node, indent);
			});
		}
		function checkLastNodeLineIndent(node, lastLineIndent) {
			var lastToken = sourceCode.getLastToken(node);
			var endIndent = getNodeIndent(lastToken, true);

			if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {
				report(node, lastLineIndent, endIndent.space, endIndent.tab, { line: lastToken.loc.start.line, column: lastToken.loc.start.column }, true);
			}
		}
		function checkLastReturnStatementLineIndent(node, firstLineIndent) {
			var lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);
			var textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);

			if (textBeforeClosingParenthesis.trim()) {
				return;
			}

			var endIndent = getNodeIndent(lastToken, true);

			if (endIndent.goodChar !== firstLineIndent) {
				report(node, firstLineIndent, endIndent.space, endIndent.tab, { line: lastToken.loc.start.line, column: lastToken.loc.start.column }, true);
			}
		}
		function checkFirstNodeLineIndent(node, firstLineIndent) {
			var startIndent = getNodeIndent(node, false);

			if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {
				report(node, firstLineIndent, startIndent.space, startIndent.tab, { line: node.loc.start.line, column: node.loc.start.column });
			}
		}
		function getParentNodeByType(node, type, stopAtList) {
			var parent = node.parent;

			if (!stopAtList) {
				stopAtList = ["Program"];
			}

			while (parent.type !== type && stopAtList.indexOf(parent.type) === -1 && parent.type !== "Program") {
				parent = parent.parent;
			}

			return parent.type === type ? parent : null;
		}
		function getVariableDeclaratorNode(node) {
			return getParentNodeByType(node, "VariableDeclarator");
		}
		function isNodeInVarOnTop(node, varNode) {
			return varNode && varNode.parent.loc.start.line === node.loc.start.line && varNode.parent.declarations.length > 1;
		}
		function isArgBeforeCalleeNodeMultiline(node) {
			var parent = node.parent;

			if (parent.arguments.length >= 2 && parent.arguments[1] === node) {
				return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;
			}

			return false;
		}
		function isOuterIIFE(node) {
			var parent = node.parent;
			var stmt = parent.parent;
			if (parent.type !== "CallExpression" || parent.callee !== node) {

				return false;
			}
			while (stmt.type === "UnaryExpression" && (stmt.operator === "!" || stmt.operator === "~" || stmt.operator === "+" || stmt.operator === "-") || stmt.type === "AssignmentExpression" || stmt.type === "LogicalExpression" || stmt.type === "SequenceExpression" || stmt.type === "VariableDeclarator") {

				stmt = stmt.parent;
			}

			return (stmt.type === "ExpressionStatement" || stmt.type === "VariableDeclaration") && stmt.parent && stmt.parent.type === "Program";
		}
		function checkIndentInFunctionBlock(node) {
			var calleeNode = node.parent; // FunctionExpression
			var indent = void 0;

			if (calleeNode.parent && (calleeNode.parent.type === "Property" || calleeNode.parent.type === "ArrayExpression")) {
				indent = getNodeIndent(calleeNode, false).goodChar;
			} else {
				indent = getNodeIndent(calleeNode).goodChar;
			}

			if (calleeNode.parent.type === "CallExpression") {
				var calleeParent = calleeNode.parent;

				if (calleeNode.type !== "FunctionExpression" && calleeNode.type !== "ArrowFunctionExpression") {
					if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {
						indent = getNodeIndent(calleeParent).goodChar;
					}
				} else {
					if (isArgBeforeCalleeNodeMultiline(calleeNode) && calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {
						indent = getNodeIndent(calleeParent).goodChar;
					}
				}
			}
			var functionOffset = indentSize;

			if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {
				functionOffset = options.outerIIFEBody * indentSize;
			} else if (calleeNode.type === "FunctionExpression") {
				functionOffset = options.FunctionExpression.body * indentSize;
			} else if (calleeNode.type === "FunctionDeclaration") {
				functionOffset = options.FunctionDeclaration.body * indentSize;
			}
			indent += functionOffset;
			var parentVarNode = getVariableDeclaratorNode(node);

			if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {
				indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
			}

			if (node.body.length > 0) {
				checkNodesIndent(node.body, indent);
			}

			checkLastNodeLineIndent(node, indent - functionOffset);
		}
		function isSingleLineNode(node) {
			var lastToken = sourceCode.getLastToken(node),
				startLine = node.loc.start.line,
				endLine = lastToken.loc.end.line;

			return startLine === endLine;
		}
		function isFirstArrayElementOnSameLine(node) {
			if (node.type === "ArrayExpression" && node.elements[0]) {
				return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === "ObjectExpression";
			}
			return false;
		}
		function checkIndentInArrayOrObjectBlock(node) {
			if (isSingleLineNode(node)) {
				return;
			}

			var elements = node.type === "ArrayExpression" ? node.elements : node.properties;
			elements = elements.filter(function (elem) {
				return elem !== null;
			});

			var nodeIndent = void 0;
			var elementsIndent = void 0;
			var parentVarNode = getVariableDeclaratorNode(node);
			if (isNodeFirstInLine(node)) {
				var parent = node.parent;

				nodeIndent = getNodeIndent(parent).goodChar;
				if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {
					if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
						if (parent.type === "VariableDeclarator" && parentVarNode.loc.start.line === parent.loc.start.line) {
							nodeIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
						} else if (parent.type === "ObjectExpression" || parent.type === "ArrayExpression") {
							var parentElements = node.parent.type === "ObjectExpression" ? node.parent.properties : node.parent.elements;

							if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) {
							} else if (typeof options[parent.type] === "number") {
								nodeIndent += options[parent.type] * indentSize;
							} else {
								nodeIndent = parentElements[0].loc.start.column;
							}
						} else if (parent.type === "CallExpression" || parent.type === "NewExpression") {
							if (typeof options.CallExpression.arguments === "number") {
								nodeIndent += options.CallExpression.arguments * indentSize;
							} else if (options.CallExpression.arguments === "first") {
								if (parent.arguments.indexOf(node) !== -1) {
									nodeIndent = parent.arguments[0].loc.start.column;
								}
							} else {
								nodeIndent += indentSize;
							}
						} else if (parent.type === "LogicalExpression" || parent.type === "ArrowFunctionExpression") {
							nodeIndent += indentSize;
						}
					}
				} else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && parent.type !== "MemberExpression" && parent.type !== "ExpressionStatement" && parent.type !== "AssignmentExpression" && parent.type !== "Property") {
					nodeIndent += indentSize;
				}

				checkFirstNodeLineIndent(node, nodeIndent);
			} else {
				nodeIndent = getNodeIndent(node).goodChar;
			}

			if (options[node.type] === "first") {
				elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.
			} else {
				elementsIndent = nodeIndent + indentSize * options[node.type];
			}
			if (isNodeInVarOnTop(node, parentVarNode)) {
				elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
			}

			checkNodesIndent(elements, elementsIndent);

			if (elements.length > 0) {
				if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
					return;
				}
			}

			checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));
		}
		function isNodeBodyBlock(node) {
			return node.type === "BlockStatement" || node.type === "ClassBody" || node.body && node.body.type === "BlockStatement" || node.consequent && node.consequent.type === "BlockStatement";
		}
		function blockIndentationCheck(node) {
			if (isSingleLineNode(node)) {
				return;
			}

			if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "FunctionDeclaration" || node.parent.type === "ArrowFunctionExpression")) {
				checkIndentInFunctionBlock(node);
				return;
			}

			var indent = void 0;
			var nodesToCheck = [];
			var statementsWithProperties = ["IfStatement", "WhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DoWhileStatement", "ClassDeclaration", "TryStatement"];

			if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {
				indent = getNodeIndent(node.parent).goodChar;
			} else if (node.parent && node.parent.type === "CatchClause") {
				indent = getNodeIndent(node.parent.parent).goodChar;
			} else {
				indent = getNodeIndent(node).goodChar;
			}

			if (node.type === "IfStatement" && node.consequent.type !== "BlockStatement") {
				nodesToCheck = [node.consequent];
			} else if (Array.isArray(node.body)) {
				nodesToCheck = node.body;
			} else {
				nodesToCheck = [node.body];
			}

			if (nodesToCheck.length > 0) {
				checkNodesIndent(nodesToCheck, indent + indentSize);
			}

			if (node.type === "BlockStatement") {
				checkLastNodeLineIndent(node, indent);
			}
		}
		function filterOutSameLineVars(node) {
			return node.declarations.reduce(function (finalCollection, elem) {
				var lastElem = finalCollection[finalCollection.length - 1];

				if (elem.loc.start.line !== node.loc.start.line && !lastElem || lastElem && lastElem.loc.start.line !== elem.loc.start.line) {
					finalCollection.push(elem);
				}

				return finalCollection;
			}, []);
		}
		function checkIndentInVariableDeclarations(node) {
			var elements = filterOutSameLineVars(node);
			var nodeIndent = getNodeIndent(node).goodChar;
			var lastElement = elements[elements.length - 1];

			var elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];

			checkNodesIndent(elements, elementsIndent);
			if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {
				return;
			}

			var tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);

			if (tokenBeforeLastElement.value === ",") {
				checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);
			} else {
				checkLastNodeLineIndent(node, elementsIndent - indentSize);
			}
		}
		function blockLessNodes(node) {
			if (node.body.type !== "BlockStatement") {
				blockIndentationCheck(node);
			}
		}
		function expectedCaseIndent(node, switchIndent) {
			var switchNode = node.type === "SwitchStatement" ? node : node.parent;
			var caseIndent = void 0;

			if (caseIndentStore[switchNode.loc.start.line]) {
				return caseIndentStore[switchNode.loc.start.line];
			}
			if (typeof switchIndent === "undefined") {
				switchIndent = getNodeIndent(switchNode).goodChar;
			}

			if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
				caseIndent = switchIndent;
			} else {
				caseIndent = switchIndent + indentSize * options.SwitchCase;
			}

			caseIndentStore[switchNode.loc.start.line] = caseIndent;
			return caseIndent;
		}
		function isWrappedInParenthesis(node) {
			var regex = /^return\s*?\(\s*?\);*?/;

			var statementWithoutArgument = sourceCode.getText(node).replace(sourceCode.getText(node.argument), "");

			return regex.test(statementWithoutArgument);
		}

		return {
			Program: function Program(node) {
				if (node.body.length > 0) {
					checkNodesIndent(node.body, getNodeIndent(node).goodChar);
				}
			},


			ClassBody: blockIndentationCheck,

			BlockStatement: blockIndentationCheck,

			WhileStatement: blockLessNodes,

			ForStatement: blockLessNodes,

			ForInStatement: blockLessNodes,

			ForOfStatement: blockLessNodes,

			DoWhileStatement: blockLessNodes,

			IfStatement: function IfStatement(node) {
				if (node.consequent.type !== "BlockStatement" && node.consequent.loc.start.line > node.loc.start.line) {
					blockIndentationCheck(node);
				}
			},
			VariableDeclaration: function VariableDeclaration(node) {
				if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {
					checkIndentInVariableDeclarations(node);
				}
			},
			ObjectExpression: function ObjectExpression(node) {
				checkIndentInArrayOrObjectBlock(node);
			},
			ArrayExpression: function ArrayExpression(node) {
				checkIndentInArrayOrObjectBlock(node);
			},
			MemberExpression: function MemberExpression(node) {

				if (typeof options.MemberExpression === "undefined") {
					return;
				}

				if (isSingleLineNode(node)) {
					return;
				}
				if (getParentNodeByType(node, "VariableDeclarator", ["FunctionExpression", "ArrowFunctionExpression"])) {
					return;
				}

				if (getParentNodeByType(node, "AssignmentExpression", ["FunctionExpression"])) {
					return;
				}

				var propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;

				var checkNodes = [node.property];

				var dot = sourceCode.getTokenBefore(node.property);

				if (dot.type === "Punctuator" && dot.value === ".") {
					checkNodes.push(dot);
				}

				checkNodesIndent(checkNodes, propertyIndent);
			},
			SwitchStatement: function SwitchStatement(node) {
				var switchIndent = getNodeIndent(node).goodChar;
				var caseIndent = expectedCaseIndent(node, switchIndent);

				checkNodesIndent(node.cases, caseIndent);

				checkLastNodeLineIndent(node, switchIndent);
			},
			SwitchCase: function SwitchCase(node) {
				if (isSingleLineNode(node)) {
					return;
				}
				var caseIndent = expectedCaseIndent(node);

				checkNodesIndent(node.consequent, caseIndent + indentSize);
			},
			FunctionDeclaration: function FunctionDeclaration(node) {
				if (isSingleLineNode(node)) {
					return;
				}
				if (options.FunctionDeclaration.parameters === "first" && node.params.length) {
					checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
				} else if (options.FunctionDeclaration.parameters !== null) {
					checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);
				}
			},
			FunctionExpression: function FunctionExpression(node) {
				if (isSingleLineNode(node)) {
					return;
				}
				if (options.FunctionExpression.parameters === "first" && node.params.length) {
					checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
				} else if (options.FunctionExpression.parameters !== null) {
					checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);
				}
			},
			ReturnStatement: function ReturnStatement(node) {
				if (isSingleLineNode(node)) {
					return;
				}

				var firstLineIndent = getNodeIndent(node).goodChar;
				if (isWrappedInParenthesis(node)) {
					checkLastReturnStatementLineIndent(node, firstLineIndent);
				} else {
					checkNodeIndent(node, firstLineIndent);
				}
			},
			CallExpression: function CallExpression(node) {
				if (isSingleLineNode(node)) {
					return;
				}
				if (options.CallExpression.arguments === "first" && node.arguments.length) {
					checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);
				} else if (options.CallExpression.arguments !== null) {
					checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var lodash = __webpack_require__(10);
var astUtils = __webpack_require__(0);
var createTree = __webpack_require__(439);
var KNOWN_NODES = new Set(["AssignmentExpression", "AssignmentPattern", "ArrayExpression", "ArrayPattern", "ArrowFunctionExpression", "AwaitExpression", "BlockStatement", "BinaryExpression", "BreakStatement", "CallExpression", "CatchClause", "ClassBody", "ClassDeclaration", "ClassExpression", "ConditionalExpression", "ContinueStatement", "DoWhileStatement", "DebuggerStatement", "EmptyStatement", "ExperimentalRestProperty", "ExperimentalSpreadProperty", "ExpressionStatement", "ForStatement", "ForInStatement", "ForOfStatement", "FunctionDeclaration", "FunctionExpression", "Identifier", "IfStatement", "Literal", "LabeledStatement", "LogicalExpression", "MemberExpression", "MetaProperty", "MethodDefinition", "NewExpression", "ObjectExpression", "ObjectPattern", "Program", "Property", "RestElement", "ReturnStatement", "SequenceExpression", "SpreadElement", "Super", "SwitchCase", "SwitchStatement", "TaggedTemplateExpression", "TemplateElement", "TemplateLiteral", "ThisExpression", "ThrowStatement", "TryStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "JSXIdentifier", "JSXNamespacedName", "JSXMemberExpression", "JSXEmptyExpression", "JSXExpressionContainer", "JSXElement", "JSXClosingElement", "JSXOpeningElement", "JSXAttribute", "JSXSpreadAttribute", "JSXText", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "ExportSpecifier", "ImportDeclaration", "ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"]);

var BinarySearchTree = function () {
	function BinarySearchTree() {
		_classCallCheck(this, BinarySearchTree);

		this._rbTree = createTree();
	}


	_createClass(BinarySearchTree, [{
		key: "insert",
		value: function insert(key, value) {
			var iterator = this._rbTree.find(key);

			if (iterator.valid) {
				this._rbTree = iterator.update(value);
			} else {
				this._rbTree = this._rbTree.insert(key, value);
			}
		}

	}, {
		key: "findLe",
		value: function findLe(key) {
			var iterator = this._rbTree.le(key);

			return iterator && { key: iterator.key, value: iterator.value };
		}

	}, {
		key: "deleteRange",
		value: function deleteRange(start, end) {
			if (start === end) {
				return;
			}
			var iterator = this._rbTree.ge(start);

			while (iterator.valid && iterator.key < end) {
				this._rbTree = this._rbTree.remove(iterator.key);
				iterator.next();
			}
		}
	}]);

	return BinarySearchTree;
}();


var TokenInfo = function () {
	function TokenInfo(sourceCode) {
		_classCallCheck(this, TokenInfo);

		this.sourceCode = sourceCode;
		this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce(function (map, token) {
			if (!map.has(token.loc.start.line)) {
				map.set(token.loc.start.line, token);
			}
			if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {
				map.set(token.loc.end.line, token);
			}
			return map;
		}, new Map());
	}


	_createClass(TokenInfo, [{
		key: "getFirstTokenOfLine",
		value: function getFirstTokenOfLine(token) {
			return this.firstTokensByLineNumber.get(token.loc.start.line);
		}

	}, {
		key: "isFirstTokenOfLine",
		value: function isFirstTokenOfLine(token) {
			return this.getFirstTokenOfLine(token) === token;
		}

	}, {
		key: "getTokenIndent",
		value: function getTokenIndent(token) {
			return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);
		}
	}]);

	return TokenInfo;
}();


var OffsetStorage = function () {
	function OffsetStorage(tokenInfo, indentSize, indentType) {
		_classCallCheck(this, OffsetStorage);

		this._tokenInfo = tokenInfo;
		this._indentSize = indentSize;
		this._indentType = indentType;

		this._tree = new BinarySearchTree();
		this._tree.insert(0, { offset: 0, from: null, force: false });

		this._lockedFirstTokens = new WeakMap();
		this._desiredIndentCache = new WeakMap();
		this._ignoredTokens = new WeakSet();
	}

	_createClass(OffsetStorage, [{
		key: "_getOffsetDescriptor",
		value: function _getOffsetDescriptor(token) {
			return this._tree.findLe(token.range[0]).value;
		}

	}, {
		key: "matchOffsetOf",
		value: function matchOffsetOf(baseToken, offsetToken) {
			this._lockedFirstTokens.set(offsetToken, baseToken);
		}

	}, {
		key: "setDesiredOffset",
		value: function setDesiredOffset(token, fromToken, offset) {
			return this.setDesiredOffsets(token.range, fromToken, offset);
		}

	}, {
		key: "setDesiredOffsets",
		value: function setDesiredOffsets(range, fromToken, offset, force) {

			var descriptorToInsert = { offset: offset, from: fromToken, force: force };

			var descriptorAfterRange = this._tree.findLe(range[1]).value;

			var fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];
			var fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);
			this._tree.deleteRange(range[0] + 1, range[1]);
			this._tree.insert(range[0], descriptorToInsert);
			if (fromTokenIsInRange) {
				this._tree.insert(fromToken.range[0], fromTokenDescriptor);
				this._tree.insert(fromToken.range[1], descriptorToInsert);
			}
			this._tree.insert(range[1], descriptorAfterRange);
		}

	}, {
		key: "getDesiredIndent",
		value: function getDesiredIndent(token) {
			if (!this._desiredIndentCache.has(token)) {

				if (this._ignoredTokens.has(token)) {
					this._desiredIndentCache.set(token, this._tokenInfo.getTokenIndent(token));
				} else if (this._lockedFirstTokens.has(token)) {
					var firstToken = this._lockedFirstTokens.get(token);

					this._desiredIndentCache.set(token,
					this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) +
					this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column));
				} else {
					var offsetInfo = this._getOffsetDescriptor(token);
					var offset = offsetInfo.from && offsetInfo.from.loc.start.line === token.loc.start.line && !offsetInfo.force ? 0 : offsetInfo.offset * this._indentSize;

					this._desiredIndentCache.set(token, (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : "") + this._indentType.repeat(offset));
				}
			}
			return this._desiredIndentCache.get(token);
		}

	}, {
		key: "ignoreToken",
		value: function ignoreToken(token) {
			if (this._tokenInfo.isFirstTokenOfLine(token)) {
				this._ignoredTokens.add(token);
			}
		}

	}, {
		key: "getFirstDependency",
		value: function getFirstDependency(token) {
			return this._getOffsetDescriptor(token).from;
		}
	}]);

	return OffsetStorage;
}();

var ELEMENT_LIST_SCHEMA = {
	oneOf: [{
		type: "integer",
		minimum: 0
	}, {
		enum: ["first", "off"]
	}]
};

module.exports = {
	meta: {
		docs: {
			description: "enforce consistent indentation",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["tab"]
			}, {
				type: "integer",
				minimum: 0
			}]
		}, {
			type: "object",
			properties: {
				SwitchCase: {
					type: "integer",
					minimum: 0
				},
				VariableDeclarator: {
					oneOf: [{
						type: "integer",
						minimum: 0
					}, {
						type: "object",
						properties: {
							var: {
								type: "integer",
								minimum: 0
							},
							let: {
								type: "integer",
								minimum: 0
							},
							const: {
								type: "integer",
								minimum: 0
							}
						},
						additionalProperties: false
					}]
				},
				outerIIFEBody: {
					type: "integer",
					minimum: 0
				},
				MemberExpression: {
					oneOf: [{
						type: "integer",
						minimum: 0
					}, {
						enum: ["off"]
					}]
				},
				FunctionDeclaration: {
					type: "object",
					properties: {
						parameters: ELEMENT_LIST_SCHEMA,
						body: {
							type: "integer",
							minimum: 0
						}
					},
					additionalProperties: false
				},
				FunctionExpression: {
					type: "object",
					properties: {
						parameters: ELEMENT_LIST_SCHEMA,
						body: {
							type: "integer",
							minimum: 0
						}
					},
					additionalProperties: false
				},
				CallExpression: {
					type: "object",
					properties: {
						arguments: ELEMENT_LIST_SCHEMA
					},
					additionalProperties: false
				},
				ArrayExpression: ELEMENT_LIST_SCHEMA,
				ObjectExpression: ELEMENT_LIST_SCHEMA,
				ImportDeclaration: ELEMENT_LIST_SCHEMA,
				flatTernaryExpressions: {
					type: "boolean"
				},
				ignoredNodes: {
					type: "array",
					items: {
						type: "string",
						not: {
							pattern: ":exit$"
						}
					}
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var DEFAULT_VARIABLE_INDENT = 1;
		var DEFAULT_PARAMETER_INDENT = 1;
		var DEFAULT_FUNCTION_BODY_INDENT = 1;

		var indentType = "space";
		var indentSize = 4;
		var options = {
			SwitchCase: 0,
			VariableDeclarator: {
				var: DEFAULT_VARIABLE_INDENT,
				let: DEFAULT_VARIABLE_INDENT,
				const: DEFAULT_VARIABLE_INDENT
			},
			outerIIFEBody: 1,
			FunctionDeclaration: {
				parameters: DEFAULT_PARAMETER_INDENT,
				body: DEFAULT_FUNCTION_BODY_INDENT
			},
			FunctionExpression: {
				parameters: DEFAULT_PARAMETER_INDENT,
				body: DEFAULT_FUNCTION_BODY_INDENT
			},
			CallExpression: {
				arguments: DEFAULT_PARAMETER_INDENT
			},
			MemberExpression: 1,
			ArrayExpression: 1,
			ObjectExpression: 1,
			ImportDeclaration: 1,
			flatTernaryExpressions: false,
			ignoredNodes: []
		};

		if (context.options.length) {
			if (context.options[0] === "tab") {
				indentSize = 1;
				indentType = "tab";
			} else {
				indentSize = context.options[0];
				indentType = "space";
			}

			if (context.options[1]) {
				lodash.merge(options, context.options[1]);

				if (typeof options.VariableDeclarator === "number") {
					options.VariableDeclarator = {
						var: options.VariableDeclarator,
						let: options.VariableDeclarator,
						const: options.VariableDeclarator
					};
				}
			}
		}

		var sourceCode = context.getSourceCode();
		var tokenInfo = new TokenInfo(sourceCode);
		var offsets = new OffsetStorage(tokenInfo, indentSize, indentType === "space" ? " " : "\t");
		var parameterParens = new WeakSet();
		function createErrorMessage(expectedAmount, actualSpaces, actualTabs) {
			var expectedStatement = expectedAmount + " " + indentType + (expectedAmount === 1 ? "" : "s"); // e.g. "2 tabs"
			var foundSpacesWord = "space" + (actualSpaces === 1 ? "" : "s"); // e.g. "space"
			var foundTabsWord = "tab" + (actualTabs === 1 ? "" : "s"); // e.g. "tabs"
			var foundStatement = void 0;

			if (actualSpaces > 0) {
				foundStatement = indentType === "space" ? actualSpaces : actualSpaces + " " + foundSpacesWord;
			} else if (actualTabs > 0) {
				foundStatement = indentType === "tab" ? actualTabs : actualTabs + " " + foundTabsWord;
			} else {
				foundStatement = "0";
			}

			return "Expected indentation of " + expectedStatement + " but found " + foundStatement + ".";
		}
		function report(token, neededIndent) {
			var actualIndent = Array.from(tokenInfo.getTokenIndent(token));
			var numSpaces = actualIndent.filter(function (char) {
				return char === " ";
			}).length;
			var numTabs = actualIndent.filter(function (char) {
				return char === "\t";
			}).length;

			context.report({
				node: token,
				message: createErrorMessage(neededIndent.length, numSpaces, numTabs),
				loc: {
					start: { line: token.loc.start.line, column: 0 },
					end: { line: token.loc.start.line, column: token.loc.start.column }
				},
				fix: function fix(fixer) {
					var range = [token.range[0] - token.loc.start.column, token.range[0]];
					var newText = neededIndent;

					return fixer.replaceTextRange(range, newText);
				}
			});
		}
		function validateTokenIndent(token, desiredIndent) {
			var indentation = tokenInfo.getTokenIndent(token);

			return indentation === desiredIndent ||
			indentation.includes(" ") && indentation.includes("\t");
		}
		function isOuterIIFE(node) {
			if (!node.parent || node.parent.type !== "CallExpression" || node.parent.callee !== node) {
				return false;
			}
			var statement = node.parent && node.parent.parent;

			while (statement.type === "UnaryExpression" && ["!", "~", "+", "-"].indexOf(statement.operator) > -1 || statement.type === "AssignmentExpression" || statement.type === "LogicalExpression" || statement.type === "SequenceExpression" || statement.type === "VariableDeclarator") {
				statement = statement.parent;
			}

			return (statement.type === "ExpressionStatement" || statement.type === "VariableDeclaration") && statement.parent.type === "Program";
		}
		function addElementListIndent(elements, startToken, endToken, offset) {
			function getFirstToken(element) {
				var token = sourceCode.getTokenBefore(element);

				while (astUtils.isOpeningParenToken(token) && token !== startToken) {
					token = sourceCode.getTokenBefore(token);
				}
				return sourceCode.getTokenAfter(token);
			}
			offsets.setDesiredOffsets([startToken.range[1], endToken.range[0]], startToken, typeof offset === "number" ? offset : 1);
			offsets.setDesiredOffset(endToken, startToken, 0);
			if (offset === "first" && elements.length && !elements[0]) {
				return;
			}
			elements.forEach(function (element, index) {
				if (!element) {
					return;
				}
				if (offset === "off") {
					offsets.ignoreToken(getFirstToken(element));
				}
				if (index === 0) {
					return;
				}
				if (offset === "first" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {
					offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));
				} else {
					var previousElement = elements[index - 1];
					var firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);

					if (previousElement && sourceCode.getLastToken(previousElement).loc.start.line > startToken.loc.end.line) {
						offsets.setDesiredOffsets(element.range, firstTokenOfPreviousElement, 0);
					}
				}
			});
		}
		function addBlocklessNodeIndent(node) {
			if (node.type !== "BlockStatement") {
				var lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);

				var firstBodyToken = sourceCode.getFirstToken(node);
				var lastBodyToken = sourceCode.getLastToken(node);

				while (astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) && astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))) {
					firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);
					lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);
				}

				offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);
				var lastToken = sourceCode.getLastToken(node);

				if (node.type !== "EmptyStatement" && astUtils.isSemicolonToken(lastToken)) {
					offsets.setDesiredOffset(lastToken, lastParentToken, 0);
				}
			}
		}
		function addFunctionCallIndent(node) {
			var openingParen = void 0;

			if (node.arguments.length) {
				openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);
			} else {
				openingParen = sourceCode.getLastToken(node, 1);
			}
			var closingParen = sourceCode.getLastToken(node);

			parameterParens.add(openingParen);
			parameterParens.add(closingParen);
			offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);

			addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);
		}
		function addParensIndent(tokens) {
			var parenStack = [];
			var parenPairs = [];

			tokens.forEach(function (nextToken) {
				if (astUtils.isOpeningParenToken(nextToken)) {
					parenStack.push(nextToken);
				} else if (astUtils.isClosingParenToken(nextToken)) {
					parenPairs.unshift({ left: parenStack.pop(), right: nextToken });
				}
			});

			parenPairs.forEach(function (pair) {
				var leftParen = pair.left;
				var rightParen = pair.right;
				if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {
					var parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));

					parenthesizedTokens.forEach(function (token) {
						if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {
							offsets.setDesiredOffset(token, leftParen, 1);
						}
					});
				}

				offsets.setDesiredOffset(rightParen, leftParen, 0);
			});
		}
		function ignoreNode(node) {
			var unknownNodeTokens = new Set(sourceCode.getTokens(node, { includeComments: true }));

			unknownNodeTokens.forEach(function (token) {
				if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {
					var firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);

					if (token === firstTokenOfLine) {
						offsets.ignoreToken(token);
					} else {
						offsets.setDesiredOffset(token, firstTokenOfLine, 0);
					}
				}
			});
		}
		function isOnFirstLineOfStatement(token, leafNode) {
			var node = leafNode;

			while (node.parent && !node.parent.type.endsWith("Statement") && !node.parent.type.endsWith("Declaration")) {
				node = node.parent;
			}
			node = node.parent;

			return !node || node.loc.start.line === token.loc.start.line;
		}

		var baseOffsetListeners = {
			"ArrayExpression, ArrayPattern": function ArrayExpressionArrayPattern(node) {
				var openingBracket = sourceCode.getFirstToken(node);
				var closingBracket = sourceCode.getTokenAfter(lodash.findLast(node.elements) || openingBracket, astUtils.isClosingBracketToken);

				addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);
			},
			"ObjectExpression, ObjectPattern": function ObjectExpressionObjectPattern(node) {
				var openingCurly = sourceCode.getFirstToken(node);
				var closingCurly = sourceCode.getTokenAfter(node.properties.length ? node.properties[node.properties.length - 1] : openingCurly, astUtils.isClosingBraceToken);

				addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);
			},
			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
				var firstToken = sourceCode.getFirstToken(node);

				if (astUtils.isOpeningParenToken(firstToken)) {
					var openingParen = firstToken;
					var closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);

					parameterParens.add(openingParen);
					parameterParens.add(closingParen);
					addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);
				}
				addBlocklessNodeIndent(node.body);

				var arrowToken = void 0;

				if (node.params.length) {
					arrowToken = sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isArrowToken);
				} else {
					arrowToken = sourceCode.getFirstToken(node, astUtils.isArrowToken);
				}
				offsets.setDesiredOffset(arrowToken, sourceCode.getFirstToken(node), 0);
			},
			AssignmentExpression: function AssignmentExpression(node) {
				var operator = sourceCode.getFirstTokenBetween(node.left, node.right, function (token) {
					return token.value === node.operator;
				});

				offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);
				offsets.ignoreToken(operator);
				offsets.ignoreToken(sourceCode.getTokenAfter(operator));
			},
			"BinaryExpression, LogicalExpression": function BinaryExpressionLogicalExpression(node) {
				var operator = sourceCode.getFirstTokenBetween(node.left, node.right, function (token) {
					return token.value === node.operator;
				});

				var tokenAfterOperator = sourceCode.getTokenAfter(operator);

				offsets.ignoreToken(operator);
				offsets.ignoreToken(tokenAfterOperator);
				offsets.setDesiredOffset(tokenAfterOperator, operator, 0);
				offsets.setDesiredOffsets([tokenAfterOperator.range[1], node.range[1]], tokenAfterOperator, 1);
			},
			"BlockStatement, ClassBody": function BlockStatementClassBody(node) {

				var blockIndentLevel = void 0;

				if (node.parent && isOuterIIFE(node.parent)) {
					blockIndentLevel = options.outerIIFEBody;
				} else if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "ArrowFunctionExpression")) {
					blockIndentLevel = options.FunctionExpression.body;
				} else if (node.parent && node.parent.type === "FunctionDeclaration") {
					blockIndentLevel = options.FunctionDeclaration.body;
				} else {
					blockIndentLevel = 1;
				}
				if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
					offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);
				}
				addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);
			},


			CallExpression: addFunctionCallIndent,

			"ClassDeclaration[superClass], ClassExpression[superClass]": function ClassDeclarationSuperClassClassExpressionSuperClass(node) {
				var classToken = sourceCode.getFirstToken(node);
				var extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);

				offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);
			},
			ConditionalExpression: function ConditionalExpression(node) {
				var firstToken = sourceCode.getFirstToken(node);
				if (!options.flatTernaryExpressions || !astUtils.isTokenOnSameLine(node.test, node.consequent) || isOnFirstLineOfStatement(firstToken, node)) {
					var questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, function (token) {
						return token.type === "Punctuator" && token.value === "?";
					});
					var colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, function (token) {
						return token.type === "Punctuator" && token.value === ":";
					});

					var firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken, { includeComments: true });
					var lastConsequentToken = sourceCode.getTokenBefore(colonToken, { includeComments: true });
					var firstAlternateToken = sourceCode.getTokenAfter(colonToken);

					offsets.setDesiredOffset(questionMarkToken, firstToken, 1);
					offsets.setDesiredOffset(colonToken, firstToken, 1);

					offsets.setDesiredOffset(firstConsequentToken, firstToken, 1);
					if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {
						offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);
					} else {
						offsets.setDesiredOffset(firstAlternateToken, firstToken, 1);
					}

					offsets.setDesiredOffsets([questionMarkToken.range[1], colonToken.range[0]], firstConsequentToken, 0);
					offsets.setDesiredOffsets([colonToken.range[1], node.range[1]], firstAlternateToken, 0);
				}
			},


			"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement": function DoWhileStatementWhileStatementForInStatementForOfStatement(node) {
				return addBlocklessNodeIndent(node.body);
			},

			ExportNamedDeclaration: function ExportNamedDeclaration(node) {
				if (node.declaration === null) {
					var closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);
					addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, { skip: 1 }), closingCurly, 1);

					if (node.source) {
						offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);
					}
				}
			},
			ForStatement: function ForStatement(node) {
				var forOpeningParen = sourceCode.getFirstToken(node, 1);

				if (node.init) {
					offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);
				}
				if (node.test) {
					offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);
				}
				if (node.update) {
					offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);
				}
				addBlocklessNodeIndent(node.body);
			},
			"FunctionDeclaration, FunctionExpression": function FunctionDeclarationFunctionExpression(node) {
				var closingParen = sourceCode.getTokenBefore(node.body);
				var openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);

				parameterParens.add(openingParen);
				parameterParens.add(closingParen);
				addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);
			},
			IfStatement: function IfStatement(node) {
				addBlocklessNodeIndent(node.consequent);
				if (node.alternate && node.alternate.type !== "IfStatement") {
					addBlocklessNodeIndent(node.alternate);
				}
			},
			ImportDeclaration: function ImportDeclaration(node) {
				if (node.specifiers.some(function (specifier) {
					return specifier.type === "ImportSpecifier";
				})) {
					var openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);
					var closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);

					addElementListIndent(node.specifiers.filter(function (specifier) {
						return specifier.type === "ImportSpecifier";
					}), openingCurly, closingCurly, options.ImportDeclaration);
				}

				var fromToken = sourceCode.getLastToken(node, function (token) {
					return token.type === "Identifier" && token.value === "from";
				});

				if (fromToken) {
					offsets.setDesiredOffsets([fromToken.range[0], node.range[1]], sourceCode.getFirstToken(node), 1);
				}
			},
			"MemberExpression, JSXMemberExpression, MetaProperty": function MemberExpressionJSXMemberExpressionMetaProperty(node) {
				var object = node.type === "MetaProperty" ? node.meta : node.object;
				var firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);
				var secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);

				var objectParenCount = sourceCode.getTokensBetween(object, node.property, { filter: astUtils.isClosingParenToken }).length;
				var firstObjectToken = objectParenCount ? sourceCode.getTokenBefore(object, { skip: objectParenCount - 1 }) : sourceCode.getFirstToken(object);
				var lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);
				var firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;

				if (node.computed) {
					offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);
					offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);
				}
				var offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line ? lastObjectToken : firstObjectToken;

				if (typeof options.MemberExpression === "number") {
					offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);
					offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);
				} else {
					offsets.ignoreToken(firstNonObjectToken);
					offsets.ignoreToken(secondNonObjectToken);
					offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);
					offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);
				}
			},
			NewExpression: function NewExpression(node) {
				if (node.arguments.length > 0 || astUtils.isClosingParenToken(sourceCode.getLastToken(node)) && astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {
					addFunctionCallIndent(node);
				}
			},
			Property: function Property(node) {
				if (!node.shorthand && !node.method && node.kind === "init") {
					var colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);

					offsets.ignoreToken(sourceCode.getTokenAfter(colon));
				}
			},
			SwitchStatement: function SwitchStatement(node) {
				var openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);
				var closingCurly = sourceCode.getLastToken(node);
				var caseKeywords = node.cases.map(function (switchCase) {
					return sourceCode.getFirstToken(switchCase);
				});

				offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);

				node.cases.forEach(function (switchCase, index) {
					var caseKeyword = caseKeywords[index];

					if (!(switchCase.consequent.length === 1 && switchCase.consequent[0].type === "BlockStatement")) {
						var tokenAfterCurrentCase = index === node.cases.length - 1 ? closingCurly : caseKeywords[index + 1];

						offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);
					}
				});

				if (node.cases.length) {
					sourceCode.getTokensBetween(node.cases[node.cases.length - 1], closingCurly, { includeComments: true, filter: astUtils.isCommentToken }).forEach(function (token) {
						return offsets.ignoreToken(token);
					});
				}
			},
			TemplateLiteral: function TemplateLiteral(node) {
				node.expressions.forEach(function (expression, index) {
					var previousQuasi = node.quasis[index];
					var nextQuasi = node.quasis[index + 1];
					var tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line ? sourceCode.getFirstToken(previousQuasi) : null;

					offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);
					offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);
				});
			},
			VariableDeclaration: function VariableDeclaration(node) {
				var variableIndent = options.VariableDeclarator.hasOwnProperty(node.kind) ? options.VariableDeclarator[node.kind] : DEFAULT_VARIABLE_INDENT;

				if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {
					var firstToken = sourceCode.getFirstToken(node);

					offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);
				} else {
					offsets.setDesiredOffsets(node.range, sourceCode.getFirstToken(node), variableIndent);
				}
				var lastToken = sourceCode.getLastToken(node);

				if (astUtils.isSemicolonToken(lastToken)) {
					offsets.ignoreToken(lastToken);
				}
			},
			VariableDeclarator: function VariableDeclarator(node) {
				if (node.init) {
					var equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);
					var tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);

					offsets.ignoreToken(equalOperator);
					offsets.ignoreToken(tokenAfterOperator);
					offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);
					offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);
				}
			},
			"JSXAttribute[value]": function JSXAttributeValue(node) {
				var equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, function (token) {
					return token.type === "Punctuator" && token.value === "=";
				});

				offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);
			},
			JSXElement: function JSXElement(node) {
				if (node.closingElement) {
					addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);
				}
			},
			JSXOpeningElement: function JSXOpeningElement(node) {
				var firstToken = sourceCode.getFirstToken(node);
				var closingToken = void 0;

				if (node.selfClosing) {
					closingToken = sourceCode.getLastToken(node, { skip: 1 });
					offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);
				} else {
					closingToken = sourceCode.getLastToken(node);
				}
				offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));
				addElementListIndent(node.attributes, firstToken, closingToken, 1);
			},
			JSXClosingElement: function JSXClosingElement(node) {
				var firstToken = sourceCode.getFirstToken(node);

				offsets.setDesiredOffsets(node.name.range, firstToken, 1);
				offsets.setDesiredOffset(sourceCode.getLastToken(node), firstToken, 0);
			},
			JSXExpressionContainer: function JSXExpressionContainer(node) {
				var openingCurly = sourceCode.getFirstToken(node);
				var closingCurly = sourceCode.getLastToken(node);

				offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);
				offsets.setDesiredOffset(closingCurly, openingCurly, 0);
			}
		};

		var listenerCallQueue = [];
		var offsetListeners = lodash.mapValues(baseOffsetListeners,
		function (listener) {
			return function (node) {
				return listenerCallQueue.push({ listener: listener, node: node });
			};
		});
		var ignoredNodes = new Set();
		var addToIgnoredNodes = ignoredNodes.add.bind(ignoredNodes);

		var ignoredNodeListeners = options.ignoredNodes.reduce(function (listeners, ignoredSelector) {
			return Object.assign(listeners, _defineProperty({}, ignoredSelector, addToIgnoredNodes));
		}, {});
		return Object.assign(offsetListeners, ignoredNodeListeners, {
			"*:exit": function exit(node) {
				if (!KNOWN_NODES.has(node.type)) {
					ignoredNodes.add(node);
				}
			},
			"Program:exit": function ProgramExit() {
				listenerCallQueue.filter(function (nodeInfo) {
					return !ignoredNodes.has(nodeInfo.node);
				}).forEach(function (nodeInfo) {
					return nodeInfo.listener(nodeInfo.node);
				});
				ignoredNodes.forEach(ignoreNode);

				addParensIndent(sourceCode.ast.tokens);
				var precedingTokens = sourceCode.ast.comments.reduce(function (commentMap, comment) {
					var tokenOrCommentBefore = sourceCode.getTokenBefore(comment, { includeComments: true });

					return commentMap.set(comment, commentMap.has(tokenOrCommentBefore) ? commentMap.get(tokenOrCommentBefore) : tokenOrCommentBefore);
				}, new WeakMap());

				sourceCode.lines.forEach(function (line, lineIndex) {
					var lineNumber = lineIndex + 1;

					if (!tokenInfo.firstTokensByLineNumber.has(lineNumber)) {
						return;
					}

					var firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(lineNumber);

					if (firstTokenOfLine.loc.start.line !== lineNumber) {
						return;
					}
					if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {
						return;
					}

					if (astUtils.isCommentToken(firstTokenOfLine)) {
						var tokenBefore = precedingTokens.get(firstTokenOfLine);
						var tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];
						if (tokenBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) || tokenAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))) {
							return;
						}
					}
					report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));
				});
			}
		});
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = createRBTree;

var RED = 0;
var BLACK = 1;

function RBNode(color, key, value, left, right, count) {
  this._color = color;
  this.key = key;
  this.value = value;
  this.left = left;
  this.right = right;
  this._count = count;
}

function cloneNode(node) {
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);
}

function repaint(color, node) {
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count);
}

function recount(node) {
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);
}

function RedBlackTree(compare, root) {
  this._compare = compare;
  this.root = root;
}

var proto = RedBlackTree.prototype;

Object.defineProperty(proto, "keys", {
  get: function get() {
	var result = [];
	this.forEach(function (k, v) {
			result.push(k);
	});
	return result;
  }
});

Object.defineProperty(proto, "values", {
  get: function get() {
	var result = [];
	this.forEach(function (k, v) {
			result.push(v);
	});
	return result;
  }
});
Object.defineProperty(proto, "length", {
  get: function get() {
	if (this.root) {
			return this.root._count;
	}
	return 0;
  }
});
proto.insert = function (key, value) {
  var cmp = this._compare;
  var n = this.root;
  var n_stack = [];
  var d_stack = [];
  while (n) {
	var d = cmp(key, n.key);
	n_stack.push(n);
	d_stack.push(d);
	if (d <= 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  n_stack.push(new RBNode(RED, key, value, null, null, 1));
  for (var s = n_stack.length - 2; s >= 0; --s) {
	var n = n_stack[s];
	if (d_stack[s] <= 0) {
			n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1);
	} else {
			n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);
	}
  }
  for (var s = n_stack.length - 1; s > 1; --s) {
	var p = n_stack[s - 1];
	var n = n_stack[s];
	if (p._color === BLACK || n._color === BLACK) {
			break;
	}
	var pp = n_stack[s - 2];
	if (pp.left === p) {
			if (p.left === n) {
		var y = pp.right;
		if (y && y._color === RED) {
					p._color = BLACK;
					pp.right = repaint(BLACK, y);
					pp._color = RED;
					s -= 1;
		} else {
					pp._color = RED;
					pp.left = p.right;
					p._color = BLACK;
					p.right = pp;
					n_stack[s - 2] = p;
					n_stack[s - 1] = n;
					recount(pp);
					recount(p);
					if (s >= 3) {
			var ppp = n_stack[s - 3];
			if (ppp.left === pp) {
							ppp.left = p;
			} else {
							ppp.right = p;
			}
					}
					break;
		}
			} else {
		var y = pp.right;
		if (y && y._color === RED) {
					p._color = BLACK;
					pp.right = repaint(BLACK, y);
					pp._color = RED;
					s -= 1;
		} else {
					p.right = n.left;
					pp._color = RED;
					pp.left = n.right;
					n._color = BLACK;
					n.left = p;
					n.right = pp;
					n_stack[s - 2] = n;
					n_stack[s - 1] = p;
					recount(pp);
					recount(p);
					recount(n);
					if (s >= 3) {
			var ppp = n_stack[s - 3];
			if (ppp.left === pp) {
							ppp.left = n;
			} else {
							ppp.right = n;
			}
					}
					break;
		}
			}
	} else {
			if (p.right === n) {
		var y = pp.left;
		if (y && y._color === RED) {
					p._color = BLACK;
					pp.left = repaint(BLACK, y);
					pp._color = RED;
					s -= 1;
		} else {
					pp._color = RED;
					pp.right = p.left;
					p._color = BLACK;
					p.left = pp;
					n_stack[s - 2] = p;
					n_stack[s - 1] = n;
					recount(pp);
					recount(p);
					if (s >= 3) {
			var ppp = n_stack[s - 3];
			if (ppp.right === pp) {
							ppp.right = p;
			} else {
							ppp.left = p;
			}
					}
					break;
		}
			} else {
		var y = pp.left;
		if (y && y._color === RED) {
					p._color = BLACK;
					pp.left = repaint(BLACK, y);
					pp._color = RED;
					s -= 1;
		} else {
					p.left = n.right;
					pp._color = RED;
					pp.right = n.left;
					n._color = BLACK;
					n.right = p;
					n.left = pp;
					n_stack[s - 2] = n;
					n_stack[s - 1] = p;
					recount(pp);
					recount(p);
					recount(n);
					if (s >= 3) {
			var ppp = n_stack[s - 3];
			if (ppp.right === pp) {
							ppp.right = n;
			} else {
							ppp.left = n;
			}
					}
					break;
		}
			}
	}
  }
  n_stack[0]._color = BLACK;
  return new RedBlackTree(cmp, n_stack[0]);
};
function doVisitFull(visit, node) {
  if (node.left) {
	var v = doVisitFull(visit, node.left);
	if (v) {
			return v;
	}
  }
  var v = visit(node.key, node.value);
  if (v) {
	return v;
  }
  if (node.right) {
	return doVisitFull(visit, node.right);
  }
}
function doVisitHalf(lo, compare, visit, node) {
  var l = compare(lo, node.key);
  if (l <= 0) {
	if (node.left) {
			var v = doVisitHalf(lo, compare, visit, node.left);
			if (v) {
		return v;
			}
	}
	var v = visit(node.key, node.value);
	if (v) {
			return v;
	}
  }
  if (node.right) {
	return doVisitHalf(lo, compare, visit, node.right);
  }
}
function doVisit(lo, hi, compare, visit, node) {
  var l = compare(lo, node.key);
  var h = compare(hi, node.key);
  var v;
  if (l <= 0) {
	if (node.left) {
			v = doVisit(lo, hi, compare, visit, node.left);
			if (v) {
		return v;
			}
	}
	if (h > 0) {
			v = visit(node.key, node.value);
			if (v) {
		return v;
			}
	}
  }
  if (h > 0 && node.right) {
	return doVisit(lo, hi, compare, visit, node.right);
  }
}

proto.forEach = function rbTreeForEach(visit, lo, hi) {
  if (!this.root) {
	return;
  }
  switch (arguments.length) {
	case 1:
			return doVisitFull(visit, this.root);
			break;

	case 2:
			return doVisitHalf(lo, this._compare, visit, this.root);
			break;

	case 3:
			if (this._compare(lo, hi) >= 0) {
		return;
			}
			return doVisit(lo, hi, this._compare, visit, this.root);
			break;
  }
};
Object.defineProperty(proto, "begin", {
  get: function get() {
	var stack = [];
	var n = this.root;
	while (n) {
			stack.push(n);
			n = n.left;
	}
	return new RedBlackTreeIterator(this, stack);
  }
});
Object.defineProperty(proto, "end", {
  get: function get() {
	var stack = [];
	var n = this.root;
	while (n) {
			stack.push(n);
			n = n.right;
	}
	return new RedBlackTreeIterator(this, stack);
  }
});
proto.at = function (idx) {
  if (idx < 0) {
	return new RedBlackTreeIterator(this, []);
  }
  var n = this.root;
  var stack = [];
  while (true) {
	stack.push(n);
	if (n.left) {
			if (idx < n.left._count) {
		n = n.left;
		continue;
			}
			idx -= n.left._count;
	}
	if (!idx) {
			return new RedBlackTreeIterator(this, stack);
	}
	idx -= 1;
	if (n.right) {
			if (idx >= n.right._count) {
		break;
			}
			n = n.right;
	} else {
			break;
	}
  }
  return new RedBlackTreeIterator(this, []);
};

proto.ge = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
	var d = cmp(key, n.key);
	stack.push(n);
	if (d <= 0) {
			last_ptr = stack.length;
	}
	if (d <= 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

proto.gt = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
	var d = cmp(key, n.key);
	stack.push(n);
	if (d < 0) {
			last_ptr = stack.length;
	}
	if (d < 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

proto.lt = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
	var d = cmp(key, n.key);
	stack.push(n);
	if (d > 0) {
			last_ptr = stack.length;
	}
	if (d <= 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

proto.le = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
	var d = cmp(key, n.key);
	stack.push(n);
	if (d >= 0) {
			last_ptr = stack.length;
	}
	if (d < 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};
proto.find = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  while (n) {
	var d = cmp(key, n.key);
	stack.push(n);
	if (d === 0) {
			return new RedBlackTreeIterator(this, stack);
	}
	if (d <= 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  return new RedBlackTreeIterator(this, []);
};
proto.remove = function (key) {
  var iter = this.find(key);
  if (iter) {
	return iter.remove();
  }
  return this;
};
proto.get = function (key) {
  var cmp = this._compare;
  var n = this.root;
  while (n) {
	var d = cmp(key, n.key);
	if (d === 0) {
			return n.value;
	}
	if (d <= 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  return;
};
function RedBlackTreeIterator(tree, stack) {
  this.tree = tree;
  this._stack = stack;
}

var iproto = RedBlackTreeIterator.prototype;
Object.defineProperty(iproto, "valid", {
  get: function get() {
	return this._stack.length > 0;
  }
});
Object.defineProperty(iproto, "node", {
  get: function get() {
	if (this._stack.length > 0) {
			return this._stack[this._stack.length - 1];
	}
	return null;
  },
  enumerable: true
});
iproto.clone = function () {
  return new RedBlackTreeIterator(this.tree, this._stack.slice());
};
function swapNode(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n._color = v._color;
  n._count = v._count;
}
function fixDoubleBlack(stack) {
  var n, p, s, z;
  for (var i = stack.length - 1; i >= 0; --i) {
	n = stack[i];
	if (i === 0) {
			n._color = BLACK;
			return;
	}
	p = stack[i - 1];
	if (p.left === n) {
			s = p.right;
			if (s.right && s.right._color === RED) {
		s = p.right = cloneNode(s);
		z = s.right = cloneNode(s.right);
		p.right = s.left;
		s.left = p;
		s.right = z;
		s._color = p._color;
		n._color = BLACK;
		p._color = BLACK;
		z._color = BLACK;
		recount(p);
		recount(s);
		if (i > 1) {
					var pp = stack[i - 2];
					if (pp.left === p) {
			pp.left = s;
					} else {
			pp.right = s;
					}
		}
		stack[i - 1] = s;
		return;
			} else if (s.left && s.left._color === RED) {
		s = p.right = cloneNode(s);
		z = s.left = cloneNode(s.left);
		p.right = z.left;
		s.left = z.right;
		z.left = p;
		z.right = s;
		z._color = p._color;
		p._color = BLACK;
		s._color = BLACK;
		n._color = BLACK;
		recount(p);
		recount(s);
		recount(z);
		if (i > 1) {
					var pp = stack[i - 2];
					if (pp.left === p) {
			pp.left = z;
					} else {
			pp.right = z;
					}
		}
		stack[i - 1] = z;
		return;
			}
			if (s._color === BLACK) {
		if (p._color === RED) {
					p._color = BLACK;
					p.right = repaint(RED, s);
					return;
		} else {
					p.right = repaint(RED, s);
					continue;
		}
			} else {
		s = cloneNode(s);
		p.right = s.left;
		s.left = p;
		s._color = p._color;
		p._color = RED;
		recount(p);
		recount(s);
		if (i > 1) {
					var pp = stack[i - 2];
					if (pp.left === p) {
			pp.left = s;
					} else {
			pp.right = s;
					}
		}
		stack[i - 1] = s;
		stack[i] = p;
		if (i + 1 < stack.length) {
					stack[i + 1] = n;
		} else {
					stack.push(n);
		}
		i = i + 2;
			}
	} else {
			s = p.left;
			if (s.left && s.left._color === RED) {
		s = p.left = cloneNode(s);
		z = s.left = cloneNode(s.left);
		p.left = s.right;
		s.right = p;
		s.left = z;
		s._color = p._color;
		n._color = BLACK;
		p._color = BLACK;
		z._color = BLACK;
		recount(p);
		recount(s);
		if (i > 1) {
					var pp = stack[i - 2];
					if (pp.right === p) {
			pp.right = s;
					} else {
			pp.left = s;
					}
		}
		stack[i - 1] = s;
		return;
			} else if (s.right && s.right._color === RED) {
		s = p.left = cloneNode(s);
		z = s.right = cloneNode(s.right);
		p.left = z.right;
		s.right = z.left;
		z.right = p;
		z.left = s;
		z._color = p._color;
		p._color = BLACK;
		s._color = BLACK;
		n._color = BLACK;
		recount(p);
		recount(s);
		recount(z);
		if (i > 1) {
					var pp = stack[i - 2];
					if (pp.right === p) {
			pp.right = z;
					} else {
			pp.left = z;
					}
		}
		stack[i - 1] = z;
		return;
			}
			if (s._color === BLACK) {
		if (p._color === RED) {
					p._color = BLACK;
					p.left = repaint(RED, s);
					return;
		} else {
					p.left = repaint(RED, s);
					continue;
		}
			} else {
		s = cloneNode(s);
		p.left = s.right;
		s.right = p;
		s._color = p._color;
		p._color = RED;
		recount(p);
		recount(s);
		if (i > 1) {
					var pp = stack[i - 2];
					if (pp.right === p) {
			pp.right = s;
					} else {
			pp.left = s;
					}
		}
		stack[i - 1] = s;
		stack[i] = p;
		if (i + 1 < stack.length) {
					stack[i + 1] = n;
		} else {
					stack.push(n);
		}
		i = i + 2;
			}
	}
  }
}
iproto.remove = function () {
  var stack = this._stack;
  if (stack.length === 0) {
	return this.tree;
  }
  var cstack = new Array(stack.length);
  var n = stack[stack.length - 1];
  cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);
  for (var i = stack.length - 2; i >= 0; --i) {
	var n = stack[i];
	if (n.left === stack[i + 1]) {
			cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
	} else {
			cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
	}
  }
  n = cstack[cstack.length - 1];
  if (n.left && n.right) {
	var split = cstack.length;
	n = n.left;
	while (n.right) {
			cstack.push(n);
			n = n.right;
	}
	var v = cstack[split - 1];
	cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));
	cstack[split - 1].key = n.key;
	cstack[split - 1].value = n.value;
	for (var i = cstack.length - 2; i >= split; --i) {
			n = cstack[i];
			cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
	}
	cstack[split - 1].left = cstack[split];
  }
  n = cstack[cstack.length - 1];
  if (n._color === RED) {
	var p = cstack[cstack.length - 2];
	if (p.left === n) {
			p.left = null;
	} else if (p.right === n) {
			p.right = null;
	}
	cstack.pop();
	for (var i = 0; i < cstack.length; ++i) {
			cstack[i]._count--;
	}
	return new RedBlackTree(this.tree._compare, cstack[0]);
  } else {
	if (n.left || n.right) {
			if (n.left) {
		swapNode(n, n.left);
			} else if (n.right) {
		swapNode(n, n.right);
			}
			n._color = BLACK;
			for (var i = 0; i < cstack.length - 1; ++i) {
		cstack[i]._count--;
			}
			return new RedBlackTree(this.tree._compare, cstack[0]);
	} else if (cstack.length === 1) {
			return new RedBlackTree(this.tree._compare, null);
	} else {
			for (var i = 0; i < cstack.length; ++i) {
		cstack[i]._count--;
			}
			var parent = cstack[cstack.length - 2];
			fixDoubleBlack(cstack);
			if (parent.left === n) {
		parent.left = null;
			} else {
		parent.right = null;
			}
	}
  }
  return new RedBlackTree(this.tree._compare, cstack[0]);
};
Object.defineProperty(iproto, "key", {
  get: function get() {
	if (this._stack.length > 0) {
			return this._stack[this._stack.length - 1].key;
	}
	return;
  },
  enumerable: true
});
Object.defineProperty(iproto, "value", {
  get: function get() {
	if (this._stack.length > 0) {
			return this._stack[this._stack.length - 1].value;
	}
	return;
  },
  enumerable: true
});
Object.defineProperty(iproto, "index", {
  get: function get() {
	var idx = 0;
	var stack = this._stack;
	if (stack.length === 0) {
			var r = this.tree.root;
			if (r) {
		return r._count;
			}
			return 0;
	} else if (stack[stack.length - 1].left) {
			idx = stack[stack.length - 1].left._count;
	}
	for (var s = stack.length - 2; s >= 0; --s) {
			if (stack[s + 1] === stack[s].right) {
		++idx;
		if (stack[s].left) {
					idx += stack[s].left._count;
		}
			}
	}
	return idx;
  },
  enumerable: true
});
iproto.next = function () {
  var stack = this._stack;
  if (stack.length === 0) {
	return;
  }
  var n = stack[stack.length - 1];
  if (n.right) {
	n = n.right;
	while (n) {
			stack.push(n);
			n = n.left;
	}
  } else {
	stack.pop();
	while (stack.length > 0 && stack[stack.length - 1].right === n) {
			n = stack[stack.length - 1];
			stack.pop();
	}
  }
};
Object.defineProperty(iproto, "hasNext", {
  get: function get() {
	var stack = this._stack;
	if (stack.length === 0) {
			return false;
	}
	if (stack[stack.length - 1].right) {
			return true;
	}
	for (var s = stack.length - 1; s > 0; --s) {
			if (stack[s - 1].left === stack[s]) {
		return true;
			}
	}
	return false;
  }
});
iproto.update = function (value) {
  var stack = this._stack;
  if (stack.length === 0) {
	throw new Error("Can't update empty node!");
  }
  var cstack = new Array(stack.length);
  var n = stack[stack.length - 1];
  cstack[cstack.length - 1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);
  for (var i = stack.length - 2; i >= 0; --i) {
	n = stack[i];
	if (n.left === stack[i + 1]) {
			cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
	} else {
			cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
	}
  }
  return new RedBlackTree(this.tree._compare, cstack[0]);
};
iproto.prev = function () {
  var stack = this._stack;
  if (stack.length === 0) {
	return;
  }
  var n = stack[stack.length - 1];
  if (n.left) {
	n = n.left;
	while (n) {
			stack.push(n);
			n = n.right;
	}
  } else {
	stack.pop();
	while (stack.length > 0 && stack[stack.length - 1].left === n) {
			n = stack[stack.length - 1];
			stack.pop();
	}
  }
};
Object.defineProperty(iproto, "hasPrev", {
  get: function get() {
	var stack = this._stack;
	if (stack.length === 0) {
			return false;
	}
	if (stack[stack.length - 1].left) {
			return true;
	}
	for (var s = stack.length - 1; s > 0; --s) {
			if (stack[s - 1].right === stack[s]) {
		return true;
			}
	}
	return false;
  }
});
function defaultCompare(a, b) {
  if (a < b) {
	return -1;
  }
  if (a > b) {
	return 1;
  }
  return 0;
}
function createRBTree(compare) {
  return new RedBlackTree(compare || defaultCompare, null);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isForLoop(block) {
	return block.type === "ForInStatement" || block.type === "ForOfStatement" || block.type === "ForStatement";
}
function isInitialized(node) {
	var declaration = node.parent;
	var block = declaration.parent;

	if (isForLoop(block)) {
		if (block.type === "ForStatement") {
			return block.init === declaration;
		}
		return block.left === declaration;
	}
	return Boolean(node.init);
}
module.exports = {
	meta: {
		docs: {
			description: "require or disallow initialization in variable declarations",
			category: "Variables",
			recommended: false
		},

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["always"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["never"]
				}, {
					type: "object",
					properties: {
						ignoreForLoopInit: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		}
	},

	create: function create(context) {

		var MODE_ALWAYS = "always",
			MODE_NEVER = "never";

		var mode = context.options[0] || MODE_ALWAYS;
		var params = context.options[1] || {};
		return {
			"VariableDeclaration:exit": function VariableDeclarationExit(node) {

				var kind = node.kind,
					declarations = node.declarations;

				for (var i = 0; i < declarations.length; ++i) {
					var declaration = declarations[i],
						id = declaration.id,
						initialized = isInitialized(declaration),
						isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);

					if (id.type !== "Identifier") {
						continue;
					}

					if (mode === MODE_ALWAYS && !initialized) {
						context.report({
							node: declaration,
							message: "Variable '{{idName}}' should be initialized on declaration.",
							data: {
								idName: id.name
							}
						});
					} else if (mode === MODE_NEVER && kind !== "const" && initialized && !isIgnoredForLoop) {
						context.report({
							node: declaration,
							message: "Variable '{{idName}}' should not be initialized on declaration.",
							data: {
								idName: id.name
							}
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var QUOTE_SETTINGS = {
	"prefer-double": {
		quote: "\"",
		description: "singlequote",
		convert: function convert(str) {
			return str.replace(/'/g, "\"");
		}
	},
	"prefer-single": {
		quote: "'",
		description: "doublequote",
		convert: function convert(str) {
			return str.replace(/"/g, "'");
		}
	}
};
module.exports = {
	meta: {
		docs: {
			description: "enforce the consistent use of either double or single quotes in JSX attributes",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["prefer-single", "prefer-double"]
		}]
	},

	create: function create(context) {
		var quoteOption = context.options[0] || "prefer-double",
			setting = QUOTE_SETTINGS[quoteOption];
		function usesExpectedQuotes(node) {
			return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);
		}

		return {
			JSXAttribute: function JSXAttribute(node) {
				var attributeValue = node.value;

				if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {
					context.report({
						node: attributeValue,
						message: "Unexpected usage of {{description}}.",
						data: {
							description: setting.description
						},
						fix: function fix(fixer) {
							return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
function containsLineTerminator(str) {
	return astUtils.LINEBREAK_MATCHER.test(str);
}
function last(arr) {
	return arr[arr.length - 1];
}
function isSingleLine(node) {
	return node.loc.end.line === node.loc.start.line;
}
function initOptionProperty(toOptions, fromOptions) {
	toOptions.mode = fromOptions.mode || "strict";
	if (typeof fromOptions.beforeColon !== "undefined") {
		toOptions.beforeColon = +fromOptions.beforeColon;
	} else {
		toOptions.beforeColon = 0;
	}
	if (typeof fromOptions.afterColon !== "undefined") {
		toOptions.afterColon = +fromOptions.afterColon;
	} else {
		toOptions.afterColon = 1;
	}
	if (typeof fromOptions.align !== "undefined") {
		if (_typeof(fromOptions.align) === "object") {
			toOptions.align = fromOptions.align;
		} else {
			toOptions.align = {
				on: fromOptions.align,
				mode: toOptions.mode,
				beforeColon: toOptions.beforeColon,
				afterColon: toOptions.afterColon
			};
		}
	}

	return toOptions;
}
function initOptions(toOptions, fromOptions) {
	if (_typeof(fromOptions.align) === "object") {
		toOptions.align = initOptionProperty({}, fromOptions.align);
		toOptions.align.on = fromOptions.align.on || "colon";
		toOptions.align.mode = fromOptions.align.mode || "strict";

		toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
		toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
	} else {
		toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
		toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
		if (toOptions.multiLine.align) {
			toOptions.align = {
				on: toOptions.multiLine.align.on,
				mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
				beforeColon: toOptions.multiLine.align.beforeColon,
				afterColon: toOptions.multiLine.align.afterColon
			};
		}
	}

	return toOptions;
}
var messages = {
	key: "{{error}} space after {{computed}}key '{{key}}'.",
	value: "{{error}} space before value for {{computed}}key '{{key}}'."
};

module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing between keys and values in object literal properties",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			anyOf: [{
				type: "object",
				properties: {
					align: {
						anyOf: [{
							enum: ["colon", "value"]
						}, {
							type: "object",
							properties: {
								mode: {
									enum: ["strict", "minimum"]
								},
								on: {
									enum: ["colon", "value"]
								},
								beforeColon: {
									type: "boolean"
								},
								afterColon: {
									type: "boolean"
								}
							},
							additionalProperties: false
						}]
					},
					mode: {
						enum: ["strict", "minimum"]
					},
					beforeColon: {
						type: "boolean"
					},
					afterColon: {
						type: "boolean"
					}
				},
				additionalProperties: false
			}, {
				type: "object",
				properties: {
					singleLine: {
						type: "object",
						properties: {
							mode: {
								enum: ["strict", "minimum"]
							},
							beforeColon: {
								type: "boolean"
							},
							afterColon: {
								type: "boolean"
							}
						},
						additionalProperties: false
					},
					multiLine: {
						type: "object",
						properties: {
							align: {
								anyOf: [{
									enum: ["colon", "value"]
								}, {
									type: "object",
									properties: {
										mode: {
											enum: ["strict", "minimum"]
										},
										on: {
											enum: ["colon", "value"]
										},
										beforeColon: {
											type: "boolean"
										},
										afterColon: {
											type: "boolean"
										}
									},
									additionalProperties: false
								}]
							},
							mode: {
								enum: ["strict", "minimum"]
							},
							beforeColon: {
								type: "boolean"
							},
							afterColon: {
								type: "boolean"
							}
						},
						additionalProperties: false
					}
				},
				additionalProperties: false
			}, {
				type: "object",
				properties: {
					singleLine: {
						type: "object",
						properties: {
							mode: {
								enum: ["strict", "minimum"]
							},
							beforeColon: {
								type: "boolean"
							},
							afterColon: {
								type: "boolean"
							}
						},
						additionalProperties: false
					},
					multiLine: {
						type: "object",
						properties: {
							mode: {
								enum: ["strict", "minimum"]
							},
							beforeColon: {
								type: "boolean"
							},
							afterColon: {
								type: "boolean"
							}
						},
						additionalProperties: false
					},
					align: {
						type: "object",
						properties: {
							mode: {
								enum: ["strict", "minimum"]
							},
							on: {
								enum: ["colon", "value"]
							},
							beforeColon: {
								type: "boolean"
							},
							afterColon: {
								type: "boolean"
							}
						},
						additionalProperties: false
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {},
			ruleOptions = initOptions({}, options),
			multiLineOptions = ruleOptions.multiLine,
			singleLineOptions = ruleOptions.singleLine,
			alignmentOptions = ruleOptions.align || null;

		var sourceCode = context.getSourceCode();
		function continuesPropertyGroup(lastMember, candidate) {
			var groupEndLine = lastMember.loc.start.line,
				candidateStartLine = candidate.loc.start.line;

			if (candidateStartLine - groupEndLine <= 1) {
				return true;
			}
			var leadingComments = sourceCode.getCommentsBefore(candidate);

			if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateStartLine - last(leadingComments).loc.end.line <= 1) {
				for (var i = 1; i < leadingComments.length; i++) {
					if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {
						return false;
					}
				}
				return true;
			}

			return false;
		}
		function isKeyValueProperty(property) {
			return !(property.method || property.shorthand || property.kind !== "init" || property.type !== "Property");
		}
		function getLastTokenBeforeColon(node) {
			var colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);

			return sourceCode.getTokenBefore(colonToken);
		}
		function getNextColon(node) {
			return sourceCode.getTokenAfter(node, astUtils.isColonToken);
		}
		function getKey(property) {
			var key = property.key;

			if (property.computed) {
				return sourceCode.getText().slice(key.range[0], key.range[1]);
			}

			return property.key.name || property.key.value;
		}
		function report(property, side, whitespace, expected, mode) {
			var diff = whitespace.length - expected,
				nextColon = getNextColon(property.key),
				tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }),
				tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }),
				isKeySide = side === "key",
				locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,
				isExtra = diff > 0,
				diffAbs = Math.abs(diff),
				spaces = Array(diffAbs + 1).join(" ");

			if ((diff && mode === "strict" || diff < 0 && mode === "minimum" || diff > 0 && !expected && mode === "minimum") && !(expected && containsLineTerminator(whitespace))) {
				var fix = void 0;

				if (isExtra) {
					var range = void 0;
					if (isKeySide) {
						range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];
					} else {
						range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];
					}
					fix = function fix(fixer) {
						return fixer.removeRange(range);
					};
				} else {
					if (isKeySide) {
						fix = function fix(fixer) {
							return fixer.insertTextAfter(tokenBeforeColon, spaces);
						};
					} else {
						fix = function fix(fixer) {
							return fixer.insertTextBefore(tokenAfterColon, spaces);
						};
					}
				}

				context.report({
					node: property[side],
					loc: locStart,
					message: messages[side],
					data: {
						error: isExtra ? "Extra" : "Missing",
						computed: property.computed ? "computed " : "",
						key: getKey(property)
					},
					fix: fix
				});
			}
		}
		function getKeyWidth(property) {
			var startToken = sourceCode.getFirstToken(property);
			var endToken = getLastTokenBeforeColon(property.key);

			return endToken.range[1] - startToken.range[0];
		}
		function getPropertyWhitespace(property) {
			var whitespace = /(\s*):(\s*)/.exec(sourceCode.getText().slice(property.key.range[1], property.value.range[0]));

			if (whitespace) {
				return {
					beforeColon: whitespace[1],
					afterColon: whitespace[2]
				};
			}
			return null;
		}
		function createGroups(node) {
			if (node.properties.length === 1) {
				return [node.properties];
			}

			return node.properties.reduce(function (groups, property) {
				var currentGroup = last(groups),
					prev = last(currentGroup);

				if (!prev || continuesPropertyGroup(prev, property)) {
					currentGroup.push(property);
				} else {
					groups.push([property]);
				}

				return groups;
			}, [[]]);
		}
		function verifyGroupAlignment(properties) {
			var length = properties.length,
				widths = properties.map(getKeyWidth),
			align = alignmentOptions.on; // "value" or "colon"
			var targetWidth = Math.max.apply(null, widths),
				beforeColon = void 0,
				afterColon = void 0,
				mode = void 0;

			if (alignmentOptions && length > 1) {
				beforeColon = alignmentOptions.beforeColon;
				afterColon = alignmentOptions.afterColon;
				mode = alignmentOptions.mode;
			} else {
				beforeColon = multiLineOptions.beforeColon;
				afterColon = multiLineOptions.afterColon;
				mode = alignmentOptions.mode;
			}
			targetWidth += align === "colon" ? beforeColon : afterColon;

			for (var i = 0; i < length; i++) {
				var property = properties[i];
				var whitespace = getPropertyWhitespace(property);

				if (whitespace) {
					var width = widths[i];

					if (align === "value") {
						report(property, "key", whitespace.beforeColon, beforeColon, mode);
						report(property, "value", whitespace.afterColon, targetWidth - width, mode);
					} else {
						report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
						report(property, "value", whitespace.afterColon, afterColon, mode);
					}
				}
			}
		}
		function verifyAlignment(node) {
			createGroups(node).forEach(function (group) {
				verifyGroupAlignment(group.filter(isKeyValueProperty));
			});
		}
		function verifySpacing(node, lineOptions) {
			var actual = getPropertyWhitespace(node);

			if (actual) {
				report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
				report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
			}
		}
		function verifyListSpacing(properties) {
			var length = properties.length;

			for (var i = 0; i < length; i++) {
				verifySpacing(properties[i], singleLineOptions);
			}
		}
		if (alignmentOptions) {
			return {
				ObjectExpression: function ObjectExpression(node) {
					if (isSingleLine(node)) {
						verifyListSpacing(node.properties.filter(isKeyValueProperty));
					} else {
						verifyAlignment(node);
					}
				}
			};
		}
		return {
			Property: function Property(node) {
				verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0),
	keywords = __webpack_require__(107);
var PREV_TOKEN = /^[)\]}>]$/;
var NEXT_TOKEN = /^(?:[([{<~!]|\+\+?|--?)$/;
var PREV_TOKEN_M = /^[)\]}>*]$/;
var NEXT_TOKEN_M = /^[{*]$/;
var TEMPLATE_OPEN_PAREN = /\$\{$/;
var TEMPLATE_CLOSE_PAREN = /^\}/;
var CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/;
var KEYS = keywords.concat(["as", "async", "await", "from", "get", "let", "of", "set", "yield"]);
(function () {
	KEYS.sort();
	for (var i = 1; i < KEYS.length; ++i) {
		if (KEYS[i] === KEYS[i - 1]) {
			throw new Error("Duplication was found in the keyword list: " + KEYS[i]);
		}
	}
})();
function isOpenParenOfTemplate(token) {
	return token.type === "Template" && TEMPLATE_OPEN_PAREN.test(token.value);
}
function isCloseParenOfTemplate(token) {
	return token.type === "Template" && TEMPLATE_CLOSE_PAREN.test(token.value);
}
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before and after keywords",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				before: { type: "boolean" },
				after: { type: "boolean" },
				overrides: {
					type: "object",
					properties: KEYS.reduce(function (retv, key) {
						retv[key] = {
							type: "object",
							properties: {
								before: { type: "boolean" },
								after: { type: "boolean" }
							},
							additionalProperties: false
						};
						return retv;
					}, {}),
					additionalProperties: false
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function expectSpaceBefore(token, pattern) {
			pattern = pattern || PREV_TOKEN;

			var prevToken = sourceCode.getTokenBefore(token);

			if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && !sourceCode.isSpaceBetweenTokens(prevToken, token)) {
				context.report({
					loc: token.loc.start,
					message: "Expected space(s) before \"{{value}}\".",
					data: token,
					fix: function fix(fixer) {
						return fixer.insertTextBefore(token, " ");
					}
				});
			}
		}
		function unexpectSpaceBefore(token, pattern) {
			pattern = pattern || PREV_TOKEN;

			var prevToken = sourceCode.getTokenBefore(token);

			if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token)) {
				context.report({
					loc: token.loc.start,
					message: "Unexpected space(s) before \"{{value}}\".",
					data: token,
					fix: function fix(fixer) {
						return fixer.removeRange([prevToken.range[1], token.range[0]]);
					}
				});
			}
		}
		function expectSpaceAfter(token, pattern) {
			pattern = pattern || NEXT_TOKEN;

			var nextToken = sourceCode.getTokenAfter(token);

			if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && !sourceCode.isSpaceBetweenTokens(token, nextToken)) {
				context.report({
					loc: token.loc.start,
					message: "Expected space(s) after \"{{value}}\".",
					data: token,
					fix: function fix(fixer) {
						return fixer.insertTextAfter(token, " ");
					}
				});
			}
		}
		function unexpectSpaceAfter(token, pattern) {
			pattern = pattern || NEXT_TOKEN;

			var nextToken = sourceCode.getTokenAfter(token);

			if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken)) {
				context.report({
					loc: token.loc.start,
					message: "Unexpected space(s) after \"{{value}}\".",
					data: token,
					fix: function fix(fixer) {
						return fixer.removeRange([token.range[1], nextToken.range[0]]);
					}
				});
			}
		}
		function parseOptions(options) {
			var before = !options || options.before !== false;
			var after = !options || options.after !== false;
			var defaultValue = {
				before: before ? expectSpaceBefore : unexpectSpaceBefore,
				after: after ? expectSpaceAfter : unexpectSpaceAfter
			};
			var overrides = options && options.overrides || {};
			var retv = Object.create(null);

			for (var i = 0; i < KEYS.length; ++i) {
				var key = KEYS[i];
				var override = overrides[key];

				if (override) {
					var thisBefore = "before" in override ? override.before : before;
					var thisAfter = "after" in override ? override.after : after;

					retv[key] = {
						before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
						after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
					};
				} else {
					retv[key] = defaultValue;
				}
			}

			return retv;
		}

		var checkMethodMap = parseOptions(context.options[0]);
		function checkSpacingBefore(token, pattern) {
			checkMethodMap[token.value].before(token, pattern);
		}
		function checkSpacingAfter(token, pattern) {
			checkMethodMap[token.value].after(token, pattern);
		}
		function checkSpacingAround(token) {
			checkSpacingBefore(token);
			checkSpacingAfter(token);
		}
		function checkSpacingAroundFirstToken(node) {
			var firstToken = node && sourceCode.getFirstToken(node);

			if (firstToken && firstToken.type === "Keyword") {
				checkSpacingAround(firstToken);
			}
		}
		function checkSpacingBeforeFirstToken(node) {
			var firstToken = node && sourceCode.getFirstToken(node);

			if (firstToken && firstToken.type === "Keyword") {
				checkSpacingBefore(firstToken);
			}
		}
		function checkSpacingAroundTokenBefore(node) {
			if (node) {
				var token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);

				checkSpacingAround(token);
			}
		}
		function checkSpacingForFunction(node) {
			var firstToken = node && sourceCode.getFirstToken(node);

			if (firstToken && (firstToken.type === "Keyword" && firstToken.value === "function" || firstToken.value === "async")) {
				checkSpacingBefore(firstToken);
			}
		}
		function checkSpacingForClass(node) {
			checkSpacingAroundFirstToken(node);
			checkSpacingAroundTokenBefore(node.superClass);
		}
		function checkSpacingForIfStatement(node) {
			checkSpacingAroundFirstToken(node);
			checkSpacingAroundTokenBefore(node.alternate);
		}
		function checkSpacingForTryStatement(node) {
			checkSpacingAroundFirstToken(node);
			checkSpacingAroundFirstToken(node.handler);
			checkSpacingAroundTokenBefore(node.finalizer);
		}
		function checkSpacingForDoWhileStatement(node) {
			checkSpacingAroundFirstToken(node);
			checkSpacingAroundTokenBefore(node.test);
		}
		function checkSpacingForForInStatement(node) {
			checkSpacingAroundFirstToken(node);
			checkSpacingAroundTokenBefore(node.right);
		}
		function checkSpacingForForOfStatement(node) {
			checkSpacingAroundFirstToken(node);
			checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));
		}
		function checkSpacingForModuleDeclaration(node) {
			var firstToken = sourceCode.getFirstToken(node);

			checkSpacingBefore(firstToken, PREV_TOKEN_M);
			checkSpacingAfter(firstToken, NEXT_TOKEN_M);

			if (node.source) {
				var fromToken = sourceCode.getTokenBefore(node.source);

				checkSpacingBefore(fromToken, PREV_TOKEN_M);
				checkSpacingAfter(fromToken, NEXT_TOKEN_M);
			}
		}
		function checkSpacingForImportNamespaceSpecifier(node) {
			var asToken = sourceCode.getFirstToken(node, 1);

			checkSpacingBefore(asToken, PREV_TOKEN_M);
		}
		function checkSpacingForProperty(node) {
			if (node.static) {
				checkSpacingAroundFirstToken(node);
			}
			if (node.kind === "get" || node.kind === "set" || (node.method || node.type === "MethodDefinition") && node.value.async) {
				var token = sourceCode.getTokenBefore(node.key, function (tok) {
					switch (tok.value) {
						case "get":
						case "set":
						case "async":
							return true;
						default:
							return false;
					}
				});

				if (!token) {
					throw new Error("Failed to find token get, set, or async beside method name");
				}

				checkSpacingAround(token);
			}
		}
		function checkSpacingForAwaitExpression(node) {
			checkSpacingBefore(sourceCode.getFirstToken(node));
		}

		return {
			DebuggerStatement: checkSpacingAroundFirstToken,
			WithStatement: checkSpacingAroundFirstToken,
			BreakStatement: checkSpacingAroundFirstToken,
			ContinueStatement: checkSpacingAroundFirstToken,
			ReturnStatement: checkSpacingAroundFirstToken,
			ThrowStatement: checkSpacingAroundFirstToken,
			TryStatement: checkSpacingForTryStatement,
			IfStatement: checkSpacingForIfStatement,
			SwitchStatement: checkSpacingAroundFirstToken,
			SwitchCase: checkSpacingAroundFirstToken,
			DoWhileStatement: checkSpacingForDoWhileStatement,
			ForInStatement: checkSpacingForForInStatement,
			ForOfStatement: checkSpacingForForOfStatement,
			ForStatement: checkSpacingAroundFirstToken,
			WhileStatement: checkSpacingAroundFirstToken,
			ClassDeclaration: checkSpacingForClass,
			ExportNamedDeclaration: checkSpacingForModuleDeclaration,
			ExportDefaultDeclaration: checkSpacingAroundFirstToken,
			ExportAllDeclaration: checkSpacingForModuleDeclaration,
			FunctionDeclaration: checkSpacingForFunction,
			ImportDeclaration: checkSpacingForModuleDeclaration,
			VariableDeclaration: checkSpacingAroundFirstToken,
			ArrowFunctionExpression: checkSpacingForFunction,
			AwaitExpression: checkSpacingForAwaitExpression,
			ClassExpression: checkSpacingForClass,
			FunctionExpression: checkSpacingForFunction,
			NewExpression: checkSpacingBeforeFirstToken,
			Super: checkSpacingBeforeFirstToken,
			ThisExpression: checkSpacingBeforeFirstToken,
			UnaryExpression: checkSpacingBeforeFirstToken,
			YieldExpression: checkSpacingBeforeFirstToken,
			ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,
			MethodDefinition: checkSpacingForProperty,
			Property: checkSpacingForProperty
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce position of line comments",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				enum: ["above", "beside"]
			}, {
				type: "object",
				properties: {
					position: {
						enum: ["above", "beside"]
					},
					ignorePattern: {
						type: "string"
					},
					applyDefaultPatterns: {
						type: "boolean"
					},
					applyDefaultIgnorePatterns: {
						type: "boolean"
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var options = context.options[0];

		var above = void 0,
			ignorePattern = void 0,
			applyDefaultIgnorePatterns = true;

		if (!options || typeof options === "string") {
			above = !options || options === "above";
		} else {
			above = options.position === "above";
			ignorePattern = options.ignorePattern;

			if (options.hasOwnProperty("applyDefaultIgnorePatterns")) {
				applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;
			} else {
				applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;
			}
		}

		var defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
		var fallThroughRegExp = /^\s*falls?\s?through/;
		var customIgnoreRegExp = new RegExp(ignorePattern);
		var sourceCode = context.getSourceCode();
		return {
			Program: function Program() {
				var comments = sourceCode.getAllComments();

				comments.filter(function (token) {
					return token.type === "Line";
				}).forEach(function (node) {
					if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || fallThroughRegExp.test(node.value))) {
						return;
					}

					if (ignorePattern && customIgnoreRegExp.test(node.value)) {
						return;
					}

					var previous = sourceCode.getTokenBefore(node, { includeComments: true });
					var isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;

					if (above) {
						if (isOnSameLine) {
							context.report({
								node: node,
								message: "Expected comment to be above code."
							});
						}
					} else {
						if (!isOnSameLine) {
							context.report({
								node: node,
								message: "Expected comment to be beside code."
							});
						}
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent linebreak style",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["unix", "windows"]
		}]
	},

	create: function create(context) {

		var EXPECTED_LF_MSG = "Expected linebreaks to be 'LF' but found 'CRLF'.",
			EXPECTED_CRLF_MSG = "Expected linebreaks to be 'CRLF' but found 'LF'.";

		var sourceCode = context.getSourceCode();
		function createFix(range, text) {
			return function (fixer) {
				return fixer.replaceTextRange(range, text);
			};
		}
		return {
			Program: function checkForlinebreakStyle(node) {
				var linebreakStyle = context.options[0] || "unix",
					expectedLF = linebreakStyle === "unix",
					expectedLFChars = expectedLF ? "\n" : "\r\n",
					source = sourceCode.getText(),
					pattern = astUtils.createGlobalLinebreakMatcher();
				var match = void 0;

				var i = 0;

				while ((match = pattern.exec(source)) !== null) {
					i++;
					if (match[0] === expectedLFChars) {
						continue;
					}

					var index = match.index;
					var range = [index, index + match[0].length];

					context.report({
						node: node,
						loc: {
							line: i,
							column: sourceCode.lines[i - 1].length
						},
						message: expectedLF ? EXPECTED_LF_MSG : EXPECTED_CRLF_MSG,
						fix: createFix(range, expectedLFChars)
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10),
	astUtils = __webpack_require__(0);
function getEmptyLineNums(lines) {
	var emptyLines = lines.map(function (line, i) {
		return {
			code: line.trim(),
			num: i + 1
		};
	}).filter(function (line) {
		return !line.code;
	}).map(function (line) {
		return line.num;
	});

	return emptyLines;
}
function getCommentLineNums(comments) {
	var lines = [];

	comments.forEach(function (token) {
		var start = token.loc.start.line;
		var end = token.loc.end.line;

		lines.push(start, end);
	});
	return lines;
}
module.exports = {
	meta: {
		docs: {
			description: "require empty lines around comments",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				beforeBlockComment: {
					type: "boolean"
				},
				afterBlockComment: {
					type: "boolean"
				},
				beforeLineComment: {
					type: "boolean"
				},
				afterLineComment: {
					type: "boolean"
				},
				allowBlockStart: {
					type: "boolean"
				},
				allowBlockEnd: {
					type: "boolean"
				},
				allowClassStart: {
					type: "boolean"
				},
				allowClassEnd: {
					type: "boolean"
				},
				allowObjectStart: {
					type: "boolean"
				},
				allowObjectEnd: {
					type: "boolean"
				},
				allowArrayStart: {
					type: "boolean"
				},
				allowArrayEnd: {
					type: "boolean"
				},
				ignorePattern: {
					type: "string"
				},
				applyDefaultIgnorePatterns: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = context.options[0] ? Object.assign({}, context.options[0]) : {};
		var ignorePattern = options.ignorePattern;
		var defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
		var customIgnoreRegExp = new RegExp(ignorePattern);
		var applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;

		options.beforeLineComment = options.beforeLineComment || false;
		options.afterLineComment = options.afterLineComment || false;
		options.beforeBlockComment = typeof options.beforeBlockComment !== "undefined" ? options.beforeBlockComment : true;
		options.afterBlockComment = options.afterBlockComment || false;
		options.allowBlockStart = options.allowBlockStart || false;
		options.allowBlockEnd = options.allowBlockEnd || false;

		var sourceCode = context.getSourceCode();

		var lines = sourceCode.lines,
			numLines = lines.length + 1,
			comments = sourceCode.getAllComments(),
			commentLines = getCommentLineNums(comments),
			emptyLines = getEmptyLineNums(lines),
			commentAndEmptyLines = commentLines.concat(emptyLines);
		function codeAroundComment(token) {
			var currentToken = token;

			do {
				currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });
			} while (currentToken && astUtils.isCommentToken(currentToken));

			if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {
				return true;
			}

			currentToken = token;
			do {
				currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });
			} while (currentToken && astUtils.isCommentToken(currentToken));

			if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {
				return true;
			}

			return false;
		}
		function isParentNodeType(parent, nodeType) {
			return parent.type === nodeType || parent.body && parent.body.type === nodeType || parent.consequent && parent.consequent.type === nodeType;
		}
		function getParentNodeOfToken(token) {
			return sourceCode.getNodeByRangeIndex(token.range[0]);
		}
		function isCommentAtParentStart(token, nodeType) {
			var parent = getParentNodeOfToken(token);

			return parent && isParentNodeType(parent, nodeType) && token.loc.start.line - parent.loc.start.line === 1;
		}
		function isCommentAtParentEnd(token, nodeType) {
			var parent = getParentNodeOfToken(token);

			return parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === 1;
		}
		function isCommentAtBlockStart(token) {
			return isCommentAtParentStart(token, "ClassBody") || isCommentAtParentStart(token, "BlockStatement") || isCommentAtParentStart(token, "SwitchCase");
		}
		function isCommentAtBlockEnd(token) {
			return isCommentAtParentEnd(token, "ClassBody") || isCommentAtParentEnd(token, "BlockStatement") || isCommentAtParentEnd(token, "SwitchCase") || isCommentAtParentEnd(token, "SwitchStatement");
		}
		function isCommentAtClassStart(token) {
			return isCommentAtParentStart(token, "ClassBody");
		}
		function isCommentAtClassEnd(token) {
			return isCommentAtParentEnd(token, "ClassBody");
		}
		function isCommentAtObjectStart(token) {
			return isCommentAtParentStart(token, "ObjectExpression") || isCommentAtParentStart(token, "ObjectPattern");
		}
		function isCommentAtObjectEnd(token) {
			return isCommentAtParentEnd(token, "ObjectExpression") || isCommentAtParentEnd(token, "ObjectPattern");
		}
		function isCommentAtArrayStart(token) {
			return isCommentAtParentStart(token, "ArrayExpression") || isCommentAtParentStart(token, "ArrayPattern");
		}
		function isCommentAtArrayEnd(token) {
			return isCommentAtParentEnd(token, "ArrayExpression") || isCommentAtParentEnd(token, "ArrayPattern");
		}
		function checkForEmptyLine(token, opts) {
			if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {
				return;
			}

			if (ignorePattern && customIgnoreRegExp.test(token.value)) {
				return;
			}

			var after = opts.after,
				before = opts.before;

			var prevLineNum = token.loc.start.line - 1,
				nextLineNum = token.loc.end.line + 1,
				commentIsNotAlone = codeAroundComment(token);

			var blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token) && !(options.allowClassStart === false && isCommentAtClassStart(token)),
				blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),
				classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),
				classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),
				objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),
				objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),
				arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),
				arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);

			var exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;
			var exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;
			if (prevLineNum < 1) {
				before = false;
			}
			if (nextLineNum >= numLines) {
				after = false;
			}
			if (commentIsNotAlone) {
				return;
			}

			var previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });
			var nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });
			if (!exceptionStartAllowed && before && !lodash.includes(commentAndEmptyLines, prevLineNum) && !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {
				var lineStart = token.range[0] - token.loc.start.column;
				var range = [lineStart, lineStart];

				context.report({
					node: token,
					message: "Expected line before comment.",
					fix: function fix(fixer) {
						return fixer.insertTextBeforeRange(range, "\n");
					}
				});
			}
			if (!exceptionEndAllowed && after && !lodash.includes(commentAndEmptyLines, nextLineNum) && !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {
				context.report({
					node: token,
					message: "Expected line after comment.",
					fix: function fix(fixer) {
						return fixer.insertTextAfter(token, "\n");
					}
				});
			}
		}
		return {
			Program: function Program() {
				comments.forEach(function (token) {
					if (token.type === "Line") {
						if (options.beforeLineComment || options.afterLineComment) {
							checkForEmptyLine(token, {
								after: options.afterLineComment,
								before: options.beforeLineComment
							});
						}
					} else if (token.type === "Block") {
						if (options.beforeBlockComment || options.afterBlockComment) {
							checkForEmptyLine(token, {
								after: options.afterBlockComment,
								before: options.beforeBlockComment
							});
						}
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow newlines around directives",
			category: "Stylistic Issues",
			recommended: false,
			replacedBy: ["padding-line-between-statements"]
		},
		schema: [{
			oneOf: [{
				enum: ["always", "never"]
			}, {
				type: "object",
				properties: {
					before: {
						enum: ["always", "never"]
					},
					after: {
						enum: ["always", "never"]
					}
				},
				additionalProperties: false,
				minProperties: 2
			}]
		}],
		fixable: "whitespace",
		deprecated: true
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var config = context.options[0] || "always";
		var expectLineBefore = typeof config === "string" ? config : config.before;
		var expectLineAfter = typeof config === "string" ? config : config.after;
		function hasNewlineBefore(node) {
			var tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });
			var tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;

			return node.loc.start.line - tokenLineBefore >= 2;
		}
		function getLastTokenOnLine(node) {
			var lastToken = sourceCode.getLastToken(node);
			var secondToLastToken = sourceCode.getTokenBefore(lastToken);

			return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line ? secondToLastToken : lastToken;
		}
		function hasNewlineAfter(node) {
			var lastToken = getLastTokenOnLine(node);
			var tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });

			return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;
		}
		function reportError(node, location, expected) {
			context.report({
				node: node,
				message: "{{expected}} newline {{location}} \"{{value}}\" directive.",
				data: {
					expected: expected ? "Expected" : "Unexpected",
					value: node.expression.value,
					location: location
				},
				fix: function fix(fixer) {
					var lastToken = getLastTokenOnLine(node);

					if (expected) {
						return location === "before" ? fixer.insertTextBefore(node, "\n") : fixer.insertTextAfter(lastToken, "\n");
					}
					return fixer.removeRange(location === "before" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);
				}
			});
		}
		function checkDirectives(node) {
			var directives = astUtils.getDirectivePrologue(node);

			if (!directives.length) {
				return;
			}

			var firstDirective = directives[0];
			var leadingComments = sourceCode.getCommentsBefore(firstDirective);
			if (leadingComments.length) {
				if (expectLineBefore === "always" && !hasNewlineBefore(firstDirective)) {
					reportError(firstDirective, "before", true);
				}

				if (expectLineBefore === "never" && hasNewlineBefore(firstDirective)) {
					reportError(firstDirective, "before", false);
				}
			} else if (node.type === "Program" && expectLineBefore === "never" && !leadingComments.length && hasNewlineBefore(firstDirective)) {
				reportError(firstDirective, "before", false);
			}

			var lastDirective = directives[directives.length - 1];
			var statements = node.type === "Program" ? node.body : node.body.body;
			if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {
				return;
			}

			if (expectLineAfter === "always" && !hasNewlineAfter(lastDirective)) {
				reportError(lastDirective, "after", true);
			}

			if (expectLineAfter === "never" && hasNewlineAfter(lastDirective)) {
				reportError(lastDirective, "after", false);
			}
		}
		return {
			Program: checkDirectives,
			FunctionDeclaration: checkDirectives,
			FunctionExpression: checkDirectives,
			ArrowFunctionExpression: checkDirectives
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow an empty line between class members",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["always", "never"]
		}, {
			type: "object",
			properties: {
				exceptAfterSingleLine: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = [];

		options[0] = context.options[0] || "always";
		options[1] = context.options[1] || { exceptAfterSingleLine: false };

		var ALWAYS_MESSAGE = "Expected blank line between class members.";
		var NEVER_MESSAGE = "Unexpected blank line between class members.";

		var sourceCode = context.getSourceCode();
		function isPaddingBetweenTokens(first, second) {
			return second.loc.start.line - first.loc.end.line >= 2;
		}

		return {
			ClassBody: function ClassBody(node) {
				var body = node.body;

				var _loop = function _loop(i) {
					var curFirst = sourceCode.getFirstToken(body[i]);
					var curLast = sourceCode.getLastToken(body[i]);
					var comments = sourceCode.getCommentsBefore(body[i + 1]);
					var nextFirst = comments.length ? comments[0] : sourceCode.getFirstToken(body[i + 1]);
					var isPadded = isPaddingBetweenTokens(curLast, nextFirst);
					var isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);
					var skip = !isMulti && options[1].exceptAfterSingleLine;

					if (options[0] === "always" && !skip && !isPadded || options[0] === "never" && isPadded) {
						context.report({
							node: body[i + 1],
							message: isPadded ? NEVER_MESSAGE : ALWAYS_MESSAGE,
							fix: function fix(fixer) {
								return isPadded ? fixer.replaceTextRange([curLast.range[1], nextFirst.range[0]], "\n") : fixer.insertTextAfter(curLast, "\n");
							}
						});
					}
				};

				for (var i = 0; i < body.length - 1; i++) {
					_loop(i);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum depth that blocks can be nested",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "integer",
				minimum: 0
			}, {
				type: "object",
				properties: {
					maximum: {
						type: "integer",
						minimum: 0
					},
					max: {
						type: "integer",
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var functionStack = [],
			option = context.options[0];
		var maxDepth = 4;

		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
			maxDepth = option.maximum;
		}
		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
			maxDepth = option.max;
		}
		if (typeof option === "number") {
			maxDepth = option;
		}
		function startFunction() {
			functionStack.push(0);
		}
		function endFunction() {
			functionStack.pop();
		}
		function pushBlock(node) {
			var len = ++functionStack[functionStack.length - 1];

			if (len > maxDepth) {
				context.report({ node: node, message: "Blocks are nested too deeply ({{depth}}).", data: { depth: len } });
			}
		}
		function popBlock() {
			functionStack[functionStack.length - 1]--;
		}
		return {
			Program: startFunction,
			FunctionDeclaration: startFunction,
			FunctionExpression: startFunction,
			ArrowFunctionExpression: startFunction,

			IfStatement: function IfStatement(node) {
				if (node.parent.type !== "IfStatement") {
					pushBlock(node);
				}
			},

			SwitchStatement: pushBlock,
			TryStatement: pushBlock,
			DoWhileStatement: pushBlock,
			WhileStatement: pushBlock,
			WithStatement: pushBlock,
			ForStatement: pushBlock,
			ForInStatement: pushBlock,
			ForOfStatement: pushBlock,

			"IfStatement:exit": popBlock,
			"SwitchStatement:exit": popBlock,
			"TryStatement:exit": popBlock,
			"DoWhileStatement:exit": popBlock,
			"WhileStatement:exit": popBlock,
			"WithStatement:exit": popBlock,
			"ForStatement:exit": popBlock,
			"ForInStatement:exit": popBlock,
			"ForOfStatement:exit": popBlock,

			"FunctionDeclaration:exit": endFunction,
			"FunctionExpression:exit": endFunction,
			"ArrowFunctionExpression:exit": endFunction,
			"Program:exit": endFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var OPTIONS_SCHEMA = {
	type: "object",
	properties: {
		code: {
			type: "integer",
			minimum: 0
		},
		comments: {
			type: "integer",
			minimum: 0
		},
		tabWidth: {
			type: "integer",
			minimum: 0
		},
		ignorePattern: {
			type: "string"
		},
		ignoreComments: {
			type: "boolean"
		},
		ignoreStrings: {
			type: "boolean"
		},
		ignoreUrls: {
			type: "boolean"
		},
		ignoreTemplateLiterals: {
			type: "boolean"
		},
		ignoreRegExpLiterals: {
			type: "boolean"
		},
		ignoreTrailingComments: {
			type: "boolean"
		}
	},
	additionalProperties: false
};

var OPTIONS_OR_INTEGER_SCHEMA = {
	anyOf: [OPTIONS_SCHEMA, {
		type: "integer",
		minimum: 0
	}]
};
module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum line length",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_SCHEMA]
	},

	create: function create(context) {
		var URL_REGEXP = /[^:/?#]:\/\/[^?#]/;

		var sourceCode = context.getSourceCode();
		function computeLineLength(line, tabWidth) {
			var extraCharacterCount = 0;

			line.replace(/\t/g, function (match, offset) {
				var totalOffset = offset + extraCharacterCount,
					previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,
					spaceCount = tabWidth - previousTabStopOffset;

				extraCharacterCount += spaceCount - 1; // -1 for the replaced tab
			});
			return Array.from(line).length + extraCharacterCount;
		}
		var lastOption = context.options[context.options.length - 1];
		var options = (typeof lastOption === "undefined" ? "undefined" : _typeof(lastOption)) === "object" ? Object.create(lastOption) : {};
		if (typeof context.options[0] === "number") {
			options.code = context.options[0];
		}
		if (typeof context.options[1] === "number") {
			options.tabWidth = context.options[1];
		}

		var maxLength = options.code || 80,
			tabWidth = options.tabWidth || 4,
			ignoreComments = options.ignoreComments || false,
			ignoreStrings = options.ignoreStrings || false,
			ignoreTemplateLiterals = options.ignoreTemplateLiterals || false,
			ignoreRegExpLiterals = options.ignoreRegExpLiterals || false,
			ignoreTrailingComments = options.ignoreTrailingComments || options.ignoreComments || false,
			ignoreUrls = options.ignoreUrls || false,
			maxCommentLength = options.comments;
		var ignorePattern = options.ignorePattern || null;

		if (ignorePattern) {
			ignorePattern = new RegExp(ignorePattern);
		}
		function isTrailingComment(line, lineNumber, comment) {
			return comment && comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line && (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
		}
		function isFullLineComment(line, lineNumber, comment) {
			var start = comment.loc.start,
				end = comment.loc.end,
				isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();

			return comment && (start.line < lineNumber || start.line === lineNumber && isFirstTokenOnLine) && (end.line > lineNumber || end.line === lineNumber && end.column === line.length);
		}
		function stripTrailingComment(line, comment) {
			return line.slice(0, comment.loc.start.column).replace(/\s+$/, "");
		}
		function ensureArrayAndPush(object, key, value) {
			if (!Array.isArray(object[key])) {
				object[key] = [];
			}
			object[key].push(value);
		}
		function getAllStrings() {
			return sourceCode.ast.tokens.filter(function (token) {
				return token.type === "String";
			});
		}
		function getAllTemplateLiterals() {
			return sourceCode.ast.tokens.filter(function (token) {
				return token.type === "Template";
			});
		}
		function getAllRegExpLiterals() {
			return sourceCode.ast.tokens.filter(function (token) {
				return token.type === "RegularExpression";
			});
		}
		function groupByLineNumber(acc, node) {
			for (var i = node.loc.start.line; i <= node.loc.end.line; ++i) {
				ensureArrayAndPush(acc, i, node);
			}
			return acc;
		}
		function checkProgramForMaxLength(node) {
			var lines = sourceCode.lines,
			comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? sourceCode.getAllComments() : [];
			var commentsIndex = 0;

			var strings = getAllStrings();
			var stringsByLine = strings.reduce(groupByLineNumber, {});

			var templateLiterals = getAllTemplateLiterals();
			var templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});

			var regExpLiterals = getAllRegExpLiterals();
			var regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});

			lines.forEach(function (line, i) {
				var lineNumber = i + 1;
				var lineIsComment = false;
				if (commentsIndex < comments.length) {
					var comment = null;
					do {
						comment = comments[++commentsIndex];
					} while (comment && comment.loc.start.line <= lineNumber);
					comment = comments[--commentsIndex];

					if (isFullLineComment(line, lineNumber, comment)) {
						lineIsComment = true;
					} else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {
						line = stripTrailingComment(line, comment);
					}
				}
				if (ignorePattern && ignorePattern.test(line) || ignoreUrls && URL_REGEXP.test(line) || ignoreStrings && stringsByLine[lineNumber] || ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]) {
					return;
				}

				var lineLength = computeLineLength(line, tabWidth);
				var commentLengthApplies = lineIsComment && maxCommentLength;

				if (lineIsComment && ignoreComments) {
					return;
				}

				if (commentLengthApplies) {
					if (lineLength > maxCommentLength) {
						context.report({
							node: node,
							loc: { line: lineNumber, column: 0 },
							message: "Line {{lineNumber}} exceeds the maximum comment line length of {{maxCommentLength}}.",
							data: {
								lineNumber: i + 1,
								maxCommentLength: maxCommentLength
							}
						});
					}
				} else if (lineLength > maxLength) {
					context.report({
						node: node,
						loc: { line: lineNumber, column: 0 },
						message: "Line {{lineNumber}} exceeds the maximum line length of {{maxLength}}.",
						data: {
							lineNumber: i + 1,
							maxLength: maxLength
						}
					});
				}
			});
		}
		return {
			Program: checkProgramForMaxLength
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var lodash = __webpack_require__(10);
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum number of lines per file",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "integer",
				minimum: 0
			}, {
				type: "object",
				properties: {
					max: {
						type: "integer",
						minimum: 0
					},
					skipComments: {
						type: "boolean"
					},
					skipBlankLines: {
						type: "boolean"
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var option = context.options[0];
		var max = 300;

		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
			max = option.max;
		}

		if (typeof option === "number") {
			max = option;
		}

		var skipComments = option && option.skipComments;
		var skipBlankLines = option && option.skipBlankLines;

		var sourceCode = context.getSourceCode();
		function isCommentNodeType(token) {
			return token && (token.type === "Block" || token.type === "Line");
		}
		function getLinesWithoutCode(comment) {
			var start = comment.loc.start.line;
			var end = comment.loc.end.line;

			var token = void 0;

			token = comment;
			do {
				token = sourceCode.getTokenBefore(token, { includeComments: true });
			} while (isCommentNodeType(token));

			if (token && astUtils.isTokenOnSameLine(token, comment)) {
				start += 1;
			}

			token = comment;
			do {
				token = sourceCode.getTokenAfter(token, { includeComments: true });
			} while (isCommentNodeType(token));

			if (token && astUtils.isTokenOnSameLine(comment, token)) {
				end -= 1;
			}

			if (start <= end) {
				return lodash.range(start, end + 1);
			}
			return [];
		}

		return {
			"Program:exit": function ProgramExit() {
				var lines = sourceCode.lines.map(function (text, i) {
					return { lineNumber: i + 1, text: text };
				});

				if (skipBlankLines) {
					lines = lines.filter(function (l) {
						return l.text.trim() !== "";
					});
				}

				if (skipComments) {
					var comments = sourceCode.getAllComments();

					var commentLines = lodash.flatten(comments.map(function (comment) {
						return getLinesWithoutCode(comment);
					}));

					lines = lines.filter(function (l) {
						return !lodash.includes(commentLines, l.lineNumber);
					});
				}

				if (lines.length > max) {
					context.report({
						loc: { line: 1, column: 0 },
						message: "File must be at most {{max}} lines long. It's {{actual}} lines long.",
						data: {
							max: max,
							actual: lines.length
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum depth that callbacks can be nested",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "integer",
				minimum: 0
			}, {
				type: "object",
				properties: {
					maximum: {
						type: "integer",
						minimum: 0
					},
					max: {
						type: "integer",
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var option = context.options[0];
		var THRESHOLD = 10;

		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
			THRESHOLD = option.maximum;
		}
		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
			THRESHOLD = option.max;
		}
		if (typeof option === "number") {
			THRESHOLD = option;
		}
		var callbackStack = [];
		function checkFunction(node) {
			var parent = node.parent;

			if (parent.type === "CallExpression") {
				callbackStack.push(node);
			}

			if (callbackStack.length > THRESHOLD) {
				var opts = { num: callbackStack.length, max: THRESHOLD };

				context.report({ node: node, message: "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}.", data: opts });
			}
		}
		function popStack() {
			callbackStack.pop();
		}
		return {
			ArrowFunctionExpression: checkFunction,
			"ArrowFunctionExpression:exit": popStack,

			FunctionExpression: checkFunction,
			"FunctionExpression:exit": popStack
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var lodash = __webpack_require__(10);

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum number of parameters in function definitions",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "integer",
				minimum: 0
			}, {
				type: "object",
				properties: {
					maximum: {
						type: "integer",
						minimum: 0
					},
					max: {
						type: "integer",
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {

		var option = context.options[0];
		var numParams = 3;

		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
			numParams = option.maximum;
		}
		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
			numParams = option.max;
		}
		if (typeof option === "number") {
			numParams = option;
		}
		function checkFunction(node) {
			if (node.params.length > numParams) {
				context.report({
					node: node,
					message: "{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}.",
					data: {
						name: lodash.upperFirst(astUtils.getFunctionNameWithKind(node)),
						count: node.params.length,
						max: numParams
					}
				});
			}
		}

		return {
			FunctionDeclaration: checkFunction,
			ArrowFunctionExpression: checkFunction,
			FunctionExpression: checkFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum number of statements allowed per line",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				max: {
					type: "integer",
					minimum: 1
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode(),
			options = context.options[0] || {},
			maxStatementsPerLine = typeof options.max !== "undefined" ? options.max : 1,
			message = "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}.";

		var lastStatementLine = 0,
			numberOfStatementsOnThisLine = 0,
			firstExtraStatement = void 0;
		var SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/;
		function reportFirstExtraStatementAndClear() {
			if (firstExtraStatement) {
				context.report({
					node: firstExtraStatement,
					message: message,
					data: {
						numberOfStatementsOnThisLine: numberOfStatementsOnThisLine,
						maxStatementsPerLine: maxStatementsPerLine,
						statements: numberOfStatementsOnThisLine === 1 ? "statement" : "statements"
					}
				});
			}
			firstExtraStatement = null;
		}
		function getActualLastToken(node) {
			return sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
		}
		function enterStatement(node) {
			var line = node.loc.start.line;
			if (SINGLE_CHILD_ALLOWED.test(node.parent.type) && node.parent.alternate !== node) {
				return;
			}
			if (line === lastStatementLine) {
				numberOfStatementsOnThisLine += 1;
			} else {
				reportFirstExtraStatementAndClear();
				numberOfStatementsOnThisLine = 1;
				lastStatementLine = line;
			}
			if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {
				firstExtraStatement = firstExtraStatement || node;
			}
		}
		function leaveStatement(node) {
			var line = getActualLastToken(node).loc.end.line;
			if (line !== lastStatementLine) {
				reportFirstExtraStatementAndClear();
				numberOfStatementsOnThisLine = 1;
				lastStatementLine = line;
			}
		}
		return {
			BreakStatement: enterStatement,
			ClassDeclaration: enterStatement,
			ContinueStatement: enterStatement,
			DebuggerStatement: enterStatement,
			DoWhileStatement: enterStatement,
			ExpressionStatement: enterStatement,
			ForInStatement: enterStatement,
			ForOfStatement: enterStatement,
			ForStatement: enterStatement,
			FunctionDeclaration: enterStatement,
			IfStatement: enterStatement,
			ImportDeclaration: enterStatement,
			LabeledStatement: enterStatement,
			ReturnStatement: enterStatement,
			SwitchStatement: enterStatement,
			ThrowStatement: enterStatement,
			TryStatement: enterStatement,
			VariableDeclaration: enterStatement,
			WhileStatement: enterStatement,
			WithStatement: enterStatement,
			ExportNamedDeclaration: enterStatement,
			ExportDefaultDeclaration: enterStatement,
			ExportAllDeclaration: enterStatement,

			"BreakStatement:exit": leaveStatement,
			"ClassDeclaration:exit": leaveStatement,
			"ContinueStatement:exit": leaveStatement,
			"DebuggerStatement:exit": leaveStatement,
			"DoWhileStatement:exit": leaveStatement,
			"ExpressionStatement:exit": leaveStatement,
			"ForInStatement:exit": leaveStatement,
			"ForOfStatement:exit": leaveStatement,
			"ForStatement:exit": leaveStatement,
			"FunctionDeclaration:exit": leaveStatement,
			"IfStatement:exit": leaveStatement,
			"ImportDeclaration:exit": leaveStatement,
			"LabeledStatement:exit": leaveStatement,
			"ReturnStatement:exit": leaveStatement,
			"SwitchStatement:exit": leaveStatement,
			"ThrowStatement:exit": leaveStatement,
			"TryStatement:exit": leaveStatement,
			"VariableDeclaration:exit": leaveStatement,
			"WhileStatement:exit": leaveStatement,
			"WithStatement:exit": leaveStatement,
			"ExportNamedDeclaration:exit": leaveStatement,
			"ExportDefaultDeclaration:exit": leaveStatement,
			"ExportAllDeclaration:exit": leaveStatement,
			"Program:exit": reportFirstExtraStatementAndClear
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var lodash = __webpack_require__(10);

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum number of statements allowed in function blocks",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "integer",
				minimum: 0
			}, {
				type: "object",
				properties: {
					maximum: {
						type: "integer",
						minimum: 0
					},
					max: {
						type: "integer",
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}, {
			type: "object",
			properties: {
				ignoreTopLevelFunctions: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var functionStack = [],
			option = context.options[0],
			ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,
			topLevelFunctions = [];
		var maxStatements = 10;

		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
			maxStatements = option.maximum;
		}
		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
			maxStatements = option.max;
		}
		if (typeof option === "number") {
			maxStatements = option;
		}
		function reportIfTooManyStatements(node, count, max) {
			if (count > max) {
				var name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));

				context.report({
					node: node,
					message: "{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}.",
					data: { name: name, count: count, max: max }
				});
			}
		}
		function startFunction() {
			functionStack.push(0);
		}
		function endFunction(node) {
			var count = functionStack.pop();

			if (ignoreTopLevelFunctions && functionStack.length === 0) {
				topLevelFunctions.push({ node: node, count: count });
			} else {
				reportIfTooManyStatements(node, count, maxStatements);
			}
		}
		function countStatements(node) {
			functionStack[functionStack.length - 1] += node.body.length;
		}
		return {
			FunctionDeclaration: startFunction,
			FunctionExpression: startFunction,
			ArrowFunctionExpression: startFunction,

			BlockStatement: countStatements,

			"FunctionDeclaration:exit": endFunction,
			"FunctionExpression:exit": endFunction,
			"ArrowFunctionExpression:exit": endFunction,

			"Program:exit": function ProgramExit() {
				if (topLevelFunctions.length === 1) {
					return;
				}

				topLevelFunctions.forEach(function (element) {
					var count = element.count;
					var node = element.node;

					reportIfTooManyStatements(node, count, maxStatements);
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce a particular style for multiline comments",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{ enum: ["starred-block", "separate-lines", "bare-block"] }]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var option = context.options[0] || "starred-block";

		var EXPECTED_BLOCK_ERROR = "Expected a block comment instead of consecutive line comments.";
		var START_NEWLINE_ERROR = "Expected a linebreak after '/*'.";
		var END_NEWLINE_ERROR = "Expected a linebreak before '*/'.";
		var MISSING_STAR_ERROR = "Expected a '*' at the start of this line.";
		var ALIGNMENT_ERROR = "Expected this line to be aligned with the start of the comment.";
		var EXPECTED_LINES_ERROR = "Expected multiple line comments instead of a block comment.";
		function getCommentLines(commentGroup) {
			if (commentGroup[0].type === "Line") {
				return commentGroup.map(function (comment) {
					return comment.value;
				});
			}
			return commentGroup[0].value.split(astUtils.LINEBREAK_MATCHER).map(function (line) {
				return line.replace(/^\s*\*?/, "");
			});
		}
		function convertToStarredBlock(firstComment, commentLinesList) {
			var initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
			var starredLines = commentLinesList.map(function (line) {
				return initialOffset + " *" + line;
			});

			return "\n" + starredLines.join("\n") + "\n" + initialOffset + " ";
		}
		function convertToSeparateLines(firstComment, commentLinesList) {
			var initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
			var separateLines = commentLinesList.map(function (line) {
				return "// " + line.trim();
			});

			return separateLines.join("\n" + initialOffset);
		}
		function convertToBlock(firstComment, commentLinesList) {
			var initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
			var blockLines = commentLinesList.map(function (line) {
				return line.trim();
			});

			return "/* " + blockLines.join("\n" + initialOffset + "   ") + " */";
		}
		function isJSDoc(commentGroup) {
			var lines = commentGroup[0].value.split(astUtils.LINEBREAK_MATCHER);

			return commentGroup[0].type === "Block" && /^\*\s*$/.test(lines[0]) && lines.slice(1, -1).every(function (line) {
				return (/^\s* /.test(line)
				);
			}) && /^\s*$/.test(lines[lines.length - 1]);
		}
		var commentGroupCheckers = {
			"starred-block": function starredBlock(commentGroup) {
				var commentLines = getCommentLines(commentGroup);

				if (commentLines.some(function (value) {
					return value.includes("*/");
				})) {
					return;
				}

				if (commentGroup.length > 1) {
					context.report({
						loc: {
							start: commentGroup[0].loc.start,
							end: commentGroup[commentGroup.length - 1].loc.end
						},
						message: EXPECTED_BLOCK_ERROR,
						fix: function fix(fixer) {
							var range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];
							var starredBlock = "/*" + convertToStarredBlock(commentGroup[0], commentLines) + "*/";

							return commentLines.some(function (value) {
								return value.startsWith("/");
							}) ? null : fixer.replaceTextRange(range, starredBlock);
						}
					});
				} else {
					(function () {
						var block = commentGroup[0];
						var lines = block.value.split(astUtils.LINEBREAK_MATCHER);
						var expectedLinePrefix = sourceCode.text.slice(block.range[0] - block.loc.start.column, block.range[0]) + " *";

						if (!/^\*?\s*$/.test(lines[0])) {
							var start = block.value.startsWith("*") ? block.range[0] + 1 : block.range[0];

							context.report({
								loc: {
									start: block.loc.start,
									end: { line: block.loc.start.line, column: block.loc.start.column + 2 }
								},
								message: START_NEWLINE_ERROR,
								fix: function fix(fixer) {
									return fixer.insertTextAfterRange([start, start + 2], "\n" + expectedLinePrefix);
								}
							});
						}

						if (!/^\s*$/.test(lines[lines.length - 1])) {
							context.report({
								loc: {
									start: { line: block.loc.end.line, column: block.loc.end.column - 2 },
									end: block.loc.end
								},
								message: END_NEWLINE_ERROR,
								fix: function fix(fixer) {
									return fixer.replaceTextRange([block.range[1] - 2, block.range[1]], "\n" + expectedLinePrefix + "/");
								}
							});
						}

						var _loop = function _loop(lineNumber) {
							var lineText = sourceCode.lines[lineNumber - 1];

							if (!lineText.startsWith(expectedLinePrefix)) {
								context.report({
									loc: {
										start: { line: lineNumber, column: 0 },
										end: { line: lineNumber, column: sourceCode.lines[lineNumber - 1].length }
									},
									message: /^\s*\*/.test(lineText) ? ALIGNMENT_ERROR : MISSING_STAR_ERROR,
									fix: function fix(fixer) {
										var lineStartIndex = sourceCode.getIndexFromLoc({ line: lineNumber, column: 0 });
										var linePrefixLength = lineText.match(/^\s*\*? ?/)[0].length;
										var commentStartIndex = lineStartIndex + linePrefixLength;

										var replacementText = lineNumber === block.loc.end.line || lineText.length === linePrefixLength ? expectedLinePrefix : expectedLinePrefix + " ";

										return fixer.replaceTextRange([lineStartIndex, commentStartIndex], replacementText);
									}
								});
							}
						};

						for (var lineNumber = block.loc.start.line + 1; lineNumber <= block.loc.end.line; lineNumber++) {
							_loop(lineNumber);
						}
					})();
				}
			},
			"separate-lines": function separateLines(commentGroup) {
				if (!isJSDoc(commentGroup) && commentGroup[0].type === "Block") {
					var commentLines = getCommentLines(commentGroup);
					var block = commentGroup[0];
					var tokenAfter = sourceCode.getTokenAfter(block, { includeComments: true });

					if (tokenAfter && block.loc.end.line === tokenAfter.loc.start.line) {
						return;
					}

					context.report({
						loc: {
							start: block.loc.start,
							end: { line: block.loc.start.line, column: block.loc.start.column + 2 }
						},
						message: EXPECTED_LINES_ERROR,
						fix: function fix(fixer) {
							return fixer.replaceText(block, convertToSeparateLines(block, commentLines.filter(function (line) {
								return line;
							})));
						}
					});
				}
			},
			"bare-block": function bareBlock(commentGroup) {
				if (!isJSDoc(commentGroup)) {
					var commentLines = getCommentLines(commentGroup);
					if (commentGroup[0].type === "Line" && commentLines.length > 1 && !commentLines.some(function (value) {
						return value.includes("*/");
					})) {
						context.report({
							loc: {
								start: commentGroup[0].loc.start,
								end: commentGroup[commentGroup.length - 1].loc.end
							},
							message: EXPECTED_BLOCK_ERROR,
							fix: function fix(fixer) {
								var range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];
								var block = convertToBlock(commentGroup[0], commentLines.filter(function (line) {
									return line;
								}));

								return fixer.replaceTextRange(range, block);
							}
						});
					}
					if (commentGroup[0].type === "Block") {
						var block = commentGroup[0];
						var lines = block.value.split(astUtils.LINEBREAK_MATCHER).filter(function (line) {
							return line.trim();
						});

						if (lines.length > 0 && lines.every(function (line) {
							return (/^\s*\*/.test(line)
							);
						})) {
							context.report({
								loc: {
									start: block.loc.start,
									end: { line: block.loc.start.line, column: block.loc.start.column + 2 }
								},
								message: EXPECTED_BLOCK_ERROR,
								fix: function fix(fixer) {
									return fixer.replaceText(block, convertToBlock(block, commentLines.filter(function (line) {
										return line;
									})));
								}
							});
						}
					}
				}
			}
		};
		return {
			Program: function Program() {
				return sourceCode.getAllComments().filter(function (comment) {
					return comment.type !== "Shebang";
				}).filter(function (comment) {
					return !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value);
				}).filter(function (comment) {
					var tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });

					return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;
				}).reduce(function (commentGroups, comment, index, commentList) {
					var tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });

					if (comment.type === "Line" && index && commentList[index - 1].type === "Line" && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {
						commentGroups[commentGroups.length - 1].push(comment);
					} else {
						commentGroups.push([comment]);
					}

					return commentGroups;
				}, []).filter(function (commentGroup) {
					return !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line);
				}).forEach(commentGroupCheckers[option]);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce newlines between operands of ternary expressions",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: [{
			enum: ["always", "always-multiline", "never"]
		}]
	},

	create: function create(context) {
		var option = context.options[0];
		var multiline = option !== "never";
		var allowSingleLine = option === "always-multiline";
		function reportError(node, parentNode, expected) {
			context.report({
				node: node,
				message: "{{expected}} newline between {{typeOfError}} of ternary expression.",
				data: {
					expected: expected ? "Expected" : "Unexpected",
					typeOfError: node === parentNode.test ? "test and consequent" : "consequent and alternate"
				}
			});
		}
		return {
			ConditionalExpression: function ConditionalExpression(node) {
				var areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(node.test, node.consequent);
				var areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(node.consequent, node.alternate);

				if (!multiline) {
					if (!areTestAndConsequentOnSameLine) {
						reportError(node.test, node, false);
					}

					if (!areConsequentAndAlternateOnSameLine) {
						reportError(node.consequent, node, false);
					}
				} else {
					if (allowSingleLine && node.loc.start.line === node.loc.end.line) {
						return;
					}

					if (areTestAndConsequentOnSameLine) {
						reportError(node.test, node, true);
					}

					if (areConsequentAndAlternateOnSameLine) {
						reportError(node.consequent, node, true);
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var CAPS_ALLOWED = ["Array", "Boolean", "Date", "Error", "Function", "Number", "Object", "RegExp", "String", "Symbol"];
function checkArray(obj, key, fallback) {
	if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {
		throw new TypeError(key + ", if provided, must be an Array");
	}
	return obj[key] || fallback;
}
function invert(map, key) {
	map[key] = true;
	return map;
}
function calculateCapIsNewExceptions(config) {
	var capIsNewExceptions = checkArray(config, "capIsNewExceptions", CAPS_ALLOWED);

	if (capIsNewExceptions !== CAPS_ALLOWED) {
		capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);
	}

	return capIsNewExceptions.reduce(invert, {});
}
module.exports = {
	meta: {
		docs: {
			description: "require constructor names to begin with a capital letter",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				newIsCap: {
					type: "boolean"
				},
				capIsNew: {
					type: "boolean"
				},
				newIsCapExceptions: {
					type: "array",
					items: {
						type: "string"
					}
				},
				newIsCapExceptionPattern: {
					type: "string"
				},
				capIsNewExceptions: {
					type: "array",
					items: {
						type: "string"
					}
				},
				capIsNewExceptionPattern: {
					type: "string"
				},
				properties: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var config = context.options[0] ? Object.assign({}, context.options[0]) : {};

		config.newIsCap = config.newIsCap !== false;
		config.capIsNew = config.capIsNew !== false;
		var skipProperties = config.properties === false;

		var newIsCapExceptions = checkArray(config, "newIsCapExceptions", []).reduce(invert, {});
		var newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern) : null;

		var capIsNewExceptions = calculateCapIsNewExceptions(config);
		var capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern) : null;

		var listeners = {};

		var sourceCode = context.getSourceCode();
		function extractNameFromExpression(node) {

			var name = "";

			if (node.callee.type === "MemberExpression") {
				var property = node.callee.property;

				if (property.type === "Literal" && typeof property.value === "string") {
					name = property.value;
				} else if (property.type === "Identifier" && !node.callee.computed) {
					name = property.name;
				}
			} else {
				name = node.callee.name;
			}
			return name;
		}
		function getCap(str) {
			var firstChar = str.charAt(0);

			var firstCharLower = firstChar.toLowerCase();
			var firstCharUpper = firstChar.toUpperCase();

			if (firstCharLower === firstCharUpper) {
				return "non-alpha";
			}
			if (firstChar === firstCharLower) {
				return "lower";
			}
			return "upper";
		}
		function isCapAllowed(allowedMap, node, calleeName, pattern) {
			var sourceText = sourceCode.getText(node.callee);

			if (allowedMap[calleeName] || allowedMap[sourceText]) {
				return true;
			}

			if (pattern && pattern.test(sourceText)) {
				return true;
			}

			if (calleeName === "UTC" && node.callee.type === "MemberExpression") {
				return node.callee.object.type === "Identifier" && node.callee.object.name === "Date";
			}

			return skipProperties && node.callee.type === "MemberExpression";
		}
		function report(node, message) {
			var callee = node.callee;

			if (callee.type === "MemberExpression") {
				callee = callee.property;
			}

			context.report({ node: node, loc: callee.loc.start, message: message });
		}
		if (config.newIsCap) {
			listeners.NewExpression = function (node) {

				var constructorName = extractNameFromExpression(node);

				if (constructorName) {
					var capitalization = getCap(constructorName);
					var isAllowed = capitalization !== "lower" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);

					if (!isAllowed) {
						report(node, "A constructor name should not start with a lowercase letter.");
					}
				}
			};
		}

		if (config.capIsNew) {
			listeners.CallExpression = function (node) {

				var calleeName = extractNameFromExpression(node);

				if (calleeName) {
					var capitalization = getCap(calleeName);
					var isAllowed = capitalization !== "upper" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);

					if (!isAllowed) {
						report(node, "A function with a name starting with an uppercase letter should only be used as a constructor.");
					}
				}
			};
		}

		return listeners;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require parentheses when invoking a constructor with no arguments",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			NewExpression: function NewExpression(node) {
				if (node.arguments.length !== 0) {
					return; // shortcut: if there are arguments, there have to be parens
				}

				var lastToken = sourceCode.getLastToken(node);
				var hasLastParen = lastToken && astUtils.isClosingParenToken(lastToken);
				var hasParens = hasLastParen && astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken));

				if (!hasParens) {
					context.report({
						node: node,
						message: "Missing '()' invoking a constructor.",
						fix: function fix(fixer) {
							return fixer.insertTextAfter(node, "()");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow an empty line after variable declarations",
			category: "Stylistic Issues",
			recommended: false,
			replacedBy: ["padding-line-between-statements"]
		},

		schema: [{
			enum: ["never", "always"]
		}],

		fixable: "whitespace",

		deprecated: true
	},

	create: function create(context) {

		var ALWAYS_MESSAGE = "Expected blank line after variable declarations.",
			NEVER_MESSAGE = "Unexpected blank line after variable declarations.";

		var sourceCode = context.getSourceCode();
		var mode = context.options[0] === "never" ? "never" : "always";
		var commentEndLine = sourceCode.getAllComments().reduce(function (result, token) {
			result[token.loc.start.line] = token.loc.end.line;
			return result;
		}, {});
		function getLastToken(node) {
			var lastToken = sourceCode.getLastToken(node);

			if (lastToken.type === "Punctuator" && lastToken.value === ";") {
				var prevToken = sourceCode.getTokenBefore(lastToken);

				if (prevToken.loc.end.line !== lastToken.loc.start.line) {
					return prevToken;
				}
			}

			return lastToken;
		}
		function isVar(keyword) {
			return keyword === "var" || keyword === "let" || keyword === "const";
		}
		function isForTypeSpecifier(keyword) {
			return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
		}
		function isExportSpecifier(nodeType) {
			return nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportAllDeclaration";
		}
		function isLastNode(node) {
			var token = sourceCode.getTokenAfter(node);

			return !token || token.type === "Punctuator" && token.value === "}";
		}
		function getLastCommentLineOfBlock(commentStartLine) {
			var currentCommentEnd = commentEndLine[commentStartLine];

			return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;
		}
		function hasBlankLineAfterComment(token, commentStartLine) {
			return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;
		}
		function checkForBlankLine(node) {
			var lastToken = getLastToken(node),
			nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),
				nextLineNum = lastToken.loc.end.line + 1;
			if (!nextToken) {
				return;
			}
			if (isForTypeSpecifier(node.parent.type)) {
				return;
			}
			if (isExportSpecifier(node.parent.type)) {
				return;
			}
			if (nextToken.type === "Keyword" && isVar(nextToken.value)) {
				return;
			}
			if (isLastNode(node)) {
				return;
			}
			var noNextLineToken = nextToken.loc.start.line > nextLineNum;
			var hasNextLineComment = typeof commentEndLine[nextLineNum] !== "undefined";

			if (mode === "never" && noNextLineToken && !hasNextLineComment) {
				context.report({
					node: node,
					message: NEVER_MESSAGE,
					data: { identifier: node.name },
					fix: function fix(fixer) {
						var linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);

						return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], linesBetween.slice(0, -1).join("") + "\n" + linesBetween[linesBetween.length - 1]);
					}
				});
			}
			if (mode === "always" && (!noNextLineToken || hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum))) {
				context.report({
					node: node,
					message: ALWAYS_MESSAGE,
					data: { identifier: node.name },
					fix: function fix(fixer) {
						if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {
							return fixer.insertTextBefore(nextToken, "\n\n");
						}

						return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], "\n");
					}
				});
			}
		}
		return {
			VariableDeclaration: checkForBlankLine
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require an empty line before `return` statements",
			category: "Stylistic Issues",
			recommended: false,
			replacedBy: ["padding-line-between-statements"]
		},
		fixable: "whitespace",
		schema: [],
		deprecated: true
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function isPrecededByTokens(node, testTokens) {
			var tokenBefore = sourceCode.getTokenBefore(node);

			return testTokens.some(function (token) {
				return tokenBefore.value === token;
			});
		}
		function isFirstNode(node) {
			var parentType = node.parent.type;

			if (node.parent.body) {
				return Array.isArray(node.parent.body) ? node.parent.body[0] === node : node.parent.body === node;
			}

			if (parentType === "IfStatement") {
				return isPrecededByTokens(node, ["else", ")"]);
			}
			if (parentType === "DoWhileStatement") {
				return isPrecededByTokens(node, ["do"]);
			}
			if (parentType === "SwitchCase") {
				return isPrecededByTokens(node, [":"]);
			}
			return isPrecededByTokens(node, [")"]);
		}
		function calcCommentLines(node, lineNumTokenBefore) {
			var comments = sourceCode.getCommentsBefore(node);
			var numLinesComments = 0;

			if (!comments.length) {
				return numLinesComments;
			}

			comments.forEach(function (comment) {
				numLinesComments++;

				if (comment.type === "Block") {
					numLinesComments += comment.loc.end.line - comment.loc.start.line;
				}
				if (comment.loc.start.line === lineNumTokenBefore) {
					numLinesComments--;
				}

				if (comment.loc.end.line === node.loc.start.line) {
					numLinesComments--;
				}
			});

			return numLinesComments;
		}
		function getLineNumberOfTokenBefore(node) {
			var tokenBefore = sourceCode.getTokenBefore(node);
			var lineNumTokenBefore = void 0;
			if (tokenBefore) {
				lineNumTokenBefore = tokenBefore.loc.end.line;
			} else {
				lineNumTokenBefore = 0; // global return at beginning of script
			}

			return lineNumTokenBefore;
		}
		function hasNewlineBefore(node) {
			var lineNumNode = node.loc.start.line;
			var lineNumTokenBefore = getLineNumberOfTokenBefore(node);
			var commentLines = calcCommentLines(node, lineNumTokenBefore);

			return lineNumNode - lineNumTokenBefore - commentLines > 1;
		}
		function canFix(node) {
			var leadingComments = sourceCode.getCommentsBefore(node);
			var lastLeadingComment = leadingComments[leadingComments.length - 1];
			var tokenBefore = sourceCode.getTokenBefore(node);

			if (leadingComments.length === 0) {
				return true;
			}
			if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line && lastLeadingComment.loc.end.line !== node.loc.start.line) {
				return true;
			}

			return false;
		}
		return {
			ReturnStatement: function ReturnStatement(node) {
				if (!isFirstNode(node) && !hasNewlineBefore(node)) {
					context.report({
						node: node,
						message: "Expected newline before return statement.",
						fix: function fix(fixer) {
							if (canFix(node)) {
								var tokenBefore = sourceCode.getTokenBefore(node);
								var newlines = node.loc.start.line === tokenBefore.loc.end.line ? "\n\n" : "\n";

								return fixer.insertTextBefore(node, newlines);
							}
							return null;
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require a newline after each call in a method chain",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			type: "object",
			properties: {
				ignoreChainWithDepth: {
					type: "integer",
					minimum: 1,
					maximum: 10
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = context.options[0] || {},
			ignoreChainWithDepth = options.ignoreChainWithDepth || 2;

		var sourceCode = context.getSourceCode();
		function getPrefix(node) {
			return node.computed ? "[" : ".";
		}
		function getPropertyText(node) {
			var prefix = getPrefix(node);
			var lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);
			var suffix = node.computed && lines.length === 1 ? "]" : "";

			return prefix + lines[0] + suffix;
		}

		return {
			"CallExpression:exit": function CallExpressionExit(node) {
				if (!node.callee || node.callee.type !== "MemberExpression") {
					return;
				}

				var callee = node.callee;
				var parent = callee.object;
				var depth = 1;

				while (parent && parent.callee) {
					depth += 1;
					parent = parent.callee.object;
				}

				if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {
					context.report({
						node: callee.property,
						loc: callee.property.loc.start,
						message: "Expected line break before `{{callee}}`.",
						data: {
							callee: getPropertyText(callee)
						},
						fix: function fix(fixer) {
							var firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);

							return fixer.insertTextBefore(firstTokenAfterObject, "\n");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var getPropertyName = __webpack_require__(0).getStaticPropertyName;
function isProhibitedIdentifier(name) {
	return (/^(alert|confirm|prompt)$/.test(name)
	);
}
function report(context, node, identifierName) {
	context.report(node, "Unexpected {{name}}.", { name: identifierName });
}
function findReference(scope, node) {
	var references = scope.references.filter(function (reference) {
		return reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1];
	});

	if (references.length === 1) {
		return references[0];
	}
	return null;
}
function isShadowed(scope, node) {
	var reference = findReference(scope, node);

	return reference && reference.resolved && reference.resolved.defs.length > 0;
}
function isGlobalThisReferenceOrGlobalWindow(scope, node) {
	if (scope.type === "global" && node.type === "ThisExpression") {
		return true;
	}
	if (node.name === "window") {
		return !isShadowed(scope, node);
	}

	return false;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `alert`, `confirm`, and `prompt`",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		return {
			CallExpression: function CallExpression(node) {
				var callee = node.callee,
					currentScope = context.getScope();
				if (callee.type === "Identifier") {
					var identifierName = callee.name;

					if (!isShadowed(currentScope, callee) && isProhibitedIdentifier(callee.name)) {
						report(context, node, identifierName);
					}
				} else if (callee.type === "MemberExpression" && isGlobalThisReferenceOrGlobalWindow(currentScope, callee.object)) {
					var _identifierName = getPropertyName(callee);

					if (isProhibitedIdentifier(_identifierName)) {
						report(context, node, _identifierName);
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `Array` constructors",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function check(node) {
			if (node.arguments.length !== 1 && node.callee.type === "Identifier" && node.callee.name === "Array") {
				context.report({ node: node, message: "The array literal notation [] is preferrable." });
			}
		}

		return {
			CallExpression: check,
			NewExpression: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var loopTypes = new Set(["ForStatement", "ForOfStatement", "ForInStatement", "WhileStatement", "DoWhileStatement"]);
var boundaryTypes = new Set(["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"]);

module.exports = {
	meta: {
		docs: {
			description: "disallow `await` inside of loops",
			category: "Possible Errors",
			recommended: false
		},
		schema: []
	},
	create: function create(context) {
		return {
			AwaitExpression: function AwaitExpression(node) {
				var ancestors = context.getAncestors();
				ancestors.reverse();
				var ancestorSet = new Set(ancestors).add(node);

				for (var i = 0; i < ancestors.length; i++) {
					var ancestor = ancestors[i];

					if (boundaryTypes.has(ancestor.type)) {
						return;
					}
					if (loopTypes.has(ancestor.type)) {
						if (ancestorSet.has(ancestor.body) || ancestorSet.has(ancestor.test) || ancestorSet.has(ancestor.update)) {
							context.report({
								node: node,
								message: "Unexpected `await` inside a loop."
							});
							return;
						}
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var BITWISE_OPERATORS = ["^", "|", "&", "<<", ">>", ">>>", "^=", "|=", "&=", "<<=", ">>=", ">>>=", "~"];
module.exports = {
	meta: {
		docs: {
			description: "disallow bitwise operators",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allow: {
					type: "array",
					items: {
						enum: BITWISE_OPERATORS
					},
					uniqueItems: true
				},
				int32Hint: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var allowed = options.allow || [];
		var int32Hint = options.int32Hint === true;
		function report(node) {
			context.report({ node: node, message: "Unexpected use of '{{operator}}'.", data: { operator: node.operator } });
		}
		function hasBitwiseOperator(node) {
			return BITWISE_OPERATORS.indexOf(node.operator) !== -1;
		}
		function allowedOperator(node) {
			return allowed.indexOf(node.operator) !== -1;
		}
		function isInt32Hint(node) {
			return int32Hint && node.operator === "|" && node.right && node.right.type === "Literal" && node.right.value === 0;
		}
		function checkNodeForBitwiseOperator(node) {
			if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {
				report(node);
			}
		}

		return {
			AssignmentExpression: checkNodeForBitwiseOperator,
			BinaryExpression: checkNodeForBitwiseOperator,
			UnaryExpression: checkNodeForBitwiseOperator
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow use of the Buffer() constructor",
			category: "Node.js and CommonJS",
			recommended: false
		},
		schema: []
	},

	create: function create(context) {
		return {
			"CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']": function CallExpressionCalleeNameBufferNewExpressionCalleeNameBuffer(node) {
				context.report({
					node: node,
					message: "{{example}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead.",
					data: { example: node.type === "CallExpression" ? "Buffer()" : "new Buffer()" }
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `arguments.caller` or `arguments.callee`",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			MemberExpression: function MemberExpression(node) {
				var objectName = node.object.name,
					propertyName = node.property.name;

				if (objectName === "arguments" && !node.computed && propertyName && propertyName.match(/^calle[er]$/)) {
					context.report({ node: node, message: "Avoid arguments.{{property}}.", data: { property: propertyName } });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow lexical declarations in case clauses",
			category: "Best Practices",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function isLexicalDeclaration(node) {
			switch (node.type) {
				case "FunctionDeclaration":
				case "ClassDeclaration":
					return true;
				case "VariableDeclaration":
					return node.kind !== "var";
				default:
					return false;
			}
		}

		return {
			SwitchCase: function SwitchCase(node) {
				for (var i = 0; i < node.consequent.length; i++) {
					var statement = node.consequent[i];

					if (isLexicalDeclaration(statement)) {
						context.report({
							node: node,
							message: "Unexpected lexical declaration in case block."
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow `catch` clause parameters from shadowing variables in the outer scope",
			category: "Variables",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function paramIsShadowing(scope, name) {
			return astUtils.getVariableByName(scope, name) !== null;
		}
		return {
			CatchClause: function CatchClause(node) {
				var scope = context.getScope();
				if (scope.block === node) {
					scope = scope.upper;
				}

				if (paramIsShadowing(scope, node.param.name)) {
					context.report({ node: node, message: "Value of '{{name}}' may be overwritten in IE 8 and earlier.", data: { name: node.param.name } });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow reassigning class members",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function checkVariable(variable) {
			astUtils.getModifyingReferences(variable.references).forEach(function (reference) {
				context.report({ node: reference.identifier, message: "'{{name}}' is a class.", data: { name: reference.identifier.name } });
			});
		}
		function checkForClass(node) {
			context.getDeclaredVariables(node).forEach(checkVariable);
		}

		return {
			ClassDeclaration: checkForClass,
			ClassExpression: checkForClass
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow comparing against -0",
			category: "Possible Errors",
			recommended: true
		},
		fixable: null,
		schema: []
	},

	create: function create(context) {
		function isNegZero(node) {
			return node.type === "UnaryExpression" && node.operator === "-" && node.argument.type === "Literal" && node.argument.value === 0;
		}
		var OPERATORS_TO_CHECK = new Set([">", ">=", "<", "<=", "==", "===", "!=", "!=="]);

		return {
			BinaryExpression: function BinaryExpression(node) {
				if (OPERATORS_TO_CHECK.has(node.operator)) {
					if (isNegZero(node.left) || isNegZero(node.right)) {
						context.report({
							node: node,
							message: "Do not use the '{{operator}}' operator to compare against -0.",
							data: { operator: node.operator }
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);

var NODE_DESCRIPTIONS = {
	DoWhileStatement: "a 'do...while' statement",
	ForStatement: "a 'for' statement",
	IfStatement: "an 'if' statement",
	WhileStatement: "a 'while' statement"
};
module.exports = {
	meta: {
		docs: {
			description: "disallow assignment operators in conditional expressions",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			enum: ["except-parens", "always"]
		}]
	},

	create: function create(context) {

		var prohibitAssign = context.options[0] || "except-parens";

		var sourceCode = context.getSourceCode();
		function isConditionalTestExpression(node) {
			return node.parent && node.parent.test && node === node.parent.test;
		}
		function findConditionalAncestor(node) {
			var currentAncestor = node;

			do {
				if (isConditionalTestExpression(currentAncestor)) {
					return currentAncestor.parent;
				}
			} while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));

			return null;
		}
		function isParenthesisedTwice(node) {
			var previousToken = sourceCode.getTokenBefore(node, 1),
				nextToken = sourceCode.getTokenAfter(node, 1);

			return astUtils.isParenthesised(sourceCode, node) && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
		}
		function testForAssign(node) {
			if (node.test && node.test.type === "AssignmentExpression" && (node.type === "ForStatement" ? !astUtils.isParenthesised(sourceCode, node.test) : !isParenthesisedTwice(node.test))) {
				context.report({
					node: node,
					loc: node.test.loc.start,
					message: "Expected a conditional expression and instead saw an assignment."
				});
			}
		}
		function testForConditionalAncestor(node) {
			var ancestor = findConditionalAncestor(node);

			if (ancestor) {
				context.report({
					node: ancestor,
					message: "Unexpected assignment within {{type}}.",
					data: {
						type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
					}
				});
			}
		}

		if (prohibitAssign === "always") {
			return {
				AssignmentExpression: testForConditionalAncestor
			};
		}

		return {
			DoWhileStatement: testForAssign,
			ForStatement: testForAssign,
			IfStatement: testForAssign,
			WhileStatement: testForAssign
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
function isConditional(node) {
	return node && node.type === "ConditionalExpression";
}
module.exports = {
	meta: {
		docs: {
			description: "disallow arrow functions where they could be confused with comparisons",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "code",

		schema: [{
			type: "object",
			properties: {
				allowParens: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var config = context.options[0] || {};
		var sourceCode = context.getSourceCode();
		function checkArrowFunc(node) {
			var body = node.body;

			if (isConditional(body) && !(config.allowParens && astUtils.isParenthesised(sourceCode, body))) {
				context.report({
					node: node,
					message: "Arrow function used ambiguously with a conditional expression.",
					fix: function fix(fixer) {
						return config.allowParens && fixer.replaceText(node.body, "(" + sourceCode.getText(node.body) + ")");
					}
				});
			}
		}

		return {
			ArrowFunctionExpression: checkArrowFunc
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `console`",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				allow: {
					type: "array",
					items: {
						type: "string"
					},
					minItems: 1,
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var allowed = options.allow || [];
		function isConsole(reference) {
			var id = reference.identifier;

			return id && id.name === "console";
		}
		function isAllowed(node) {
			var propertyName = astUtils.getStaticPropertyName(node);

			return propertyName && allowed.indexOf(propertyName) !== -1;
		}
		function isMemberAccessExceptAllowed(reference) {
			var node = reference.identifier;
			var parent = node.parent;

			return parent.type === "MemberExpression" && parent.object === node && !isAllowed(parent);
		}
		function report(reference) {
			var node = reference.identifier.parent;

			context.report({
				node: node,
				loc: node.loc,
				message: "Unexpected console statement."
			});
		}

		return {
			"Program:exit": function ProgramExit() {
				var scope = context.getScope();
				var consoleVar = astUtils.getVariableByName(scope, "console");
				var shadowed = consoleVar && consoleVar.defs.length > 0;
				var references = consoleVar ? consoleVar.references : scope.through.filter(isConsole);

				if (!shadowed) {
					references.filter(isMemberAccessExceptAllowed).forEach(report);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow reassigning `const` variables",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function checkVariable(variable) {
			astUtils.getModifyingReferences(variable.references).forEach(function (reference) {
				context.report({ node: reference.identifier, message: "'{{name}}' is constant.", data: { name: reference.identifier.name } });
			});
		}

		return {
			VariableDeclaration: function VariableDeclaration(node) {
				if (node.kind === "const") {
					context.getDeclaredVariables(node).forEach(checkVariable);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow constant expressions in conditions",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				checkLoops: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {},
			checkLoops = options.checkLoops !== false,
			loopSetStack = [];

		var loopsInCurrentScope = new Set();
		function isLogicalIdentity(node, operator) {
			switch (node.type) {
				case "Literal":
					return operator === "||" && node.value === true || operator === "&&" && node.value === false;

				case "UnaryExpression":
					return operator === "&&" && node.operator === "void";

				case "LogicalExpression":
					return isLogicalIdentity(node.left, node.operator) || isLogicalIdentity(node.right, node.operator);
			}
			return false;
		}
		function isConstant(node, inBooleanPosition) {
			switch (node.type) {
				case "Literal":
				case "ArrowFunctionExpression":
				case "FunctionExpression":
				case "ObjectExpression":
				case "ArrayExpression":
					return true;

				case "UnaryExpression":
					if (node.operator === "void") {
						return true;
					}

					return node.operator === "typeof" && inBooleanPosition || isConstant(node.argument, true);

				case "BinaryExpression":
					return isConstant(node.left, false) && isConstant(node.right, false) && node.operator !== "in";

				case "LogicalExpression":
					{
						var isLeftConstant = isConstant(node.left, inBooleanPosition);
						var isRightConstant = isConstant(node.right, inBooleanPosition);
						var isLeftShortCircuit = isLeftConstant && isLogicalIdentity(node.left, node.operator);
						var isRightShortCircuit = isRightConstant && isLogicalIdentity(node.right, node.operator);

						return isLeftConstant && isRightConstant || isLeftShortCircuit || isRightShortCircuit;
					}

				case "AssignmentExpression":
					return node.operator === "=" && isConstant(node.right, inBooleanPosition);

				case "SequenceExpression":
					return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);
			}
			return false;
		}
		function trackConstantConditionLoop(node) {
			if (node.test && isConstant(node.test, true)) {
				loopsInCurrentScope.add(node);
			}
		}
		function checkConstantConditionLoopInSet(node) {
			if (loopsInCurrentScope.has(node)) {
				loopsInCurrentScope.delete(node);
				context.report({ node: node.test, message: "Unexpected constant condition." });
			}
		}
		function reportIfConstant(node) {
			if (node.test && isConstant(node.test, true)) {
				context.report({ node: node.test, message: "Unexpected constant condition." });
			}
		}
		function enterFunction() {
			loopSetStack.push(loopsInCurrentScope);
			loopsInCurrentScope = new Set();
		}
		function exitFunction() {
			loopsInCurrentScope = loopSetStack.pop();
		}
		function checkLoop(node) {
			if (checkLoops) {
				trackConstantConditionLoop(node);
			}
		}
		return {
			ConditionalExpression: reportIfConstant,
			IfStatement: reportIfConstant,
			WhileStatement: checkLoop,
			"WhileStatement:exit": checkConstantConditionLoopInSet,
			DoWhileStatement: checkLoop,
			"DoWhileStatement:exit": checkConstantConditionLoopInSet,
			ForStatement: checkLoop,
			"ForStatement > .test": function ForStatementTest(node) {
				return checkLoop(node.parent);
			},
			"ForStatement:exit": checkConstantConditionLoopInSet,
			FunctionDeclaration: enterFunction,
			"FunctionDeclaration:exit": exitFunction,
			YieldExpression: function YieldExpression() {
				return loopsInCurrentScope.clear();
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `continue` statements",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			ContinueStatement: function ContinueStatement(node) {
				context.report({ node: node, message: "Unexpected use of continue statement." });
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow control characters in regular expressions",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function getRegExp(node) {
			if (node.value instanceof RegExp) {
				return node.value;
			}
			if (typeof node.value === "string") {

				var parent = context.getAncestors().pop();

				if ((parent.type === "NewExpression" || parent.type === "CallExpression") && parent.callee.type === "Identifier" && parent.callee.name === "RegExp") {
					try {
						return new RegExp(node.value);
					} catch (ex) {
						return null;
					}
				}
			}

			return null;
		}

		var controlChar = /[\x00-\x1f]/g; // eslint-disable-line no-control-regex
		var consecutiveSlashes = /\\+/g;
		var consecutiveSlashesAtEnd = /\\+$/g;
		var stringControlChar = /\\x[01][0-9a-f]/ig;
		var stringControlCharWithoutSlash = /x[01][0-9a-f]/ig;
		function getControlCharacters(regexStr) {
			var controlChars = regexStr.match(controlChar) || [];

			var stringControlChars = [];
			var subStrIndex = regexStr.search(stringControlChar);

			if (subStrIndex > -1) {
				var possibleEscapeCharacters = regexStr.slice(0, subStrIndex).match(consecutiveSlashesAtEnd);

				var hasControlChars = possibleEscapeCharacters === null || !(possibleEscapeCharacters[0].length % 2);

				if (hasControlChars) {
					stringControlChars = regexStr.slice(subStrIndex, -1).split(consecutiveSlashes).filter(Boolean).map(function (x) {
						var match = x.match(stringControlCharWithoutSlash) || [x];

						return "\\" + match[0];
					});
				}
			}

			return controlChars.map(function (x) {
				var hexCode = ("0" + x.charCodeAt(0).toString(16)).slice(-2);

				return "\\x" + hexCode;
			}).concat(stringControlChars);
		}

		return {
			Literal: function Literal(node) {
				var regex = getRegExp(node);

				if (regex) {
					var computedValue = regex.toString();

					var controlCharacters = getControlCharacters(computedValue);

					if (controlCharacters.length > 0) {
						context.report({
							node: node,
							message: "Unexpected control character(s) in regular expression: {{controlChars}}.",
							data: {
								controlChars: controlCharacters.join(", ")
							}
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `debugger`",
			category: "Possible Errors",
			recommended: true
		},
		fixable: "code",
		schema: []
	},

	create: function create(context) {

		return {
			DebuggerStatement: function DebuggerStatement(node) {
				context.report({
					node: node,
					message: "Unexpected 'debugger' statement.",
					fix: function fix(fixer) {
						if (astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
							return fixer.remove(node);
						}
						return null;
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow deleting variables",
			category: "Variables",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {

		return {
			UnaryExpression: function UnaryExpression(node) {
				if (node.operator === "delete" && node.argument.type === "Identifier") {
					context.report({ node: node, message: "Variables should not be deleted." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow division operators explicitly at the beginning of regular expressions",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			Literal: function Literal(node) {
				var token = sourceCode.getFirstToken(node);

				if (token.type === "RegularExpression" && token.value[1] === "=") {
					context.report({ node: node, message: "A regular expression literal can be confused with '/='." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow duplicate arguments in `function` definitions",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function isParameter(def) {
			return def.type === "Parameter";
		}
		function checkParams(node) {
			var variables = context.getDeclaredVariables(node);

			for (var i = 0; i < variables.length; ++i) {
				var variable = variables[i];
				var defs = variable.defs.filter(isParameter);

				if (defs.length >= 2) {
					context.report({
						node: node,
						message: "Duplicate param '{{name}}'.",
						data: { name: variable.name }
					});
				}
			}
		}
		return {
			FunctionDeclaration: checkParams,
			FunctionExpression: checkParams
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow duplicate class members",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var stack = [];
		function getState(name, isStatic) {
			var stateMap = stack[stack.length - 1];
			var key = "$" + name; // to avoid "__proto__".

			if (!stateMap[key]) {
				stateMap[key] = {
					nonStatic: { init: false, get: false, set: false },
					static: { init: false, get: false, set: false }
				};
			}

			return stateMap[key][isStatic ? "static" : "nonStatic"];
		}
		function getName(node) {
			switch (node.type) {
				case "Identifier":
					return node.name;
				case "Literal":
					return String(node.value);
				default:
					return "";
			}
		}

		return {
			Program: function Program() {
				stack = [];
			},
			ClassBody: function ClassBody() {
				stack.push(Object.create(null));
			},
			"ClassBody:exit": function ClassBodyExit() {
				stack.pop();
			},
			MethodDefinition: function MethodDefinition(node) {
				if (node.computed) {
					return;
				}

				var name = getName(node.key);
				var state = getState(name, node.static);
				var isDuplicate = false;

				if (node.kind === "get") {
					isDuplicate = state.init || state.get;
					state.get = true;
				} else if (node.kind === "set") {
					isDuplicate = state.init || state.set;
					state.set = true;
				} else {
					isDuplicate = state.init || state.get || state.set;
					state.init = true;
				}

				if (isDuplicate) {
					context.report({ node: node, message: "Duplicate name '{{name}}'.", data: { name: name } });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var astUtils = __webpack_require__(0);
var GET_KIND = /^(?:init|get)$/;
var SET_KIND = /^(?:init|set)$/;

var ObjectInfo = function () {
	function ObjectInfo(upper, node) {
		_classCallCheck(this, ObjectInfo);

		this.upper = upper;
		this.node = node;
		this.properties = new Map();
	}


	_createClass(ObjectInfo, [{
		key: "getPropertyInfo",
		value: function getPropertyInfo(node) {
			var name = astUtils.getStaticPropertyName(node);

			if (!this.properties.has(name)) {
				this.properties.set(name, { get: false, set: false });
			}
			return this.properties.get(name);
		}

	}, {
		key: "isPropertyDefined",
		value: function isPropertyDefined(node) {
			var entry = this.getPropertyInfo(node);

			return GET_KIND.test(node.kind) && entry.get || SET_KIND.test(node.kind) && entry.set;
		}

	}, {
		key: "defineProperty",
		value: function defineProperty(node) {
			var entry = this.getPropertyInfo(node);

			if (GET_KIND.test(node.kind)) {
				entry.get = true;
			}
			if (SET_KIND.test(node.kind)) {
				entry.set = true;
			}
		}
	}]);

	return ObjectInfo;
}();
module.exports = {
	meta: {
		docs: {
			description: "disallow duplicate keys in object literals",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var info = null;

		return {
			ObjectExpression: function ObjectExpression(node) {
				info = new ObjectInfo(info, node);
			},
			"ObjectExpression:exit": function ObjectExpressionExit() {
				info = info.upper;
			},
			Property: function Property(node) {
				var name = astUtils.getStaticPropertyName(node);
				if (node.parent.type !== "ObjectExpression") {
					return;
				}
				if (!name) {
					return;
				}
				if (info.isPropertyDefined(node)) {
					context.report({
						node: info.node,
						loc: node.key.loc,
						message: "Duplicate key '{{name}}'.",
						data: { name: name }
					});
				}
				info.defineProperty(node);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow duplicate case labels",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			SwitchStatement: function SwitchStatement(node) {
				var mapping = {};

				node.cases.forEach(function (switchCase) {
					var key = sourceCode.getText(switchCase.test);

					if (mapping[key]) {
						context.report({ node: switchCase, message: "Duplicate case label." });
					} else {
						mapping[key] = switchCase;
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function getValue(node) {
	if (node && node.source && node.source.value) {
		return node.source.value.trim();
	}

	return "";
}
function checkAndReport(context, node, value, array, message) {
	if (array.indexOf(value) !== -1) {
		context.report({
			node: node,
			message: "'{{module}}' {{message}}",
			data: {
				module: value,
				message: message
			}
		});
	}
}
function handleImports(context, includeExports, importsInFile, exportsInFile) {
	return function (node) {
		var value = getValue(node);

		if (value) {
			checkAndReport(context, node, value, importsInFile, "import is duplicated.");

			if (includeExports) {
				checkAndReport(context, node, value, exportsInFile, "import is duplicated as export.");
			}

			importsInFile.push(value);
		}
	};
}
function handleExports(context, importsInFile, exportsInFile) {
	return function (node) {
		var value = getValue(node);

		if (value) {
			checkAndReport(context, node, value, exportsInFile, "export is duplicated.");
			checkAndReport(context, node, value, importsInFile, "export is duplicated as import.");

			exportsInFile.push(value);
		}
	};
}

module.exports = {
	meta: {
		docs: {
			description: "disallow duplicate module imports",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				includeExports: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var includeExports = (context.options[0] || {}).includeExports,
			importsInFile = [],
			exportsInFile = [];

		var handlers = {
			ImportDeclaration: handleImports(context, includeExports, importsInFile, exportsInFile)
		};

		if (includeExports) {
			handlers.ExportNamedDeclaration = handleExports(context, importsInFile, exportsInFile);
			handlers.ExportAllDeclaration = handleExports(context, importsInFile, exportsInFile);
		}

		return handlers;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var FixTracker = __webpack_require__(70);
module.exports = {
	meta: {
		docs: {
			description: "disallow `else` blocks after `return` statements in `if` statements",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowElseIf: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],
		fixable: "code"
	},

	create: function create(context) {
		function displayReport(node) {
			context.report({
				node: node,
				message: "Unnecessary 'else' after 'return'.",
				fix: function fix(fixer) {
					var sourceCode = context.getSourceCode();
					var startToken = sourceCode.getFirstToken(node);
					var elseToken = sourceCode.getTokenBefore(startToken);
					var source = sourceCode.getText(node);
					var lastIfToken = sourceCode.getTokenBefore(elseToken);
					var fixedSource = void 0,
						firstTokenOfElseBlock = void 0;

					if (startToken.type === "Punctuator" && startToken.value === "{") {
						firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);
					} else {
						firstTokenOfElseBlock = startToken;
					}
					var ifBlockMaybeUnsafe = node.parent.consequent.type !== "BlockStatement" && lastIfToken.value !== ";";
					var elseBlockUnsafe = /^[([/+`-]/.test(firstTokenOfElseBlock.value);

					if (ifBlockMaybeUnsafe && elseBlockUnsafe) {
						return null;
					}

					var endToken = sourceCode.getLastToken(node);
					var lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);

					if (lastTokenOfElseBlock.value !== ";") {
						var nextToken = sourceCode.getTokenAfter(endToken);

						var nextTokenUnsafe = nextToken && /^[([/+`-]/.test(nextToken.value);
						var nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;
						if (nextTokenUnsafe || nextTokenOnSameLine && nextToken.value !== "}") {
							return null;
						}
					}

					if (startToken.type === "Punctuator" && startToken.value === "{") {
						fixedSource = source.slice(1, -1);
					} else {
						fixedSource = source;
					}
					return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);
				}
			});
		}
		function checkForReturn(node) {
			return node.type === "ReturnStatement";
		}
		function naiveHasReturn(node) {
			if (node.type === "BlockStatement") {
				var body = node.body,
					lastChildNode = body[body.length - 1];

				return lastChildNode && checkForReturn(lastChildNode);
			}
			return checkForReturn(node);
		}
		function hasElse(node) {
			return node.alternate && node.consequent;
		}
		function checkForIf(node) {
			return node.type === "IfStatement" && hasElse(node) && naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
		}
		function checkForReturnOrIf(node) {
			return checkForReturn(node) || checkForIf(node);
		}
		function alwaysReturns(node) {
			if (node.type === "BlockStatement") {
				return node.body.some(checkForReturnOrIf);
			}
			return checkForReturnOrIf(node);
		}
		function checkIfWithoutElse(node) {
			var parent = node.parent;
			var consequents = void 0,
				alternate = void 0;
			if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
				return;
			}

			for (consequents = []; node.type === "IfStatement"; node = node.alternate) {
				if (!node.alternate) {
					return;
				}
				consequents.push(node.consequent);
				alternate = node.alternate;
			}

			if (consequents.every(alwaysReturns)) {
				displayReport(alternate);
			}
		}
		function checkIfWithElse(node) {
			var parent = node.parent;
			if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
				return;
			}

			var alternate = node.alternate;

			if (alternate && alwaysReturns(node.consequent)) {
				displayReport(alternate);
			}
		}

		var allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);
		return {

			"IfStatement:exit": allowElseIf ? checkIfWithoutElse : checkIfWithElse

		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var regex = /^\/([^\\[]|\\.|\[([^\\\]]|\\.)+])*\/[gimuy]*$/;
module.exports = {
	meta: {
		docs: {
			description: "disallow empty character classes in regular expressions",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			Literal: function Literal(node) {
				var token = sourceCode.getFirstToken(node);

				if (token.type === "RegularExpression" && !regex.test(token.value)) {
					context.report({ node: node, message: "Empty class." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var ALLOW_OPTIONS = Object.freeze(["functions", "arrowFunctions", "generatorFunctions", "methods", "generatorMethods", "getters", "setters", "constructors"]);
function getKind(node) {
	var parent = node.parent;
	var kind = "";

	if (node.type === "ArrowFunctionExpression") {
		return "arrowFunctions";
	}
	if (parent.type === "Property") {
		if (parent.kind === "get") {
			return "getters";
		}
		if (parent.kind === "set") {
			return "setters";
		}
		kind = parent.method ? "methods" : "functions";
	} else if (parent.type === "MethodDefinition") {
		if (parent.kind === "get") {
			return "getters";
		}
		if (parent.kind === "set") {
			return "setters";
		}
		if (parent.kind === "constructor") {
			return "constructors";
		}
		kind = "methods";
	} else {
		kind = "functions";
	}
	var prefix = "";

	if (node.generator) {
		prefix = "generator";
	} else if (node.async) {
		prefix = "async";
	} else {
		return kind;
	}
	return prefix + kind[0].toUpperCase() + kind.slice(1);
}
module.exports = {
	meta: {
		docs: {
			description: "disallow empty functions",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allow: {
					type: "array",
					items: { enum: ALLOW_OPTIONS },
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var allowed = options.allow || [];

		var sourceCode = context.getSourceCode();
		function reportIfEmpty(node) {
			var kind = getKind(node);
			var name = astUtils.getFunctionNameWithKind(node);
			var innerComments = sourceCode.getTokens(node.body, {
				includeComments: true,
				filter: astUtils.isCommentToken
			});

			if (allowed.indexOf(kind) === -1 && node.body.type === "BlockStatement" && node.body.body.length === 0 && innerComments.length === 0) {
				context.report({
					node: node,
					loc: node.body.loc.start,
					message: "Unexpected empty {{name}}.",
					data: { name: name }
				});
			}
		}

		return {
			ArrowFunctionExpression: reportIfEmpty,
			FunctionDeclaration: reportIfEmpty,
			FunctionExpression: reportIfEmpty
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow empty destructuring patterns",
			category: "Best Practices",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		return {
			ObjectPattern: function ObjectPattern(node) {
				if (node.properties.length === 0) {
					context.report({ node: node, message: "Unexpected empty object pattern." });
				}
			},
			ArrayPattern: function ArrayPattern(node) {
				if (node.elements.length === 0) {
					context.report({ node: node, message: "Unexpected empty array pattern." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow empty block statements",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				allowEmptyCatch: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {},
			allowEmptyCatch = options.allowEmptyCatch || false;

		var sourceCode = context.getSourceCode();

		return {
			BlockStatement: function BlockStatement(node) {
				if (node.body.length !== 0) {
					return;
				}
				if (astUtils.isFunction(node.parent)) {
					return;
				}

				if (allowEmptyCatch && node.parent.type === "CatchClause") {
					return;
				}
				if (sourceCode.getCommentsInside(node).length > 0) {
					return;
				}

				context.report({ node: node, message: "Empty block statement." });
			},
			SwitchStatement: function SwitchStatement(node) {

				if (typeof node.cases === "undefined" || node.cases.length === 0) {
					context.report({ node: node, message: "Empty switch statement." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `null` comparisons without type-checking operators",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			BinaryExpression: function BinaryExpression(node) {
				var badOperator = node.operator === "==" || node.operator === "!=";

				if (node.right.type === "Literal" && node.right.raw === "null" && badOperator || node.left.type === "Literal" && node.left.raw === "null" && badOperator) {
					context.report({ node: node, message: "Use ‘===’ to compare with ‘null’." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var candidatesOfGlobalObject = Object.freeze(["global", "window"]);
function isIdentifier(node, name) {
	return node.type === "Identifier" && node.name === name;
}
function isConstant(node, name) {
	switch (node.type) {
		case "Literal":
			return node.value === name;

		case "TemplateLiteral":
			return node.expressions.length === 0 && node.quasis[0].value.cooked === name;

		default:
			return false;
	}
}
function isMember(node, name) {
	return node.type === "MemberExpression" && (node.computed ? isConstant : isIdentifier)(node.property, name);
}
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `eval()`",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowIndirect: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var allowIndirect = Boolean(context.options[0] && context.options[0].allowIndirect);
		var sourceCode = context.getSourceCode();
		var funcInfo = null;
		function enterVarScope(node) {
			var strict = context.getScope().isStrict;

			funcInfo = {
				upper: funcInfo,
				node: node,
				strict: strict,
				defaultThis: false,
				initialized: strict
			};
		}
		function exitVarScope() {
			funcInfo = funcInfo.upper;
		}
		function report(node) {
			var locationNode = node;
			var parent = node.parent;

			if (node.type === "MemberExpression") {
				locationNode = node.property;
			}
			if (parent.type === "CallExpression" && parent.callee === node) {
				node = parent;
			}

			context.report({
				node: node,
				loc: locationNode.loc.start,
				message: "eval can be harmful."
			});
		}
		function reportAccessingEvalViaGlobalObject(globalScope) {
			for (var i = 0; i < candidatesOfGlobalObject.length; ++i) {
				var name = candidatesOfGlobalObject[i];
				var variable = astUtils.getVariableByName(globalScope, name);

				if (!variable) {
					continue;
				}

				var references = variable.references;

				for (var j = 0; j < references.length; ++j) {
					var identifier = references[j].identifier;
					var node = identifier.parent;
					while (isMember(node, name)) {
						node = node.parent;
					}
					if (isMember(node, "eval")) {
						report(node);
					}
				}
			}
		}
		function reportAccessingEval(globalScope) {
			var variable = astUtils.getVariableByName(globalScope, "eval");

			if (!variable) {
				return;
			}

			var references = variable.references;

			for (var i = 0; i < references.length; ++i) {
				var reference = references[i];
				var id = reference.identifier;

				if (id.name === "eval" && !astUtils.isCallee(id)) {
					report(id);
				}
			}
		}

		if (allowIndirect) {
			return {
				"CallExpression:exit": function CallExpressionExit(node) {
					var callee = node.callee;

					if (isIdentifier(callee, "eval")) {
						report(callee);
					}
				}
			};
		}

		return {
			"CallExpression:exit": function CallExpressionExit(node) {
				var callee = node.callee;

				if (isIdentifier(callee, "eval")) {
					report(callee);
				}
			},
			Program: function Program(node) {
				var scope = context.getScope(),
					features = context.parserOptions.ecmaFeatures || {},
					strict = scope.isStrict || node.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict;

				funcInfo = {
					upper: null,
					node: node,
					strict: strict,
					defaultThis: true,
					initialized: true
				};
			},
			"Program:exit": function ProgramExit() {
				var globalScope = context.getScope();

				exitVarScope();
				reportAccessingEval(globalScope);
				reportAccessingEvalViaGlobalObject(globalScope);
			},


			FunctionDeclaration: enterVarScope,
			"FunctionDeclaration:exit": exitVarScope,
			FunctionExpression: enterVarScope,
			"FunctionExpression:exit": exitVarScope,
			ArrowFunctionExpression: enterVarScope,
			"ArrowFunctionExpression:exit": exitVarScope,

			ThisExpression: function ThisExpression(node) {
				if (!isMember(node.parent, "eval")) {
					return;
				}
				if (!funcInfo.initialized) {
					funcInfo.initialized = true;
					funcInfo.defaultThis = astUtils.isDefaultThisBinding(funcInfo.node, sourceCode);
				}

				if (!funcInfo.strict && funcInfo.defaultThis) {
					report(node.parent);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow reassigning exceptions in `catch` clauses",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function checkVariable(variable) {
			astUtils.getModifyingReferences(variable.references).forEach(function (reference) {
				context.report({ node: reference.identifier, message: "Do not assign to the exception parameter." });
			});
		}

		return {
			CatchClause: function CatchClause(node) {
				context.getDeclaredVariables(node).forEach(checkVariable);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var globals = __webpack_require__(162);
var propertyDefinitionMethods = new Set(["defineProperty", "defineProperties"]);
module.exports = {
	meta: {
		docs: {
			description: "disallow extending native types",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				exceptions: {
					type: "array",
					items: {
						type: "string"
					},
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var config = context.options[0] || {};
		var exceptions = new Set(config.exceptions || []);
		var modifiedBuiltins = new Set(Object.keys(globals.builtin).filter(function (builtin) {
			return builtin[0].toUpperCase() === builtin[0];
		}).filter(function (builtin) {
			return !exceptions.has(builtin);
		}));
		function reportNode(node, builtin) {
			context.report({
				node: node,
				message: "{{builtin}} prototype is read only, properties should not be added.",
				data: {
					builtin: builtin
				}
			});
		}
		function isPrototypePropertyAccessed(identifierNode) {
			return Boolean(identifierNode && identifierNode.parent && identifierNode.parent.type === "MemberExpression" && identifierNode.parent.object === identifierNode && astUtils.getStaticPropertyName(identifierNode.parent) === "prototype");
		}
		function isInPrototypePropertyAssignment(identifierNode) {
			return Boolean(isPrototypePropertyAccessed(identifierNode) && identifierNode.parent.parent.type === "MemberExpression" && identifierNode.parent.parent.parent.type === "AssignmentExpression" && identifierNode.parent.parent.parent.left === identifierNode.parent.parent);
		}
		function isInDefinePropertyCall(identifierNode) {
			return Boolean(isPrototypePropertyAccessed(identifierNode) && identifierNode.parent.parent.type === "CallExpression" && identifierNode.parent.parent.arguments[0] === identifierNode.parent && identifierNode.parent.parent.callee.type === "MemberExpression" && identifierNode.parent.parent.callee.object.type === "Identifier" && identifierNode.parent.parent.callee.object.name === "Object" && identifierNode.parent.parent.callee.property.type === "Identifier" && propertyDefinitionMethods.has(identifierNode.parent.parent.callee.property.name));
		}
		function checkAndReportPrototypeExtension(identifierNode) {
			if (isInPrototypePropertyAssignment(identifierNode)) {
				reportNode(identifierNode.parent.parent.parent, identifierNode.name);
			} else if (isInDefinePropertyCall(identifierNode)) {
				reportNode(identifierNode.parent.parent, identifierNode.name);
			}
		}

		return {
			"Program:exit": function ProgramExit() {
				var globalScope = context.getScope();

				modifiedBuiltins.forEach(function (builtin) {
					var builtinVar = globalScope.set.get(builtin);

					if (builtinVar && builtinVar.references) {
						builtinVar.references.map(function (ref) {
							return ref.identifier;
						}).forEach(checkAndReportPrototypeExtension);
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary calls to `.bind()`",
			category: "Best Practices",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var scopeInfo = null;
		function report(node) {
			context.report({
				node: node.parent.parent,
				message: "The function binding is unnecessary.",
				loc: node.parent.property.loc.start,
				fix: function fix(fixer) {
					var firstTokenToRemove = context.getSourceCode().getFirstTokenBetween(node.parent.object, node.parent.property, astUtils.isNotClosingParenToken);

					return fixer.removeRange([firstTokenToRemove.range[0], node.parent.parent.range[1]]);
				}
			});
		}
		function isCalleeOfBindMethod(node) {
			var parent = node.parent;
			var grandparent = parent.parent;

			return grandparent && grandparent.type === "CallExpression" && grandparent.callee === parent && grandparent.arguments.length === 1 && parent.type === "MemberExpression" && parent.object === node && astUtils.getStaticPropertyName(parent) === "bind";
		}
		function enterFunction(node) {
			scopeInfo = {
				isBound: isCalleeOfBindMethod(node),
				thisFound: false,
				upper: scopeInfo
			};
		}
		function exitFunction(node) {
			if (scopeInfo.isBound && !scopeInfo.thisFound) {
				report(node);
			}

			scopeInfo = scopeInfo.upper;
		}
		function exitArrowFunction(node) {
			if (isCalleeOfBindMethod(node)) {
				report(node);
			}
		}
		function markAsThisFound() {
			if (scopeInfo) {
				scopeInfo.thisFound = true;
			}
		}

		return {
			"ArrowFunctionExpression:exit": exitArrowFunction,
			FunctionDeclaration: enterFunction,
			"FunctionDeclaration:exit": exitFunction,
			FunctionExpression: enterFunction,
			"FunctionExpression:exit": exitFunction,
			ThisExpression: markAsThisFound
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary boolean casts",
			category: "Possible Errors",
			recommended: true
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var BOOLEAN_NODE_TYPES = ["IfStatement", "DoWhileStatement", "WhileStatement", "ConditionalExpression", "ForStatement"];
		function isInBooleanContext(node, parent) {
			return BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 && node === parent.test ||
			parent.type === "UnaryExpression" && parent.operator === "!";
		}

		return {
			UnaryExpression: function UnaryExpression(node) {
				var ancestors = context.getAncestors(),
					parent = ancestors.pop(),
					grandparent = ancestors.pop();
				if (node.operator !== "!" || parent.type !== "UnaryExpression" || parent.operator !== "!") {
					return;
				}

				if (isInBooleanContext(parent, grandparent) ||
				(grandparent.type === "CallExpression" || grandparent.type === "NewExpression") && grandparent.callee.type === "Identifier" && grandparent.callee.name === "Boolean") {
					context.report({
						node: node,
						message: "Redundant double negation.",
						fix: function fix(fixer) {
							return fixer.replaceText(parent, sourceCode.getText(node.argument));
						}
					});
				}
			},
			CallExpression: function CallExpression(node) {
				var parent = node.parent;

				if (node.callee.type !== "Identifier" || node.callee.name !== "Boolean") {
					return;
				}

				if (isInBooleanContext(node, parent)) {
					context.report({
						node: node,
						message: "Redundant Boolean call.",
						fix: function fix(fixer) {
							if (!node.arguments.length) {
								return fixer.replaceText(parent, "true");
							}

							if (node.arguments.length > 1 || node.arguments[0].type === "SpreadElement") {
								return null;
							}

							var argument = node.arguments[0];

							if (astUtils.getPrecedence(argument) < astUtils.getPrecedence(node.parent)) {
								return fixer.replaceText(node, "(" + sourceCode.getText(argument) + ")");
							}
							return fixer.replaceText(node, sourceCode.getText(argument));
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary labels",
			category: "Best Practices",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var scopeInfo = null;
		function enterBreakableStatement(node) {
			scopeInfo = {
				label: node.parent.type === "LabeledStatement" ? node.parent.label : null,
				breakable: true,
				upper: scopeInfo
			};
		}
		function exitBreakableStatement() {
			scopeInfo = scopeInfo.upper;
		}
		function enterLabeledStatement(node) {
			if (!astUtils.isBreakableStatement(node.body)) {
				scopeInfo = {
					label: node.label,
					breakable: false,
					upper: scopeInfo
				};
			}
		}
		function exitLabeledStatement(node) {
			if (!astUtils.isBreakableStatement(node.body)) {
				scopeInfo = scopeInfo.upper;
			}
		}
		function reportIfUnnecessary(node) {
			if (!node.label) {
				return;
			}

			var labelNode = node.label;

			for (var info = scopeInfo; info !== null; info = info.upper) {
				if (info.breakable || info.label && info.label.name === labelNode.name) {
					if (info.breakable && info.label && info.label.name === labelNode.name) {
						context.report({
							node: labelNode,
							message: "This label '{{name}}' is unnecessary.",
							data: labelNode,
							fix: function fix(fixer) {
								return fixer.removeRange([sourceCode.getFirstToken(node).range[1], labelNode.range[1]]);
							}
						});
					}
					return;
				}
			}
		}

		return {
			WhileStatement: enterBreakableStatement,
			"WhileStatement:exit": exitBreakableStatement,
			DoWhileStatement: enterBreakableStatement,
			"DoWhileStatement:exit": exitBreakableStatement,
			ForStatement: enterBreakableStatement,
			"ForStatement:exit": exitBreakableStatement,
			ForInStatement: enterBreakableStatement,
			"ForInStatement:exit": exitBreakableStatement,
			ForOfStatement: enterBreakableStatement,
			"ForOfStatement:exit": exitBreakableStatement,
			SwitchStatement: enterBreakableStatement,
			"SwitchStatement:exit": exitBreakableStatement,
			LabeledStatement: enterLabeledStatement,
			"LabeledStatement:exit": exitLabeledStatement,
			BreakStatement: reportIfUnnecessary,
			ContinueStatement: reportIfUnnecessary
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);

module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary parentheses",
			category: "Possible Errors",
			recommended: false
		},

		fixable: "code",

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["functions"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["all"]
				}, {
					type: "object",
					properties: {
						conditionalAssign: { type: "boolean" },
						nestedBinaryExpressions: { type: "boolean" },
						returnAssign: { type: "boolean" },
						ignoreJSX: { enum: ["none", "all", "single-line", "multi-line"] },
						enforceForArrowConditionals: { type: "boolean" }
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		}
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		var tokensToIgnore = new WeakSet();
		var isParenthesised = astUtils.isParenthesised.bind(astUtils, sourceCode);
		var precedence = astUtils.getPrecedence;
		var ALL_NODES = context.options[0] !== "functions";
		var EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;
		var NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;
		var EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;
		var IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;
		var IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] && context.options[1].enforceForArrowConditionals === false;

		var PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: "AssignmentExpression" });
		var PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: "UpdateExpression" });
		function ruleApplies(node) {
			if (node.type === "JSXElement") {
				var isSingleLine = node.loc.start.line === node.loc.end.line;

				switch (IGNORE_JSX) {
					case "all":
						return false;
					case "multi-line":
						return isSingleLine;
					case "single-line":
						return !isSingleLine;
					case "none":
						break;
				}
			}

			return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
		}
		function isParenthesisedTwice(node) {
			var previousToken = sourceCode.getTokenBefore(node, 1),
				nextToken = sourceCode.getTokenAfter(node, 1);

			return isParenthesised(node) && previousToken && nextToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
		}
		function hasExcessParens(node) {
			return ruleApplies(node) && isParenthesised(node);
		}
		function hasDoubleExcessParens(node) {
			return ruleApplies(node) && isParenthesisedTwice(node);
		}
		function isCondAssignException(node) {
			return EXCEPT_COND_ASSIGN && node.test.type === "AssignmentExpression";
		}
		function isInReturnStatement(node) {
			while (node) {
				if (node.type === "ReturnStatement" || node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") {
					return true;
				}
				node = node.parent;
			}

			return false;
		}
		function isNewExpressionWithParens(newExpression) {
			var lastToken = sourceCode.getLastToken(newExpression);
			var penultimateToken = sourceCode.getTokenBefore(lastToken);

			return newExpression.arguments.length > 0 || astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken);
		}
		function containsAssignment(node) {
			if (node.type === "AssignmentExpression") {
				return true;
			}
			if (node.type === "ConditionalExpression" && (node.consequent.type === "AssignmentExpression" || node.alternate.type === "AssignmentExpression")) {
				return true;
			}
			if (node.left && node.left.type === "AssignmentExpression" || node.right && node.right.type === "AssignmentExpression") {
				return true;
			}

			return false;
		}
		function isReturnAssignException(node) {
			if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {
				return false;
			}

			if (node.type === "ReturnStatement") {
				return node.argument && containsAssignment(node.argument);
			}
			if (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") {
				return containsAssignment(node.body);
			}
			return containsAssignment(node);
		}
		function hasExcessParensNoLineTerminator(token, node) {
			if (token.loc.end.line === node.loc.start.line) {
				return hasExcessParens(node);
			}

			return hasDoubleExcessParens(node);
		}
		function requiresLeadingSpace(node) {
			var leftParenToken = sourceCode.getTokenBefore(node);
			var tokenBeforeLeftParen = sourceCode.getTokenBefore(node, 1);
			var firstToken = sourceCode.getFirstToken(node);

			return tokenBeforeLeftParen && tokenBeforeLeftParen.range[1] === leftParenToken.range[0] && leftParenToken.range[1] === firstToken.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, firstToken);
		}
		function requiresTrailingSpace(node) {
			var nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });
			var rightParenToken = nextTwoTokens[0];
			var tokenAfterRightParen = nextTwoTokens[1];
			var tokenBeforeRightParen = sourceCode.getLastToken(node);

			return rightParenToken && tokenAfterRightParen && !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) && !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);
		}
		function isIIFE(node) {
			return node.type === "CallExpression" && node.callee.type === "FunctionExpression";
		}
		function report(node) {
			var leftParenToken = sourceCode.getTokenBefore(node);
			var rightParenToken = sourceCode.getTokenAfter(node);

			if (!isParenthesisedTwice(node)) {
				if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {
					return;
				}

				if (isIIFE(node) && !isParenthesised(node.callee)) {
					return;
				}
			}

			context.report({
				node: node,
				loc: leftParenToken.loc.start,
				message: "Gratuitous parentheses around expression.",
				fix: function fix(fixer) {
					var parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);

					return fixer.replaceTextRange([leftParenToken.range[0], rightParenToken.range[1]], (requiresLeadingSpace(node) ? " " : "") + parenthesizedSource + (requiresTrailingSpace(node) ? " " : ""));
				}
			});
		}
		function checkUnaryUpdate(node) {
			if (node.type === "UnaryExpression" && node.argument.type === "BinaryExpression" && node.argument.operator === "**") {
				return;
			}

			if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {
				report(node.argument);
			}
		}
		function doesMemberExpressionContainCallExpression(node) {
			var currentNode = node.object;
			var currentNodeType = node.object.type;

			while (currentNodeType === "MemberExpression") {
				currentNode = currentNode.object;
				currentNodeType = currentNode.type;
			}

			return currentNodeType === "CallExpression";
		}
		function checkCallNew(node) {
			var callee = node.callee;

			if (hasExcessParens(callee) && precedence(callee) >= precedence(node)) {
				var hasNewParensException = callee.type === "NewExpression" && !isNewExpressionWithParens(callee);

				if (hasDoubleExcessParens(callee) || !isIIFE(node) && !hasNewParensException && !(
				callee.type === "MemberExpression" && doesMemberExpressionContainCallExpression(callee))) {
					report(node.callee);
				}
			}
			if (node.arguments.length === 1) {
				if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
					report(node.arguments[0]);
				}
			} else {
				node.arguments.filter(function (arg) {
					return hasExcessParens(arg) && precedence(arg) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;
				}).forEach(report);
			}
		}
		function checkBinaryLogical(node) {
			var prec = precedence(node);
			var leftPrecedence = precedence(node.left);
			var rightPrecedence = precedence(node.right);
			var isExponentiation = node.operator === "**";
			var shouldSkipLeft = NESTED_BINARY && (node.left.type === "BinaryExpression" || node.left.type === "LogicalExpression") || node.left.type === "UnaryExpression" && isExponentiation;
			var shouldSkipRight = NESTED_BINARY && (node.right.type === "BinaryExpression" || node.right.type === "LogicalExpression");

			if (!shouldSkipLeft && hasExcessParens(node.left) && (leftPrecedence > prec || leftPrecedence === prec && !isExponentiation)) {
				report(node.left);
			}
			if (!shouldSkipRight && hasExcessParens(node.right) && (rightPrecedence > prec || rightPrecedence === prec && isExponentiation)) {
				report(node.right);
			}
		}
		function checkClass(node) {
			if (!node.superClass) {
				return;
			}
			var hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR ? hasExcessParens(node.superClass) : hasDoubleExcessParens(node.superClass);

			if (hasExtraParens) {
				report(node.superClass);
			}
		}
		function checkSpreadOperator(node) {
			var hasExtraParens = precedence(node.argument) >= PRECEDENCE_OF_ASSIGNMENT_EXPR ? hasExcessParens(node.argument) : hasDoubleExcessParens(node.argument);

			if (hasExtraParens) {
				report(node.argument);
			}
		}
		function checkExpressionOrExportStatement(node) {
			var firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);
			var secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);
			var thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;

			if (astUtils.isOpeningParenToken(firstToken) && (astUtils.isOpeningBraceToken(secondToken) || secondToken.type === "Keyword" && (secondToken.value === "function" || secondToken.value === "class" || secondToken.value === "let" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken))) || secondToken && secondToken.type === "Identifier" && secondToken.value === "async" && thirdToken && thirdToken.type === "Keyword" && thirdToken.value === "function")) {
				tokensToIgnore.add(secondToken);
			}

			if (hasExcessParens(node)) {
				report(node);
			}
		}

		return {
			ArrayExpression: function ArrayExpression(node) {
				node.elements.filter(function (e) {
					return e && hasExcessParens(e) && precedence(e) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;
				}).forEach(report);
			},
			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
				if (isReturnAssignException(node)) {
					return;
				}

				if (node.body.type === "ConditionalExpression" && IGNORE_ARROW_CONDITIONALS && !isParenthesisedTwice(node.body)) {
					return;
				}

				if (node.body.type !== "BlockStatement") {
					var firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);
					var tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);

					if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {
						tokensToIgnore.add(firstBodyToken);
					}
					if (hasExcessParens(node.body) && precedence(node.body) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
						report(node.body);
					}
				}
			},
			AssignmentExpression: function AssignmentExpression(node) {
				if (isReturnAssignException(node)) {
					return;
				}

				if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {
					report(node.right);
				}
			},


			BinaryExpression: checkBinaryLogical,
			CallExpression: checkCallNew,

			ConditionalExpression: function ConditionalExpression(node) {
				if (isReturnAssignException(node)) {
					return;
				}

				if (hasExcessParens(node.test) && precedence(node.test) >= precedence({ type: "LogicalExpression", operator: "||" })) {
					report(node.test);
				}

				if (hasExcessParens(node.consequent) && precedence(node.consequent) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
					report(node.consequent);
				}

				if (hasExcessParens(node.alternate) && precedence(node.alternate) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
					report(node.alternate);
				}
			},
			DoWhileStatement: function DoWhileStatement(node) {
				if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
					report(node.test);
				}
			},


			ExportDefaultDeclaration: function ExportDefaultDeclaration(node) {
				return checkExpressionOrExportStatement(node.declaration);
			},
			ExpressionStatement: function ExpressionStatement(node) {
				return checkExpressionOrExportStatement(node.expression);
			},

			"ForInStatement, ForOfStatement": function ForInStatementForOfStatement(node) {
				if (node.left.type !== "VariableDeclarator") {
					var firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);

					if (firstLeftToken.value === "let" && (
					firstLeftToken.range[1] === node.left.range[1] ||
					astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)))) {
						tokensToIgnore.add(firstLeftToken);
					}
				}
				if (hasExcessParens(node.right)) {
					report(node.right);
				}
				if (hasExcessParens(node.left)) {
					report(node.left);
				}
			},
			ForStatement: function ForStatement(node) {
				if (node.init && hasExcessParens(node.init)) {
					report(node.init);
				}

				if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {
					report(node.test);
				}

				if (node.update && hasExcessParens(node.update)) {
					report(node.update);
				}
			},
			IfStatement: function IfStatement(node) {
				if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
					report(node.test);
				}
			},


			LogicalExpression: checkBinaryLogical,

			MemberExpression: function MemberExpression(node) {
				var nodeObjHasExcessParens = hasExcessParens(node.object);

				if (nodeObjHasExcessParens && precedence(node.object) >= precedence(node) && (node.computed || !(astUtils.isDecimalInteger(node.object) ||
				node.object.type === "Literal" && node.object.regex))) {
					report(node.object);
				}

				if (nodeObjHasExcessParens && node.object.type === "CallExpression" && node.parent.type !== "NewExpression") {
					report(node.object);
				}

				if (node.computed && hasExcessParens(node.property)) {
					report(node.property);
				}
			},


			NewExpression: checkCallNew,

			ObjectExpression: function ObjectExpression(node) {
				node.properties.filter(function (property) {
					var value = property.value;

					return value && hasExcessParens(value) && precedence(value) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;
				}).forEach(function (property) {
					return report(property.value);
				});
			},
			ReturnStatement: function ReturnStatement(node) {
				var returnToken = sourceCode.getFirstToken(node);

				if (isReturnAssignException(node)) {
					return;
				}

				if (node.argument && hasExcessParensNoLineTerminator(returnToken, node.argument) &&
				!(node.argument.type === "Literal" && node.argument.regex)) {
					report(node.argument);
				}
			},
			SequenceExpression: function SequenceExpression(node) {
				node.expressions.filter(function (e) {
					return hasExcessParens(e) && precedence(e) >= precedence(node);
				}).forEach(report);
			},
			SwitchCase: function SwitchCase(node) {
				if (node.test && hasExcessParens(node.test)) {
					report(node.test);
				}
			},
			SwitchStatement: function SwitchStatement(node) {
				if (hasDoubleExcessParens(node.discriminant)) {
					report(node.discriminant);
				}
			},
			ThrowStatement: function ThrowStatement(node) {
				var throwToken = sourceCode.getFirstToken(node);

				if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {
					report(node.argument);
				}
			},


			UnaryExpression: checkUnaryUpdate,
			UpdateExpression: checkUnaryUpdate,
			AwaitExpression: checkUnaryUpdate,

			VariableDeclarator: function VariableDeclarator(node) {
				if (node.init && hasExcessParens(node.init) && precedence(node.init) >= PRECEDENCE_OF_ASSIGNMENT_EXPR &&
				!(node.init.type === "Literal" && node.init.regex)) {
					report(node.init);
				}
			},
			WhileStatement: function WhileStatement(node) {
				if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
					report(node.test);
				}
			},
			WithStatement: function WithStatement(node) {
				if (hasDoubleExcessParens(node.object)) {
					report(node.object);
				}
			},
			YieldExpression: function YieldExpression(node) {
				if (node.argument) {
					var yieldToken = sourceCode.getFirstToken(node);

					if (precedence(node.argument) >= precedence(node) && hasExcessParensNoLineTerminator(yieldToken, node.argument) || hasDoubleExcessParens(node.argument)) {
						report(node.argument);
					}
				}
			},


			ClassDeclaration: checkClass,
			ClassExpression: checkClass,

			SpreadElement: checkSpreadOperator,
			SpreadProperty: checkSpreadOperator,
			ExperimentalSpreadProperty: checkSpreadOperator
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var FixTracker = __webpack_require__(70);
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary semicolons",
			category: "Possible Errors",
			recommended: true
		},

		fixable: "code",
		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function report(nodeOrToken) {
			context.report({
				node: nodeOrToken,
				message: "Unnecessary semicolon.",
				fix: function fix(fixer) {
					return new FixTracker(fixer, context.getSourceCode()).retainSurroundingTokens(nodeOrToken).remove(nodeOrToken);
				}
			});
		}
		function checkForPartOfClassBody(firstToken) {
			for (var token = firstToken; token.type === "Punctuator" && !astUtils.isClosingBraceToken(token); token = sourceCode.getTokenAfter(token)) {
				if (astUtils.isSemicolonToken(token)) {
					report(token);
				}
			}
		}

		return {
			EmptyStatement: function EmptyStatement(node) {
				var parent = node.parent,
					allowedParentTypes = ["ForStatement", "ForInStatement", "ForOfStatement", "WhileStatement", "DoWhileStatement", "IfStatement", "LabeledStatement", "WithStatement"];

				if (allowedParentTypes.indexOf(parent.type) === -1) {
					report(node);
				}
			},
			ClassBody: function ClassBody(node) {
				checkForPartOfClassBody(sourceCode.getFirstToken(node, 1)); // 0 is `{`.
			},
			MethodDefinition: function MethodDefinition(node) {
				checkForPartOfClassBody(sourceCode.getTokenAfter(node));
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10);
var DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/i;
function hasFallthroughComment(node, context, fallthroughCommentPattern) {
	var sourceCode = context.getSourceCode();
	var comment = lodash.last(sourceCode.getCommentsBefore(node));

	return Boolean(comment && fallthroughCommentPattern.test(comment.value));
}
function isReachable(segment) {
	return segment.reachable;
}
function hasBlankLinesBetween(node, token) {
	return token.loc.start.line > node.loc.end.line + 1;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow fallthrough of `case` statements",
			category: "Best Practices",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				commentPattern: {
					type: "string"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var currentCodePath = null;
		var sourceCode = context.getSourceCode();
		var fallthroughCase = null;
		var fallthroughCommentPattern = null;

		if (options.commentPattern) {
			fallthroughCommentPattern = new RegExp(options.commentPattern);
		} else {
			fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;
		}

		return {
			onCodePathStart: function onCodePathStart(codePath) {
				currentCodePath = codePath;
			},
			onCodePathEnd: function onCodePathEnd() {
				currentCodePath = currentCodePath.upper;
			},
			SwitchCase: function SwitchCase(node) {
				if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {
					context.report({
						message: "Expected a 'break' statement before '{{type}}'.",
						data: { type: node.test ? "case" : "default" },
						node: node
					});
				}
				fallthroughCase = null;
			},
			"SwitchCase:exit": function SwitchCaseExit(node) {
				var nextToken = sourceCode.getTokenAfter(node);
				if (currentCodePath.currentSegments.some(isReachable) && (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) && lodash.last(node.parent.cases) !== node) {
					fallthroughCase = node;
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow leading or trailing decimal points in numeric literals",
			category: "Best Practices",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			Literal: function Literal(node) {

				if (typeof node.value === "number") {
					if (node.raw.startsWith(".")) {
						context.report({
							node: node,
							message: "A leading decimal point can be confused with a dot.",
							fix: function fix(fixer) {
								var tokenBefore = sourceCode.getTokenBefore(node);
								var needsSpaceBefore = tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, "0" + node.raw);

								return fixer.insertTextBefore(node, needsSpaceBefore ? " 0" : "0");
							}
						});
					}
					if (node.raw.indexOf(".") === node.raw.length - 1) {
						context.report({
							node: node,
							message: "A trailing decimal point can be confused with a dot.",
							fix: function fix(fixer) {
								return fixer.insertTextAfter(node, "0");
							}
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow reassigning `function` declarations",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function checkReference(references) {
			astUtils.getModifyingReferences(references).forEach(function (reference) {
				context.report({ node: reference.identifier, message: "'{{name}}' is a function.", data: { name: reference.identifier.name } });
			});
		}
		function checkVariable(variable) {
			if (variable.defs[0].type === "FunctionName") {
				checkReference(variable.references);
			}
		}
		function checkForFunction(node) {
			context.getDeclaredVariables(node).forEach(checkVariable);
		}

		return {
			FunctionDeclaration: checkForFunction,
			FunctionExpression: checkForFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow assignments to native objects or read-only global variables",
			category: "Best Practices",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				exceptions: {
					type: "array",
					items: { type: "string" },
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var config = context.options[0];
		var exceptions = config && config.exceptions || [];
		function checkReference(reference, index, references) {
			var identifier = reference.identifier;

			if (reference.init === false && reference.isWrite() && (
			index === 0 || references[index - 1].identifier !== identifier)) {
				context.report({
					node: identifier,
					message: "Read-only global '{{name}}' should not be modified.",
					data: identifier
				});
			}
		}
		function checkVariable(variable) {
			if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
				variable.references.forEach(checkReference);
			}
		}

		return {
			Program: function Program() {
				var globalScope = context.getScope();

				globalScope.variables.forEach(checkVariable);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
var INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/;
var ALLOWABLE_OPERATORS = ["~", "!!", "+", "*"];
function parseOptions(options) {
	options = options || {};
	return {
		boolean: "boolean" in options ? Boolean(options.boolean) : true,
		number: "number" in options ? Boolean(options.number) : true,
		string: "string" in options ? Boolean(options.string) : true,
		allow: options.allow || []
	};
}
function isDoubleLogicalNegating(node) {
	return node.operator === "!" && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
}
function isBinaryNegatingOfIndexOf(node) {
	return node.operator === "~" && node.argument.type === "CallExpression" && node.argument.callee.type === "MemberExpression" && node.argument.callee.property.type === "Identifier" && INDEX_OF_PATTERN.test(node.argument.callee.property.name);
}
function isMultiplyByOne(node) {
	return node.operator === "*" && (node.left.type === "Literal" && node.left.value === 1 || node.right.type === "Literal" && node.right.value === 1);
}
function isNumeric(node) {
	return node.type === "Literal" && typeof node.value === "number" || node.type === "CallExpression" && (node.callee.name === "Number" || node.callee.name === "parseInt" || node.callee.name === "parseFloat");
}
function getNonNumericOperand(node) {
	var left = node.left,
		right = node.right;

	if (right.type !== "BinaryExpression" && !isNumeric(right)) {
		return right;
	}

	if (left.type !== "BinaryExpression" && !isNumeric(left)) {
		return left;
	}

	return null;
}
function isEmptyString(node) {
	return astUtils.isStringLiteral(node) && (node.value === "" || node.type === "TemplateLiteral" && node.quasis.length === 1 && node.quasis[0].value.cooked === "");
}
function isConcatWithEmptyString(node) {
	return node.operator === "+" && (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right) || isEmptyString(node.right) && !astUtils.isStringLiteral(node.left));
}
function isAppendEmptyString(node) {
	return node.operator === "+=" && isEmptyString(node.right);
}
function getNonEmptyOperand(node) {
	return isEmptyString(node.left) ? node.right : node.left;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow shorthand type conversions",
			category: "Best Practices",
			recommended: false
		},

		fixable: "code",
		schema: [{
			type: "object",
			properties: {
				boolean: {
					type: "boolean"
				},
				number: {
					type: "boolean"
				},
				string: {
					type: "boolean"
				},
				allow: {
					type: "array",
					items: {
						enum: ALLOWABLE_OPERATORS
					},
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = parseOptions(context.options[0]);
		var sourceCode = context.getSourceCode();
		function report(node, recommendation, shouldFix) {
			shouldFix = typeof shouldFix === "undefined" ? true : shouldFix;

			context.report({
				node: node,
				message: "use `{{recommendation}}` instead.",
				data: {
					recommendation: recommendation
				},
				fix: function fix(fixer) {
					if (!shouldFix) {
						return null;
					}

					var tokenBefore = sourceCode.getTokenBefore(node);

					if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)) {
						return fixer.replaceText(node, " " + recommendation);
					}
					return fixer.replaceText(node, recommendation);
				}
			});
		}

		return {
			UnaryExpression: function UnaryExpression(node) {
				var operatorAllowed = void 0;
				operatorAllowed = options.allow.indexOf("!!") >= 0;
				if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {
					var recommendation = "Boolean(" + sourceCode.getText(node.argument.argument) + ")";

					report(node, recommendation);
				}
				operatorAllowed = options.allow.indexOf("~") >= 0;
				if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {
					var _recommendation = sourceCode.getText(node.argument) + " !== -1";

					report(node, _recommendation, false);
				}
				operatorAllowed = options.allow.indexOf("+") >= 0;
				if (!operatorAllowed && options.number && node.operator === "+" && !isNumeric(node.argument)) {
					var _recommendation2 = "Number(" + sourceCode.getText(node.argument) + ")";

					report(node, _recommendation2);
				}
			},
			"BinaryExpression:exit": function BinaryExpressionExit(node) {
				var operatorAllowed = void 0;
				operatorAllowed = options.allow.indexOf("*") >= 0;
				var nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);

				if (nonNumericOperand) {
					var recommendation = "Number(" + sourceCode.getText(nonNumericOperand) + ")";

					report(node, recommendation);
				}
				operatorAllowed = options.allow.indexOf("+") >= 0;
				if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {
					var _recommendation3 = "String(" + sourceCode.getText(getNonEmptyOperand(node)) + ")";

					report(node, _recommendation3);
				}
			},
			AssignmentExpression: function AssignmentExpression(node) {
				var operatorAllowed = options.allow.indexOf("+") >= 0;

				if (!operatorAllowed && options.string && isAppendEmptyString(node)) {
					var code = sourceCode.getText(getNonEmptyOperand(node));
					var recommendation = code + " = String(" + code + ")";

					report(node, recommendation);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow variable and `function` declarations in the global scope",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		return {
			Program: function Program() {
				var scope = context.getScope();

				scope.variables.forEach(function (variable) {
					if (variable.writeable) {
						return;
					}

					variable.defs.forEach(function (def) {
						if (def.type === "FunctionName" || def.type === "Variable" && def.parent.kind === "var") {
							context.report({ node: def.node, message: "Implicit global variable, assign as global property instead." });
						}
					});
				});

				scope.implicit.variables.forEach(function (variable) {
					var scopeVariable = scope.set.get(variable.name);

					if (scopeVariable && scopeVariable.writeable) {
						return;
					}

					variable.defs.forEach(function (def) {
						context.report({ node: def.node, message: "Implicit global variable, assign as global property instead." });
					});
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `eval()`-like methods",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var CALLEE_RE = /^(setTimeout|setInterval|execScript)$/;
		var impliedEvalAncestorsStack = [];
		function last(arr) {
			return arr ? arr[arr.length - 1] : null;
		}
		function isImpliedEvalMemberExpression(node) {
			var object = node.object,
				property = node.property,
				hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);

			return object.name === "window" && hasImpliedEvalName;
		}
		function isImpliedEvalCallExpression(node) {
			var isMemberExpression = node.callee.type === "MemberExpression",
				isIdentifier = node.callee.type === "Identifier",
				isImpliedEvalCallee = isIdentifier && CALLEE_RE.test(node.callee.name) || isMemberExpression && isImpliedEvalMemberExpression(node.callee);

			return isImpliedEvalCallee && node.arguments.length;
		}
		function hasImpliedEvalParent(node) {
			return node.parent === last(last(impliedEvalAncestorsStack)) && (
			node.parent.type !== "CallExpression" || node === node.parent.arguments[0]);
		}
		function checkString(node) {
			if (hasImpliedEvalParent(node)) {
				var substack = impliedEvalAncestorsStack.pop();

				context.report({ node: substack[0], message: "Implied eval. Consider passing a function instead of a string." });
			}
		}
		return {
			CallExpression: function CallExpression(node) {
				if (isImpliedEvalCallExpression(node)) {
					impliedEvalAncestorsStack.push([node]);
				}
			},
			"CallExpression:exit": function CallExpressionExit(node) {
				if (node === last(last(impliedEvalAncestorsStack))) {
					impliedEvalAncestorsStack.pop();
				}
			},
			BinaryExpression: function BinaryExpression(node) {
				if (node.operator === "+" && hasImpliedEvalParent(node)) {
					last(impliedEvalAncestorsStack).push(node);
				}
			},
			"BinaryExpression:exit": function BinaryExpressionExit(node) {
				if (node === last(last(impliedEvalAncestorsStack))) {
					last(impliedEvalAncestorsStack).pop();
				}
			},
			Literal: function Literal(node) {
				if (typeof node.value === "string") {
					checkString(node);
				}
			},
			TemplateLiteral: function TemplateLiteral(node) {
				checkString(node);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow inline comments after code",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function testCodeAroundComment(node) {
			var startLine = String(sourceCode.lines[node.loc.start.line - 1]);
			var endLine = String(sourceCode.lines[node.loc.end.line - 1]);

			var preamble = startLine.slice(0, node.loc.start.column).trim();
			var postamble = endLine.slice(node.loc.end.column).trim();
			var isDirective = astUtils.isDirectiveComment(node);
			if (!isDirective && (preamble || postamble)) {
				context.report({ node: node, message: "Unexpected comment inline with code." });
			}
		}
		return {
			Program: function Program() {
				var comments = sourceCode.getAllComments();

				comments.filter(function (token) {
					return token.type !== "Shebang";
				}).forEach(testCodeAroundComment);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow variable or `function` declarations in nested blocks",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			enum: ["functions", "both"]
		}]
	},

	create: function create(context) {
		function nearestBody() {
			var ancestors = context.getAncestors();
			var ancestor = ancestors.pop(),
				generation = 1;

			while (ancestor && ["Program", "FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(ancestor.type) < 0) {
				generation += 1;
				ancestor = ancestors.pop();
			}

			return {
				type: ancestor.type,
				distance: generation
			};
		}
		function check(node) {
			var body = nearestBody(),
				valid = body.type === "Program" && body.distance === 1 || body.distance === 2;

			if (!valid) {
				context.report({
					node: node,
					message: "Move {{type}} declaration to {{body}} root.",
					data: {
						type: node.type === "FunctionDeclaration" ? "function" : "variable",
						body: body.type === "Program" ? "program" : "function body"
					}
				});
			}
		}

		return {

			FunctionDeclaration: check,
			VariableDeclaration: function VariableDeclaration(node) {
				if (context.options[0] === "both" && node.kind === "var") {
					check(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var espree = __webpack_require__(69);
module.exports = {
	meta: {
		docs: {
			description: "disallow invalid regular expression strings in `RegExp` constructors",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				allowConstructorFlags: {
					type: "array",
					items: {
						type: "string"
					}
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = context.options[0];
		var allowedFlags = "";

		if (options && options.allowConstructorFlags) {
			allowedFlags = options.allowConstructorFlags.join("");
		}
		function isString(node) {
			return node && node.type === "Literal" && typeof node.value === "string";
		}
		function check(node) {
			if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0])) {
				var flags = isString(node.arguments[1]) ? node.arguments[1].value : "";

				if (allowedFlags) {
					flags = flags.replace(new RegExp("[" + allowedFlags + "]", "gi"), "");
				}

				try {
					void new RegExp(node.arguments[0].value);
				} catch (e) {
					context.report({
						node: node,
						message: "{{message}}.",
						data: e
					});
				}

				if (flags) {

					try {
						espree.parse("/./" + flags, context.parserOptions);
					} catch (ex) {
						context.report({
							node: node,
							message: "Invalid flags supplied to RegExp constructor '{{flags}}'.",
							data: {
								flags: flags
							}
						});
					}
				}
			}
		}

		return {
			CallExpression: check,
			NewExpression: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow `this` keywords outside of classes or class-like objects",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var stack = [],
			sourceCode = context.getSourceCode();
		stack.getCurrent = function () {
			var current = this[this.length - 1];

			if (!current.init) {
				current.init = true;
				current.valid = !astUtils.isDefaultThisBinding(current.node, sourceCode);
			}
			return current;
		};
		function enterFunction(node) {
			stack.push({
				init: !context.getScope().isStrict,
				node: node,
				valid: true
			});
		}
		function exitFunction() {
			stack.pop();
		}

		return {
			Program: function Program(node) {
				var scope = context.getScope(),
					features = context.parserOptions.ecmaFeatures || {};

				stack.push({
					init: true,
					node: node,
					valid: !(scope.isStrict || node.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict)
				});
			},
			"Program:exit": function ProgramExit() {
				stack.pop();
			},


			FunctionDeclaration: enterFunction,
			"FunctionDeclaration:exit": exitFunction,
			FunctionExpression: enterFunction,
			"FunctionExpression:exit": exitFunction,
			ThisExpression: function ThisExpression(node) {
				var current = stack.getCurrent();

				if (current && !current.valid) {
					context.report({ node: node, message: "Unexpected 'this'." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var ALL_IRREGULARS = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/;
var IRREGULAR_WHITESPACE = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mg;
var IRREGULAR_LINE_TERMINATORS = /[\u2028\u2029]/mg;
var LINE_BREAK = astUtils.createGlobalLinebreakMatcher();
module.exports = {
	meta: {
		docs: {
			description: "disallow irregular whitespace outside of strings and comments",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				skipComments: {
					type: "boolean"
				},
				skipStrings: {
					type: "boolean"
				},
				skipTemplates: {
					type: "boolean"
				},
				skipRegExps: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var errors = [];
		var options = context.options[0] || {};
		var skipComments = !!options.skipComments;
		var skipStrings = options.skipStrings !== false;
		var skipRegExps = !!options.skipRegExps;
		var skipTemplates = !!options.skipTemplates;

		var sourceCode = context.getSourceCode();
		var commentNodes = sourceCode.getAllComments();
		function removeWhitespaceError(node) {
			var locStart = node.loc.start;
			var locEnd = node.loc.end;

			errors = errors.filter(function (error) {
				var errorLoc = error[1];

				if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {
					if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {
						return false;
					}
				}
				return true;
			});
		}
		function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {
			var shouldCheckStrings = skipStrings && typeof node.value === "string";
			var shouldCheckRegExps = skipRegExps && node.value instanceof RegExp;

			if (shouldCheckStrings || shouldCheckRegExps) {
				if (ALL_IRREGULARS.test(node.raw)) {
					removeWhitespaceError(node);
				}
			}
		}
		function removeInvalidNodeErrorsInTemplateLiteral(node) {
			if (typeof node.value.raw === "string") {
				if (ALL_IRREGULARS.test(node.value.raw)) {
					removeWhitespaceError(node);
				}
			}
		}
		function removeInvalidNodeErrorsInComment(node) {
			if (ALL_IRREGULARS.test(node.value)) {
				removeWhitespaceError(node);
			}
		}
		function checkForIrregularWhitespace(node) {
			var sourceLines = sourceCode.lines;

			sourceLines.forEach(function (sourceLine, lineIndex) {
				var lineNumber = lineIndex + 1;
				var match = void 0;

				while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {
					var location = {
						line: lineNumber,
						column: match.index
					};

					errors.push([node, location, "Irregular whitespace not allowed."]);
				}
			});
		}
		function checkForIrregularLineTerminators(node) {
			var source = sourceCode.getText(),
				sourceLines = sourceCode.lines,
				linebreaks = source.match(LINE_BREAK);
			var lastLineIndex = -1,
				match = void 0;

			while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {
				var lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;
				var location = {
					line: lineIndex + 1,
					column: sourceLines[lineIndex].length
				};

				errors.push([node, location, "Irregular whitespace not allowed."]);
				lastLineIndex = lineIndex;
			}
		}
		function noop() {}

		var nodes = {};

		if (ALL_IRREGULARS.test(sourceCode.getText())) {
			nodes.Program = function (node) {
				checkForIrregularWhitespace(node);
				checkForIrregularLineTerminators(node);
			};

			nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;
			nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;
			nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;
			nodes["Program:exit"] = function () {
				if (skipComments) {
					commentNodes.forEach(removeInvalidNodeErrorsInComment);
				}
				errors.forEach(function (error) {
					context.report.apply(context, error);
				});
			};
		} else {
			nodes.Program = noop;
		}

		return nodes;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of the `__iterator__` property",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			MemberExpression: function MemberExpression(node) {

				if (node.property && node.property.type === "Identifier" && node.property.name === "__iterator__" && !node.computed || node.property.type === "Literal" && node.property.value === "__iterator__") {
					context.report({ node: node, message: "Reserved name '__iterator__'." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow labels that share a name with a variable",
			category: "Variables",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function findIdentifier(scope, name) {
			return astUtils.getVariableByName(scope, name) !== null;
		}
		return {
			LabeledStatement: function LabeledStatement(node) {
				var scope = context.getScope();
				if (findIdentifier(scope, node.label.name)) {
					context.report({ node: node, message: "Found identifier with same name as label." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow labeled statements",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowLoop: {
					type: "boolean"
				},
				allowSwitch: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0];
		var allowLoop = Boolean(options && options.allowLoop);
		var allowSwitch = Boolean(options && options.allowSwitch);
		var scopeInfo = null;
		function getBodyKind(node) {
			if (astUtils.isLoop(node)) {
				return "loop";
			}
			if (node.type === "SwitchStatement") {
				return "switch";
			}
			return "other";
		}
		function isAllowed(kind) {
			switch (kind) {
				case "loop":
					return allowLoop;
				case "switch":
					return allowSwitch;
				default:
					return false;
			}
		}
		function getKind(label) {
			var info = scopeInfo;

			while (info) {
				if (info.label === label) {
					return info.kind;
				}
				info = info.upper;
			}
			return "other";
		}
		return {
			LabeledStatement: function LabeledStatement(node) {
				scopeInfo = {
					label: node.label.name,
					kind: getBodyKind(node.body),
					upper: scopeInfo
				};
			},
			"LabeledStatement:exit": function LabeledStatementExit(node) {
				if (!isAllowed(scopeInfo.kind)) {
					context.report({
						node: node,
						message: "Unexpected labeled statement."
					});
				}

				scopeInfo = scopeInfo.upper;
			},
			BreakStatement: function BreakStatement(node) {
				if (node.label && !isAllowed(getKind(node.label.name))) {
					context.report({
						node: node,
						message: "Unexpected label in break statement."
					});
				}
			},
			ContinueStatement: function ContinueStatement(node) {
				if (node.label && !isAllowed(getKind(node.label.name))) {
					context.report({
						node: node,
						message: "Unexpected label in continue statement."
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary nested blocks",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var loneBlocks = [];
		var ruleDef = void 0;
		function report(node) {
			var message = node.parent.type === "BlockStatement" ? "Nested block is redundant." : "Block is redundant.";

			context.report({ node: node, message: message });
		}
		function isLoneBlock(node) {
			return node.parent.type === "BlockStatement" || node.parent.type === "Program" ||
			node.parent.type === "SwitchCase" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);
		}
		function markLoneBlock() {
			if (loneBlocks.length === 0) {
				return;
			}

			var block = context.getAncestors().pop();

			if (loneBlocks[loneBlocks.length - 1] === block) {
				loneBlocks.pop();
			}
		}
		ruleDef = {
			BlockStatement: function BlockStatement(node) {
				if (isLoneBlock(node)) {
					report(node);
				}
			}
		};
		if (context.parserOptions.ecmaVersion >= 6) {
			ruleDef = {
				BlockStatement: function BlockStatement(node) {
					if (isLoneBlock(node)) {
						loneBlocks.push(node);
					}
				},
				"BlockStatement:exit": function BlockStatementExit(node) {
					if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {
						loneBlocks.pop();
						report(node);
					}
				}
			};

			ruleDef.VariableDeclaration = function (node) {
				if (node.kind === "let" || node.kind === "const") {
					markLoneBlock();
				}
			};

			ruleDef.FunctionDeclaration = function () {
				if (context.getScope().isStrict) {
					markLoneBlock();
				}
			};

			ruleDef.ClassDeclaration = markLoneBlock;
		}

		return ruleDef;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `if` statements as the only statement in `else` blocks",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			IfStatement: function IfStatement(node) {
				var ancestors = context.getAncestors(),
					parent = ancestors.pop(),
					grandparent = ancestors.pop();

				if (parent && parent.type === "BlockStatement" && parent.body.length === 1 && grandparent && grandparent.type === "IfStatement" && parent === grandparent.alternate) {
					context.report({
						node: node,
						message: "Unexpected if as the only statement in an else block.",
						fix: function fix(fixer) {
							var openingElseCurly = sourceCode.getFirstToken(parent);
							var closingElseCurly = sourceCode.getLastToken(parent);
							var elseKeyword = sourceCode.getTokenBefore(openingElseCurly);
							var tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);
							var lastIfToken = sourceCode.getLastToken(node.consequent);
							var sourceText = sourceCode.getText();

							if (sourceText.slice(openingElseCurly.range[1], node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {
								return null;
							}

							if (node.consequent.type !== "BlockStatement" && lastIfToken.value !== ";" && tokenAfterElseBlock && (node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line || /^[([/+`-]/.test(tokenAfterElseBlock.value) || lastIfToken.value === "++" || lastIfToken.value === "--")) {
								return null;
							}

							return fixer.replaceTextRange([openingElseCurly.range[0], closingElseCurly.range[1]], (elseKeyword.range[1] === openingElseCurly.range[0] ? " " : "") + sourceCode.getText(node));
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function getContainingLoopNode(node) {
	var parent = node.parent;

	while (parent) {
		switch (parent.type) {
			case "WhileStatement":
			case "DoWhileStatement":
				return parent;

			case "ForStatement":
				if (parent.init !== node) {
					return parent;
				}
				break;

			case "ForInStatement":
			case "ForOfStatement":
				if (parent.right !== node) {
					return parent;
				}
				break;

			case "ArrowFunctionExpression":
			case "FunctionExpression":
			case "FunctionDeclaration":
				return null;

			default:
				break;
		}

		node = parent;
		parent = node.parent;
	}

	return null;
}
function getTopLoopNode(node, excludedNode) {
	var retv = node;
	var border = excludedNode ? excludedNode.range[1] : 0;

	while (node && node.range[0] >= border) {
		retv = node;
		node = getContainingLoopNode(node);
	}

	return retv;
}
function isSafe(loopNode, reference) {
	var variable = reference.resolved;
	var definition = variable && variable.defs[0];
	var declaration = definition && definition.parent;
	var kind = declaration && declaration.type === "VariableDeclaration" ? declaration.kind : "";
	if (kind === "const") {
		return true;
	}
	if (kind === "let" && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {
		return true;
	}
	var border = getTopLoopNode(loopNode, kind === "let" ? declaration : null).range[0];
	function isSafeReference(upperRef) {
		var id = upperRef.identifier;

		return !upperRef.isWrite() || variable.scope.variableScope === upperRef.from.variableScope && id.range[0] < border;
	}

	return Boolean(variable) && variable.references.every(isSafeReference);
}
module.exports = {
	meta: {
		docs: {
			description: "disallow `function` declarations and expressions inside loop statements",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function checkForLoops(node) {
			var loopNode = getContainingLoopNode(node);

			if (!loopNode) {
				return;
			}

			var references = context.getScope().through;

			if (references.length > 0 && !references.every(isSafe.bind(null, loopNode))) {
				context.report({ node: node, message: "Don't make functions within a loop." });
			}
		}

		return {
			ArrowFunctionExpression: checkForLoops,
			FunctionExpression: checkForLoops,
			FunctionDeclaration: checkForLoops
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow magic numbers",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				detectObjects: {
					type: "boolean"
				},
				enforceConst: {
					type: "boolean"
				},
				ignore: {
					type: "array",
					items: {
						type: "number"
					},
					uniqueItems: true
				},
				ignoreArrayIndexes: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var config = context.options[0] || {},
			detectObjects = !!config.detectObjects,
			enforceConst = !!config.enforceConst,
			ignore = config.ignore || [],
			ignoreArrayIndexes = !!config.ignoreArrayIndexes;
		function isNumber(node) {
			return typeof node.value === "number";
		}
		function shouldIgnoreNumber(num) {
			return ignore.indexOf(num) !== -1;
		}
		function shouldIgnoreParseInt(parent, node) {
			return parent.type === "CallExpression" && node === parent.arguments[1] && (parent.callee.name === "parseInt" || parent.callee.type === "MemberExpression" && parent.callee.object.name === "Number" && parent.callee.property.name === "parseInt");
		}
		function shouldIgnoreJSXNumbers(parent) {
			return parent.type.indexOf("JSX") === 0;
		}
		function shouldIgnoreArrayIndexes(parent) {
			return parent.type === "MemberExpression" && ignoreArrayIndexes;
		}

		return {
			Literal: function Literal(node) {
				var parent = node.parent,
					value = node.value,
					raw = node.raw;
				var okTypes = detectObjects ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];

				if (!isNumber(node)) {
					return;
				}
				if (parent.type === "UnaryExpression" && parent.operator === "-") {
					node = parent;
					parent = node.parent;
					value = -value;
					raw = "-" + raw;
				}

				if (shouldIgnoreNumber(value) || shouldIgnoreParseInt(parent, node) || shouldIgnoreArrayIndexes(parent) || shouldIgnoreJSXNumbers(parent)) {
					return;
				}

				if (parent.type === "VariableDeclarator") {
					if (enforceConst && parent.parent.kind !== "const") {
						context.report({
							node: node,
							message: "Number constants declarations must use 'const'."
						});
					}
				} else if (okTypes.indexOf(parent.type) === -1 || parent.type === "AssignmentExpression" && parent.left.type === "Identifier") {
					context.report({
						node: node,
						message: "No magic number: {{raw}}.",
						data: {
							raw: raw
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var ARITHMETIC_OPERATORS = ["+", "-", "*", "/", "%", "**"];
var BITWISE_OPERATORS = ["&", "|", "^", "~", "<<", ">>", ">>>"];
var COMPARISON_OPERATORS = ["==", "!=", "===", "!==", ">", ">=", "<", "<="];
var LOGICAL_OPERATORS = ["&&", "||"];
var RELATIONAL_OPERATORS = ["in", "instanceof"];
var ALL_OPERATORS = [].concat(ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS);
var DEFAULT_GROUPS = [ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS];
var TARGET_NODE_TYPE = /^(?:Binary|Logical)Expression$/;
function normalizeOptions(options) {
	var hasGroups = options && options.groups && options.groups.length > 0;
	var groups = hasGroups ? options.groups : DEFAULT_GROUPS;
	var allowSamePrecedence = (options && options.allowSamePrecedence) !== false;

	return {
		groups: groups,
		allowSamePrecedence: allowSamePrecedence
	};
}
function includesBothInAGroup(groups, left, right) {
	return groups.some(function (group) {
		return group.indexOf(left) !== -1 && group.indexOf(right) !== -1;
	});
}
module.exports = {
	meta: {
		docs: {
			description: "disallow mixed binary operators",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: [{
			type: "object",
			properties: {
				groups: {
					type: "array",
					items: {
						type: "array",
						items: { enum: ALL_OPERATORS },
						minItems: 2,
						uniqueItems: true
					},
					uniqueItems: true
				},
				allowSamePrecedence: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var options = normalizeOptions(context.options[0]);
		function shouldIgnore(node) {
			var a = node;
			var b = node.parent;

			return !includesBothInAGroup(options.groups, a.operator, b.operator) || options.allowSamePrecedence && astUtils.getPrecedence(a) === astUtils.getPrecedence(b);
		}
		function isMixedWithParent(node) {
			return node.operator !== node.parent.operator && !astUtils.isParenthesised(sourceCode, node);
		}
		function getOperatorToken(node) {
			return sourceCode.getTokenAfter(node.left, astUtils.isNotClosingParenToken);
		}
		function reportBothOperators(node) {
			var parent = node.parent;
			var left = parent.left === node ? node : parent;
			var right = parent.left !== node ? node : parent;
			var message = "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.";
			var data = {
				leftOperator: left.operator,
				rightOperator: right.operator
			};

			context.report({
				node: left,
				loc: getOperatorToken(left).loc.start,
				message: message,
				data: data
			});
			context.report({
				node: right,
				loc: getOperatorToken(right).loc.start,
				message: message,
				data: data
			});
		}
		function check(node) {
			if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) {
				reportBothOperators(node);
			}
		}

		return {
			BinaryExpression: check,
			LogicalExpression: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
	meta: {
		docs: {
			description: "disallow `require` calls to be mixed with regular variable declarations",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "boolean"
			}, {
				type: "object",
				properties: {
					grouping: {
						type: "boolean"
					},
					allowCall: {
						type: "boolean"
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {

		var options = context.options[0];
		var grouping = false,
			allowCall = false;

		if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
			grouping = options.grouping;
			allowCall = options.allowCall;
		} else {
			grouping = !!options;
		}
		function getBuiltinModules() {
			return ["assert", "buffer", "child_process", "cluster", "crypto", "dgram", "dns", "domain", "events", "fs", "http", "https", "net", "os", "path", "punycode", "querystring", "readline", "repl", "smalloc", "stream", "string_decoder", "tls", "tty", "url", "util", "v8", "vm", "zlib"];
		}

		var BUILTIN_MODULES = getBuiltinModules();

		var DECL_REQUIRE = "require",
			DECL_UNINITIALIZED = "uninitialized",
			DECL_OTHER = "other";

		var REQ_CORE = "core",
			REQ_FILE = "file",
			REQ_MODULE = "module",
			REQ_COMPUTED = "computed";
		function getDeclarationType(initExpression) {
			if (!initExpression) {
				return DECL_UNINITIALIZED;
			}

			if (initExpression.type === "CallExpression" && initExpression.callee.type === "Identifier" && initExpression.callee.name === "require") {
				return DECL_REQUIRE;
			}
			if (allowCall && initExpression.type === "CallExpression" && initExpression.callee.type === "CallExpression") {
				return getDeclarationType(initExpression.callee);
			}
			if (initExpression.type === "MemberExpression") {
				return getDeclarationType(initExpression.object);
			}
			return DECL_OTHER;
		}
		function inferModuleType(initExpression) {
			if (initExpression.type === "MemberExpression") {
				return inferModuleType(initExpression.object);
			}
			if (initExpression.arguments.length === 0) {
				return REQ_COMPUTED;
			}

			var arg = initExpression.arguments[0];

			if (arg.type !== "Literal" || typeof arg.value !== "string") {
				return REQ_COMPUTED;
			}

			if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {
				return REQ_CORE;
			}
			if (/^\.{0,2}\//.test(arg.value)) {
				return REQ_FILE;
			}
			return REQ_MODULE;
		}
		function isMixed(declarations) {
			var contains = {};

			declarations.forEach(function (declaration) {
				var type = getDeclarationType(declaration.init);

				contains[type] = true;
			});

			return !!(contains[DECL_REQUIRE] && (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER]));
		}
		function isGrouped(declarations) {
			var found = {};

			declarations.forEach(function (declaration) {
				if (getDeclarationType(declaration.init) === DECL_REQUIRE) {
					found[inferModuleType(declaration.init)] = true;
				}
			});

			return Object.keys(found).length <= 1;
		}

		return {
			VariableDeclaration: function VariableDeclaration(node) {

				if (isMixed(node.declarations)) {
					context.report({ node: node, message: "Do not mix 'require' and other declarations." });
				} else if (grouping && !isGrouped(node.declarations)) {
					context.report({ node: node, message: "Do not mix core, module, file and computed requires." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow mixed spaces and tabs for indentation",
			category: "Stylistic Issues",
			recommended: true
		},

		schema: [{
			enum: ["smart-tabs", true, false]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		var smartTabs = void 0;
		var ignoredLocs = [];

		switch (context.options[0]) {
			case true: // Support old syntax, maybe add deprecation warning here
			case "smart-tabs":
				smartTabs = true;
				break;
			default:
				smartTabs = false;
		}
		function beforeLoc(loc, line, column) {
			if (line < loc.start.line) {
				return true;
			}
			return line === loc.start.line && column < loc.start.column;
		}
		function afterLoc(loc, line, column) {
			if (line > loc.end.line) {
				return true;
			}
			return line === loc.end.line && column > loc.end.column;
		}
		return {
			TemplateElement: function TemplateElement(node) {
				ignoredLocs.push(node.loc);
			},
			"Program:exit": function ProgramExit(node) {
				var regex = /^(?=[\t ]*(\t | \t))/;
				var lines = sourceCode.lines,
					comments = sourceCode.getAllComments();

				comments.forEach(function (comment) {
					ignoredLocs.push(comment.loc);
				});

				ignoredLocs.sort(function (first, second) {
					if (beforeLoc(first, second.start.line, second.start.column)) {
						return 1;
					}

					if (beforeLoc(second, first.start.line, second.start.column)) {
						return -1;
					}

					return 0;
				});

				if (smartTabs) {
					regex = /^(?=[\t ]* \t)/;
				}

				lines.forEach(function (line, i) {
					var match = regex.exec(line);

					if (match) {
						var lineNumber = i + 1,
							column = match.index + 1;

						for (var j = 0; j < ignoredLocs.length; j++) {
							if (beforeLoc(ignoredLocs[j], lineNumber, column)) {
								continue;
							}
							if (afterLoc(ignoredLocs[j], lineNumber, column)) {
								continue;
							}

							return;
						}

						context.report({ node: node, loc: { line: lineNumber, column: column }, message: "Mixed spaces and tabs." });
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow use of chained assignment expressions",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: []
	},

	create: function create(context) {
		return {
			AssignmentExpression: function AssignmentExpression(node) {
				if (["AssignmentExpression", "VariableDeclarator"].indexOf(node.parent.type) !== -1) {
					context.report({
						node: node,
						message: "Unexpected chained assignment."
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow multiple spaces",
			category: "Best Practices",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				exceptions: {
					type: "object",
					patternProperties: {
						"^([A-Z][a-z]*)+$": {
							type: "boolean"
						}
					},
					additionalProperties: false
				},
				ignoreEOLComments: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var options = context.options[0] || {};
		var ignoreEOLComments = options.ignoreEOLComments;
		var exceptions = Object.assign({ Property: true }, options.exceptions);
		var hasExceptions = Object.keys(exceptions).filter(function (key) {
			return exceptions[key];
		}).length > 0;
		function formatReportedCommentValue(token) {
			var valueLines = token.value.split("\n");
			var value = valueLines[0];
			var formattedValue = value.slice(0, 12) + "...";

			return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;
		}
		return {
			Program: function Program() {
				sourceCode.tokensAndComments.forEach(function (leftToken, leftIndex, tokensAndComments) {
					if (leftIndex === tokensAndComments.length - 1) {
						return;
					}
					var rightToken = tokensAndComments[leftIndex + 1];
					if (!sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes("  ") || leftToken.loc.end.line < rightToken.loc.start.line) {
						return;
					}
					if (ignoreEOLComments && astUtils.isCommentToken(rightToken) && (leftIndex === tokensAndComments.length - 2 || rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line)) {
						return;
					}
					if (hasExceptions) {
						var parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);

						if (parentNode && exceptions[parentNode.type]) {
							return;
						}
					}

					var displayValue = void 0;

					if (rightToken.type === "Block") {
						displayValue = "/*" + formatReportedCommentValue(rightToken) + "*/";
					} else if (rightToken.type === "Line") {
						displayValue = "//" + formatReportedCommentValue(rightToken);
					} else {
						displayValue = rightToken.value;
					}

					context.report({
						node: rightToken,
						loc: rightToken.loc.start,
						message: "Multiple spaces found before '{{displayValue}}'.",
						data: { displayValue: displayValue },
						fix: function fix(fixer) {
							return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], " ");
						}
					});
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow multiline strings",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function isJSXElement(node) {
			return node.type.indexOf("JSX") === 0;
		}
		return {
			Literal: function Literal(node) {
				if (astUtils.LINEBREAK_MATCHER.test(node.raw) && !isJSXElement(node.parent)) {
					context.report({ node: node, message: "Multiline support is limited to browsers supporting ES5 only." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow multiple empty lines",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				max: {
					type: "integer",
					minimum: 0
				},
				maxEOF: {
					type: "integer",
					minimum: 0
				},
				maxBOF: {
					type: "integer",
					minimum: 0
				}
			},
			required: ["max"],
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var max = 2,
			maxEOF = max,
			maxBOF = max;

		if (context.options.length) {
			max = context.options[0].max;
			maxEOF = typeof context.options[0].maxEOF !== "undefined" ? context.options[0].maxEOF : max;
			maxBOF = typeof context.options[0].maxBOF !== "undefined" ? context.options[0].maxBOF : max;
		}

		var sourceCode = context.getSourceCode();
		var allLines = sourceCode.lines[sourceCode.lines.length - 1] === "" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;
		var templateLiteralLines = new Set();
		return {
			TemplateLiteral: function TemplateLiteral(node) {
				node.quasis.forEach(function (literalPart) {
					for (var ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {
						templateLiteralLines.add(ignoredLine);
					}
				});
			},
			"Program:exit": function ProgramExit(node) {
				return allLines
				.reduce(function (nonEmptyLineNumbers, line, index) {
					if (line.trim() || templateLiteralLines.has(index + 1)) {
						nonEmptyLineNumbers.push(index + 1);
					}
					return nonEmptyLineNumbers;
				}, [])
				.concat(allLines.length + 1)
				.reduce(function (lastLineNumber, lineNumber) {
					var message = void 0,
						maxAllowed = void 0;

					if (lastLineNumber === 0) {
						message = "Too many blank lines at the beginning of file. Max of {{max}} allowed.";
						maxAllowed = maxBOF;
					} else if (lineNumber === allLines.length + 1) {
						message = "Too many blank lines at the end of file. Max of {{max}} allowed.";
						maxAllowed = maxEOF;
					} else {
						message = "More than {{max}} blank {{pluralizedLines}} not allowed.";
						maxAllowed = max;
					}

					if (lineNumber - lastLineNumber - 1 > maxAllowed) {
						context.report({
							node: node,
							loc: { start: { line: lastLineNumber + 1, column: 0 }, end: { line: lineNumber, column: 0 } },
							message: message,
							data: { max: maxAllowed, pluralizedLines: maxAllowed === 1 ? "line" : "lines" },
							fix: function fix(fixer) {
								var rangeStart = sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 });
								var lineNumberAfterRemovedLines = lineNumber - maxAllowed;
								var rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({ line: lineNumberAfterRemovedLines, column: 0 }) : sourceCode.text.length;

								return fixer.removeRange([rangeStart, rangeEnd]);
							}
						});
					}

					return lineNumber;
				}, 0);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow assignments to native objects or read-only global variables",
			category: "Best Practices",
			recommended: false,
			replacedBy: ["no-global-assign"]
		},

		deprecated: true,

		schema: [{
			type: "object",
			properties: {
				exceptions: {
					type: "array",
					items: { type: "string" },
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var config = context.options[0];
		var exceptions = config && config.exceptions || [];
		function checkReference(reference, index, references) {
			var identifier = reference.identifier;

			if (reference.init === false && reference.isWrite() && (
			index === 0 || references[index - 1].identifier !== identifier)) {
				context.report({
					node: identifier,
					message: "Read-only global '{{name}}' should not be modified.",
					data: identifier
				});
			}
		}
		function checkVariable(variable) {
			if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
				variable.references.forEach(checkReference);
			}
		}

		return {
			Program: function Program() {
				var globalScope = context.getScope();

				globalScope.variables.forEach(checkVariable);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow negated conditions",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function hasElseWithoutCondition(node) {
			return node.alternate && node.alternate.type !== "IfStatement";
		}
		function isNegatedUnaryExpression(test) {
			return test.type === "UnaryExpression" && test.operator === "!";
		}
		function isNegatedBinaryExpression(test) {
			return test.type === "BinaryExpression" && (test.operator === "!=" || test.operator === "!==");
		}
		function isNegatedIf(node) {
			return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);
		}

		return {
			IfStatement: function IfStatement(node) {
				if (!hasElseWithoutCondition(node)) {
					return;
				}

				if (isNegatedIf(node)) {
					context.report({ node: node, message: "Unexpected negated condition." });
				}
			},
			ConditionalExpression: function ConditionalExpression(node) {
				if (isNegatedIf(node)) {
					context.report({ node: node, message: "Unexpected negated condition." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow negating the left operand in `in` expressions",
			category: "Possible Errors",
			recommended: false,
			replacedBy: ["no-unsafe-negation"]
		},
		deprecated: true,

		schema: []
	},

	create: function create(context) {

		return {
			BinaryExpression: function BinaryExpression(node) {
				if (node.operator === "in" && node.left.type === "UnaryExpression" && node.left.operator === "!") {
					context.report({ node: node, message: "The 'in' expression's left operand is negated." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow nested ternary expressions",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			ConditionalExpression: function ConditionalExpression(node) {
				if (node.alternate.type === "ConditionalExpression" || node.consequent.type === "ConditionalExpression") {
					context.report({ node: node, message: "Do not nest ternary expressions." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `new` operators with the `Function` object",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function report(node) {
			context.report({ node: node, message: "The Function constructor is eval." });
		}

		return {
			"NewExpression[callee.name = 'Function']": report,
			"CallExpression[callee.name = 'Function']": report
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `Object` constructors",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			NewExpression: function NewExpression(node) {
				if (node.callee.name === "Object") {
					context.report({ node: node, message: "The object literal notation {} is preferrable." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `new` operators with calls to `require`",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			NewExpression: function NewExpression(node) {
				if (node.callee.type === "Identifier" && node.callee.name === "require") {
					context.report({ node: node, message: "Unexpected use of new with require." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `new` operators with the `Symbol` object",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {

		return {
			"Program:exit": function ProgramExit() {
				var globalScope = context.getScope();
				var variable = globalScope.set.get("Symbol");

				if (variable && variable.defs.length === 0) {
					variable.references.forEach(function (ref) {
						var node = ref.identifier;

						if (node.parent && node.parent.type === "NewExpression") {
							context.report({ node: node, message: "`Symbol` cannot be called as a constructor." });
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `new` operators with the `String`, `Number`, and `Boolean` objects",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			NewExpression: function NewExpression(node) {
				var wrapperObjects = ["String", "Number", "Boolean", "Math", "JSON"];

				if (wrapperObjects.indexOf(node.callee.name) > -1) {
					context.report({ node: node, message: "Do not use {{fn}} as a constructor.", data: { fn: node.callee.name } });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `new` operators outside of assignments or comparisons",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			"ExpressionStatement > NewExpression": function ExpressionStatementNewExpression(node) {
				context.report({ node: node.parent, message: "Do not use 'new' for side effects." });
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow calling global object properties as functions",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {

		return {
			CallExpression: function CallExpression(node) {

				if (node.callee.type === "Identifier") {
					var name = node.callee.name;

					if (name === "Math" || name === "JSON" || name === "Reflect") {
						context.report({ node: node, message: "'{{name}}' is not a function.", data: { name: name } });
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow octal escape sequences in string literals",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			Literal: function Literal(node) {
				if (typeof node.value !== "string") {
					return;
				}

				var match = node.raw.match(/^([^\\]|\\[^0-7])*\\([0-3][0-7]{1,2}|[4-7][0-7]|[0-7])/);

				if (match) {
					var octalDigit = match[2];
					if (match[2] !== "0" || typeof match[3] !== "undefined") {
						context.report({ node: node, message: "Don't use octal: '\\{{octalDigit}}'. Use '\\u....' instead.", data: { octalDigit: octalDigit } });
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow octal literals",
			category: "Best Practices",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {

		return {
			Literal: function Literal(node) {
				if (typeof node.value === "number" && /^0[0-7]/.test(node.raw)) {
					context.report({ node: node, message: "Octal literals should not be used." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/;

module.exports = {
	meta: {
		docs: {
			description: "disallow reassigning `function` parameters",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "object",
				properties: {
					props: {
						enum: [false]
					}
				},
				additionalProperties: false
			}, {
				type: "object",
				properties: {
					props: {
						enum: [true]
					},
					ignorePropertyModificationsFor: {
						type: "array",
						items: {
							type: "string"
						},
						uniqueItems: true
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var props = context.options[0] && Boolean(context.options[0].props);
		var ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];
		function isModifyingProp(reference) {
			var node = reference.identifier;
			var parent = node.parent;

			while (parent && !stopNodePattern.test(parent.type)) {
				switch (parent.type) {
					case "AssignmentExpression":
						return parent.left === node;
					case "UpdateExpression":
						return true;
					case "UnaryExpression":
						if (parent.operator === "delete") {
							return true;
						}
						break;
					case "CallExpression":
						if (parent.callee !== node) {
							return false;
						}
						break;
					case "MemberExpression":
						if (parent.property === node) {
							return false;
						}
						break;
					case "Property":
						if (parent.key === node) {
							return false;
						}

						break;
				}

				node = parent;
				parent = node.parent;
			}

			return false;
		}
		function checkReference(reference, index, references) {
			var identifier = reference.identifier;

			if (identifier && !reference.init && (
			index === 0 || references[index - 1].identifier !== identifier)) {
				if (reference.isWrite()) {
					context.report({ node: identifier, message: "Assignment to function parameter '{{name}}'.", data: { name: identifier.name } });
				} else if (props && isModifyingProp(reference) && ignoredPropertyAssignmentsFor.indexOf(identifier.name) === -1) {
					context.report({ node: identifier, message: "Assignment to property of function parameter '{{name}}'.", data: { name: identifier.name } });
				}
			}
		}
		function checkVariable(variable) {
			if (variable.defs[0].type === "Parameter") {
				variable.references.forEach(checkReference);
			}
		}
		function checkForFunction(node) {
			context.getDeclaredVariables(node).forEach(checkVariable);
		}

		return {
			"FunctionDeclaration:exit": checkForFunction,
			"FunctionExpression:exit": checkForFunction,
			"ArrowFunctionExpression:exit": checkForFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow string concatenation with `__dirname` and `__filename`",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		var MATCHER = /^__(?:dir|file)name$/;
		return {
			BinaryExpression: function BinaryExpression(node) {

				var left = node.left,
					right = node.right;

				if (node.operator === "+" && (left.type === "Identifier" && MATCHER.test(left.name) || right.type === "Identifier" && MATCHER.test(right.name))) {

					context.report({ node: node, message: "Use path.join() or path.resolve() instead of + to create paths." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
	meta: {
		docs: {
			description: "disallow the unary operators `++` and `--`",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowForLoopAfterthoughts: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var config = context.options[0];
		var allowInForAfterthought = false;

		if ((typeof config === "undefined" ? "undefined" : _typeof(config)) === "object") {
			allowInForAfterthought = config.allowForLoopAfterthoughts === true;
		}

		return {
			UpdateExpression: function UpdateExpression(node) {
				if (allowInForAfterthought && node.parent.type === "ForStatement") {
					return;
				}
				context.report({
					node: node,
					message: "Unary operator '{{operator}}' used.",
					data: {
						operator: node.operator
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `process.env`",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			MemberExpression: function MemberExpression(node) {
				var objectName = node.object.name,
					propertyName = node.property.name;

				if (objectName === "process" && !node.computed && propertyName && propertyName === "env") {
					context.report({ node: node, message: "Unexpected use of process.env." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `process.exit()`",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		return {
			"CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']": function CallExpressionMemberExpressionCalleeObjectNameProcessPropertyNameExit(node) {
				context.report({ node: node.parent, message: "Don't use process.exit(); throw an error instead." });
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of the `__proto__` property",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			MemberExpression: function MemberExpression(node) {

				if (node.property && node.property.type === "Identifier" && node.property.name === "__proto__" && !node.computed || node.property.type === "Literal" && node.property.value === "__proto__") {
					context.report({ node: node, message: "The '__proto__' property is deprecated." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow calling some `Object.prototype` methods directly on objects",
			category: "Possible Errors",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var DISALLOWED_PROPS = ["hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable"];
		function disallowBuiltIns(node) {
			if (node.callee.type !== "MemberExpression" || node.callee.computed) {
				return;
			}
			var propName = node.callee.property.name;

			if (DISALLOWED_PROPS.indexOf(propName) > -1) {
				context.report({
					message: "Do not access Object.prototype method '{{prop}}' from target object.",
					loc: node.callee.property.loc.start,
					data: { prop: propName },
					node: node
				});
			}
		}

		return {
			CallExpression: disallowBuiltIns
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow variable redeclaration",
			category: "Best Practices",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				builtinGlobals: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = {
			builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals)
		};
		function findVariablesInScope(scope) {
			scope.variables.forEach(function (variable) {
				var hasBuiltin = options.builtinGlobals && "writeable" in variable;
				var count = (hasBuiltin ? 1 : 0) + variable.identifiers.length;

				if (count >= 2) {
					variable.identifiers.sort(function (a, b) {
						return a.range[1] - b.range[1];
					});

					for (var i = hasBuiltin ? 0 : 1, l = variable.identifiers.length; i < l; i++) {
						context.report({ node: variable.identifiers[i], message: "'{{a}}' is already defined.", data: { a: variable.name } });
					}
				}
			});
		}
		function checkForGlobal(node) {
			var scope = context.getScope(),
				parserOptions = context.parserOptions,
				ecmaFeatures = parserOptions.ecmaFeatures || {};
			if (ecmaFeatures.globalReturn || node.sourceType === "module") {
				findVariablesInScope(scope.childScopes[0]);
			} else {
				findVariablesInScope(scope);
			}
		}
		function checkForBlock() {
			findVariablesInScope(context.getScope());
		}

		if (context.parserOptions.ecmaVersion >= 6) {
			return {
				Program: checkForGlobal,
				BlockStatement: checkForBlock,
				SwitchStatement: checkForBlock
			};
		}
		return {
			Program: checkForGlobal,
			FunctionDeclaration: checkForBlock,
			FunctionExpression: checkForBlock,
			ArrowFunctionExpression: checkForBlock
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow multiple spaces in regular expressions",
			category: "Possible Errors",
			recommended: true
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function checkRegex(node, value, valueStart) {
			var multipleSpacesRegex = /( {2,})( [+*{?]|[^+*{?]|$)/,
				regexResults = multipleSpacesRegex.exec(value);

			if (regexResults !== null) {
				var count = regexResults[1].length;

				context.report({
					node: node,
					message: "Spaces are hard to count. Use {{{count}}}.",
					data: { count: count },
					fix: function fix(fixer) {
						return fixer.replaceTextRange([valueStart + regexResults.index, valueStart + regexResults.index + count], " {" + count + "}");
					}
				});
			}
		}
		function checkLiteral(node) {
			var token = sourceCode.getFirstToken(node),
				nodeType = token.type,
				nodeValue = token.value;

			if (nodeType === "RegularExpression") {
				checkRegex(node, nodeValue, token.range[0]);
			}
		}
		function isString(node) {
			return node && node.type === "Literal" && typeof node.value === "string";
		}
		function checkFunction(node) {
			var scope = context.getScope();
			var regExpVar = astUtils.getVariableByName(scope, "RegExp");
			var shadowed = regExpVar && regExpVar.defs.length > 0;

			if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0]) && !shadowed) {
				checkRegex(node, node.arguments[0].value, node.arguments[0].range[0] + 1);
			}
		}

		return {
			Literal: checkLiteral,
			CallExpression: checkFunction,
			NewExpression: checkFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var DEFAULT_MESSAGE_TEMPLATE = "Unexpected use of '{{name}}'.",
	CUSTOM_MESSAGE_TEMPLATE = "Unexpected use of '{{name}}'. {{customMessage}}";
module.exports = {
	meta: {
		docs: {
			description: "disallow specified global variables",
			category: "Variables",
			recommended: false
		},

		schema: {
			type: "array",
			items: {
				oneOf: [{
					type: "string"
				}, {
					type: "object",
					properties: {
						name: { type: "string" },
						message: { type: "string" }
					},
					required: ["name"],
					additionalProperties: false
				}]
			},
			uniqueItems: true,
			minItems: 0
		}
	},

	create: function create(context) {
		if (context.options.length === 0) {
			return {};
		}

		var restrictedGlobalMessages = context.options.reduce(function (memo, option) {
			if (typeof option === "string") {
				memo[option] = null;
			} else {
				memo[option.name] = option.message;
			}

			return memo;
		}, {});
		function reportReference(reference) {
			var name = reference.identifier.name,
				customMessage = restrictedGlobalMessages[name],
				message = customMessage ? CUSTOM_MESSAGE_TEMPLATE : DEFAULT_MESSAGE_TEMPLATE;

			context.report({
				node: reference.identifier,
				message: message,
				data: {
					name: name,
					customMessage: customMessage
				}
			});
		}
		function isRestricted(name) {
			return restrictedGlobalMessages.hasOwnProperty(name);
		}

		return {
			Program: function Program() {
				var scope = context.getScope();
				scope.variables.forEach(function (variable) {
					if (!variable.defs.length && isRestricted(variable.name)) {
						variable.references.forEach(reportReference);
					}
				});
				scope.through.forEach(function (reference) {
					if (isRestricted(reference.identifier.name)) {
						reportReference(reference);
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var DEFAULT_MESSAGE_TEMPLATE = "'{{importSource}}' import is restricted from being used.";
var CUSTOM_MESSAGE_TEMPLATE = "'{{importSource}}' import is restricted from being used. {{customMessage}}";
var ignore = __webpack_require__(163);

var arrayOfStrings = {
	type: "array",
	items: { type: "string" },
	uniqueItems: true
};

var arrayOfStringsOrObjects = {
	type: "array",
	items: {
		anyOf: [{ type: "string" }, {
			type: "object",
			properties: {
				name: { type: "string" },
				message: {
					type: "string",
					minLength: 1
				},
				importNames: {
					type: "array",
					items: {
						type: "string"
					}
				}
			},
			additionalProperties: false,
			required: ["name"]
		}]
	},
	uniqueItems: true
};

module.exports = {
	meta: {
		docs: {
			description: "disallow specified modules when loaded by `import`",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: {
			anyOf: [arrayOfStringsOrObjects, {
				type: "array",
				items: {
					type: "object",
					properties: {
						paths: arrayOfStringsOrObjects,
						patterns: arrayOfStrings
					},
					additionalProperties: false
				},
				additionalItems: false
			}]
		}
	},

	create: function create(context) {
		var options = Array.isArray(context.options) ? context.options : [];
		var isPathAndPatternsObject = _typeof(options[0]) === "object" && (options[0].hasOwnProperty("paths") || options[0].hasOwnProperty("patterns"));

		var restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
		var restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];

		var restrictedPathMessages = restrictedPaths.reduce(function (memo, importSource) {
			if (typeof importSource === "string") {
				memo[importSource] = { message: null };
			} else {
				memo[importSource.name] = {
					message: importSource.message,
					importNames: importSource.importNames
				};
			}
			return memo;
		}, {});
		if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
			return {};
		}

		var restrictedPatternsMatcher = ignore().add(restrictedPatterns);
		function isEverythingImported(importNames) {
			return importNames.has("*");
		}
		function reportPath(node) {
			var importSource = node.source.value.trim();
			var customMessage = restrictedPathMessages[importSource] && restrictedPathMessages[importSource].message;
			var message = customMessage ? CUSTOM_MESSAGE_TEMPLATE : DEFAULT_MESSAGE_TEMPLATE;

			context.report({
				node: node,
				message: message,
				data: {
					importSource: importSource,
					customMessage: customMessage
				}
			});
		}
		function reportPathForPatterns(node) {
			var importSource = node.source.value.trim();

			context.report({
				node: node,
				message: "'{{importSource}}' import is restricted from being used by a pattern.",
				data: {
					importSource: importSource
				}
			});
		}
		function reportPathForEverythingImported(importSource, node) {
			var importNames = restrictedPathMessages[importSource].importNames;

			context.report({
				node: node,
				message: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.",
				data: {
					importSource: importSource,
					importNames: importNames
				}
			});
		}
		function isRestrictedForEverythingImported(importSource, importNames) {
			return Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource) && restrictedPathMessages[importSource].importNames && isEverythingImported(importNames);
		}
		function isRestrictedObject(importNames, restrictedImportNames) {
			return restrictedImportNames.some(function (restrictedObjectName) {
				return importNames.has(restrictedObjectName);
			});
		}
		function isRestrictedPath(importSource, importNames) {
			var isRestricted = false;

			if (Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {
				if (restrictedPathMessages[importSource].importNames) {
					isRestricted = isRestrictedObject(importNames, restrictedPathMessages[importSource].importNames);
				} else {
					isRestricted = true;
				}
			}

			return isRestricted;
		}
		function isRestrictedPattern(importSource) {
			return restrictedPatterns.length > 0 && restrictedPatternsMatcher.ignores(importSource);
		}

		return {
			ImportDeclaration: function ImportDeclaration(node) {
				var importSource = node.source.value.trim();
				var importNames = node.specifiers.reduce(function (set, specifier) {
					if (specifier.type === "ImportDefaultSpecifier") {
						set.add("default");
					} else if (specifier.type === "ImportNamespaceSpecifier") {
						set.add("*");
					} else {
						set.add(specifier.imported.name);
					}
					return set;
				}, new Set());

				if (isRestrictedForEverythingImported(importSource, importNames)) {
					reportPathForEverythingImported(importSource, node);
				}

				if (isRestrictedPath(importSource, importNames)) {
					reportPath(node);
				}
				if (isRestrictedPattern(importSource)) {
					reportPathForPatterns(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var DEFAULT_MESSAGE_TEMPLATE = "'{{moduleName}}' module is restricted from being used.";
var CUSTOM_MESSAGE_TEMPLATE = "'{{moduleName}}' module is restricted from being used. {{customMessage}}";
var ignore = __webpack_require__(163);

var arrayOfStrings = {
	type: "array",
	items: { type: "string" },
	uniqueItems: true
};

var arrayOfStringsOrObjects = {
	type: "array",
	items: {
		anyOf: [{ type: "string" }, {
			type: "object",
			properties: {
				name: { type: "string" },
				message: {
					type: "string",
					minLength: 1
				}
			},
			additionalProperties: false,
			required: ["name"]
		}]
	},
	uniqueItems: true
};

module.exports = {
	meta: {
		docs: {
			description: "disallow specified modules when loaded by `require`",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: {
			anyOf: [arrayOfStringsOrObjects, {
				type: "array",
				items: {
					type: "object",
					properties: {
						paths: arrayOfStringsOrObjects,
						patterns: arrayOfStrings
					},
					additionalProperties: false
				},
				additionalItems: false
			}]
		}
	},

	create: function create(context) {
		var options = Array.isArray(context.options) ? context.options : [];
		var isPathAndPatternsObject = _typeof(options[0]) === "object" && (options[0].hasOwnProperty("paths") || options[0].hasOwnProperty("patterns"));

		var restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
		var restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];

		var restrictedPathMessages = restrictedPaths.reduce(function (memo, importName) {
			if (typeof importName === "string") {
				memo[importName] = null;
			} else {
				memo[importName.name] = importName.message;
			}
			return memo;
		}, {});
		if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
			return {};
		}

		var ig = ignore().add(restrictedPatterns);
		function isString(node) {
			return node && node.type === "Literal" && typeof node.value === "string";
		}
		function isRequireCall(node) {
			return node.callee.type === "Identifier" && node.callee.name === "require";
		}
		function reportPath(node) {
			var moduleName = node.arguments[0].value.trim();
			var customMessage = restrictedPathMessages[moduleName];
			var message = customMessage ? CUSTOM_MESSAGE_TEMPLATE : DEFAULT_MESSAGE_TEMPLATE;

			context.report({
				node: node,
				message: message,
				data: {
					moduleName: moduleName,
					customMessage: customMessage
				}
			});
		}
		function isRestrictedPath(name) {
			return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);
		}

		return {
			CallExpression: function CallExpression(node) {
				if (isRequireCall(node)) {
					if (node.arguments.length && isString(node.arguments[0])) {
						var moduleName = node.arguments[0].value.trim();
						if (isRestrictedPath(moduleName)) {
							reportPath(node);
						}

						if (restrictedPatterns.length > 0 && ig.ignores(moduleName)) {
							context.report({
								node: node,
								message: "'{{moduleName}}' module is restricted from being used by a pattern.",
								data: { moduleName: moduleName }
							});
						}
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow certain properties on certain objects",
			category: "Best Practices",
			recommended: false
		},

		schema: {
			type: "array",
			items: {
				anyOf: [// `object` and `property` are both optional, but at least one of them must be provided.
				{
					type: "object",
					properties: {
						object: {
							type: "string"
						},
						property: {
							type: "string"
						},
						message: {
							type: "string"
						}
					},
					additionalProperties: false,
					required: ["object"]
				}, {
					type: "object",
					properties: {
						object: {
							type: "string"
						},
						property: {
							type: "string"
						},
						message: {
							type: "string"
						}
					},
					additionalProperties: false,
					required: ["property"]
				}]
			},
			uniqueItems: true
		}
	},

	create: function create(context) {
		var restrictedCalls = context.options;

		if (restrictedCalls.length === 0) {
			return {};
		}

		var restrictedProperties = new Map();
		var globallyRestrictedObjects = new Map();
		var globallyRestrictedProperties = new Map();

		restrictedCalls.forEach(function (option) {
			var objectName = option.object;
			var propertyName = option.property;

			if (typeof objectName === "undefined") {
				globallyRestrictedProperties.set(propertyName, { message: option.message });
			} else if (typeof propertyName === "undefined") {
				globallyRestrictedObjects.set(objectName, { message: option.message });
			} else {
				if (!restrictedProperties.has(objectName)) {
					restrictedProperties.set(objectName, new Map());
				}

				restrictedProperties.get(objectName).set(propertyName, {
					message: option.message
				});
			}
		});
		function checkPropertyAccess(node, objectName, propertyName) {
			if (propertyName === null) {
				return;
			}
			var matchedObject = restrictedProperties.get(objectName);
			var matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);
			var globalMatchedProperty = globallyRestrictedProperties.get(propertyName);

			if (matchedObjectProperty) {
				var message = matchedObjectProperty.message ? " " + matchedObjectProperty.message : "";

				context.report({
					node: node,
					message: "'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}",
					data: {
						objectName: objectName,
						propertyName: propertyName,
						message: message
					}
				});
			} else if (globalMatchedProperty) {
				var _message = globalMatchedProperty.message ? " " + globalMatchedProperty.message : "";

				context.report({
					node: node,
					message: "'{{propertyName}}' is restricted from being used.{{message}}",
					data: {
						propertyName: propertyName,
						message: _message
					}
				});
			}
		}
		function checkDestructuringAssignment(node) {
			if (node.right.type === "Identifier") {
				var objectName = node.right.name;

				if (node.left.type === "ObjectPattern") {
					node.left.properties.forEach(function (property) {
						checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));
					});
				}
			}
		}

		return {
			MemberExpression: function MemberExpression(node) {
				checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));
			},
			VariableDeclarator: function VariableDeclarator(node) {
				if (node.init && node.init.type === "Identifier") {
					var objectName = node.init.name;

					if (node.id.type === "ObjectPattern") {
						node.id.properties.forEach(function (property) {
							checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));
						});
					}
				}
			},

			AssignmentExpression: checkDestructuringAssignment,
			AssignmentPattern: checkDestructuringAssignment
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

module.exports = {
	meta: {
		docs: {
			description: "disallow specified syntax",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: {
			type: "array",
			items: [{
				oneOf: [{
					type: "string"
				}, {
					type: "object",
					properties: {
						selector: { type: "string" },
						message: { type: "string" }
					},
					required: ["selector"],
					additionalProperties: false
				}]
			}],
			uniqueItems: true,
			minItems: 0
		}
	},

	create: function create(context) {
		return context.options.reduce(function (result, selectorOrObject) {
			var isStringFormat = typeof selectorOrObject === "string";
			var hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);

			var selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;
			var message = hasCustomMessage ? selectorOrObject.message : "Using '{{selector}}' is not allowed.";

			return Object.assign(result, _defineProperty({}, selector, function (node) {
				context.report({
					node: node,
					message: message,
					data: hasCustomMessage ? {} : { selector: selector }
				});
			}));
		}, {});
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/;
module.exports = {
	meta: {
		docs: {
			description: "disallow assignment operators in `return` statements",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			enum: ["except-parens", "always"]
		}]
	},

	create: function create(context) {
		var always = (context.options[0] || "except-parens") !== "except-parens";
		var sourceCode = context.getSourceCode();

		return {
			AssignmentExpression: function AssignmentExpression(node) {
				if (!always && astUtils.isParenthesised(sourceCode, node)) {
					return;
				}

				var parent = node.parent;
				while (parent && !SENTINEL_TYPE.test(parent.type)) {
					node = parent;
					parent = parent.parent;
				}
				if (parent && parent.type === "ReturnStatement") {
					context.report({
						node: parent,
						message: "Return statement should not contain assignment."
					});
				} else if (parent && parent.type === "ArrowFunctionExpression" && parent.body === node) {
					context.report({
						node: parent,
						message: "Arrow function should not return assignment."
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
var message = "Redundant use of `await` on a return value.";

module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary `return await`",
			category: "Best Practices",
			recommended: false // TODO: set to true
		},
		fixable: null,
		schema: []
	},

	create: function create(context) {
		function reportUnnecessaryAwait(node) {
			context.report({
				node: context.getSourceCode().getFirstToken(node),
				loc: node.loc,
				message: message
			});
		}
		function hasErrorHandler(node) {
			var ancestor = node;

			while (!astUtils.isFunction(ancestor) && ancestor.type !== "Program") {
				if (ancestor.parent.type === "TryStatement" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {
					return true;
				}
				ancestor = ancestor.parent;
			}
			return false;
		}
		function isInTailCallPosition(node) {
			if (node.parent.type === "ArrowFunctionExpression") {
				return true;
			}
			if (node.parent.type === "ReturnStatement") {
				return !hasErrorHandler(node.parent);
			}
			if (node.parent.type === "ConditionalExpression" && (node === node.parent.consequent || node === node.parent.alternate)) {
				return isInTailCallPosition(node.parent);
			}
			if (node.parent.type === "LogicalExpression" && node === node.parent.right) {
				return isInTailCallPosition(node.parent);
			}
			if (node.parent.type === "SequenceExpression" && node === node.parent.expressions[node.parent.expressions.length - 1]) {
				return isInTailCallPosition(node.parent);
			}
			return false;
		}

		return {
			AwaitExpression: function AwaitExpression(node) {
				if (isInTailCallPosition(node) && !hasErrorHandler(node)) {
					reportUnnecessaryAwait(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `javascript:` urls",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			Literal: function Literal(node) {
				if (node.value && typeof node.value === "string") {
					var value = node.value.toLowerCase();

					if (value.indexOf("javascript:") === 0) {
						context.report({ node: node, message: "Script URL is a form of eval." });
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var SPACES = /\s+/g;
function isSameProperty(left, right) {
	if (left.property.type === "Identifier" && left.property.type === right.property.type && left.property.name === right.property.name && left.computed === right.computed) {
		return true;
	}

	var lname = astUtils.getStaticPropertyName(left);
	var rname = astUtils.getStaticPropertyName(right);

	return lname !== null && lname === rname;
}
function isSameMember(left, right) {
	if (!isSameProperty(left, right)) {
		return false;
	}

	var lobj = left.object;
	var robj = right.object;

	if (lobj.type !== robj.type) {
		return false;
	}
	if (lobj.type === "MemberExpression") {
		return isSameMember(lobj, robj);
	}
	return lobj.type === "Identifier" && lobj.name === robj.name;
}
function eachSelfAssignment(left, right, props, report) {
	if (!left || !right) {
	} else if (left.type === "Identifier" && right.type === "Identifier" && left.name === right.name) {
		report(right);
	} else if (left.type === "ArrayPattern" && right.type === "ArrayExpression") {
		var end = Math.min(left.elements.length, right.elements.length);

		for (var i = 0; i < end; ++i) {
			var rightElement = right.elements[i];

			eachSelfAssignment(left.elements[i], rightElement, props, report);
			if (rightElement && rightElement.type === "SpreadElement") {
				break;
			}
		}
	} else if (left.type === "RestElement" && right.type === "SpreadElement") {
		eachSelfAssignment(left.argument, right.argument, props, report);
	} else if (left.type === "ObjectPattern" && right.type === "ObjectExpression" && right.properties.length >= 1) {
		var startJ = 0;

		for (var _i = right.properties.length - 1; _i >= 0; --_i) {
			if (right.properties[_i].type === "ExperimentalSpreadProperty") {
				startJ = _i + 1;
				break;
			}
		}

		for (var _i2 = 0; _i2 < left.properties.length; ++_i2) {
			for (var j = startJ; j < right.properties.length; ++j) {
				eachSelfAssignment(left.properties[_i2], right.properties[j], props, report);
			}
		}
	} else if (left.type === "Property" && right.type === "Property" && !left.computed && !right.computed && right.kind === "init" && !right.method && left.key.name === right.key.name) {
		eachSelfAssignment(left.value, right.value, props, report);
	} else if (props && left.type === "MemberExpression" && right.type === "MemberExpression" && isSameMember(left, right)) {
		report(right);
	}
}
module.exports = {
	meta: {
		docs: {
			description: "disallow assignments where both sides are exactly the same",
			category: "Best Practices",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				props: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var options = context.options[0];
		var props = Boolean(options && options.props);
		function report(node) {
			context.report({
				node: node,
				message: "'{{name}}' is assigned to itself.",
				data: {
					name: sourceCode.getText(node).replace(SPACES, "")
				}
			});
		}

		return {
			AssignmentExpression: function AssignmentExpression(node) {
				if (node.operator === "=") {
					eachSelfAssignment(node.left, node.right, props, report);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow comparisons where both sides are exactly the same",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function hasSameTokens(nodeA, nodeB) {
			var tokensA = sourceCode.getTokens(nodeA);
			var tokensB = sourceCode.getTokens(nodeB);

			return tokensA.length === tokensB.length && tokensA.every(function (token, index) {
				return token.type === tokensB[index].type && token.value === tokensB[index].value;
			});
		}

		return {
			BinaryExpression: function BinaryExpression(node) {
				var operators = new Set(["===", "==", "!==", "!=", ">", "<", ">=", "<="]);

				if (operators.has(node.operator) && hasSameTokens(node.left, node.right)) {
					context.report({ node: node, message: "Comparing to itself is potentially pointless." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow comma operators",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var parenthesized = {
			DoWhileStatement: "test",
			IfStatement: "test",
			SwitchStatement: "discriminant",
			WhileStatement: "test",
			WithStatement: "object",
			ArrowFunctionExpression: "body"
		};
		function requiresExtraParens(node) {
			return node.parent && parenthesized[node.parent.type] && node === node.parent[parenthesized[node.parent.type]];
		}
		function isParenthesised(node) {
			return astUtils.isParenthesised(sourceCode, node);
		}
		function isParenthesisedTwice(node) {
			var previousToken = sourceCode.getTokenBefore(node, 1),
				nextToken = sourceCode.getTokenAfter(node, 1);

			return isParenthesised(node) && previousToken && nextToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
		}

		return {
			SequenceExpression: function SequenceExpression(node) {
				if (node.parent.type === "ForStatement" && (node === node.parent.init || node === node.parent.update)) {
					return;
				}
				if (requiresExtraParens(node)) {
					if (isParenthesisedTwice(node)) {
						return;
					}
				} else {
					if (isParenthesised(node)) {
						return;
					}
				}

				var child = sourceCode.getTokenAfter(node.expressions[0]);

				context.report({ node: node, loc: child.loc.start, message: "Unexpected use of comma operator." });
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow identifiers from shadowing restricted names",
			category: "Variables",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		var RESTRICTED = ["undefined", "NaN", "Infinity", "arguments", "eval"];
		function checkForViolation(id) {
			if (RESTRICTED.indexOf(id.name) > -1) {
				context.report({
					node: id,
					message: "Shadowing of global property '{{idName}}'.",
					data: {
						idName: id.name
					}
				});
			}
		}

		return {
			VariableDeclarator: function VariableDeclarator(node) {
				checkForViolation(node.id);
			},
			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
				[].map.call(node.params, checkForViolation);
			},
			FunctionExpression: function FunctionExpression(node) {
				if (node.id) {
					checkForViolation(node.id);
				}
				[].map.call(node.params, checkForViolation);
			},
			FunctionDeclaration: function FunctionDeclaration(node) {
				if (node.id) {
					checkForViolation(node.id);
					[].map.call(node.params, checkForViolation);
				}
			},
			CatchClause: function CatchClause(node) {
				checkForViolation(node.param);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow variable declarations from shadowing variables declared in the outer scope",
			category: "Variables",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				builtinGlobals: { type: "boolean" },
				hoist: { enum: ["all", "functions", "never"] },
				allow: {
					type: "array",
					items: {
						type: "string"
					}
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = {
			builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals),
			hoist: context.options[0] && context.options[0].hoist || "functions",
			allow: context.options[0] && context.options[0].allow || []
		};
		function isAllowed(variable) {
			return options.allow.indexOf(variable.name) !== -1;
		}
		function isDuplicatedClassNameVariable(variable) {
			var block = variable.scope.block;

			return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
		}
		function isOnInitializer(variable, scopeVar) {
			var outerScope = scopeVar.scope;
			var outerDef = scopeVar.defs[0];
			var outer = outerDef && outerDef.parent && outerDef.parent.range;
			var innerScope = variable.scope;
			var innerDef = variable.defs[0];
			var inner = innerDef && innerDef.name.range;

			return outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression" || innerDef.node.type === "ClassExpression") && outerScope === innerScope.upper;
		}
		function getNameRange(variable) {
			var def = variable.defs[0];

			return def && def.name.range;
		}
		function isInTdz(variable, scopeVar) {
			var outerDef = scopeVar.defs[0];
			var inner = getNameRange(variable);
			var outer = getNameRange(scopeVar);

			return inner && outer && inner[1] < outer[0] && (
			options.hoist !== "functions" || !outerDef || outerDef.node.type !== "FunctionDeclaration");
		}
		function checkForShadows(scope) {
			var variables = scope.variables;

			for (var i = 0; i < variables.length; ++i) {
				var variable = variables[i];
				if (variable.identifiers.length === 0 || isDuplicatedClassNameVariable(variable) || isAllowed(variable)) {
					continue;
				}
				var shadowed = astUtils.getVariableByName(scope.upper, variable.name);

				if (shadowed && (shadowed.identifiers.length > 0 || options.builtinGlobals && "writeable" in shadowed) && !isOnInitializer(variable, shadowed) && !(options.hoist !== "all" && isInTdz(variable, shadowed))) {
					context.report({
						node: variable.identifiers[0],
						message: "'{{name}}' is already declared in the upper scope.",
						data: variable
					});
				}
			}
		}

		return {
			"Program:exit": function ProgramExit() {
				var globalScope = context.getScope();
				var stack = globalScope.childScopes.slice();

				while (stack.length) {
					var scope = stack.pop();

					stack.push.apply(stack, scope.childScopes);
					checkForShadows(scope);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow spacing between function identifiers and their applications (deprecated)",
			category: "Stylistic Issues",
			recommended: false,
			replacedBy: ["func-call-spacing"]
		},

		deprecated: true,

		fixable: "whitespace",
		schema: []
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode();
		function detectOpenSpaces(node) {
			var lastCalleeToken = sourceCode.getLastToken(node.callee);
			var prevToken = lastCalleeToken,
				parenToken = sourceCode.getTokenAfter(lastCalleeToken);
			while (parenToken && parenToken.range[1] < node.range[1] && parenToken.value !== "(") {
				prevToken = parenToken;
				parenToken = sourceCode.getTokenAfter(parenToken);
			}
			if (parenToken && parenToken.range[1] < node.range[1] && sourceCode.isSpaceBetweenTokens(prevToken, parenToken)) {
				context.report({
					node: node,
					loc: lastCalleeToken.loc.start,
					message: "Unexpected space between function name and paren.",
					fix: function fix(fixer) {
						return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
					}
				});
			}
		}

		return {
			CallExpression: detectOpenSpaces,
			NewExpression: detectOpenSpaces
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow sparse arrays",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		return {
			ArrayExpression: function ArrayExpression(node) {

				var emptySpot = node.elements.indexOf(null) > -1;

				if (emptySpot) {
					context.report({ node: node, message: "Unexpected comma in middle of array." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

module.exports = {
	meta: {
		docs: {
			description: "disallow synchronous methods",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowAtRootLevel: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var selector = context.options[0] && context.options[0].allowAtRootLevel ? ":function MemberExpression[property.name=/.*Sync$/]" : "MemberExpression[property.name=/.*Sync$/]";

		return _defineProperty({}, selector, function (node) {
			context.report({
				node: node,
				message: "Unexpected sync method: '{{propertyName}}'.",
				data: {
					propertyName: node.property.name
				}
			});
		});
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var regex = /\t/;
module.exports = {
	meta: {
		docs: {
			description: "disallow all tabs",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: []
	},

	create: function create(context) {
		return {
			Program: function Program(node) {
				context.getSourceCode().getLines().forEach(function (line, index) {
					var match = regex.exec(line);

					if (match) {
						context.report({
							node: node,
							loc: {
								line: index + 1,
								column: match.index + 1
							},
							message: "Unexpected tab character."
						});
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow template literal placeholder syntax in regular strings",
			category: "Possible Errors",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var regex = /\$\{[^}]+\}/;

		return {
			Literal: function Literal(node) {
				if (typeof node.value === "string" && regex.test(node.value)) {
					context.report({
						node: node,
						message: "Unexpected template string expression."
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow ternary operators",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			ConditionalExpression: function ConditionalExpression(node) {
				context.report({ node: node, message: "Ternary operator used." });
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isConstructorFunction(node) {
	return node.type === "FunctionExpression" && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
}
module.exports = {
	meta: {
		docs: {
			description: "disallow `this`/`super` before calling `super()` in constructors",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var funcInfo = null;
		var segInfoMap = Object.create(null);
		function isCalled(segment) {
			return !segment.reachable || segInfoMap[segment.id].superCalled;
		}
		function isInConstructorOfDerivedClass() {
			return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
		}
		function isBeforeCallOfSuper() {
			return isInConstructorOfDerivedClass() && !funcInfo.codePath.currentSegments.every(isCalled);
		}
		function setInvalid(node) {
			var segments = funcInfo.codePath.currentSegments;

			for (var i = 0; i < segments.length; ++i) {
				var segment = segments[i];

				if (segment.reachable) {
					segInfoMap[segment.id].invalidNodes.push(node);
				}
			}
		}
		function setSuperCalled() {
			var segments = funcInfo.codePath.currentSegments;

			for (var i = 0; i < segments.length; ++i) {
				var segment = segments[i];

				if (segment.reachable) {
					segInfoMap[segment.id].superCalled = true;
				}
			}
		}

		return {
			onCodePathStart: function onCodePathStart(codePath, node) {
				if (isConstructorFunction(node)) {
					var classNode = node.parent.parent.parent;

					funcInfo = {
						upper: funcInfo,
						isConstructor: true,
						hasExtends: Boolean(classNode.superClass && !astUtils.isNullOrUndefined(classNode.superClass)),
						codePath: codePath
					};
				} else {
					funcInfo = {
						upper: funcInfo,
						isConstructor: false,
						hasExtends: false,
						codePath: codePath
					};
				}
			},
			onCodePathEnd: function onCodePathEnd(codePath) {
				var isDerivedClass = funcInfo.hasExtends;

				funcInfo = funcInfo.upper;
				if (!isDerivedClass) {
					return;
				}

				codePath.traverseSegments(function (segment, controller) {
					var info = segInfoMap[segment.id];

					for (var i = 0; i < info.invalidNodes.length; ++i) {
						var invalidNode = info.invalidNodes[i];

						context.report({
							message: "'{{kind}}' is not allowed before 'super()'.",
							node: invalidNode,
							data: {
								kind: invalidNode.type === "Super" ? "super" : "this"
							}
						});
					}

					if (info.superCalled) {
						controller.skip();
					}
				});
			},
			onCodePathSegmentStart: function onCodePathSegmentStart(segment) {
				if (!isInConstructorOfDerivedClass()) {
					return;
				}
				segInfoMap[segment.id] = {
					superCalled: segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled),
					invalidNodes: []
				};
			},
			onCodePathSegmentLoop: function onCodePathSegmentLoop(fromSegment, toSegment) {
				if (!isInConstructorOfDerivedClass()) {
					return;
				}
				funcInfo.codePath.traverseSegments({ first: toSegment, last: fromSegment }, function (segment, controller) {
					var info = segInfoMap[segment.id];

					if (info.superCalled) {
						info.invalidNodes = [];
						controller.skip();
					} else if (segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled)) {
						info.superCalled = true;
						info.invalidNodes = [];
					}
				});
			},
			ThisExpression: function ThisExpression(node) {
				if (isBeforeCallOfSuper()) {
					setInvalid(node);
				}
			},
			Super: function Super(node) {
				if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {
					setInvalid(node);
				}
			},
			"CallExpression:exit": function CallExpressionExit(node) {
				if (node.callee.type === "Super" && isBeforeCallOfSuper()) {
					setSuperCalled();
				}
			},
			"Program:exit": function ProgramExit() {
				segInfoMap = Object.create(null);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow throwing literals as exceptions",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			ThrowStatement: function ThrowStatement(node) {
				if (!astUtils.couldBeError(node.argument)) {
					context.report({ node: node, message: "Expected an object to be thrown." });
				} else if (node.argument.type === "Identifier") {
					if (node.argument.name === "undefined") {
						context.report({ node: node, message: "Do not throw undefined." });
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow trailing whitespace at the end of lines",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				skipBlankLines: {
					type: "boolean"
				},
				ignoreComments: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		var BLANK_CLASS = "[ \t\xA0\u2000-\u200B\u3000]",
			SKIP_BLANK = "^" + BLANK_CLASS + "*$",
			NONBLANK = BLANK_CLASS + "+$";

		var options = context.options[0] || {},
			skipBlankLines = options.skipBlankLines || false,
			ignoreComments = typeof options.ignoreComments === "boolean" && options.ignoreComments;
		function report(node, location, fixRange) {
			context.report({
				node: node,
				loc: location,
				message: "Trailing spaces not allowed.",
				fix: function fix(fixer) {
					return fixer.removeRange(fixRange);
				}
			});
		}
		function getCommentLineNumbers(comments) {
			var lines = new Set();

			comments.forEach(function (comment) {
				for (var i = comment.loc.start.line; i <= comment.loc.end.line; i++) {
					lines.add(i);
				}
			});

			return lines;
		}
		return {

			Program: function checkTrailingSpaces(node) {

				var re = new RegExp(NONBLANK),
					skipMatch = new RegExp(SKIP_BLANK),
					lines = sourceCode.lines,
					linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),
					comments = sourceCode.getAllComments(),
					commentLineNumbers = getCommentLineNumbers(comments);

				var totalLength = 0,
					fixRange = [];

				for (var i = 0, ii = lines.length; i < ii; i++) {
					var matches = re.exec(lines[i]);
					var linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;
					var lineLength = lines[i].length + linebreakLength;

					if (matches) {
						var location = {
							line: i + 1,
							column: matches.index
						};

						var rangeStart = totalLength + location.column;
						var rangeEnd = totalLength + lineLength - linebreakLength;
						var containingNode = sourceCode.getNodeByRangeIndex(rangeStart);

						if (containingNode && containingNode.type === "TemplateElement" && rangeStart > containingNode.parent.range[0] && rangeEnd < containingNode.parent.range[1]) {
							totalLength += lineLength;
							continue;
						}
						if (skipBlankLines && skipMatch.test(lines[i])) {
							totalLength += lineLength;
							continue;
						}

						fixRange = [rangeStart, rangeEnd];

						if (!ignoreComments || !commentLineNumbers.has(location.line)) {
							report(node, location, fixRange);
						}
					}

					totalLength += lineLength;
				}
			}

		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow initializing variables to `undefined`",
			category: "Variables",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode();

		return {
			VariableDeclarator: function VariableDeclarator(node) {
				var name = sourceCode.getText(node.id),
					init = node.init && node.init.name,
					scope = context.getScope(),
					undefinedVar = astUtils.getVariableByName(scope, "undefined"),
					shadowed = undefinedVar && undefinedVar.defs.length > 0;

				if (init === "undefined" && node.parent.kind !== "const" && !shadowed) {
					context.report({
						node: node,
						message: "It's not necessary to initialize '{{name}}' to undefined.",
						data: { name: name },
						fix: function fix(fixer) {
							if (node.parent.kind === "var") {
								return null;
							}

							if (node.id.type === "ArrayPattern" || node.id.type === "ObjectPattern") {
								return null;
							}
							return fixer.removeRange([node.id.range[1], node.range[1]]);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function hasTypeOfOperator(node) {
	var parent = node.parent;

	return parent.type === "UnaryExpression" && parent.operator === "typeof";
}
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of undeclared variables unless mentioned in `/*global */` comments",
			category: "Variables",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				typeof: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0];
		var considerTypeOf = options && options.typeof === true || false;

		return {
			"Program:exit": function ProgramExit() /* node */{
				var globalScope = context.getScope();

				globalScope.through.forEach(function (ref) {
					var identifier = ref.identifier;

					if (!considerTypeOf && hasTypeOfOperator(identifier)) {
						return;
					}

					context.report({
						node: identifier,
						message: "'{{name}}' is not defined.",
						data: identifier
					});
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `undefined` as an identifier",
			category: "Variables",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function report(node) {
			context.report({
				node: node,
				message: "Unexpected use of undefined."
			});
		}
		function checkScope(scope) {
			var undefinedVar = scope.set.get("undefined");

			if (!undefinedVar) {
				return;
			}

			var references = undefinedVar.references;

			var defs = undefinedVar.defs;
			references.filter(function (ref) {
				return !ref.init;
			}).forEach(function (ref) {
				return report(ref.identifier);
			});

			defs.forEach(function (def) {
				return report(def.name);
			});
		}

		return {
			"Program:exit": function ProgramExit() {
				var globalScope = context.getScope();

				var stack = [globalScope];

				while (stack.length) {
					var scope = stack.pop();

					stack.push.apply(stack, scope.childScopes);
					checkScope(scope);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow dangling underscores in identifiers",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allow: {
					type: "array",
					items: {
						type: "string"
					}
				},
				allowAfterThis: {
					type: "boolean"
				},
				allowAfterSuper: {
					type: "boolean"
				},
				enforceInMethodNames: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = context.options[0] || {};
		var ALLOWED_VARIABLES = options.allow ? options.allow : [];
		var allowAfterThis = typeof options.allowAfterThis !== "undefined" ? options.allowAfterThis : false;
		var allowAfterSuper = typeof options.allowAfterSuper !== "undefined" ? options.allowAfterSuper : false;
		var enforceInMethodNames = typeof options.enforceInMethodNames !== "undefined" ? options.enforceInMethodNames : false;
		function isAllowed(identifier) {
			return ALLOWED_VARIABLES.some(function (ident) {
				return ident === identifier;
			});
		}
		function hasTrailingUnderscore(identifier) {
			var len = identifier.length;

			return identifier !== "_" && (identifier[0] === "_" || identifier[len - 1] === "_");
		}
		function isSpecialCaseIdentifierForMemberExpression(identifier) {
			return identifier === "__proto__";
		}
		function isSpecialCaseIdentifierInVariableExpression(identifier) {
			return identifier === "_";
		}
		function checkForTrailingUnderscoreInFunctionDeclaration(node) {
			if (node.id) {
				var identifier = node.id.name;

				if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !isAllowed(identifier)) {
					context.report({
						node: node,
						message: "Unexpected dangling '_' in '{{identifier}}'.",
						data: {
							identifier: identifier
						}
					});
				}
			}
		}
		function checkForTrailingUnderscoreInVariableExpression(node) {
			var identifier = node.id.name;

			if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {
				context.report({
					node: node,
					message: "Unexpected dangling '_' in '{{identifier}}'.",
					data: {
						identifier: identifier
					}
				});
			}
		}
		function checkForTrailingUnderscoreInMemberExpression(node) {
			var identifier = node.property.name,
				isMemberOfThis = node.object.type === "ThisExpression",
				isMemberOfSuper = node.object.type === "Super";

			if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !(isMemberOfThis && allowAfterThis) && !(isMemberOfSuper && allowAfterSuper) && !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {
				context.report({
					node: node,
					message: "Unexpected dangling '_' in '{{identifier}}'.",
					data: {
						identifier: identifier
					}
				});
			}
		}
		function checkForTrailingUnderscoreInMethod(node) {
			var identifier = node.key.name;
			var isMethod = node.type === "MethodDefinition" || node.type === "Property" && node.method;

			if (typeof identifier !== "undefined" && enforceInMethodNames && isMethod && hasTrailingUnderscore(identifier)) {
				context.report({
					node: node,
					message: "Unexpected dangling '_' in '{{identifier}}'.",
					data: {
						identifier: identifier
					}
				});
			}
		}
		return {
			FunctionDeclaration: checkForTrailingUnderscoreInFunctionDeclaration,
			VariableDeclarator: checkForTrailingUnderscoreInVariableExpression,
			MemberExpression: checkForTrailingUnderscoreInMemberExpression,
			MethodDefinition: checkForTrailingUnderscoreInMethod,
			Property: checkForTrailingUnderscoreInMethod
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow confusing multiline expressions",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {

		var FUNCTION_MESSAGE = "Unexpected newline between function and ( of function call.";
		var PROPERTY_MESSAGE = "Unexpected newline between object and [ of property access.";
		var TAGGED_TEMPLATE_MESSAGE = "Unexpected newline between template tag and template literal.";
		var DIVISION_MESSAGE = "Unexpected newline between numerator and division operator.";

		var REGEX_FLAG_MATCHER = /^[gimuy]+$/;

		var sourceCode = context.getSourceCode();
		function checkForBreakAfter(node, msg) {
			var openParen = sourceCode.getTokenAfter(node, astUtils.isNotClosingParenToken);
			var nodeExpressionEnd = sourceCode.getTokenBefore(openParen);

			if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {
				context.report({ node: node, loc: openParen.loc.start, message: msg, data: { char: openParen.value } });
			}
		}
		return {
			MemberExpression: function MemberExpression(node) {
				if (!node.computed) {
					return;
				}
				checkForBreakAfter(node.object, PROPERTY_MESSAGE);
			},
			TaggedTemplateExpression: function TaggedTemplateExpression(node) {
				if (node.tag.loc.end.line === node.quasi.loc.start.line) {
					return;
				}
				context.report({ node: node, loc: node.loc.start, message: TAGGED_TEMPLATE_MESSAGE });
			},
			CallExpression: function CallExpression(node) {
				if (node.arguments.length === 0) {
					return;
				}
				checkForBreakAfter(node.callee, FUNCTION_MESSAGE);
			},
			"BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left": function BinaryExpressionOperatorBinaryExpressionOperatorLeft(node) {
				var secondSlash = sourceCode.getTokenAfter(node, function (token) {
					return token.value === "/";
				});
				var tokenAfterOperator = sourceCode.getTokenAfter(secondSlash);

				if (tokenAfterOperator.type === "Identifier" && REGEX_FLAG_MATCHER.test(tokenAfterOperator.value) && secondSlash.range[1] === tokenAfterOperator.range[0]) {
					checkForBreakAfter(node.left, DIVISION_MESSAGE);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var Traverser = __webpack_require__(106),
	astUtils = __webpack_require__(0);
var pushAll = Function.apply.bind(Array.prototype.push);
var SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/;
var LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/; // for-in/of statements don't have `test` property.
var GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/;
var SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/;
var DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/;
function isWriteReference(reference) {
	if (reference.init) {
		var def = reference.resolved && reference.resolved.defs[0];

		if (!def || def.type !== "Variable" || def.parent.kind !== "var") {
			return false;
		}
	}
	return reference.isWrite();
}
function isUnmodified(condition) {
	return !condition.modified;
}
function isUnmodifiedAndNotBelongToGroup(condition) {
	return !(condition.modified || condition.group);
}
function isInRange(node, reference) {
	var or = node.range;
	var ir = reference.identifier.range;

	return or[0] <= ir[0] && ir[1] <= or[1];
}
var isInLoop = {
	WhileStatement: isInRange,
	DoWhileStatement: isInRange,
	ForStatement: function ForStatement(node, reference) {
		return isInRange(node, reference) && !(node.init && isInRange(node.init, reference));
	}
};
function hasDynamicExpressions(root) {
	var retv = false;
	var traverser = new Traverser();

	traverser.traverse(root, {
		enter: function enter(node) {
			if (DYNAMIC_PATTERN.test(node.type)) {
				retv = true;
				this.break();
			} else if (SKIP_PATTERN.test(node.type)) {
				this.skip();
			}
		}
	});

	return retv;
}
function toLoopCondition(reference) {
	if (reference.init) {
		return null;
	}

	var group = null;
	var child = reference.identifier;
	var node = child.parent;

	while (node) {
		if (SENTINEL_PATTERN.test(node.type)) {
			if (LOOP_PATTERN.test(node.type) && node.test === child) {
				return {
					reference: reference,
					group: group,
					isInLoop: isInLoop[node.type].bind(null, node),
					modified: false
				};
			}
			break;
		}
		if (GROUP_PATTERN.test(node.type)) {
			if (hasDynamicExpressions(node)) {
				break;
			} else {
				group = node;
			}
		}

		child = node;
		node = node.parent;
	}

	return null;
}
function getEncloseFunctionDeclaration(reference) {
	var node = reference.identifier;

	while (node) {
		if (node.type === "FunctionDeclaration") {
			return node.id ? node : null;
		}

		node = node.parent;
	}

	return null;
}
function updateModifiedFlag(conditions, modifiers) {

	for (var i = 0; i < conditions.length; ++i) {
		var condition = conditions[i];

		for (var j = 0; !condition.modified && j < modifiers.length; ++j) {
			var modifier = modifiers[j];
			var funcNode = void 0,
				funcVar = void 0;
			var inLoop = condition.isInLoop(modifier) || Boolean((funcNode = getEncloseFunctionDeclaration(modifier)) && (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) && funcVar.references.some(condition.isInLoop));

			condition.modified = inLoop;
		}
	}
}
module.exports = {
	meta: {
		docs: {
			description: "disallow unmodified loop conditions",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var groupMap = null;
		function report(condition) {
			var node = condition.reference.identifier;

			context.report({
				node: node,
				message: "'{{name}}' is not modified in this loop.",
				data: node
			});
		}
		function registerConditionsToGroup(conditions) {
			for (var i = 0; i < conditions.length; ++i) {
				var condition = conditions[i];

				if (condition.group) {
					var group = groupMap.get(condition.group);

					if (!group) {
						group = [];
						groupMap.set(condition.group, group);
					}
					group.push(condition);
				}
			}
		}
		function checkConditionsInGroup(conditions) {
			if (conditions.every(isUnmodified)) {
				conditions.forEach(report);
			}
		}
		function checkReferences(variable) {
			var conditions = variable.references.map(toLoopCondition).filter(Boolean);

			if (conditions.length === 0) {
				return;
			}
			registerConditionsToGroup(conditions);
			var modifiers = variable.references.filter(isWriteReference);

			if (modifiers.length > 0) {
				updateModifiedFlag(conditions, modifiers);
			}
			conditions.filter(isUnmodifiedAndNotBelongToGroup).forEach(report);
		}

		return {
			"Program:exit": function ProgramExit() {
				var queue = [context.getScope()];

				groupMap = new Map();

				var scope = void 0;

				while (scope = queue.pop()) {
					pushAll(queue, scope.childScopes);
					scope.variables.forEach(checkReferences);
				}

				groupMap.forEach(checkConditionsInGroup);
				groupMap = null;
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
var BOOLEAN_OPERATORS = new Set(["==", "===", "!=", "!==", ">", ">=", "<", "<=", "in", "instanceof"]);
var OPERATOR_INVERSES = {
	"==": "!=",
	"!=": "==",
	"===": "!==",
	"!==": "==="
};
module.exports = {
	meta: {
		docs: {
			description: "disallow ternary operators when simpler alternatives exist",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				defaultAssignment: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var defaultAssignment = options.defaultAssignment !== false;
		var sourceCode = context.getSourceCode();
		function isBooleanLiteral(node) {
			return node.type === "Literal" && typeof node.value === "boolean";
		}
		function invertExpression(node) {
			if (node.type === "BinaryExpression" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {
				var operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, function (token) {
					return token.value === node.operator;
				});
				var text = sourceCode.getText();

				return text.slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);
			}

			if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: "UnaryExpression" })) {
				return "!(" + astUtils.getParenthesisedText(sourceCode, node) + ")";
			}
			return "!" + astUtils.getParenthesisedText(sourceCode, node);
		}
		function isBooleanExpression(node) {
			return node.type === "BinaryExpression" && BOOLEAN_OPERATORS.has(node.operator) || node.type === "UnaryExpression" && node.operator === "!";
		}
		function matchesDefaultAssignment(node) {
			return node.test.type === "Identifier" && node.consequent.type === "Identifier" && node.test.name === node.consequent.name;
		}

		return {
			ConditionalExpression: function ConditionalExpression(node) {
				if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {
					context.report({
						node: node,
						loc: node.consequent.loc.start,
						message: "Unnecessary use of boolean literals in conditional expression.",
						fix: function fix(fixer) {
							if (node.consequent.value === node.alternate.value) {
								return node.test.type === "Identifier" ? fixer.replaceText(node, node.consequent.value.toString()) : null;
							}
							if (node.alternate.value) {
								return fixer.replaceText(node, invertExpression(node.test));
							}
							return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : "!" + invertExpression(node.test));
						}
					});
				} else if (!defaultAssignment && matchesDefaultAssignment(node)) {
					context.report({
						node: node,
						loc: node.consequent.loc.start,
						message: "Unnecessary use of conditional expression for default assignment.",
						fix: function fix(fixer) {
							var nodeAlternate = astUtils.getParenthesisedText(sourceCode, node.alternate);

							if (node.alternate.type === "ConditionalExpression") {
								var isAlternateParenthesised = astUtils.isParenthesised(sourceCode, node.alternate);

								nodeAlternate = isAlternateParenthesised ? nodeAlternate : "(" + nodeAlternate + ")";
							}

							return fixer.replaceText(node, astUtils.getParenthesisedText(sourceCode, node.test) + " || " + nodeAlternate);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function isInitialized(node) {
	return Boolean(node.init);
}
function isUnreachable(segment) {
	return !segment.reachable;
}

var ConsecutiveRange = function () {
	function ConsecutiveRange(sourceCode) {
		_classCallCheck(this, ConsecutiveRange);

		this.sourceCode = sourceCode;
		this.startNode = null;
		this.endNode = null;
	}


	_createClass(ConsecutiveRange, [{
		key: "contains",
		value: function contains(node) {
			return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];
		}

	}, {
		key: "isConsecutive",
		value: function isConsecutive(node) {
			return this.contains(this.sourceCode.getTokenBefore(node));
		}

	}, {
		key: "merge",
		value: function merge(node) {
			this.endNode = node;
		}

	}, {
		key: "reset",
		value: function reset(node) {
			this.startNode = this.endNode = node;
		}
	}, {
		key: "location",
		get: function get() {
			return {
				start: this.startNode.loc.start,
				end: this.endNode.loc.end
			};
		}

	}, {
		key: "isEmpty",
		get: function get() {
			return !(this.startNode && this.endNode);
		}
	}]);

	return ConsecutiveRange;
}();
module.exports = {
	meta: {
		docs: {
			description: "disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var currentCodePath = null;

		var range = new ConsecutiveRange(context.getSourceCode());
		function reportIfUnreachable(node) {
			var nextNode = null;

			if (node && currentCodePath.currentSegments.every(isUnreachable)) {
				if (range.isEmpty) {
					range.reset(node);
					return;
				}
				if (range.contains(node)) {
					return;
				}
				if (range.isConsecutive(node)) {
					range.merge(node);
					return;
				}

				nextNode = node;
			}
			if (!range.isEmpty) {
				context.report({
					message: "Unreachable code.",
					loc: range.location,
					node: range.startNode
				});
			}
			range.reset(nextNode);
		}

		return {
			onCodePathStart: function onCodePathStart(codePath) {
				currentCodePath = codePath;
			},
			onCodePathEnd: function onCodePathEnd() {
				currentCodePath = currentCodePath.upper;
			},
			BlockStatement: reportIfUnreachable,
			BreakStatement: reportIfUnreachable,
			ClassDeclaration: reportIfUnreachable,
			ContinueStatement: reportIfUnreachable,
			DebuggerStatement: reportIfUnreachable,
			DoWhileStatement: reportIfUnreachable,
			EmptyStatement: reportIfUnreachable,
			ExpressionStatement: reportIfUnreachable,
			ForInStatement: reportIfUnreachable,
			ForOfStatement: reportIfUnreachable,
			ForStatement: reportIfUnreachable,
			IfStatement: reportIfUnreachable,
			ImportDeclaration: reportIfUnreachable,
			LabeledStatement: reportIfUnreachable,
			ReturnStatement: reportIfUnreachable,
			SwitchStatement: reportIfUnreachable,
			ThrowStatement: reportIfUnreachable,
			TryStatement: reportIfUnreachable,

			VariableDeclaration: function VariableDeclaration(node) {
				if (node.kind !== "var" || node.declarations.some(isInitialized)) {
					reportIfUnreachable(node);
				}
			},


			WhileStatement: reportIfUnreachable,
			WithStatement: reportIfUnreachable,
			ExportNamedDeclaration: reportIfUnreachable,
			ExportDefaultDeclaration: reportIfUnreachable,
			ExportAllDeclaration: reportIfUnreachable,

			"Program:exit": function ProgramExit() {
				reportIfUnreachable();
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/;
var SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/;
var SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/;
module.exports = {
	meta: {
		docs: {
			description: "disallow control flow statements in `finally` blocks",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},
	create: function create(context) {
		function isFinallyBlock(node) {
			return node.parent.type === "TryStatement" && node.parent.finalizer === node;
		}
		function isInFinallyBlock(node, label) {
			var labelInside = false;
			var sentinelNodeType = void 0;

			if (node.type === "BreakStatement" && !node.label) {
				sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;
			} else if (node.type === "ContinueStatement") {
				sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;
			} else {
				sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;
			}

			while (node && !sentinelNodeType.test(node.type)) {
				if (node.parent.label && label && node.parent.label.name === label.name) {
					labelInside = true;
				}
				if (isFinallyBlock(node)) {
					if (label && labelInside) {
						return false;
					}
					return true;
				}
				node = node.parent;
			}
			return false;
		}
		function check(node) {
			if (isInFinallyBlock(node, node.label)) {
				context.report({
					message: "Unsafe usage of {{nodeType}}.",
					data: {
						nodeType: node.type
					},
					node: node,
					line: node.loc.line,
					column: node.loc.column
				});
			}
		}

		return {
			ReturnStatement: check,
			ThrowStatement: check,
			BreakStatement: check,
			ContinueStatement: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isRelationalOperator(op) {
	return op === "in" || op === "instanceof";
}
function isNegation(node) {
	return node.type === "UnaryExpression" && node.operator === "!";
}
module.exports = {
	meta: {
		docs: {
			description: "disallow negating the left operand of relational operators",
			category: "Possible Errors",
			recommended: true
		},
		schema: [],
		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			BinaryExpression: function BinaryExpression(node) {
				if (isRelationalOperator(node.operator) && isNegation(node.left) && !astUtils.isParenthesised(sourceCode, node.left)) {
					context.report({
						node: node,
						loc: node.left.loc,
						message: "Unexpected negating the left operand of '{{operator}}' operator.",
						data: node,

						fix: function fix(fixer) {
							var negationToken = sourceCode.getFirstToken(node.left);
							var fixRange = [negationToken.range[1], node.range[1]];
							var text = sourceCode.text.slice(fixRange[0], fixRange[1]);

							return fixer.replaceTextRange(fixRange, "(" + text + ")");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow unused expressions",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowShortCircuit: {
					type: "boolean"
				},
				allowTernary: {
					type: "boolean"
				},
				allowTaggedTemplates: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var config = context.options[0] || {},
			allowShortCircuit = config.allowShortCircuit || false,
			allowTernary = config.allowTernary || false,
			allowTaggedTemplates = config.allowTaggedTemplates || false;
		function looksLikeDirective(node) {
			return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
		}
		function takeWhile(predicate, list) {
			for (var i = 0; i < list.length; ++i) {
				if (!predicate(list[i])) {
					return list.slice(0, i);
				}
			}
			return list.slice();
		}
		function directives(node) {
			return takeWhile(looksLikeDirective, node.body);
		}
		function isDirective(node, ancestors) {
			var parent = ancestors[ancestors.length - 1],
				grandparent = ancestors[ancestors.length - 2];

			return (parent.type === "Program" || parent.type === "BlockStatement" && /Function/.test(grandparent.type)) && directives(parent).indexOf(node) >= 0;
		}
		function isValidExpression(node) {
			if (allowTernary) {
				if (node.type === "ConditionalExpression") {
					return isValidExpression(node.consequent) && isValidExpression(node.alternate);
				}
			}

			if (allowShortCircuit) {
				if (node.type === "LogicalExpression") {
					return isValidExpression(node.right);
				}
			}

			if (allowTaggedTemplates && node.type === "TaggedTemplateExpression") {
				return true;
			}

			return (/^(?:Assignment|Call|New|Update|Yield|Await)Expression$/.test(node.type) || node.type === "UnaryExpression" && ["delete", "void"].indexOf(node.operator) >= 0
			);
		}

		return {
			ExpressionStatement: function ExpressionStatement(node) {
				if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {
					context.report({ node: node, message: "Expected an assignment or function call and instead saw an expression." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow unused labels",
			category: "Best Practices",
			recommended: true
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var scopeInfo = null;
		function enterLabeledScope(node) {
			scopeInfo = {
				label: node.label.name,
				used: false,
				upper: scopeInfo
			};
		}
		function exitLabeledScope(node) {
			if (!scopeInfo.used) {
				context.report({
					node: node.label,
					message: "'{{name}}:' is defined but never used.",
					data: node.label,
					fix: function fix(fixer) {
						if (sourceCode.getTokenAfter(node.label, { includeComments: true }) === sourceCode.getTokenBefore(node.body, { includeComments: true })) {
							return fixer.removeRange([node.range[0], node.body.range[0]]);
						}

						return null;
					}
				});
			}

			scopeInfo = scopeInfo.upper;
		}
		function markAsUsed(node) {
			if (!node.label) {
				return;
			}

			var label = node.label.name;
			var info = scopeInfo;

			while (info) {
				if (info.label === label) {
					info.used = true;
					break;
				}
				info = info.upper;
			}
		}

		return {
			LabeledStatement: enterLabeledScope,
			"LabeledStatement:exit": exitLabeledScope,
			BreakStatement: markAsUsed,
			ContinueStatement: markAsUsed
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10);
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow unused variables",
			category: "Variables",
			recommended: true
		},

		schema: [{
			oneOf: [{
				enum: ["all", "local"]
			}, {
				type: "object",
				properties: {
					vars: {
						enum: ["all", "local"]
					},
					varsIgnorePattern: {
						type: "string"
					},
					args: {
						enum: ["all", "after-used", "none"]
					},
					ignoreRestSiblings: {
						type: "boolean"
					},
					argsIgnorePattern: {
						type: "string"
					},
					caughtErrors: {
						enum: ["all", "none"]
					},
					caughtErrorsIgnorePattern: {
						type: "string"
					}
				}
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		var REST_PROPERTY_TYPE = /^(?:Experimental)?RestProperty$/;

		var config = {
			vars: "all",
			args: "after-used",
			ignoreRestSiblings: false,
			caughtErrors: "none"
		};

		var firstOption = context.options[0];

		if (firstOption) {
			if (typeof firstOption === "string") {
				config.vars = firstOption;
			} else {
				config.vars = firstOption.vars || config.vars;
				config.args = firstOption.args || config.args;
				config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;
				config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;

				if (firstOption.varsIgnorePattern) {
					config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern);
				}

				if (firstOption.argsIgnorePattern) {
					config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern);
				}

				if (firstOption.caughtErrorsIgnorePattern) {
					config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern);
				}
			}
		}
		function getDefinedMessage(unusedVar) {
			var type = void 0;
			var pattern = void 0;

			if (config.varsIgnorePattern) {
				type = "vars";
				pattern = config.varsIgnorePattern.toString();
			}

			if (unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type) {
				var defType = unusedVar.defs[0].type;

				if (defType === "CatchClause" && config.caughtErrorsIgnorePattern) {
					type = "args";
					pattern = config.caughtErrorsIgnorePattern.toString();
				} else if (defType === "Parameter" && config.argsIgnorePattern) {
					type = "args";
					pattern = config.argsIgnorePattern.toString();
				}
			}

			var additional = type ? " Allowed unused " + type + " must match " + pattern + "." : "";

			return "'{{name}}' is defined but never used." + additional;
		}
		function getAssignedMessage() {
			var additional = config.varsIgnorePattern ? " Allowed unused vars must match " + config.varsIgnorePattern.toString() + "." : "";

			return "'{{name}}' is assigned a value but never used." + additional;
		}
		var STATEMENT_TYPE = /(?:Statement|Declaration)$/;
		function isExported(variable) {

			var definition = variable.defs[0];

			if (definition) {

				var node = definition.node;

				if (node.type === "VariableDeclarator") {
					node = node.parent;
				} else if (definition.type === "Parameter") {
					return false;
				}

				return node.parent.type.indexOf("Export") === 0;
			}
			return false;
		}
		function hasRestSpreadSibling(variable) {
			if (config.ignoreRestSiblings) {
				return variable.defs.some(function (def) {
					var propertyNode = def.name.parent;
					var patternNode = propertyNode.parent;

					return propertyNode.type === "Property" && patternNode.type === "ObjectPattern" && REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type);
				});
			}

			return false;
		}
		function isReadRef(ref) {
			return ref.isRead();
		}
		function isSelfReference(ref, nodes) {
			var scope = ref.from;

			while (scope) {
				if (nodes.indexOf(scope.block) >= 0) {
					return true;
				}

				scope = scope.upper;
			}

			return false;
		}
		function isInside(inner, outer) {
			return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];
		}
		function getRhsNode(ref, prevRhsNode) {
			var id = ref.identifier;
			var parent = id.parent;
			var granpa = parent.parent;
			var refScope = ref.from.variableScope;
			var varScope = ref.resolved.scope.variableScope;
			var canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);
			if (prevRhsNode && isInside(id, prevRhsNode)) {
				return prevRhsNode;
			}

			if (parent.type === "AssignmentExpression" && granpa.type === "ExpressionStatement" && id === parent.left && !canBeUsedLater) {
				return parent.right;
			}
			return null;
		}
		function isStorableFunction(funcNode, rhsNode) {
			var node = funcNode;
			var parent = funcNode.parent;

			while (parent && isInside(parent, rhsNode)) {
				switch (parent.type) {
					case "SequenceExpression":
						if (parent.expressions[parent.expressions.length - 1] !== node) {
							return false;
						}
						break;

					case "CallExpression":
					case "NewExpression":
						return parent.callee !== node;

					case "AssignmentExpression":
					case "TaggedTemplateExpression":
					case "YieldExpression":
						return true;

					default:
						if (STATEMENT_TYPE.test(parent.type)) {
							return true;
						}
				}

				node = parent;
				parent = parent.parent;
			}

			return false;
		}
		function isInsideOfStorableFunction(id, rhsNode) {
			var funcNode = astUtils.getUpperFunction(id);

			return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);
		}
		function isReadForItself(ref, rhsNode) {
			var id = ref.identifier;
			var parent = id.parent;
			var granpa = parent.parent;

			return ref.isRead() && (
			parent.type === "AssignmentExpression" && granpa.type === "ExpressionStatement" && parent.left === id || parent.type === "UpdateExpression" && granpa.type === "ExpressionStatement" ||
			rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));
		}
		function isForInRef(ref) {
			var target = ref.identifier.parent;
			if (target.type === "VariableDeclarator") {
				target = target.parent.parent;
			}

			if (target.type !== "ForInStatement") {
				return false;
			}
			if (target.body.type === "BlockStatement") {
				target = target.body.body[0];
			} else {
				target = target.body;
			}
			if (!target) {
				return false;
			}

			return target.type === "ReturnStatement";
		}
		function isUsedVariable(variable) {
			var functionNodes = variable.defs.filter(function (def) {
				return def.type === "FunctionName";
			}).map(function (def) {
				return def.node;
			}),
				isFunctionDefinition = functionNodes.length > 0;
			var rhsNode = null;

			return variable.references.some(function (ref) {
				if (isForInRef(ref)) {
					return true;
				}

				var forItself = isReadForItself(ref, rhsNode);

				rhsNode = getRhsNode(ref, rhsNode);

				return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));
			});
		}
		function isLastInNonIgnoredParameters(variable) {
			var def = variable.defs[0];
			if (def.index === def.node.params.length - 1) {
				return true;
			}
			if (config.argsIgnorePattern) {
				var params = context.getDeclaredVariables(def.node);
				var posteriorParams = params.slice(params.indexOf(variable) + 1);

				if (posteriorParams.every(function (v) {
					return v.references.length === 0 && config.argsIgnorePattern.test(v.name);
				})) {
					return true;
				}
			}

			return false;
		}
		function collectUnusedVariables(scope, unusedVars) {
			var variables = scope.variables;
			var childScopes = scope.childScopes;
			var i = void 0,
				l = void 0;

			if (scope.type !== "TDZ" && (scope.type !== "global" || config.vars === "all")) {
				for (i = 0, l = variables.length; i < l; ++i) {
					var variable = variables[i];
					if (scope.type === "class" && scope.block.id === variable.identifiers[0]) {
						continue;
					}
					if (scope.functionExpressionScope || variable.eslintUsed) {
						continue;
					}
					if (scope.type === "function" && variable.name === "arguments" && variable.identifiers.length === 0) {
						continue;
					}
					var def = variable.defs[0];

					if (def) {
						var type = def.type;
						if (type === "CatchClause") {
							if (config.caughtErrors === "none") {
								continue;
							}
							if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {
								continue;
							}
						}

						if (type === "Parameter") {
							if ((def.node.parent.type === "Property" || def.node.parent.type === "MethodDefinition") && def.node.parent.kind === "set") {
								continue;
							}
							if (config.args === "none") {
								continue;
							}
							if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {
								continue;
							}
							if (config.args === "after-used" && astUtils.isFunction(def.name.parent) && !isLastInNonIgnoredParameters(variable)) {
								continue;
							}
						} else {
							if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {
								continue;
							}
						}
					}

					if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {
						unusedVars.push(variable);
					}
				}
			}

			for (i = 0, l = childScopes.length; i < l; ++i) {
				collectUnusedVariables(childScopes[i], unusedVars);
			}

			return unusedVars;
		}
		function getColumnInComment(variable, comment) {
			var namePattern = new RegExp("[\\s,]" + lodash.escapeRegExp(variable.name) + "(?:$|[\\s,:])", "g");
			namePattern.lastIndex = comment.value.indexOf("global") + 6;
			var match = namePattern.exec(comment.value);

			return match ? match.index + 1 : 0;
		}
		function getLocation(variable) {
			var comment = variable.eslintExplicitGlobalComment;

			return sourceCode.getLocFromIndex(comment.range[0] + 2 + getColumnInComment(variable, comment));
		}
		return {
			"Program:exit": function ProgramExit(programNode) {
				var unusedVars = collectUnusedVariables(context.getScope(), []);

				for (var i = 0, l = unusedVars.length; i < l; ++i) {
					var unusedVar = unusedVars[i];

					if (unusedVar.eslintExplicitGlobal) {
						context.report({
							node: programNode,
							loc: getLocation(unusedVar),
							message: getDefinedMessage(unusedVar),
							data: unusedVar
						});
					} else if (unusedVar.defs.length > 0) {
						context.report({
							node: unusedVar.identifiers[0],
							message: unusedVar.references.some(function (ref) {
								return ref.isWrite();
							}) ? getAssignedMessage() : getDefinedMessage(unusedVar),
							data: unusedVar
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;
var FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/;
function parseOptions(options) {
	var functions = true;
	var classes = true;
	var variables = true;

	if (typeof options === "string") {
		functions = options !== "nofunc";
	} else if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object" && options !== null) {
		functions = options.functions !== false;
		classes = options.classes !== false;
		variables = options.variables !== false;
	}

	return { functions: functions, classes: classes, variables: variables };
}
function isFunction(variable) {
	return variable.defs[0].type === "FunctionName";
}
function isOuterClass(variable, reference) {
	return variable.defs[0].type === "ClassName" && variable.scope.variableScope !== reference.from.variableScope;
}
function isOuterVariable(variable, reference) {
	return variable.defs[0].type === "Variable" && variable.scope.variableScope !== reference.from.variableScope;
}
function isInRange(node, location) {
	return node && node.range[0] <= location && location <= node.range[1];
}
function isInInitializer(variable, reference) {
	if (variable.scope !== reference.from) {
		return false;
	}

	var node = variable.identifiers[0].parent;
	var location = reference.identifier.range[1];

	while (node) {
		if (node.type === "VariableDeclarator") {
			if (isInRange(node.init, location)) {
				return true;
			}
			if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {
				return true;
			}
			break;
		} else if (node.type === "AssignmentPattern") {
			if (isInRange(node.right, location)) {
				return true;
			}
		} else if (SENTINEL_TYPE.test(node.type)) {
			break;
		}

		node = node.parent;
	}

	return false;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of variables before they are defined",
			category: "Variables",
			recommended: false
		},

		schema: [{
			oneOf: [{
				enum: ["nofunc"]
			}, {
				type: "object",
				properties: {
					functions: { type: "boolean" },
					classes: { type: "boolean" },
					variables: { type: "boolean" }
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var options = parseOptions(context.options[0]);
		function isForbidden(variable, reference) {
			if (isFunction(variable)) {
				return options.functions;
			}
			if (isOuterClass(variable, reference)) {
				return options.classes;
			}
			if (isOuterVariable(variable, reference)) {
				return options.variables;
			}
			return true;
		}
		function findVariablesInScope(scope) {
			scope.references.forEach(function (reference) {
				var variable = reference.resolved;
				if (reference.init || !variable || variable.identifiers.length === 0 || variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference) || !isForbidden(variable, reference)) {
					return;
				}
				context.report({
					node: reference.identifier,
					message: "'{{name}}' was used before it was defined.",
					data: reference.identifier
				});
			});
		}
		function findVariables() {
			var scope = context.getScope();

			findVariablesInScope(scope);
		}

		var ruleDefinition = {
			"Program:exit": function ProgramExit(node) {
				var scope = context.getScope(),
					ecmaFeatures = context.parserOptions.ecmaFeatures || {};

				findVariablesInScope(scope);
				if (ecmaFeatures.globalReturn || node.sourceType === "module") {
					findVariablesInScope(scope.childScopes[0]);
				}
			}
		};

		if (context.parserOptions.ecmaVersion >= 6) {
			ruleDefinition["BlockStatement:exit"] = ruleDefinition["SwitchStatement:exit"] = findVariables;

			ruleDefinition["ArrowFunctionExpression:exit"] = function (node) {
				if (node.body.type !== "BlockStatement") {
					findVariables();
				}
			};
		} else {
			ruleDefinition["FunctionExpression:exit"] = ruleDefinition["FunctionDeclaration:exit"] = ruleDefinition["ArrowFunctionExpression:exit"] = findVariables;
		}

		return ruleDefinition;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
function isCallOrNonVariadicApply(node) {
	return node.callee.type === "MemberExpression" && node.callee.property.type === "Identifier" && node.callee.computed === false && (node.callee.property.name === "call" && node.arguments.length >= 1 || node.callee.property.name === "apply" && node.arguments.length === 2 && node.arguments[1].type === "ArrayExpression");
}
function isValidThisArg(expectedThis, thisArg, sourceCode) {
	if (!expectedThis) {
		return astUtils.isNullOrUndefined(thisArg);
	}
	return astUtils.equalTokens(expectedThis, thisArg, sourceCode);
}
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary calls to `.call()` and `.apply()`",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			CallExpression: function CallExpression(node) {
				if (!isCallOrNonVariadicApply(node)) {
					return;
				}

				var applied = node.callee.object;
				var expectedThis = applied.type === "MemberExpression" ? applied.object : null;
				var thisArg = node.arguments[0];

				if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
					context.report({ node: node, message: "unnecessary '.{{name}}()'.", data: { name: node.callee.property.name } });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
var MESSAGE_UNNECESSARY_COMPUTED = "Unnecessarily computed property [{{property}}] found.";

module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary computed property keys in object literals",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},
	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			Property: function Property(node) {
				if (!node.computed) {
					return;
				}

				var key = node.key,
					nodeType = _typeof(key.value);

				if (key.type === "Literal" && (nodeType === "string" || nodeType === "number") && key.value !== "__proto__") {
					context.report({
						node: node,
						message: MESSAGE_UNNECESSARY_COMPUTED,
						data: { property: sourceCode.getText(key) },
						fix: function fix(fixer) {
							var leftSquareBracket = sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken);
							var rightSquareBracket = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken);
							var tokensBetween = sourceCode.getTokensBetween(leftSquareBracket, rightSquareBracket, 1);

							if (tokensBetween.slice(0, -1).some(function (token, index) {
								return sourceCode.getText().slice(token.range[1], tokensBetween[index + 1].range[0]).trim();
							})) {
								return null;
							}

							var tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);
							var needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));

							var replacementKey = (needsSpaceBeforeKey ? " " : "") + key.raw;

							return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isConcatenation(node) {
	return node.type === "BinaryExpression" && node.operator === "+";
}
function isConcatOperatorToken(token) {
	return token.value === "+" && token.type === "Punctuator";
}
function getLeft(node) {
	var left = node.left;

	while (isConcatenation(left)) {
		left = left.right;
	}
	return left;
}
function getRight(node) {
	var right = node.right;

	while (isConcatenation(right)) {
		right = right.left;
	}
	return right;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary concatenation of literals or template literals",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			BinaryExpression: function BinaryExpression(node) {
				if (node.operator !== "+") {
					return;
				}
				var left = getLeft(node);
				var right = getRight(node);

				if (astUtils.isStringLiteral(left) && astUtils.isStringLiteral(right) && astUtils.isTokenOnSameLine(left, right)) {
					var operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);

					context.report({
						node: node,
						loc: operatorToken.loc.start,
						message: "Unexpected string concatenation of literals."
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isSingleSuperCall(body) {
	return body.length === 1 && body[0].type === "ExpressionStatement" && body[0].expression.type === "CallExpression" && body[0].expression.callee.type === "Super";
}
function isSimple(node) {
	return node.type === "Identifier" || node.type === "RestElement";
}
function isSpreadArguments(superArgs) {
	return superArgs.length === 1 && superArgs[0].type === "SpreadElement" && superArgs[0].argument.type === "Identifier" && superArgs[0].argument.name === "arguments";
}
function isValidIdentifierPair(ctorParam, superArg) {
	return ctorParam.type === "Identifier" && superArg.type === "Identifier" && ctorParam.name === superArg.name;
}
function isValidRestSpreadPair(ctorParam, superArg) {
	return ctorParam.type === "RestElement" && superArg.type === "SpreadElement" && isValidIdentifierPair(ctorParam.argument, superArg.argument);
}
function isValidPair(ctorParam, superArg) {
	return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);
}
function isPassingThrough(ctorParams, superArgs) {
	if (ctorParams.length !== superArgs.length) {
		return false;
	}

	for (var i = 0; i < ctorParams.length; ++i) {
		if (!isValidPair(ctorParams[i], superArgs[i])) {
			return false;
		}
	}

	return true;
}
function isRedundantSuperCall(body, ctorParams) {
	return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));
}
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary constructors",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function checkForConstructor(node) {
			if (node.kind !== "constructor") {
				return;
			}

			var body = node.value.body.body;
			var ctorParams = node.value.params;
			var superClass = node.parent.parent.superClass;

			if (superClass ? isRedundantSuperCall(body, ctorParams) : body.length === 0) {
				context.report({
					node: node,
					message: "Useless constructor."
				});
			}
		}

		return {
			MethodDefinition: checkForConstructor
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
function union(setA, setB) {
	return new Set( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
		return regeneratorRuntime.wrap(function _callee$(_context) {
			while (1) {
				switch (_context.prev = _context.next) {
					case 0:
						return _context.delegateYield(setA, "t0", 1);

					case 1:
						return _context.delegateYield(setB, "t1", 2);

					case 2:
					case "end":
						return _context.stop();
				}
			}
		}, _callee, this);
	})());
}

var VALID_STRING_ESCAPES = union(new Set("\\nrvtbfux"), astUtils.LINEBREAKS);
var REGEX_GENERAL_ESCAPES = new Set("\\bcdDfnrsStvwWxu0123456789]");
var REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set("^/.$*+?[{}|()B"));
function parseRegExp(regExpText) {
	var charList = [];

	regExpText.split("").reduce(function (state, char, index) {
		if (!state.escapeNextChar) {
			if (char === "\\") {
				return Object.assign(state, { escapeNextChar: true });
			}
			if (char === "[" && !state.inCharClass) {
				return Object.assign(state, { inCharClass: true, startingCharClass: true });
			}
			if (char === "]" && state.inCharClass) {
				if (charList.length && charList[charList.length - 1].inCharClass) {
					charList[charList.length - 1].endsCharClass = true;
				}
				return Object.assign(state, { inCharClass: false, startingCharClass: false });
			}
		}
		charList.push({
			text: char,
			index: index,
			escaped: state.escapeNextChar,
			inCharClass: state.inCharClass,
			startsCharClass: state.startingCharClass,
			endsCharClass: false
		});
		return Object.assign(state, { escapeNextChar: false, startingCharClass: false });
	}, { escapeNextChar: false, inCharClass: false, startingCharClass: false });

	return charList;
}

module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary escape characters",
			category: "Best Practices",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function report(node, startOffset, character) {
			context.report({
				node: node,
				loc: sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(node.loc.start) + startOffset),
				message: "Unnecessary escape character: \\{{character}}.",
				data: { character: character }
			});
		}
		function validateString(node, match) {
			var isTemplateElement = node.type === "TemplateElement";
			var escapedChar = match[0][1];
			var isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
			var isQuoteEscape = void 0;

			if (isTemplateElement) {
				isQuoteEscape = escapedChar === "`";

				if (escapedChar === "$") {
					isUnnecessaryEscape = match.input[match.index + 2] !== "{";
				} else if (escapedChar === "{") {
					isUnnecessaryEscape = match.input[match.index - 1] !== "$";
				}
			} else {
				isQuoteEscape = escapedChar === node.raw[0];
			}

			if (isUnnecessaryEscape && !isQuoteEscape) {
				report(node, match.index + 1, match[0].slice(1));
			}
		}
		function check(node) {
			var isTemplateElement = node.type === "TemplateElement";

			if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === "TaggedTemplateExpression" && node.parent === node.parent.parent.quasi) {
				return;
			}

			if (typeof node.value === "string" || isTemplateElement) {
				if (node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement") {
					return;
				}

				var value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);
				var pattern = /\\[^\d]/g;
				var match = void 0;

				while (match = pattern.exec(value)) {
					validateString(node, match);
				}
			} else if (node.regex) {
				parseRegExp(node.regex.pattern)
				.filter(function (charInfo) {
					return !(charInfo.text === "-" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass);
				})
				.filter(function (charInfo) {
					return !(charInfo.text === "^" && charInfo.startsCharClass);
				})
				.filter(function (charInfo) {
					return charInfo.escaped;
				})
				.filter(function (charInfo) {
					return !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text);
				})
				.forEach(function (charInfo) {
					return report(node, charInfo.index, charInfo.text);
				});
			}
		}

		return {
			Literal: check,
			TemplateElement: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow renaming import, export, and destructured assignments to the same name",
			category: "ECMAScript 6",
			recommended: false
		},
		fixable: "code",
		schema: [{
			type: "object",
			properties: {
				ignoreDestructuring: { type: "boolean" },
				ignoreImport: { type: "boolean" },
				ignoreExport: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {},
			ignoreDestructuring = options.ignoreDestructuring === true,
			ignoreImport = options.ignoreImport === true,
			ignoreExport = options.ignoreExport === true;
		function reportError(node, initial, result, type) {
			var name = initial.type === "Identifier" ? initial.name : initial.value;

			return context.report({
				node: node,
				message: "{{type}} {{name}} unnecessarily renamed.",
				data: {
					name: name,
					type: type
				},
				fix: function fix(fixer) {
					return fixer.replaceTextRange([initial.range[0], result.range[1]], name);
				}
			});
		}
		function checkDestructured(node) {
			if (ignoreDestructuring) {
				return;
			}

			var properties = node.properties;

			for (var i = 0; i < properties.length; i++) {
				if (properties[i].shorthand) {
					continue;
				}
				if (properties[i].computed || !properties[i].key) {
					continue;
				}

				if (properties[i].key.type === "Identifier" && properties[i].key.name === properties[i].value.name || properties[i].key.type === "Literal" && properties[i].key.value === properties[i].value.name) {
					reportError(properties[i], properties[i].key, properties[i].value, "Destructuring assignment");
				}
			}
		}
		function checkImport(node) {
			if (ignoreImport) {
				return;
			}

			if (node.imported.name === node.local.name && node.imported.range[0] !== node.local.range[0]) {
				reportError(node, node.imported, node.local, "Import");
			}
		}
		function checkExport(node) {
			if (ignoreExport) {
				return;
			}

			if (node.local.name === node.exported.name && node.local.range[0] !== node.exported.range[0]) {
				reportError(node, node.local, node.exported, "Export");
			}
		}
		return {
			ObjectPattern: checkDestructured,
			ImportSpecifier: checkImport,
			ExportSpecifier: checkExport
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0),
	FixTracker = __webpack_require__(70);
var pushAll = Function.apply.bind(Array.prototype.push);
function remove(array, element) {
	var index = array.indexOf(element);

	if (index !== -1) {
		array.splice(index, 1);
	}
}
function isRemovable(node) {
	return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
}
function isInFinally(node) {
	while (node && node.parent && !astUtils.isFunction(node)) {
		if (node.parent.type === "TryStatement" && node.parent.finalizer === node) {
			return true;
		}

		node = node.parent;
	}

	return false;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow redundant return statements",
			category: "Best Practices",
			recommended: false
		},
		fixable: "code",
		schema: []
	},

	create: function create(context) {
		var segmentInfoMap = new WeakMap();
		var usedUnreachableSegments = new WeakSet();
		var scopeInfo = null;
		function isReturned(segment) {
			var info = segmentInfoMap.get(segment);

			return !info || info.returned;
		}
		function getUselessReturns(uselessReturns, prevSegments, traversedSegments) {
			if (!traversedSegments) {
				traversedSegments = new WeakSet();
			}
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = prevSegments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var segment = _step.value;

					if (!segment.reachable) {
						if (!traversedSegments.has(segment)) {
							traversedSegments.add(segment);
							getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);
						}
						continue;
					}

					pushAll(uselessReturns, segmentInfoMap.get(segment).uselessReturns);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return uselessReturns;
		}
		function markReturnStatementsOnSegmentAsUsed(segment) {
			if (!segment.reachable) {
				usedUnreachableSegments.add(segment);
				segment.allPrevSegments.filter(isReturned).filter(function (prevSegment) {
					return !usedUnreachableSegments.has(prevSegment);
				}).forEach(markReturnStatementsOnSegmentAsUsed);
				return;
			}

			var info = segmentInfoMap.get(segment);

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = info.uselessReturns[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var node = _step2.value;

					remove(scopeInfo.uselessReturns, node);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			info.uselessReturns = [];
		}
		function markReturnStatementsOnCurrentSegmentsAsUsed() {
			scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);
		}
		return {
			onCodePathStart: function onCodePathStart(codePath) {
				scopeInfo = {
					upper: scopeInfo,
					uselessReturns: [],
					codePath: codePath
				};
			},
			onCodePathEnd: function onCodePathEnd() {
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					var _loop = function _loop() {
						var node = _step3.value;

						context.report({
							node: node,
							loc: node.loc,
							message: "Unnecessary return statement.",
							fix: function fix(fixer) {
								if (isRemovable(node)) {
									return new FixTracker(fixer, context.getSourceCode()).retainEnclosingFunction(node).remove(node);
								}
								return null;
							}
						});
					};

					for (var _iterator3 = scopeInfo.uselessReturns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						_loop();
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}

				scopeInfo = scopeInfo.upper;
			},
			onCodePathSegmentStart: function onCodePathSegmentStart(segment) {
				var info = {
					uselessReturns: getUselessReturns([], segment.allPrevSegments),
					returned: false
				};
				segmentInfoMap.set(segment, info);
			},
			ReturnStatement: function ReturnStatement(node) {
				if (node.argument) {
					markReturnStatementsOnCurrentSegmentsAsUsed();
				}
				if (node.argument || astUtils.isInLoop(node) || isInFinally(node)) {
					return;
				}

				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;

				try {
					for (var _iterator4 = scopeInfo.codePath.currentSegments[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var segment = _step4.value;

						var info = segmentInfoMap.get(segment);

						if (info) {
							info.uselessReturns.push(node);
							info.returned = true;
						}
					}
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4.return) {
							_iterator4.return();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}

				scopeInfo.uselessReturns.push(node);
			},
			ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isGlobal(variable) {
	return Boolean(variable.scope) && variable.scope.type === "global";
}
function getEnclosingFunctionScope(scope) {
	while (scope.type !== "function" && scope.type !== "global") {
		scope = scope.upper;
	}
	return scope;
}
function isReferencedInClosure(variable) {
	var enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);

	return variable.references.some(function (reference) {
		return getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope;
	});
}
function isLoopAssignee(node) {
	return (node.parent.type === "ForOfStatement" || node.parent.type === "ForInStatement") && node === node.parent.left;
}
function isDeclarationInitialized(node) {
	return node.declarations.every(function (declarator) {
		return declarator.init !== null;
	});
}

var SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/;
function getScopeNode(node) {
	while (node) {
		if (SCOPE_NODE_TYPE.test(node.type)) {
			return node;
		}

		node = node.parent;
	}
	return null;
}
function isRedeclared(variable) {
	return variable.defs.length >= 2;
}
function isUsedFromOutsideOf(scopeNode) {
	function isOutsideOfScope(reference) {
		var scope = scopeNode.range;
		var id = reference.identifier.range;

		return id[0] < scope[0] || id[1] > scope[1];
	}

	return function (variable) {
		return variable.references.some(isOutsideOfScope);
	};
}
function hasReferenceInTDZ(node) {
	var initStart = node.range[0];
	var initEnd = node.range[1];

	return function (variable) {
		var id = variable.defs[0].name;
		var idStart = id.range[0];
		var defaultValue = id.parent.type === "AssignmentPattern" ? id.parent.right : null;
		var defaultStart = defaultValue && defaultValue.range[0];
		var defaultEnd = defaultValue && defaultValue.range[1];

		return variable.references.some(function (reference) {
			var start = reference.identifier.range[0];
			var end = reference.identifier.range[1];

			return !reference.init && (start < idStart || defaultValue !== null && start >= defaultStart && end <= defaultEnd || start >= initStart && end <= initEnd);
		});
	};
}
module.exports = {
	meta: {
		docs: {
			description: "require `let` or `const` instead of `var`",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [],
		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function hasSelfReferenceInTDZ(declarator) {
			if (!declarator.init) {
				return false;
			}
			var variables = context.getDeclaredVariables(declarator);

			return variables.some(hasReferenceInTDZ(declarator.init));
		}
		function canFix(node) {
			var variables = context.getDeclaredVariables(node);
			var scopeNode = getScopeNode(node);

			if (node.parent.type === "SwitchCase" || node.declarations.some(hasSelfReferenceInTDZ) || variables.some(isGlobal) || variables.some(isRedeclared) || variables.some(isUsedFromOutsideOf(scopeNode))) {
				return false;
			}

			if (astUtils.isInLoop(node)) {
				if (variables.some(isReferencedInClosure)) {
					return false;
				}
				if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {
					return false;
				}
			}

			if (!isLoopAssignee(node) && !(node.parent.type === "ForStatement" && node.parent.init === node) && !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
				return false;
			}

			return true;
		}
		function report(node) {
			var varToken = sourceCode.getFirstToken(node);

			context.report({
				node: node,
				message: "Unexpected var, use let or const instead.",

				fix: function fix(fixer) {
					if (canFix(node)) {
						return fixer.replaceText(varToken, "let");
					}
					return null;
				}
			});
		}

		return {
			"VariableDeclaration:exit": function VariableDeclarationExit(node) {
				if (node.kind === "var") {
					report(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `void` operators",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		return {
			UnaryExpression: function UnaryExpression(node) {
				if (node.operator === "void") {
					context.report({ node: node, message: "Expected 'undefined' and instead saw 'void'." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow specified warning terms in comments",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				terms: {
					type: "array",
					items: {
						type: "string"
					}
				},
				location: {
					enum: ["start", "anywhere"]
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode(),
			configuration = context.options[0] || {},
			warningTerms = configuration.terms || ["todo", "fixme", "xxx"],
			location = configuration.location || "start",
			selfConfigRegEx = /\bno-warning-comments\b/;
		function convertToRegExp(term) {
			var escaped = term.replace(/[-/\\$^*+?.()|[\]{}]/g, "\\$&");
			var prefix = void 0;
			var suffix = /\w$/.test(term) ? "\\b" : "";

			if (location === "start") {
				prefix = "^\\s*";
			} else if (/^\w/.test(term)) {
				prefix = "\\b";
			} else {
				prefix = "";
			}

			return new RegExp(prefix + escaped + suffix, "i");
		}

		var warningRegExps = warningTerms.map(convertToRegExp);
		function commentContainsWarningTerm(comment) {
			var matches = [];

			warningRegExps.forEach(function (regex, index) {
				if (regex.test(comment)) {
					matches.push(warningTerms[index]);
				}
			});

			return matches;
		}
		function checkComment(node) {
			if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {
				return;
			}

			var matches = commentContainsWarningTerm(node.value);

			matches.forEach(function (matchedTerm) {
				context.report({
					node: node,
					message: "Unexpected '{{matchedTerm}}' comment.",
					data: {
						matchedTerm: matchedTerm
					}
				});
			});
		}

		return {
			Program: function Program() {
				var comments = sourceCode.getAllComments();

				comments.filter(function (token) {
					return token.type !== "Shebang";
				}).forEach(checkComment);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow whitespace before properties",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",
		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function reportError(node, leftToken, rightToken) {
			var replacementText = node.computed ? "" : ".";

			context.report({
				node: node,
				message: "Unexpected whitespace before property {{propName}}.",
				data: {
					propName: sourceCode.getText(node.property)
				},
				fix: function fix(fixer) {
					if (!node.computed && astUtils.isDecimalInteger(node.object)) {
						return null;
					}
					return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);
				}
			});
		}
		return {
			MemberExpression: function MemberExpression(node) {
				var rightToken = void 0;
				var leftToken = void 0;

				if (!astUtils.isTokenOnSameLine(node.object, node.property)) {
					return;
				}

				if (node.computed) {
					rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);
					leftToken = sourceCode.getTokenBefore(rightToken);
				} else {
					rightToken = sourceCode.getFirstToken(node.property);
					leftToken = sourceCode.getTokenBefore(rightToken, 1);
				}

				if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
					reportError(node, leftToken, rightToken);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `with` statements",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			WithStatement: function WithStatement(node) {
				context.report({ node: node, message: "Unexpected use of 'with' statement." });
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var POSITION_SCHEMA = { enum: ["beside", "below", "any"] };

module.exports = {
	meta: {
		docs: {
			description: "enforce the location of single-line statements",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [POSITION_SCHEMA, {
			properties: {
				overrides: {
					properties: {
						if: POSITION_SCHEMA,
						else: POSITION_SCHEMA,
						while: POSITION_SCHEMA,
						do: POSITION_SCHEMA,
						for: POSITION_SCHEMA
					},
					additionalProperties: false
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function getOption(keywordName) {
			return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] || context.options[0] || "beside";
		}
		function validateStatement(node, keywordName) {
			var option = getOption(keywordName);

			if (node.type === "BlockStatement" || option === "any") {
				return;
			}

			var tokenBefore = sourceCode.getTokenBefore(node);

			if (tokenBefore.loc.end.line === node.loc.start.line && option === "below") {
				context.report({
					node: node,
					message: "Expected a linebreak before this statement.",
					fix: function fix(fixer) {
						return fixer.insertTextBefore(node, "\n");
					}
				});
			} else if (tokenBefore.loc.end.line !== node.loc.start.line && option === "beside") {
				context.report({
					node: node,
					message: "Expected no linebreak before this statement.",
					fix: function fix(fixer) {
						if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {
							return null;
						}
						return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], " ");
					}
				});
			}
		}
		return {
			IfStatement: function IfStatement(node) {
				validateStatement(node.consequent, "if");
				if (node.alternate && node.alternate.type !== "IfStatement") {
					validateStatement(node.alternate, "else");
				}
			},

			WhileStatement: function WhileStatement(node) {
				return validateStatement(node.body, "while");
			},
			DoWhileStatement: function DoWhileStatement(node) {
				return validateStatement(node.body, "do");
			},
			ForStatement: function ForStatement(node) {
				return validateStatement(node.body, "for");
			},
			ForInStatement: function ForInStatement(node) {
				return validateStatement(node.body, "for");
			},
			ForOfStatement: function ForOfStatement(node) {
				return validateStatement(node.body, "for");
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var OPTION_VALUE = {
	oneOf: [{
		enum: ["always", "never"]
	}, {
		type: "object",
		properties: {
			multiline: {
				type: "boolean"
			},
			minProperties: {
				type: "integer",
				minimum: 0
			},
			consistent: {
				type: "boolean"
			}
		},
		additionalProperties: false,
		minProperties: 1
	}]
};
function normalizeOptionValue(value) {
	var multiline = false;
	var minProperties = Number.POSITIVE_INFINITY;
	var consistent = false;

	if (value) {
		if (value === "always") {
			minProperties = 0;
		} else if (value === "never") {
			minProperties = Number.POSITIVE_INFINITY;
		} else {
			multiline = Boolean(value.multiline);
			minProperties = value.minProperties || Number.POSITIVE_INFINITY;
			consistent = Boolean(value.consistent);
		}
	} else {
		multiline = true;
	}

	return { multiline: multiline, minProperties: minProperties, consistent: consistent };
}
function normalizeOptions(options) {
	if (options && (options.ObjectExpression || options.ObjectPattern)) {
		return {
			ObjectExpression: normalizeOptionValue(options.ObjectExpression),
			ObjectPattern: normalizeOptionValue(options.ObjectPattern)
		};
	}

	var value = normalizeOptionValue(options);

	return { ObjectExpression: value, ObjectPattern: value };
}
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent line breaks inside braces",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			oneOf: [OPTION_VALUE, {
				type: "object",
				properties: {
					ObjectExpression: OPTION_VALUE,
					ObjectPattern: OPTION_VALUE
				},
				additionalProperties: false,
				minProperties: 1
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var normalizedOptions = normalizeOptions(context.options[0]);
		function check(node) {
			var options = normalizedOptions[node.type];
			var openBrace = sourceCode.getFirstToken(node, function (token) {
				return token.value === "{";
			});
			var closeBrace = void 0;

			if (node.typeAnnotation) {
				closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);
			} else {
				closeBrace = sourceCode.getLastToken(node);
			}

			var first = sourceCode.getTokenAfter(openBrace, { includeComments: true });
			var last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });
			var needsLinebreaks = node.properties.length >= options.minProperties || options.multiline && node.properties.length > 0 && first.loc.start.line !== last.loc.end.line;
			var hasCommentsFirstToken = astUtils.isCommentToken(first);
			var hasCommentsLastToken = astUtils.isCommentToken(last);
			first = sourceCode.getTokenAfter(openBrace);
			last = sourceCode.getTokenBefore(closeBrace);

			if (needsLinebreaks) {
				if (astUtils.isTokenOnSameLine(openBrace, first)) {
					context.report({
						message: "Expected a line break after this opening brace.",
						node: node,
						loc: openBrace.loc.start,
						fix: function fix(fixer) {
							if (hasCommentsFirstToken) {
								return null;
							}

							return fixer.insertTextAfter(openBrace, "\n");
						}
					});
				}
				if (astUtils.isTokenOnSameLine(last, closeBrace)) {
					context.report({
						message: "Expected a line break before this closing brace.",
						node: node,
						loc: closeBrace.loc.start,
						fix: function fix(fixer) {
							if (hasCommentsLastToken) {
								return null;
							}

							return fixer.insertTextBefore(closeBrace, "\n");
						}
					});
				}
			} else {
				var consistent = options.consistent;
				var hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);
				var hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);

				if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) {
					context.report({
						message: "Unexpected line break after this opening brace.",
						node: node,
						loc: openBrace.loc.start,
						fix: function fix(fixer) {
							if (hasCommentsFirstToken) {
								return null;
							}

							return fixer.removeRange([openBrace.range[1], first.range[0]]);
						}
					});
				}
				if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) {
					context.report({
						message: "Unexpected line break before this closing brace.",
						node: node,
						loc: closeBrace.loc.start,
						fix: function fix(fixer) {
							if (hasCommentsLastToken) {
								return null;
							}

							return fixer.removeRange([last.range[1], closeBrace.range[0]]);
						}
					});
				}
			}
		}

		return {
			ObjectExpression: check,
			ObjectPattern: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing inside braces",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["always", "never"]
		}, {
			type: "object",
			properties: {
				arraysInObjects: {
					type: "boolean"
				},
				objectsInObjects: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var spaced = context.options[0] === "always",
			sourceCode = context.getSourceCode();
		function isOptionSet(option) {
			return context.options[1] ? context.options[1][option] === !spaced : false;
		}

		var options = {
			spaced: spaced,
			arraysInObjectsException: isOptionSet("arraysInObjects"),
			objectsInObjectsException: isOptionSet("objectsInObjects")
		};
		function reportNoBeginningSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "There should be no space after '{{token}}'.",
				data: {
					token: token.value
				},
				fix: function fix(fixer) {
					var nextToken = context.getSourceCode().getTokenAfter(token);

					return fixer.removeRange([token.range[1], nextToken.range[0]]);
				}
			});
		}
		function reportNoEndingSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "There should be no space before '{{token}}'.",
				data: {
					token: token.value
				},
				fix: function fix(fixer) {
					var previousToken = context.getSourceCode().getTokenBefore(token);

					return fixer.removeRange([previousToken.range[1], token.range[0]]);
				}
			});
		}
		function reportRequiredBeginningSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "A space is required after '{{token}}'.",
				data: {
					token: token.value
				},
				fix: function fix(fixer) {
					return fixer.insertTextAfter(token, " ");
				}
			});
		}
		function reportRequiredEndingSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "A space is required before '{{token}}'.",
				data: {
					token: token.value
				},
				fix: function fix(fixer) {
					return fixer.insertTextBefore(token, " ");
				}
			});
		}
		function validateBraceSpacing(node, first, second, penultimate, last) {
			if (astUtils.isTokenOnSameLine(first, second)) {
				var firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);

				if (options.spaced && !firstSpaced) {
					reportRequiredBeginningSpace(node, first);
				}
				if (!options.spaced && firstSpaced) {
					reportNoBeginningSpace(node, first);
				}
			}

			if (astUtils.isTokenOnSameLine(penultimate, last)) {
				var shouldCheckPenultimate = options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) || options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate);
				var penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;

				var closingCurlyBraceMustBeSpaced = options.arraysInObjectsException && penultimateType === "ArrayExpression" || options.objectsInObjectsException && (penultimateType === "ObjectExpression" || penultimateType === "ObjectPattern") ? !options.spaced : options.spaced;

				var lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);

				if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
					reportRequiredEndingSpace(node, last);
				}
				if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
					reportNoEndingSpace(node, last);
				}
			}
		}
		function getClosingBraceOfObject(node) {
			var lastProperty = node.properties[node.properties.length - 1];

			return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);
		}
		function checkForObject(node) {
			if (node.properties.length === 0) {
				return;
			}

			var first = sourceCode.getFirstToken(node),
				last = getClosingBraceOfObject(node),
				second = sourceCode.getTokenAfter(first),
				penultimate = sourceCode.getTokenBefore(last);

			validateBraceSpacing(node, first, second, penultimate, last);
		}
		function checkForImport(node) {
			if (node.specifiers.length === 0) {
				return;
			}

			var firstSpecifier = node.specifiers[0];
			var lastSpecifier = node.specifiers[node.specifiers.length - 1];

			if (lastSpecifier.type !== "ImportSpecifier") {
				return;
			}
			if (firstSpecifier.type !== "ImportSpecifier") {
				firstSpecifier = node.specifiers[1];
			}

			var first = sourceCode.getTokenBefore(firstSpecifier),
				last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),
				second = sourceCode.getTokenAfter(first),
				penultimate = sourceCode.getTokenBefore(last);

			validateBraceSpacing(node, first, second, penultimate, last);
		}
		function checkForExport(node) {
			if (node.specifiers.length === 0) {
				return;
			}

			var firstSpecifier = node.specifiers[0],
				lastSpecifier = node.specifiers[node.specifiers.length - 1],
				first = sourceCode.getTokenBefore(firstSpecifier),
				last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),
				second = sourceCode.getTokenAfter(first),
				penultimate = sourceCode.getTokenBefore(last);

			validateBraceSpacing(node, first, second, penultimate, last);
		}
		return {
			ObjectPattern: checkForObject,
			ObjectExpression: checkForObject,
			ImportDeclaration: checkForImport,
			ExportNamedDeclaration: checkForExport
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce placing object properties on separate lines",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowMultiplePropertiesPerLine: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "whitespace"
	},

	create: function create(context) {
		var allowSameLine = context.options[0] && Boolean(context.options[0].allowMultiplePropertiesPerLine);
		var errorMessage = allowSameLine ? "Object properties must go on a new line if they aren't all on the same line." : "Object properties must go on a new line.";

		var sourceCode = context.getSourceCode();

		return {
			ObjectExpression: function ObjectExpression(node) {
				if (allowSameLine) {
					if (node.properties.length > 1) {
						var firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);
						var lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);

						if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {
							return;
						}
					}
				}

				var _loop = function _loop(i) {
					var lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);
					var firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);

					if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {
						context.report({
							node: node,
							loc: firstTokenOfCurrentProperty.loc.start,
							message: errorMessage,
							fix: function fix(fixer) {
								var comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);
								var rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];
								if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {
									return null;
								}

								return fixer.replaceTextRange(rangeAfterComma, "\n");
							}
						});
					}
				};

				for (var i = 1; i < node.properties.length; i++) {
					_loop(i);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var OPTIONS = {
	always: "always",
	never: "never",
	methods: "methods",
	properties: "properties",
	consistent: "consistent",
	consistentAsNeeded: "consistent-as-needed"
};
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow method and property shorthand syntax for object literals",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "code",

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["always", "methods", "properties", "never", "consistent", "consistent-as-needed"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["always", "methods", "properties"]
				}, {
					type: "object",
					properties: {
						avoidQuotes: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}, {
				type: "array",
				items: [{
					enum: ["always", "methods"]
				}, {
					type: "object",
					properties: {
						ignoreConstructors: {
							type: "boolean"
						},
						avoidQuotes: {
							type: "boolean"
						},
						avoidExplicitReturnArrows: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		}
	},

	create: function create(context) {
		var APPLY = context.options[0] || OPTIONS.always;
		var APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
		var APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
		var APPLY_NEVER = APPLY === OPTIONS.never;
		var APPLY_CONSISTENT = APPLY === OPTIONS.consistent;
		var APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;

		var PARAMS = context.options[1] || {};
		var IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;
		var AVOID_QUOTES = PARAMS.avoidQuotes;
		var AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;
		var sourceCode = context.getSourceCode();
		function isConstructor(name) {
			var firstChar = name.charAt(0);

			return firstChar === firstChar.toUpperCase();
		}
		function canHaveShorthand(property) {
			return property.kind !== "set" && property.kind !== "get" && property.type !== "SpreadProperty" && property.type !== "ExperimentalSpreadProperty";
		}
		function isStringLiteral(node) {
			return node.type === "Literal" && typeof node.value === "string";
		}
		function isShorthand(property) {
			return property.shorthand || property.method;
		}
		function isRedundant(property) {
			var value = property.value;

			if (value.type === "FunctionExpression") {
				return !value.id; // Only anonymous should be shorthand method.
			}
			if (value.type === "Identifier") {
				return astUtils.getStaticPropertyName(property) === value.name;
			}

			return false;
		}
		function checkConsistency(node, checkRedundancy) {
			var properties = node.properties.filter(canHaveShorthand);
			if (properties.length > 0) {
				var shorthandProperties = properties.filter(isShorthand);
				if (shorthandProperties.length !== properties.length) {
					if (shorthandProperties.length > 0) {
						context.report({ node: node, message: "Unexpected mix of shorthand and non-shorthand properties." });
					} else if (checkRedundancy) {
						var canAlwaysUseShorthand = properties.every(isRedundant);

						if (canAlwaysUseShorthand) {
							context.report({ node: node, message: "Expected shorthand for all properties." });
						}
					}
				}
			}
		}
		function makeFunctionShorthand(fixer, node) {
			var firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);
			var lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);
			var keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
			var keyPrefix = "";

			if (node.value.generator) {
				keyPrefix = "*";
			} else if (node.value.async) {
				keyPrefix = "async ";
			}

			if (node.value.type === "FunctionExpression") {
				var functionToken = sourceCode.getTokens(node.value).find(function (token) {
					return token.type === "Keyword" && token.value === "function";
				});
				var tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;

				return fixer.replaceTextRange([firstKeyToken.range[0], node.range[1]], keyPrefix + keyText + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1]));
			}
			var arrowToken = sourceCode.getTokens(node.value).find(function (token) {
				return token.value === "=>";
			});
			var tokenBeforeArrow = sourceCode.getTokenBefore(arrowToken);
			var hasParensAroundParameters = tokenBeforeArrow.type === "Punctuator" && tokenBeforeArrow.value === ")";
			var oldParamText = sourceCode.text.slice(sourceCode.getFirstToken(node.value, node.value.async ? 1 : 0).range[0], tokenBeforeArrow.range[1]);
			var newParamText = hasParensAroundParameters ? oldParamText : "(" + oldParamText + ")";

			return fixer.replaceTextRange([firstKeyToken.range[0], node.range[1]], keyPrefix + keyText + newParamText + sourceCode.text.slice(arrowToken.range[1], node.value.range[1]));
		}
		function makeFunctionLongform(fixer, node) {
			var firstKeyToken = node.computed ? sourceCode.getTokens(node).find(function (token) {
				return token.value === "[";
			}) : sourceCode.getFirstToken(node.key);
			var lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(function (token) {
				return token.value === "]";
			}) : sourceCode.getLastToken(node.key);
			var keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
			var functionHeader = "function";

			if (node.value.generator) {
				functionHeader = "function*";
			} else if (node.value.async) {
				functionHeader = "async function";
			}

			return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], keyText + ": " + functionHeader);
		}
		var lexicalScopeStack = [];
		var arrowsWithLexicalIdentifiers = new WeakSet();
		var argumentsIdentifiers = new WeakSet();
		function enterFunction() {
			lexicalScopeStack.unshift(new Set());
			context.getScope().variables.filter(function (variable) {
				return variable.name === "arguments";
			}).forEach(function (variable) {
				variable.references.map(function (ref) {
					return ref.identifier;
				}).forEach(function (identifier) {
					return argumentsIdentifiers.add(identifier);
				});
			});
		}
		function exitFunction() {
			lexicalScopeStack.shift();
		}
		function reportLexicalIdentifier() {
			lexicalScopeStack[0].forEach(function (arrowFunction) {
				return arrowsWithLexicalIdentifiers.add(arrowFunction);
			});
		}
		return {
			Program: enterFunction,
			FunctionDeclaration: enterFunction,
			FunctionExpression: enterFunction,
			"Program:exit": exitFunction,
			"FunctionDeclaration:exit": exitFunction,
			"FunctionExpression:exit": exitFunction,

			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
				lexicalScopeStack[0].add(node);
			},
			"ArrowFunctionExpression:exit": function ArrowFunctionExpressionExit(node) {
				lexicalScopeStack[0].delete(node);
			},


			ThisExpression: reportLexicalIdentifier,
			Super: reportLexicalIdentifier,
			MetaProperty: function MetaProperty(node) {
				if (node.meta.name === "new" && node.property.name === "target") {
					reportLexicalIdentifier();
				}
			},
			Identifier: function Identifier(node) {
				if (argumentsIdentifiers.has(node)) {
					reportLexicalIdentifier();
				}
			},
			ObjectExpression: function ObjectExpression(node) {
				if (APPLY_CONSISTENT) {
					checkConsistency(node, false);
				} else if (APPLY_CONSISTENT_AS_NEEDED) {
					checkConsistency(node, true);
				}
			},
			"Property:exit": function PropertyExit(node) {
				var isConciseProperty = node.method || node.shorthand;
				if (node.parent.type === "ObjectPattern") {
					return;
				}
				if (node.kind === "get" || node.kind === "set") {
					return;
				}
				if (node.computed && node.value.type !== "FunctionExpression" && node.value.type !== "ArrowFunctionExpression") {
					return;
				}
				if (isConciseProperty) {
					if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {
						var message = APPLY_NEVER ? "Expected longform method syntax." : "Expected longform method syntax for string literal keys.";
						context.report({
							node: node,
							message: message,
							fix: function fix(fixer) {
								return makeFunctionLongform(fixer, node);
							}
						});
					} else if (APPLY_NEVER) {
						context.report({
							node: node,
							message: "Expected longform property syntax.",
							fix: function fix(fixer) {
								return fixer.insertTextAfter(node.key, ": " + node.key.name);
							}
						});
					}
				} else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression")) {
					if (IGNORE_CONSTRUCTORS && node.key.type === "Identifier" && isConstructor(node.key.name)) {
						return;
					}
					if (AVOID_QUOTES && isStringLiteral(node.key)) {
						return;
					}
					if (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression" && node.value.body.type === "BlockStatement" && AVOID_EXPLICIT_RETURN_ARROWS && !arrowsWithLexicalIdentifiers.has(node.value)) {
						context.report({
							node: node,
							message: "Expected method shorthand.",
							fix: function fix(fixer) {
								return makeFunctionShorthand(fixer, node);
							}
						});
					}
				} else if (node.value.type === "Identifier" && node.key.name === node.value.name && APPLY_TO_PROPS) {
					context.report({
						node: node,
						message: "Expected property shorthand.",
						fix: function fix(fixer) {
							return fixer.replaceText(node, node.value.name);
						}
					});
				} else if (node.value.type === "Identifier" && node.key.type === "Literal" && node.key.value === node.value.name && APPLY_TO_PROPS) {
					if (AVOID_QUOTES) {
						return;
					}
					context.report({
						node: node,
						message: "Expected property shorthand.",
						fix: function fix(fixer) {
							return fixer.replaceText(node, node.value.name);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require or disallow newlines around variable declarations",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			enum: ["always", "initializations"]
		}],

		fixable: "whitespace"
	},

	create: function create(context) {

		var ERROR_MESSAGE = "Expected variable declaration to be on a new line.";
		var always = context.options[0] === "always";
		function isForTypeSpecifier(keyword) {
			return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
		}
		function checkForNewLine(node) {
			if (isForTypeSpecifier(node.parent.type)) {
				return;
			}

			var declarations = node.declarations;
			var prev = void 0;

			declarations.forEach(function (current) {
				if (prev && prev.loc.end.line === current.loc.start.line) {
					if (always || prev.init || current.init) {
						context.report({
							node: node,
							message: ERROR_MESSAGE,
							loc: current.loc.start,
							fix: function fix(fixer) {
								return fixer.insertTextBefore(current, "\n");
							}
						});
					}
				}
				prev = current;
			});
		}
		return {
			VariableDeclaration: checkForNewLine
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
	meta: {
		docs: {
			description: "enforce variables to be declared either together or separately in functions",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				enum: ["always", "never"]
			}, {
				type: "object",
				properties: {
					var: {
						enum: ["always", "never"]
					},
					let: {
						enum: ["always", "never"]
					},
					const: {
						enum: ["always", "never"]
					}
				},
				additionalProperties: false
			}, {
				type: "object",
				properties: {
					initialized: {
						enum: ["always", "never"]
					},
					uninitialized: {
						enum: ["always", "never"]
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {

		var MODE_ALWAYS = "always",
			MODE_NEVER = "never";

		var mode = context.options[0] || MODE_ALWAYS;

		var options = {};

		if (typeof mode === "string") {
			options.var = { uninitialized: mode, initialized: mode };
			options.let = { uninitialized: mode, initialized: mode };
			options.const = { uninitialized: mode, initialized: mode };
		} else if ((typeof mode === "undefined" ? "undefined" : _typeof(mode)) === "object") {
			if (mode.hasOwnProperty("var") && typeof mode.var === "string") {
				options.var = { uninitialized: mode.var, initialized: mode.var };
			}
			if (mode.hasOwnProperty("let") && typeof mode.let === "string") {
				options.let = { uninitialized: mode.let, initialized: mode.let };
			}
			if (mode.hasOwnProperty("const") && typeof mode.const === "string") {
				options.const = { uninitialized: mode.const, initialized: mode.const };
			}
			if (mode.hasOwnProperty("uninitialized")) {
				if (!options.var) {
					options.var = {};
				}
				if (!options.let) {
					options.let = {};
				}
				if (!options.const) {
					options.const = {};
				}
				options.var.uninitialized = mode.uninitialized;
				options.let.uninitialized = mode.uninitialized;
				options.const.uninitialized = mode.uninitialized;
			}
			if (mode.hasOwnProperty("initialized")) {
				if (!options.var) {
					options.var = {};
				}
				if (!options.let) {
					options.let = {};
				}
				if (!options.const) {
					options.const = {};
				}
				options.var.initialized = mode.initialized;
				options.let.initialized = mode.initialized;
				options.const.initialized = mode.initialized;
			}
		}
		var functionStack = [];
		var blockStack = [];
		function startBlock() {
			blockStack.push({
				let: { initialized: false, uninitialized: false },
				const: { initialized: false, uninitialized: false }
			});
		}
		function startFunction() {
			functionStack.push({ initialized: false, uninitialized: false });
			startBlock();
		}
		function endBlock() {
			blockStack.pop();
		}
		function endFunction() {
			functionStack.pop();
			endBlock();
		}
		function recordTypes(statementType, declarations, currentScope) {
			for (var i = 0; i < declarations.length; i++) {
				if (declarations[i].init === null) {
					if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {
						currentScope.uninitialized = true;
					}
				} else {
					if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {
						currentScope.initialized = true;
					}
				}
			}
		}
		function getCurrentScope(statementType) {
			var currentScope = void 0;

			if (statementType === "var") {
				currentScope = functionStack[functionStack.length - 1];
			} else if (statementType === "let") {
				currentScope = blockStack[blockStack.length - 1].let;
			} else if (statementType === "const") {
				currentScope = blockStack[blockStack.length - 1].const;
			}
			return currentScope;
		}
		function countDeclarations(declarations) {
			var counts = { uninitialized: 0, initialized: 0 };

			for (var i = 0; i < declarations.length; i++) {
				if (declarations[i].init === null) {
					counts.uninitialized++;
				} else {
					counts.initialized++;
				}
			}
			return counts;
		}
		function hasOnlyOneStatement(statementType, declarations) {

			var declarationCounts = countDeclarations(declarations);
			var currentOptions = options[statementType] || {};
			var currentScope = getCurrentScope(statementType);

			if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {
				if (currentScope.uninitialized || currentScope.initialized) {
					return false;
				}
			}

			if (declarationCounts.uninitialized > 0) {
				if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {
					return false;
				}
			}
			if (declarationCounts.initialized > 0) {
				if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {
					return false;
				}
			}
			recordTypes(statementType, declarations, currentScope);
			return true;
		}
		return {
			Program: startFunction,
			FunctionDeclaration: startFunction,
			FunctionExpression: startFunction,
			ArrowFunctionExpression: startFunction,
			BlockStatement: startBlock,
			ForStatement: startBlock,
			ForInStatement: startBlock,
			ForOfStatement: startBlock,
			SwitchStatement: startBlock,

			VariableDeclaration: function VariableDeclaration(node) {
				var parent = node.parent;
				var type = node.kind;

				if (!options[type]) {
					return;
				}

				var declarations = node.declarations;
				var declarationCounts = countDeclarations(declarations);
				if (!hasOnlyOneStatement(type, declarations)) {
					if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {
						context.report({
							node: node,
							message: "Combine this with the previous '{{type}}' statement.",
							data: {
								type: type
							}
						});
					} else {
						if (options[type].initialized === MODE_ALWAYS) {
							context.report({
								node: node,
								message: "Combine this with the previous '{{type}}' statement with initialized variables.",
								data: {
									type: type
								}
							});
						}
						if (options[type].uninitialized === MODE_ALWAYS) {
							if (node.parent.left === node && (node.parent.type === "ForInStatement" || node.parent.type === "ForOfStatement")) {
								return;
							}
							context.report({
								node: node,
								message: "Combine this with the previous '{{type}}' statement with uninitialized variables.",
								data: {
									type: type
								}
							});
						}
					}
				}
				if (parent.type !== "ForStatement" || parent.init !== node) {
					var totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;

					if (totalDeclarations > 1) {

						if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {
							context.report({
								node: node,
								message: "Split '{{type}}' declarations into multiple statements.",
								data: {
									type: type
								}
							});
						} else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {
							context.report({
								node: node,
								message: "Split initialized '{{type}}' declarations into multiple statements.",
								data: {
									type: type
								}
							});
						} else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {
							context.report({
								node: node,
								message: "Split uninitialized '{{type}}' declarations into multiple statements.",
								data: {
									type: type
								}
							});
						}
					}
				}
			},


			"ForStatement:exit": endBlock,
			"ForOfStatement:exit": endBlock,
			"ForInStatement:exit": endBlock,
			"SwitchStatement:exit": endBlock,
			"BlockStatement:exit": endBlock,
			"Program:exit": endFunction,
			"FunctionDeclaration:exit": endFunction,
			"FunctionExpression:exit": endFunction,
			"ArrowFunctionExpression:exit": endFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isCommutativeOperatorWithShorthand(operator) {
	return ["*", "&", "^", "|"].indexOf(operator) >= 0;
}
function isNonCommutativeOperatorWithShorthand(operator) {
	return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].indexOf(operator) >= 0;
}
function same(a, b) {
	if (a.type !== b.type) {
		return false;
	}

	switch (a.type) {
		case "Identifier":
			return a.name === b.name;

		case "Literal":
			return a.value === b.value;

		case "MemberExpression":
			return same(a.object, b.object) && same(a.property, b.property);

		default:
			return false;
	}
}
function canBeFixed(node) {
	return node.type === "Identifier" || node.type === "MemberExpression" && node.object.type === "Identifier" && (!node.computed || node.property.type === "Literal");
}

module.exports = {
	meta: {
		docs: {
			description: "require or disallow assignment operator shorthand where possible",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			enum: ["always", "never"]
		}],

		fixable: "code"
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode();
		function getOperatorToken(node) {
			return sourceCode.getFirstTokenBetween(node.left, node.right, function (token) {
				return token.value === node.operator;
			});
		}
		function verify(node) {
			if (node.operator !== "=" || node.right.type !== "BinaryExpression") {
				return;
			}

			var left = node.left;
			var expr = node.right;
			var operator = expr.operator;

			if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {
				if (same(left, expr.left)) {
					context.report({
						node: node,
						message: "Assignment can be replaced with operator assignment.",
						fix: function fix(fixer) {
							if (canBeFixed(left)) {
								var equalsToken = getOperatorToken(node);
								var operatorToken = getOperatorToken(expr);
								var leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);
								var rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);

								return fixer.replaceText(node, "" + leftText + expr.operator + "=" + rightText);
							}
							return null;
						}
					});
				} else if (same(left, expr.right) && isCommutativeOperatorWithShorthand(operator)) {
					context.report({
						node: node,
						message: "Assignment can be replaced with operator assignment."
					});
				}
			}
		}
		function prohibit(node) {
			if (node.operator !== "=") {
				context.report({
					node: node,
					message: "Unexpected operator assignment shorthand.",
					fix: function fix(fixer) {
						if (canBeFixed(node.left)) {
							var operatorToken = getOperatorToken(node);
							var leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);
							var newOperator = node.operator.slice(0, -1);
							var rightText = void 0;
							if (astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: "BinaryExpression", operator: newOperator }) && !astUtils.isParenthesised(sourceCode, node.right)) {
								rightText = sourceCode.text.slice(operatorToken.range[1], node.right.range[0]) + "(" + sourceCode.getText(node.right) + ")";
							} else {
								rightText = sourceCode.text.slice(operatorToken.range[1], node.range[1]);
							}

							return fixer.replaceText(node, leftText + "= " + leftText + newOperator + rightText);
						}
						return null;
					}
				});
			}
		}

		return {
			AssignmentExpression: context.options[0] !== "never" ? verify : prohibit
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent linebreak style for operators",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			enum: ["after", "before", "none", null]
		}, {
			type: "object",
			properties: {
				overrides: {
					type: "object",
					properties: {
						anyOf: {
							type: "string",
							enum: ["after", "before", "none", "ignore"]
						}
					}
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {

		var usedDefaultGlobal = !context.options[0];
		var globalStyle = context.options[0] || "after";
		var options = context.options[1] || {};
		var styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};

		if (usedDefaultGlobal && !styleOverrides["?"]) {
			styleOverrides["?"] = "before";
		}

		if (usedDefaultGlobal && !styleOverrides[":"]) {
			styleOverrides[":"] = "before";
		}

		var sourceCode = context.getSourceCode();
		function getFixer(operatorToken, desiredStyle) {
			return function (fixer) {
				var tokenBefore = sourceCode.getTokenBefore(operatorToken);
				var tokenAfter = sourceCode.getTokenAfter(operatorToken);
				var textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);
				var textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);
				var hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);
				var hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);
				var newTextBefore = void 0,
					newTextAfter = void 0;

				if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== "none") {
					if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {

						return null;
					}
					newTextBefore = textAfter;
					newTextAfter = textBefore;
				} else {
					var LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();
					newTextBefore = desiredStyle === "before" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, "");
					newTextAfter = desiredStyle === "after" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, "");
					if (newTextBefore === textBefore && newTextAfter === textAfter) {
						return null;
					}
				}

				if (newTextAfter === "" && tokenAfter.type === "Punctuator" && "+-".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {
					newTextAfter += " ";
				}

				return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);
			};
		}
		function validateNode(node, leftSide) {
			var operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);
			var leftToken = sourceCode.getTokenBefore(operatorToken);
			var rightToken = sourceCode.getTokenAfter(operatorToken);
			var operator = operatorToken.value;
			var operatorStyleOverride = styleOverrides[operator];
			var style = operatorStyleOverride || globalStyle;
			var fix = getFixer(operatorToken, style);
			if (astUtils.isTokenOnSameLine(leftToken, operatorToken) && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
			} else if (operatorStyleOverride !== "ignore" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) && !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
				context.report({
					node: node,
					loc: {
						line: operatorToken.loc.end.line,
						column: operatorToken.loc.end.column
					},
					message: "Bad line breaking before and after '{{operator}}'.",
					data: {
						operator: operator
					},
					fix: fix
				});
			} else if (style === "before" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {

				context.report({
					node: node,
					loc: {
						line: operatorToken.loc.end.line,
						column: operatorToken.loc.end.column
					},
					message: "'{{operator}}' should be placed at the beginning of the line.",
					data: {
						operator: operator
					},
					fix: fix
				});
			} else if (style === "after" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {

				context.report({
					node: node,
					loc: {
						line: operatorToken.loc.end.line,
						column: operatorToken.loc.end.column
					},
					message: "'{{operator}}' should be placed at the end of the line.",
					data: {
						operator: operator
					},
					fix: fix
				});
			} else if (style === "none") {

				context.report({
					node: node,
					loc: {
						line: operatorToken.loc.end.line,
						column: operatorToken.loc.end.column
					},
					message: "There should be no line break before or after '{{operator}}'.",
					data: {
						operator: operator
					},
					fix: fix
				});
			}
		}
		function validateBinaryExpression(node) {
			validateNode(node, node.left);
		}
		return {
			BinaryExpression: validateBinaryExpression,
			LogicalExpression: validateBinaryExpression,
			AssignmentExpression: validateBinaryExpression,
			VariableDeclarator: function VariableDeclarator(node) {
				if (node.init) {
					validateNode(node, node.id);
				}
			},
			ConditionalExpression: function ConditionalExpression(node) {
				validateNode(node, node.test);
				validateNode(node, node.consequent);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require or disallow padding within blocks",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["always", "never"]
			}, {
				type: "object",
				properties: {
					blocks: {
						enum: ["always", "never"]
					},
					switches: {
						enum: ["always", "never"]
					},
					classes: {
						enum: ["always", "never"]
					}
				},
				additionalProperties: false,
				minProperties: 1
			}]
		}]
	},

	create: function create(context) {
		var options = {};
		var config = context.options[0] || "always";

		if (typeof config === "string") {
			var shouldHavePadding = config === "always";

			options.blocks = shouldHavePadding;
			options.switches = shouldHavePadding;
			options.classes = shouldHavePadding;
		} else {
			if (config.hasOwnProperty("blocks")) {
				options.blocks = config.blocks === "always";
			}
			if (config.hasOwnProperty("switches")) {
				options.switches = config.switches === "always";
			}
			if (config.hasOwnProperty("classes")) {
				options.classes = config.classes === "always";
			}
		}

		var ALWAYS_MESSAGE = "Block must be padded by blank lines.",
			NEVER_MESSAGE = "Block must not be padded by blank lines.";

		var sourceCode = context.getSourceCode();
		function getOpenBrace(node) {
			if (node.type === "SwitchStatement") {
				return sourceCode.getTokenBefore(node.cases[0]);
			}
			return sourceCode.getFirstToken(node);
		}
		function isComment(node) {
			return node.type === "Line" || node.type === "Block";
		}
		function isPaddingBetweenTokens(first, second) {
			return second.loc.start.line - first.loc.end.line >= 2;
		}
		function getFirstBlockToken(token) {
			var prev = void 0,
				first = token;

			do {
				prev = first;
				first = sourceCode.getTokenAfter(first, { includeComments: true });
			} while (isComment(first) && first.loc.start.line === prev.loc.end.line);

			return first;
		}
		function getLastBlockToken(token) {
			var last = token,
				next = void 0;

			do {
				next = last;
				last = sourceCode.getTokenBefore(last, { includeComments: true });
			} while (isComment(last) && last.loc.end.line === next.loc.start.line);

			return last;
		}
		function requirePaddingFor(node) {
			switch (node.type) {
				case "BlockStatement":
					return options.blocks;
				case "SwitchStatement":
					return options.switches;
				case "ClassBody":
					return options.classes;
				default:
					throw new Error("unreachable");
			}
		}
		function checkPadding(node) {
			var openBrace = getOpenBrace(node),
				firstBlockToken = getFirstBlockToken(openBrace),
				tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),
				closeBrace = sourceCode.getLastToken(node),
				lastBlockToken = getLastBlockToken(closeBrace),
				tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),
				blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),
				blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);

			if (requirePaddingFor(node)) {
				if (!blockHasTopPadding) {
					context.report({
						node: node,
						loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },
						fix: function fix(fixer) {
							return fixer.insertTextAfter(tokenBeforeFirst, "\n");
						},

						message: ALWAYS_MESSAGE
					});
				}
				if (!blockHasBottomPadding) {
					context.report({
						node: node,
						loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },
						fix: function fix(fixer) {
							return fixer.insertTextBefore(tokenAfterLast, "\n");
						},

						message: ALWAYS_MESSAGE
					});
				}
			} else {
				if (blockHasTopPadding) {

					context.report({
						node: node,
						loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },
						fix: function fix(fixer) {
							return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], "\n");
						},

						message: NEVER_MESSAGE
					});
				}

				if (blockHasBottomPadding) {

					context.report({
						node: node,
						loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },
						message: NEVER_MESSAGE,
						fix: function fix(fixer) {
							return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], "\n");
						}
					});
				}
			}
		}

		var rule = {};

		if (options.hasOwnProperty("switches")) {
			rule.SwitchStatement = function (node) {
				if (node.cases.length === 0) {
					return;
				}
				checkPadding(node);
			};
		}

		if (options.hasOwnProperty("blocks")) {
			rule.BlockStatement = function (node) {
				if (node.body.length === 0) {
					return;
				}
				checkPadding(node);
			};
		}

		if (options.hasOwnProperty("classes")) {
			rule.ClassBody = function (node) {
				if (node.body.length === 0) {
					return;
				}
				checkPadding(node);
			};
		}

		return rule;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _templateObject = _taggedTemplateLiteral(["^(s*?", ")s*", "(s*;?)$"], ["^(\\s*?", ")\\s*", "(\\s*;?)$"]);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var astUtils = __webpack_require__(0);
var LT = "[" + Array.from(astUtils.LINEBREAKS).join("") + "]";
var PADDING_LINE_SEQUENCE = new RegExp(String.raw(_templateObject, LT, LT));
var CJS_EXPORT = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/;
var CJS_IMPORT = /^require\(/;
function newKeywordTester(keyword) {
	return {
		test: function test(node, sourceCode) {
			return sourceCode.getFirstToken(node).value === keyword;
		}
	};
}
function newNodeTypeTester(type) {
	return {
		test: function test(node) {
			return node.type === type;
		}
	};
}
function isIIFEStatement(node) {
	if (node.type === "ExpressionStatement") {
		var call = node.expression;

		if (call.type === "UnaryExpression") {
			call = call.argument;
		}
		return call.type === "CallExpression" && astUtils.isFunction(call.callee);
	}
	return false;
}
function isBlockLikeStatement(sourceCode, node) {
	if (node.type === "DoWhileStatement" && node.body.type === "BlockStatement") {
		return true;
	}
	if (isIIFEStatement(node)) {
		return true;
	}
	var lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
	var belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;

	return Boolean(belongingNode) && (belongingNode.type === "BlockStatement" || belongingNode.type === "SwitchStatement");
}
function isDirective(node, sourceCode) {
	return node.type === "ExpressionStatement" && (node.parent.type === "Program" || node.parent.type === "BlockStatement" && astUtils.isFunction(node.parent.parent)) && node.expression.type === "Literal" && typeof node.expression.value === "string" && !astUtils.isParenthesised(sourceCode, node.expression);
}
function isDirectivePrologue(node, sourceCode) {
	if (isDirective(node, sourceCode)) {
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = node.parent.body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var sibling = _step.value;

				if (sibling === node) {
					break;
				}
				if (!isDirective(sibling, sourceCode)) {
					return false;
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		return true;
	}
	return false;
}
function getActualLastToken(sourceCode, node) {
	var semiToken = sourceCode.getLastToken(node);
	var prevToken = sourceCode.getTokenBefore(semiToken);
	var nextToken = sourceCode.getTokenAfter(semiToken);
	var isSemicolonLessStyle = Boolean(prevToken && nextToken && prevToken.range[0] >= node.range[0] && astUtils.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line);

	return isSemicolonLessStyle ? prevToken : semiToken;
}
function replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {
	return trailingSpaces + indentSpaces;
}
function verifyForAny() {}
function verifyForNever(context, _, nextNode, paddingLines) {
	if (paddingLines.length === 0) {
		return;
	}

	context.report({
		node: nextNode,
		message: "Unexpected blank line before this statement.",
		fix: function fix(fixer) {
			if (paddingLines.length >= 2) {
				return null;
			}

			var prevToken = paddingLines[0][0];
			var nextToken = paddingLines[0][1];
			var start = prevToken.range[1];
			var end = nextToken.range[0];
			var text = context.getSourceCode().text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);

			return fixer.replaceTextRange([start, end], text);
		}
	});
}
function verifyForAlways(context, prevNode, nextNode, paddingLines) {
	if (paddingLines.length > 0) {
		return;
	}

	context.report({
		node: nextNode,
		message: "Expected blank line before this statement.",
		fix: function fix(fixer) {
			var sourceCode = context.getSourceCode();
			var prevToken = getActualLastToken(sourceCode, prevNode);
			var nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {
				includeComments: true,
				filter: function filter(token) {
					if (astUtils.isTokenOnSameLine(prevToken, token)) {
						prevToken = token;
						return false;
					}
					return true;
				}
			}) || nextNode;
			var insertText = astUtils.isTokenOnSameLine(prevToken, nextToken) ? "\n\n" : "\n";

			return fixer.insertTextAfter(prevToken, insertText);
		}
	});
}
var PaddingTypes = {
	any: { verify: verifyForAny },
	never: { verify: verifyForNever },
	always: { verify: verifyForAlways }
};
var StatementTypes = {
	"*": { test: function test() {
			return true;
		} },
	"block-like": {
		test: function test(node, sourceCode) {
			return isBlockLikeStatement(sourceCode, node);
		}
	},
	"cjs-export": {
		test: function test(node, sourceCode) {
			return node.type === "ExpressionStatement" && node.expression.type === "AssignmentExpression" && CJS_EXPORT.test(sourceCode.getText(node.expression.left));
		}
	},
	"cjs-import": {
		test: function test(node, sourceCode) {
			return node.type === "VariableDeclaration" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init));
		}
	},
	directive: {
		test: isDirectivePrologue
	},
	expression: {
		test: function test(node, sourceCode) {
			return node.type === "ExpressionStatement" && !isDirectivePrologue(node, sourceCode);
		}
	},
	"multiline-block-like": {
		test: function test(node, sourceCode) {
			return node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(sourceCode, node);
		}
	},

	block: newNodeTypeTester("BlockStatement"),
	empty: newNodeTypeTester("EmptyStatement"),

	break: newKeywordTester("break"),
	case: newKeywordTester("case"),
	class: newKeywordTester("class"),
	const: newKeywordTester("const"),
	continue: newKeywordTester("continue"),
	debugger: newKeywordTester("debugger"),
	default: newKeywordTester("default"),
	do: newKeywordTester("do"),
	export: newKeywordTester("export"),
	for: newKeywordTester("for"),
	function: newKeywordTester("function"),
	if: newKeywordTester("if"),
	import: newKeywordTester("import"),
	let: newKeywordTester("let"),
	return: newKeywordTester("return"),
	switch: newKeywordTester("switch"),
	throw: newKeywordTester("throw"),
	try: newKeywordTester("try"),
	var: newKeywordTester("var"),
	while: newKeywordTester("while"),
	with: newKeywordTester("with")
};
module.exports = {
	meta: {
		docs: {
			description: "require or disallow padding lines between statements",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: {
			definitions: {
				paddingType: {
					enum: Object.keys(PaddingTypes)
				},
				statementType: {
					anyOf: [{ enum: Object.keys(StatementTypes) }, {
						type: "array",
						items: { enum: Object.keys(StatementTypes) },
						minItems: 1,
						uniqueItems: true,
						additionalItems: false
					}]
				}
			},
			type: "array",
			items: {
				type: "object",
				properties: {
					blankLine: { $ref: "#/definitions/paddingType" },
					prev: { $ref: "#/definitions/statementType" },
					next: { $ref: "#/definitions/statementType" }
				},
				additionalProperties: false,
				required: ["blankLine", "prev", "next"]
			},
			additionalItems: false
		}
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var configureList = context.options || [];
		var scopeInfo = null;
		function enterScope() {
			scopeInfo = {
				upper: scopeInfo,
				prevNode: null
			};
		}
		function exitScope() {
			scopeInfo = scopeInfo.upper;
		}
		function match(node, type) {
			while (node.type === "LabeledStatement") {
				node = node.body;
			}
			if (Array.isArray(type)) {
				return type.some(match.bind(null, node));
			}
			return StatementTypes[type].test(node, sourceCode);
		}
		function getPaddingType(prevNode, nextNode) {
			for (var i = configureList.length - 1; i >= 0; --i) {
				var configure = configureList[i];
				var matched = match(prevNode, configure.prev) && match(nextNode, configure.next);

				if (matched) {
					return PaddingTypes[configure.blankLine];
				}
			}
			return PaddingTypes.any;
		}
		function getPaddingLineSequences(prevNode, nextNode) {
			var pairs = [];
			var prevToken = getActualLastToken(sourceCode, prevNode);

			if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {
				do {
					var token = sourceCode.getTokenAfter(prevToken, { includeComments: true });

					if (token.loc.start.line - prevToken.loc.end.line >= 2) {
						pairs.push([prevToken, token]);
					}
					prevToken = token;
				} while (prevToken.range[0] < nextNode.range[0]);
			}

			return pairs;
		}
		function verify(node) {
			var parentType = node.parent.type;
			var validParent = astUtils.STATEMENT_LIST_PARENTS.has(parentType) || parentType === "SwitchStatement";

			if (!validParent) {
				return;
			}
			var prevNode = scopeInfo.prevNode;
			if (prevNode) {
				var type = getPaddingType(prevNode, node);
				var paddingLines = getPaddingLineSequences(prevNode, node);

				type.verify(context, prevNode, node, paddingLines);
			}

			scopeInfo.prevNode = node;
		}
		function verifyThenEnterScope(node) {
			verify(node);
			enterScope();
		}

		return {
			Program: enterScope,
			BlockStatement: enterScope,
			SwitchStatement: enterScope,
			"Program:exit": exitScope,
			"BlockStatement:exit": exitScope,
			"SwitchStatement:exit": exitScope,

			":statement": verify,

			SwitchCase: verifyThenEnterScope,
			"SwitchCase:exit": exitScope
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isFunctionName(variable) {
	return variable && variable.defs[0].type === "FunctionName";
}
function checkMetaProperty(node, metaName, propertyName) {
	return node.meta.name === metaName && node.property.name === propertyName;
}
function getVariableOfArguments(scope) {
	var variables = scope.variables;

	for (var i = 0; i < variables.length; ++i) {
		var variable = variables[i];

		if (variable.name === "arguments") {
			return variable.identifiers.length === 0 ? variable : null;
		}
	}
	return null;
}
function getCallbackInfo(node) {
	var retv = { isCallback: false, isLexicalThis: false };
	var parent = node.parent;

	while (node) {
		switch (parent.type) {
			case "LogicalExpression":
			case "ConditionalExpression":
				break;
			case "MemberExpression":
				if (parent.object === node && !parent.property.computed && parent.property.type === "Identifier" && parent.property.name === "bind" && parent.parent.type === "CallExpression" && parent.parent.callee === parent) {
					retv.isLexicalThis = parent.parent.arguments.length === 1 && parent.parent.arguments[0].type === "ThisExpression";
					parent = parent.parent;
				} else {
					return retv;
				}
				break;
			case "CallExpression":
			case "NewExpression":
				if (parent.callee !== node) {
					retv.isCallback = true;
				}
				return retv;

			default:
				return retv;
		}

		node = parent;
		parent = parent.parent;
	}
	throw new Error("unreachable");
}
function hasDuplicateParams(paramsList) {
	return paramsList.every(function (param) {
		return param.type === "Identifier";
	}) && paramsList.length !== new Set(paramsList.map(function (param) {
		return param.name;
	})).size;
}
module.exports = {
	meta: {
		docs: {
			description: "require using arrow functions for callbacks",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowNamedFunctions: {
					type: "boolean"
				},
				allowUnboundThis: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {
		var options = context.options[0] || {};

		var allowUnboundThis = options.allowUnboundThis !== false; // default to true
		var allowNamedFunctions = options.allowNamedFunctions;
		var sourceCode = context.getSourceCode();
		var stack = [];
		function enterScope() {
			stack.push({ this: false, super: false, meta: false });
		}
		function exitScope() {
			return stack.pop();
		}

		return {
			Program: function Program() {
				stack = [];
			},
			ThisExpression: function ThisExpression() {
				var info = stack[stack.length - 1];

				if (info) {
					info.this = true;
				}
			},
			Super: function Super() {
				var info = stack[stack.length - 1];

				if (info) {
					info.super = true;
				}
			},
			MetaProperty: function MetaProperty(node) {
				var info = stack[stack.length - 1];

				if (info && checkMetaProperty(node, "new", "target")) {
					info.meta = true;
				}
			},
			FunctionDeclaration: enterScope,
			"FunctionDeclaration:exit": exitScope,
			FunctionExpression: enterScope,
			"FunctionExpression:exit": function FunctionExpressionExit(node) {
				var scopeInfo = exitScope();
				if (allowNamedFunctions && node.id && node.id.name) {
					return;
				}
				if (node.generator) {
					return;
				}
				var nameVar = context.getDeclaredVariables(node)[0];

				if (isFunctionName(nameVar) && nameVar.references.length > 0) {
					return;
				}
				var variable = getVariableOfArguments(context.getScope());

				if (variable && variable.references.length > 0) {
					return;
				}
				var callbackInfo = getCallbackInfo(node);

				if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) && !scopeInfo.super && !scopeInfo.meta) {
					context.report({
						node: node,
						message: "Unexpected function expression.",
						fix: function fix(fixer) {
							if (!callbackInfo.isLexicalThis && scopeInfo.this || hasDuplicateParams(node.params)) {
								return null;
							}

							var paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);
							var paramsRightParen = sourceCode.getTokenBefore(node.body);
							var asyncKeyword = node.async ? "async " : "";
							var paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);
							var arrowFunctionText = "" + asyncKeyword + paramsFullText + " => " + sourceCode.getText(node.body);
							var replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;
							var needsParens = replacedNode.parent.type !== "CallExpression" && replacedNode.parent.type !== "ConditionalExpression";
							var replacementText = needsParens ? "(" + arrowFunctionText + ")" : arrowFunctionText;

							return fixer.replaceText(replacedNode, replacementText);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/;
var DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/;
var DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/;
var pushAll = Function.apply.bind(Array.prototype.push);
function isInitOfForStatement(node) {
	return node.parent.type === "ForStatement" && node.parent.init === node;
}
function canBecomeVariableDeclaration(identifier) {
	var node = identifier.parent;

	while (PATTERN_TYPE.test(node.type)) {
		node = node.parent;
	}

	return node.type === "VariableDeclarator" || node.type === "AssignmentExpression" && node.parent.type === "ExpressionStatement" && DECLARATION_HOST_TYPE.test(node.parent.parent.type);
}
function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {
	if (variable.eslintUsed && variable.scope.type === "global") {
		return null;
	}
	var writer = null;
	var isReadBeforeInit = false;
	var references = variable.references;

	for (var i = 0; i < references.length; ++i) {
		var reference = references[i];

		if (reference.isWrite()) {
			var isReassigned = writer !== null && writer.identifier !== reference.identifier;

			if (isReassigned) {
				return null;
			}
			writer = reference;
		} else if (reference.isRead() && writer === null) {
			if (ignoreReadBeforeAssign) {
				return null;
			}
			isReadBeforeInit = true;
		}
	}
	var shouldBeConst = writer !== null && writer.from === variable.scope && canBecomeVariableDeclaration(writer.identifier);

	if (!shouldBeConst) {
		return null;
	}
	if (isReadBeforeInit) {
		return variable.defs[0].name;
	}
	return writer.identifier;
}
function getDestructuringHost(reference) {
	if (!reference.isWrite()) {
		return null;
	}
	var node = reference.identifier.parent;

	while (PATTERN_TYPE.test(node.type)) {
		node = node.parent;
	}

	if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {
		return null;
	}
	return node;
}
function groupByDestructuring(variables, ignoreReadBeforeAssign) {
	var identifierMap = new Map();

	for (var i = 0; i < variables.length; ++i) {
		var variable = variables[i];
		var references = variable.references;
		var identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);
		var prevId = null;

		for (var j = 0; j < references.length; ++j) {
			var reference = references[j];
			var id = reference.identifier;
			if (id === prevId) {
				continue;
			}
			prevId = id;
			var group = getDestructuringHost(reference);

			if (group) {
				if (identifierMap.has(group)) {
					identifierMap.get(group).push(identifier);
				} else {
					identifierMap.set(group, [identifier]);
				}
			}
		}
	}

	return identifierMap;
}
function findUp(node, type, shouldStop) {
	if (!node || shouldStop(node)) {
		return null;
	}
	if (node.type === type) {
		return node;
	}
	return findUp(node.parent, type, shouldStop);
}
module.exports = {
	meta: {
		docs: {
			description: "require `const` declarations for variables that are never reassigned after declared",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "code",

		schema: [{
			type: "object",
			properties: {
				destructuring: { enum: ["any", "all"] },
				ignoreReadBeforeAssign: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var sourceCode = context.getSourceCode();
		var checkingMixedDestructuring = options.destructuring !== "all";
		var ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;
		var variables = [];
		function checkGroup(nodes) {
			var nodesToReport = nodes.filter(Boolean);

			if (nodes.length && (checkingMixedDestructuring || nodesToReport.length === nodes.length)) {
				var varDeclParent = findUp(nodes[0], "VariableDeclaration", function (parentNode) {
					return parentNode.type.endsWith("Statement");
				});
				var shouldFix = varDeclParent &&
				varDeclParent.declarations.length === 1 && (
				varDeclParent.parent.type === "ForInStatement" || varDeclParent.parent.type === "ForOfStatement" || varDeclParent.declarations[0].init) &&
				nodesToReport.length === nodes.length;

				nodesToReport.forEach(function (node) {
					context.report({
						node: node,
						message: "'{{name}}' is never reassigned. Use 'const' instead.",
						data: node,
						fix: shouldFix ? function (fixer) {
							return fixer.replaceText(sourceCode.getFirstToken(varDeclParent), "const");
						} : null
					});
				});
			}
		}

		return {
			"Program:exit": function ProgramExit() {
				groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);
			},
			VariableDeclaration: function VariableDeclaration(node) {
				if (node.kind === "let" && !isInitOfForStatement(node)) {
					pushAll(variables, context.getDeclaredVariables(node));
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require destructuring from arrays and/or objects",
			category: "ECMAScript 6",
			recommended: false
		},
		schema: [{
			oneOf: [{
				type: "object",
				properties: {
					VariableDeclarator: {
						type: "object",
						properties: {
							array: {
								type: "boolean"
							},
							object: {
								type: "boolean"
							}
						},
						additionalProperties: false
					},
					AssignmentExpression: {
						type: "object",
						properties: {
							array: {
								type: "boolean"
							},
							object: {
								type: "boolean"
							}
						},
						additionalProperties: false
					}
				},
				additionalProperties: false
			}, {
				type: "object",
				properties: {
					array: {
						type: "boolean"
					},
					object: {
						type: "boolean"
					}
				},
				additionalProperties: false
			}]
		}, {
			type: "object",
			properties: {
				enforceForRenamedProperties: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},
	create: function create(context) {

		var enabledTypes = context.options[0];
		var enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;
		var normalizedOptions = {
			VariableDeclarator: { array: true, object: true },
			AssignmentExpression: { array: true, object: true }
		};

		if (enabledTypes) {
			normalizedOptions = typeof enabledTypes.array !== "undefined" || typeof enabledTypes.object !== "undefined" ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes } : enabledTypes;
		}
		function shouldCheck(nodeType, destructuringType) {
			return normalizedOptions && normalizedOptions[nodeType] && normalizedOptions[nodeType][destructuringType];
		}
		function isArrayIndexAccess(node) {
			return Number.isInteger(node.property.value);
		}
		function report(reportNode, type) {
			context.report({ node: reportNode, message: "Use {{type}} destructuring.", data: { type: type } });
		}
		function performCheck(leftNode, rightNode, reportNode) {
			if (rightNode.type !== "MemberExpression" || rightNode.object.type === "Super") {
				return;
			}

			if (isArrayIndexAccess(rightNode)) {
				if (shouldCheck(reportNode.type, "array")) {
					report(reportNode, "array");
				}
				return;
			}

			if (shouldCheck(reportNode.type, "object") && enforceForRenamedProperties) {
				report(reportNode, "object");
				return;
			}

			if (shouldCheck(reportNode.type, "object")) {
				var property = rightNode.property;

				if (property.type === "Literal" && leftNode.name === property.value || property.type === "Identifier" && leftNode.name === property.name) {
					report(reportNode, "object");
				}
			}
		}
		function checkVariableDeclarator(node) {
			if (!node.init) {
				return;
			}
			if (node.init.type !== "MemberExpression") {
				return;
			}

			performCheck(node.id, node.init, node);
		}
		function checkAssigmentExpression(node) {
			if (node.operator === "=") {
				performCheck(node.left, node.right, node);
			}
		}
		return {
			VariableDeclarator: checkVariableDeclarator,
			AssignmentExpression: checkAssigmentExpression
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isParseInt(calleeNode) {
	switch (calleeNode.type) {
		case "Identifier":
			return calleeNode.name === "parseInt";
		case "MemberExpression":
			return calleeNode.object.type === "Identifier" && calleeNode.object.name === "Number" && calleeNode.property.type === "Identifier" && calleeNode.property.name === "parseInt";
	}

	return false;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		var radixMap = {
			2: "binary",
			8: "octal",
			16: "hexadecimal"
		};

		var prefixMap = {
			2: "0b",
			8: "0o",
			16: "0x"
		};
		return {
			CallExpression: function CallExpression(node) {
				if (node.arguments.length !== 2) {
					return;
				}
				var radixName = radixMap[node.arguments[1].value];

				if (isParseInt(node.callee) && radixName && node.arguments[0].type === "Literal") {
					context.report({
						node: node,
						message: "Use {{radixName}} literals instead of {{functionName}}().",
						data: {
							radixName: radixName,
							functionName: sourceCode.getText(node.callee)
						},
						fix: function fix(fixer) {
							var newPrefix = prefixMap[node.arguments[1].value];

							if (+(newPrefix + node.arguments[0].value) !== parseInt(node.arguments[0].value, node.arguments[1].value)) {
								return null;
							}
							return fixer.replaceText(node, prefixMap[node.arguments[1].value] + node.arguments[0].value);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require using Error objects as Promise rejection reasons",
			category: "Best Practices",
			recommended: false
		},
		fixable: null,
		schema: [{
			type: "object",
			properties: {
				allowEmptyReject: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var ALLOW_EMPTY_REJECT = context.options.length && context.options[0].allowEmptyReject;
		function checkRejectCall(callExpression) {
			if (!callExpression.arguments.length && ALLOW_EMPTY_REJECT) {
				return;
			}
			if (!callExpression.arguments.length || !astUtils.couldBeError(callExpression.arguments[0]) || callExpression.arguments[0].type === "Identifier" && callExpression.arguments[0].name === "undefined") {
				context.report({
					node: callExpression,
					message: "Expected the Promise rejection reason to be an Error."
				});
			}
		}
		function isPromiseRejectCall(node) {
			return node.callee.type === "MemberExpression" && node.callee.object.type === "Identifier" && node.callee.object.name === "Promise" && node.callee.property.type === "Identifier" && node.callee.property.name === "reject";
		}
		return {
			CallExpression: function CallExpression(node) {
				if (isPromiseRejectCall(node)) {
					checkRejectCall(node);
				}
			},
			"NewExpression:exit": function NewExpressionExit(node) {
				if (node.callee.type === "Identifier" && node.callee.name === "Promise" && node.arguments.length && astUtils.isFunction(node.arguments[0]) && node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === "Identifier") {
					context.getDeclaredVariables(node.arguments[0])
					.find(function (variable) {
						return variable.name === node.arguments[0].params[1].name;
					})
					.references
					.filter(function (ref) {
						return ref.isRead();
					})
					.filter(function (ref) {
						return ref.identifier.parent.type === "CallExpression" && ref.identifier === ref.identifier.parent.callee;
					})
					.forEach(function (ref) {
						return checkRejectCall(ref.identifier.parent);
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require `Reflect` methods where applicable",
			category: "ECMAScript 6",
			recommended: false,
			replacedBy: []
		},

		deprecated: true,

		schema: [{
			type: "object",
			properties: {
				exceptions: {
					type: "array",
					items: {
						enum: ["apply", "call", "delete", "defineProperty", "getOwnPropertyDescriptor", "getPrototypeOf", "setPrototypeOf", "isExtensible", "getOwnPropertyNames", "preventExtensions"]
					},
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var existingNames = {
			apply: "Function.prototype.apply",
			call: "Function.prototype.call",
			defineProperty: "Object.defineProperty",
			getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor",
			getPrototypeOf: "Object.getPrototypeOf",
			setPrototypeOf: "Object.setPrototypeOf",
			isExtensible: "Object.isExtensible",
			getOwnPropertyNames: "Object.getOwnPropertyNames",
			preventExtensions: "Object.preventExtensions"
		};

		var reflectSubsitutes = {
			apply: "Reflect.apply",
			call: "Reflect.apply",
			defineProperty: "Reflect.defineProperty",
			getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor",
			getPrototypeOf: "Reflect.getPrototypeOf",
			setPrototypeOf: "Reflect.setPrototypeOf",
			isExtensible: "Reflect.isExtensible",
			getOwnPropertyNames: "Reflect.getOwnPropertyNames",
			preventExtensions: "Reflect.preventExtensions"
		};

		var exceptions = (context.options[0] || {}).exceptions || [];
		function report(node, existing, substitute) {
			context.report({
				node: node,
				message: "Avoid using {{existing}}, instead use {{substitute}}.",
				data: {
					existing: existing,
					substitute: substitute
				}
			});
		}

		return {
			CallExpression: function CallExpression(node) {
				var methodName = (node.callee.property || {}).name;
				var isReflectCall = (node.callee.object || {}).name === "Reflect";
				var hasReflectSubsitute = reflectSubsitutes.hasOwnProperty(methodName);
				var userConfiguredException = exceptions.indexOf(methodName) !== -1;

				if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {
					report(node, existingNames[methodName], reflectSubsitutes[methodName]);
				}
			},
			UnaryExpression: function UnaryExpression(node) {
				var isDeleteOperator = node.operator === "delete";
				var targetsIdentifier = node.argument.type === "Identifier";
				var userConfiguredException = exceptions.indexOf("delete") !== -1;

				if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {
					report(node, "the delete keyword", "Reflect.deleteProperty");
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function getVariableOfArguments(scope) {
	var variables = scope.variables;

	for (var i = 0; i < variables.length; ++i) {
		var variable = variables[i];

		if (variable.name === "arguments") {
			return variable.identifiers.length === 0 ? variable : null;
		}
	}
	return null;
}
function isNotNormalMemberAccess(reference) {
	var id = reference.identifier;
	var parent = id.parent;

	return !(parent.type === "MemberExpression" && parent.object === id && !parent.computed);
}
module.exports = {
	meta: {
		docs: {
			description: "require rest parameters instead of `arguments`",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function report(reference) {
			context.report({
				node: reference.identifier,
				loc: reference.identifier.loc,
				message: "Use the rest parameters instead of 'arguments'."
			});
		}
		function checkForArguments() {
			var argumentsVar = getVariableOfArguments(context.getScope());

			if (argumentsVar) {
				argumentsVar.references.filter(isNotNormalMemberAccess).forEach(report);
			}
		}

		return {
			"FunctionDeclaration:exit": checkForArguments,
			"FunctionExpression:exit": checkForArguments
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
function isVariadicApplyCalling(node) {
	return node.callee.type === "MemberExpression" && node.callee.property.type === "Identifier" && node.callee.property.name === "apply" && node.callee.computed === false && node.arguments.length === 2 && node.arguments[1].type !== "ArrayExpression" && node.arguments[1].type !== "SpreadElement";
}
function isValidThisArg(expectedThis, thisArg, context) {
	if (!expectedThis) {
		return astUtils.isNullOrUndefined(thisArg);
	}
	return astUtils.equalTokens(expectedThis, thisArg, context);
}
module.exports = {
	meta: {
		docs: {
			description: "require spread operators instead of `.apply()`",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			CallExpression: function CallExpression(node) {
				if (!isVariadicApplyCalling(node)) {
					return;
				}

				var applied = node.callee.object;
				var expectedThis = applied.type === "MemberExpression" ? applied.object : null;
				var thisArg = node.arguments[0];

				if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
					context.report({
						node: node,
						message: "Use the spread operator instead of '.apply()'.",
						fix: function fix(fixer) {
							if (expectedThis && expectedThis.type !== "Identifier") {
								return null;
							}

							var propertyDot = sourceCode.getFirstTokenBetween(applied, node.callee.property, function (token) {
								return token.value === ".";
							});

							return fixer.replaceTextRange([propertyDot.range[0], node.range[1]], "(..." + sourceCode.getText(node.arguments[1]) + ")");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isConcatenation(node) {
	return node.type === "BinaryExpression" && node.operator === "+";
}
function getTopConcatBinaryExpression(node) {
	while (isConcatenation(node.parent)) {
		node = node.parent;
	}
	return node;
}
function hasStringLiteral(node) {
	if (isConcatenation(node)) {
		return hasStringLiteral(node.right) || hasStringLiteral(node.left);
	}
	return astUtils.isStringLiteral(node);
}
function hasNonStringLiteral(node) {
	if (isConcatenation(node)) {
		return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);
	}
	return !astUtils.isStringLiteral(node);
}
function startsWithTemplateCurly(node) {
	if (node.type === "BinaryExpression") {
		return startsWithTemplateCurly(node.left);
	}
	if (node.type === "TemplateLiteral") {
		return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];
	}
	return node.type !== "Literal" || typeof node.value !== "string";
}
function endsWithTemplateCurly(node) {
	if (node.type === "BinaryExpression") {
		return startsWithTemplateCurly(node.right);
	}
	if (node.type === "TemplateLiteral") {
		return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];
	}
	return node.type !== "Literal" || typeof node.value !== "string";
}
module.exports = {
	meta: {
		docs: {
			description: "require template literals instead of string concatenation",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var done = Object.create(null);
		function getTextBetween(node1, node2) {
			var allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);
			var sourceText = sourceCode.getText();

			return allTokens.slice(0, -1).reduce(function (accumulator, token, index) {
				return accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]);
			}, "");
		}
		function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {
			if (currentNode.type === "Literal" && typeof currentNode.value === "string") {
				return "`" + currentNode.raw.slice(1, -1).replace(/\\*(\${|`)/g, function (matched) {
					if (matched.lastIndexOf("\\") % 2) {
						return "\\" + matched;
					}
					return matched;
				}).replace(new RegExp("\\\\" + currentNode.raw[0], "g"), currentNode.raw[0]) + "`";
			}

			if (currentNode.type === "TemplateLiteral") {
				return sourceCode.getText(currentNode);
			}

			if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {
				var plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, function (token) {
					return token.value === "+";
				});
				var textBeforePlus = getTextBetween(currentNode.left, plusSign);
				var textAfterPlus = getTextBetween(plusSign, currentNode.right);
				var leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);
				var rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);

				if (leftEndsWithCurly) {
					return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) + getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);
				}
				if (rightStartsWithCurly) {
					return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) + getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);
				}
				return "" + getTemplateLiteral(currentNode.left, textBeforeNode, null) + textBeforePlus + "+" + textAfterPlus + getTemplateLiteral(currentNode.right, textAfterNode, null);
			}

			return "`${" + (textBeforeNode || "") + sourceCode.getText(currentNode) + (textAfterNode || "") + "}`";
		}
		function checkForStringConcat(node) {
			if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {
				return;
			}

			var topBinaryExpr = getTopConcatBinaryExpression(node.parent);
			if (done[topBinaryExpr.range[0]]) {
				return;
			}
			done[topBinaryExpr.range[0]] = true;

			if (hasNonStringLiteral(topBinaryExpr)) {
				context.report({
					node: topBinaryExpr,
					message: "Unexpected string concatenation.",
					fix: function fix(fixer) {
						return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));
					}
				});
			}
		}

		return {
			Program: function Program() {
				done = Object.create(null);
			},


			Literal: checkForStringConcat,
			TemplateLiteral: checkForStringConcat
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var espree = __webpack_require__(69),
	keywords = __webpack_require__(107);
module.exports = {
	meta: {
		docs: {
			description: "require quotes around object literal property names",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
				}, {
					type: "object",
					properties: {
						keywords: {
							type: "boolean"
						},
						unnecessary: {
							type: "boolean"
						},
						numbers: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		},

		fixable: "code"
	},

	create: function create(context) {

		var MODE = context.options[0],
			KEYWORDS = context.options[1] && context.options[1].keywords,
			CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,
			NUMBERS = context.options[1] && context.options[1].numbers,
			MESSAGE_UNNECESSARY = "Unnecessarily quoted property '{{property}}' found.",
			MESSAGE_UNQUOTED = "Unquoted property '{{property}}' found.",
			MESSAGE_NUMERIC = "Unquoted number literal '{{property}}' used as key.",
			MESSAGE_RESERVED = "Unquoted reserved word '{{property}}' used as key.",
			sourceCode = context.getSourceCode();
		function isKeyword(tokenStr) {
			return keywords.indexOf(tokenStr) >= 0;
		}
		function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {
			return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && (["Identifier", "Keyword", "Null", "Boolean"].indexOf(tokens[0].type) >= 0 || tokens[0].type === "Numeric" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);
		}
		function getUnquotedKey(key) {
			return key.type === "Identifier" ? key.name : key.value;
		}
		function getQuotedKey(key) {
			if (key.type === "Literal" && typeof key.value === "string") {
				return sourceCode.getText(key);
			}
			return "\"" + (key.type === "Identifier" ? key.name : key.value) + "\"";
		}
		function checkUnnecessaryQuotes(node) {
			var key = node.key;

			if (node.method || node.computed || node.shorthand) {
				return;
			}

			if (key.type === "Literal" && typeof key.value === "string") {
				var tokens = void 0;

				try {
					tokens = espree.tokenize(key.value);
				} catch (e) {
					return;
				}

				if (tokens.length !== 1) {
					return;
				}

				var isKeywordToken = isKeyword(tokens[0].value);

				if (isKeywordToken && KEYWORDS) {
					return;
				}

				if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {
					context.report({
						node: node,
						message: MESSAGE_UNNECESSARY,
						data: { property: key.value },
						fix: function fix(fixer) {
							return fixer.replaceText(key, getUnquotedKey(key));
						}
					});
				}
			} else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
				context.report({
					node: node,
					message: MESSAGE_RESERVED,
					data: { property: key.name },
					fix: function fix(fixer) {
						return fixer.replaceText(key, getQuotedKey(key));
					}
				});
			} else if (NUMBERS && key.type === "Literal" && typeof key.value === "number") {
				context.report({
					node: node,
					message: MESSAGE_NUMERIC,
					data: { property: key.value },
					fix: function fix(fixer) {
						return fixer.replaceText(key, getQuotedKey(key));
					}
				});
			}
		}
		function checkOmittedQuotes(node) {
			var key = node.key;

			if (!node.method && !node.computed && !node.shorthand && !(key.type === "Literal" && typeof key.value === "string")) {
				context.report({
					node: node,
					message: MESSAGE_UNQUOTED,
					data: { property: key.name || key.value },
					fix: function fix(fixer) {
						return fixer.replaceText(key, getQuotedKey(key));
					}
				});
			}
		}
		function checkConsistency(node, checkQuotesRedundancy) {
			var quotedProps = [],
				unquotedProps = [];
			var keywordKeyName = null,
				necessaryQuotes = false;

			node.properties.forEach(function (property) {
				var key = property.key;

				if (!key || property.method || property.computed || property.shorthand) {
					return;
				}

				if (key.type === "Literal" && typeof key.value === "string") {

					quotedProps.push(property);

					if (checkQuotesRedundancy) {
						var tokens = void 0;

						try {
							tokens = espree.tokenize(key.value);
						} catch (e) {
							necessaryQuotes = true;
							return;
						}

						necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);
					}
				} else if (KEYWORDS && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
					unquotedProps.push(property);
					necessaryQuotes = true;
					keywordKeyName = key.name;
				} else {
					unquotedProps.push(property);
				}
			});

			if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {
				quotedProps.forEach(function (property) {
					context.report({
						node: property,
						message: "Properties shouldn't be quoted as all quotes are redundant.",
						fix: function fix(fixer) {
							return fixer.replaceText(property.key, getUnquotedKey(property.key));
						}
					});
				});
			} else if (unquotedProps.length && keywordKeyName) {
				unquotedProps.forEach(function (property) {
					context.report({
						node: property,
						message: "Properties should be quoted as '{{property}}' is a reserved word.",
						data: { property: keywordKeyName },
						fix: function fix(fixer) {
							return fixer.replaceText(property.key, getQuotedKey(property.key));
						}
					});
				});
			} else if (quotedProps.length && unquotedProps.length) {
				unquotedProps.forEach(function (property) {
					context.report({
						node: property,
						message: "Inconsistently quoted property '{{key}}' found.",
						data: { key: property.key.name || property.key.value },
						fix: function fix(fixer) {
							return fixer.replaceText(property.key, getQuotedKey(property.key));
						}
					});
				});
			}
		}

		return {
			Property: function Property(node) {
				if (MODE === "always" || !MODE) {
					checkOmittedQuotes(node);
				}
				if (MODE === "as-needed") {
					checkUnnecessaryQuotes(node);
				}
			},
			ObjectExpression: function ObjectExpression(node) {
				if (MODE === "consistent") {
					checkConsistency(node, false);
				}
				if (MODE === "consistent-as-needed") {
					checkConsistency(node, true);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _templateObject = _taggedTemplateLiteral(["(^|[^\\])(\\\\)*[", "]"], ["(^|[^\\\\])(\\\\\\\\)*[", "]"]);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var astUtils = __webpack_require__(0);
var QUOTE_SETTINGS = {
	double: {
		quote: "\"",
		alternateQuote: "'",
		description: "doublequote"
	},
	single: {
		quote: "'",
		alternateQuote: "\"",
		description: "singlequote"
	},
	backtick: {
		quote: "`",
		alternateQuote: "\"",
		description: "backtick"
	}
};
var UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw(_templateObject, Array.from(astUtils.LINEBREAKS).join("")));
QUOTE_SETTINGS.double.convert = QUOTE_SETTINGS.single.convert = QUOTE_SETTINGS.backtick.convert = function (str) {
	var newQuote = this.quote;
	var oldQuote = str[0];

	if (newQuote === oldQuote) {
		return str;
	}
	return newQuote + str.slice(1, -1).replace(/\\(\${|\r\n?|\n|.)|["'`]|\${|(\r\n?|\n)/g, function (match, escaped, newline) {
		if (escaped === oldQuote || oldQuote === "`" && escaped === "${") {
			return escaped; // unescape
		}
		if (match === newQuote || newQuote === "`" && match === "${") {
			return "\\" + match; // escape
		}
		if (newline && oldQuote === "`") {
			return "\\n"; // escape newlines
		}
		return match;
	}) + newQuote;
};

var AVOID_ESCAPE = "avoid-escape";
module.exports = {
	meta: {
		docs: {
			description: "enforce the consistent use of either backticks, double, or single quotes",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "code",

		schema: [{
			enum: ["single", "double", "backtick"]
		}, {
			anyOf: [{
				enum: ["avoid-escape"]
			}, {
				type: "object",
				properties: {
					avoidEscape: {
						type: "boolean"
					},
					allowTemplateLiterals: {
						type: "boolean"
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {

		var quoteOption = context.options[0],
			settings = QUOTE_SETTINGS[quoteOption || "double"],
			options = context.options[1],
			allowTemplateLiterals = options && options.allowTemplateLiterals === true,
			sourceCode = context.getSourceCode();
		var avoidEscape = options && options.avoidEscape === true;
		if (options === AVOID_ESCAPE) {
			avoidEscape = true;
		}
		function isJSXLiteral(node) {
			return node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement";
		}
		function isDirective(node) {
			return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
		}
		function isPartOfDirectivePrologue(node) {
			var block = node.parent.parent;

			if (block.type !== "Program" && (block.type !== "BlockStatement" || !astUtils.isFunction(block.parent))) {
				return false;
			}
			for (var i = 0; i < block.body.length; ++i) {
				var statement = block.body[i];

				if (statement === node.parent) {
					return true;
				}
				if (!isDirective(statement)) {
					break;
				}
			}

			return false;
		}
		function isAllowedAsNonBacktick(node) {
			var parent = node.parent;

			switch (parent.type) {
				case "ExpressionStatement":
					return isPartOfDirectivePrologue(node);
				case "Property":
				case "MethodDefinition":
					return parent.key === node && !parent.computed;
				case "ImportDeclaration":
				case "ExportNamedDeclaration":
				case "ExportAllDeclaration":
					return parent.source === node;
				default:
					return false;
			}
		}

		return {
			Literal: function Literal(node) {
				var val = node.value,
					rawVal = node.raw;

				if (settings && typeof val === "string") {
					var isValid = quoteOption === "backtick" && isAllowedAsNonBacktick(node) || isJSXLiteral(node) || astUtils.isSurroundedBy(rawVal, settings.quote);

					if (!isValid && avoidEscape) {
						isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
					}

					if (!isValid) {
						context.report({
							node: node,
							message: "Strings must use {{description}}.",
							data: {
								description: settings.description
							},
							fix: function fix(fixer) {
								return fixer.replaceText(node, settings.convert(node.raw));
							}
						});
					}
				}
			},
			TemplateLiteral: function TemplateLiteral(node) {
				if (allowTemplateLiterals || quoteOption === "backtick" || node.parent.type === "TaggedTemplateExpression" && node === node.parent.quasi) {
					return;
				}
				var shouldWarn = node.quasis.length === 1 && !UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);

				if (shouldWarn) {
					context.report({
						node: node,
						message: "Strings must use {{description}}.",
						data: {
							description: settings.description
						},
						fix: function fix(fixer) {
							if (isPartOfDirectivePrologue(node)) {
								return null;
							}
							return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var MODE_ALWAYS = "always",
	MODE_AS_NEEDED = "as-needed";
function isShadowed(variable) {
	return variable.defs.length >= 1;
}
function isParseIntMethod(node) {
	return node.type === "MemberExpression" && !node.computed && node.property.type === "Identifier" && node.property.name === "parseInt";
}
function isValidRadix(radix) {
	return !(radix.type === "Literal" && typeof radix.value !== "number" || radix.type === "Identifier" && radix.name === "undefined");
}
function isDefaultRadix(radix) {
	return radix.type === "Literal" && radix.value === 10;
}
module.exports = {
	meta: {
		docs: {
			description: "enforce the consistent use of the radix argument when using `parseInt()`",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			enum: ["always", "as-needed"]
		}]
	},

	create: function create(context) {
		var mode = context.options[0] || MODE_ALWAYS;
		function checkArguments(node) {
			var args = node.arguments;

			switch (args.length) {
				case 0:
					context.report({
						node: node,
						message: "Missing parameters."
					});
					break;

				case 1:
					if (mode === MODE_ALWAYS) {
						context.report({
							node: node,
							message: "Missing radix parameter."
						});
					}
					break;

				default:
					if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {
						context.report({
							node: node,
							message: "Redundant radix parameter."
						});
					} else if (!isValidRadix(args[1])) {
						context.report({
							node: node,
							message: "Invalid radix parameter."
						});
					}
					break;
			}
		}

		return {
			"Program:exit": function ProgramExit() {
				var scope = context.getScope();
				var variable = void 0;
				variable = astUtils.getVariableByName(scope, "parseInt");
				if (!isShadowed(variable)) {
					variable.references.forEach(function (reference) {
						var node = reference.identifier;

						if (astUtils.isCallee(node)) {
							checkArguments(node.parent);
						}
					});
				}
				variable = astUtils.getVariableByName(scope, "Number");
				if (!isShadowed(variable)) {
					variable.references.forEach(function (reference) {
						var node = reference.identifier.parent;

						if (isParseIntMethod(node) && astUtils.isCallee(node)) {
							checkArguments(node.parent);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function capitalizeFirstLetter(text) {
	return text[0].toUpperCase() + text.slice(1);
}
module.exports = {
	meta: {
		docs: {
			description: "disallow async functions which have no `await` expression",
			category: "Best Practices",
			recommended: false
		},
		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var scopeInfo = null;
		function enterFunction() {
			scopeInfo = {
				upper: scopeInfo,
				hasAwait: false
			};
		}
		function exitFunction(node) {
			if (node.async && !scopeInfo.hasAwait && !astUtils.isEmptyFunction(node)) {
				context.report({
					node: node,
					loc: astUtils.getFunctionHeadLoc(node, sourceCode),
					message: "{{name}} has no 'await' expression.",
					data: {
						name: capitalizeFirstLetter(astUtils.getFunctionNameWithKind(node))
					}
				});
			}

			scopeInfo = scopeInfo.upper;
		}

		return {
			FunctionDeclaration: enterFunction,
			FunctionExpression: enterFunction,
			ArrowFunctionExpression: enterFunction,
			"FunctionDeclaration:exit": exitFunction,
			"FunctionExpression:exit": exitFunction,
			"ArrowFunctionExpression:exit": exitFunction,

			AwaitExpression: function AwaitExpression() {
				scopeInfo.hasAwait = true;
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
	meta: {
		docs: {
			description: "require JSDoc comments",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				require: {
					type: "object",
					properties: {
						ClassDeclaration: {
							type: "boolean"
						},
						MethodDefinition: {
							type: "boolean"
						},
						FunctionDeclaration: {
							type: "boolean"
						},
						ArrowFunctionExpression: {
							type: "boolean"
						},
						FunctionExpression: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var source = context.getSourceCode();
		var DEFAULT_OPTIONS = {
			FunctionDeclaration: true,
			MethodDefinition: false,
			ClassDeclaration: false,
			ArrowFunctionExpression: false,
			FunctionExpression: false
		};
		var options = Object.assign(DEFAULT_OPTIONS, context.options[0] && context.options[0].require || {});
		function report(node) {
			context.report({ node: node, message: "Missing JSDoc comment." });
		}
		function checkJsDoc(node) {
			var jsdocComment = source.getJSDocComment(node);

			if (!jsdocComment) {
				report(node);
			}
		}

		return {
			FunctionDeclaration: function FunctionDeclaration(node) {
				if (options.FunctionDeclaration) {
					checkJsDoc(node);
				}
			},
			FunctionExpression: function FunctionExpression(node) {
				if (options.MethodDefinition && node.parent.type === "MethodDefinition" || options.FunctionExpression && (node.parent.type === "VariableDeclarator" || node.parent.type === "Property" && node === node.parent.value)) {
					checkJsDoc(node);
				}
			},
			ClassDeclaration: function ClassDeclaration(node) {
				if (options.ClassDeclaration) {
					checkJsDoc(node);
				}
			},
			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
				if (options.ArrowFunctionExpression && node.parent.type === "VariableDeclarator") {
					checkJsDoc(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require generator functions to contain `yield`",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var stack = [];
		function beginChecking(node) {
			if (node.generator) {
				stack.push(0);
			}
		}
		function endChecking(node) {
			if (!node.generator) {
				return;
			}

			var countYield = stack.pop();

			if (countYield === 0 && node.body.body.length > 0) {
				context.report({ node: node, message: "This generator function does not have 'yield'." });
			}
		}

		return {
			FunctionDeclaration: beginChecking,
			"FunctionDeclaration:exit": endChecking,
			FunctionExpression: beginChecking,
			"FunctionExpression:exit": endChecking,
			YieldExpression: function YieldExpression() {
				if (stack.length > 0) {
					stack[stack.length - 1] += 1;
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce spacing between rest and spread operators and their expressions",
			category: "ECMAScript 6",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			enum: ["always", "never"]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode(),
			alwaysSpace = context.options[0] === "always";
		function checkWhiteSpace(node) {
			var operator = sourceCode.getFirstToken(node),
				nextToken = sourceCode.getTokenAfter(operator),
				hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);
			var type = void 0;

			switch (node.type) {
				case "SpreadElement":
					type = "spread";
					break;
				case "RestElement":
					type = "rest";
					break;
				case "ExperimentalSpreadProperty":
					type = "spread property";
					break;
				case "ExperimentalRestProperty":
					type = "rest property";
					break;
				default:
					return;
			}

			if (alwaysSpace && !hasWhitespace) {
				context.report({
					node: node,
					loc: {
						line: operator.loc.end.line,
						column: operator.loc.end.column
					},
					message: "Expected whitespace after {{type}} operator.",
					data: {
						type: type
					},
					fix: function fix(fixer) {
						return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], " ");
					}
				});
			} else if (!alwaysSpace && hasWhitespace) {
				context.report({
					node: node,
					loc: {
						line: operator.loc.end.line,
						column: operator.loc.end.column
					},
					message: "Unexpected whitespace after {{type}} operator.",
					data: {
						type: type
					},
					fix: function fix(fixer) {
						return fixer.removeRange([operator.range[1], nextToken.range[0]]);
					}
				});
			}
		}
		return {
			SpreadElement: checkWhiteSpace,
			RestElement: checkWhiteSpace,
			ExperimentalSpreadProperty: checkWhiteSpace,
			ExperimentalRestProperty: checkWhiteSpace
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before and after semicolons",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				before: {
					type: "boolean"
				},
				after: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var config = context.options[0],
			sourceCode = context.getSourceCode();
		var requireSpaceBefore = false,
			requireSpaceAfter = true;

		if ((typeof config === "undefined" ? "undefined" : _typeof(config)) === "object") {
			if (config.hasOwnProperty("before")) {
				requireSpaceBefore = config.before;
			}
			if (config.hasOwnProperty("after")) {
				requireSpaceAfter = config.after;
			}
		}
		function hasLeadingSpace(token) {
			var tokenBefore = sourceCode.getTokenBefore(token);

			return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);
		}
		function hasTrailingSpace(token) {
			var tokenAfter = sourceCode.getTokenAfter(token);

			return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);
		}
		function isLastTokenInCurrentLine(token) {
			var tokenAfter = sourceCode.getTokenAfter(token);

			return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
		}
		function isFirstTokenInCurrentLine(token) {
			var tokenBefore = sourceCode.getTokenBefore(token);

			return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));
		}
		function isBeforeClosingParen(token) {
			var nextToken = sourceCode.getTokenAfter(token);

			return nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken);
		}
		function checkSemicolonSpacing(token, node) {
			if (astUtils.isSemicolonToken(token)) {
				var location = token.loc.start;

				if (hasLeadingSpace(token)) {
					if (!requireSpaceBefore) {
						context.report({
							node: node,
							loc: location,
							message: "Unexpected whitespace before semicolon.",
							fix: function fix(fixer) {
								var tokenBefore = sourceCode.getTokenBefore(token);

								return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
							}
						});
					}
				} else {
					if (requireSpaceBefore) {
						context.report({
							node: node,
							loc: location,
							message: "Missing whitespace before semicolon.",
							fix: function fix(fixer) {
								return fixer.insertTextBefore(token, " ");
							}
						});
					}
				}

				if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
					if (hasTrailingSpace(token)) {
						if (!requireSpaceAfter) {
							context.report({
								node: node,
								loc: location,
								message: "Unexpected whitespace after semicolon.",
								fix: function fix(fixer) {
									var tokenAfter = sourceCode.getTokenAfter(token);

									return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
								}
							});
						}
					} else {
						if (requireSpaceAfter) {
							context.report({
								node: node,
								loc: location,
								message: "Missing whitespace after semicolon.",
								fix: function fix(fixer) {
									return fixer.insertTextAfter(token, " ");
								}
							});
						}
					}
				}
			}
		}
		function checkNode(node) {
			var token = sourceCode.getLastToken(node);

			checkSemicolonSpacing(token, node);
		}

		return {
			VariableDeclaration: checkNode,
			ExpressionStatement: checkNode,
			BreakStatement: checkNode,
			ContinueStatement: checkNode,
			DebuggerStatement: checkNode,
			ReturnStatement: checkNode,
			ThrowStatement: checkNode,
			ImportDeclaration: checkNode,
			ExportNamedDeclaration: checkNode,
			ExportAllDeclaration: checkNode,
			ExportDefaultDeclaration: checkNode,
			ForStatement: function ForStatement(node) {
				if (node.init) {
					checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);
				}

				if (node.test) {
					checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var astUtils = __webpack_require__(0);
var SELECTOR = ":matches(" + ["BreakStatement", "ContinueStatement", "DebuggerStatement", "DoWhileStatement", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ImportDeclaration", "ReturnStatement", "ThrowStatement", "VariableDeclaration"].join(",") + ")";
function getChildren(node) {
	var t = node.type;

	if (t === "BlockStatement" || t === "Program") {
		return node.body;
	}
	if (t === "SwitchCase") {
		return node.consequent;
	}
	return null;
}
function isLastChild(node) {
	var t = node.parent.type;

	if (t === "IfStatement" && node.parent.consequent === node && node.parent.alternate) {
		return true;
	}
	if (t === "DoWhileStatement") {
		return true;
	}
	var nodeList = getChildren(node.parent);

	return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.
}

module.exports = {
	meta: {
		docs: {
			description: "enforce location of semicolons",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: [{ enum: ["last", "first"] }],
		fixable: "whitespace"
	},

	create: function create(context) {
		var _ref;

		var sourceCode = context.getSourceCode();
		var option = context.options[0] || "last";
		function check(semiToken, expected) {
			var prevToken = sourceCode.getTokenBefore(semiToken);
			var nextToken = sourceCode.getTokenAfter(semiToken);
			var prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);
			var nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);

			if (expected === "last" && !prevIsSameLine || expected === "first" && !nextIsSameLine) {
				context.report({
					loc: semiToken.loc,
					message: "Expected this semicolon to be at {{pos}}.",
					data: {
						pos: expected === "last" ? "the end of the previous line" : "the beginning of the next line"
					},
					fix: function fix(fixer) {
						if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {
							return null;
						}

						var start = prevToken ? prevToken.range[1] : semiToken.range[0];
						var end = nextToken ? nextToken.range[0] : semiToken.range[1];
						var text = expected === "last" ? ";\n" : "\n;";

						return fixer.replaceTextRange([start, end], text);
					}
				});
			}
		}

		return _ref = {}, _defineProperty(_ref, SELECTOR, function (node) {
			if (option === "first" && isLastChild(node)) {
				return;
			}

			var lastToken = sourceCode.getLastToken(node);

			if (astUtils.isSemicolonToken(lastToken)) {
				check(lastToken, option);
			}
		}), _defineProperty(_ref, "ForStatement", function ForStatement(node) {
			var firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);
			var secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);

			if (firstSemi) {
				check(firstSemi, "last");
			}
			if (secondSemi) {
				check(secondSemi, "last");
			}
		}), _ref;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var FixTracker = __webpack_require__(70);
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow semicolons instead of ASI",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "code",

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["never"]
				}, {
					type: "object",
					properties: {
						beforeStatementContinuationChars: {
							enum: ["always", "any", "never"]
						}
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}, {
				type: "array",
				items: [{
					enum: ["always"]
				}, {
					type: "object",
					properties: {
						omitLastInOneLineBlock: { type: "boolean" }
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		}
	},

	create: function create(context) {

		var OPT_OUT_PATTERN = /^[-[(/+`]/; // One of [(/+-`
		var options = context.options[1];
		var never = context.options[0] === "never";
		var exceptOneLine = Boolean(options && options.omitLastInOneLineBlock);
		var beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || "any";
		var sourceCode = context.getSourceCode();
		function report(node, missing) {
			var lastToken = sourceCode.getLastToken(node);
			var message = void 0,
				fix = void 0,
				loc = lastToken.loc;

			if (!missing) {
				message = "Missing semicolon.";
				loc = loc.end;
				fix = function fix(fixer) {
					return fixer.insertTextAfter(lastToken, ";");
				};
			} else {
				message = "Extra semicolon.";
				loc = loc.start;
				fix = function fix(fixer) {
					return new FixTracker(fixer, sourceCode).retainSurroundingTokens(lastToken).remove(lastToken);
				};
			}

			context.report({
				node: node,
				loc: loc,
				message: message,
				fix: fix
			});
		}
		function isRedundantSemi(semiToken) {
			var nextToken = sourceCode.getTokenAfter(semiToken);

			return !nextToken || astUtils.isClosingBraceToken(nextToken) || astUtils.isSemicolonToken(nextToken);
		}
		function isEndOfArrowBlock(lastToken) {
			if (!astUtils.isClosingBraceToken(lastToken)) {
				return false;
			}
			var node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);

			return node.type === "BlockStatement" && node.parent.type === "ArrowFunctionExpression";
		}
		function isOnSameLineWithNextToken(node) {
			var prevToken = sourceCode.getLastToken(node, 1);
			var nextToken = sourceCode.getTokenAfter(node);

			return !!nextToken && astUtils.isTokenOnSameLine(prevToken, nextToken);
		}
		function maybeAsiHazardAfter(node) {
			var t = node.type;

			if (t === "DoWhileStatement" || t === "BreakStatement" || t === "ContinueStatement" || t === "DebuggerStatement" || t === "ImportDeclaration" || t === "ExportAllDeclaration") {
				return false;
			}
			if (t === "ReturnStatement") {
				return Boolean(node.argument);
			}
			if (t === "ExportNamedDeclaration") {
				return Boolean(node.declaration);
			}
			if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) {
				return false;
			}

			return true;
		}
		function maybeAsiHazardBefore(token) {
			return Boolean(token) && OPT_OUT_PATTERN.test(token.value) && token.value !== "++" && token.value !== "--";
		}
		function canRemoveSemicolon(node) {
			if (isRedundantSemi(sourceCode.getLastToken(node))) {
				return true; // `;;` or `;}`
			}
			if (isOnSameLineWithNextToken(node)) {
				return false; // One liner.
			}
			if (beforeStatementContinuationChars === "never" && !maybeAsiHazardAfter(node)) {
				return true; // ASI works. This statement doesn't connect to the next.
			}
			if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {
				return true; // ASI works. The next token doesn't connect to this statement.
			}

			return false;
		}
		function isOneLinerBlock(node) {
			var parent = node.parent;
			var nextToken = sourceCode.getTokenAfter(node);

			if (!nextToken || nextToken.value !== "}") {
				return false;
			}
			return !!parent && parent.type === "BlockStatement" && parent.loc.start.line === parent.loc.end.line;
		}
		function checkForSemicolon(node) {
			var isSemi = astUtils.isSemicolonToken(sourceCode.getLastToken(node));

			if (never) {
				if (isSemi && canRemoveSemicolon(node)) {
					report(node, true);
				} else if (!isSemi && beforeStatementContinuationChars === "always" && maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {
					report(node);
				}
			} else {
				var oneLinerBlock = exceptOneLine && isOneLinerBlock(node);

				if (isSemi && oneLinerBlock) {
					report(node, true);
				} else if (!isSemi && !oneLinerBlock) {
					report(node);
				}
			}
		}
		function checkForSemicolonForVariableDeclaration(node) {
			var parent = node.parent;

			if ((parent.type !== "ForStatement" || parent.init !== node) && (!/^For(?:In|Of)Statement/.test(parent.type) || parent.left !== node)) {
				checkForSemicolon(node);
			}
		}
		return {
			VariableDeclaration: checkForSemicolonForVariableDeclaration,
			ExpressionStatement: checkForSemicolon,
			ReturnStatement: checkForSemicolon,
			ThrowStatement: checkForSemicolon,
			DoWhileStatement: checkForSemicolon,
			DebuggerStatement: checkForSemicolon,
			BreakStatement: checkForSemicolon,
			ContinueStatement: checkForSemicolon,
			ImportDeclaration: checkForSemicolon,
			ExportAllDeclaration: checkForSemicolon,
			ExportNamedDeclaration: function ExportNamedDeclaration(node) {
				if (!node.declaration) {
					checkForSemicolon(node);
				}
			},
			ExportDefaultDeclaration: function ExportDefaultDeclaration(node) {
				if (!/(?:Class|Function)Declaration/.test(node.declaration.type)) {
					checkForSemicolon(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce sorted import declarations within modules",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				ignoreCase: {
					type: "boolean"
				},
				memberSyntaxSortOrder: {
					type: "array",
					items: {
						enum: ["none", "all", "multiple", "single"]
					},
					uniqueItems: true,
					minItems: 4,
					maxItems: 4
				},
				ignoreMemberSort: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {

		var configuration = context.options[0] || {},
			ignoreCase = configuration.ignoreCase || false,
			ignoreMemberSort = configuration.ignoreMemberSort || false,
			memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || ["none", "all", "multiple", "single"],
			sourceCode = context.getSourceCode();
		var previousDeclaration = null;
		function usedMemberSyntax(node) {
			if (node.specifiers.length === 0) {
				return "none";
			}
			if (node.specifiers[0].type === "ImportNamespaceSpecifier") {
				return "all";
			}
			if (node.specifiers.length === 1) {
				return "single";
			}
			return "multiple";
		}
		function getMemberParameterGroupIndex(node) {
			return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));
		}
		function getFirstLocalMemberName(node) {
			if (node.specifiers[0]) {
				return node.specifiers[0].local.name;
			}
			return null;
		}

		return {
			ImportDeclaration: function ImportDeclaration(node) {
				if (previousDeclaration) {
					var currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),
						previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);
					var currentLocalMemberName = getFirstLocalMemberName(node),
						previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);

					if (ignoreCase) {
						previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();
						currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();
					}
					if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {
						if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {
							context.report({
								node: node,
								message: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.",
								data: {
									syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],
									syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]
								}
							});
						}
					} else {
						if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {
							context.report({
								node: node,
								message: "Imports should be sorted alphabetically."
							});
						}
					}
				}

				if (!ignoreMemberSort) {
					var importSpecifiers = node.specifiers.filter(function (specifier) {
						return specifier.type === "ImportSpecifier";
					});
					var getSortableName = ignoreCase ? function (specifier) {
						return specifier.local.name.toLowerCase();
					} : function (specifier) {
						return specifier.local.name;
					};
					var firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex(function (name, index, array) {
						return array[index - 1] > name;
					});

					if (firstUnsortedIndex !== -1) {
						context.report({
							node: importSpecifiers[firstUnsortedIndex],
							message: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
							data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },
							fix: function fix(fixer) {
								if (importSpecifiers.some(function (specifier) {
									return sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length;
								})) {
									return null;
								}

								return fixer.replaceTextRange([importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]], importSpecifiers
								.slice()
								.sort(function (specifierA, specifierB) {
									var aName = getSortableName(specifierA);
									var bName = getSortableName(specifierB);

									return aName > bName ? 1 : -1;
								})
								.reduce(function (sourceText, specifier, index) {
									var textAfterSpecifier = index === importSpecifiers.length - 1 ? "" : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);

									return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;
								}, ""));
							}
						});
					}
				}

				previousDeclaration = node;
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0),
	naturalCompare = __webpack_require__(630);
function getPropertyName(node) {
	return astUtils.getStaticPropertyName(node) || node.key.name || null;
}
var isValidOrders = {
	asc: function asc(a, b) {
		return a <= b;
	},
	ascI: function ascI(a, b) {
		return a.toLowerCase() <= b.toLowerCase();
	},
	ascN: function ascN(a, b) {
		return naturalCompare(a, b) <= 0;
	},
	ascIN: function ascIN(a, b) {
		return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;
	},
	desc: function desc(a, b) {
		return isValidOrders.asc(b, a);
	},
	descI: function descI(a, b) {
		return isValidOrders.ascI(b, a);
	},
	descN: function descN(a, b) {
		return isValidOrders.ascN(b, a);
	},
	descIN: function descIN(a, b) {
		return isValidOrders.ascIN(b, a);
	}
};
module.exports = {
	meta: {
		docs: {
			description: "require object keys to be sorted",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: [{
			enum: ["asc", "desc"]
		}, {
			type: "object",
			properties: {
				caseSensitive: {
					type: "boolean"
				},
				natural: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var order = context.options[0] || "asc";
		var options = context.options[1];
		var insensitive = (options && options.caseSensitive) === false;
		var natual = Boolean(options && options.natural);
		var isValidOrder = isValidOrders[order + (insensitive ? "I" : "") + (natual ? "N" : "")];
		var stack = null;

		return {
			ObjectExpression: function ObjectExpression() {
				stack = {
					upper: stack,
					prevName: null
				};
			},
			"ObjectExpression:exit": function ObjectExpressionExit() {
				stack = stack.upper;
			},
			Property: function Property(node) {
				if (node.parent.type === "ObjectPattern") {
					return;
				}

				var prevName = stack.prevName;
				var thisName = getPropertyName(node);

				stack.prevName = thisName || prevName;

				if (!prevName || !thisName) {
					return;
				}

				if (!isValidOrder(prevName, thisName)) {
					context.report({
						node: node,
						loc: node.key.loc,
						message: "Expected object keys to be in {{natual}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.",
						data: {
							thisName: thisName,
							prevName: prevName,
							order: order,
							insensitive: insensitive ? "insensitive " : "",
							natual: natual ? "natural " : ""
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var naturalCompare = function naturalCompare(a, b) {
	var i,
	    codeA,
	    codeB = 1,
	    posA = 0,
	    posB = 0,
	    alphabet = String.alphabet;

	function getCode(str, pos, code) {
		if (code) {
			for (i = pos; code = getCode(str, i), code < 76 && code > 65;) {
				++i;
			}return +str.slice(pos - 1, i);
		}
		code = alphabet && alphabet.indexOf(str.charAt(pos));
		return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 // -
		: code < 48 ? code - 1 : code < 58 ? code + 18 // 0-9
		: code < 65 ? code - 11 : code < 91 ? code + 11 // A-Z
		: code < 97 ? code - 37 : code < 123 ? code + 5 // a-z
		: code - 63;
	}

	if ((a += "") != (b += "")) for (; codeB;) {
		codeA = getCode(a, posA++);
		codeB = getCode(b, posB++);

		if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
			codeA = getCode(a, posA, posA);
			codeB = getCode(b, posB, posA = i);
			posB = i;
		}

		if (codeA != codeB) return codeA < codeB ? -1 : 1;
	}
	return 0;
};

try {
	module.exports = naturalCompare;
} catch (e) {
	String.naturalCompare = naturalCompare;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require variables within the same declaration block to be sorted",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				ignoreCase: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {

		var configuration = context.options[0] || {},
			ignoreCase = configuration.ignoreCase || false,
			sourceCode = context.getSourceCode();

		return {
			VariableDeclaration: function VariableDeclaration(node) {
				var idDeclarations = node.declarations.filter(function (decl) {
					return decl.id.type === "Identifier";
				});
				var getSortableName = ignoreCase ? function (decl) {
					return decl.id.name.toLowerCase();
				} : function (decl) {
					return decl.id.name;
				};
				var unfixable = idDeclarations.some(function (decl) {
					return decl.init !== null && decl.init.type !== "Literal";
				});
				var fixed = false;

				idDeclarations.slice(1).reduce(function (memo, decl) {
					var lastVariableName = getSortableName(memo),
						currentVariableName = getSortableName(decl);

					if (currentVariableName < lastVariableName) {
						context.report({
							node: decl,
							message: "Variables within the same declaration block should be sorted alphabetically.",
							fix: function fix(fixer) {
								if (unfixable || fixed) {
									return null;
								}
								return fixer.replaceTextRange([idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]], idDeclarations
								.slice()
								.sort(function (declA, declB) {
									var aName = getSortableName(declA);
									var bName = getSortableName(declB);

									return aName > bName ? 1 : -1;
								})
								.reduce(function (sourceText, identifier, index) {
									var textAfterIdentifier = index === idDeclarations.length - 1 ? "" : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);

									return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;
								}, ""));
							}
						});
						fixed = true;
						return memo;
					}
					return decl;
				}, idDeclarations[0]);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before blocks",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["always", "never"]
			}, {
				type: "object",
				properties: {
					keywords: {
						enum: ["always", "never"]
					},
					functions: {
						enum: ["always", "never"]
					},
					classes: {
						enum: ["always", "never"]
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var config = context.options[0],
			sourceCode = context.getSourceCode();
		var checkFunctions = true,
			checkKeywords = true,
			checkClasses = true;

		if ((typeof config === "undefined" ? "undefined" : _typeof(config)) === "object") {
			checkFunctions = config.functions !== "never";
			checkKeywords = config.keywords !== "never";
			checkClasses = config.classes !== "never";
		} else if (config === "never") {
			checkFunctions = false;
			checkKeywords = false;
			checkClasses = false;
		}
		function isConflicted(token) {
			return token.type === "Punctuator" && token.value === "=>" || token.type === "Keyword";
		}
		function checkPrecedingSpace(node) {
			var precedingToken = sourceCode.getTokenBefore(node);

			if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) {
				var hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);
				var parent = context.getAncestors().pop();
				var requireSpace = void 0;

				if (parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration") {
					requireSpace = checkFunctions;
				} else if (node.type === "ClassBody") {
					requireSpace = checkClasses;
				} else {
					requireSpace = checkKeywords;
				}

				if (requireSpace) {
					if (!hasSpace) {
						context.report({
							node: node,
							message: "Missing space before opening brace.",
							fix: function fix(fixer) {
								return fixer.insertTextBefore(node, " ");
							}
						});
					}
				} else {
					if (hasSpace) {
						context.report({
							node: node,
							message: "Unexpected space before opening brace.",
							fix: function fix(fixer) {
								return fixer.removeRange([precedingToken.range[1], node.range[0]]);
							}
						});
					}
				}
			}
		}
		function checkSpaceBeforeCaseBlock(node) {
			var cases = node.cases;
			var openingBrace = void 0;

			if (cases.length > 0) {
				openingBrace = sourceCode.getTokenBefore(cases[0]);
			} else {
				openingBrace = sourceCode.getLastToken(node, 1);
			}

			checkPrecedingSpace(openingBrace);
		}

		return {
			BlockStatement: checkPrecedingSpace,
			ClassBody: checkPrecedingSpace,
			SwitchStatement: checkSpaceBeforeCaseBlock
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before `function` definition opening parenthesis",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["always", "never"]
			}, {
				type: "object",
				properties: {
					anonymous: {
						enum: ["always", "never", "ignore"]
					},
					named: {
						enum: ["always", "never", "ignore"]
					},
					asyncArrow: {
						enum: ["always", "never", "ignore"]
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var baseConfig = typeof context.options[0] === "string" ? context.options[0] : "always";
		var overrideConfig = _typeof(context.options[0]) === "object" ? context.options[0] : {};
		function isNamedFunction(node) {
			if (node.id) {
				return true;
			}

			var parent = node.parent;

			return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.kind === "get" || parent.kind === "set" || parent.method);
		}
		function getConfigForFunction(node) {
			if (node.type === "ArrowFunctionExpression") {
				if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {
					return overrideConfig.asyncArrow || baseConfig;
				}
			} else if (isNamedFunction(node)) {
				return overrideConfig.named || baseConfig;
			} else if (!node.generator) {
				return overrideConfig.anonymous || baseConfig;
			}

			return "ignore";
		}
		function checkFunction(node) {
			var functionConfig = getConfigForFunction(node);

			if (functionConfig === "ignore") {
				return;
			}

			var rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
			var leftToken = sourceCode.getTokenBefore(rightToken);
			var hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);

			if (hasSpacing && functionConfig === "never") {
				context.report({
					node: node,
					loc: leftToken.loc.end,
					message: "Unexpected space before function parentheses.",
					fix: function fix(fixer) {
						return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
					}
				});
			} else if (!hasSpacing && functionConfig === "always") {
				context.report({
					node: node,
					loc: leftToken.loc.end,
					message: "Missing space before function parentheses.",
					fix: function fix(fixer) {
						return fixer.insertTextAfter(leftToken, " ");
					}
				});
			}
		}

		return {
			ArrowFunctionExpression: checkFunction,
			FunctionDeclaration: checkFunction,
			FunctionExpression: checkFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing inside parentheses",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["always", "never"]
		}, {
			type: "object",
			properties: {
				exceptions: {
					type: "array",
					items: {
						enum: ["{}", "[]", "()", "empty"]
					},
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var MISSING_SPACE_MESSAGE = "There must be a space inside this paren.",
			REJECTED_SPACE_MESSAGE = "There should be no spaces inside this paren.",
			ALWAYS = context.options[0] === "always",
			exceptionsArrayOptions = context.options[1] && context.options[1].exceptions || [],
			options = {};
		var exceptions = void 0;

		if (exceptionsArrayOptions.length) {
			options.braceException = exceptionsArrayOptions.indexOf("{}") !== -1;
			options.bracketException = exceptionsArrayOptions.indexOf("[]") !== -1;
			options.parenException = exceptionsArrayOptions.indexOf("()") !== -1;
			options.empty = exceptionsArrayOptions.indexOf("empty") !== -1;
		}
		function getExceptions() {
			var openers = [],
				closers = [];

			if (options.braceException) {
				openers.push("{");
				closers.push("}");
			}

			if (options.bracketException) {
				openers.push("[");
				closers.push("]");
			}

			if (options.parenException) {
				openers.push("(");
				closers.push(")");
			}

			if (options.empty) {
				openers.push(")");
				closers.push("(");
			}

			return {
				openers: openers,
				closers: closers
			};
		}
		var sourceCode = context.getSourceCode();
		function isOpenerException(token) {
			return token.type === "Punctuator" && exceptions.openers.indexOf(token.value) >= 0;
		}
		function isCloserException(token) {
			return token.type === "Punctuator" && exceptions.closers.indexOf(token.value) >= 0;
		}
		function shouldOpenerHaveSpace(left, right) {
			if (sourceCode.isSpaceBetweenTokens(left, right)) {
				return false;
			}

			if (ALWAYS) {
				if (astUtils.isClosingParenToken(right)) {
					return false;
				}
				return !isOpenerException(right);
			}
			return isOpenerException(right);
		}
		function shouldCloserHaveSpace(left, right) {
			if (astUtils.isOpeningParenToken(left)) {
				return false;
			}

			if (sourceCode.isSpaceBetweenTokens(left, right)) {
				return false;
			}

			if (ALWAYS) {
				return !isCloserException(left);
			}
			return isCloserException(left);
		}
		function shouldOpenerRejectSpace(left, right) {
			if (right.type === "Line") {
				return false;
			}

			if (!astUtils.isTokenOnSameLine(left, right)) {
				return false;
			}

			if (!sourceCode.isSpaceBetweenTokens(left, right)) {
				return false;
			}

			if (ALWAYS) {
				return isOpenerException(right);
			}
			return !isOpenerException(right);
		}
		function shouldCloserRejectSpace(left, right) {
			if (astUtils.isOpeningParenToken(left)) {
				return false;
			}

			if (!astUtils.isTokenOnSameLine(left, right)) {
				return false;
			}

			if (!sourceCode.isSpaceBetweenTokens(left, right)) {
				return false;
			}

			if (ALWAYS) {
				return isCloserException(left);
			}
			return !isCloserException(left);
		}
		return {
			Program: function checkParenSpaces(node) {
				exceptions = getExceptions();
				var tokens = sourceCode.tokensAndComments;

				tokens.forEach(function (token, i) {
					var prevToken = tokens[i - 1];
					var nextToken = tokens[i + 1];

					if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {
						return;
					}

					if (token.value === "(" && shouldOpenerHaveSpace(token, nextToken)) {
						context.report({
							node: node,
							loc: token.loc.start,
							message: MISSING_SPACE_MESSAGE,
							fix: function fix(fixer) {
								return fixer.insertTextAfter(token, " ");
							}
						});
					} else if (token.value === "(" && shouldOpenerRejectSpace(token, nextToken)) {
						context.report({
							node: node,
							loc: token.loc.start,
							message: REJECTED_SPACE_MESSAGE,
							fix: function fix(fixer) {
								return fixer.removeRange([token.range[1], nextToken.range[0]]);
							}
						});
					} else if (token.value === ")" && shouldCloserHaveSpace(prevToken, token)) {
						context.report({
							node: node,
							loc: token.loc.start,
							message: MISSING_SPACE_MESSAGE,
							fix: function fix(fixer) {
								return fixer.insertTextBefore(token, " ");
							}
						});
					} else if (token.value === ")" && shouldCloserRejectSpace(prevToken, token)) {
						context.report({
							node: node,
							loc: token.loc.start,
							message: REJECTED_SPACE_MESSAGE,
							fix: function fix(fixer) {
								return fixer.removeRange([prevToken.range[1], token.range[0]]);
							}
						});
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require spacing around infix operators",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				int32Hint: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;

		var OPERATORS = ["*", "/", "%", "+", "-", "<<", ">>", ">>>", "<", "<=", ">", ">=", "in", "instanceof", "==", "!=", "===", "!==", "&", "^", "|", "&&", "||", "=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "^=", "|=", "?", ":", ",", "**"];

		var sourceCode = context.getSourceCode();
		function getFirstNonSpacedToken(left, right) {
			var tokens = sourceCode.getTokensBetween(left, right, 1);

			for (var i = 1, l = tokens.length - 1; i < l; ++i) {
				var op = tokens[i];

				if ((op.type === "Punctuator" || op.type === "Keyword") && OPERATORS.indexOf(op.value) >= 0 && (tokens[i - 1].range[1] >= op.range[0] || op.range[1] >= tokens[i + 1].range[0])) {
					return op;
				}
			}
			return null;
		}
		function report(mainNode, culpritToken) {
			context.report({
				node: mainNode,
				loc: culpritToken.loc.start,
				message: "Infix operators must be spaced.",
				fix: function fix(fixer) {
					var previousToken = sourceCode.getTokenBefore(culpritToken);
					var afterToken = sourceCode.getTokenAfter(culpritToken);
					var fixString = "";

					if (culpritToken.range[0] - previousToken.range[1] === 0) {
						fixString = " ";
					}

					fixString += culpritToken.value;

					if (afterToken.range[0] - culpritToken.range[1] === 0) {
						fixString += " ";
					}

					return fixer.replaceText(culpritToken, fixString);
				}
			});
		}
		function checkBinary(node) {
			var leftNode = node.left.typeAnnotation ? node.left.typeAnnotation : node.left;
			var rightNode = node.right;

			var nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode);

			if (nonSpacedNode) {
				if (!(int32Hint && sourceCode.getText(node).endsWith("|0"))) {
					report(node, nonSpacedNode);
				}
			}
		}
		function checkConditional(node) {
			var nonSpacedConsequesntNode = getFirstNonSpacedToken(node.test, node.consequent);
			var nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate);

			if (nonSpacedConsequesntNode) {
				report(node, nonSpacedConsequesntNode);
			} else if (nonSpacedAlternateNode) {
				report(node, nonSpacedAlternateNode);
			}
		}
		function checkVar(node) {
			var leftNode = node.id.typeAnnotation ? node.id.typeAnnotation : node.id;
			var rightNode = node.init;

			if (rightNode) {
				var nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode);

				if (nonSpacedNode) {
					report(node, nonSpacedNode);
				}
			}
		}

		return {
			AssignmentExpression: checkBinary,
			AssignmentPattern: checkBinary,
			BinaryExpression: checkBinary,
			LogicalExpression: checkBinary,
			ConditionalExpression: checkConditional,
			VariableDeclarator: checkVar
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before or after unary operators",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				words: {
					type: "boolean"
				},
				nonwords: {
					type: "boolean"
				},
				overrides: {
					type: "object",
					additionalProperties: {
						type: "boolean"
					}
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options && Array.isArray(context.options) && context.options[0] || { words: true, nonwords: false };

		var sourceCode = context.getSourceCode();
		function isFirstBangInBangBangExpression(node) {
			return node && node.type === "UnaryExpression" && node.argument.operator === "!" && node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
		}
		function isArgumentObjectExpression(node) {
			return node.argument && node.argument.type && node.argument.type === "ObjectExpression";
		}
		function overrideExistsForOperator(operator) {
			return options.overrides && options.overrides.hasOwnProperty(operator);
		}
		function overrideEnforcesSpaces(operator) {
			return options.overrides[operator];
		}
		function verifyWordHasSpaces(node, firstToken, secondToken, word) {
			if (secondToken.range[0] === firstToken.range[1]) {
				context.report({
					node: node,
					message: "Unary word operator '{{word}}' must be followed by whitespace.",
					data: {
						word: word
					},
					fix: function fix(fixer) {
						return fixer.insertTextAfter(firstToken, " ");
					}
				});
			}
		}
		function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {
			if (isArgumentObjectExpression(node)) {
				if (secondToken.range[0] > firstToken.range[1]) {
					context.report({
						node: node,
						message: "Unexpected space after unary word operator '{{word}}'.",
						data: {
							word: word
						},
						fix: function fix(fixer) {
							return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
						}
					});
				}
			}
		}
		function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
			word = word || firstToken.value;

			if (overrideExistsForOperator(word)) {
				if (overrideEnforcesSpaces(word)) {
					verifyWordHasSpaces(node, firstToken, secondToken, word);
				} else {
					verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
				}
			} else if (options.words) {
				verifyWordHasSpaces(node, firstToken, secondToken, word);
			} else {
				verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
			}
		}
		function checkForSpacesAfterYield(node) {
			var tokens = sourceCode.getFirstTokens(node, 3),
				word = "yield";

			if (!node.argument || node.delegate) {
				return;
			}

			checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
		}
		function checkForSpacesAfterAwait(node) {
			var tokens = sourceCode.getFirstTokens(node, 3);

			checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], "await");
		}
		function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {
			if (node.prefix) {
				if (isFirstBangInBangBangExpression(node)) {
					return;
				}
				if (firstToken.range[1] === secondToken.range[0]) {
					context.report({
						node: node,
						message: "Unary operator '{{operator}}' must be followed by whitespace.",
						data: {
							operator: firstToken.value
						},
						fix: function fix(fixer) {
							return fixer.insertTextAfter(firstToken, " ");
						}
					});
				}
			} else {
				if (firstToken.range[1] === secondToken.range[0]) {
					context.report({
						node: node,
						message: "Space is required before unary expressions '{{token}}'.",
						data: {
							token: secondToken.value
						},
						fix: function fix(fixer) {
							return fixer.insertTextBefore(secondToken, " ");
						}
					});
				}
			}
		}
		function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {
			if (node.prefix) {
				if (secondToken.range[0] > firstToken.range[1]) {
					context.report({
						node: node,
						message: "Unexpected space after unary operator '{{operator}}'.",
						data: {
							operator: firstToken.value
						},
						fix: function fix(fixer) {
							if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
								return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
							}
							return null;
						}
					});
				}
			} else {
				if (secondToken.range[0] > firstToken.range[1]) {
					context.report({
						node: node,
						message: "Unexpected space before unary operator '{{operator}}'.",
						data: {
							operator: secondToken.value
						},
						fix: function fix(fixer) {
							return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
						}
					});
				}
			}
		}
		function checkForSpaces(node) {
			var tokens = node.type === "UpdateExpression" && !node.prefix ? sourceCode.getLastTokens(node, 2) : sourceCode.getFirstTokens(node, 2);
			var firstToken = tokens[0];
			var secondToken = tokens[1];

			if ((node.type === "NewExpression" || node.prefix) && firstToken.type === "Keyword") {
				checkUnaryWordOperatorForSpaces(node, firstToken, secondToken);
				return;
			}

			var operator = node.prefix ? tokens[0].value : tokens[1].value;

			if (overrideExistsForOperator(operator)) {
				if (overrideEnforcesSpaces(operator)) {
					verifyNonWordsHaveSpaces(node, firstToken, secondToken);
				} else {
					verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
				}
			} else if (options.nonwords) {
				verifyNonWordsHaveSpaces(node, firstToken, secondToken);
			} else {
				verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
			}
		}
		return {
			UnaryExpression: checkForSpaces,
			UpdateExpression: checkForSpaces,
			NewExpression: checkForSpaces,
			YieldExpression: checkForSpacesAfterYield,
			AwaitExpression: checkForSpacesAfterAwait
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var lodash = __webpack_require__(10);
var astUtils = __webpack_require__(0);
function escape(s) {
	var isOneChar = s.length === 1;

	s = lodash.escapeRegExp(s);
	return isOneChar ? s : "(?:" + s + ")";
}
function escapeAndRepeat(s) {
	return escape(s) + "+";
}
function parseMarkersOption(markers) {
	markers = markers ? markers.slice(0) : [];
	if (markers.indexOf("*") === -1) {
		markers.push("*");
	}

	return markers;
}
function createExceptionsPattern(exceptions) {
	var pattern = "";
	if (exceptions.length === 0) {
		pattern += "\\s";
	} else {
		pattern += "(?:\\s|";

		if (exceptions.length === 1) {
			pattern += escapeAndRepeat(exceptions[0]);
		} else {
			pattern += "(?:";
			pattern += exceptions.map(escapeAndRepeat).join("|");
			pattern += ")";
		}
		pattern += "(?:$|[" + Array.from(astUtils.LINEBREAKS).join("") + "]))";
	}

	return pattern;
}
function createAlwaysStylePattern(markers, exceptions) {
	var pattern = "^";
	if (markers.length === 1) {
		pattern += escape(markers[0]);
	} else {
		pattern += "(?:";
		pattern += markers.map(escape).join("|");
		pattern += ")";
	}

	pattern += "?"; // or nothing.
	pattern += createExceptionsPattern(exceptions);

	return new RegExp(pattern);
}
function createNeverStylePattern(markers) {
	var pattern = "^(" + markers.map(escape).join("|") + ")?[ \t]+";

	return new RegExp(pattern);
}
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing after the `//` or `/*` in a comment",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["always", "never"]
		}, {
			type: "object",
			properties: {
				exceptions: {
					type: "array",
					items: {
						type: "string"
					}
				},
				markers: {
					type: "array",
					items: {
						type: "string"
					}
				},
				line: {
					type: "object",
					properties: {
						exceptions: {
							type: "array",
							items: {
								type: "string"
							}
						},
						markers: {
							type: "array",
							items: {
								type: "string"
							}
						}
					},
					additionalProperties: false
				},
				block: {
					type: "object",
					properties: {
						exceptions: {
							type: "array",
							items: {
								type: "string"
							}
						},
						markers: {
							type: "array",
							items: {
								type: "string"
							}
						},
						balanced: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode();
		var requireSpace = context.options[0] !== "never";
		var config = context.options[1] || {};
		var balanced = config.block && config.block.balanced;

		var styleRules = ["block", "line"].reduce(function (rule, type) {
			var markers = parseMarkersOption(config[type] && config[type].markers || config.markers);
			var exceptions = config[type] && config[type].exceptions || config.exceptions || [];
			var endNeverPattern = "[ \t]+$";
			rule[type] = {
				beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
				endRegex: balanced && requireSpace ? new RegExp(createExceptionsPattern(exceptions) + "$") : new RegExp(endNeverPattern),
				hasExceptions: exceptions.length > 0,
				markers: new RegExp("^(" + markers.map(escape).join("|") + ")")
			};

			return rule;
		}, {});
		function reportBegin(node, message, match, refChar) {
			var type = node.type.toLowerCase(),
				commentIdentifier = type === "block" ? "/*" : "//";

			context.report({
				node: node,
				fix: function fix(fixer) {
					var start = node.range[0];
					var end = start + 2;

					if (requireSpace) {
						if (match) {
							end += match[0].length;
						}
						return fixer.insertTextAfterRange([start, end], " ");
					}
					end += match[0].length;
					return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : ""));
				},

				message: message,
				data: { refChar: refChar }
			});
		}
		function reportEnd(node, message, match) {
			context.report({
				node: node,
				fix: function fix(fixer) {
					if (requireSpace) {
						return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], " ");
					}
					var end = node.range[1] - 2,
						start = end - match[0].length;

					return fixer.replaceTextRange([start, end], "");
				},

				message: message
			});
		}
		function checkCommentForSpace(node) {
			var type = node.type.toLowerCase(),
				rule = styleRules[type],
				commentIdentifier = type === "block" ? "/*" : "//";
			if (node.value.length === 0) {
				return;
			}

			var beginMatch = rule.beginRegex.exec(node.value);
			var endMatch = rule.endRegex.exec(node.value);
			if (requireSpace) {
				if (!beginMatch) {
					var hasMarker = rule.markers.exec(node.value);
					var marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;

					if (rule.hasExceptions) {
						reportBegin(node, "Expected exception block, space or tab after '{{refChar}}' in comment.", hasMarker, marker);
					} else {
						reportBegin(node, "Expected space or tab after '{{refChar}}' in comment.", hasMarker, marker);
					}
				}

				if (balanced && type === "block" && !endMatch) {
					reportEnd(node, "Expected space or tab before '*/' in comment.");
				}
			} else {
				if (beginMatch) {
					if (!beginMatch[1]) {
						reportBegin(node, "Unexpected space or tab after '{{refChar}}' in comment.", beginMatch, commentIdentifier);
					} else {
						reportBegin(node, "Unexpected space or tab after marker ({{refChar}}) in comment.", beginMatch, beginMatch[1]);
					}
				}

				if (balanced && type === "block" && endMatch) {
					reportEnd(node, "Unexpected space or tab before '*/' in comment.", endMatch);
				}
			}
		}

		return {
			Program: function Program() {
				var comments = sourceCode.getAllComments();

				comments.filter(function (token) {
					return token.type !== "Shebang";
				}).forEach(checkCommentForSpace);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var messages = {
	function: "Use the function form of 'use strict'.",
	global: "Use the global form of 'use strict'.",
	multiple: "Multiple 'use strict' directives.",
	never: "Strict mode is not permitted.",
	unnecessary: "Unnecessary 'use strict' directive.",
	module: "'use strict' is unnecessary inside of modules.",
	implied: "'use strict' is unnecessary when implied strict mode is enabled.",
	unnecessaryInClasses: "'use strict' is unnecessary inside of classes.",
	nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",
	wrap: "Wrap {{name}} in a function with 'use strict' directive."
};
function getUseStrictDirectives(statements) {
	var directives = [];

	for (var i = 0; i < statements.length; i++) {
		var statement = statements[i];

		if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && statement.expression.value === "use strict") {
			directives[i] = statement;
		} else {
			break;
		}
	}

	return directives;
}
function isSimpleParameter(node) {
	return node.type === "Identifier";
}
function isSimpleParameterList(params) {
	return params.every(isSimpleParameter);
}
module.exports = {
	meta: {
		docs: {
			description: "require or disallow strict mode directives",
			category: "Strict Mode",
			recommended: false
		},

		schema: [{
			enum: ["never", "global", "function", "safe"]
		}],

		fixable: "code"
	},

	create: function create(context) {

		var ecmaFeatures = context.parserOptions.ecmaFeatures || {},
			scopes = [],
			classScopes = [];
		var mode = context.options[0] || "safe";

		if (ecmaFeatures.impliedStrict) {
			mode = "implied";
		} else if (mode === "safe") {
			mode = ecmaFeatures.globalReturn ? "global" : "function";
		}
		function shouldFix(errorType) {
			return errorType === "multiple" || errorType === "unnecessary" || errorType === "module" || errorType === "implied" || errorType === "unnecessaryInClasses";
		}
		function getFixFunction(node) {
			return function (fixer) {
				return fixer.remove(node);
			};
		}
		function reportSlice(nodes, start, end, message, fix) {
			nodes.slice(start, end).forEach(function (node) {
				context.report({ node: node, message: message, fix: fix ? getFixFunction(node) : null });
			});
		}
		function reportAll(nodes, message, fix) {
			reportSlice(nodes, 0, nodes.length, message, fix);
		}
		function reportAllExceptFirst(nodes, message, fix) {
			reportSlice(nodes, 1, nodes.length, message, fix);
		}
		function enterFunctionInFunctionMode(node, useStrictDirectives) {
			var isInClass = classScopes.length > 0,
				isParentGlobal = scopes.length === 0 && classScopes.length === 0,
				isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],
				isStrict = useStrictDirectives.length > 0;

			if (isStrict) {
				if (!isSimpleParameterList(node.params)) {
					context.report({ node: useStrictDirectives[0], message: messages.nonSimpleParameterList });
				} else if (isParentStrict) {
					context.report({ node: useStrictDirectives[0], message: messages.unnecessary, fix: getFixFunction(useStrictDirectives[0]) });
				} else if (isInClass) {
					context.report({ node: useStrictDirectives[0], message: messages.unnecessaryInClasses, fix: getFixFunction(useStrictDirectives[0]) });
				}

				reportAllExceptFirst(useStrictDirectives, messages.multiple, true);
			} else if (isParentGlobal) {
				if (isSimpleParameterList(node.params)) {
					context.report({ node: node, message: messages.function });
				} else {
					context.report({
						node: node,
						message: messages.wrap,
						data: { name: astUtils.getFunctionNameWithKind(node) }
					});
				}
			}

			scopes.push(isParentStrict || isStrict);
		}
		function exitFunctionInFunctionMode() {
			scopes.pop();
		}
		function enterFunction(node) {
			var isBlock = node.body.type === "BlockStatement",
				useStrictDirectives = isBlock ? getUseStrictDirectives(node.body.body) : [];

			if (mode === "function") {
				enterFunctionInFunctionMode(node, useStrictDirectives);
			} else if (useStrictDirectives.length > 0) {
				if (isSimpleParameterList(node.params)) {
					reportAll(useStrictDirectives, messages[mode], shouldFix(mode));
				} else {
					context.report({ node: useStrictDirectives[0], message: messages.nonSimpleParameterList });
					reportAllExceptFirst(useStrictDirectives, messages.multiple, true);
				}
			}
		}

		var rule = {
			Program: function Program(node) {
				var useStrictDirectives = getUseStrictDirectives(node.body);

				if (node.sourceType === "module") {
					mode = "module";
				}

				if (mode === "global") {
					if (node.body.length > 0 && useStrictDirectives.length === 0) {
						context.report({ node: node, message: messages.global });
					}
					reportAllExceptFirst(useStrictDirectives, messages.multiple, true);
				} else {
					reportAll(useStrictDirectives, messages[mode], shouldFix(mode));
				}
			},

			FunctionDeclaration: enterFunction,
			FunctionExpression: enterFunction,
			ArrowFunctionExpression: enterFunction
		};

		if (mode === "function") {
			Object.assign(rule, {
				ClassBody: function ClassBody() {
					classScopes.push(true);
				},
				"ClassBody:exit": function ClassBodyExit() {
					classScopes.pop();
				},


				"FunctionDeclaration:exit": exitFunctionInFunctionMode,
				"FunctionExpression:exit": exitFunctionInFunctionMode,
				"ArrowFunctionExpression:exit": exitFunctionInFunctionMode
			});
		}

		return rule;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce spacing around colons of switch statements",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: [{
			type: "object",
			properties: {
				before: { type: "boolean" },
				after: { type: "boolean" }
			},
			additionalProperties: false
		}],
		fixable: "whitespace"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var options = context.options[0] || {};
		var beforeSpacing = options.before === true; // false by default
		var afterSpacing = options.after !== false; // true by default
		function getColonToken(node) {
			if (node.test) {
				return sourceCode.getTokenAfter(node.test, astUtils.isColonToken);
			}
			return sourceCode.getFirstToken(node, 1);
		}
		function isValidSpacing(left, right, expected) {
			return astUtils.isClosingBraceToken(right) || !astUtils.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === expected;
		}
		function commentsExistBetween(left, right) {
			return sourceCode.getFirstTokenBetween(left, right, {
				includeComments: true,
				filter: astUtils.isCommentToken
			}) !== null;
		}
		function _fix(fixer, left, right, spacing) {
			if (commentsExistBetween(left, right)) {
				return null;
			}
			if (spacing) {
				return fixer.insertTextAfter(left, " ");
			}
			return fixer.removeRange([left.range[1], right.range[0]]);
		}

		return {
			SwitchCase: function SwitchCase(node) {
				var colonToken = getColonToken(node);
				var beforeToken = sourceCode.getTokenBefore(colonToken);
				var afterToken = sourceCode.getTokenAfter(colonToken);

				if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {
					context.report({
						node: node,
						loc: colonToken.loc,
						message: "{{verb}} space(s) before this colon.",
						data: { verb: beforeSpacing ? "Expected" : "Unexpected" },
						fix: function fix(fixer) {
							return _fix(fixer, beforeToken, colonToken, beforeSpacing);
						}
					});
				}
				if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {
					context.report({
						node: node,
						loc: colonToken.loc,
						message: "{{verb}} space(s) after this colon.",
						data: { verb: afterSpacing ? "Expected" : "Unexpected" },
						fix: function fix(fixer) {
							return _fix(fixer, colonToken, afterToken, afterSpacing);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);

module.exports = {
	meta: {
		docs: {
			description: "require symbol descriptions",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function checkArgument(node) {
			if (node.arguments.length === 0) {
				context.report({
					node: node,
					message: "Expected Symbol to have a description."
				});
			}
		}

		return {
			"Program:exit": function ProgramExit() {
				var scope = context.getScope();
				var variable = astUtils.getVariableByName(scope, "Symbol");

				if (variable && variable.defs.length === 0) {
					variable.references.forEach(function (reference) {
						var node = reference.identifier;

						if (astUtils.isCallee(node)) {
							checkArgument(node.parent);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var OPEN_PAREN = /\$\{$/;
var CLOSE_PAREN = /^\}/;
module.exports = {
	meta: {
		docs: {
			description: "require or disallow spacing around embedded expressions of template strings",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{ enum: ["always", "never"] }]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var always = context.options[0] === "always";
		var prefix = always ? "Expected" : "Unexpected";
		function checkSpacingBefore(token) {
			var prevToken = sourceCode.getTokenBefore(token);

			if (prevToken && CLOSE_PAREN.test(token.value) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token) !== always) {
				context.report({
					loc: token.loc.start,
					message: "{{prefix}} space(s) before '}'.",
					data: {
						prefix: prefix
					},
					fix: function fix(fixer) {
						if (always) {
							return fixer.insertTextBefore(token, " ");
						}
						return fixer.removeRange([prevToken.range[1], token.range[0]]);
					}
				});
			}
		}
		function checkSpacingAfter(token) {
			var nextToken = sourceCode.getTokenAfter(token);

			if (nextToken && OPEN_PAREN.test(token.value) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken) !== always) {
				context.report({
					loc: {
						line: token.loc.end.line,
						column: token.loc.end.column - 2
					},
					message: "{{prefix}} space(s) after '${'.",
					data: {
						prefix: prefix
					},
					fix: function fix(fixer) {
						if (always) {
							return fixer.insertTextAfter(token, " ");
						}
						return fixer.removeRange([token.range[1], nextToken.range[0]]);
					}
				});
			}
		}

		return {
			TemplateElement: function TemplateElement(node) {
				var token = sourceCode.getFirstToken(node);

				checkSpacingBefore(token);
				checkSpacingAfter(token);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require or disallow spacing between template tags and their literals",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{ enum: ["always", "never"] }]
	},

	create: function create(context) {
		var never = context.options[0] !== "always";
		var sourceCode = context.getSourceCode();
		function checkSpacing(node) {
			var tagToken = sourceCode.getTokenBefore(node.quasi);
			var literalToken = sourceCode.getFirstToken(node.quasi);
			var hasWhitespace = sourceCode.isSpaceBetweenTokens(tagToken, literalToken);

			if (never && hasWhitespace) {
				context.report({
					node: node,
					loc: tagToken.loc.start,
					message: "Unexpected space between template tag and template literal.",
					fix: function fix(fixer) {
						var comments = sourceCode.getCommentsBefore(node.quasi);
						if (comments.some(function (comment) {
							return comment.type === "Line";
						})) {
							return null;
						}

						return fixer.replaceTextRange([tagToken.range[1], literalToken.range[0]], comments.reduce(function (text, comment) {
							return text + sourceCode.getText(comment);
						}, ""));
					}
				});
			} else if (!never && !hasWhitespace) {
				context.report({
					node: node,
					loc: tagToken.loc.start,
					message: "Missing space between template tag and template literal.",
					fix: function fix(fixer) {
						return fixer.insertTextAfter(tagToken, " ");
					}
				});
			}
		}

		return {
			TaggedTemplateExpression: checkSpacing
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require or disallow Unicode byte order mark (BOM)",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["always", "never"]
		}]
	},

	create: function create(context) {
		return {

			Program: function checkUnicodeBOM(node) {

				var sourceCode = context.getSourceCode(),
					location = { column: 0, line: 1 },
					requireBOM = context.options[0] || "never";

				if (!sourceCode.hasBOM && requireBOM === "always") {
					context.report({
						node: node,
						loc: location,
						message: "Expected Unicode BOM (Byte Order Mark).",
						fix: function fix(fixer) {
							return fixer.insertTextBeforeRange([0, 1], "\uFEFF");
						}
					});
				} else if (sourceCode.hasBOM && requireBOM === "never") {
					context.report({
						node: node,
						loc: location,
						message: "Unexpected Unicode BOM (Byte Order Mark).",
						fix: function fix(fixer) {
							return fixer.removeRange([-1, 0]);
						}
					});
				}
			}

		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require calls to `isNaN()` when checking for `NaN`",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {

		return {
			BinaryExpression: function BinaryExpression(node) {
				if (/^(?:[<>]|[!=]=)=?$/.test(node.operator) && (node.left.name === "NaN" || node.right.name === "NaN")) {
					context.report({ node: node, message: "Use the isNaN function to compare with NaN." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var doctrine = __webpack_require__(164);
module.exports = {
	meta: {
		docs: {
			description: "enforce valid JSDoc comments",
			category: "Possible Errors",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				prefer: {
					type: "object",
					additionalProperties: {
						type: "string"
					}
				},
				preferType: {
					type: "object",
					additionalProperties: {
						type: "string"
					}
				},
				requireReturn: {
					type: "boolean"
				},
				requireParamDescription: {
					type: "boolean"
				},
				requireReturnDescription: {
					type: "boolean"
				},
				matchDescription: {
					type: "string"
				},
				requireReturnType: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = context.options[0] || {},
			prefer = options.prefer || {},
			sourceCode = context.getSourceCode(),
		requireReturn = options.requireReturn !== false,
			requireParamDescription = options.requireParamDescription !== false,
			requireReturnDescription = options.requireReturnDescription !== false,
			requireReturnType = options.requireReturnType !== false,
			preferType = options.preferType || {},
			checkPreferType = Object.keys(preferType).length !== 0;
		var fns = [];
		function isTypeClass(node) {
			return node.type === "ClassExpression" || node.type === "ClassDeclaration";
		}
		function startFunction(node) {
			fns.push({
				returnPresent: node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement" || isTypeClass(node)
			});
		}
		function addReturn(node) {
			var functionState = fns[fns.length - 1];

			if (functionState && node.argument !== null) {
				functionState.returnPresent = true;
			}
		}
		function isValidReturnType(tag) {
			return tag.type === null || tag.type.name === "void" || tag.type.type === "UndefinedLiteral";
		}
		function canTypeBeValidated(type) {
			return type !== "UndefinedLiteral" && // {undefined} as there is no name property available.
			type !== "NullLiteral" && // {null}
			type !== "NullableLiteral" && // {?}
			type !== "FunctionType" && // {function(a)}
			type !== "AllLiteral"; // {*}
		}
		function getCurrentExpectedTypes(type) {
			var currentType = void 0;

			if (type.name) {
				currentType = type.name;
			} else if (type.expression) {
				currentType = type.expression.name;
			}

			var expectedType = currentType && preferType[currentType];

			return {
				currentType: currentType,
				expectedType: expectedType
			};
		}
		function validateType(jsdocNode, type) {
			if (!type || !canTypeBeValidated(type.type)) {
				return;
			}

			var typesToCheck = [];
			var elements = [];

			switch (type.type) {
				case "TypeApplication":
					elements = type.applications[0].type === "UnionType" ? type.applications[0].elements : type.applications;
					typesToCheck.push(getCurrentExpectedTypes(type));
					break;
				case "RecordType":
					elements = type.fields;
					break;
				case "UnionType": // {String|number|Test}
				case "ArrayType":
					elements = type.elements;
					break;
				case "FieldType":
					if (type.value) {
						typesToCheck.push(getCurrentExpectedTypes(type.value));
					}
					break;
				default:
					typesToCheck.push(getCurrentExpectedTypes(type));
			}

			elements.forEach(validateType.bind(null, jsdocNode));

			typesToCheck.forEach(function (typeToCheck) {
				if (typeToCheck.expectedType && typeToCheck.expectedType !== typeToCheck.currentType) {
					context.report({
						node: jsdocNode,
						message: "Use '{{expectedType}}' instead of '{{currentType}}'.",
						data: {
							currentType: typeToCheck.currentType,
							expectedType: typeToCheck.expectedType
						}
					});
				}
			});
		}
		function checkJSDoc(node) {
			var jsdocNode = sourceCode.getJSDocComment(node),
				functionData = fns.pop(),
				params = Object.create(null),
				paramsTags = [];
			var hasReturns = false,
				returnsTag = void 0,
				hasConstructor = false,
				isInterface = false,
				isOverride = false,
				isAbstract = false;
			if (jsdocNode) {
				var jsdoc = void 0;

				try {
					jsdoc = doctrine.parse(jsdocNode.value, {
						strict: true,
						unwrap: true,
						sloppy: true
					});
				} catch (ex) {

					if (/braces/i.test(ex.message)) {
						context.report({ node: jsdocNode, message: "JSDoc type missing brace." });
					} else {
						context.report({ node: jsdocNode, message: "JSDoc syntax error." });
					}

					return;
				}

				jsdoc.tags.forEach(function (tag) {

					switch (tag.title.toLowerCase()) {

						case "param":
						case "arg":
						case "argument":
							paramsTags.push(tag);
							break;

						case "return":
						case "returns":
							hasReturns = true;
							returnsTag = tag;
							break;

						case "constructor":
						case "class":
							hasConstructor = true;
							break;

						case "override":
						case "inheritdoc":
							isOverride = true;
							break;

						case "abstract":
						case "virtual":
							isAbstract = true;
							break;

						case "interface":
							isInterface = true;
							break;
					}
					if (prefer.hasOwnProperty(tag.title) && tag.title !== prefer[tag.title]) {
						context.report({ node: jsdocNode, message: "Use @{{name}} instead.", data: { name: prefer[tag.title] } });
					}
					if (checkPreferType && tag.type) {
						validateType(jsdocNode, tag.type);
					}
				});

				paramsTags.forEach(function (param) {
					if (!param.type) {
						context.report({ node: jsdocNode, message: "Missing JSDoc parameter type for '{{name}}'.", data: { name: param.name } });
					}
					if (!param.description && requireParamDescription) {
						context.report({ node: jsdocNode, message: "Missing JSDoc parameter description for '{{name}}'.", data: { name: param.name } });
					}
					if (params[param.name]) {
						context.report({ node: jsdocNode, message: "Duplicate JSDoc parameter '{{name}}'.", data: { name: param.name } });
					} else if (param.name.indexOf(".") === -1) {
						params[param.name] = 1;
					}
				});

				if (hasReturns) {
					if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {
						context.report({
							node: jsdocNode,
							message: "Unexpected @{{title}} tag; function has no return statement.",
							data: {
								title: returnsTag.title
							}
						});
					} else {
						if (requireReturnType && !returnsTag.type) {
							context.report({ node: jsdocNode, message: "Missing JSDoc return type." });
						}

						if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {
							context.report({ node: jsdocNode, message: "Missing JSDoc return description." });
						}
					}
				}
				if (!isOverride && !hasReturns && !hasConstructor && !isInterface && node.parent.kind !== "get" && node.parent.kind !== "constructor" && node.parent.kind !== "set" && !isTypeClass(node)) {
					if (requireReturn || functionData.returnPresent) {
						context.report({
							node: jsdocNode,
							message: "Missing JSDoc @{{returns}} for function.",
							data: {
								returns: prefer.returns || "returns"
							}
						});
					}
				}
				var jsdocParams = Object.keys(params);

				if (node.params) {
					node.params.forEach(function (param, i) {
						if (param.type === "AssignmentPattern") {
							param = param.left;
						}

						var name = param.name;
						if (param.type === "Identifier") {
							if (jsdocParams[i] && name !== jsdocParams[i]) {
								context.report({
									node: jsdocNode,
									message: "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.",
									data: {
										name: name,
										jsdocName: jsdocParams[i]
									}
								});
							} else if (!params[name] && !isOverride) {
								context.report({
									node: jsdocNode,
									message: "Missing JSDoc for parameter '{{name}}'.",
									data: {
										name: name
									}
								});
							}
						}
					});
				}

				if (options.matchDescription) {
					var regex = new RegExp(options.matchDescription);

					if (!regex.test(jsdoc.description)) {
						context.report({ node: jsdocNode, message: "JSDoc description does not satisfy the regex pattern." });
					}
				}
			}
		}
		return {
			ArrowFunctionExpression: startFunction,
			FunctionExpression: startFunction,
			FunctionDeclaration: startFunction,
			ClassExpression: startFunction,
			ClassDeclaration: startFunction,
			"ArrowFunctionExpression:exit": checkJSDoc,
			"FunctionExpression:exit": checkJSDoc,
			"FunctionDeclaration:exit": checkJSDoc,
			"ClassExpression:exit": checkJSDoc,
			"ClassDeclaration:exit": checkJSDoc,
			ReturnStatement: addReturn
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
	'use strict';

	var Syntax, Token, source, length, index, previous, token, value, esutils, utility;

	esutils = __webpack_require__(68);
	utility = __webpack_require__(165);

	Syntax = {
		NullableLiteral: 'NullableLiteral',
		AllLiteral: 'AllLiteral',
		NullLiteral: 'NullLiteral',
		UndefinedLiteral: 'UndefinedLiteral',
		VoidLiteral: 'VoidLiteral',
		UnionType: 'UnionType',
		ArrayType: 'ArrayType',
		RecordType: 'RecordType',
		FieldType: 'FieldType',
		FunctionType: 'FunctionType',
		ParameterType: 'ParameterType',
		RestType: 'RestType',
		NonNullableType: 'NonNullableType',
		OptionalType: 'OptionalType',
		NullableType: 'NullableType',
		NameExpression: 'NameExpression',
		TypeApplication: 'TypeApplication',
		StringLiteralType: 'StringLiteralType',
		NumericLiteralType: 'NumericLiteralType',
		BooleanLiteralType: 'BooleanLiteralType'
	};

	Token = {
		ILLEGAL: 0, // ILLEGAL
		DOT_LT: 1, // .<
		REST: 2, // ...
		LT: 3, // <
		GT: 4, // >
		LPAREN: 5, // (
		RPAREN: 6, // )
		LBRACE: 7, // {
		RBRACE: 8, // }
		LBRACK: 9, // [
		RBRACK: 10, // ]
		COMMA: 11, // ,
		COLON: 12, // :
		STAR: 13, // *
		PIPE: 14, // |
		QUESTION: 15, // ?
		BANG: 16, // !
		EQUAL: 17, // =
		NAME: 18, // name token
		STRING: 19, // string
		NUMBER: 20, // number
		EOF: 21
	};

	function isTypeName(ch) {
		return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);
	}

	function Context(previous, index, token, value) {
		this._previous = previous;
		this._index = index;
		this._token = token;
		this._value = value;
	}

	Context.prototype.restore = function () {
		previous = this._previous;
		index = this._index;
		token = this._token;
		value = this._value;
	};

	Context.save = function () {
		return new Context(previous, index, token, value);
	};

	function advance() {
		var ch = source.charAt(index);
		index += 1;
		return ch;
	}

	function scanHexEscape(prefix) {
		var i,
			len,
			ch,
			code = 0;

		len = prefix === 'u' ? 4 : 2;
		for (i = 0; i < len; ++i) {
			if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {
				ch = advance();
				code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
			} else {
				return '';
			}
		}
		return String.fromCharCode(code);
	}

	function scanString() {
		var str = '',
			quote,
			ch,
			code,
			unescaped,
			restore; //TODO review removal octal = false
		quote = source.charAt(index);
		++index;

		while (index < length) {
			ch = advance();

			if (ch === quote) {
				quote = '';
				break;
			} else if (ch === '\\') {
				ch = advance();
				if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
					switch (ch) {
						case 'n':
							str += '\n';
							break;
						case 'r':
							str += '\r';
							break;
						case 't':
							str += '\t';
							break;
						case 'u':
						case 'x':
							restore = index;
							unescaped = scanHexEscape(ch);
							if (unescaped) {
								str += unescaped;
							} else {
								index = restore;
								str += ch;
							}
							break;
						case 'b':
							str += '\b';
							break;
						case 'f':
							str += '\f';
							break;
						case 'v':
							str += '\v';
							break;

						default:
							if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
								code = '01234567'.indexOf(ch);
								if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
									code = code * 8 + '01234567'.indexOf(advance());
									if ('0123'.indexOf(ch) >= 0 && index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
										code = code * 8 + '01234567'.indexOf(advance());
									}
								}
								str += String.fromCharCode(code);
							} else {
								str += ch;
							}
							break;
					}
				} else {
					if (ch === '\r' && source.charCodeAt(index) === 0x0A /* '\n' */) {
							++index;
						}
				}
			} else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
				break;
			} else {
				str += ch;
			}
		}

		if (quote !== '') {
			utility.throwError('unexpected quote');
		}

		value = str;
		return Token.STRING;
	}

	function scanNumber() {
		var number, ch;

		number = '';
		ch = source.charCodeAt(index);

		if (ch !== 0x2E /* '.' */) {
				number = advance();
				ch = source.charCodeAt(index);

				if (number === '0') {
					if (ch === 0x78 /* 'x' */ || ch === 0x58 /* 'X' */) {
							number += advance();
							while (index < length) {
								ch = source.charCodeAt(index);
								if (!esutils.code.isHexDigit(ch)) {
									break;
								}
								number += advance();
							}

							if (number.length <= 2) {
								utility.throwError('unexpected token');
							}

							if (index < length) {
								ch = source.charCodeAt(index);
								if (esutils.code.isIdentifierStartES5(ch)) {
									utility.throwError('unexpected token');
								}
							}
							value = parseInt(number, 16);
							return Token.NUMBER;
						}

					if (esutils.code.isOctalDigit(ch)) {
						number += advance();
						while (index < length) {
							ch = source.charCodeAt(index);
							if (!esutils.code.isOctalDigit(ch)) {
								break;
							}
							number += advance();
						}

						if (index < length) {
							ch = source.charCodeAt(index);
							if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {
								utility.throwError('unexpected token');
							}
						}
						value = parseInt(number, 8);
						return Token.NUMBER;
					}

					if (esutils.code.isDecimalDigit(ch)) {
						utility.throwError('unexpected token');
					}
				}

				while (index < length) {
					ch = source.charCodeAt(index);
					if (!esutils.code.isDecimalDigit(ch)) {
						break;
					}
					number += advance();
				}
			}

		if (ch === 0x2E /* '.' */) {
				number += advance();
				while (index < length) {
					ch = source.charCodeAt(index);
					if (!esutils.code.isDecimalDigit(ch)) {
						break;
					}
					number += advance();
				}
			}

		if (ch === 0x65 /* 'e' */ || ch === 0x45 /* 'E' */) {
				number += advance();

				ch = source.charCodeAt(index);
				if (ch === 0x2B /* '+' */ || ch === 0x2D /* '-' */) {
						number += advance();
					}

				ch = source.charCodeAt(index);
				if (esutils.code.isDecimalDigit(ch)) {
					number += advance();
					while (index < length) {
						ch = source.charCodeAt(index);
						if (!esutils.code.isDecimalDigit(ch)) {
							break;
						}
						number += advance();
					}
				} else {
					utility.throwError('unexpected token');
				}
			}

		if (index < length) {
			ch = source.charCodeAt(index);
			if (esutils.code.isIdentifierStartES5(ch)) {
				utility.throwError('unexpected token');
			}
		}

		value = parseFloat(number);
		return Token.NUMBER;
	}

	function scanTypeName() {
		var ch, ch2;

		value = advance();
		while (index < length && isTypeName(source.charCodeAt(index))) {
			ch = source.charCodeAt(index);
			if (ch === 0x2E /* '.' */) {
					if (index + 1 >= length) {
						return Token.ILLEGAL;
					}
					ch2 = source.charCodeAt(index + 1);
					if (ch2 === 0x3C /* '<' */) {
							break;
						}
				}
			value += advance();
		}
		return Token.NAME;
	}

	function next() {
		var ch;

		previous = index;

		while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {
			advance();
		}
		if (index >= length) {
			token = Token.EOF;
			return token;
		}

		ch = source.charCodeAt(index);
		switch (ch) {
			case 0x27: /* ''' */
			case 0x22:
				token = scanString();
				return token;

			case 0x3A:
				advance();
				token = Token.COLON;
				return token;

			case 0x2C:
				advance();
				token = Token.COMMA;
				return token;

			case 0x28:
				advance();
				token = Token.LPAREN;
				return token;

			case 0x29:
				advance();
				token = Token.RPAREN;
				return token;

			case 0x5B:
				advance();
				token = Token.LBRACK;
				return token;

			case 0x5D:
				advance();
				token = Token.RBRACK;
				return token;

			case 0x7B:
				advance();
				token = Token.LBRACE;
				return token;

			case 0x7D:
				advance();
				token = Token.RBRACE;
				return token;

			case 0x2E:
				if (index + 1 < length) {
					ch = source.charCodeAt(index + 1);
					if (ch === 0x3C /* '<' */) {
							advance(); // '.'
							advance(); // '<'
							token = Token.DOT_LT;
							return token;
						}

					if (ch === 0x2E /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E /* '.' */) {
							advance(); // '.'
							advance(); // '.'
							advance(); // '.'
							token = Token.REST;
							return token;
						}

					if (esutils.code.isDecimalDigit(ch)) {
						token = scanNumber();
						return token;
					}
				}
				token = Token.ILLEGAL;
				return token;

			case 0x3C:
				advance();
				token = Token.LT;
				return token;

			case 0x3E:
				advance();
				token = Token.GT;
				return token;

			case 0x2A:
				advance();
				token = Token.STAR;
				return token;

			case 0x7C:
				advance();
				token = Token.PIPE;
				return token;

			case 0x3F:
				advance();
				token = Token.QUESTION;
				return token;

			case 0x21:
				advance();
				token = Token.BANG;
				return token;

			case 0x3D:
				advance();
				token = Token.EQUAL;
				return token;

			case 0x2D:
				token = scanNumber();
				return token;

			default:
				if (esutils.code.isDecimalDigit(ch)) {
					token = scanNumber();
					return token;
				}
				//
				//
				utility.assert(isTypeName(ch));
				token = scanTypeName();
				return token;
		}
	}

	function consume(target, text) {
		utility.assert(token === target, text || 'consumed token not matched');
		next();
	}

	function expect(target, message) {
		if (token !== target) {
			utility.throwError(message || 'unexpected token');
		}
		next();
	}
	//
	//
	function parseUnionType() {
		var elements;
		consume(Token.LPAREN, 'UnionType should start with (');
		elements = [];
		if (token !== Token.RPAREN) {
			while (true) {
				elements.push(parseTypeExpression());
				if (token === Token.RPAREN) {
					break;
				}
				expect(Token.PIPE);
			}
		}
		consume(Token.RPAREN, 'UnionType should end with )');
		return {
			type: Syntax.UnionType,
			elements: elements
		};
	}
	//
	function parseArrayType() {
		var elements;
		consume(Token.LBRACK, 'ArrayType should start with [');
		elements = [];
		while (token !== Token.RBRACK) {
			if (token === Token.REST) {
				consume(Token.REST);
				elements.push({
					type: Syntax.RestType,
					expression: parseTypeExpression()
				});
				break;
			} else {
				elements.push(parseTypeExpression());
			}
			if (token !== Token.RBRACK) {
				expect(Token.COMMA);
			}
		}
		expect(Token.RBRACK);
		return {
			type: Syntax.ArrayType,
			elements: elements
		};
	}

	function parseFieldName() {
		var v = value;
		if (token === Token.NAME || token === Token.STRING) {
			next();
			return v;
		}

		if (token === Token.NUMBER) {
			consume(Token.NUMBER);
			return String(v);
		}

		utility.throwError('unexpected token');
	}
	//
	function parseFieldType() {
		var key;

		key = parseFieldName();
		if (token === Token.COLON) {
			consume(Token.COLON);
			return {
				type: Syntax.FieldType,
				key: key,
				value: parseTypeExpression()
			};
		}
		return {
			type: Syntax.FieldType,
			key: key,
			value: null
		};
	}
	//
	function parseRecordType() {
		var fields;

		consume(Token.LBRACE, 'RecordType should start with {');
		fields = [];
		if (token === Token.COMMA) {
			consume(Token.COMMA);
		} else {
			while (token !== Token.RBRACE) {
				fields.push(parseFieldType());
				if (token !== Token.RBRACE) {
					expect(Token.COMMA);
				}
			}
		}
		expect(Token.RBRACE);
		return {
			type: Syntax.RecordType,
			fields: fields
		};
	}
	//
	function parseNameExpression() {
		var name = value;
		expect(Token.NAME);

		if (token === Token.COLON && (name === 'module' || name === 'external' || name === 'event')) {
			consume(Token.COLON);
			name += ':' + value;
			expect(Token.NAME);
		}

		return {
			type: Syntax.NameExpression,
			name: name
		};
	}
	function parseTypeExpressionList() {
		var elements = [];

		elements.push(parseTop());
		while (token === Token.COMMA) {
			consume(Token.COMMA);
			elements.push(parseTop());
		}
		return elements;
	}
	//
	function parseTypeName() {
		var expr, applications;

		expr = parseNameExpression();
		if (token === Token.DOT_LT || token === Token.LT) {
			next();
			applications = parseTypeExpressionList();
			expect(Token.GT);
			return {
				type: Syntax.TypeApplication,
				expression: expr,
				applications: applications
			};
		}
		return expr;
	}
	//
	function parseResultType() {
		consume(Token.COLON, 'ResultType should start with :');
		if (token === Token.NAME && value === 'void') {
			consume(Token.NAME);
			return {
				type: Syntax.VoidLiteral
			};
		}
		return parseTypeExpression();
	}
	//
	//
	//
	//
	//
	//
	function parseParametersType() {
		var params = [],
			optionalSequence = false,
			expr,
			rest = false;

		while (token !== Token.RPAREN) {
			if (token === Token.REST) {
				consume(Token.REST);
				rest = true;
			}

			expr = parseTypeExpression();
			if (expr.type === Syntax.NameExpression && token === Token.COLON) {
				consume(Token.COLON);
				expr = {
					type: Syntax.ParameterType,
					name: expr.name,
					expression: parseTypeExpression()
				};
			}
			if (token === Token.EQUAL) {
				consume(Token.EQUAL);
				expr = {
					type: Syntax.OptionalType,
					expression: expr
				};
				optionalSequence = true;
			} else {
				if (optionalSequence) {
					utility.throwError('unexpected token');
				}
			}
			if (rest) {
				expr = {
					type: Syntax.RestType,
					expression: expr
				};
			}
			params.push(expr);
			if (token !== Token.RPAREN) {
				expect(Token.COMMA);
			}
		}
		return params;
	}
	//
	function parseFunctionType() {
		var isNew, thisBinding, params, result, fnType;
		utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \'function\'');
		consume(Token.NAME);
		expect(Token.LPAREN);

		isNew = false;
		params = [];
		thisBinding = null;
		if (token !== Token.RPAREN) {
			if (token === Token.NAME && (value === 'this' || value === 'new')) {
				isNew = value === 'new';
				consume(Token.NAME);
				expect(Token.COLON);
				thisBinding = parseTypeName();
				if (token === Token.COMMA) {
					consume(Token.COMMA);
					params = parseParametersType();
				}
			} else {
				params = parseParametersType();
			}
		}

		expect(Token.RPAREN);

		result = null;
		if (token === Token.COLON) {
			result = parseResultType();
		}

		fnType = {
			type: Syntax.FunctionType,
			params: params,
			result: result
		};
		if (thisBinding) {
			fnType['this'] = thisBinding;
			if (isNew) {
				fnType['new'] = true;
			}
		}
		return fnType;
	}
	function parseBasicTypeExpression() {
		var context;
		switch (token) {
			case Token.STAR:
				consume(Token.STAR);
				return {
					type: Syntax.AllLiteral
				};

			case Token.LPAREN:
				return parseUnionType();

			case Token.LBRACK:
				return parseArrayType();

			case Token.LBRACE:
				return parseRecordType();

			case Token.NAME:
				if (value === 'null') {
					consume(Token.NAME);
					return {
						type: Syntax.NullLiteral
					};
				}

				if (value === 'undefined') {
					consume(Token.NAME);
					return {
						type: Syntax.UndefinedLiteral
					};
				}

				if (value === 'true' || value === 'false') {
					consume(Token.NAME);
					return {
						type: Syntax.BooleanLiteralType,
						value: value === 'true'
					};
				}

				context = Context.save();
				if (value === 'function') {
					try {
						return parseFunctionType();
					} catch (e) {
						context.restore();
					}
				}

				return parseTypeName();

			case Token.STRING:
				next();
				return {
					type: Syntax.StringLiteralType,
					value: value
				};

			case Token.NUMBER:
				next();
				return {
					type: Syntax.NumericLiteralType,
					value: value
				};

			default:
				utility.throwError('unexpected token');
		}
	}
	function parseTypeExpression() {
		var expr;

		if (token === Token.QUESTION) {
			consume(Token.QUESTION);
			if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE || token === Token.RPAREN || token === Token.PIPE || token === Token.EOF || token === Token.RBRACK || token === Token.GT) {
				return {
					type: Syntax.NullableLiteral
				};
			}
			return {
				type: Syntax.NullableType,
				expression: parseBasicTypeExpression(),
				prefix: true
			};
		}

		if (token === Token.BANG) {
			consume(Token.BANG);
			return {
				type: Syntax.NonNullableType,
				expression: parseBasicTypeExpression(),
				prefix: true
			};
		}

		expr = parseBasicTypeExpression();
		if (token === Token.BANG) {
			consume(Token.BANG);
			return {
				type: Syntax.NonNullableType,
				expression: expr,
				prefix: false
			};
		}

		if (token === Token.QUESTION) {
			consume(Token.QUESTION);
			return {
				type: Syntax.NullableType,
				expression: expr,
				prefix: false
			};
		}

		if (token === Token.LBRACK) {
			consume(Token.LBRACK);
			expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');
			return {
				type: Syntax.TypeApplication,
				expression: {
					type: Syntax.NameExpression,
					name: 'Array'
				},
				applications: [expr]
			};
		}

		return expr;
	}
	//
	function parseTop() {
		var expr, elements;

		expr = parseTypeExpression();
		if (token !== Token.PIPE) {
			return expr;
		}

		elements = [expr];
		consume(Token.PIPE);
		while (true) {
			elements.push(parseTypeExpression());
			if (token !== Token.PIPE) {
				break;
			}
			consume(Token.PIPE);
		}

		return {
			type: Syntax.UnionType,
			elements: elements
		};
	}

	function parseTopParamType() {
		var expr;

		if (token === Token.REST) {
			consume(Token.REST);
			return {
				type: Syntax.RestType,
				expression: parseTop()
			};
		}

		expr = parseTop();
		if (token === Token.EQUAL) {
			consume(Token.EQUAL);
			return {
				type: Syntax.OptionalType,
				expression: expr
			};
		}

		return expr;
	}

	function parseType(src, opt) {
		var expr;

		source = src;
		length = source.length;
		index = 0;
		previous = 0;

		next();
		expr = parseTop();

		if (opt && opt.midstream) {
			return {
				expression: expr,
				index: previous
			};
		}

		if (token !== Token.EOF) {
			utility.throwError('not reach to EOF');
		}

		return expr;
	}

	function parseParamType(src, opt) {
		var expr;

		source = src;
		length = source.length;
		index = 0;
		previous = 0;

		next();
		expr = parseTopParamType();

		if (opt && opt.midstream) {
			return {
				expression: expr,
				index: previous
			};
		}

		if (token !== Token.EOF) {
			utility.throwError('not reach to EOF');
		}

		return expr;
	}

	function stringifyImpl(node, compact, topLevel) {
		var result, i, iz;

		switch (node.type) {
			case Syntax.NullableLiteral:
				result = '?';
				break;

			case Syntax.AllLiteral:
				result = '*';
				break;

			case Syntax.NullLiteral:
				result = 'null';
				break;

			case Syntax.UndefinedLiteral:
				result = 'undefined';
				break;

			case Syntax.VoidLiteral:
				result = 'void';
				break;

			case Syntax.UnionType:
				if (!topLevel) {
					result = '(';
				} else {
					result = '';
				}

				for (i = 0, iz = node.elements.length; i < iz; ++i) {
					result += stringifyImpl(node.elements[i], compact);
					if (i + 1 !== iz) {
						result += compact ? '|' : ' | ';
					}
				}

				if (!topLevel) {
					result += ')';
				}
				break;

			case Syntax.ArrayType:
				result = '[';
				for (i = 0, iz = node.elements.length; i < iz; ++i) {
					result += stringifyImpl(node.elements[i], compact);
					if (i + 1 !== iz) {
						result += compact ? ',' : ', ';
					}
				}
				result += ']';
				break;

			case Syntax.RecordType:
				result = '{';
				for (i = 0, iz = node.fields.length; i < iz; ++i) {
					result += stringifyImpl(node.fields[i], compact);
					if (i + 1 !== iz) {
						result += compact ? ',' : ', ';
					}
				}
				result += '}';
				break;

			case Syntax.FieldType:
				if (node.value) {
					result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);
				} else {
					result = node.key;
				}
				break;

			case Syntax.FunctionType:
				result = compact ? 'function(' : 'function (';

				if (node['this']) {
					if (node['new']) {
						result += compact ? 'new:' : 'new: ';
					} else {
						result += compact ? 'this:' : 'this: ';
					}

					result += stringifyImpl(node['this'], compact);

					if (node.params.length !== 0) {
						result += compact ? ',' : ', ';
					}
				}

				for (i = 0, iz = node.params.length; i < iz; ++i) {
					result += stringifyImpl(node.params[i], compact);
					if (i + 1 !== iz) {
						result += compact ? ',' : ', ';
					}
				}

				result += ')';

				if (node.result) {
					result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);
				}
				break;

			case Syntax.ParameterType:
				result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);
				break;

			case Syntax.RestType:
				result = '...';
				if (node.expression) {
					result += stringifyImpl(node.expression, compact);
				}
				break;

			case Syntax.NonNullableType:
				if (node.prefix) {
					result = '!' + stringifyImpl(node.expression, compact);
				} else {
					result = stringifyImpl(node.expression, compact) + '!';
				}
				break;

			case Syntax.OptionalType:
				result = stringifyImpl(node.expression, compact) + '=';
				break;

			case Syntax.NullableType:
				if (node.prefix) {
					result = '?' + stringifyImpl(node.expression, compact);
				} else {
					result = stringifyImpl(node.expression, compact) + '?';
				}
				break;

			case Syntax.NameExpression:
				result = node.name;
				break;

			case Syntax.TypeApplication:
				result = stringifyImpl(node.expression, compact) + '.<';
				for (i = 0, iz = node.applications.length; i < iz; ++i) {
					result += stringifyImpl(node.applications[i], compact);
					if (i + 1 !== iz) {
						result += compact ? ',' : ', ';
					}
				}
				result += '>';
				break;

			case Syntax.StringLiteralType:
				result = '"' + node.value + '"';
				break;

			case Syntax.NumericLiteralType:
				result = String(node.value);
				break;

			case Syntax.BooleanLiteralType:
				result = String(node.value);
				break;

			default:
				utility.throwError('Unknown type ' + node.type);
		}

		return result;
	}

	function stringify(node, options) {
		if (options == null) {
			options = {};
		}
		return stringifyImpl(node, options.compact, options.topLevel);
	}

	exports.parseType = parseType;
	exports.parseParamType = parseParamType;
	exports.stringify = stringify;
	exports.Syntax = Syntax;
})();
 }),
 (function(module, exports) {

module.exports = {"_from":"doctrine@^2.0.2","_id":"doctrine@2.0.2","_inBundle":false,"_integrity":"sha512-y0tm5Pq6ywp3qSTZ1vPgVdAnbDEoeoc5wlOHXoY1c4Wug/a7JvqHIl7BTvwodaHmejWkK/9dSb3sCYfyo/om8A==","_location":"/doctrine","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"doctrine@^2.0.2","name":"doctrine","escapedName":"doctrine","rawSpec":"^2.0.2","saveSpec":null,"fetchSpec":"^2.0.2"},"_requiredBy":["/eslint","/eslint-plugin-react"],"_resolved":"https://registry.npmjs.org/doctrine/-/doctrine-2.0.2.tgz","_shasum":"68f96ce8efc56cc42651f1faadb4f175273b0075","_spec":"doctrine@^2.0.2","_where":"J:\\Chromium\\newclient\\plugins\\c9.ide.language.javascript.eslint\\packager\\node_modules\\eslint","bugs":{"url":"https://github.com/eslint/doctrine/issues"},"bundleDependencies":false,"dependencies":{"esutils":"^2.0.2"},"deprecated":false,"description":"JSDoc parser","devDependencies":{"coveralls":"^2.11.2","dateformat":"^1.0.11","eslint":"^1.10.3","eslint-release":"^0.10.0","linefix":"^0.1.1","mocha":"^3.4.2","npm-license":"^0.3.1","nyc":"^10.3.2","semver":"^5.0.3","shelljs":"^0.5.3","shelljs-nodecli":"^0.1.1","should":"^5.0.1"},"directories":{"lib":"./lib"},"engines":{"node":">=0.10.0"},"files":["lib"],"homepage":"https://github.com/eslint/doctrine","license":"Apache-2.0","main":"lib/doctrine.js","maintainers":[{"name":"Nicholas C. Zakas","email":"nicholas+npm@nczconsulting.com","url":"https://www.nczonline.net"},{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","url":"https://github.com/Constellation"}],"name":"doctrine","repository":{"type":"git","url":"git+https://github.com/eslint/doctrine.git"},"scripts":{"alpharelease":"eslint-prerelease alpha","betarelease":"eslint-prerelease beta","ci-release":"eslint-ci-release","coveralls":"nyc report --reporter=text-lcov | coveralls","lint":"eslint lib/","pretest":"npm run lint","release":"eslint-release","test":"nyc mocha"},"version":"2.0.2"}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function compare(a, b) {
  if (a === b) {
	return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	if (a[i] !== b[i]) {
			x = a[i];
			y = b[i];
			break;
	}
  }

  if (x < y) {
	return -1;
  }
  if (y < x) {
	return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}
//
//
//
//
//
var util = __webpack_require__(108);
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = function () {
  return function foo() {}.name === 'foo';
}();
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
	return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
	return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
	return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
	return false;
  }
  if (arrbuf instanceof DataView) {
	return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	return true;
  }
  return false;
}
var assert = module.exports = ok;
var regex = /\s*function\s+([^\(\s]*)\s*/;
function getName(func) {
  if (!util.isFunction(func)) {
	return;
  }
  if (functionsHaveNames) {
	return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
	this.message = options.message;
	this.generatedMessage = false;
  } else {
	this.message = getMessage(this);
	this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
	Error.captureStackTrace(this, stackStartFunction);
  } else {
	var err = new Error();
	if (err.stack) {
			var out = err.stack;
			var fn_name = getName(stackStartFunction);
			var idx = out.indexOf('\n' + fn_name);
			if (idx >= 0) {
		var next_line = out.indexOf('\n', idx + 1);
		out = out.substring(next_line + 1);
			}

			this.stack = out;
	}
  }
};
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
	return s.length < n ? s : s.slice(0, n);
  } else {
	return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
	return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
	message: message,
	actual: actual,
	expected: expected,
	operator: operator,
	stackStartFunction: stackStartFunction
  });
}
assert.fail = fail;
function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;
assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};
assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
	fail(actual, expected, message, '!=', assert.notEqual);
  }
};
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
	fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
	fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
	return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
	return compare(actual, expected) === 0;
  } else if (util.isDate(actual) && util.isDate(expected)) {
	return actual.getTime() === expected.getTime();
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) !== 'object') && (expected === null || (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) !== 'object')) {
	return strict ? actual === expected : actual == expected;
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
	return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
  } else if (isBuffer(actual) !== isBuffer(expected)) {
	return false;
  } else {
	memos = memos || { actual: [], expected: [] };

	var actualIndex = memos.actual.indexOf(actual);
	if (actualIndex !== -1) {
			if (actualIndex === memos.expected.indexOf(expected)) {
		return true;
			}
	}

	memos.actual.push(actual);
	memos.expected.push(expected);

	return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false;
  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
  if (aIsArgs) {
	a = pSlice.call(a);
	b = pSlice.call(b);
	return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  if (ka.length !== kb.length) return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
	if (ka[i] !== kb[i]) return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
	key = ka[i];
	if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }
  return true;
}
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
	fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
	fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
	fail(actual, expected, message, '===', assert.strictEqual);
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
	fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
	return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	return expected.test(actual);
  }

  try {
	if (actual instanceof expected) {
			return true;
	}
  } catch (e) {
  }

  if (Error.isPrototypeOf(expected)) {
	return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
	block();
  } catch (e) {
	error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
	throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
	message = expected;
	expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
	fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
	fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
	throw actual;
  }
}
assert.throws = function (block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};
assert.doesNotThrow = function (block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function (err) {
  if (err) throw err;
};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
	if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};
}.call(exports, __webpack_require__(101)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function isBuffer(arg) {
  return arg && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


if (typeof Object.create === 'function') {
  module.exports = function inherits(ctor, superCtor) {
	ctor.super_ = superCtor;
	ctor.prototype = Object.create(superCtor.prototype, {
			constructor: {
		value: ctor,
		enumerable: false,
		writable: true,
		configurable: true
			}
	});
  };
} else {
  module.exports = function inherits(ctor, superCtor) {
	ctor.super_ = superCtor;
	var TempCtor = function TempCtor() {};
	TempCtor.prototype = superCtor.prototype;
	ctor.prototype = new TempCtor();
	ctor.prototype.constructor = ctor;
  };
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce comparing `typeof` expressions against valid strings",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				requireStringLiterals: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var VALID_TYPES = ["symbol", "undefined", "object", "boolean", "number", "string", "function"],
			OPERATORS = ["==", "===", "!=", "!=="];

		var requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;
		function isTypeofExpression(node) {
			return node.type === "UnaryExpression" && node.operator === "typeof";
		}
		return {
			UnaryExpression: function UnaryExpression(node) {
				if (isTypeofExpression(node)) {
					var parent = context.getAncestors().pop();

					if (parent.type === "BinaryExpression" && OPERATORS.indexOf(parent.operator) !== -1) {
						var sibling = parent.left === node ? parent.right : parent.left;

						if (sibling.type === "Literal" || sibling.type === "TemplateLiteral" && !sibling.expressions.length) {
							var value = sibling.type === "Literal" ? sibling.value : sibling.quasis[0].value.cooked;

							if (VALID_TYPES.indexOf(value) === -1) {
								context.report({ node: sibling, message: "Invalid typeof comparison value." });
							}
						} else if (requireStringLiterals && !isTypeofExpression(sibling)) {
							context.report({ node: sibling, message: "Typeof comparisons should be to string literals." });
						}
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require `var` declarations be placed at the top of their containing scope",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var errorMessage = "All 'var' declarations must be at the top of the function scope.";
		function looksLikeDirective(node) {
			return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
		}
		function looksLikeImport(node) {
			return node.type === "ImportDeclaration" || node.type === "ImportSpecifier" || node.type === "ImportDefaultSpecifier" || node.type === "ImportNamespaceSpecifier";
		}
		function isVariableDeclaration(node) {
			return node.type === "VariableDeclaration" || node.type === "ExportNamedDeclaration" && node.declaration && node.declaration.type === "VariableDeclaration";
		}
		function isVarOnTop(node, statements) {
			var l = statements.length;
			var i = 0;
			for (; i < l; ++i) {
				if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {
					break;
				}
			}

			for (; i < l; ++i) {
				if (!isVariableDeclaration(statements[i])) {
					return false;
				}
				if (statements[i] === node) {
					return true;
				}
			}

			return false;
		}
		function globalVarCheck(node, parent) {
			if (!isVarOnTop(node, parent.body)) {
				context.report({ node: node, message: errorMessage });
			}
		}
		function blockScopeVarCheck(node, parent, grandParent) {
			if (!(/Function/.test(grandParent.type) && parent.type === "BlockStatement" && isVarOnTop(node, parent.body))) {
				context.report({ node: node, message: errorMessage });
			}
		}
		return {
			VariableDeclaration: function VariableDeclaration(node) {
				var ancestors = context.getAncestors();
				var parent = ancestors.pop();
				var grandParent = ancestors.pop();

				if (node.kind === "var") {
					if (parent.type === "ExportNamedDeclaration") {
						node = parent;
						parent = grandParent;
						grandParent = ancestors.pop();
					}

					if (parent.type === "Program") {
						globalVarCheck(node, parent);
					} else {
						blockScopeVarCheck(node, parent, grandParent);
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require parentheses around immediate `function` invocations",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			enum: ["outside", "inside", "any"]
		}, {
			type: "object",
			properties: {
				functionPrototypeMethods: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {

		var style = context.options[0] || "outside";
		var includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods || false;

		var sourceCode = context.getSourceCode();
		function wrapped(node) {
			return astUtils.isParenthesised(sourceCode, node);
		}
		function getFunctionNodeFromIIFE(node) {
			var callee = node.callee;

			if (callee.type === "FunctionExpression") {
				return callee;
			}

			if (includeFunctionPrototypeMethods && callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && (astUtils.getStaticPropertyName(callee) === "call" || astUtils.getStaticPropertyName(callee) === "apply")) {
				return callee.object;
			}

			return null;
		}

		return {
			CallExpression: function CallExpression(node) {
				var innerNode = getFunctionNodeFromIIFE(node);

				if (!innerNode) {
					return;
				}

				var callExpressionWrapped = wrapped(node),
					functionExpressionWrapped = wrapped(innerNode);

				if (!callExpressionWrapped && !functionExpressionWrapped) {
					context.report({
						node: node,
						message: "Wrap an immediate function invocation in parentheses.",
						fix: function fix(fixer) {
							var nodeToSurround = style === "inside" ? innerNode : node;

							return fixer.replaceText(nodeToSurround, "(" + sourceCode.getText(nodeToSurround) + ")");
						}
					});
				} else if (style === "inside" && !functionExpressionWrapped) {
					context.report({
						node: node,
						message: "Wrap only the function expression in parens.",
						fix: function fix(fixer) {
							var parenAfter = sourceCode.getTokenAfter(node);

							return fixer.replaceTextRange([innerNode.range[1], parenAfter.range[1]], ")" + sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0]));
						}
					});
				} else if (style === "outside" && !callExpressionWrapped) {
					context.report({
						node: node,
						message: "Move the invocation into the parens that contain the function.",
						fix: function fix(fixer) {
							var parenAfter = sourceCode.getTokenAfter(innerNode);

							return fixer.replaceTextRange([parenAfter.range[0], node.range[1]], sourceCode.getText().slice(parenAfter.range[1], node.range[1]) + ")");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require parenthesis around regex literals",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			Literal: function Literal(node) {
				var token = sourceCode.getFirstToken(node),
					nodeType = token.type;

				if (nodeType === "RegularExpression") {
					var source = sourceCode.getTokenBefore(node);
					var ancestors = context.getAncestors();
					var grandparent = ancestors[ancestors.length - 1];

					if (grandparent.type === "MemberExpression" && grandparent.object === node && (!source || source.value !== "(")) {
						context.report({
							node: node,
							message: "Wrap the regexp literal in parens to disambiguate the slash.",
							fix: function fix(fixer) {
								return fixer.replaceText(node, "(" + sourceCode.getText(node) + ")");
							}
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require or disallow spacing around the `*` in `yield*` expressions",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["before", "after", "both", "neither"]
			}, {
				type: "object",
				properties: {
					before: { type: "boolean" },
					after: { type: "boolean" }
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		var mode = function (option) {
			if (!option || typeof option === "string") {
				return {
					before: { before: true, after: false },
					after: { before: false, after: true },
					both: { before: true, after: true },
					neither: { before: false, after: false }
				}[option || "after"];
			}
			return option;
		}(context.options[0]);
		function checkSpacing(side, leftToken, rightToken) {
			if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {
				var after = leftToken.value === "*";
				var spaceRequired = mode[side];
				var node = after ? leftToken : rightToken;
				var type = spaceRequired ? "Missing" : "Unexpected";
				var message = "{{type}} space {{side}} *.";

				context.report({
					node: node,
					message: message,
					data: {
						type: type,
						side: side
					},
					fix: function fix(fixer) {
						if (spaceRequired) {
							if (after) {
								return fixer.insertTextAfter(node, " ");
							}
							return fixer.insertTextBefore(node, " ");
						}
						return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
					}
				});
			}
		}
		function checkExpression(node) {
			if (!node.delegate) {
				return;
			}

			var tokens = sourceCode.getFirstTokens(node, 3);
			var yieldToken = tokens[0];
			var starToken = tokens[1];
			var nextToken = tokens[2];

			checkSpacing("before", yieldToken, starToken);
			checkSpacing("after", starToken, nextToken);
		}

		return {
			YieldExpression: checkExpression
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isComparisonOperator(operator) {
	return (/^(==|===|!=|!==|<|>|<=|>=)$/.test(operator)
	);
}
function isEqualityOperator(operator) {
	return (/^(==|===)$/.test(operator)
	);
}
function isRangeTestOperator(operator) {
	return ["<", "<="].indexOf(operator) >= 0;
}
function looksLikeLiteral(node) {
	return node.type === "UnaryExpression" && node.operator === "-" && node.prefix && node.argument.type === "Literal" && typeof node.argument.value === "number";
}
function getNormalizedLiteral(node, defaultValue) {
	if (node.type === "Literal") {
		return node;
	}

	if (looksLikeLiteral(node)) {
		return {
			type: "Literal",
			value: -node.argument.value,
			raw: "-" + node.argument.value
		};
	}

	if (defaultValue) {
		return {
			type: "Literal",
			value: defaultValue,
			raw: String(defaultValue)
		};
	}

	return null;
}
function same(a, b) {
	if (a.type !== b.type) {
		return false;
	}

	switch (a.type) {
		case "Identifier":
			return a.name === b.name;

		case "Literal":
			return a.value === b.value;

		case "MemberExpression":
			{
				var nameA = astUtils.getStaticPropertyName(a);
				if (nameA) {
					return same(a.object, b.object) && nameA === astUtils.getStaticPropertyName(b);
				}
				return a.computed === b.computed && same(a.object, b.object) && same(a.property, b.property);
			}

		case "ThisExpression":
			return true;

		default:
			return false;
	}
}
module.exports = {
	meta: {
		docs: {
			description: "require or disallow \"Yoda\" conditions",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			enum: ["always", "never"]
		}, {
			type: "object",
			properties: {
				exceptRange: {
					type: "boolean"
				},
				onlyEquality: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {
		var always = context.options[0] === "always";
		var exceptRange = context.options[1] && context.options[1].exceptRange;
		var onlyEquality = context.options[1] && context.options[1].onlyEquality;

		var sourceCode = context.getSourceCode();
		function isRangeTest(node) {
			var left = node.left,
				right = node.right;
			function isBetweenTest() {
				var leftLiteral = void 0,
					rightLiteral = void 0;

				return node.operator === "&&" && (leftLiteral = getNormalizedLiteral(left.left)) && (rightLiteral = getNormalizedLiteral(right.right, Number.POSITIVE_INFINITY)) && leftLiteral.value <= rightLiteral.value && same(left.right, right.left);
			}
			function isOutsideTest() {
				var leftLiteral = void 0,
					rightLiteral = void 0;

				return node.operator === "||" && (leftLiteral = getNormalizedLiteral(left.right, Number.NEGATIVE_INFINITY)) && (rightLiteral = getNormalizedLiteral(right.left)) && leftLiteral.value <= rightLiteral.value && same(left.left, right.right);
			}
			function isParenWrapped() {
				return astUtils.isParenthesised(sourceCode, node);
			}

			return node.type === "LogicalExpression" && left.type === "BinaryExpression" && right.type === "BinaryExpression" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (isBetweenTest() || isOutsideTest()) && isParenWrapped();
		}

		var OPERATOR_FLIP_MAP = {
			"===": "===",
			"!==": "!==",
			"==": "==",
			"!=": "!=",
			"<": ">",
			">": "<",
			"<=": ">=",
			">=": "<="
		};
		function getFlippedString(node) {
			var operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, function (token) {
				return token.value === node.operator;
			});
			var textBeforeOperator = sourceCode.getText().slice(sourceCode.getTokenBefore(operatorToken).range[1], operatorToken.range[0]);
			var textAfterOperator = sourceCode.getText().slice(operatorToken.range[1], sourceCode.getTokenAfter(operatorToken).range[0]);
			var leftText = sourceCode.getText().slice(node.range[0], sourceCode.getTokenBefore(operatorToken).range[1]);
			var rightText = sourceCode.getText().slice(sourceCode.getTokenAfter(operatorToken).range[0], node.range[1]);

			return rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText;
		}
		return {
			BinaryExpression: function BinaryExpression(node) {
				var expectedLiteral = always ? node.left : node.right;
				var expectedNonLiteral = always ? node.right : node.left;
				if ((expectedNonLiteral.type === "Literal" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === "Literal" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node.operator) && onlyEquality) && isComparisonOperator(node.operator) && !(exceptRange && isRangeTest(context.getAncestors().pop()))) {
					context.report({
						node: node,
						message: "Expected literal to be on the {{expectedSide}} side of {{operator}}.",
						data: {
							operator: node.operator,
							expectedSide: always ? "left" : "right"
						},
						fix: function fix(fixer) {
							return fixer.replaceText(node, getFlippedString(node));
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);

var allRules = {
  'boolean-prop-naming': __webpack_require__(660),
  'default-props-match-prop-types': __webpack_require__(661),
  'display-name': __webpack_require__(662),
  'forbid-component-props': __webpack_require__(663),
  'forbid-elements': __webpack_require__(664),
  'forbid-prop-types': __webpack_require__(665),
  'forbid-foreign-prop-types': __webpack_require__(666),
  'jsx-boolean-value': __webpack_require__(667),
  'jsx-closing-bracket-location': __webpack_require__(668),
  'jsx-closing-tag-location': __webpack_require__(669),
  'jsx-curly-spacing': __webpack_require__(670),
  'jsx-equals-spacing': __webpack_require__(671),
  'jsx-filename-extension': __webpack_require__(672),
  'jsx-first-prop-new-line': __webpack_require__(673),
  'jsx-handler-names': __webpack_require__(674),
  'jsx-indent': __webpack_require__(675),
  'jsx-indent-props': __webpack_require__(676),
  'jsx-key': __webpack_require__(677),
  'jsx-max-props-per-line': __webpack_require__(700),
  'jsx-no-bind': __webpack_require__(701),
  'jsx-no-comment-textnodes': __webpack_require__(702),
  'jsx-no-duplicate-props': __webpack_require__(703),
  'jsx-no-literals': __webpack_require__(704),
  'jsx-no-target-blank': __webpack_require__(705),
  'jsx-no-undef': __webpack_require__(706),
  'jsx-curly-brace-presence': __webpack_require__(707),
  'jsx-pascal-case': __webpack_require__(708),
  'jsx-sort-props': __webpack_require__(709),
  'jsx-space-before-closing': __webpack_require__(710),
  'jsx-tag-spacing': __webpack_require__(711),
  'jsx-uses-react': __webpack_require__(712),
  'jsx-uses-vars': __webpack_require__(713),
  'jsx-wrap-multilines': __webpack_require__(714),
  'no-array-index-key': __webpack_require__(715),
  'no-children-prop': __webpack_require__(716),
  'no-danger': __webpack_require__(717),
  'no-danger-with-children': __webpack_require__(718),
  'no-deprecated': __webpack_require__(719),
  'no-did-mount-set-state': __webpack_require__(720),
  'no-did-update-set-state': __webpack_require__(721),
  'no-direct-mutation-state': __webpack_require__(722),
  'no-find-dom-node': __webpack_require__(723),
  'no-is-mounted': __webpack_require__(724),
  'no-multi-comp': __webpack_require__(725),
  'no-set-state': __webpack_require__(726),
  'no-string-refs': __webpack_require__(727),
  'no-redundant-should-component-update': __webpack_require__(728),
  'no-render-return-value': __webpack_require__(729),
  'no-typos': __webpack_require__(730),
  'no-unescaped-entities': __webpack_require__(735),
  'no-unknown-property': __webpack_require__(736),
  'no-unused-prop-types': __webpack_require__(737),
  'no-unused-state': __webpack_require__(738),
  'no-will-update-set-state': __webpack_require__(739),
  'prefer-es6-class': __webpack_require__(740),
  'prefer-stateless-function': __webpack_require__(741),
  'prop-types': __webpack_require__(742),
  'react-in-jsx-scope': __webpack_require__(743),
  'require-default-props': __webpack_require__(744),
  'require-optimization': __webpack_require__(745),
  'require-render-return': __webpack_require__(746),
  'self-closing-comp': __webpack_require__(747),
  'sort-comp': __webpack_require__(748),
  'sort-prop-types': __webpack_require__(749),
  'style-prop-object': __webpack_require__(750),
  'void-dom-elements-no-children': __webpack_require__(751)
};

function filterRules(rules, predicate) {
  var result = {};
  for (var key in rules) {
	if (has(rules, key) && predicate(rules[key])) {
			result[key] = rules[key];
	}
  }
  return result;
}

function configureAsError(rules) {
  var result = {};
  for (var key in rules) {
	if (!has(rules, key)) {
			continue;
	}
	result['react/' + key] = 2;
  }
  return result;
}

var activeRules = filterRules(allRules, function (rule) {
  return !rule.meta.deprecated;
});
var activeRulesConfig = configureAsError(activeRules);

var deprecatedRules = filterRules(allRules, function (rule) {
  return rule.meta.deprecated;
});

module.exports = {
  deprecatedRules: deprecatedRules,
  rules: allRules,
  configs: {
	recommended: {
			plugins: ['react'],
			parserOptions: {
		ecmaFeatures: {
					jsx: true
		}
			},
			rules: {
		'react/display-name': 2,
		'react/jsx-key': 2,
		'react/jsx-no-comment-textnodes': 2,
		'react/jsx-no-duplicate-props': 2,
		'react/jsx-no-target-blank': 2,
		'react/jsx-no-undef': 2,
		'react/jsx-uses-react': 2,
		'react/jsx-uses-vars': 2,
		'react/no-children-prop': 2,
		'react/no-danger-with-children': 2,
		'react/no-deprecated': 2,
		'react/no-direct-mutation-state': 2,
		'react/no-find-dom-node': 2,
		'react/no-is-mounted': 2,
		'react/no-render-return-value': 2,
		'react/no-string-refs': 2,
		'react/no-unescaped-entities': 2,
		'react/no-unknown-property': 2,
		'react/prop-types': 2,
		'react/react-in-jsx-scope': 2,
		'react/require-render-return': 2
			}
	},
	all: {
			plugins: ['react'],
			parserOptions: {
		ecmaFeatures: {
					jsx: true
		}
			},
			rules: activeRulesConfig
	}
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(659);

module.exports = Function.prototype.bind || implementation;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
	var target = this;
	if (typeof target !== 'function' || toStr.call(target) !== funcType) {
		throw new TypeError(ERROR_MESSAGE + target);
	}
	var args = slice.call(arguments, 1);

	var bound;
	var binder = function binder() {
		if (this instanceof bound) {
			var result = target.apply(this, args.concat(slice.call(arguments)));
			if (Object(result) === result) {
				return result;
			}
			return this;
		} else {
			return target.apply(that, args.concat(slice.call(arguments)));
		}
	};

	var boundLength = Math.max(0, target.length - args.length);
	var boundArgs = [];
	for (var i = 0; i < boundLength; i++) {
		boundArgs.push('$' + i);
	}

	bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

	if (target.prototype) {
		var Empty = function Empty() {};
		Empty.prototype = target.prototype;
		bound.prototype = new Empty();
		Empty.prototype = null;
	}

	return bound;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			category: 'Stylistic Issues',
			description: 'Enforces consistent naming for boolean props',
			recommended: false
	},

	schema: [{
			additionalProperties: false,
			properties: {
		propTypeNames: {
					items: {
			type: 'string'
					},
					minItems: 1,
					type: 'array',
					uniqueItems: true
		},
		rule: {
					default: '^(is|has)[A-Z]([A-Za-z0-9]?)+',
					minLength: 1,
					type: 'string'
		}
			},
			type: 'object'
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var sourceCode = context.getSourceCode();
	var config = context.options[0] || {};
	var rule = config.rule ? new RegExp(config.rule) : null;
	var propTypeNames = config.propTypeNames || ['bool'];
	var objectTypeAnnotations = new Map();
	function isPropTypesDeclaration(node) {
			if (node && node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		if (tokens[0].value === 'propTypes' || tokens[1] && tokens[1].value === 'propTypes') {
					return true;
		}
		if (node.typeAnnotation && node.key.name === 'props') {
					return true;
		}
		return false;
			}

			return Boolean(node && node.name === 'propTypes');
	}
	function getPropKey(node) {
			if (node.value.property) {
		return node.value.property.name;
			}
			if (node.value.type === 'Identifier') {
		return node.value.name;
			}
			return null;
	}
	function getPropName(node) {
			if (node.type === 'ObjectTypeProperty') {
		return sourceCode.getFirstToken(node).value;
			}

			return node.key.name;
	}
	function validatePropNaming(node, proptypes) {
			var component = components.get(node) || node;
			var invalidProps = component.invalidProps || [];

			(proptypes || []).forEach(function (prop) {
		var propKey = getPropKey(prop);
		var flowCheck = prop.type === 'ObjectTypeProperty' && prop.value.type === 'BooleanTypeAnnotation' && rule.test(getPropName(prop)) === false;
		var regularCheck = propKey && propTypeNames.indexOf(propKey) >= 0 && rule.test(getPropName(prop)) === false;

		if (flowCheck || regularCheck) {
					invalidProps.push(prop);
		}
			});

			components.set(node, {
		invalidProps: invalidProps
			});
	}
	function reportInvalidNaming(component) {
			component.invalidProps.forEach(function (propNode) {
		var propName = getPropName(propNode);
		context.report({
					node: propNode,
					message: 'Prop name (' + propName + ') doesn\'t match rule (' + config.rule + ')',
					data: {
			component: propName
					}
		});
			});
	}
	return {
			ClassProperty: function ClassProperty(node) {
		if (!rule || !isPropTypesDeclaration(node)) {
					return;
		}
		if (node.value && node.value.properties) {
					validatePropNaming(node, node.value.properties);
		}
		if (node.typeAnnotation && node.typeAnnotation.typeAnnotation) {
					validatePropNaming(node, node.typeAnnotation.typeAnnotation.properties);
		}
			},

			MemberExpression: function MemberExpression(node) {
		if (!rule || !isPropTypesDeclaration(node.property)) {
					return;
		}
		var component = utils.getRelatedComponent(node);
		if (!component || !node.parent.right.properties) {
					return;
		}
		validatePropNaming(component.node, node.parent.right.properties);
			},

			ObjectExpression: function ObjectExpression(node) {
		if (!rule) {
					return;
		}
		node.properties.forEach(function (property) {
					if (!isPropTypesDeclaration(property.key)) {
			return;
					}
					validatePropNaming(node, property.value.properties);
		});
			},

			TypeAlias: function TypeAlias(node) {
		if (node.right.type === 'ObjectTypeAnnotation') {
					objectTypeAnnotations.set(node.id.name, node.right);
		}
			},

			'Program:exit': function ProgramExit() {
		if (!rule) {
					return;
		}

		var list = components.list();
		Object.keys(list).forEach(function (component) {
					if (list[component].node.type === 'FunctionDeclaration' && list[component].node.params && list[component].node.params.length && list[component].node.params[0].typeAnnotation) {
			var typeNode = list[component].node.params[0].typeAnnotation;
			var propType = objectTypeAnnotations.get(typeNode.typeAnnotation.id.name);
			if (propType) {
							validatePropNaming(list[component].node, propType.properties);
			}
					}

					if (!has(list, component) || (list[component].invalidProps || []).length) {
			reportInvalidNaming(list[component]);
					}
		});
		objectTypeAnnotations.clear();
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
var variableUtil = __webpack_require__(27);
var annotations = __webpack_require__(72);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce all defaultProps are defined and not "required" in propTypes.',
			category: 'Best Practices'
	},

	schema: [{
			type: 'object',
			properties: {
		allowRequiredDefaults: {
					default: false,
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var configuration = context.options[0] || {};
	var allowRequiredDefaults = configuration.allowRequiredDefaults || false;
	var propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
	function getPropertyName(node) {
			if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {
		return node.key.name;
			} else if (node.type === 'MemberExpression') {
		return node.property.name;
			} else if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
			}
			return '';
	}
	function isPropTypesDeclaration(node) {
			return getPropertyName(node) === 'propTypes';
	}
	function isDefaultPropsDeclaration(node) {
			var propName = getPropertyName(node);
			return propName === 'defaultProps' || propName === 'getDefaultProps';
	}
	function isRequiredPropType(propTypeExpression) {
			return propTypeExpression.type === 'MemberExpression' && propTypeExpression.property.name === 'isRequired';
	}
	function findVariableByName(name) {
			var variable = variableUtil.variablesInScope(context).find(function (item) {
		return item.name === name;
			});

			if (!variable || !variable.defs[0] || !variable.defs[0].node) {
		return null;
			}

			if (variable.defs[0].node.type === 'TypeAlias') {
		return variable.defs[0].node.right;
			}

			return variable.defs[0].node.init;
	}
	function resolveNodeValue(node) {
			if (node.type === 'Identifier') {
		return findVariableByName(node.name);
			}
			if (node.type === 'CallExpression' && propWrapperFunctions.has(node.callee.name) && node.arguments && node.arguments[0]) {
		return resolveNodeValue(node.arguments[0]);
			}
			return node;
	}
	function resolveGenericTypeAnnotation(node) {
			if (node.type !== 'GenericTypeAnnotation' || node.id.type !== 'Identifier') {
		return null;
			}

			return findVariableByName(node.id.name);
	}

	function resolveUnionTypeAnnotation(node) {
			return node.types.map(function (annotation) {
		if (annotation.type === 'GenericTypeAnnotation') {
					return resolveGenericTypeAnnotation(annotation);
		}

		return annotation;
			});
	}
	function getPropTypesFromObjectExpression(objectExpression) {
			var props = objectExpression.properties.filter(function (property) {
		return property.type !== 'ExperimentalSpreadProperty';
			});

			return props.map(function (property) {
		return {
					name: property.key.name,
					isRequired: isRequiredPropType(property.value),
					node: property
		};
			});
	}
	function getPropertiesFromIntersectionTypeAnnotationNode(annotation) {
			return annotation.types.reduce(function (properties, type) {
		annotation = resolveGenericTypeAnnotation(type);

		if (annotation && annotation.id) {
					annotation = findVariableByName(annotation.id.name);
		}

		return properties.concat(annotation.properties);
			}, []);
	}
	function getPropTypesFromTypeAnnotation(node) {
			var properties = [];

			switch (node.typeAnnotation.type) {
		case 'GenericTypeAnnotation':
					var annotation = resolveGenericTypeAnnotation(node.typeAnnotation);

					if (annotation && annotation.type === 'IntersectionTypeAnnotation') {
			properties = getPropertiesFromIntersectionTypeAnnotationNode(annotation);
					} else {
			if (annotation && annotation.id) {
							annotation = findVariableByName(annotation.id.name);
			}

			properties = annotation ? annotation.properties || [] : [];
					}

					break;

		case 'UnionTypeAnnotation':
					var union = resolveUnionTypeAnnotation(node.typeAnnotation);
					properties = union.reduce(function (acc, curr) {
			if (!curr) {
							return acc;
			}

			return acc.concat(curr.properties);
					}, []);
					break;

		case 'ObjectTypeAnnotation':
					properties = node.typeAnnotation.properties;
					break;

		default:
					properties = [];
					break;
			}

			var props = properties.filter(function (property) {
		return property.type === 'ObjectTypeProperty';
			});

			return props.map(function (property) {
		var tokens = context.getFirstTokens(property, 1);
		var name = tokens[0].value;

		return {
					name: name,
					isRequired: !property.optional,
					node: property
		};
			});
	}
	function getDefaultPropsFromObjectExpression(objectExpression) {
			var hasSpread = objectExpression.properties.find(function (property) {
		return property.type === 'ExperimentalSpreadProperty';
			});

			if (hasSpread) {
		return 'unresolved';
			}

			return objectExpression.properties.map(function (defaultProp) {
		return {
					name: defaultProp.key.name,
					node: defaultProp
		};
			});
	}
	function markDefaultPropsAsUnresolved(component) {
			components.set(component.node, {
		defaultProps: 'unresolved'
			});
	}
	function addPropTypesToComponent(component, propTypes) {
			var props = component.propTypes || [];

			components.set(component.node, {
		propTypes: props.concat(propTypes)
			});
	}
	function addDefaultPropsToComponent(component, defaultProps) {
			if (component.defaultProps === 'unresolved') {
		return;
			}

			if (defaultProps === 'unresolved') {
		markDefaultPropsAsUnresolved(component);
		return;
			}

			var defaults = component.defaultProps || [];

			components.set(component.node, {
		defaultProps: defaults.concat(defaultProps)
			});
	}
	function handleStatelessComponent(node) {
			if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {
		return;
			}
			var component = components.get(utils.getParentStatelessComponent());
			if (!component) {
		return;
			}

			addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.params[0].typeAnnotation, context));
	}

	function handlePropTypeAnnotationClassProperty(node) {
			var component = components.get(utils.getParentES6Component());
			if (!component) {
		return;
			}
			addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.typeAnnotation, context));
	}

	function isPropTypeAnnotation(node) {
			return getPropertyName(node) === 'props' && !!node.typeAnnotation;
	}

	function propFromName(propTypes, name) {
			return propTypes.find(function (prop) {
		return prop.name === name;
			});
	}
	function reportInvalidDefaultProps(propTypes, defaultProps) {
			if (defaultProps === 'unresolved' || !propTypes) {
		return;
			}

			defaultProps.forEach(function (defaultProp) {
		var prop = propFromName(propTypes, defaultProp.name);

		if (prop && (allowRequiredDefaults || !prop.isRequired)) {
					return;
		}

		if (prop) {
					context.report(defaultProp.node, 'defaultProp "{{name}}" defined for isRequired propType.', { name: defaultProp.name });
		} else {
					context.report(defaultProp.node, 'defaultProp "{{name}}" has no corresponding propTypes declaration.', { name: defaultProp.name });
		}
			});
	}
	return {
			MemberExpression: function MemberExpression(node) {
		var isPropType = isPropTypesDeclaration(node);
		var isDefaultProp = isDefaultPropsDeclaration(node);

		if (!isPropType && !isDefaultProp) {
					return;
		}
		var component = utils.getRelatedComponent(node);
		if (!component) {
					return;
		}
		//
		//
		if (node.parent.type === 'AssignmentExpression') {
					var expression = resolveNodeValue(node.parent.right);
					if (!expression || expression.type !== 'ObjectExpression') {
			if (isDefaultProp) {
							markDefaultPropsAsUnresolved(component);
			}

			return;
					}

					if (isPropType) {
			addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
					} else {
			addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
					}

					return;
		}
		if (node.parent.type === 'MemberExpression' && node.parent.parent && node.parent.parent.type === 'AssignmentExpression') {
					if (isPropType) {
			addPropTypesToComponent(component, [{
							name: node.parent.property.name,
							isRequired: isRequiredPropType(node.parent.parent.right),
							node: node.parent.parent
			}]);
					} else {
			addDefaultPropsToComponent(component, [{
							name: node.parent.property.name,
							node: node.parent.parent
			}]);
					}

					return;
		}
			},
			MethodDefinition: function MethodDefinition(node) {
		if (!node.static || node.kind !== 'get') {
					return;
		}

		var isPropType = isPropTypesDeclaration(node);
		var isDefaultProp = isDefaultPropsDeclaration(node);

		if (!isPropType && !isDefaultProp) {
					return;
		}
		var component = components.get(utils.getParentES6Component());
		if (!component) {
					return;
		}

		var returnStatement = utils.findReturnStatement(node);
		if (!returnStatement) {
					return;
		}

		var expression = resolveNodeValue(returnStatement.argument);
		if (!expression || expression.type !== 'ObjectExpression') {
					return;
		}

		if (isPropType) {
					addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
		} else {
					addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
		}
			},
			ClassProperty: function ClassProperty(node) {
		if (isPropTypeAnnotation(node)) {
					handlePropTypeAnnotationClassProperty(node);
					return;
		}

		if (!node.static) {
					return;
		}

		if (!node.value) {
					return;
		}

		var propName = getPropertyName(node);
		var isPropType = propName === 'propTypes';
		var isDefaultProp = propName === 'defaultProps' || propName === 'getDefaultProps';

		if (!isPropType && !isDefaultProp) {
					return;
		}
		var component = components.get(utils.getParentES6Component());
		if (!component) {
					return;
		}

		var expression = resolveNodeValue(node.value);
		if (!expression || expression.type !== 'ObjectExpression') {
					return;
		}

		if (isPropType) {
					addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
		} else {
					addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
		}
			},
			ObjectExpression: function ObjectExpression(node) {
		var component = utils.isES5Component(node) && components.get(node);
		if (!component) {
					return;
		}
		node.properties.forEach(function (property) {
					if (property.type === 'ExperimentalSpreadProperty') {
			return;
					}

					var isPropType = isPropTypesDeclaration(property);
					var isDefaultProp = isDefaultPropsDeclaration(property);

					if (!isPropType && !isDefaultProp) {
			return;
					}

					if (isPropType && property.value.type === 'ObjectExpression') {
			addPropTypesToComponent(component, getPropTypesFromObjectExpression(property.value));
			return;
					}

					if (isDefaultProp && property.value.type === 'FunctionExpression') {
			var returnStatement = utils.findReturnStatement(property);
			if (!returnStatement || returnStatement.argument.type !== 'ObjectExpression') {
							return;
			}

			addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(returnStatement.argument));
					}
		});
			},
			FunctionDeclaration: handleStatelessComponent,
			ArrowFunctionExpression: handleStatelessComponent,
			FunctionExpression: handleStatelessComponent,

			'Program:exit': function ProgramExit() {
		var list = components.list();

		for (var component in list) {
					if (!has(list, component)) {
			continue;
					}
					if (!list[component].defaultProps) {
			return;
					}

					reportInvalidDefaultProps(list[component].propTypes, list[component].defaultProps || {});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent missing displayName in a React component definition',
			category: 'Best Practices',
			recommended: true
	},

	schema: [{
			type: 'object',
			properties: {
		ignoreTranspilerName: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var sourceCode = context.getSourceCode();
	var config = context.options[0] || {};
	var ignoreTranspilerName = config.ignoreTranspilerName || false;

	var MISSING_MESSAGE = 'Component definition is missing display name';
	function isDisplayNameDeclaration(node) {
			switch (node.type) {
		case 'ClassProperty':
					var tokens = sourceCode.getFirstTokens(node, 2);
					if (tokens[0].value === 'displayName' || tokens[1] && tokens[1].value === 'displayName') {
			return true;
					}
					return false;
		case 'Identifier':
					return node.name === 'displayName';
		case 'Literal':
					return node.value === 'displayName';
		default:
					return false;
			}
	}
	function markDisplayNameAsDeclared(node) {
			components.set(node, {
		hasDisplayName: true
			});
	}
	function reportMissingDisplayName(component) {
			context.report({
		node: component.node,
		message: MISSING_MESSAGE,
		data: {
					component: component.name
		}
			});
	}
	function hasTranspilerName(node) {
			var namedObjectAssignment = node.type === 'ObjectExpression' && node.parent && node.parent.parent && node.parent.parent.type === 'AssignmentExpression' && (!node.parent.parent.left.object || node.parent.parent.left.object.name !== 'module' || node.parent.parent.left.property.name !== 'exports');
			var namedObjectDeclaration = node.type === 'ObjectExpression' && node.parent && node.parent.parent && node.parent.parent.type === 'VariableDeclarator';
			var namedClass = (node.type === 'ClassDeclaration' || node.type === 'ClassExpression') && node.id && node.id.name;

			var namedFunctionDeclaration = (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') && node.id && node.id.name;

			var namedFunctionExpression = (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') && node.parent && (node.parent.type === 'VariableDeclarator' || node.parent.method === true) && (!node.parent.parent || !utils.isES5Component(node.parent.parent));

			if (namedObjectAssignment || namedObjectDeclaration || namedClass || namedFunctionDeclaration || namedFunctionExpression) {
		return true;
			}
			return false;
	}
	return {

			ClassProperty: function ClassProperty(node) {
		if (!isDisplayNameDeclaration(node)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			MemberExpression: function MemberExpression(node) {
		if (!isDisplayNameDeclaration(node.property)) {
					return;
		}
		var component = utils.getRelatedComponent(node);
		if (!component) {
					return;
		}
		markDisplayNameAsDeclared(component.node);
			},

			FunctionExpression: function FunctionExpression(node) {
		if (ignoreTranspilerName || !hasTranspilerName(node)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			FunctionDeclaration: function FunctionDeclaration(node) {
		if (ignoreTranspilerName || !hasTranspilerName(node)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
		if (ignoreTranspilerName || !hasTranspilerName(node)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			MethodDefinition: function MethodDefinition(node) {
		if (!isDisplayNameDeclaration(node.key)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			ClassExpression: function ClassExpression(node) {
		if (ignoreTranspilerName || !hasTranspilerName(node)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			ClassDeclaration: function ClassDeclaration(node) {
		if (ignoreTranspilerName || !hasTranspilerName(node)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			ObjectExpression: function ObjectExpression(node) {
		if (ignoreTranspilerName || !hasTranspilerName(node)) {
					node.properties.forEach(function (property) {
			if (!property.key || !isDisplayNameDeclaration(property.key)) {
							return;
			}
			markDisplayNameAsDeclared(node);
					});
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			'Program:exit': function ProgramExit() {
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || list[component].hasDisplayName) {
			continue;
					}
					reportMissingDisplayName(list[component]);
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var DEFAULTS = ['className', 'style'];
module.exports = {
  meta: {
	docs: {
			description: 'Forbid certain props on components',
			category: 'Best Practices',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		forbid: {
					type: 'array',
					items: {
			type: 'string'
					}
		}
			},
			additionalProperties: true
	}]
  },

  create: function create(context) {
	function isForbidden(prop) {
			var configuration = context.options[0] || {};

			var forbid = configuration.forbid || DEFAULTS;
			return forbid.indexOf(prop) >= 0;
	}

	return {
			JSXAttribute: function JSXAttribute(node) {
		var tag = node.parent.name.name;
		if (tag && tag[0] !== tag[0].toUpperCase()) {
					return;
		}

		var prop = node.name.name;

		if (!isForbidden(prop)) {
					return;
		}

		context.report({
					node: node,
					message: 'Prop `' + prop + '` is forbidden on Components'
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
module.exports = {
  meta: {
	docs: {
			description: 'Forbid certain elements',
			category: 'Best Practices',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		forbid: {
					type: 'array',
					items: {
			anyOf: [{ type: 'string' }, {
							type: 'object',
							properties: {
				element: { type: 'string' },
				message: { type: 'string' }
							},
							required: ['element'],
							additionalProperties: false
			}]
					}
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();
	var configuration = context.options[0] || {};
	var forbidConfiguration = configuration.forbid || [];

	var indexedForbidConfigs = {};

	forbidConfiguration.forEach(function (item) {
			if (typeof item === 'string') {
		indexedForbidConfigs[item] = { element: item };
			} else {
		indexedForbidConfigs[item.element] = item;
			}
	});

	function errorMessageForElement(name) {
			var message = '<' + name + '> is forbidden';
			var additionalMessage = indexedForbidConfigs[name].message;

			if (additionalMessage) {
		return message + ', ' + additionalMessage;
			}

			return message;
	}

	function isValidCreateElement(node) {
			return node.callee && node.callee.type === 'MemberExpression' && node.callee.object.name === 'React' && node.callee.property.name === 'createElement' && node.arguments.length > 0;
	}

	function reportIfForbidden(element, node) {
			if (has(indexedForbidConfigs, element)) {
		context.report({
					node: node,
					message: errorMessageForElement(element)
		});
			}
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		reportIfForbidden(sourceCode.getText(node.name), node.name);
			},

			CallExpression: function CallExpression(node) {
		if (!isValidCreateElement(node)) {
					return;
		}

		var argument = node.arguments[0];
		var argType = argument.type;

		if (argType === 'Identifier' && /^[A-Z_]/.test(argument.name)) {
					reportIfForbidden(argument.name, argument);
		} else if (argType === 'Literal' && /^[a-z][^\.]*$/.test(argument.value)) {
					reportIfForbidden(argument.value, argument);
		} else if (argType === 'MemberExpression') {
					reportIfForbidden(sourceCode.getText(argument), argument);
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var variableUtil = __webpack_require__(27);
var DEFAULTS = ['any', 'array', 'object'];
module.exports = {
  meta: {
	docs: {
			description: 'Forbid certain propTypes',
			category: 'Best Practices',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		forbid: {
					type: 'array',
					items: {
			type: 'string'
					}
		}
			},
			additionalProperties: true
	}]
  },

  create: function create(context) {
	var propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);

	function isForbidden(type) {
			var configuration = context.options[0] || {};

			var forbid = configuration.forbid || DEFAULTS;
			return forbid.indexOf(type) >= 0;
	}
	function isPropTypesDeclaration(node) {
			if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		if (tokens[0].value === 'propTypes' || tokens[1] && tokens[1].value === 'propTypes') {
					return true;
		}
		return false;
			}

			return Boolean(node && node.name === 'propTypes');
	}
	function findVariableByName(name) {
			var variable = variableUtil.variablesInScope(context).find(function (item) {
		return item.name === name;
			});

			if (!variable || !variable.defs[0] || !variable.defs[0].node) {
		return null;
			}

			if (variable.defs[0].node.type === 'TypeAlias') {
		return variable.defs[0].node.right;
			}

			return variable.defs[0].node.init;
	}
	function checkProperties(declarations) {
			declarations.forEach(function (declaration) {
		if (declaration.type !== 'Property') {
					return;
		}
		var target = void 0;
		var value = declaration.value;
		if (value.type === 'MemberExpression' && value.property && value.property.name && value.property.name === 'isRequired') {
					value = value.object;
		}
		if (value.type === 'CallExpression' && value.callee.type === 'MemberExpression') {
					value = value.callee;
		}
		if (value.property) {
					target = value.property.name;
		} else if (value.type === 'Identifier') {
					target = value.name;
		}
		if (isForbidden(target)) {
					context.report({
			node: declaration,
			message: 'Prop type `' + target + '` is forbidden'
					});
		}
			});
	}

	function checkNode(node) {
			switch (node && node.type) {
		case 'ObjectExpression':
					checkProperties(node.properties);
					break;
		case 'Identifier':
					var propTypesObject = findVariableByName(node.name);
					if (propTypesObject && propTypesObject.properties) {
			checkProperties(propTypesObject.properties);
					}
					break;
		case 'CallExpression':
					var innerNode = node.arguments && node.arguments[0];
					if (propWrapperFunctions.has(node.callee.name) && innerNode) {
			checkNode(innerNode);
					}
					break;
		default:
					break;
			}
	}

	return {
			ClassProperty: function ClassProperty(node) {
		if (!isPropTypesDeclaration(node)) {
					return;
		}
		checkNode(node.value);
			},

			MemberExpression: function MemberExpression(node) {
		if (!isPropTypesDeclaration(node.property)) {
					return;
		}

		checkNode(node.parent.right);
			},

			ObjectExpression: function ObjectExpression(node) {
		node.properties.forEach(function (property) {
					if (!property.key) {
			return;
					}

					if (!isPropTypesDeclaration(property.key)) {
			return;
					}
					if (property.value.type === 'ObjectExpression') {
			checkProperties(property.value.properties);
					}
		});
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Forbid using another component\'s propTypes',
			category: 'Best Practices',
			recommended: false
	}
  },

  create: function create(context) {
	function isLeftSideOfAssignment(node) {
			return node.parent.type === 'AssignmentExpression' && node.parent.left === node;
	}

	return {
			MemberExpression: function MemberExpression(node) {
		if (!node.computed && node.property && node.property.type === 'Identifier' && node.property.name === 'propTypes' && !isLeftSideOfAssignment(node) || node.property && node.property.type === 'Literal' && node.property.value === 'propTypes' && !isLeftSideOfAssignment(node)) {
					context.report({
			node: node.property,
			message: 'Using another component\'s propTypes is forbidden'
					});
		}
			},

			ObjectPattern: function ObjectPattern(node) {
		var propTypesNode = node.properties.find(function (property) {
					return property.type === 'Property' && property.key.name === 'propTypes';
		});

		if (propTypesNode) {
					context.report({
			node: propTypesNode,
			message: 'Using another component\'s propTypes is forbidden'
					});
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var exceptionsSchema = {
  type: 'array',
  items: { type: 'string', minLength: 1 },
  uniqueItems: true
};

var ALWAYS = 'always';
var NEVER = 'never';

var errorData = new WeakMap();
function getErrorData(exceptions) {
  if (!errorData.has(exceptions)) {
	var exceptionProps = Array.from(exceptions, function (name) {
			return '`' + name + '`';
	}).join(', ');
	var exceptionsMessage = exceptions.size > 0 ? ' for the following props: ' + exceptionProps : '';
	errorData.set(exceptions, { exceptionsMessage: exceptionsMessage });
  }
  return errorData.get(exceptions);
}

function isAlways(configuration, exceptions, propName) {
  var isException = exceptions.has(propName);
  if (configuration === ALWAYS) {
	return !isException;
  }
  return isException;
}

function isNever(configuration, exceptions, propName) {
  var isException = exceptions.has(propName);
  if (configuration === NEVER) {
	return !isException;
  }
  return isException;
}

module.exports = {
  meta: {
	docs: {
			description: 'Enforce boolean attributes notation in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: {
			anyOf: [{
		type: 'array',
		items: [{ enum: [ALWAYS, NEVER] }],
		additionalItems: false
			}, {
		type: 'array',
		items: [{
					enum: [ALWAYS]
		}, {
					type: 'object',
					additionalProperties: false,
					properties: _defineProperty({}, NEVER, exceptionsSchema)
		}],
		additionalItems: false
			}, {
		type: 'array',
		items: [{
					enum: [NEVER]
		}, {
					type: 'object',
					additionalProperties: false,
					properties: _defineProperty({}, ALWAYS, exceptionsSchema)
		}],
		additionalItems: false
			}]
	}
  },

  create: function create(context) {
	var configuration = context.options[0] || NEVER;
	var configObject = context.options[1] || {};
	var exceptions = new Set((configuration === ALWAYS ? configObject[NEVER] : configObject[ALWAYS]) || []);

	var NEVER_MESSAGE = 'Value must be omitted for boolean attributes{{exceptionsMessage}}';
	var ALWAYS_MESSAGE = 'Value must be set for boolean attributes{{exceptionsMessage}}';

	return {
			JSXAttribute: function JSXAttribute(node) {
		var propName = node.name && node.name.name;
		var value = node.value;

		if (isAlways(configuration, exceptions, propName) && value === null) {
					var data = getErrorData(exceptions);
					context.report({
			node: node,
			message: ALWAYS_MESSAGE,
			data: data,
			fix: function fix(fixer) {
							return fixer.insertTextAfter(node, '={true}');
			}
					});
		}
		if (isNever(configuration, exceptions, propName) && value && value.type === 'JSXExpressionContainer' && value.expression.value === true) {
					var _data = getErrorData(exceptions);
					context.report({
			node: node,
			message: NEVER_MESSAGE,
			data: _data,
			fix: function fix(fixer) {
							return fixer.removeRange([node.name.range[1], value.range[1]]);
			}
					});
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var has = __webpack_require__(7);
module.exports = {
  meta: {
	docs: {
			description: 'Validate closing bracket location in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			oneOf: [{
		enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']
			}, {
		type: 'object',
		properties: {
					location: {
			enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']
					}
		},
		additionalProperties: false
			}, {
		type: 'object',
		properties: {
					nonEmpty: {
			enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]
					},
					selfClosing: {
			enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]
					}
		},
		additionalProperties: false
			}]
	}]
  },

  create: function create(context) {
	var MESSAGE = 'The closing bracket must be {{location}}{{details}}';
	var MESSAGE_LOCATION = {
			'after-props': 'placed after the last prop',
			'after-tag': 'placed after the opening tag',
			'props-aligned': 'aligned with the last prop',
			'tag-aligned': 'aligned with the opening tag',
			'line-aligned': 'aligned with the line containing the opening tag'
	};
	var DEFAULT_LOCATION = 'tag-aligned';

	var sourceCode = context.getSourceCode();
	var config = context.options[0];
	var options = {
			nonEmpty: DEFAULT_LOCATION,
			selfClosing: DEFAULT_LOCATION
	};

	if (typeof config === 'string') {
			options.nonEmpty = config;
			options.selfClosing = config;
	} else if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') {
			if (has(config, 'location')) {
		options.nonEmpty = config.location;
		options.selfClosing = config.location;
			}
			if (has(config, 'nonEmpty')) {
		options.nonEmpty = config.nonEmpty;
			}
			if (has(config, 'selfClosing')) {
		options.selfClosing = config.selfClosing;
			}
	}
	function getExpectedLocation(tokens) {
			var location = void 0;
			if (typeof tokens.lastProp === 'undefined') {
		location = 'after-tag';
			} else if (tokens.opening.line === tokens.lastProp.lastLine) {
		location = 'after-props';
			} else {
		location = tokens.selfClosing ? options.selfClosing : options.nonEmpty;
			}
			return location;
	}
	function getCorrectColumn(tokens, expectedLocation) {
			switch (expectedLocation) {
		case 'props-aligned':
					return tokens.lastProp.column;
		case 'tag-aligned':
					return tokens.opening.column;
		case 'line-aligned':
					return tokens.openingStartOfLine.column;
		default:
					return null;
			}
	}
	function hasCorrectLocation(tokens, expectedLocation) {
			switch (expectedLocation) {
		case 'after-tag':
					return tokens.tag.line === tokens.closing.line;
		case 'after-props':
					return tokens.lastProp.lastLine === tokens.closing.line;
		case 'props-aligned':
		case 'tag-aligned':
		case 'line-aligned':
					var correctColumn = getCorrectColumn(tokens, expectedLocation);
					return correctColumn === tokens.closing.column;
		default:
					return true;
			}
	}
	function getIndentation(tokens, expectedLocation, correctColumn) {
			var indentation = void 0,
					spaces = [];
			switch (expectedLocation) {
		case 'props-aligned':
					indentation = /^\s*/.exec(sourceCode.lines[tokens.lastProp.firstLine - 1])[0];
					break;
		case 'tag-aligned':
		case 'line-aligned':
					indentation = /^\s*/.exec(sourceCode.lines[tokens.opening.line - 1])[0];
					break;
		default:
					indentation = '';
			}
			if (indentation.length + 1 < correctColumn) {
		spaces = new Array(+correctColumn + 1 - indentation.length);
			}
			return indentation + spaces.join(' ');
	}
	function getTokensLocations(node) {
			var opening = sourceCode.getFirstToken(node).loc.start;
			var closing = sourceCode.getLastTokens(node, node.selfClosing ? 2 : 1)[0].loc.start;
			var tag = sourceCode.getFirstToken(node.name).loc.start;
			var lastProp = void 0;
			if (node.attributes.length) {
		lastProp = node.attributes[node.attributes.length - 1];
		lastProp = {
					column: sourceCode.getFirstToken(lastProp).loc.start.column,
					firstLine: sourceCode.getFirstToken(lastProp).loc.start.line,
					lastLine: sourceCode.getLastToken(lastProp).loc.end.line
		};
			}
			var openingLine = sourceCode.lines[opening.line - 1];
			var openingStartOfLine = {
		column: /^\s*/.exec(openingLine)[0].length,
		line: opening.line
			};
			return {
		tag: tag,
		opening: opening,
		closing: closing,
		lastProp: lastProp,
		selfClosing: node.selfClosing,
		openingStartOfLine: openingStartOfLine
			};
	}
	function getOpeningElementId(node) {
			return node.range.join(':');
	}

	var lastAttributeNode = {};

	return {
			JSXAttribute: function JSXAttribute(node) {
		lastAttributeNode[getOpeningElementId(node.parent)] = node;
			},

			JSXSpreadAttribute: function JSXSpreadAttribute(node) {
		lastAttributeNode[getOpeningElementId(node.parent)] = node;
			},

			'JSXOpeningElement:exit': function JSXOpeningElementExit(node) {
		var attributeNode = lastAttributeNode[getOpeningElementId(node)];
		var cachedLastAttributeEndPos = attributeNode ? attributeNode.end : null;
		var expectedNextLine = void 0;
		var tokens = getTokensLocations(node);
		var expectedLocation = getExpectedLocation(tokens);

		if (hasCorrectLocation(tokens, expectedLocation)) {
					return;
		}

		var data = { location: MESSAGE_LOCATION[expectedLocation], details: '' };
		var correctColumn = getCorrectColumn(tokens, expectedLocation);

		if (correctColumn !== null) {
					expectedNextLine = tokens.lastProp && tokens.lastProp.lastLine === tokens.closing.line;
					data.details = ' (expected column ' + (correctColumn + 1) + (expectedNextLine ? ' on the next line)' : ')');
		}

		context.report({
					node: node,
					loc: tokens.closing,
					message: MESSAGE,
					data: data,
					fix: function fix(fixer) {
			var closingTag = tokens.selfClosing ? '/>' : '>';
			switch (expectedLocation) {
							case 'after-tag':
				if (cachedLastAttributeEndPos) {
									return fixer.replaceTextRange([cachedLastAttributeEndPos, node.end], (expectedNextLine ? '\n' : '') + closingTag);
				}
				return fixer.replaceTextRange([node.name.range[1], node.end], (expectedNextLine ? '\n' : ' ') + closingTag);
							case 'after-props':
				return fixer.replaceTextRange([cachedLastAttributeEndPos, node.end], (expectedNextLine ? '\n' : '') + closingTag);
							case 'props-aligned':
							case 'tag-aligned':
							case 'line-aligned':
				return fixer.replaceTextRange([cachedLastAttributeEndPos, node.end], '\n' + getIndentation(tokens, expectedLocation, correctColumn) + closingTag);
							default:
				return true;
			}
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Validate closing tag location for multiline JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'whitespace'
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();
	function isNodeFirstInLine(node) {
			var token = node;
			var lines = void 0;
			do {
		token = sourceCode.getTokenBefore(token);
		lines = token.type === 'JSXText' ? token.value.split('\n') : null;
			} while (token.type === 'JSXText' && /^\s*$/.test(lines[lines.length - 1]));

			var startLine = node.loc.start.line;
			var endLine = token ? token.loc.end.line : -1;
			return startLine !== endLine;
	}

	return {
			JSXClosingElement: function JSXClosingElement(node) {
		if (!node.parent) {
					return;
		}

		var opening = node.parent.openingElement;
		if (opening.loc.start.line === node.loc.start.line) {
					return;
		}

		if (opening.loc.start.column === node.loc.start.column) {
					return;
		}

		var message = void 0;
		if (!isNodeFirstInLine(node)) {
					message = 'Closing tag of a multiline JSX expression must be on its own line.';
		} else {
					message = 'Expected closing tag to match indentation of opening.';
		}

		context.report({
					node: node,
					loc: node.loc,
					message: message,
					fix: function fix(fixer) {
			var indent = Array(opening.loc.start.column + 1).join(' ');
			if (isNodeFirstInLine(node)) {
							return fixer.replaceTextRange([node.start - node.loc.start.column, node.start], indent);
			}

			return fixer.insertTextBefore(node, '\n' + indent);
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var SPACING = {
  always: 'always',
  never: 'never'
};
var SPACING_VALUES = [SPACING.always, SPACING.never];

module.exports = {
  meta: {
	docs: {
			description: 'Enforce or disallow spaces inside of curly braces in JSX attributes',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: {
			definitions: {
		basicConfig: {
					type: 'object',
					properties: {
			when: {
							enum: SPACING_VALUES
			},
			allowMultiline: {
							type: 'boolean'
			},
			spacing: {
							type: 'object',
							properties: {
				objectLiterals: {
									enum: SPACING_VALUES
				}
							}
			}
					}
		},
		basicConfigOrBoolean: {
					oneOf: [{
			$ref: '#/definitions/basicConfig'
					}, {
			type: 'boolean'
					}]
		}
			},
			type: 'array',
			items: [{
		oneOf: [{
					allOf: [{
			$ref: '#/definitions/basicConfig'
					}, {
			type: 'object',
			properties: {
							attributes: {
				$ref: '#/definitions/basicConfigOrBoolean'
							},
							children: {
				$ref: '#/definitions/basicConfigOrBoolean'
							}
			}
					}]
		}, {
					enum: SPACING_VALUES
		}]
			}, {
		type: 'object',
		properties: {
					allowMultiline: {
			type: 'boolean'
					},
					spacing: {
			type: 'object',
			properties: {
							objectLiterals: {
				enum: SPACING_VALUES
							}
			}
					}
		},
		additionalProperties: false
			}]
	}
  },

  create: function create(context) {
	function normalizeConfig(configOrTrue, defaults, lastPass) {
			var config = configOrTrue === true ? {} : configOrTrue;
			var when = config.when || defaults.when;
			var allowMultiline = has(config, 'allowMultiline') ? config.allowMultiline : defaults.allowMultiline;
			var spacing = config.spacing || {};
			var objectLiteralSpaces = spacing.objectLiterals || defaults.objectLiteralSpaces;
			if (lastPass) {
		objectLiteralSpaces = objectLiteralSpaces || when;
			}

			return {
		when: when,
		allowMultiline: allowMultiline,
		objectLiteralSpaces: objectLiteralSpaces
			};
	}

	var DEFAULT_WHEN = SPACING.never;
	var DEFAULT_ALLOW_MULTILINE = true;
	var DEFAULT_ATTRIBUTES = true;
	var DEFAULT_CHILDREN = false;

	var sourceCode = context.getSourceCode();
	var originalConfig = context.options[0] || {};
	if (SPACING_VALUES.indexOf(originalConfig) !== -1) {
			originalConfig = Object.assign({ when: context.options[0] }, context.options[1]);
	}
	var defaultConfig = normalizeConfig(originalConfig, {
			when: DEFAULT_WHEN,
			allowMultiline: DEFAULT_ALLOW_MULTILINE
	});
	var attributes = has(originalConfig, 'attributes') ? originalConfig.attributes : DEFAULT_ATTRIBUTES;
	var attributesConfig = attributes ? normalizeConfig(attributes, defaultConfig, true) : null;
	var children = has(originalConfig, 'children') ? originalConfig.children : DEFAULT_CHILDREN;
	var childrenConfig = children ? normalizeConfig(children, defaultConfig, true) : null;
	function isMultiline(left, right) {
			return left.loc.start.line !== right.loc.start.line;
	}
	function reportNoBeginningNewline(node, token, spacing) {
			context.report({
		node: node,
		loc: token.loc.start,
		message: 'There should be no newline after \'' + token.value + '\'',
		fix: function fix(fixer) {
					var nextToken = sourceCode.getTokenAfter(token);
					return fixer.replaceTextRange([token.range[1], nextToken.range[0]], spacing === SPACING.always ? ' ' : '');
		}
			});
	}
	function reportNoEndingNewline(node, token, spacing) {
			context.report({
		node: node,
		loc: token.loc.start,
		message: 'There should be no newline before \'' + token.value + '\'',
		fix: function fix(fixer) {
					var previousToken = sourceCode.getTokenBefore(token);
					return fixer.replaceTextRange([previousToken.range[1], token.range[0]], spacing === SPACING.always ? ' ' : '');
		}
			});
	}
	function reportNoBeginningSpace(node, token) {
			context.report({
		node: node,
		loc: token.loc.start,
		message: 'There should be no space after \'' + token.value + '\'',
		fix: function fix(fixer) {
					var nextToken = sourceCode.getTokenAfter(token);
					var nextNode = sourceCode.getNodeByRangeIndex(nextToken.range[0]);
					var leadingComments = sourceCode.getComments(nextNode).leading;
					var rangeEndRef = leadingComments.length ? leadingComments[0] : nextToken;
					return fixer.removeRange([token.range[1], rangeEndRef.range[0]]);
		}
			});
	}
	function reportNoEndingSpace(node, token) {
			context.report({
		node: node,
		loc: token.loc.start,
		message: 'There should be no space before \'' + token.value + '\'',
		fix: function fix(fixer) {
					var previousToken = sourceCode.getTokenBefore(token);
					var previousNode = sourceCode.getNodeByRangeIndex(previousToken.range[0]);
					var trailingComments = sourceCode.getComments(previousNode).trailing;
					var rangeStartRef = trailingComments.length ? trailingComments[trailingComments.length - 1] : previousToken;
					return fixer.removeRange([rangeStartRef.range[1], token.range[0]]);
		}
			});
	}
	function reportRequiredBeginningSpace(node, token) {
			context.report({
		node: node,
		loc: token.loc.start,
		message: 'A space is required after \'' + token.value + '\'',
		fix: function fix(fixer) {
					return fixer.insertTextAfter(token, ' ');
		}
			});
	}
	function reportRequiredEndingSpace(node, token) {
			context.report({
		node: node,
		loc: token.loc.start,
		message: 'A space is required before \'' + token.value + '\'',
		fix: function fix(fixer) {
					return fixer.insertTextBefore(token, ' ');
		}
			});
	}
	function validateBraceSpacing(node) {
			var config = void 0;
			switch (node.parent.type) {
		case 'JSXAttribute':
		case 'JSXOpeningElement':
					config = attributesConfig;
					break;

		case 'JSXElement':
					config = childrenConfig;
					break;

		default:
					return;
			}
			if (config === null) {
		return;
			}

			var first = context.getFirstToken(node);
			var last = sourceCode.getLastToken(node);
			var second = context.getTokenAfter(first, { includeComments: true });
			var penultimate = sourceCode.getTokenBefore(last, { includeComments: true });

			if (!second) {
		second = context.getTokenAfter(first);
		var leadingComments = sourceCode.getNodeByRangeIndex(second.range[0]).leadingComments;
		second = leadingComments ? leadingComments[0] : second;
			}
			if (!penultimate) {
		penultimate = sourceCode.getTokenBefore(last);
		var trailingComments = sourceCode.getNodeByRangeIndex(penultimate.range[0]).trailingComments;
		penultimate = trailingComments ? trailingComments[trailingComments.length - 1] : penultimate;
			}

			var isObjectLiteral = first.value === second.value;
			var spacing = isObjectLiteral ? config.objectLiteralSpaces : config.when;
			if (spacing === SPACING.always) {
		if (!sourceCode.isSpaceBetweenTokens(first, second)) {
					reportRequiredBeginningSpace(node, first);
		} else if (!config.allowMultiline && isMultiline(first, second)) {
					reportNoBeginningNewline(node, first, spacing);
		}
		if (!sourceCode.isSpaceBetweenTokens(penultimate, last)) {
					reportRequiredEndingSpace(node, last);
		} else if (!config.allowMultiline && isMultiline(penultimate, last)) {
					reportNoEndingNewline(node, last, spacing);
		}
			} else if (spacing === SPACING.never) {
		if (isMultiline(first, second)) {
					if (!config.allowMultiline) {
			reportNoBeginningNewline(node, first, spacing);
					}
		} else if (sourceCode.isSpaceBetweenTokens(first, second)) {
					reportNoBeginningSpace(node, first);
		}
		if (isMultiline(penultimate, last)) {
					if (!config.allowMultiline) {
			reportNoEndingNewline(node, last, spacing);
					}
		} else if (sourceCode.isSpaceBetweenTokens(penultimate, last)) {
					reportNoEndingSpace(node, last);
		}
			}
	}
	return {
			JSXExpressionContainer: validateBraceSpacing,
			JSXSpreadAttribute: validateBraceSpacing
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Disallow or enforce spaces around equal signs in JSX attributes',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			enum: ['always', 'never']
	}]
  },

  create: function create(context) {
	var config = context.options[0];
	var sourceCode = context.getSourceCode();
	function hasEqual(attrNode) {
			return attrNode.type !== 'JSXSpreadAttribute' && attrNode.value !== null;
	}
	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		node.attributes.forEach(function (attrNode) {
					if (!hasEqual(attrNode)) {
			return;
					}

					var equalToken = sourceCode.getTokenAfter(attrNode.name);
					var spacedBefore = sourceCode.isSpaceBetweenTokens(attrNode.name, equalToken);
					var spacedAfter = sourceCode.isSpaceBetweenTokens(equalToken, attrNode.value);

					switch (config) {
			default:
			case 'never':
							if (spacedBefore) {
				context.report({
									node: attrNode,
									loc: equalToken.loc.start,
									message: 'There should be no space before \'=\'',
									fix: function fix(fixer) {
					return fixer.removeRange([attrNode.name.range[1], equalToken.start]);
									}
				});
							}
							if (spacedAfter) {
				context.report({
									node: attrNode,
									loc: equalToken.loc.start,
									message: 'There should be no space after \'=\'',
									fix: function fix(fixer) {
					return fixer.removeRange([equalToken.end, attrNode.value.range[0]]);
									}
				});
							}
							break;
			case 'always':
							if (!spacedBefore) {
				context.report({
									node: attrNode,
									loc: equalToken.loc.start,
									message: 'A space is required before \'=\'',
									fix: function fix(fixer) {
					return fixer.insertTextBefore(equalToken, ' ');
									}
				});
							}
							if (!spacedAfter) {
				context.report({
									node: attrNode,
									loc: equalToken.loc.start,
									message: 'A space is required after \'=\'',
									fix: function fix(fixer) {
					return fixer.insertTextAfter(equalToken, ' ');
									}
				});
							}
							break;
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var path = __webpack_require__(103);
var DEFAULTS = {
  extensions: ['.jsx']
};
module.exports = {
  meta: {
	docs: {
			description: 'Restrict file extensions that may contain JSX',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		extensions: {
					type: 'array',
					items: {
			type: 'string'
					}
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	function getExtensionsConfig() {
			return context.options[0] && context.options[0].extensions || DEFAULTS.extensions;
	}

	var invalidExtension = void 0;
	var invalidNode = void 0;
	return {
			JSXElement: function JSXElement(node) {
		var filename = context.getFilename();
		if (filename === '<text>') {
					return;
		}

		if (invalidNode) {
					return;
		}

		var allowedExtensions = getExtensionsConfig();
		var isAllowedExtension = allowedExtensions.some(function (extension) {
					return filename.slice(-extension.length) === extension;
		});

		if (isAllowedExtension) {
					return;
		}

		invalidNode = node;
		invalidExtension = path.extname(filename);
			},

			'Program:exit': function ProgramExit() {
		if (!invalidNode) {
					return;
		}

		context.report({
					node: invalidNode,
					message: 'JSX not allowed in files with extension \'' + invalidExtension + '\''
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Ensure proper position of the first property in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			enum: ['always', 'never', 'multiline', 'multiline-multiprop']
	}]
  },

  create: function create(context) {
	var configuration = context.options[0] || 'multiline-multiprop';

	function isMultilineJSX(jsxNode) {
			return jsxNode.loc.start.line < jsxNode.loc.end.line;
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		if (configuration === 'multiline' && isMultilineJSX(node) || configuration === 'multiline-multiprop' && isMultilineJSX(node) && node.attributes.length > 1 || configuration === 'always') {
					node.attributes.some(function (decl) {
			if (decl.loc.start.line === node.loc.start.line) {
							context.report({
				node: decl,
				message: 'Property should be placed on a new line',
				fix: function fix(fixer) {
									return fixer.replaceTextRange([node.name.end, decl.start], '\n');
				}
							});
			}
			return true;
					});
		} else if (configuration === 'never' && node.attributes.length > 0) {
					var firstNode = node.attributes[0];
					if (node.loc.start.line < firstNode.loc.start.line) {
			context.report({
							node: firstNode,
							message: 'Property should be placed on the same line as the component declaration',
							fix: function fix(fixer) {
				return fixer.replaceTextRange([node.name.end, firstNode.start], ' ');
							}
			});
			return;
					}
		}
		return;
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
  meta: {
	docs: {
			description: 'Enforce event handler naming conventions in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		eventHandlerPrefix: {
					type: 'string'
		},
		eventHandlerPropPrefix: {
					type: 'string'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();
	var configuration = context.options[0] || {};
	var eventHandlerPrefix = configuration.eventHandlerPrefix || 'handle';
	var eventHandlerPropPrefix = configuration.eventHandlerPropPrefix || 'on';

	var EVENT_HANDLER_REGEX = new RegExp('^((props\\.' + eventHandlerPropPrefix + ')|((.*\\.)?' + eventHandlerPrefix + '))[A-Z].*$');
	var PROP_EVENT_HANDLER_REGEX = new RegExp('^(' + eventHandlerPropPrefix + '[A-Z].*|ref)$');

	return {
			JSXAttribute: function JSXAttribute(node) {
		if (!node.value || !node.value.expression || !node.value.expression.object) {
					return;
		}

		var propKey = _typeof(node.name) === 'object' ? node.name.name : node.name;
		var propValue = sourceCode.getText(node.value.expression).replace(/^this\.|.*::/, '');

		if (propKey === 'ref') {
					return;
		}

		var propIsEventHandler = PROP_EVENT_HANDLER_REGEX.test(propKey);
		var propFnIsNamedCorrectly = EVENT_HANDLER_REGEX.test(propValue);

		if (propIsEventHandler && !propFnIsNamedCorrectly) {
					context.report({
			node: node,
			message: 'Handler function for ' + propKey + ' prop key must begin with \'' + eventHandlerPrefix + '\''
					});
		} else if (propFnIsNamedCorrectly && !propIsEventHandler) {
					context.report({
			node: node,
			message: 'Prop key for ' + propValue + ' must begin with \'' + eventHandlerPropPrefix + '\''
					});
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Validate JSX indentation',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'whitespace',
	schema: [{
			oneOf: [{
		enum: ['tab']
			}, {
		type: 'integer'
			}]
	}]
  },

  create: function create(context) {
	var MESSAGE = 'Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.';

	var extraColumnStart = 0;
	var indentType = 'space';
	var indentSize = 4;

	var sourceCode = context.getSourceCode();

	if (context.options.length) {
			if (context.options[0] === 'tab') {
		indentSize = 1;
		indentType = 'tab';
			} else if (typeof context.options[0] === 'number') {
		indentSize = context.options[0];
		indentType = 'space';
			}
	}

	var indentChar = indentType === 'space' ? ' ' : '\t';
	function getFixerFunction(node, needed) {
			return function (fixer) {
		var indent = Array(needed + 1).join(indentChar);
		return fixer.replaceTextRange([node.start - node.loc.start.column, node.start], indent);
			};
	}
	function report(node, needed, gotten, loc) {
			var msgContext = {
		needed: needed,
		type: indentType,
		characters: needed === 1 ? 'character' : 'characters',
		gotten: gotten
			};

			if (loc) {
		context.report({
					node: node,
					loc: loc,
					message: MESSAGE,
					data: msgContext,
					fix: getFixerFunction(node, needed)
		});
			} else {
		context.report({
					node: node,
					message: MESSAGE,
					data: msgContext,
					fix: getFixerFunction(node, needed)
		});
			}
	}
	function getNodeIndent(node, byLastLine, excludeCommas) {
			byLastLine = byLastLine || false;
			excludeCommas = excludeCommas || false;

			var src = sourceCode.getText(node, node.loc.start.column + extraColumnStart);
			var lines = src.split('\n');
			if (byLastLine) {
		src = lines[lines.length - 1];
			} else {
		src = lines[0];
			}

			var skip = excludeCommas ? ',' : '';

			var regExp = void 0;
			if (indentType === 'space') {
		regExp = new RegExp('^[ ' + skip + ']+');
			} else {
		regExp = new RegExp('^[\t' + skip + ']+');
			}

			var indent = regExp.exec(src);
			return indent ? indent[0].length : 0;
	}
	function isNodeFirstInLine(node) {
			var token = node;
			do {
		token = sourceCode.getTokenBefore(token);
			} while (token.type === 'JSXText' && /^\s*$/.test(token.value));
			var startLine = node.loc.start.line;
			var endLine = token ? token.loc.end.line : -1;

			return startLine !== endLine;
	}
	function isRightInLogicalExp(node) {
			return node.parent && node.parent.parent && node.parent.parent.type === 'LogicalExpression' && node.parent.parent.right === node.parent;
	}
	function isAlternateInConditionalExp(node) {
			return node.parent && node.parent.parent && node.parent.parent.type === 'ConditionalExpression' && node.parent.parent.alternate === node.parent && sourceCode.getTokenBefore(node).value !== '(';
	}
	function checkNodesIndent(node, indent, excludeCommas) {
			var nodeIndent = getNodeIndent(node, false, excludeCommas);
			var isCorrectRightInLogicalExp = isRightInLogicalExp(node) && nodeIndent - indent === indentSize;
			var isCorrectAlternateInCondExp = isAlternateInConditionalExp(node) && nodeIndent - indent === 0;
			if (nodeIndent !== indent && isNodeFirstInLine(node) && !isCorrectRightInLogicalExp && !isCorrectAlternateInCondExp) {
		report(node, indent, nodeIndent);
			}
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		var prevToken = sourceCode.getTokenBefore(node);
		if (!prevToken) {
					return;
		}
		if (prevToken.type === 'JSXText' || prevToken.type === 'Punctuator' && prevToken.value === ',') {
					prevToken = sourceCode.getNodeByRangeIndex(prevToken.start);
					prevToken = prevToken.type === 'Literal' ? prevToken.parent : prevToken;
		} else if (prevToken.type === 'Punctuator' && prevToken.value === ':') {
					do {
			prevToken = sourceCode.getTokenBefore(prevToken);
					} while (prevToken.type === 'Punctuator');
					prevToken = sourceCode.getNodeByRangeIndex(prevToken.range[0]);
					while (prevToken.parent && prevToken.parent.type !== 'ConditionalExpression') {
			prevToken = prevToken.parent;
					}
		}
		prevToken = prevToken.type === 'JSXExpressionContainer' ? prevToken.expression : prevToken;

		var parentElementIndent = getNodeIndent(prevToken);
		var indent = prevToken.loc.start.line === node.loc.start.line || isRightInLogicalExp(node) || isAlternateInConditionalExp(node) ? 0 : indentSize;
		checkNodesIndent(node, parentElementIndent + indent);
			},
			JSXClosingElement: function JSXClosingElement(node) {
		if (!node.parent) {
					return;
		}
		var peerElementIndent = getNodeIndent(node.parent.openingElement);
		checkNodesIndent(node, peerElementIndent);
			},
			JSXExpressionContainer: function JSXExpressionContainer(node) {
		if (!node.parent) {
					return;
		}
		var parentNodeIndent = getNodeIndent(node.parent);
		checkNodesIndent(node, parentNodeIndent + indentSize);
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Validate props indentation in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			oneOf: [{
		enum: ['tab']
			}, {
		type: 'integer'
			}]
	}]
  },

  create: function create(context) {
	var MESSAGE = 'Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.';

	var extraColumnStart = 0;
	var indentType = 'space';
	var indentSize = 4;

	var sourceCode = context.getSourceCode();

	if (context.options.length) {
			if (context.options[0] === 'tab') {
		indentSize = 1;
		indentType = 'tab';
			} else if (typeof context.options[0] === 'number') {
		indentSize = context.options[0];
		indentType = 'space';
			}
	}
	function report(node, needed, gotten, loc) {
			var msgContext = {
		needed: needed,
		type: indentType,
		characters: needed === 1 ? 'character' : 'characters',
		gotten: gotten
			};

			if (loc) {
		context.report({
					node: node,
					loc: loc,
					message: MESSAGE,
					data: msgContext
		});
			} else {
		context.report({
					node: node,
					message: MESSAGE,
					data: msgContext,
					fix: function fix(fixer) {
			return fixer.replaceTextRange([node.start - node.loc.start.column, node.start], Array(needed + 1).join(indentType === 'space' ? ' ' : '\t'));
					}
		});
			}
	}
	function getNodeIndent(node, byLastLine, excludeCommas) {
			byLastLine = byLastLine || false;
			excludeCommas = excludeCommas || false;

			var src = sourceCode.getText(node, node.loc.start.column + extraColumnStart);
			var lines = src.split('\n');
			if (byLastLine) {
		src = lines[lines.length - 1];
			} else {
		src = lines[0];
			}

			var skip = excludeCommas ? ',' : '';

			var regExp = void 0;
			if (indentType === 'space') {
		regExp = new RegExp('^[ ' + skip + ']+');
			} else {
		regExp = new RegExp('^[\t' + skip + ']+');
			}

			var indent = regExp.exec(src);
			return indent ? indent[0].length : 0;
	}
	function isNodeFirstInLine(node, byEndLocation) {
			var firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node);
			var startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line;
			var endLine = firstToken ? firstToken.loc.end.line : -1;

			return startLine !== endLine;
	}
	function checkNodesIndent(nodes, indent, excludeCommas) {
			nodes.forEach(function (node) {
		var nodeIndent = getNodeIndent(node, false, excludeCommas);
		if (node.type !== 'ArrayExpression' && node.type !== 'ObjectExpression' && nodeIndent !== indent && isNodeFirstInLine(node)) {
					report(node, indent, nodeIndent);
		}
			});
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		var elementIndent = getNodeIndent(node);
		checkNodesIndent(node.attributes, elementIndent + indentSize);
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var hasProp = __webpack_require__(678);
module.exports = {
  meta: {
	docs: {
			description: 'Report missing `key` props in iterators/collection literals',
			category: 'Possible Errors',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	function checkIteratorElement(node) {
			if (node.type === 'JSXElement' && !hasProp(node.openingElement.attributes, 'key')) {
		context.report({
					node: node,
					message: 'Missing "key" prop for element in iterator'
		});
			}
	}

	function getReturnStatement(body) {
			return body.filter(function (item) {
		return item.type === 'ReturnStatement';
			})[0];
	}

	return {
			JSXElement: function JSXElement(node) {
		if (hasProp(node.openingElement.attributes, 'key')) {
					return;
		}

		if (node.parent.type === 'ArrayExpression') {
					context.report({
			node: node,
			message: 'Missing "key" prop for element in array'
					});
		}
			},
			CallExpression: function CallExpression(node) {
		if (node.callee && node.callee.type !== 'MemberExpression') {
					return;
		}

		if (node.callee && node.callee.property && node.callee.property.name !== 'map') {
					return;
		}

		var fn = node.arguments[0];
		var isFn = fn && fn.type === 'FunctionExpression';
		var isArrFn = fn && fn.type === 'ArrowFunctionExpression';

		if (isArrFn && fn.body.type === 'JSXElement') {
					checkIteratorElement(fn.body);
		}

		if (isFn || isArrFn) {
					if (fn.body.type === 'BlockStatement') {
			var returnStatement = getReturnStatement(fn.body.body);
			if (returnStatement && returnStatement.argument) {
							checkIteratorElement(returnStatement.argument);
			}
					}
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(109).hasProp; // eslint-disable-line import/no-unresolved
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hasProp;
exports.hasAnyProp = hasAnyProp;
exports.hasEveryProp = hasEveryProp;

var _propName = __webpack_require__(110);

var _propName2 = _interopRequireDefault(_propName);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var DEFAULT_OPTIONS = {
  spreadStrict: true,
  ignoreCase: true
};
function hasProp() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;

  var propToCheck = options.ignoreCase ? prop.toUpperCase() : prop;

  return props.some(function (attribute) {
	if (attribute.type === 'JSXSpreadAttribute') {
			return !options.spreadStrict;
	}

	var currentProp = options.ignoreCase ? (0, _propName2.default)(attribute).toUpperCase() : (0, _propName2.default)(attribute);

	return propToCheck === currentProp;
  });
}
function hasAnyProp() {
  var nodeProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;

  var propsToCheck = typeof props === 'string' ? props.split(' ') : props;

  return propsToCheck.some(function (prop) {
	return hasProp(nodeProps, prop, options);
  });
}
function hasEveryProp() {
  var nodeProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;

  var propsToCheck = typeof props === 'string' ? props.split(' ') : props;

  return propsToCheck.every(function (prop) {
	return hasProp(nodeProps, prop, options);
  });
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = elementType;
function resolveMemberExpressions() {
  var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var property = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (object.type === 'JSXMemberExpression') {
	return resolveMemberExpressions(object.object, object.property) + '.' + property.name;
  }

  return object.name + '.' + property.name;
}
function elementType() {
  var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var name = node.name;

  if (!name) {
	throw new Error('The argument provided is not a JSXElement node.');
  }

  if (name.type === 'JSXMemberExpression') {
	var _name$object = name.object,
		object = _name$object === undefined ? {} : _name$object,
		_name$property = name.property,
		property = _name$property === undefined ? {} : _name$property;

	return resolveMemberExpressions(object, property);
  } else if (name.type === 'JSXNamespacedName') {
	return name.namespace.name + ':' + name.name.name;
  }

  return node.name.name;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var eventHandlersByType = {
  clipboard: ['onCopy', 'onCut', 'onPaste'],
  composition: ['onCompositionEnd', 'onCompositionStart', 'onCompositionUpdate'],
  keyboard: ['onKeyDown', 'onKeyPress', 'onKeyUp'],
  focus: ['onFocus', 'onBlur'],
  form: ['onChange', 'onInput', 'onSubmit'],
  mouse: ['onClick', 'onContextMenu', 'onDblClick', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp'],
  selection: ['onSelect'],
  touch: ['onTouchCancel', 'onTouchEnd', 'onTouchMove', 'onTouchStart'],
  ui: ['onScroll'],
  wheel: ['onWheel'],
  media: ['onAbort', 'onCanPlay', 'onCanPlayThrough', 'onDurationChange', 'onEmptied', 'onEncrypted', 'onEnded', 'onError', 'onLoadedData', 'onLoadedMetadata', 'onLoadStart', 'onPause', 'onPlay', 'onPlaying', 'onProgress', 'onRateChange', 'onSeeked', 'onSeeking', 'onStalled', 'onSuspend', 'onTimeUpdate', 'onVolumeChange', 'onWaiting'],
  image: ['onLoad', 'onError'],
  animation: ['onAnimationStart', 'onAnimationEnd', 'onAnimationIteration'],
  transition: ['onTransitionEnd']
};

var eventHandlers = Object.keys(eventHandlersByType).reduce(function (accumulator, type) {
  return accumulator.concat(eventHandlersByType[type]);
}, []);

exports.default = eventHandlers;
exports.eventHandlersByType = eventHandlersByType;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getProp;

var _propName = __webpack_require__(110);

var _propName2 = _interopRequireDefault(_propName);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var DEFAULT_OPTIONS = {
  ignoreCase: true
};
function getProp() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;

  var propToFind = options.ignoreCase ? prop.toUpperCase() : prop;

  return props.find(function (attribute) {
	if (attribute.type === 'JSXSpreadAttribute') {
			return false;
	}

	var currentProp = options.ignoreCase ? (0, _propName2.default)(attribute).toUpperCase() : (0, _propName2.default)(attribute);

	return propToFind === currentProp;
  });
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getPropValue;
exports.getLiteralPropValue = getLiteralPropValue;

var _values = __webpack_require__(684);

var _values2 = _interopRequireDefault(_values);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var extractValue = function extractValue(attribute, extractor) {
  if (attribute && attribute.type === 'JSXAttribute') {
	if (attribute.value === null) {
			return true;
	}

	return extractor(attribute.value);
  }

  return undefined;
};
function getPropValue(attribute) {
  return extractValue(attribute, _values2.default);
}
function getLiteralPropValue(attribute) {
  return extractValue(attribute, _values.getLiteralValue);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getValue;
exports.getLiteralValue = getLiteralValue;

var _Literal = __webpack_require__(166);

var _Literal2 = _interopRequireDefault(_Literal);

var _JSXElement = __webpack_require__(167);

var _JSXElement2 = _interopRequireDefault(_JSXElement);

var _expressions = __webpack_require__(21);

var _expressions2 = _interopRequireDefault(_expressions);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var TYPES = {
  Literal: _Literal2.default,
  JSXElement: _JSXElement2.default,
  JSXExpressionContainer: _expressions2.default
};
var LITERAL_TYPES = Object.assign({}, TYPES, {
  JSXElement: function JSXElement() {
	return null;
  },
  JSXExpressionContainer: _expressions.extractLiteral
});
function getValue(value) {
  return TYPES[value.type](value);
}
function getLiteralValue(value) {
  return LITERAL_TYPES[value.type](value);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromIdentifier;
var JS_RESERVED = {
  Array: Array,
  Date: Date,
  Infinity: Infinity,
  Math: Math,
  Number: Number,
  Object: Object,
  String: String,
  undefined: undefined
};
function extractValueFromIdentifier(value) {
  var name = value.name;

  if (Object.hasOwnProperty.call(JS_RESERVED, name)) {
	return JS_RESERVED[name];
  }

  return name;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromTaggedTemplateExpression;

var _TemplateLiteral = __webpack_require__(168);

var _TemplateLiteral2 = _interopRequireDefault(_TemplateLiteral);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromTaggedTemplateExpression(value) {
  return (0, _TemplateLiteral2.default)(value.quasi);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromFunctionExpression;
function extractValueFromFunctionExpression(value) {
  return function () {
	return value;
  };
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromLogicalExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromLogicalExpression(value) {
  var operator = value.operator,
			left = value.left,
			right = value.right;

  var leftVal = (0, _index2.default)(left);
  var rightVal = (0, _index2.default)(right);

  return operator === '&&' ? leftVal && rightVal : leftVal || rightVal;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromMemberExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromMemberExpression(value) {
  return (0, _index2.default)(value.object) + '.' + (0, _index2.default)(value.property);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromCallExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromCallExpression(value) {
  return (0, _index2.default)(value.callee);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromUnaryExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromUnaryExpression(value) {
  var operator = value.operator,
			argument = value.argument;

  switch (operator) {
	case '-':
			return -(0, _index2.default)(argument);
	case '+':
			return +(0, _index2.default)(argument); // eslint-disable-line no-implicit-coercion
	case '!':
			return !(0, _index2.default)(argument);
	case '~':
			return ~(0, _index2.default)(argument); // eslint-disable-line no-bitwise
	case 'delete':
			return true;
	case 'typeof':
	case 'void':
	default:
			return undefined;
  }
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromThisExpression;
function extractValueFromThisExpression() {
  return 'this';
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromConditionalExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromConditionalExpression(value) {
  var test = value.test,
			alternate = value.alternate,
			consequent = value.consequent;

  return (0, _index2.default)(test) ? (0, _index2.default)(consequent) : (0, _index2.default)(alternate);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromBinaryExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromBinaryExpression(value) {
  var operator = value.operator,
			left = value.left,
			right = value.right;

  var leftVal = (0, _index2.default)(left);
  var rightVal = (0, _index2.default)(right);

  switch (operator) {
	case '==':
			return leftVal == rightVal; // eslint-disable-line
	case '!=':
			return leftVal != rightVal; // eslint-disable-line
	case '===':
			return leftVal === rightVal;
	case '!==':
			return leftVal !== rightVal;
	case '<':
			return leftVal < rightVal;
	case '<=':
			return leftVal <= rightVal;
	case '>':
			return leftVal > rightVal;
	case '>=':
			return leftVal >= rightVal;
	case '<<':
			return leftVal << rightVal; // eslint-disable-line no-bitwise
	case '>>':
			return leftVal >> rightVal; // eslint-disable-line no-bitwise
	case '>>>':
			return leftVal >>> rightVal; // eslint-disable-line no-bitwise
	case '+':
			return leftVal + rightVal;
	case '-':
			return leftVal - rightVal;
	case '*':
			return leftVal * rightVal;
	case '/':
			return leftVal / rightVal;
	case '%':
			return leftVal % rightVal;
	case '|':
			return leftVal | rightVal; // eslint-disable-line no-bitwise
	case '^':
			return leftVal ^ rightVal; // eslint-disable-line no-bitwise
	case '&':
			return leftVal & rightVal; // eslint-disable-line no-bitwise
	case 'in':
			try {
		return leftVal in rightVal;
			} catch (err) {
		return false;
			}
	case 'instanceof':
			if (typeof rightVal !== 'function') {
		return false;
			}
			return leftVal instanceof rightVal;
	default:
			return undefined;
  }
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromObjectExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromObjectExpression(value) {
  return value.properties.reduce(function (obj, property) {
	var object = Object.assign({}, obj);
	object[(0, _index2.default)(property.key)] = (0, _index2.default)(property.value);
	return object;
  }, {});
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromNewExpression;
function extractValueFromNewExpression() {
  return new Object(); // eslint-disable-line
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromUpdateExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromUpdateExpression(value) {
  var operator = value.operator,
			argument = value.argument,
			prefix = value.prefix;

  var val = (0, _index2.default)(argument);

  switch (operator) {
	case '++':
			return prefix ? ++val : val++; // eslint-disable-line no-plusplus
	case '--':
			return prefix ? --val : val--; // eslint-disable-line no-plusplus
	default:
			return undefined;
  }
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromArrayExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromArrayExpression(value) {
  return value.elements.map(function (element) {
	return (0, _index2.default)(element);
  });
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromBindExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromBindExpression(value) {
  var callee = (0, _index2.default)(value.callee);
  var object = value.object === null ? (0, _index2.default)(value.callee.object) : (0, _index2.default)(value.object);

  if (value.object && value.object.property) {
	return object + '.' + callee + '.bind(' + object + ')';
  }

  return callee + '.bind(' + object + ')';
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Limit maximum of props on a single line in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',
	schema: [{
			type: 'object',
			properties: {
		maximum: {
					type: 'integer',
					minimum: 1
		},
		when: {
					type: 'string',
					enum: ['always', 'multiline']
		}
			}
	}]
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();
	var configuration = context.options[0] || {};
	var maximum = configuration.maximum || 1;
	var when = configuration.when || 'always';

	function getPropName(propNode) {
			if (propNode.type === 'JSXSpreadAttribute') {
		return sourceCode.getText(propNode.argument);
			}
			return propNode.name.name;
	}

	function generateFixFunction(line, max) {
			var output = [];
			var front = line[0].start;
			var back = line[line.length - 1].end;
			for (var i = 0; i < line.length; i += max) {
		var nodes = line.slice(i, i + max);
		output.push(nodes.reduce(function (prev, curr) {
					if (prev === '') {
			return sourceCode.getText(curr);
					}
					return prev + ' ' + sourceCode.getText(curr);
		}, ''));
			}
			var code = output.join('\n');
			return function (fixer) {
		return fixer.replaceTextRange([front, back], code);
			};
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		if (!node.attributes.length) {
					return;
		}

		if (when === 'multiline' && node.loc.start.line === node.loc.end.line) {
					return;
		}

		var firstProp = node.attributes[0];
		var linePartitionedProps = [[firstProp]];

		node.attributes.reduce(function (last, decl) {
					if (last.loc.end.line === decl.loc.start.line) {
			linePartitionedProps[linePartitionedProps.length - 1].push(decl);
					} else {
			linePartitionedProps.push([decl]);
					}
					return decl;
		});

		linePartitionedProps.forEach(function (propsInLine) {
					if (propsInLine.length > maximum) {
			var name = getPropName(propsInLine[maximum]);
			context.report({
							node: propsInLine[maximum],
							message: 'Prop `' + name + '` must be placed on a new line',
							fix: generateFixFunction(propsInLine, maximum)
			});
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var Components = __webpack_require__(8);
var propName = __webpack_require__(169);
module.exports = {
  meta: {
	docs: {
			description: 'Prevents usage of Function.prototype.bind and arrow functions in React component definition',
			category: 'Best Practices',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		allowArrowFunctions: {
					default: false,
					type: 'boolean'
		},
		allowBind: {
					default: false,
					type: 'boolean'
		},
		ignoreRefs: {
					default: false,
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var configuration = context.options[0] || {};

	return {
			CallExpression: function CallExpression(node) {
		var callee = node.callee;
		if (!configuration.allowBind && (callee.type !== 'MemberExpression' || callee.property.name !== 'bind')) {
					return;
		}
		var ancestors = context.getAncestors(callee).reverse();
		for (var i = 0, j = ancestors.length; i < j; i++) {
					if (!configuration.allowBind && ancestors[i].type === 'MethodDefinition' && ancestors[i].key.name === 'render' || ancestors[i].type === 'Property' && ancestors[i].key.name === 'render') {
			if (utils.isReturningJSX(ancestors[i])) {
							context.report({
				node: callee,
				message: 'JSX props should not use .bind()'
							});
			}
			break;
					}
		}
			},

			JSXAttribute: function JSXAttribute(node) {
		var isRef = configuration.ignoreRefs && propName(node) === 'ref';
		if (isRef || !node.value || !node.value.expression) {
					return;
		}
		var valueNode = node.value.expression;
		if (!configuration.allowBind && valueNode.type === 'CallExpression' && valueNode.callee.type === 'MemberExpression' && valueNode.callee.property.name === 'bind') {
					context.report({
			node: node,
			message: 'JSX props should not use .bind()'
					});
		} else if (!configuration.allowArrowFunctions && valueNode.type === 'ArrowFunctionExpression') {
					context.report({
			node: node,
			message: 'JSX props should not use arrow functions'
					});
		} else if (!configuration.allowBind && valueNode.type === 'BindExpression') {
					context.report({
			node: node,
			message: 'JSX props should not use ::'
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Comments inside children section of tag should be placed inside braces',
			category: 'Possible Errors',
			recommended: true
	},

	schema: [{
			type: 'object',
			properties: {},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	function reportLiteralNode(node) {
			context.report(node, 'Comments inside children section of tag should be placed inside braces');
	}
	return {
			Literal: function Literal(node) {
		if (/^\s*\/(\/|\*)/m.test(node.value)) {
					if (node.parent.type !== 'JSXAttribute' && node.parent.type !== 'JSXExpressionContainer' && node.parent.type.indexOf('JSX') !== -1) {
			reportLiteralNode(node);
					}
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var has = __webpack_require__(7);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce no duplicate props',
			category: 'Possible Errors',
			recommended: true
	},

	schema: [{
			type: 'object',
			properties: {
		ignoreCase: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var configuration = context.options[0] || {};
	var ignoreCase = configuration.ignoreCase || false;

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		var props = {};

		node.attributes.forEach(function (decl) {
					if (decl.type === 'JSXSpreadAttribute') {
			return;
					}

					var name = decl.name.name;

					if (typeof name !== 'string') {
			return;
					}

					if (ignoreCase) {
			name = name.toLowerCase();
					}

					if (has(props, name)) {
			context.report({
							node: decl,
							message: 'No duplicate props allowed'
			});
					} else {
			props[name] = 1;
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Prevent using string literals in React component definition',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		noStrings: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var isNoStrings = context.options[0] ? context.options[0].noStrings : false;

	var message = isNoStrings ? 'Strings not allowed in JSX files' : 'Missing JSX expression container around literal string';

	function reportLiteralNode(node) {
			context.report({
		node: node,
		message: message
			});
	}

	function getValidation(node) {
			var standard = !/^[\s]+$/.test(node.value) && typeof node.value === 'string' && node.parent && node.parent.type.indexOf('JSX') !== -1 && node.parent.type !== 'JSXAttribute';
			if (isNoStrings) {
		return standard;
			}
			return standard && node.parent.type !== 'JSXExpressionContainer';
	}
	return {

			Literal: function Literal(node) {
		if (getValidation(node)) {
					reportLiteralNode(node);
		}
			},

			TemplateLiteral: function TemplateLiteral(node) {
		if (isNoStrings && node.parent.type === 'JSXExpressionContainer') {
					reportLiteralNode(node);
		}
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function isTargetBlank(attr) {
  return attr.name.name === 'target' && attr.value.type === 'Literal' && attr.value.value.toLowerCase() === '_blank';
}

function hasExternalLink(element) {
  return element.attributes.some(function (attr) {
	return attr.name && attr.name.name === 'href' && attr.value.type === 'Literal' && /^(?:\w+:|\/\/)/.test(attr.value.value);
  });
}

function hasSecureRel(element) {
  return element.attributes.find(function (attr) {
	if (attr.type === 'JSXAttribute' && attr.name.name === 'rel') {
			var tags = attr.value && attr.value.type === 'Literal' && attr.value.value.toLowerCase().split(' ');
			return tags && tags.indexOf('noopener') >= 0 && tags.indexOf('noreferrer') >= 0;
	}
	return false;
  });
}

module.exports = {
  meta: {
	docs: {
			description: 'Forbid target="_blank" attribute without rel="noopener noreferrer"',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	return {
			JSXAttribute: function JSXAttribute(node) {
		if (node.parent.name.name !== 'a') {
					return;
		}

		if (isTargetBlank(node) && hasExternalLink(node.parent) && !hasSecureRel(node.parent)) {
					context.report(node, 'Using target="_blank" without rel="noopener noreferrer" ' + 'is a security risk: see https://mathiasbynens.github.io/rel-noopener');
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var tagConvention = /^[a-z]|\-/;
function isTagName(name) {
  return tagConvention.test(name);
}
module.exports = {
  meta: {
	docs: {
			description: 'Disallow undeclared variables in JSX',
			category: 'Possible Errors',
			recommended: true
	},
	schema: [{
			type: 'object',
			properties: {
		allowGlobals: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var config = context.options[0] || {};
	var allowGlobals = config.allowGlobals || false;
	function checkIdentifierInJSX(node) {
			var scope = context.getScope();
			var sourceCode = context.getSourceCode();
			var sourceType = sourceCode.ast.sourceType;
			var variables = scope.variables;
			var scopeType = 'global';
			var i = void 0;
			var len = void 0;
			if (node.name === 'this') {
		return;
			}

			if (!allowGlobals && sourceType === 'module') {
		scopeType = 'module';
			}

			while (scope.type !== scopeType) {
		scope = scope.upper;
		variables = scope.variables.concat(variables);
			}
			if (scope.childScopes.length) {
		variables = scope.childScopes[0].variables.concat(variables);
		if (scope.childScopes[0].childScopes.length) {
					variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
		}
			}

			for (i = 0, len = variables.length; i < len; i++) {
		if (variables[i].name === node.name) {
					return;
		}
			}

			context.report({
		node: node,
		message: '\'' + node.name + '\' is not defined.'
			});
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		switch (node.name.type) {
					case 'JSXIdentifier':
			node = node.name;
			if (isTagName(node.name)) {
							return;
			}
			break;
					case 'JSXMemberExpression':
			node = node.name;
			do {
							node = node.object;
			} while (node && node.type !== 'JSXIdentifier');
			break;
					case 'JSXNamespacedName':
			node = node.name.namespace;
			break;
					default:
			break;
		}
		checkIdentifierInJSX(node);
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var OPTION_ALWAYS = 'always';
var OPTION_NEVER = 'never';
var OPTION_IGNORE = 'ignore';

var OPTION_VALUES = [OPTION_ALWAYS, OPTION_NEVER, OPTION_IGNORE];
var DEFAULT_CONFIG = { props: OPTION_NEVER, children: OPTION_NEVER };
module.exports = {
  meta: {
	docs: {
			description: 'Disallow unnecessary JSX expressions when literals alone are sufficient ' + 'or enfore JSX expressions on literals in JSX children or attributes',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			oneOf: [{
		type: 'object',
		properties: {
					props: { enum: OPTION_VALUES, default: OPTION_NEVER },
					children: { enum: OPTION_VALUES, default: OPTION_NEVER }
		},
		additionalProperties: false
			}, {
		enum: OPTION_VALUES
			}]
	}]
  },

  create: function create(context) {
	var ruleOptions = context.options[0];
	var userConfig = typeof ruleOptions === 'string' ? { props: ruleOptions, children: ruleOptions } : Object.assign({}, DEFAULT_CONFIG, ruleOptions);

	function containsBackslashForEscaping(rawStringValue) {
			return rawStringValue.includes('\\');
	}

	function escapeDoubleQuotes(rawStringValue) {
			return rawStringValue.replace(/\\"/g, '"').replace(/"/g, '\\"');
	}
	function reportUnnecessaryCurly(JSXExpressionNode) {
			context.report({
		node: JSXExpressionNode,
		message: 'Curly braces are unnecessary here.',
		fix: function fix(fixer) {
					var expression = JSXExpressionNode.expression;
					var expressionType = expression.type;
					var parentType = JSXExpressionNode.parent.type;

					var textToReplace = void 0;
					if (parentType === 'JSXAttribute') {
			textToReplace = '"' + escapeDoubleQuotes(expressionType === 'TemplateLiteral' ? expression.quasis[0].value.raw : expression.raw.substring(1, expression.raw.length - 1)) + '"';
					} else {
			textToReplace = expressionType === 'TemplateLiteral' ? expression.quasis[0].value.cooked : expression.value;
					}

					return fixer.replaceText(JSXExpressionNode, textToReplace);
		}
			});
	}

	function reportMissingCurly(literalNode) {
			context.report({
		node: literalNode,
		message: 'Need to wrap this literal in a JSX expression.',
		fix: function fix(fixer) {
					var expression = literalNode.parent.type === 'JSXAttribute' ? '{"' + escapeDoubleQuotes(literalNode.raw.substring(1, literalNode.raw.length - 1)) + '"}' : '{' + JSON.stringify(literalNode.value) + '}';

					return fixer.replaceText(literalNode, expression);
		}
			});
	}

	function lintUnnecessaryCurly(JSXExpressionNode) {
			var expression = JSXExpressionNode.expression;
			var expressionType = expression.type;
			var parentType = JSXExpressionNode.parent.type;

			if (expressionType === 'Literal' && typeof expression.value === 'string' && (parentType === 'JSXAttribute' || !containsBackslashForEscaping(expression.raw))) {
		reportUnnecessaryCurly(JSXExpressionNode);
			} else if (expressionType === 'TemplateLiteral' && expression.expressions.length === 0 && (parentType === 'JSXAttribute' || !containsBackslashForEscaping(expression.quasis[0].value.raw))) {
		reportUnnecessaryCurly(JSXExpressionNode);
			}
	}

	function areRuleConditionsSatisfied(parentType, config, ruleCondition) {
			return parentType === 'JSXAttribute' && typeof config.props === 'string' && config.props === ruleCondition || parentType === 'JSXElement' && typeof config.children === 'string' && config.children === ruleCondition;
	}

	function shouldCheckForUnnecessaryCurly(parent, config) {
			var parentType = parent.type;
			if (parentType === 'JSXElement' && parent.children.length !== 1) {
		return false;
			}

			return areRuleConditionsSatisfied(parentType, config, OPTION_NEVER);
	}

	function shouldCheckForMissingCurly(parentType, config) {
			return areRuleConditionsSatisfied(parentType, config, OPTION_ALWAYS);
	}
	return {
			JSXExpressionContainer: function JSXExpressionContainer(node) {
		var parent = node.parent;

		if (shouldCheckForUnnecessaryCurly(parent, userConfig)) {
					lintUnnecessaryCurly(node);
		}
			},

			Literal: function Literal(node) {
		var parentType = node.parent.type;

		if (shouldCheckForMissingCurly(parentType, userConfig)) {
					reportMissingCurly(node);
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var elementType = __webpack_require__(170);
var PASCAL_CASE_REGEX = /^([A-Z0-9]|[A-Z0-9]+[a-z0-9]+(?:[A-Z0-9]+[a-z0-9]*)*)$/;
var COMPAT_TAG_REGEX = /^[a-z]|\-/;
var ALL_CAPS_TAG_REGEX = /^[A-Z0-9]+$/;
module.exports = {
  meta: {
	docs: {
			description: 'Enforce PascalCase for user-defined JSX components',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		allowAllCaps: {
					type: 'boolean'
		},
		ignore: {
					type: 'array'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var configuration = context.options[0] || {};
	var allowAllCaps = configuration.allowAllCaps || false;
	var ignore = configuration.ignore || [];

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		var name = elementType(node);
		if (name.indexOf(':') > -1) {
					name = name.substring(0, name.indexOf(':'));
		} else if (name.indexOf('.') > -1) {
					name = name.substring(0, name.indexOf('.'));
		}

		var isPascalCase = PASCAL_CASE_REGEX.test(name);
		var isCompatTag = COMPAT_TAG_REGEX.test(name);
		var isAllowedAllCaps = allowAllCaps && ALL_CAPS_TAG_REGEX.test(name);
		var isIgnored = ignore.indexOf(name) !== -1;

		if (!isPascalCase && !isCompatTag && !isAllowedAllCaps && !isIgnored) {
					context.report({
			node: node,
			message: 'Imported JSX component ' + name + ' must be in PascalCase'
					});
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var elementType = __webpack_require__(170);
var propName = __webpack_require__(169);
function isCallbackPropName(name) {
  return (/^on[A-Z]/.test(name)
  );
}

var COMPAT_TAG_REGEX = /^[a-z]|\-/;
function isDOMComponent(node) {
  var name = elementType(node);
  if (name.indexOf(':') > -1) {
	name = name.substring(0, name.indexOf(':'));
  } else if (name.indexOf('.') > -1) {
	name = name.substring(0, name.indexOf('.'));
  }

  return COMPAT_TAG_REGEX.test(name);
}

var RESERVED_PROPS_LIST = ['children', 'dangerouslySetInnerHTML', 'key', 'ref'];

function isReservedPropName(name, list) {
  return list.indexOf(name) >= 0;
}

function alphabeticalCompare(a, b, ignoreCase) {
  if (ignoreCase) {
	a = a.toLowerCase();
	b = b.toLowerCase();
  }
  return a.localeCompare(b);
}
function getGroupsOfSortableAttributes(attributes) {
  var sortableAttributeGroups = [];
  var groupCount = 0;
  for (var i = 0; i < attributes.length; i++) {
	var lastAttr = attributes[i - 1];
	if (!lastAttr || lastAttr.type === 'JSXSpreadAttribute' && attributes[i].type !== 'JSXSpreadAttribute') {
			groupCount++;
			sortableAttributeGroups[groupCount - 1] = [];
	}
	if (attributes[i].type !== 'JSXSpreadAttribute') {
			sortableAttributeGroups[groupCount - 1].push(attributes[i]);
	}
  }
  return sortableAttributeGroups;
}

var generateFixerFunction = function generateFixerFunction(node, context) {
  var sourceCode = context.getSourceCode();
  var attributes = node.attributes.slice(0);
  var configuration = context.options[0] || {};
  var ignoreCase = configuration.ignoreCase || false;
  var sortableAttributeGroups = getGroupsOfSortableAttributes(attributes);
  var sortedAttributeGroups = sortableAttributeGroups.slice(0).map(function (group) {
	return group.slice(0).sort(function (a, b) {
			return alphabeticalCompare(propName(a), propName(b), ignoreCase);
	});
  });

  return function (fixer) {
	var fixers = [];
	sortableAttributeGroups.forEach(function (sortableGroup, ii) {
			sortableGroup.forEach(function (attr, jj) {
		var sortedAttr = sortedAttributeGroups[ii][jj];
		var sortedAttrText = sourceCode.getText(sortedAttr);
		fixers.push(fixer.replaceTextRange([attr.start, attr.end], sortedAttrText));
			});
	});

	return fixers;
  };
};
function validateReservedFirstConfig(context, reservedFirst) {
  if (reservedFirst) {
	if (Array.isArray(reservedFirst)) {
			var nonReservedWords = reservedFirst.filter(function (word) {
		if (!isReservedPropName(word, RESERVED_PROPS_LIST)) {
					return true;
		}
			});

			if (reservedFirst.length === 0) {
		return function (decl) {
					context.report({
			node: decl,
			message: 'A customized reserved first list must not be empty'
					});
		};
			} else if (nonReservedWords.length > 0) {
		return function (decl) {
					context.report({
			node: decl,
			message: 'A customized reserved first list must only contain a subset of React reserved props.' + ' Remove: {{ nonReservedWords }}',
			data: {
							nonReservedWords: nonReservedWords.toString()
			}
					});
		};
			}
	}
  }
}

module.exports = {
  meta: {
	docs: {
			description: 'Enforce props alphabetical sorting',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',
	schema: [{
			type: 'object',
			properties: {
		callbacksLast: {
					type: 'boolean'
		},
		shorthandFirst: {
					type: 'boolean'
		},
		shorthandLast: {
					type: 'boolean'
		},
		ignoreCase: {
					type: 'boolean'
		},
		noSortAlphabetically: {
					type: 'boolean'
		},
		reservedFirst: {
					type: ['array', 'boolean']
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var configuration = context.options[0] || {};
	var ignoreCase = configuration.ignoreCase || false;
	var callbacksLast = configuration.callbacksLast || false;
	var shorthandFirst = configuration.shorthandFirst || false;
	var shorthandLast = configuration.shorthandLast || false;
	var noSortAlphabetically = configuration.noSortAlphabetically || false;
	var reservedFirst = configuration.reservedFirst || false;
	var reservedFirstError = validateReservedFirstConfig(context, reservedFirst);
	var reservedList = Array.isArray(reservedFirst) ? reservedFirst : RESERVED_PROPS_LIST;

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		if (reservedFirst && !isDOMComponent(node)) {
					reservedList = reservedList.filter(function (prop) {
			return prop !== 'dangerouslySetInnerHTML';
					});
		}

		node.attributes.reduce(function (memo, decl, idx, attrs) {
					if (decl.type === 'JSXSpreadAttribute') {
			return attrs[idx + 1];
					}

					var previousPropName = propName(memo);
					var currentPropName = propName(decl);
					var previousValue = memo.value;
					var currentValue = decl.value;
					var previousIsCallback = isCallbackPropName(previousPropName);
					var currentIsCallback = isCallbackPropName(currentPropName);

					if (ignoreCase) {
			previousPropName = previousPropName.toLowerCase();
			currentPropName = currentPropName.toLowerCase();
					}

					if (reservedFirst) {
			if (reservedFirstError) {
							reservedFirstError(decl);
							return memo;
			}

			var previousIsReserved = isReservedPropName(previousPropName, reservedList);
			var currentIsReserved = isReservedPropName(currentPropName, reservedList);

			if (previousIsReserved && currentIsReserved) {
							if (!noSortAlphabetically && currentPropName < previousPropName) {
				context.report({
									node: decl,
									message: 'Props should be sorted alphabetically',
									fix: generateFixerFunction(node, context)
				});
				return memo;
							}
							return decl;
			}
			if (!previousIsReserved && currentIsReserved) {
							context.report({
				node: decl,
				message: 'Reserved props must be listed before all other props'
							});
							return memo;
			}
			return decl;
					}

					if (callbacksLast) {
			if (!previousIsCallback && currentIsCallback) {
							return decl;
			}
			if (previousIsCallback && !currentIsCallback) {
							context.report({
				node: memo,
				message: 'Callbacks must be listed after all other props'
							});
							return memo;
			}
					}

					if (shorthandFirst) {
			if (currentValue && !previousValue) {
							return decl;
			}
			if (!currentValue && previousValue) {
							context.report({
				node: memo,
				message: 'Shorthand props must be listed before all other props'
							});
							return memo;
			}
					}

					if (shorthandLast) {
			if (!currentValue && previousValue) {
							return decl;
			}
			if (currentValue && !previousValue) {
							context.report({
				node: memo,
				message: 'Shorthand props must be listed after all other props'
							});
							return memo;
			}
					}

					if (!noSortAlphabetically && currentPropName < previousPropName) {
			context.report({
							node: decl,
							message: 'Props should be sorted alphabetically',
							fix: generateFixerFunction(node, context)
			});
			return memo;
					}

					return decl;
		}, node.attributes[0]);
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {/**
 * @fileoverview Validate spacing before closing bracket in JSX.
 * @author ryym
 * @deprecated
 */


var getTokenBeforeClosingBracket = __webpack_require__(171);
var isWarnedForDeprecation = false;
module.exports = {
  meta: {
	deprecated: true,
	docs: {
			description: 'Validate spacing before closing bracket in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			enum: ['always', 'never']
	}]
  },

  create: function create(context) {
	var configuration = context.options[0] || 'always';
	var sourceCode = context.getSourceCode();

	var NEVER_MESSAGE = 'A space is forbidden before closing bracket';
	var ALWAYS_MESSAGE = 'A space is required before closing bracket';
	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		if (!node.selfClosing) {
					return;
		}

		var leftToken = getTokenBeforeClosingBracket(node);
		var closingSlash = sourceCode.getTokenAfter(leftToken);

		if (leftToken.loc.end.line !== closingSlash.loc.start.line) {
					return;
		}

		if (configuration === 'always' && !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {
					context.report({
			loc: closingSlash.loc.start,
			message: ALWAYS_MESSAGE,
			fix: function fix(fixer) {
							return fixer.insertTextBefore(closingSlash, ' ');
			}
					});
		} else if (configuration === 'never' && sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {
					context.report({
			loc: closingSlash.loc.start,
			message: NEVER_MESSAGE,
			fix: function fix(fixer) {
							var previousToken = sourceCode.getTokenBefore(closingSlash);
							return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);
			}
					});
		}
			},

			Program: function Program() {
		if (isWarnedForDeprecation || /\=-(f|-format)=/.test(process.argv.join('='))) {
					return;
		}
		console.log('The react/jsx-space-before-closing rule is deprecated. ' + 'Please use the react/jsx-tag-spacing rule with the ' + '"beforeSelfClosing" option instead.');
		isWarnedForDeprecation = true;
			}
	};
  }
};
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var getTokenBeforeClosingBracket = __webpack_require__(171);
function validateClosingSlash(context, node, option) {
  var sourceCode = context.getSourceCode();

  var SELF_CLOSING_NEVER_MESSAGE = 'Whitespace is forbidden between `/` and `>`; write `/>`';
  var SELF_CLOSING_ALWAYS_MESSAGE = 'Whitespace is required between `/` and `>`; write `/ >`';
  var NEVER_MESSAGE = 'Whitespace is forbidden between `<` and `/`; write `</`';
  var ALWAYS_MESSAGE = 'Whitespace is required between `<` and `/`; write `< /`';

  var adjacent = void 0;

  if (node.selfClosing) {
	var lastTokens = sourceCode.getLastTokens(node, 2);

	adjacent = !sourceCode.isSpaceBetweenTokens(lastTokens[0], lastTokens[1]);

	if (option === 'never') {
			if (!adjacent) {
		context.report({
					node: node,
					loc: {
			start: lastTokens[0].loc.start,
			end: lastTokens[1].loc.end
					},
					message: SELF_CLOSING_NEVER_MESSAGE,
					fix: function fix(fixer) {
			return fixer.removeRange([lastTokens[0].range[1], lastTokens[1].range[0]]);
					}
		});
			}
	} else if (option === 'always' && adjacent) {
			context.report({
		node: node,
		loc: {
					start: lastTokens[0].loc.start,
					end: lastTokens[1].loc.end
		},
		message: SELF_CLOSING_ALWAYS_MESSAGE,
		fix: function fix(fixer) {
					return fixer.insertTextBefore(lastTokens[1], ' ');
		}
			});
	}
  } else {
	var firstTokens = sourceCode.getFirstTokens(node, 2);

	adjacent = !sourceCode.isSpaceBetweenTokens(firstTokens[0], firstTokens[1]);

	if (option === 'never') {
			if (!adjacent) {
		context.report({
					node: node,
					loc: {
			start: firstTokens[0].loc.start,
			end: firstTokens[1].loc.end
					},
					message: NEVER_MESSAGE,
					fix: function fix(fixer) {
			return fixer.removeRange([firstTokens[0].range[1], firstTokens[1].range[0]]);
					}
		});
			}
	} else if (option === 'always' && adjacent) {
			context.report({
		node: node,
		loc: {
					start: firstTokens[0].loc.start,
					end: firstTokens[1].loc.end
		},
		message: ALWAYS_MESSAGE,
		fix: function fix(fixer) {
					return fixer.insertTextBefore(firstTokens[1], ' ');
		}
			});
	}
  }
}

function validateBeforeSelfClosing(context, node, option) {
  var sourceCode = context.getSourceCode();

  var NEVER_MESSAGE = 'A space is forbidden before closing bracket';
  var ALWAYS_MESSAGE = 'A space is required before closing bracket';

  var leftToken = getTokenBeforeClosingBracket(node);
  var closingSlash = sourceCode.getTokenAfter(leftToken);

  if (leftToken.loc.end.line !== closingSlash.loc.start.line) {
	return;
  }

  if (option === 'always' && !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {
	context.report({
			node: node,
			loc: closingSlash.loc.start,
			message: ALWAYS_MESSAGE,
			fix: function fix(fixer) {
		return fixer.insertTextBefore(closingSlash, ' ');
			}
	});
  } else if (option === 'never' && sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {
	context.report({
			node: node,
			loc: closingSlash.loc.start,
			message: NEVER_MESSAGE,
			fix: function fix(fixer) {
		var previousToken = sourceCode.getTokenBefore(closingSlash);
		return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);
			}
	});
  }
}

function validateAfterOpening(context, node, option) {
  var sourceCode = context.getSourceCode();

  var NEVER_MESSAGE = 'A space is forbidden after opening bracket';
  var ALWAYS_MESSAGE = 'A space is required after opening bracket';

  var openingToken = sourceCode.getTokenBefore(node.name);

  if (option === 'allow-multiline') {
	if (openingToken.loc.start.line !== node.name.loc.start.line) {
			return;
	}
  }

  var adjacent = !sourceCode.isSpaceBetweenTokens(openingToken, node.name);

  if (option === 'never' || option === 'allow-multiline') {
	if (!adjacent) {
			context.report({
		node: node,
		loc: {
					start: openingToken.loc.start,
					end: node.name.loc.start
		},
		message: NEVER_MESSAGE,
		fix: function fix(fixer) {
					return fixer.removeRange([openingToken.range[1], node.name.range[0]]);
		}
			});
	}
  } else if (option === 'always' && adjacent) {
	context.report({
			node: node,
			loc: {
		start: openingToken.loc.start,
		end: node.name.loc.start
			},
			message: ALWAYS_MESSAGE,
			fix: function fix(fixer) {
		return fixer.insertTextBefore(node.name, ' ');
			}
	});
  }
}
module.exports = {
  meta: {
	docs: {},
	fixable: 'whitespace',
	schema: [{
			type: 'object',
			properties: {
		closingSlash: {
					enum: ['always', 'never', 'allow']
		},
		beforeSelfClosing: {
					enum: ['always', 'never', 'allow']
		},
		afterOpening: {
					enum: ['always', 'allow-multiline', 'never', 'allow']
		}
			},
			default: {
		closingSlash: 'never',
		beforeSelfClosing: 'always',
		afterOpening: 'never'
			},
			additionalProperties: false
	}]
  },
  create: function create(context) {
	var options = {
			closingSlash: 'never',
			beforeSelfClosing: 'always',
			afterOpening: 'never'
	};
	for (var key in options) {
			if (has(options, key) && has(context.options[0] || {}, key)) {
		options[key] = context.options[0][key];
			}
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		if (options.closingSlash !== 'allow' && node.selfClosing) {
					validateClosingSlash(context, node, options.closingSlash);
		}
		if (options.afterOpening !== 'allow') {
					validateAfterOpening(context, node, options.afterOpening);
		}
		if (options.beforeSelfClosing !== 'allow' && node.selfClosing) {
					validateBeforeSelfClosing(context, node, options.beforeSelfClosing);
		}
			},
			JSXClosingElement: function JSXClosingElement(node) {
		if (options.afterOpening !== 'allow') {
					validateAfterOpening(context, node, options.afterOpening);
		}
		if (options.closingSlash !== 'allow') {
					validateClosingSlash(context, node, options.closingSlash);
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var pragmaUtil = __webpack_require__(71);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent React to be marked as unused',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	var pragma = pragmaUtil.getFromContext(context);
	return {

			JSXOpeningElement: function JSXOpeningElement() {
		context.markVariableAsUsed(pragma);
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Prevent variables used in JSX to be marked as unused',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		var name = void 0;
		if (node.name.namespace && node.name.namespace.name) {
					name = node.name.namespace.name;
		} else if (node.name.name) {
					name = node.name.name;
		} else if (node.name.object) {
					var parent = node.name.object;
					while (parent.object) {
			parent = parent.object;
					}
					name = parent.name;
		} else {
					return;
		}

		context.markVariableAsUsed(name);
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var DEFAULTS = {
  declaration: true,
  assignment: true,
  return: true,
  arrow: true
};
module.exports = {
  meta: {
	docs: {
			description: 'Prevent missing parentheses around multilines JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			type: 'object',
			properties: {
		declaration: {
					type: 'boolean'
		},
		assignment: {
					type: 'boolean'
		},
		return: {
					type: 'boolean'
		},
		arrow: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();

	function isParenthesised(node) {
			var previousToken = sourceCode.getTokenBefore(node);
			var nextToken = sourceCode.getTokenAfter(node);

			return previousToken && nextToken && previousToken.value === '(' && previousToken.range[1] <= node.range[0] && nextToken.value === ')' && nextToken.range[0] >= node.range[1];
	}

	function isMultilines(node) {
			return node.loc.start.line !== node.loc.end.line;
	}

	function check(node) {
			if (!node || node.type !== 'JSXElement') {
		return;
			}

			if (!isParenthesised(node) && isMultilines(node)) {
		context.report({
					node: node,
					message: 'Missing parentheses around multilines JSX',
					fix: function fix(fixer) {
			return fixer.replaceText(node, '(' + sourceCode.getText(node) + ')');
					}
		});
			}
	}

	function isEnabled(type) {
			var userOptions = context.options[0] || {};
			if (has(userOptions, type)) {
		return userOptions[type];
			}
			return DEFAULTS[type];
	}
	return {

			VariableDeclarator: function VariableDeclarator(node) {
		if (!isEnabled('declaration')) {
					return;
		}
		if (node.init && node.init.type === 'ConditionalExpression') {
					check(node.init.consequent);
					check(node.init.alternate);
					return;
		}
		check(node.init);
			},

			AssignmentExpression: function AssignmentExpression(node) {
		if (!isEnabled('assignment')) {
					return;
		}
		if (node.right.type === 'ConditionalExpression') {
					check(node.right.consequent);
					check(node.right.alternate);
					return;
		}
		check(node.right);
			},

			ReturnStatement: function ReturnStatement(node) {
		if (isEnabled('return')) {
					check(node.argument);
		}
			},

			'ArrowFunctionExpression:exit': function ArrowFunctionExpressionExit(node) {
		var arrowBody = node.body;

		if (isEnabled('arrow') && arrowBody.type !== 'BlockStatement') {
					check(arrowBody);
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of Array index in keys',
			category: 'Best Practices',
			recommended: false
	},

	schema: []
  },

  create: function create(context) {
	var indexParamNames = [];
	var iteratorFunctionsToIndexParamPosition = {
			every: 1,
			filter: 1,
			find: 1,
			findIndex: 1,
			forEach: 1,
			map: 1,
			reduce: 2,
			reduceRight: 2,
			some: 1
	};
	var ERROR_MESSAGE = 'Do not use Array index in keys';

	function isArrayIndex(node) {
			return node.type === 'Identifier' && indexParamNames.indexOf(node.name) !== -1;
	}

	function getMapIndexParamName(node) {
			var callee = node.callee;
			if (callee.type !== 'MemberExpression') {
		return null;
			}
			if (callee.property.type !== 'Identifier') {
		return null;
			}
			if (!has(iteratorFunctionsToIndexParamPosition, callee.property.name)) {
		return null;
			}

			var firstArg = node.arguments[0];
			if (!firstArg) {
		return null;
			}

			var isFunction = ['ArrowFunctionExpression', 'FunctionExpression'].indexOf(firstArg.type) !== -1;
			if (!isFunction) {
		return null;
			}

			var params = firstArg.params;

			var indexParamPosition = iteratorFunctionsToIndexParamPosition[callee.property.name];
			if (params.length < indexParamPosition + 1) {
		return null;
			}

			return params[indexParamPosition].name;
	}

	function getIdentifiersFromBinaryExpression(side) {
			if (side.type === 'Identifier') {
		return side;
			}

			if (side.type === 'BinaryExpression') {
		var left = getIdentifiersFromBinaryExpression(side.left);
		var right = getIdentifiersFromBinaryExpression(side.right);
		return [].concat(left, right).filter(Boolean);
			}

			return null;
	}

	function checkPropValue(node) {
			if (isArrayIndex(node)) {
		context.report({
					node: node,
					message: ERROR_MESSAGE
		});
		return;
			}

			if (node.type === 'TemplateLiteral') {
		node.expressions.filter(isArrayIndex).forEach(function () {
					context.report({ node: node, message: ERROR_MESSAGE });
		});

		return;
			}

			if (node.type === 'BinaryExpression') {
		var identifiers = getIdentifiersFromBinaryExpression(node);

		identifiers.filter(isArrayIndex).forEach(function () {
					context.report({ node: node, message: ERROR_MESSAGE });
		});

		return;
			}
	}

	return {
			CallExpression: function CallExpression(node) {
		if (node.callee && node.callee.type === 'MemberExpression' && ['createElement', 'cloneElement'].indexOf(node.callee.property.name) !== -1 && node.arguments.length > 1) {
					if (!indexParamNames.length) {
			return;
					}

					var props = node.arguments[1];

					if (props.type !== 'ObjectExpression') {
			return;
					}

					props.properties.forEach(function (prop) {
			if (!prop.key || prop.key.name !== 'key') {
							return;
			}

			checkPropValue(prop.value);
					});

					return;
		}

		var mapIndexParamName = getMapIndexParamName(node);
		if (!mapIndexParamName) {
					return;
		}

		indexParamNames.push(mapIndexParamName);
			},

			JSXAttribute: function JSXAttribute(node) {
		if (node.name.name !== 'key') {
					return;
		}

		if (!indexParamNames.length) {
					return;
		}

		var value = node.value;
		if (!value || value.type !== 'JSXExpressionContainer') {
					return;
		}

		checkPropValue(value.expression);
			},

			'CallExpression:exit': function CallExpressionExit(node) {
		var mapIndexParamName = getMapIndexParamName(node);
		if (!mapIndexParamName) {
					return;
		}

		indexParamNames.pop();
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isCreateElementWithProps(node) {
  return node.callee && node.callee.type === 'MemberExpression' && node.callee.property.name === 'createElement' && node.arguments.length > 1 && node.arguments[1].type === 'ObjectExpression';
}
module.exports = {
  meta: {
	docs: {
			description: 'Prevent passing of children as props.',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },
  create: function create(context) {
	return {
			JSXAttribute: function JSXAttribute(node) {
		if (node.name.name !== 'children') {
					return;
		}

		context.report({
					node: node,
					message: 'Do not pass children as props. Instead, nest children between the opening and closing tags.'
		});
			},
			CallExpression: function CallExpression(node) {
		if (!isCreateElementWithProps(node)) {
					return;
		}

		var props = node.arguments[1].properties;
		var childrenProp = props.find(function (prop) {
					return prop.key && prop.key.name === 'children';
		});

		if (childrenProp) {
					context.report({
			node: node,
			message: 'Do not pass children as props. Instead, pass them as additional arguments to React.createElement.'
					});
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var DANGEROUS_MESSAGE = 'Dangerous property \'{{name}}\' found';

var DANGEROUS_PROPERTY_NAMES = ['dangerouslySetInnerHTML'];

var DANGEROUS_PROPERTIES = DANGEROUS_PROPERTY_NAMES.reduce(function (props, prop) {
  props[prop] = prop;
  return props;
}, Object.create(null));
var tagConvention = /^[a-z]|\-/;
function isTagName(name) {
  return tagConvention.test(name);
}
function isDangerous(name) {
  return name in DANGEROUS_PROPERTIES;
}
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of dangerous JSX props',
			category: 'Best Practices',
			recommended: false
	},
	schema: []
  },

  create: function create(context) {
	return {

			JSXAttribute: function JSXAttribute(node) {
		if (isTagName(node.parent.name.name) && isDangerous(node.name.name)) {
					context.report({
			node: node,
			message: DANGEROUS_MESSAGE,
			data: {
							name: node.name.name
			}
					});
		}
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var variableUtil = __webpack_require__(27);
module.exports = {
  meta: {
	docs: {
			description: 'Report when a DOM element is using both children and dangerouslySetInnerHTML',
			category: '',
			recommended: true
	},
	schema: [] // no options
  },
  create: function create(context) {
	function findSpreadVariable(name) {
			return variableUtil.variablesInScope(context).find(function (item) {
		return item.name === name;
			});
	}
	function findObjectProp(node, propName) {
			if (!node.properties) {
		return false;
			}
			return node.properties.find(function (prop) {
		if (prop.type === 'Property') {
					return prop.key.name === propName;
		} else if (prop.type === 'ExperimentalSpreadProperty') {
					var variable = findSpreadVariable(prop.argument.name);
					if (variable && variable.defs.length && variable.defs[0].node.init) {
			return findObjectProp(variable.defs[0].node.init, propName);
					}
		}
		return false;
			});
	}
	function findJsxProp(node, propName) {
			var attributes = node.openingElement.attributes;
			return attributes.find(function (attribute) {
		if (attribute.type === 'JSXSpreadAttribute') {
					var variable = findSpreadVariable(attribute.argument.name);
					if (variable && variable.defs.length && variable.defs[0].node.init) {
			return findObjectProp(variable.defs[0].node.init, propName);
					}
		}
		return attribute.name && attribute.name.name === propName;
			});
	}
	function isLineBreak(node) {
			var isLiteral = node.type === 'Literal';
			var isMultiline = node.loc.start.line !== node.loc.end.line;
			var isWhiteSpaces = /^\s*$/.test(node.value);

			return isLiteral && isMultiline && isWhiteSpaces;
	}

	return {
			JSXElement: function JSXElement(node) {
		var hasChildren = false;

		if (node.children.length && !isLineBreak(node.children[0])) {
					hasChildren = true;
		} else if (findJsxProp(node, 'children')) {
					hasChildren = true;
		}

		if (node.openingElement.attributes && hasChildren && findJsxProp(node, 'dangerouslySetInnerHTML')) {
					context.report(node, 'Only set one of `children` or `props.dangerouslySetInnerHTML`');
		}
			},
			CallExpression: function CallExpression(node) {
		if (node.callee && node.callee.type === 'MemberExpression' && node.callee.property.name === 'createElement' && node.arguments.length > 1) {
					var hasChildren = false;

					var props = node.arguments[1];

					if (props.type === 'Identifier') {
			var variable = variableUtil.variablesInScope(context).find(function (item) {
							return item.name === props.name;
			});
			if (variable && variable.defs.length && variable.defs[0].node.init) {
							props = variable.defs[0].node.init;
			}
					}

					var dangerously = findObjectProp(props, 'dangerouslySetInnerHTML');

					if (node.arguments.length === 2) {
			if (findObjectProp(props, 'children')) {
							hasChildren = true;
			}
					} else {
			hasChildren = true;
					}

					if (dangerously && hasChildren) {
			context.report(node, 'Only set one of `children` or `props.dangerouslySetInnerHTML`');
					}
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);

var pragmaUtil = __webpack_require__(71);
var versionUtil = __webpack_require__(57);
var MODULES = {
  react: ['React'],
  'react-addons-perf': ['ReactPerf', 'Perf']
};

var DEPRECATED_MESSAGE = '{{oldMethod}} is deprecated since React {{version}}{{newMethod}}';
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of deprecated methods',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();
	var pragma = pragmaUtil.getFromContext(context);

	function getDeprecated() {
			var deprecated = {};
			deprecated[pragma + '.renderComponent'] = ['0.12.0', pragma + '.render'];
			deprecated[pragma + '.renderComponentToString'] = ['0.12.0', pragma + '.renderToString'];
			deprecated[pragma + '.renderComponentToStaticMarkup'] = ['0.12.0', pragma + '.renderToStaticMarkup'];
			deprecated[pragma + '.isValidComponent'] = ['0.12.0', pragma + '.isValidElement'];
			deprecated[pragma + '.PropTypes.component'] = ['0.12.0', pragma + '.PropTypes.element'];
			deprecated[pragma + '.PropTypes.renderable'] = ['0.12.0', pragma + '.PropTypes.node'];
			deprecated[pragma + '.isValidClass'] = ['0.12.0'];
			deprecated['this.transferPropsTo'] = ['0.12.0', 'spread operator ({...})'];
			deprecated[pragma + '.addons.classSet'] = ['0.13.0', 'the npm module classnames'];
			deprecated[pragma + '.addons.cloneWithProps'] = ['0.13.0', pragma + '.cloneElement'];
			deprecated[pragma + '.render'] = ['0.14.0', 'ReactDOM.render'];
			deprecated[pragma + '.unmountComponentAtNode'] = ['0.14.0', 'ReactDOM.unmountComponentAtNode'];
			deprecated[pragma + '.findDOMNode'] = ['0.14.0', 'ReactDOM.findDOMNode'];
			deprecated[pragma + '.renderToString'] = ['0.14.0', 'ReactDOMServer.renderToString'];
			deprecated[pragma + '.renderToStaticMarkup'] = ['0.14.0', 'ReactDOMServer.renderToStaticMarkup'];
			deprecated[pragma + '.addons.LinkedStateMixin'] = ['15.0.0'];
			deprecated['ReactPerf.printDOM'] = ['15.0.0', 'ReactPerf.printOperations'];
			deprecated['Perf.printDOM'] = ['15.0.0', 'Perf.printOperations'];
			deprecated['ReactPerf.getMeasurementsSummaryMap'] = ['15.0.0', 'ReactPerf.getWasted'];
			deprecated['Perf.getMeasurementsSummaryMap'] = ['15.0.0', 'Perf.getWasted'];
			deprecated[pragma + '.createClass'] = ['15.5.0', 'the npm module create-react-class'];
			deprecated[pragma + '.PropTypes'] = ['15.5.0', 'the npm module prop-types'];

			return deprecated;
	}

	function isDeprecated(method) {
			var deprecated = getDeprecated();

			return deprecated && deprecated[method] && versionUtil.testReactVersion(context, deprecated[method][0]);
	}

	function checkDeprecation(node, method) {
			if (!isDeprecated(method)) {
		return;
			}
			var deprecated = getDeprecated();
			context.report({
		node: node,
		message: DEPRECATED_MESSAGE,
		data: {
					oldMethod: method,
					version: deprecated[method][0],
					newMethod: deprecated[method][1] ? ', use ' + deprecated[method][1] + ' instead' : ''
		}
			});
	}

	function getReactModuleName(node) {
			var moduleName = false;
			if (!node.init) {
		return moduleName;
			}
			for (var _module in MODULES) {
		if (!has(MODULES, _module)) {
					continue;
		}
		moduleName = MODULES[_module].find(function (name) {
					return name === node.init.name;
		});
		if (moduleName) {
					break;
		}
			}
			return moduleName;
	}
	return {

			MemberExpression: function MemberExpression(node) {
		checkDeprecation(node, sourceCode.getText(node));
			},

			ImportDeclaration: function ImportDeclaration(node) {
		var isReactImport = typeof MODULES[node.source.value] !== 'undefined';
		if (!isReactImport) {
					return;
		}
		node.specifiers.forEach(function (specifier) {
					if (!specifier.imported) {
			return;
					}
					checkDeprecation(node, MODULES[node.source.value][0] + '.' + specifier.imported.name);
		});
			},

			VariableDeclarator: function VariableDeclarator(node) {
		var reactModuleName = getReactModuleName(node);
		var isRequire = node.init && node.init.callee && node.init.callee.name === 'require';
		var isReactRequire = node.init && node.init.arguments && node.init.arguments.length && typeof MODULES[node.init.arguments[0].value] !== 'undefined';
		var isDestructuring = node.id && node.id.type === 'ObjectPattern';

		if (!(isDestructuring && reactModuleName) && !(isDestructuring && isRequire && isReactRequire)) {
					return;
		}
		node.id.properties.forEach(function (property) {
					checkDeprecation(node, (reactModuleName || pragma) + '.' + property.key.name);
		});
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var makeNoMethodSetStateRule = __webpack_require__(111);

module.exports = makeNoMethodSetStateRule('componentDidMount');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var makeNoMethodSetStateRule = __webpack_require__(111);

module.exports = makeNoMethodSetStateRule('componentDidUpdate');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent direct mutation of this.state',
			category: 'Possible Errors',
			recommended: true
	}
  },

  create: Components.detect(function (context, components, utils) {
	function isValid(component) {
			return Boolean(component && !component.mutateSetState);
	}
	function reportMutations(component) {
			var mutation = void 0;
			for (var i = 0, j = component.mutations.length; i < j; i++) {
		mutation = component.mutations[i];
		context.report({
					node: mutation,
					message: 'Do not mutate state directly. Use setState().'
		});
			}
	}
	function getOuterMemberExpression(node) {
			while (node.object && node.object.property) {
		node = node.object;
			}
			return node;
	}
	function isStateMemberExpression(node) {
			return node.object.type === 'ThisExpression' && node.property.name === 'state';
	}
	function shouldIgnoreComponent(component) {
			return !component || component.inConstructor && !component.inCallExpression;
	}
	return {
			MethodDefinition: function MethodDefinition(node) {
		if (node.kind === 'constructor') {
					components.set(node, {
			inConstructor: true
					});
		}
			},


			CallExpression: function CallExpression(node) {
		components.set(node, {
					inCallExpression: true
		});
			},

			AssignmentExpression: function AssignmentExpression(node) {
		var component = components.get(utils.getParentComponent());
		if (shouldIgnoreComponent(component) || !node.left || !node.left.object) {
					return;
		}
		var item = getOuterMemberExpression(node.left);
		if (isStateMemberExpression(item)) {
					var mutations = component && component.mutations || [];
					mutations.push(node.left.object);
					components.set(node, {
			mutateSetState: true,
			mutations: mutations
					});
		}
			},
			UpdateExpression: function UpdateExpression(node) {
		var component = components.get(utils.getParentComponent());
		if (shouldIgnoreComponent(component) || node.argument.type !== 'MemberExpression') {
					return;
		}
		var item = getOuterMemberExpression(node.argument);
		if (isStateMemberExpression(item)) {
					var mutations = component && component.mutations || [];
					mutations.push(item);
					components.set(node, {
			mutateSetState: true,
			mutations: mutations
					});
		}
			},


			'CallExpression:exit': function CallExpressionExit(node) {
		components.set(node, {
					inCallExpression: false
		});
			},

			'MethodDefinition:exit': function MethodDefinitionExit(node) {
		if (node.kind === 'constructor') {
					components.set(node, {
			inConstructor: false
					});
		}
			},

			'Program:exit': function ProgramExit() {
		var list = components.list();

		Object.keys(list).forEach(function (key) {
					if (!isValid(list[key])) {
			reportMutations(list[key]);
					}
		});
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of findDOMNode',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	return {

			CallExpression: function CallExpression(node) {
		var callee = node.callee;

		var isfindDOMNode = callee.name === 'findDOMNode' || callee.property && callee.property.name === 'findDOMNode';

		if (!isfindDOMNode) {
					return;
		}

		context.report({
					node: callee,
					message: 'Do not use findDOMNode'
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of isMounted',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	return {

			CallExpression: function CallExpression(node) {
		var callee = node.callee;
		if (callee.type !== 'MemberExpression') {
					return;
		}
		if (callee.object.type !== 'ThisExpression' || callee.property.name !== 'isMounted') {
					return;
		}
		var ancestors = context.getAncestors(callee);
		for (var i = 0, j = ancestors.length; i < j; i++) {
					if (ancestors[i].type === 'Property' || ancestors[i].type === 'MethodDefinition') {
			context.report({
							node: callee,
							message: 'Do not use isMounted'
			});
			break;
					}
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent multiple component definition per file',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		ignoreStateless: {
					default: false,
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components) {
	var configuration = context.options[0] || {};
	var ignoreStateless = configuration.ignoreStateless || false;

	var MULTI_COMP_MESSAGE = 'Declare only one React component per file';
	function isIgnored(component) {
			return ignoreStateless && /Function/.test(component.node.type);
	}
	return {
			'Program:exit': function ProgramExit() {
		if (components.length() <= 1) {
					return;
		}

		var list = components.list();
		var i = 0;

		for (var component in list) {
					if (!has(list, component) || isIgnored(list[component]) || ++i === 1) {
			continue;
					}
					context.report({
			node: list[component].node,
			message: MULTI_COMP_MESSAGE
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of setState',
			category: 'Stylistic Issues',
			recommended: false
	},
	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	function isValid(component) {
			return Boolean(component && !component.useSetState);
	}
	function reportSetStateUsages(component) {
			var setStateUsage = void 0;
			for (var i = 0, j = component.setStateUsages.length; i < j; i++) {
		setStateUsage = component.setStateUsages[i];
		context.report({
					node: setStateUsage,
					message: 'Do not use setState'
		});
			}
	}
	return {

			CallExpression: function CallExpression(node) {
		var callee = node.callee;
		if (callee.type !== 'MemberExpression' || callee.object.type !== 'ThisExpression' || callee.property.name !== 'setState') {
					return;
		}
		var component = components.get(utils.getParentComponent());
		var setStateUsages = component && component.setStateUsages || [];
		setStateUsages.push(callee);
		components.set(node, {
					useSetState: true,
					setStateUsages: setStateUsages
		});
			},

			'Program:exit': function ProgramExit() {
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || isValid(list[component])) {
			continue;
					}
					reportSetStateUsages(list[component]);
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent string definitions for references and prevent referencing this.refs',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	function isRefsUsage(node) {
			return Boolean((utils.getParentES6Component() || utils.getParentES5Component()) && node.object.type === 'ThisExpression' && node.property.name === 'refs');
	}
	function isRefAttribute(node) {
			return Boolean(node.type === 'JSXAttribute' && node.name && node.name.name === 'ref');
	}
	function containsStringLiteral(node) {
			return Boolean(node.value && node.value.type === 'Literal' && typeof node.value.value === 'string');
	}
	function containsStringExpressionContainer(node) {
			return Boolean(node.value && node.value.type === 'JSXExpressionContainer' && node.value.expression && node.value.expression.type === 'Literal' && typeof node.value.expression.value === 'string');
	}

	return {
			MemberExpression: function MemberExpression(node) {
		if (isRefsUsage(node)) {
					context.report({
			node: node,
			message: 'Using this.refs is deprecated.'
					});
		}
			},
			JSXAttribute: function JSXAttribute(node) {
		if (isRefAttribute(node) && (containsStringLiteral(node) || containsStringExpressionContainer(node))) {
					context.report({
			node: node,
			message: 'Using string literals in ref attributes is deprecated.'
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var Components = __webpack_require__(8);

function errorMessage(node) {
  return node + ' does not need shouldComponentUpdate when extending React.PureComponent.';
}
module.exports = {
  meta: {
	docs: {
			description: 'Flag shouldComponentUpdate when extending PureComponent',
			category: 'Possible Errors',
			recommended: false
	},
	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	function getPropertyName(node) {
			if (node.key) {
		return node.key.name;
			} else if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
			}
			return '';
	}
	function getComponentProperties(node) {
			switch (node.type) {
		case 'ClassExpression':
		case 'ClassDeclaration':
					return node.body.body;
		default:
					return [];
			}
	}
	function hasShouldComponentUpdate(node) {
			var properties = getComponentProperties(node);
			return properties.some(function (property) {
		var name = getPropertyName(property);
		return name === 'shouldComponentUpdate';
			});
	}
	function getNodeName(node) {
			if (node.id) {
		return node.id.name;
			} else if (node.parent && node.parent.id) {
		return node.parent.id.name;
			}
			return '';
	}
	function checkForViolation(node) {
			if (utils.isPureComponent(node)) {
		var hasScu = hasShouldComponentUpdate(node);
		if (hasScu) {
					var className = getNodeName(node);
					context.report({
			node: node,
			message: errorMessage(className)
					});
		}
			}
	}

	return {
			ClassDeclaration: checkForViolation,
			ClassExpression: checkForViolation
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var versionUtil = __webpack_require__(57);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of the return value of React.render',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	return {

			CallExpression: function CallExpression(node) {
		var callee = node.callee;
		var parent = node.parent;
		if (callee.type !== 'MemberExpression') {
					return;
		}

		var calleeObjectName = /^ReactDOM$/;
		if (versionUtil.testReactVersion(context, '15.0.0')) {
					calleeObjectName = /^ReactDOM$/;
		} else if (versionUtil.testReactVersion(context, '0.14.0')) {
					calleeObjectName = /^React(DOM)?$/;
		} else if (versionUtil.testReactVersion(context, '0.13.0')) {
					calleeObjectName = /^React$/;
		}

		if (callee.object.type !== 'Identifier' || !calleeObjectName.test(callee.object.name) || callee.property.name !== 'render') {
					return;
		}

		if (parent.type === 'VariableDeclarator' || parent.type === 'Property' || parent.type === 'ReturnStatement' || parent.type === 'ArrowFunctionExpression') {
					context.report({
			node: callee,
			message: 'Do not depend on the return value from ' + callee.object.name + '.render'
					});
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var Components = __webpack_require__(8);
var STATIC_CLASS_PROPERTIES = ['propTypes', 'contextTypes', 'childContextTypes', 'defaultProps'];
var LIFECYCLE_METHODS = ['componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate', 'componentWillUnmount', 'render'];

var PROP_TYPES = Object.keys(__webpack_require__(731));

module.exports = {
  meta: {
	docs: {
			description: 'Prevent common typos',
			category: 'Stylistic Issues',
			recommended: false
	},
	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	function checkValidPropTypeQualfier(node) {
			if (node.name !== 'isRequired') {
		context.report({
					node: node,
					message: 'Typo in prop type chain qualifier: ' + node.name
		});
			}
	}

	function checkValidPropType(node) {
			if (node.name && !PROP_TYPES.some(function (propTypeName) {
		return propTypeName === node.name;
			})) {
		context.report({
					node: node,
					message: 'Typo in declared prop type: ' + node.name
		});
			}
	}
	function checkValidProp(node) {
			if (node && node.type === 'MemberExpression' && node.object.type === 'MemberExpression') {
		checkValidPropType(node.object.property);
		checkValidPropTypeQualfier(node.property);
			} else if (node && node.type === 'MemberExpression' && node.object.type === 'Identifier') {
		checkValidPropType(node.property);
			} else if (node && node.type === 'CallExpression') {
		var callee = node.callee;
		if (callee.type === 'MemberExpression' && callee.property.name === 'shape') {
					checkValidPropObject(node.arguments[0]);
		} else if (callee.type === 'MemberExpression' && callee.property.name === 'oneOfType') {
					var args = node.arguments[0];
					if (args && args.type === 'ArrayExpression') {
			args.elements.forEach(function (el) {
							return checkValidProp(el);
			});
					}
		}
			}
	}

	function checkValidPropObject(node) {
			if (node.type === 'ObjectExpression') {
		node.properties.forEach(function (prop) {
					return checkValidProp(prop.value);
		});
			}
	}

	function reportErrorIfClassPropertyCasingTypo(node, propertyName) {
			if (propertyName === 'propTypes' || propertyName === 'contextTypes' || propertyName === 'childContextTypes') {
		var propsNode = node && node.parent && node.parent.type === 'AssignmentExpression' && node.parent.right;
		checkValidPropObject(propsNode);
			}
			STATIC_CLASS_PROPERTIES.forEach(function (CLASS_PROP) {
		if (propertyName && CLASS_PROP.toLowerCase() === propertyName.toLowerCase() && CLASS_PROP !== propertyName) {
					context.report({
			node: node,
			message: 'Typo in static class property declaration'
					});
		}
			});
	}

	function reportErrorIfLifecycleMethodCasingTypo(node) {
			LIFECYCLE_METHODS.forEach(function (method) {
		if (method.toLowerCase() === node.key.name.toLowerCase() && method !== node.key.name) {
					context.report({
			node: node,
			message: 'Typo in component lifecycle method declaration'
					});
		}
			});
	}

	return {
			ClassProperty: function ClassProperty(node) {
		if (!node.static || !utils.isES6Component(node.parent.parent)) {
					return;
		}

		var tokens = context.getFirstTokens(node, 2);
		var propertyName = tokens[1].value;
		reportErrorIfClassPropertyCasingTypo(node, propertyName);
			},

			MemberExpression: function MemberExpression(node) {
		var propertyName = node.property.name;

		if (!propertyName || STATIC_CLASS_PROPERTIES.map(function (prop) {
					return prop.toLocaleLowerCase();
		}).indexOf(propertyName.toLowerCase()) === -1) {
					return;
		}

		var relatedComponent = utils.getRelatedComponent(node);

		if (relatedComponent && (utils.isES6Component(relatedComponent.node) || utils.isReturningJSX(relatedComponent.node))) {
					reportErrorIfClassPropertyCasingTypo(node, propertyName);
		}
			},

			MethodDefinition: function MethodDefinition(node) {
		if (!utils.isES6Component(node.parent.parent)) {
					return;
		}

		reportErrorIfLifecycleMethodCasingTypo(node);
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
	return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(732)(isValidElement, throwOnDirectAccess);
} else {
  module.exports = __webpack_require__(734)();
}
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var emptyFunction = __webpack_require__(112);
var invariant = __webpack_require__(113);
var warning = __webpack_require__(172);
var assign = __webpack_require__(154);

var ReactPropTypesSecret = __webpack_require__(114);
var checkPropTypes = __webpack_require__(733);

module.exports = function (isValidElement, throwOnDirectAccess) {
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
  function getIteratorFn(maybeIterable) {
	var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	if (typeof iteratorFn === 'function') {
			return iteratorFn;
	}
  }

  var ANONYMOUS = '<<anonymous>>';
  var ReactPropTypes = {
	array: createPrimitiveTypeChecker('array'),
	bool: createPrimitiveTypeChecker('boolean'),
	func: createPrimitiveTypeChecker('function'),
	number: createPrimitiveTypeChecker('number'),
	object: createPrimitiveTypeChecker('object'),
	string: createPrimitiveTypeChecker('string'),
	symbol: createPrimitiveTypeChecker('symbol'),

	any: createAnyTypeChecker(),
	arrayOf: createArrayOfTypeChecker,
	element: createElementTypeChecker(),
	instanceOf: createInstanceTypeChecker,
	node: createNodeChecker(),
	objectOf: createObjectOfTypeChecker,
	oneOf: createEnumTypeChecker,
	oneOfType: createUnionTypeChecker,
	shape: createShapeTypeChecker,
	exact: createStrictShapeTypeChecker
  };
  function is(x, y) {
	if (x === y) {
			return x !== 0 || 1 / x === 1 / y;
	} else {
			return x !== x && y !== y;
	}
  }
  function PropTypeError(message) {
	this.message = message;
	this.stack = '';
  }
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
	if (process.env.NODE_ENV !== 'production') {
			var manualPropTypeCallCache = {};
			var manualPropTypeWarningCount = 0;
	}
	function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
			componentName = componentName || ANONYMOUS;
			propFullName = propFullName || propName;

			if (secret !== ReactPropTypesSecret) {
		if (throwOnDirectAccess) {
					invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
		} else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
					var cacheKey = componentName + ':' + propName;
					if (!manualPropTypeCallCache[cacheKey] &&
					manualPropTypeWarningCount < 3) {
			warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
			manualPropTypeCallCache[cacheKey] = true;
			manualPropTypeWarningCount++;
					}
		}
			}
			if (props[propName] == null) {
		if (isRequired) {
					if (props[propName] === null) {
			return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
					}
					return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
		}
		return null;
			} else {
		return validate(props, propName, componentName, location, propFullName);
			}
	}

	var chainedCheckType = checkType.bind(null, false);
	chainedCheckType.isRequired = checkType.bind(null, true);

	return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
	function validate(props, propName, componentName, location, propFullName, secret) {
			var propValue = props[propName];
			var propType = getPropType(propValue);
			if (propType !== expectedType) {
		var preciseType = getPreciseType(propValue);

		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
	return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
	function validate(props, propName, componentName, location, propFullName) {
			if (typeof typeChecker !== 'function') {
		return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
			}
			var propValue = props[propName];
			if (!Array.isArray(propValue)) {
		var propType = getPropType(propValue);
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
			}
			for (var i = 0; i < propValue.length; i++) {
		var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
		if (error instanceof Error) {
					return error;
		}
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
	function validate(props, propName, componentName, location, propFullName) {
			var propValue = props[propName];
			if (!isValidElement(propValue)) {
		var propType = getPropType(propValue);
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
	function validate(props, propName, componentName, location, propFullName) {
			if (!(props[propName] instanceof expectedClass)) {
		var expectedClassName = expectedClass.name || ANONYMOUS;
		var actualClassName = getClassName(props[propName]);
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
	if (!Array.isArray(expectedValues)) {
			process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
			return emptyFunction.thatReturnsNull;
	}

	function validate(props, propName, componentName, location, propFullName) {
			var propValue = props[propName];
			for (var i = 0; i < expectedValues.length; i++) {
		if (is(propValue, expectedValues[i])) {
					return null;
		}
			}

			var valuesString = JSON.stringify(expectedValues);
			return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	}
	return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
	function validate(props, propName, componentName, location, propFullName) {
			if (typeof typeChecker !== 'function') {
		return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
			}
			var propValue = props[propName];
			var propType = getPropType(propValue);
			if (propType !== 'object') {
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
			}
			for (var key in propValue) {
		if (propValue.hasOwnProperty(key)) {
					var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
					if (error instanceof Error) {
			return error;
					}
		}
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
	if (!Array.isArray(arrayOfTypeCheckers)) {
			process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
			return emptyFunction.thatReturnsNull;
	}

	for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
			var checker = arrayOfTypeCheckers[i];
			if (typeof checker !== 'function') {
		warning(false, 'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
		return emptyFunction.thatReturnsNull;
			}
	}

	function validate(props, propName, componentName, location, propFullName) {
			for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
		var checker = arrayOfTypeCheckers[i];
		if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
					return null;
		}
			}

			return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	}
	return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
	function validate(props, propName, componentName, location, propFullName) {
			if (!isNode(props[propName])) {
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
	function validate(props, propName, componentName, location, propFullName) {
			var propValue = props[propName];
			var propType = getPropType(propValue);
			if (propType !== 'object') {
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
			}
			for (var key in shapeTypes) {
		var checker = shapeTypes[key];
		if (!checker) {
					continue;
		}
		var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
		if (error) {
					return error;
		}
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
	function validate(props, propName, componentName, location, propFullName) {
			var propValue = props[propName];
			var propType = getPropType(propValue);
			if (propType !== 'object') {
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
			}
			var allKeys = assign({}, props[propName], shapeTypes);
			for (var key in allKeys) {
		var checker = shapeTypes[key];
		if (!checker) {
					return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
		}
		var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
		if (error) {
					return error;
		}
			}
			return null;
	}

	return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
	switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
			case 'number':
			case 'string':
			case 'undefined':
		return true;
			case 'boolean':
		return !propValue;
			case 'object':
		if (Array.isArray(propValue)) {
					return propValue.every(isNode);
		}
		if (propValue === null || isValidElement(propValue)) {
					return true;
		}

		var iteratorFn = getIteratorFn(propValue);
		if (iteratorFn) {
					var iterator = iteratorFn.call(propValue);
					var step;
					if (iteratorFn !== propValue.entries) {
			while (!(step = iterator.next()).done) {
							if (!isNode(step.value)) {
				return false;
							}
			}
					} else {
			while (!(step = iterator.next()).done) {
							var entry = step.value;
							if (entry) {
				if (!isNode(entry[1])) {
									return false;
				}
							}
			}
					}
		} else {
					return false;
		}

		return true;
			default:
		return false;
	}
  }

  function isSymbol(propType, propValue) {
	if (propType === 'symbol') {
			return true;
	}
	if (propValue['@@toStringTag'] === 'Symbol') {
			return true;
	}
	if (typeof Symbol === 'function' && propValue instanceof Symbol) {
			return true;
	}

	return false;
  }
  function getPropType(propValue) {
	var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	if (Array.isArray(propValue)) {
			return 'array';
	}
	if (propValue instanceof RegExp) {
			return 'object';
	}
	if (isSymbol(propType, propValue)) {
			return 'symbol';
	}
	return propType;
  }
  function getPreciseType(propValue) {
	if (typeof propValue === 'undefined' || propValue === null) {
			return '' + propValue;
	}
	var propType = getPropType(propValue);
	if (propType === 'object') {
			if (propValue instanceof Date) {
		return 'date';
			} else if (propValue instanceof RegExp) {
		return 'regexp';
			}
	}
	return propType;
  }
  function getPostfixForTypeWarning(value) {
	var type = getPreciseType(value);
	switch (type) {
			case 'array':
			case 'object':
		return 'an ' + type;
			case 'boolean':
			case 'date':
			case 'regexp':
		return 'a ' + type;
			default:
		return type;
	}
  }
  function getClassName(propValue) {
	if (!propValue.constructor || !propValue.constructor.name) {
			return ANONYMOUS;
	}
	return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(113);
  var warning = __webpack_require__(172);
  var ReactPropTypesSecret = __webpack_require__(114);
  var loggedTypeFailures = {};
}
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
	for (var typeSpecName in typeSpecs) {
			if (typeSpecs.hasOwnProperty(typeSpecName)) {
		var error;
		try {
					invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, _typeof(typeSpecs[typeSpecName]));
					error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
		} catch (ex) {
					error = ex;
		}
		warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
		if (error instanceof Error && !(error.message in loggedTypeFailures)) {
					loggedTypeFailures[error.message] = true;

					var stack = getStack ? getStack() : '';

					warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
		}
			}
	}
  }
}

module.exports = checkPropTypes;
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var emptyFunction = __webpack_require__(112);
var invariant = __webpack_require__(113);
var ReactPropTypesSecret = __webpack_require__(114);

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
	if (secret === ReactPropTypesSecret) {
			return;
	}
	invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
  };
  shim.isRequired = shim;
  function getShim() {
	return shim;
  };
  var ReactPropTypes = {
	array: shim,
	bool: shim,
	func: shim,
	number: shim,
	object: shim,
	string: shim,
	symbol: shim,

	any: shim,
	arrayOf: getShim,
	element: shim,
	instanceOf: getShim,
	node: shim,
	objectOf: getShim,
	oneOf: getShim,
	oneOfType: getShim,
	shape: getShim,
	exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var DEFAULTS = ['>', '"', '\'', '}'];

module.exports = {
  meta: {
	docs: {
			description: 'Detect unescaped HTML entities, which might represent malformed tags',
			category: 'Possible Errors',
			recommended: true
	},
	schema: [{
			type: 'object',
			properties: {
		forbid: {
					type: 'array',
					items: {
			type: 'string'
					}
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	function reportInvalidEntity(node) {
			var configuration = context.options[0] || {};
			var entities = configuration.forbid || DEFAULTS;
			for (var i = node.loc.start.line; i <= node.loc.end.line; i++) {
		var rawLine = context.getSourceCode().lines[i - 1];
		var start = 0;
		var end = rawLine.length;
		if (i === node.loc.start.line) {
					start = node.loc.start.column;
		}
		if (i === node.loc.end.line) {
					end = node.loc.end.column;
		}
		rawLine = rawLine.substring(start, end);
		for (var j = 0; j < entities.length; j++) {
					for (var index = 0; index < rawLine.length; index++) {
			var c = rawLine[index];
			if (c === entities[j]) {
							context.report({
				loc: { line: i, column: start + index },
				message: 'HTML entities must be escaped.',
				node: node
							});
			}
					}
		}
			}
	}

	return {
			Literal: function Literal(node) {
		if (node.type === 'Literal' && node.parent.type === 'JSXElement') {
					reportInvalidEntity(node);
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var DEFAULTS = {
  ignore: []
};

var UNKNOWN_MESSAGE = 'Unknown property \'{{name}}\' found, use \'{{standardName}}\' instead';

var DOM_ATTRIBUTE_NAMES = {
  'accept-charset': 'acceptCharset',
  class: 'className',
  for: 'htmlFor',
  'http-equiv': 'httpEquiv'
};

var SVGDOM_ATTRIBUTE_NAMES = {
  'accent-height': 'accentHeight',
  'alignment-baseline': 'alignmentBaseline',
  'arabic-form': 'arabicForm',
  'baseline-shift': 'baselineShift',
  'cap-height': 'capHeight',
  'clip-path': 'clipPath',
  'clip-rule': 'clipRule',
  'color-interpolation': 'colorInterpolation',
  'color-interpolation-filters': 'colorInterpolationFilters',
  'color-profile': 'colorProfile',
  'color-rendering': 'colorRendering',
  'dominant-baseline': 'dominantBaseline',
  'enable-background': 'enableBackground',
  'fill-opacity': 'fillOpacity',
  'fill-rule': 'fillRule',
  'flood-color': 'floodColor',
  'flood-opacity': 'floodOpacity',
  'font-family': 'fontFamily',
  'font-size': 'fontSize',
  'font-size-adjust': 'fontSizeAdjust',
  'font-stretch': 'fontStretch',
  'font-style': 'fontStyle',
  'font-variant': 'fontVariant',
  'font-weight': 'fontWeight',
  'glyph-name': 'glyphName',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  'horiz-adv-x': 'horizAdvX',
  'horiz-origin-x': 'horizOriginX',
  'image-rendering': 'imageRendering',
  'letter-spacing': 'letterSpacing',
  'lighting-color': 'lightingColor',
  'marker-end': 'markerEnd',
  'marker-mid': 'markerMid',
  'marker-start': 'markerStart',
  'overline-position': 'overlinePosition',
  'overline-thickness': 'overlineThickness',
  'paint-order': 'paintOrder',
  'panose-1': 'panose1',
  'pointer-events': 'pointerEvents',
  'rendering-intent': 'renderingIntent',
  'shape-rendering': 'shapeRendering',
  'stop-color': 'stopColor',
  'stop-opacity': 'stopOpacity',
  'strikethrough-position': 'strikethroughPosition',
  'strikethrough-thickness': 'strikethroughThickness',
  'stroke-dasharray': 'strokeDasharray',
  'stroke-dashoffset': 'strokeDashoffset',
  'stroke-linecap': 'strokeLinecap',
  'stroke-linejoin': 'strokeLinejoin',
  'stroke-miterlimit': 'strokeMiterlimit',
  'stroke-opacity': 'strokeOpacity',
  'stroke-width': 'strokeWidth',
  'text-anchor': 'textAnchor',
  'text-decoration': 'textDecoration',
  'text-rendering': 'textRendering',
  'underline-position': 'underlinePosition',
  'underline-thickness': 'underlineThickness',
  'unicode-bidi': 'unicodeBidi',
  'unicode-range': 'unicodeRange',
  'units-per-em': 'unitsPerEm',
  'v-alphabetic': 'vAlphabetic',
  'v-hanging': 'vHanging',
  'v-ideographic': 'vIdeographic',
  'v-mathematical': 'vMathematical',
  'vector-effect': 'vectorEffect',
  'vert-adv-y': 'vertAdvY',
  'vert-origin-x': 'vertOriginX',
  'vert-origin-y': 'vertOriginY',
  'word-spacing': 'wordSpacing',
  'writing-mode': 'writingMode',
  'x-height': 'xHeight',
  'xlink:actuate': 'xlinkActuate',
  'xlink:arcrole': 'xlinkArcrole',
  'xlink:href': 'xlinkHref',
  'xlink:role': 'xlinkRole',
  'xlink:show': 'xlinkShow',
  'xlink:title': 'xlinkTitle',
  'xlink:type': 'xlinkType',
  'xml:base': 'xmlBase',
  'xml:lang': 'xmlLang',
  'xml:space': 'xmlSpace'
};

var DOM_PROPERTY_NAMES = [
'acceptCharset', 'accessKey', 'allowFullScreen', 'allowTransparency', 'autoComplete', 'autoFocus', 'autoPlay', 'cellPadding', 'cellSpacing', 'charSet', 'classID', 'className', 'colSpan', 'contentEditable', 'contextMenu', 'crossOrigin', 'dateTime', 'encType', 'formAction', 'formEncType', 'formMethod', 'formNoValidate', 'formTarget', 'frameBorder', 'hrefLang', 'htmlFor', 'httpEquiv', 'inputMode', 'keyParams', 'keyType', 'marginHeight', 'marginWidth', 'maxLength', 'mediaGroup', 'minLength', 'noValidate', 'onAnimationEnd', 'onAnimationIteration', 'onAnimationStart', 'onBlur', 'onChange', 'onClick', 'onContextMenu', 'onCopy', 'onCompositionEnd', 'onCompositionStart', 'onCompositionUpdate', 'onCut', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onError', 'onFocus', 'onInput', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onLoad', 'onWheel', 'onDragOver', 'onDragStart', 'onDrop', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp', 'onPaste', 'onScroll', 'onSelect', 'onSubmit', 'onTransitionEnd', 'radioGroup', 'readOnly', 'rowSpan', 'spellCheck', 'srcDoc', 'srcLang', 'srcSet', 'tabIndex', 'useMap',
'autoCapitalize', 'autoCorrect', 'autoSave', 'itemProp', 'itemScope', 'itemType', 'itemRef', 'itemID'];
var tagConvention = /^[a-z][^-]*$/;
function isTagName(node) {
  if (tagConvention.test(node.parent.name.name)) {
	return !node.parent.attributes.some(function (attrNode) {
			return attrNode.type === 'JSXAttribute' && attrNode.name.type === 'JSXIdentifier' && attrNode.name.name === 'is';
	});
  }
  return false;
}
function getStandardName(name) {
  if (DOM_ATTRIBUTE_NAMES[name]) {
	return DOM_ATTRIBUTE_NAMES[name];
  }
  if (SVGDOM_ATTRIBUTE_NAMES[name]) {
	return SVGDOM_ATTRIBUTE_NAMES[name];
  }
  var i = void 0;
  var found = DOM_PROPERTY_NAMES.some(function (element, index) {
	i = index;
	return element.toLowerCase() === name;
  });
  return found ? DOM_PROPERTY_NAMES[i] : null;
}
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of unknown DOM property',
			category: 'Possible Errors',
			recommended: true
	},
	fixable: 'code',

	schema: [{
			type: 'object',
			properties: {
		ignore: {
					type: 'array',
					items: {
			type: 'string'
					}
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	function getIgnoreConfig() {
			return context.options[0] && context.options[0].ignore || DEFAULTS.ignore;
	}

	var sourceCode = context.getSourceCode();

	return {

			JSXAttribute: function JSXAttribute(node) {
		var ignoreNames = getIgnoreConfig();
		var name = sourceCode.getText(node.name);
		var standardName = getStandardName(name);
		if (!isTagName(node) || !standardName || ignoreNames.indexOf(name) >= 0) {
					return;
		}
		context.report({
					node: node,
					message: UNKNOWN_MESSAGE,
					data: {
			name: name,
			standardName: standardName
					},
					fix: function fix(fixer) {
			return fixer.replaceText(node.name, standardName);
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var has = __webpack_require__(7);
var Components = __webpack_require__(8);
var variable = __webpack_require__(27);
var annotations = __webpack_require__(72);
var versionUtil = __webpack_require__(57);
var DIRECT_PROPS_REGEX = /^props\s*(\.|\[)/;
var DIRECT_NEXT_PROPS_REGEX = /^nextProps\s*(\.|\[)/;
var DIRECT_PREV_PROPS_REGEX = /^prevProps\s*(\.|\[)/;
var LIFE_CYCLE_METHODS = ['componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate'];
module.exports = {
  meta: {
	docs: {
			description: 'Prevent definitions of unused prop types',
			category: 'Best Practices',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		customValidators: {
					type: 'array',
					items: {
			type: 'string'
					}
		},
		skipShapeProps: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var defaults = { skipShapeProps: true };
	var sourceCode = context.getSourceCode();
	var configuration = Object.assign({}, defaults, context.options[0] || {});
	var skipShapeProps = configuration.skipShapeProps;
	var customValidators = configuration.customValidators || [];
	var propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
	var stack = null;

	var UNUSED_MESSAGE = '\'{{name}}\' PropType is defined but prop is never used';
	function typeScope(key, value) {
			if (arguments.length === 0) {
		return stack[stack.length - 1];
			} else if (arguments.length === 1) {
		return stack[stack.length - 1][key];
			}
			stack[stack.length - 1][key] = value;
			return value;
	}
	function inLifeCycleMethod() {
			var scope = context.getScope();
			while (scope) {
		if (scope.block && scope.block.parent && scope.block.parent.key && LIFE_CYCLE_METHODS.indexOf(scope.block.parent.key.name) >= 0) {
					return true;
		}
		scope = scope.upper;
			}
			return false;
	}
	function isPropTypesUsage(node) {
			var isClassUsage = (utils.getParentES6Component() || utils.getParentES5Component()) && node.object.type === 'ThisExpression' && node.property.name === 'props';
			var isStatelessFunctionUsage = node.object.name === 'props';
			return isClassUsage || isStatelessFunctionUsage || inLifeCycleMethod();
	}
	function isAnnotatedClassPropsDeclaration(node) {
			if (node && node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		if (node.typeAnnotation && (tokens[0].value === 'props' || tokens[1] && tokens[1].value === 'props')) {
					return true;
		}
			}
			return false;
	}
	function resolveSuperParameterPropsType(node) {
			var propsParameterPosition = void 0;
			try {
		propsParameterPosition = versionUtil.testFlowVersion(context, '0.53.0') ? 0 : 1;
			} catch (e) {
		propsParameterPosition = node.superTypeParameters.params.length <= 2 ? 0 : 1;
			}

			var annotation = node.superTypeParameters.params[propsParameterPosition];
			while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {
		annotation = annotation.typeAnnotation;
			}
			if (annotation.type === 'GenericTypeAnnotation' && typeScope(annotation.id.name)) {
		return typeScope(annotation.id.name);
			}
			return annotation;
	}
	function isSuperTypeParameterPropsDeclaration(node) {
			if (node && node.type === 'ClassDeclaration') {
		if (node.superTypeParameters && node.superTypeParameters.params.length > 0) {
					return true;
		}
			}
			return false;
	}
	function isPropTypesDeclaration(node) {
			if (node && node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		if (tokens[0].value === 'propTypes' || tokens[1] && tokens[1].value === 'propTypes') {
					return true;
		}
		return false;
			}

			return Boolean(node && node.name === 'propTypes');
	}
	function hasCustomValidator(validator) {
			return customValidators.indexOf(validator) !== -1;
	}
	function mustBeValidated(component) {
			return Boolean(component && !component.ignorePropsValidation);
	}
	function isNodeALifeCycleMethod(node) {
			var nodeKeyName = (node.key || {}).name;
			return node.kind === 'constructor' || nodeKeyName === 'componentWillReceiveProps' || nodeKeyName === 'shouldComponentUpdate' || nodeKeyName === 'componentWillUpdate' || nodeKeyName === 'componentDidUpdate';
	}
	function isInLifeCycleMethod(node) {
			if (node.type === 'MethodDefinition' && isNodeALifeCycleMethod(node)) {
		return true;
			}

			if (node.parent) {
		return isInLifeCycleMethod(node.parent);
			}

			return false;
	}
	function isPropAttributeName(node) {
			return node.init.name === 'props' || node.init.name === 'nextProps' || node.init.name === 'prevProps';
	}
	function isPropUsed(node, prop) {
			var usedPropTypes = node.usedPropTypes || [];
			for (var i = 0, l = usedPropTypes.length; i < l; i++) {
		var usedProp = usedPropTypes[i];
		if (prop.type === 'shape' || prop.name === '__ANY_KEY__' || usedProp.name === prop.name) {
					return true;
		}
			}

			return false;
	}
	function hasSpreadOperator(node) {
			var tokens = sourceCode.getTokens(node);
			return tokens.length && tokens[0].value === '...';
	}
	function stripQuotes(string) {
			return string.replace(/^\'|\'$/g, '');
	}
	function getKeyValue(node) {
			if (node.type === 'ObjectTypeProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[0].value === '+' || tokens[0].value === '-' ? tokens[1].value : stripQuotes(tokens[0].value);
			}
			var key = node.key || node.argument;
			return key.type === 'Identifier' ? key.name : key.value;
	}
	function iterateProperties(properties, fn) {
			if (properties.length && typeof fn === 'function') {
		for (var i = 0, j = properties.length; i < j; i++) {
					var node = properties[i];
					var key = getKeyValue(node);

					var value = node.value;
					fn(key, value);
		}
			}
	}
	function buildReactDeclarationTypes(value, parentName) {
			if (value && value.callee && value.callee.object && hasCustomValidator(value.callee.object.name)) {
		return {};
			}

			if (value && value.type === 'MemberExpression' && value.property && value.property.name && value.property.name === 'isRequired') {
		value = value.object;
			}
			if (value && value.type === 'CallExpression' && value.callee && value.callee.property && value.callee.property.name && value.arguments && value.arguments.length > 0) {
		var callName = value.callee.property.name;
		var argument = value.arguments[0];
		switch (callName) {
					case 'shape':
			if (skipShapeProps) {
							return {};
			}

			if (argument.type !== 'ObjectExpression') {
							return {};
			}
			var shapeTypeDefinition = {
							type: 'shape',
							children: []
			};
			iterateProperties(argument.properties, function (childKey, childValue) {
							var fullName = [parentName, childKey].join('.');
							var types = buildReactDeclarationTypes(childValue, fullName);
							types.fullName = fullName;
							types.name = childKey;
							types.node = childValue;
							shapeTypeDefinition.children.push(types);
			});
			return shapeTypeDefinition;
					case 'arrayOf':
					case 'objectOf':
			var fullName = [parentName, '*'].join('.');
			var child = buildReactDeclarationTypes(argument, fullName);
			child.fullName = fullName;
			child.name = '__ANY_KEY__';
			child.node = argument;
			return {
							type: 'object',
							children: [child]
			};
					case 'oneOfType':
			if (!argument.elements || !argument.elements.length) {
							return {};
			}
			var unionTypeDefinition = {
							type: 'union',
							children: []
			};
			for (var i = 0, j = argument.elements.length; i < j; i++) {
							var type = buildReactDeclarationTypes(argument.elements[i], parentName);
							if (Object.keys(type).length > 0) {
				if (type.children === true) {
									unionTypeDefinition.children = true;
									return unionTypeDefinition;
				}
							}

							unionTypeDefinition.children.push(type);
			}
			if (unionTypeDefinition.length === 0) {
							return {};
			}
			return unionTypeDefinition;
					case 'instanceOf':
			return {
							type: 'instance',
							children: true
			};
					case 'oneOf':
					default:
			return {};
		}
			}
			return {};
	}
	function buildTypeAnnotationDeclarationTypes(annotation, parentName) {
			switch (annotation.type) {
		case 'GenericTypeAnnotation':
					if (typeScope(annotation.id.name)) {
			return buildTypeAnnotationDeclarationTypes(typeScope(annotation.id.name), parentName);
					}
					return {};
		case 'ObjectTypeAnnotation':
					if (skipShapeProps) {
			return {};
					}
					var shapeTypeDefinition = {
			type: 'shape',
			children: []
					};
					iterateProperties(annotation.properties, function (childKey, childValue) {
			var fullName = [parentName, childKey].join('.');
			var types = buildTypeAnnotationDeclarationTypes(childValue, fullName);
			types.fullName = fullName;
			types.name = childKey;
			types.node = childValue;
			shapeTypeDefinition.children.push(types);
					});
					return shapeTypeDefinition;
		case 'UnionTypeAnnotation':
					var unionTypeDefinition = {
			type: 'union',
			children: []
					};
					for (var i = 0, j = annotation.types.length; i < j; i++) {
			var type = buildTypeAnnotationDeclarationTypes(annotation.types[i], parentName);
			if (Object.keys(type).length > 0) {
							if (type.children === true) {
				unionTypeDefinition.children = true;
				return unionTypeDefinition;
							}
			}

			unionTypeDefinition.children.push(type);
					}
					if (unionTypeDefinition.children.length === 0) {
			return {};
					}
					return unionTypeDefinition;
		case 'ArrayTypeAnnotation':
					var fullName = [parentName, '*'].join('.');
					var child = buildTypeAnnotationDeclarationTypes(annotation.elementType, fullName);
					child.fullName = fullName;
					child.name = '__ANY_KEY__';
					child.node = annotation;
					return {
			type: 'object',
			children: [child]
					};
		default:
					return {};
			}
	}
	function inConstructor() {
			var scope = context.getScope();
			while (scope) {
		if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {
					return true;
		}
		scope = scope.upper;
			}
			return false;
	}
	function getPropertyName(node) {
			var isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));
			var isDirectNextProp = DIRECT_NEXT_PROPS_REGEX.test(sourceCode.getText(node));
			var isDirectPrevProp = DIRECT_PREV_PROPS_REGEX.test(sourceCode.getText(node));
			var isInClassComponent = utils.getParentES6Component() || utils.getParentES5Component();
			var isNotInConstructor = !inConstructor(node);
			var isNotInLifeCycleMethod = !inLifeCycleMethod();
			if ((isDirectProp || isDirectNextProp || isDirectPrevProp) && isInClassComponent && isNotInConstructor && isNotInLifeCycleMethod) {
		return void 0;
			}
			if (!isDirectProp && !isDirectNextProp && !isDirectPrevProp) {
		node = node.parent;
			}
			var property = node.property;
			if (property) {
		switch (property.type) {
					case 'Identifier':
			if (node.computed) {
							return '__COMPUTED_PROP__';
			}
			return property.name;
					case 'MemberExpression':
			return void 0;
					case 'Literal':
			if (typeof property.value === 'string') {
							return property.value;
			}
					default:
			if (node.computed) {
							return '__COMPUTED_PROP__';
			}
			break;
		}
			}
			return void 0;
	}
	function markPropTypesAsUsed(node, parentNames) {
			parentNames = parentNames || [];
			var type = void 0;
			var name = void 0;
			var allNames = void 0;
			var properties = void 0;
			switch (node.type) {
		case 'MemberExpression':
					name = getPropertyName(node);
					if (name) {
			allNames = parentNames.concat(name);
			if (node.parent.type === 'MemberExpression') {
							markPropTypesAsUsed(node.parent, allNames);
			}
			type = name !== '__COMPUTED_PROP__' ? 'direct' : null;
					} else if (node.parent.id && node.parent.id.properties && node.parent.id.properties.length && getKeyValue(node.parent.id.properties[0])) {
			type = 'destructuring';
			properties = node.parent.id.properties;
					}
					break;
		case 'ArrowFunctionExpression':
		case 'FunctionDeclaration':
		case 'FunctionExpression':
					type = 'destructuring';
					properties = node.params[0].properties;
					break;
		case 'VariableDeclarator':
					for (var i = 0, j = node.id.properties.length; i < j; i++) {
			var thisDestructuring = node.id.properties[i].key && (node.id.properties[i].key.name === 'props' || node.id.properties[i].key.value === 'props') && node.id.properties[i].value.type === 'ObjectPattern';
			var genericDestructuring = isPropAttributeName(node) && (utils.getParentStatelessComponent() || isInLifeCycleMethod(node));

			if (thisDestructuring) {
							properties = node.id.properties[i].value.properties;
			} else if (genericDestructuring) {
							properties = node.id.properties;
			} else {
							continue;
			}
			type = 'destructuring';
			break;
					}
					break;
		default:
					throw new Error(node.type + ' ASTNodes are not handled by markPropTypesAsUsed');
			}

			var component = components.get(utils.getParentComponent());
			var usedPropTypes = component && component.usedPropTypes || [];
			var ignorePropsValidation = component && component.ignorePropsValidation || false;

			switch (type) {
		case 'direct':
					if (Object.prototype[name]) {
			break;
					}

					usedPropTypes.push({
			name: name,
			allNames: allNames
					});
					break;
		case 'destructuring':
					for (var k = 0, l = (properties || []).length; k < l; k++) {
			if (hasSpreadOperator(properties[k]) || properties[k].computed) {
							ignorePropsValidation = true;
							break;
			}
			var propName = getKeyValue(properties[k]);

			var currentNode = node;
			allNames = [];
			while (currentNode.property && currentNode.property.name !== 'props') {
							allNames.unshift(currentNode.property.name);
							currentNode = currentNode.object;
			}
			allNames.push(propName);

			if (propName) {
							usedPropTypes.push({
				allNames: allNames,
				name: propName
							});
			}
					}
					break;
		default:
					break;
			}

			components.set(component ? component.node : node, {
		usedPropTypes: usedPropTypes,
		ignorePropsValidation: ignorePropsValidation
			});
	}
	function declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes) {
			var ignorePropsValidation = false;

			iterateProperties(propTypes.properties, function (key, value) {
		if (!value) {
					ignorePropsValidation = true;
					return;
		}

		var types = buildTypeAnnotationDeclarationTypes(value, key);
		types.fullName = key;
		types.name = key;
		types.node = value;
		declaredPropTypes.push(types);
			});

			return ignorePropsValidation;
	}
	function declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes) {
			return propTypes.types.some(function (annotation) {
		if (annotation.type === 'ObjectTypeAnnotation') {
					return declarePropTypesForObjectTypeAnnotation(annotation, declaredPropTypes);
		}

		var typeNode = typeScope(annotation.id.name);

		if (!typeNode) {
					return true;
		} else if (typeNode.type === 'IntersectionTypeAnnotation') {
					return declarePropTypesForIntersectionTypeAnnotation(typeNode, declaredPropTypes);
		}

		return declarePropTypesForObjectTypeAnnotation(typeNode, declaredPropTypes);
			});
	}
	function markPropTypesAsDeclared(node, propTypes) {
			var component = components.get(node);
			var declaredPropTypes = component && component.declaredPropTypes || [];
			var ignorePropsValidation = component && component.ignorePropsValidation || false;

			switch (propTypes && propTypes.type) {
		case 'ObjectTypeAnnotation':
					ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes);
					break;
		case 'ObjectExpression':
					iterateProperties(propTypes.properties, function (key, value) {
			if (!value) {
							ignorePropsValidation = true;
							return;
			}
			var types = buildReactDeclarationTypes(value, key);
			types.fullName = key;
			types.name = key;
			types.node = value;
			declaredPropTypes.push(types);
					});
					break;
		case 'MemberExpression':
					break;
		case 'Identifier':
					var variablesInScope = variable.variablesInScope(context);
					for (var i = 0, j = variablesInScope.length; i < j; i++) {
			if (variablesInScope[i].name !== propTypes.name) {
							continue;
			}
			var defInScope = variablesInScope[i].defs[variablesInScope[i].defs.length - 1];
			markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init);
			return;
					}
					ignorePropsValidation = true;
					break;
		case 'CallExpression':
					if (propWrapperFunctions.has(propTypes.callee.name) && propTypes.arguments && propTypes.arguments[0]) {
			markPropTypesAsDeclared(node, propTypes.arguments[0]);
			return;
					}
					break;
		case 'IntersectionTypeAnnotation':
					ignorePropsValidation = declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes);
					break;
		case null:
					break;
		default:
					ignorePropsValidation = true;
					break;
			}

			components.set(node, {
		declaredPropTypes: declaredPropTypes,
		ignorePropsValidation: ignorePropsValidation
			});
	}
	function reportUnusedPropType(component, props) {
			if (props === true) {
		return;
			}

			(props || []).forEach(function (prop) {
		if (prop === true) {
					return;
		}

		if (prop.node && !isPropUsed(component, prop)) {
					context.report(prop.node, UNUSED_MESSAGE, {
			name: prop.fullName
					});
		}

		if (prop.children) {
					reportUnusedPropType(component, prop.children);
		}
			});
	}
	function reportUnusedPropTypes(component) {
			reportUnusedPropType(component, component.declaredPropTypes);
	}
	function resolveTypeAnnotation(node) {
			var annotation = node.typeAnnotation || node;
			while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {
		annotation = annotation.typeAnnotation;
			}
			if (annotation.type === 'GenericTypeAnnotation' && typeScope(annotation.id.name)) {
		return typeScope(annotation.id.name);
			}
			return annotation;
	}
	function markDestructuredFunctionArgumentsAsUsed(node) {
			var destructuring = node.params && node.params[0] && node.params[0].type === 'ObjectPattern';
			if (destructuring && components.get(node)) {
		markPropTypesAsUsed(node);
			}
	}
	function markAnnotatedFunctionArgumentsAsDeclared(node) {
			if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {
		return;
			}
			markPropTypesAsDeclared(node, resolveTypeAnnotation(node.params[0]));
	}
	function handleStatelessComponent(node) {
			markDestructuredFunctionArgumentsAsUsed(node);
			markAnnotatedFunctionArgumentsAsDeclared(node);
	}
	return {
			ClassDeclaration: function ClassDeclaration(node) {
		if (isSuperTypeParameterPropsDeclaration(node)) {
					markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));
		}
			},

			ClassProperty: function ClassProperty(node) {
		if (isAnnotatedClassPropsDeclaration(node)) {
					markPropTypesAsDeclared(node, resolveTypeAnnotation(node));
		} else if (isPropTypesDeclaration(node)) {
					markPropTypesAsDeclared(node, node.value);
		}
			},

			VariableDeclarator: function VariableDeclarator(node) {
		var destructuring = node.init && node.id && node.id.type === 'ObjectPattern';
		var thisDestructuring = destructuring && node.init.type === 'ThisExpression';
		var statelessDestructuring = destructuring && isPropAttributeName(node) && (utils.getParentStatelessComponent() || isInLifeCycleMethod(node));

		if (!thisDestructuring && !statelessDestructuring) {
					return;
		}
		markPropTypesAsUsed(node);
			},

			FunctionDeclaration: handleStatelessComponent,

			ArrowFunctionExpression: handleStatelessComponent,

			FunctionExpression: handleStatelessComponent,

			MemberExpression: function MemberExpression(node) {
		var type = void 0;
		if (isPropTypesUsage(node)) {
					type = 'usage';
		} else if (isPropTypesDeclaration(node.property)) {
					type = 'declaration';
		}

		switch (type) {
					case 'usage':
			markPropTypesAsUsed(node);
			break;
					case 'declaration':
			var component = utils.getRelatedComponent(node);
			if (!component) {
							return;
			}
			markPropTypesAsDeclared(component.node, node.parent.right || node.parent);
			break;
					default:
			break;
		}
			},

			JSXSpreadAttribute: function JSXSpreadAttribute(node) {
		var component = components.get(utils.getParentComponent());
		components.set(component ? component.node : node, {
					ignorePropsValidation: true
		});
			},

			MethodDefinition: function MethodDefinition(node) {
		if (!isPropTypesDeclaration(node.key)) {
					return;
		}

		var i = node.value.body.body.length - 1;
		for (; i >= 0; i--) {
					if (node.value.body.body[i].type === 'ReturnStatement') {
			break;
					}
		}

		if (i >= 0) {
					markPropTypesAsDeclared(node, node.value.body.body[i].argument);
		}
			},

			ObjectPattern: function ObjectPattern(node) {
		if (isNodeALifeCycleMethod(node.parent.parent)) {
					node.properties.forEach(function (property, i) {
			if (i === 0) {
							markPropTypesAsUsed(node.parent);
			}
					});
		}
			},

			ObjectExpression: function ObjectExpression(node) {
		node.properties.forEach(function (property) {
					if (!isPropTypesDeclaration(property.key)) {
			return;
					}
					markPropTypesAsDeclared(node, property.value);
		});
			},

			TypeAlias: function TypeAlias(node) {
		typeScope(node.id.name, node.right);
			},

			Program: function Program() {
		stack = [{}];
			},

			BlockStatement: function BlockStatement() {
		stack.push(Object.create(typeScope()));
			},

			'BlockStatement:exit': function BlockStatementExit() {
		stack.pop();
			},

			'Program:exit': function ProgramExit() {
		stack = null;
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || !mustBeValidated(list[component])) {
			continue;
					}
					reportUnusedPropTypes(list[component]);
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var Components = __webpack_require__(8);
function uncast(node) {
  while (node.type === 'TypeCastExpression') {
	node = node.expression;
  }
  return node;
}
function getName(node) {
  node = uncast(node);
  var type = node.type;

  if (type === 'Identifier') {
	return node.name;
  } else if (type === 'Literal') {
	return String(node.value);
  } else if (type === 'TemplateLiteral' && node.expressions.length === 0) {
	return node.quasis[0].value.raw;
  }
  return null;
}

function isThisExpression(node) {
  return uncast(node).type === 'ThisExpression';
}

function getInitialClassInfo() {
  return {
	stateFields: new Set(),
	usedStateFields: new Set(),
	aliases: null
  };
}

module.exports = {
  meta: {
	docs: {
			description: 'Prevent definition of unused state fields',
			category: 'Best Practices',
			recommended: false
	},
	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	var classInfo = null;
	function isStateReference(node) {
			node = uncast(node);

			var isDirectStateReference = node.type === 'MemberExpression' && isThisExpression(node.object) && node.property.name === 'state';

			var isAliasedStateReference = node.type === 'Identifier' && classInfo.aliases && classInfo.aliases.has(node.name);

			return isDirectStateReference || isAliasedStateReference;
	}
	function addStateFields(node) {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
		for (var _iterator = node.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var prop = _step.value;

					var key = prop.key;

					if (prop.type === 'Property' && (key.type === 'Literal' || key.type === 'TemplateLiteral' && key.expressions.length === 0 || prop.computed === false && key.type === 'Identifier') && getName(prop.key) !== null) {
			classInfo.stateFields.add(prop);
					}
		}
			} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
			} finally {
		try {
					if (!_iteratorNormalCompletion && _iterator.return) {
			_iterator.return();
					}
		} finally {
					if (_didIteratorError) {
			throw _iteratorError;
					}
		}
			}
	}
	function addUsedStateField(node) {
			var name = getName(node);
			if (name) {
		classInfo.usedStateFields.add(name);
			}
	}
	function handleStateDestructuring(node) {
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
		for (var _iterator2 = node.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var prop = _step2.value;

					if (prop.type === 'Property') {
			addUsedStateField(prop.key);
					} else if (prop.type === 'ExperimentalRestProperty' && classInfo.aliases) {
			classInfo.aliases.add(getName(prop.argument));
					}
		}
			} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
			} finally {
		try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
			_iterator2.return();
					}
		} finally {
					if (_didIteratorError2) {
			throw _iteratorError2;
					}
		}
			}
	}
	function handleAssignment(left, right) {
			switch (left.type) {
		case 'Identifier':
					if (isStateReference(right) && classInfo.aliases) {
			classInfo.aliases.add(left.name);
					}
					break;
		case 'ObjectPattern':
					if (isStateReference(right)) {
			handleStateDestructuring(left);
					} else if (isThisExpression(right) && classInfo.aliases) {
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
							for (var _iterator3 = left.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var prop = _step3.value;

				if (prop.type === 'Property' && getName(prop.key) === 'state') {
									var name = getName(prop.value);
									if (name) {
					classInfo.aliases.add(name);
									} else if (prop.value.type === 'ObjectPattern') {
					handleStateDestructuring(prop.value);
									}
				}
							}
			} catch (err) {
							_didIteratorError3 = true;
							_iteratorError3 = err;
			} finally {
							try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
									_iterator3.return();
				}
							} finally {
				if (_didIteratorError3) {
									throw _iteratorError3;
				}
							}
			}
					}
					break;
		default:
			}
	}

	function reportUnusedFields() {
			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
		for (var _iterator4 = classInfo.stateFields[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var node = _step4.value;

					var name = getName(node.key);
					if (!classInfo.usedStateFields.has(name)) {
			context.report(node, 'Unused state field: \'' + name + '\'');
					}
		}
			} catch (err) {
		_didIteratorError4 = true;
		_iteratorError4 = err;
			} finally {
		try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
			_iterator4.return();
					}
		} finally {
					if (_didIteratorError4) {
			throw _iteratorError4;
					}
		}
			}
	}

	return {
			ClassDeclaration: function ClassDeclaration(node) {
		if (utils.isES6Component(node)) {
					classInfo = getInitialClassInfo();
		}
			},
			ObjectExpression: function ObjectExpression(node) {
		if (utils.isES5Component(node)) {
					classInfo = getInitialClassInfo();
		}
			},
			'ObjectExpression:exit': function ObjectExpressionExit(node) {
		if (!classInfo) {
					return;
		}

		if (utils.isES5Component(node)) {
					reportUnusedFields();
					classInfo = null;
		}
			},
			'ClassDeclaration:exit': function ClassDeclarationExit() {
		if (!classInfo) {
					return;
		}
		reportUnusedFields();
		classInfo = null;
			},
			CallExpression: function CallExpression(node) {
		if (!classInfo) {
					return;
		}
		if (node.callee.type === 'MemberExpression' && isThisExpression(node.callee.object) && getName(node.callee.property) === 'setState' && node.arguments.length > 0 && node.arguments[0].type === 'ObjectExpression') {
					addStateFields(node.arguments[0]);
		}
			},
			ClassProperty: function ClassProperty(node) {
		if (!classInfo) {
					return;
		}
		if (getName(node.key) === 'state' && !node.static && node.value && node.value.type === 'ObjectExpression') {
					addStateFields(node.value);
		}
			},
			MethodDefinition: function MethodDefinition() {
		if (!classInfo) {
					return;
		}
		classInfo.aliases = new Set();
			},
			'MethodDefinition:exit': function MethodDefinitionExit() {
		if (!classInfo) {
					return;
		}
		classInfo.aliases = null;
			},
			FunctionExpression: function FunctionExpression(node) {
		if (!classInfo) {
					return;
		}

		var parent = node.parent;
		if (!utils.isES5Component(parent.parent)) {
					return;
		}

		if (parent.key.name === 'getInitialState') {
					var body = node.body.body;
					var lastBodyNode = body[body.length - 1];

					if (lastBodyNode.type === 'ReturnStatement' && lastBodyNode.argument.type === 'ObjectExpression') {
			addStateFields(lastBodyNode.argument);
					}
		} else {
					classInfo.aliases = new Set();
		}
			},
			AssignmentExpression: function AssignmentExpression(node) {
		if (!classInfo) {
					return;
		}
		if (node.left.type === 'MemberExpression' && isThisExpression(node.left.object) && getName(node.left.property) === 'state' && node.right.type === 'ObjectExpression') {
					var fn = node;
					while (fn.type !== 'FunctionExpression' && fn.parent) {
			fn = fn.parent;
					}
					if (fn.parent && fn.parent.type === 'MethodDefinition' && fn.parent.kind === 'constructor') {
			addStateFields(node.right);
					}
		} else {
					handleAssignment(node.left, node.right);
		}
			},
			VariableDeclarator: function VariableDeclarator(node) {
		if (!classInfo || !node.init) {
					return;
		}
		handleAssignment(node.id, node.init);
			},
			MemberExpression: function MemberExpression(node) {
		if (!classInfo) {
					return;
		}
		if (isStateReference(node.object)) {
					if (node.computed && node.property.type !== 'Literal') {
			classInfo = null;
			return;
					}
					addUsedStateField(node.property);
		}
			},
			JSXSpreadAttribute: function JSXSpreadAttribute(node) {
		if (classInfo && isStateReference(node.argument)) {
					classInfo = null;
		}
			},
			ExperimentalSpreadProperty: function ExperimentalSpreadProperty(node) {
		if (classInfo && isStateReference(node.argument)) {
					classInfo = null;
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var makeNoMethodSetStateRule = __webpack_require__(111);

module.exports = makeNoMethodSetStateRule('componentWillUpdate');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce ES5 or ES6 class for React Components',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			enum: ['always', 'never']
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var configuration = context.options[0] || 'always';

	return {
			ObjectExpression: function ObjectExpression(node) {
		if (utils.isES5Component(node) && configuration === 'always') {
					context.report({
			node: node,
			message: 'Component should use es6 class instead of createClass'
					});
		}
			},
			ClassDeclaration: function ClassDeclaration(node) {
		if (utils.isES6Component(node) && configuration === 'never') {
					context.report({
			node: node,
			message: 'Component should use createClass instead of es6 class'
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
var versionUtil = __webpack_require__(57);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce stateless components to be written as a pure function',
			category: 'Stylistic Issues',
			recommended: false
	},
	schema: [{
			type: 'object',
			properties: {
		ignorePureComponents: {
					default: false,
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var configuration = context.options[0] || {};
	var ignorePureComponents = configuration.ignorePureComponents || false;

	var sourceCode = context.getSourceCode();
	function getPropertyName(node) {
			if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
			}

			return node.key.name;
	}
	function getComponentProperties(node) {
			switch (node.type) {
		case 'ClassExpression':
		case 'ClassDeclaration':
					return node.body.body;
		case 'ObjectExpression':
					return node.properties;
		default:
					return [];
			}
	}
	function isSingleSuperCall(body) {
			return body.length === 1 && body[0].type === 'ExpressionStatement' && body[0].expression.type === 'CallExpression' && body[0].expression.callee.type === 'Super';
	}
	function isSimple(node) {
			return node.type === 'Identifier' || node.type === 'RestElement';
	}
	function isSpreadArguments(superArgs) {
			return superArgs.length === 1 && superArgs[0].type === 'SpreadElement' && superArgs[0].argument.type === 'Identifier' && superArgs[0].argument.name === 'arguments';
	}
	function isValidIdentifierPair(ctorParam, superArg) {
			return ctorParam.type === 'Identifier' && superArg.type === 'Identifier' && ctorParam.name === superArg.name;
	}
	function isValidRestSpreadPair(ctorParam, superArg) {
			return ctorParam.type === 'RestElement' && superArg.type === 'SpreadElement' && isValidIdentifierPair(ctorParam.argument, superArg.argument);
	}
	function isValidPair(ctorParam, superArg) {
			return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);
	}
	function isPassingThrough(ctorParams, superArgs) {
			if (ctorParams.length !== superArgs.length) {
		return false;
			}

			for (var i = 0; i < ctorParams.length; ++i) {
		if (!isValidPair(ctorParams[i], superArgs[i])) {
					return false;
		}
			}

			return true;
	}
	function isRedundantSuperCall(body, ctorParams) {
			return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));
	}
	function hasOtherProperties(node) {
			var properties = getComponentProperties(node);
			return properties.some(function (property) {
		var name = getPropertyName(property);
		var isDisplayName = name === 'displayName';
		var isPropTypes = name === 'propTypes' || name === 'props' && property.typeAnnotation;
		var contextTypes = name === 'contextTypes';
		var isUselessConstructor = property.kind === 'constructor' && isRedundantSuperCall(property.value.body.body, property.value.params);
		var isRender = name === 'render';
		return !isDisplayName && !isPropTypes && !contextTypes && !isUselessConstructor && !isRender;
			});
	}
	var markSCUAsDeclared = function markSCUAsDeclared(node) {
			components.set(node, {
		hasSCU: true
			});
	};
	var markChildContextTypesAsDeclared = function markChildContextTypesAsDeclared(node) {
			components.set(node, {
		hasChildContextTypes: true
			});
	};
	function markThisAsUsed(node) {
			components.set(node, {
		useThis: true
			});
	}
	function markPropsOrContextAsUsed(node) {
			components.set(node, {
		usePropsOrContext: true
			});
	}
	function markRefAsUsed(node) {
			components.set(node, {
		useRef: true
			});
	}
	function markReturnAsInvalid(node) {
			components.set(node, {
		invalidReturn: true
			});
	}
	function markDecoratorsAsUsed(node) {
			components.set(node, {
		useDecorators: true
			});
	}

	function visitClass(node) {
			if (ignorePureComponents && utils.isPureComponent(node)) {
		markSCUAsDeclared(node);
			}

			if (node.decorators && node.decorators.length) {
		markDecoratorsAsUsed(node);
			}
	}

	return {
			ClassDeclaration: visitClass,
			ClassExpression: visitClass,
			VariableDeclarator: function VariableDeclarator(node) {
		if (!node.id || node.id.type !== 'ObjectPattern' || !node.init || node.init.type !== 'ThisExpression') {
					return;
		}
		var useThis = node.id.properties.some(function (property) {
					var name = getPropertyName(property);
					return name !== 'props' && name !== 'context';
		});
		if (!useThis) {
					markPropsOrContextAsUsed(node);
					return;
		}
		markThisAsUsed(node);
			},
			MemberExpression: function MemberExpression(node) {
		if (node.object.type !== 'ThisExpression') {
					if (node.property && node.property.name === 'childContextTypes') {
			var component = utils.getRelatedComponent(node);
			if (!component) {
							return;
			}
			markChildContextTypesAsDeclared(component.node);
			return;
					}
					return;
		} else if ((node.property.name || node.property.value) === 'props' || (node.property.name || node.property.value) === 'context') {
					markPropsOrContextAsUsed(node);
					return;
		}
		markThisAsUsed(node);
			},
			JSXAttribute: function JSXAttribute(node) {
		var name = sourceCode.getText(node.name);
		if (name !== 'ref') {
					return;
		}
		markRefAsUsed(node);
			},
			ReturnStatement: function ReturnStatement(node) {
		var blockNode = void 0;
		var scope = context.getScope();
		while (scope) {
					blockNode = scope.block && scope.block.parent;
					if (blockNode && (blockNode.type === 'MethodDefinition' || blockNode.type === 'Property')) {
			break;
					}
					scope = scope.upper;
		}
		var isRender = blockNode && blockNode.key && blockNode.key.name === 'render';
		var allowNull = versionUtil.testReactVersion(context, '15.0.0'); // Stateless components can return null since React 15
		var isReturningJSX = utils.isReturningJSX(node, !allowNull);
		var isReturningNull = node.argument && (node.argument.value === null || node.argument.value === false);
		if (!isRender || allowNull && (isReturningJSX || isReturningNull) || !allowNull && isReturningJSX) {
					return;
		}
		markReturnAsInvalid(node);
			},

			'Program:exit': function ProgramExit() {
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || hasOtherProperties(list[component].node) || list[component].useThis || list[component].useRef || list[component].invalidReturn || list[component].hasChildContextTypes || list[component].useDecorators || !utils.isES5Component(list[component].node) && !utils.isES6Component(list[component].node)) {
			continue;
					}

					if (list[component].hasSCU && list[component].usePropsOrContext) {
			continue;
					}
					context.report({
			node: list[component].node,
			message: 'Component should be written as a pure function'
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var has = __webpack_require__(7);
var Components = __webpack_require__(8);
var variable = __webpack_require__(27);
var annotations = __webpack_require__(72);
var versionUtil = __webpack_require__(57);
var PROPS_REGEX = /^(props|nextProps)$/;
var DIRECT_PROPS_REGEX = /^(props|nextProps)\s*(\.|\[)/;
module.exports = {
  meta: {
	docs: {
			description: 'Prevent missing props validation in a React component definition',
			category: 'Best Practices',
			recommended: true
	},

	schema: [{
			type: 'object',
			properties: {
		ignore: {
					type: 'array',
					items: {
			type: 'string'
					}
		},
		customValidators: {
					type: 'array',
					items: {
			type: 'string'
					}
		},
		skipUndeclared: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var sourceCode = context.getSourceCode();
	var configuration = context.options[0] || {};
	var propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
	var ignored = configuration.ignore || [];
	var customValidators = configuration.customValidators || [];
	var skipUndeclared = configuration.skipUndeclared || false;
	var stack = null;
	var classExpressions = [];

	var MISSING_MESSAGE = '\'{{name}}\' is missing in props validation';
	function typeScope(key, value) {
			if (arguments.length === 0) {
		return stack[stack.length - 1];
			} else if (arguments.length === 1) {
		return stack[stack.length - 1][key];
			}
			stack[stack.length - 1][key] = value;
			return value;
	}
	function inConstructor() {
			var scope = context.getScope();
			while (scope) {
		if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {
					return true;
		}
		scope = scope.upper;
			}
			return false;
	}
	function inComponentWillReceiveProps() {
			var scope = context.getScope();
			while (scope) {
		if (scope.block && scope.block.parent && scope.block.parent.key && scope.block.parent.key.name === 'componentWillReceiveProps') {
					return true;
		}
		scope = scope.upper;
			}
			return false;
	}

	function isAssignmentToProp(node) {
			return node.parent && node.parent.type === 'AssignmentExpression' && node.parent.left === node;
	}
	function isPropTypesUsage(node) {
			var isClassUsage = (utils.getParentES6Component() || utils.getParentES5Component()) && node.object.type === 'ThisExpression' && node.property.name === 'props';
			var isStatelessFunctionUsage = node.object.name === 'props' && !isAssignmentToProp(node);
			var isNextPropsUsage = node.object.name === 'nextProps' && inComponentWillReceiveProps();
			return isClassUsage || isStatelessFunctionUsage || isNextPropsUsage;
	}
	function isAnnotatedClassPropsDeclaration(node) {
			if (node && node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		if (node.typeAnnotation && (tokens[0].value === 'props' || tokens[1] && tokens[1].value === 'props')) {
					return true;
		}
			}
			return false;
	}
	function isSuperTypeParameterPropsDeclaration(node) {
			if (node && (node.type === 'ClassDeclaration' || node.type === 'ClassExpression')) {
		if (node.superTypeParameters && node.superTypeParameters.params.length > 0) {
					return true;
		}
			}
			return false;
	}
	function isPropTypesDeclaration(node) {
			if (node && node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		if (tokens[0].value === 'propTypes' || tokens[1] && tokens[1].value === 'propTypes') {
					return true;
		}
		return false;
			}

			return Boolean(node && node.name === 'propTypes');
	}
	function isIgnored(name) {
			return ignored.indexOf(name) !== -1;
	}
	function hasCustomValidator(validator) {
			return customValidators.indexOf(validator) !== -1;
	}
	function mustBeValidated(component) {
			var isSkippedByConfig = skipUndeclared && typeof component.declaredPropTypes === 'undefined';
			return Boolean(component && component.usedPropTypes && !component.ignorePropsValidation && !isSkippedByConfig);
	}
	function _isDeclaredInComponent(declaredPropTypes, keyList) {
			for (var i = 0, j = keyList.length; i < j; i++) {
		var key = keyList[i];

		var propType = declaredPropTypes && (
		declaredPropTypes[key] || // If not, check if this type accepts any key
		declaredPropTypes.__ANY_KEY__);

		if (!propType) {
					return key === '__COMPUTED_PROP__';
		}
		if ((typeof propType === 'undefined' ? 'undefined' : _typeof(propType)) === 'object' && Object.keys(propType).length === 0) {
					return true;
		}
		if (propType.children === true) {
					return true;
		}
		if (propType.acceptedProperties) {
					return key in propType.acceptedProperties;
		}
		if (propType.type === 'union') {
					if (i + 1 >= j) {
			return true;
					}
					var unionTypes = propType.children;
					var unionPropType = {};
					for (var k = 0, z = unionTypes.length; k < z; k++) {
			unionPropType[key] = unionTypes[k];
			var isValid = _isDeclaredInComponent(unionPropType, keyList.slice(i));
			if (isValid) {
							return true;
			}
					}
					return false;
		}
		declaredPropTypes = propType.children;
			}
			return true;
	}
	function isDeclaredInComponent(node, names) {
			while (node) {
		var component = components.get(node);

		var isDeclared = component && component.confidence === 2 && _isDeclaredInComponent(component.declaredPropTypes || {}, names);
		if (isDeclared) {
					return true;
		}
		node = node.parent;
			}
			return false;
	}
	function hasSpreadOperator(node) {
			var tokens = sourceCode.getTokens(node);
			return tokens.length && tokens[0].value === '...';
	}
	function stripQuotes(string) {
			return string.replace(/^\'|\'$/g, '');
	}
	function getKeyValue(node) {
			if (node.type === 'ObjectTypeProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[0].value === '+' || tokens[0].value === '-' ? tokens[1].value : stripQuotes(tokens[0].value);
			}
			var key = node.key || node.argument;
			return key.type === 'Identifier' ? key.name : key.value;
	}
	function iterateProperties(properties, fn) {
			if (properties.length && typeof fn === 'function') {
		for (var i = 0, j = properties.length; i < j; i++) {
					var node = properties[i];
					var key = getKeyValue(node);

					var value = node.value;
					fn(key, value);
		}
			}
	}
	function buildReactDeclarationTypes(value) {
			if (value && value.callee && value.callee.object && hasCustomValidator(value.callee.object.name)) {
		return {};
			}

			if (value && value.type === 'MemberExpression' && value.property && value.property.name && value.property.name === 'isRequired') {
		value = value.object;
			}
			if (value && value.type === 'CallExpression' && value.callee && value.callee.property && value.callee.property.name && value.arguments && value.arguments.length > 0) {
		var callName = value.callee.property.name;
		var argument = value.arguments[0];
		switch (callName) {
					case 'shape':
			if (argument.type !== 'ObjectExpression') {
							return {};
			}
			var shapeTypeDefinition = {
							type: 'shape',
							children: {}
			};
			iterateProperties(argument.properties, function (childKey, childValue) {
							shapeTypeDefinition.children[childKey] = buildReactDeclarationTypes(childValue);
			});
			return shapeTypeDefinition;
					case 'arrayOf':
					case 'objectOf':
			return {
							type: 'object',
							children: {
				__ANY_KEY__: buildReactDeclarationTypes(argument)
							}
			};
					case 'oneOfType':
			if (!argument.elements || !argument.elements.length) {
							return {};
			}
			var unionTypeDefinition = {
							type: 'union',
							children: []
			};
			for (var i = 0, j = argument.elements.length; i < j; i++) {
							var type = buildReactDeclarationTypes(argument.elements[i]);
							if (Object.keys(type).length > 0) {
				if (type.children === true) {
									unionTypeDefinition.children = true;
									return unionTypeDefinition;
				}
							}

							unionTypeDefinition.children.push(type);
			}
			if (unionTypeDefinition.length === 0) {
							return {};
			}
			return unionTypeDefinition;
					case 'instanceOf':
			return {
							type: 'instance',
							children: true
			};
					case 'oneOf':
					default:
			return {};
		}
			}
			return {};
	}
	function buildTypeAnnotationDeclarationTypes(annotation) {
			switch (annotation.type) {
		case 'GenericTypeAnnotation':
					if (typeScope(annotation.id.name)) {
			return buildTypeAnnotationDeclarationTypes(typeScope(annotation.id.name));
					}
					return {};
		case 'ObjectTypeAnnotation':
					var containsObjectTypeSpread = false;
					var shapeTypeDefinition = {
			type: 'shape',
			children: {}
					};
					iterateProperties(annotation.properties, function (childKey, childValue) {
			if (!childKey && !childValue) {
							containsObjectTypeSpread = true;
			} else {
							shapeTypeDefinition.children[childKey] = buildTypeAnnotationDeclarationTypes(childValue);
			}
					});
					if (containsObjectTypeSpread) {
			return {};
					}
					return shapeTypeDefinition;
		case 'UnionTypeAnnotation':
					var unionTypeDefinition = {
			type: 'union',
			children: []
					};
					for (var i = 0, j = annotation.types.length; i < j; i++) {
			var type = buildTypeAnnotationDeclarationTypes(annotation.types[i]);
			if (Object.keys(type).length > 0) {
							if (type.children === true) {
				unionTypeDefinition.children = true;
				return unionTypeDefinition;
							}
			}

			unionTypeDefinition.children.push(type);
					}
					if (unionTypeDefinition.children.length === 0) {
			return {};
					}
					return unionTypeDefinition;
		case 'ArrayTypeAnnotation':
					return {
			type: 'object',
			children: {
							__ANY_KEY__: buildTypeAnnotationDeclarationTypes(annotation.elementType)
			}
					};
		default:
					return {};
			}
	}
	function getPropertyName(node) {
			var isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));
			var isInClassComponent = utils.getParentES6Component() || utils.getParentES5Component();
			var isNotInConstructor = !inConstructor();
			var isNotInComponentWillReceiveProps = !inComponentWillReceiveProps();
			if (isDirectProp && isInClassComponent && isNotInConstructor && isNotInComponentWillReceiveProps) {
		return void 0;
			}
			if (!isDirectProp) {
		node = node.parent;
			}
			var property = node.property;
			if (property) {
		switch (property.type) {
					case 'Identifier':
			if (node.computed) {
							return '__COMPUTED_PROP__';
			}
			return property.name;
					case 'MemberExpression':
			return void 0;
					case 'Literal':
			if (typeof property.value === 'string') {
							return property.value;
			}
					default:
			if (node.computed) {
							return '__COMPUTED_PROP__';
			}
			break;
		}
			}
			return void 0;
	}
	function markPropTypesAsUsed(node, parentNames) {
			parentNames = parentNames || [];
			var type = void 0;
			var name = void 0;
			var allNames = void 0;
			var properties = void 0;
			switch (node.type) {
		case 'MemberExpression':
					name = getPropertyName(node);
					if (name) {
			allNames = parentNames.concat(name);
			if (node.parent.type === 'MemberExpression') {
							markPropTypesAsUsed(node.parent, allNames);
			}
			type = name !== '__COMPUTED_PROP__' ? 'direct' : null;
					} else if (node.parent.id && node.parent.id.properties && node.parent.id.properties.length && getKeyValue(node.parent.id.properties[0])) {
			type = 'destructuring';
			properties = node.parent.id.properties;
					}
					break;
		case 'ArrowFunctionExpression':
		case 'FunctionDeclaration':
		case 'FunctionExpression':
					type = 'destructuring';
					properties = node.params[0].properties;
					break;
		case 'VariableDeclarator':
					for (var i = 0, j = node.id.properties.length; i < j; i++) {
			var thisDestructuring = !hasSpreadOperator(node.id.properties[i]) && (PROPS_REGEX.test(node.id.properties[i].key.name) || PROPS_REGEX.test(node.id.properties[i].key.value)) && node.id.properties[i].value.type === 'ObjectPattern';
			var directDestructuring = PROPS_REGEX.test(node.init.name) && (utils.getParentStatelessComponent() || inConstructor() || inComponentWillReceiveProps());

			if (thisDestructuring) {
							properties = node.id.properties[i].value.properties;
			} else if (directDestructuring) {
							properties = node.id.properties;
			} else {
							continue;
			}
			type = 'destructuring';
			break;
					}
					break;
		default:
					throw new Error(node.type + ' ASTNodes are not handled by markPropTypesAsUsed');
			}

			var component = components.get(utils.getParentComponent());
			var usedPropTypes = (component && component.usedPropTypes || []).slice();

			switch (type) {
		case 'direct':
					if (Object.prototype[name]) {
			break;
					}

					var isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));

					usedPropTypes.push({
			name: name,
			allNames: allNames,
			node: !isDirectProp && !inConstructor() && !inComponentWillReceiveProps() ? node.parent.property : node.property
					});
					break;
		case 'destructuring':
					for (var k = 0, l = properties.length; k < l; k++) {
			if (hasSpreadOperator(properties[k]) || properties[k].computed) {
							continue;
			}
			var propName = getKeyValue(properties[k]);

			var currentNode = node;
			allNames = [];
			while (currentNode.property && !PROPS_REGEX.test(currentNode.property.name)) {
							allNames.unshift(currentNode.property.name);
							currentNode = currentNode.object;
			}
			allNames.push(propName);

			if (propName) {
							usedPropTypes.push({
				name: propName,
				allNames: allNames,
				node: properties[k]
							});
			}
					}
					break;
		default:
					break;
			}

			components.set(node, {
		usedPropTypes: usedPropTypes
			});
	}
	function declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes) {
			var ignorePropsValidation = false;

			iterateProperties(propTypes.properties, function (key, value) {
		if (!value) {
					ignorePropsValidation = true;
					return;
		}

		declaredPropTypes[key] = buildTypeAnnotationDeclarationTypes(value);
			});

			return ignorePropsValidation;
	}
	function declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes) {
			return propTypes.types.some(function (annotation) {
		if (annotation.type === 'ObjectTypeAnnotation') {
					return declarePropTypesForObjectTypeAnnotation(annotation, declaredPropTypes);
		}

		var typeNode = typeScope(annotation.id.name);

		if (!typeNode) {
					return true;
		} else if (typeNode.type === 'IntersectionTypeAnnotation') {
					return declarePropTypesForIntersectionTypeAnnotation(typeNode, declaredPropTypes);
		}

		return declarePropTypesForObjectTypeAnnotation(typeNode, declaredPropTypes);
			});
	}
	function markPropTypesAsDeclared(node, propTypes) {
			var componentNode = node;
			while (componentNode && !components.get(componentNode)) {
		componentNode = componentNode.parent;
			}
			var component = components.get(componentNode);
			var declaredPropTypes = component && component.declaredPropTypes || {};
			var ignorePropsValidation = false;

			switch (propTypes && propTypes.type) {
		case 'ObjectTypeAnnotation':
					ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes);
					break;
		case 'ObjectExpression':
					iterateProperties(propTypes.properties, function (key, value) {
			if (!value) {
							ignorePropsValidation = true;
							return;
			}
			declaredPropTypes[key] = buildReactDeclarationTypes(value);
					});
					break;
		case 'MemberExpression':
					var curDeclaredPropTypes = declaredPropTypes;
					while (propTypes && propTypes.parent && propTypes.parent.type !== 'AssignmentExpression' && propTypes.property && curDeclaredPropTypes) {
			var propName = propTypes.property.name;
			if (propName in curDeclaredPropTypes) {
							curDeclaredPropTypes = curDeclaredPropTypes[propName].children;
							propTypes = propTypes.parent;
			} else {
							propTypes = null;
			}
					}
					if (propTypes && propTypes.parent && propTypes.property) {
			curDeclaredPropTypes[propTypes.property.name] = buildReactDeclarationTypes(propTypes.parent.right);
					} else {
			ignorePropsValidation = true;
					}
					break;
		case 'Identifier':
					var variablesInScope = variable.variablesInScope(context);
					for (var i = 0, j = variablesInScope.length; i < j; i++) {
			if (variablesInScope[i].name !== propTypes.name) {
							continue;
			}
			var defInScope = variablesInScope[i].defs[variablesInScope[i].defs.length - 1];
			markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init);
			return;
					}
					ignorePropsValidation = true;
					break;
		case 'CallExpression':
					if (propWrapperFunctions.has(sourceCode.getText(propTypes.callee)) && propTypes.arguments && propTypes.arguments[0]) {
			markPropTypesAsDeclared(node, propTypes.arguments[0]);
			return;
					}
					break;
		case 'IntersectionTypeAnnotation':
					ignorePropsValidation = declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes);
					break;
		case null:
					break;
		default:
					ignorePropsValidation = true;
					break;
			}

			components.set(node, {
		declaredPropTypes: declaredPropTypes,
		ignorePropsValidation: ignorePropsValidation
			});
	}
	function reportUndeclaredPropTypes(component) {
			var allNames = void 0;
			for (var i = 0, j = component.usedPropTypes.length; i < j; i++) {
		allNames = component.usedPropTypes[i].allNames;
		if (isIgnored(allNames[0]) || isDeclaredInComponent(component.node, allNames)) {
					continue;
		}
		context.report(component.usedPropTypes[i].node, MISSING_MESSAGE, {
					name: allNames.join('.').replace(/\.__COMPUTED_PROP__/g, '[]')
		});
			}
	}
	function resolveTypeAnnotation(node) {
			var annotation = node.typeAnnotation || node;
			while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {
		annotation = annotation.typeAnnotation;
			}
			if (annotation.type === 'GenericTypeAnnotation' && typeScope(annotation.id.name)) {
		return typeScope(annotation.id.name);
			}
			return annotation;
	}
	function resolveSuperParameterPropsType(node) {
			var propsParameterPosition = void 0;
			try {
		propsParameterPosition = versionUtil.testFlowVersion(context, '0.53.0') ? 0 : 1;
			} catch (e) {
		propsParameterPosition = node.superTypeParameters.params.length <= 2 ? 0 : 1;
			}

			var annotation = node.superTypeParameters.params[propsParameterPosition];
			while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {
		annotation = annotation.typeAnnotation;
			}

			if (annotation.type === 'GenericTypeAnnotation' && typeScope(annotation.id.name)) {
		return typeScope(annotation.id.name);
			}
			return annotation;
	}
	function markDestructuredFunctionArgumentsAsUsed(node) {
			var destructuring = node.params && node.params[0] && node.params[0].type === 'ObjectPattern';
			if (destructuring && components.get(node)) {
		markPropTypesAsUsed(node);
			}
	}
	function markAnnotatedFunctionArgumentsAsDeclared(node) {
			if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {
		return;
			}
			markPropTypesAsDeclared(node, resolveTypeAnnotation(node.params[0]));
	}
	function handleStatelessComponent(node) {
			markDestructuredFunctionArgumentsAsUsed(node);
			markAnnotatedFunctionArgumentsAsDeclared(node);
	}
	return {
			ClassDeclaration: function ClassDeclaration(node) {
		if (isSuperTypeParameterPropsDeclaration(node)) {
					markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));
		}
			},

			ClassExpression: function ClassExpression(node) {
		classExpressions.push(node);
			},

			ClassProperty: function ClassProperty(node) {
		if (isAnnotatedClassPropsDeclaration(node)) {
					markPropTypesAsDeclared(node, resolveTypeAnnotation(node));
		} else if (isPropTypesDeclaration(node)) {
					markPropTypesAsDeclared(node, node.value);
		}
			},

			VariableDeclarator: function VariableDeclarator(node) {
		var destructuring = node.init && node.id && node.id.type === 'ObjectPattern';
		var thisDestructuring = destructuring && node.init.type === 'ThisExpression';
		var directDestructuring = destructuring && PROPS_REGEX.test(node.init.name) && (utils.getParentStatelessComponent() || inConstructor() || inComponentWillReceiveProps());

		if (!thisDestructuring && !directDestructuring) {
					return;
		}
		markPropTypesAsUsed(node);
			},

			FunctionDeclaration: handleStatelessComponent,

			ArrowFunctionExpression: handleStatelessComponent,

			FunctionExpression: function FunctionExpression(node) {
		if (node.parent.type === 'MethodDefinition') {
					return;
		}
		handleStatelessComponent(node);
			},

			MemberExpression: function MemberExpression(node) {
		var type = void 0;
		if (isPropTypesUsage(node)) {
					type = 'usage';
		} else if (isPropTypesDeclaration(node.property)) {
					type = 'declaration';
		}

		switch (type) {
					case 'usage':
			markPropTypesAsUsed(node);
			break;
					case 'declaration':
			var component = utils.getRelatedComponent(node);
			if (!component) {
							return;
			}
			markPropTypesAsDeclared(component.node, node.parent.right || node.parent);
			break;
					default:
			break;
		}
			},

			MethodDefinition: function MethodDefinition(node) {
		if (!node.static || node.kind !== 'get' || !isPropTypesDeclaration(node.key)) {
					return;
		}

		var i = node.value.body.body.length - 1;
		for (; i >= 0; i--) {
					if (node.value.body.body[i].type === 'ReturnStatement') {
			break;
					}
		}

		if (i >= 0) {
					markPropTypesAsDeclared(node, node.value.body.body[i].argument);
		}
			},

			ObjectExpression: function ObjectExpression(node) {
		node.properties.forEach(function (property) {
					if (!isPropTypesDeclaration(property.key)) {
			return;
					}
					markPropTypesAsDeclared(node, property.value);
		});
			},

			TypeAlias: function TypeAlias(node) {
		typeScope(node.id.name, node.right);
			},

			TypeParameterDeclaration: function TypeParameterDeclaration(node) {
		var identifier = node.params[0];

		if (identifier.typeAnnotation) {
					typeScope(identifier.name, identifier.typeAnnotation.typeAnnotation);
		}
			},

			Program: function Program() {
		stack = [{}];
			},

			BlockStatement: function BlockStatement() {
		stack.push(Object.create(typeScope()));
			},

			'BlockStatement:exit': function BlockStatementExit() {
		stack.pop();
			},

			'Program:exit': function ProgramExit() {
		classExpressions.forEach(function (node) {
					if (isSuperTypeParameterPropsDeclaration(node)) {
			markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));
					}
		});

		stack = null;
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || !mustBeValidated(list[component])) {
			continue;
					}
					reportUndeclaredPropTypes(list[component]);
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var variableUtil = __webpack_require__(27);
var pragmaUtil = __webpack_require__(71);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent missing React when using JSX',
			category: 'Possible Errors',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	var pragma = pragmaUtil.getFromContext(context);
	var NOT_DEFINED_MESSAGE = '\'{{name}}\' must be in scope when using JSX';

	return {

			JSXOpeningElement: function JSXOpeningElement(node) {
		var variables = variableUtil.variablesInScope(context);
		if (variableUtil.findVariable(variables, pragma)) {
					return;
		}
		context.report({
					node: node,
					message: NOT_DEFINED_MESSAGE,
					data: {
			name: pragma
					}
		});
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
var variableUtil = __webpack_require__(27);
var annotations = __webpack_require__(72);

var QUOTES_REGEX = /^["']|["']$/g;
module.exports = {
  meta: {
	docs: {
			description: 'Enforce a defaultProps definition for every prop that is not a required prop.',
			category: 'Best Practices'
	},

	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	var sourceCode = context.getSourceCode();
	var propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
	function getPropertyName(node) {
			if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {
		return node.key.name;
			} else if (node.type === 'MemberExpression') {
		return node.property.name;
			} else if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
			}
			return '';
	}
	function isPropTypesDeclaration(node) {
			return getPropertyName(node) === 'propTypes';
	}
	function isDefaultPropsDeclaration(node) {
			return getPropertyName(node) === 'defaultProps' || getPropertyName(node) === 'getDefaultProps';
	}
	function isRequiredPropType(propTypeExpression) {
			return propTypeExpression.type === 'MemberExpression' && propTypeExpression.property.name === 'isRequired';
	}
	function findVariableByName(name) {
			var variable = variableUtil.variablesInScope(context).find(function (item) {
		return item.name === name;
			});

			if (!variable || !variable.defs[0] || !variable.defs[0].node) {
		return null;
			}

			if (variable.defs[0].node.type === 'TypeAlias') {
		return variable.defs[0].node.right;
			}

			return variable.defs[0].node.init;
	}
	function resolveNodeValue(node) {
			if (node.type === 'Identifier') {
		return findVariableByName(node.name);
			}
			if (node.type === 'CallExpression' && propWrapperFunctions.has(node.callee.name) && node.arguments && node.arguments[0]) {
		return resolveNodeValue(node.arguments[0]);
			}

			return node;
	}
	function resolveGenericTypeAnnotation(node) {
			if (node.type !== 'GenericTypeAnnotation' || node.id.type !== 'Identifier') {
		return null;
			}

			return findVariableByName(node.id.name);
	}

	function resolveUnionTypeAnnotation(node) {
			return node.types.map(function (annotation) {
		if (annotation.type === 'GenericTypeAnnotation') {
					return resolveGenericTypeAnnotation(annotation);
		}

		return annotation;
			});
	}
	function getPropTypesFromObjectExpression(objectExpression) {
			var props = objectExpression.properties.filter(function (property) {
		return property.type !== 'ExperimentalSpreadProperty';
			});

			return props.map(function (property) {
		return {
					name: sourceCode.getText(property.key).replace(QUOTES_REGEX, ''),
					isRequired: isRequiredPropType(property.value),
					node: property
		};
			});
	}
	function getPropTypesFromTypeAnnotation(node) {
			var properties = void 0;

			switch (node.typeAnnotation.type) {
		case 'GenericTypeAnnotation':
					var annotation = resolveGenericTypeAnnotation(node.typeAnnotation);

					if (annotation && annotation.id) {
			annotation = findVariableByName(annotation.id.name);
					}

					properties = annotation ? annotation.properties || [] : [];
					break;

		case 'UnionTypeAnnotation':
					var union = resolveUnionTypeAnnotation(node.typeAnnotation);
					properties = union.reduce(function (acc, curr) {
			if (!curr) {
							return acc;
			}

			return acc.concat(curr.properties);
					}, []);
					break;

		case 'ObjectTypeAnnotation':
					properties = node.typeAnnotation.properties;
					break;

		default:
					properties = [];
					break;
			}

			var props = properties.filter(function (property) {
		return property.type === 'ObjectTypeProperty';
			});

			return props.map(function (property) {
		var tokens = context.getFirstTokens(property, 1);
		var name = tokens[0].value;

		return {
					name: name,
					isRequired: !property.optional,
					node: property
		};
			});
	}
	function getDefaultPropsFromObjectExpression(objectExpression) {
			var hasSpread = objectExpression.properties.find(function (property) {
		return property.type === 'ExperimentalSpreadProperty';
			});

			if (hasSpread) {
		return 'unresolved';
			}

			return objectExpression.properties.map(function (property) {
		return sourceCode.getText(property.key).replace(QUOTES_REGEX, '');
			});
	}
	function markDefaultPropsAsUnresolved(component) {
			components.set(component.node, {
		defaultProps: 'unresolved'
			});
	}
	function addPropTypesToComponent(component, propTypes) {
			var props = component.propTypes || [];

			components.set(component.node, {
		propTypes: props.concat(propTypes)
			});
	}
	function addDefaultPropsToComponent(component, defaultProps) {
			if (component.defaultProps === 'unresolved') {
		return;
			}

			if (defaultProps === 'unresolved') {
		markDefaultPropsAsUnresolved(component);
		return;
			}

			var defaults = component.defaultProps || {};

			defaultProps.forEach(function (defaultProp) {
		defaults[defaultProp] = true;
			});

			components.set(component.node, {
		defaultProps: defaults
			});
	}
	function handleStatelessComponent(node) {
			if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {
		return;
			}
			var component = components.get(utils.getParentStatelessComponent());
			if (!component) {
		return;
			}

			addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.params[0].typeAnnotation, context));
	}

	function handlePropTypeAnnotationClassProperty(node) {
			var component = components.get(utils.getParentES6Component());
			if (!component) {
		return;
			}

			addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.typeAnnotation, context));
	}

	function isPropTypeAnnotation(node) {
			return getPropertyName(node) === 'props' && !!node.typeAnnotation;
	}
	function reportPropTypesWithoutDefault(propTypes, defaultProps) {
			if (defaultProps === 'unresolved') {
		return;
			}

			propTypes.forEach(function (prop) {
		if (prop.isRequired) {
					return;
		}

		if (defaultProps[prop.name]) {
					return;
		}

		context.report(prop.node, 'propType "{{name}}" is not required, but has no corresponding defaultProp declaration.', { name: prop.name });
			});
	}
	return {
			MemberExpression: function MemberExpression(node) {
		var isPropType = isPropTypesDeclaration(node);
		var isDefaultProp = isDefaultPropsDeclaration(node);

		if (!isPropType && !isDefaultProp) {
					return;
		}
		var component = utils.getRelatedComponent(node);
		if (!component) {
					return;
		}
		//
		//
		if (node.parent.type === 'AssignmentExpression') {
					var expression = resolveNodeValue(node.parent.right);
					if (!expression || expression.type !== 'ObjectExpression') {
			if (isDefaultProp) {
							markDefaultPropsAsUnresolved(component);
			}

			return;
					}

					if (isPropType) {
			addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
					} else {
			addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
					}

					return;
		}
		if (node.parent.type === 'MemberExpression' && node.parent.parent.type === 'AssignmentExpression') {
					if (isPropType) {
			addPropTypesToComponent(component, [{
							name: node.parent.property.name,
							isRequired: isRequiredPropType(node.parent.parent.right),
							node: node.parent.parent
			}]);
					} else {
			addDefaultPropsToComponent(component, [node.parent.property.name]);
					}

					return;
		}
			},
			MethodDefinition: function MethodDefinition(node) {
		if (!node.static || node.kind !== 'get') {
					return;
		}

		var isPropType = isPropTypesDeclaration(node);
		var isDefaultProp = isDefaultPropsDeclaration(node);

		if (!isPropType && !isDefaultProp) {
					return;
		}
		var component = components.get(utils.getParentES6Component());
		if (!component) {
					return;
		}

		var returnStatement = utils.findReturnStatement(node);
		if (!returnStatement) {
					return;
		}

		var expression = resolveNodeValue(returnStatement.argument);
		if (!expression || expression.type !== 'ObjectExpression') {
					return;
		}

		if (isPropType) {
					addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
		} else {
					addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
		}
			},
			ClassProperty: function ClassProperty(node) {
		if (isPropTypeAnnotation(node)) {
					handlePropTypeAnnotationClassProperty(node);
					return;
		}

		if (!node.static) {
					return;
		}

		if (!node.value) {
					return;
		}

		var isPropType = getPropertyName(node) === 'propTypes';
		var isDefaultProp = getPropertyName(node) === 'defaultProps' || getPropertyName(node) === 'getDefaultProps';

		if (!isPropType && !isDefaultProp) {
					return;
		}
		var component = components.get(utils.getParentES6Component());
		if (!component) {
					return;
		}

		var expression = resolveNodeValue(node.value);
		if (!expression || expression.type !== 'ObjectExpression') {
					return;
		}

		if (isPropType) {
					addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
		} else {
					addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
		}
			},
			ObjectExpression: function ObjectExpression(node) {
		var component = utils.isES5Component(node) && components.get(node);
		if (!component) {
					return;
		}
		node.properties.forEach(function (property) {
					if (property.type === 'ExperimentalSpreadProperty') {
			return;
					}

					var isPropType = isPropTypesDeclaration(property);
					var isDefaultProp = isDefaultPropsDeclaration(property);

					if (!isPropType && !isDefaultProp) {
			return;
					}

					if (isPropType && property.value.type === 'ObjectExpression') {
			addPropTypesToComponent(component, getPropTypesFromObjectExpression(property.value));
			return;
					}

					if (isDefaultProp && property.value.type === 'FunctionExpression') {
			var returnStatement = utils.findReturnStatement(property);
			if (!returnStatement || returnStatement.argument.type !== 'ObjectExpression') {
							return;
			}

			addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(returnStatement.argument));
					}
		});
			},
			FunctionDeclaration: handleStatelessComponent,
			ArrowFunctionExpression: handleStatelessComponent,
			FunctionExpression: handleStatelessComponent,

			'Program:exit': function ProgramExit() {
		var list = components.list();

		for (var component in list) {
					if (!has(list, component)) {
			continue;
					}
					if (!list[component].propTypes) {
			continue;
					}

					reportPropTypesWithoutDefault(list[component].propTypes, list[component].defaultProps || {});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);

module.exports = {
  meta: {
	docs: {
			description: 'Enforce React components to have a shouldComponentUpdate method',
			category: 'Best Practices',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		allowDecorators: {
					type: 'array',
					items: {
			type: 'string'
					}
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var MISSING_MESSAGE = 'Component is not optimized. Please add a shouldComponentUpdate method.';
	var configuration = context.options[0] || {};
	var allowDecorators = configuration.allowDecorators || [];
	var hasPureRenderDecorator = function hasPureRenderDecorator(node) {
			if (node.decorators && node.decorators.length) {
		for (var i = 0, l = node.decorators.length; i < l; i++) {
					if (node.decorators[i].expression && node.decorators[i].expression.callee && node.decorators[i].expression.callee.object && node.decorators[i].expression.callee.object.name === 'reactMixin' && node.decorators[i].expression.callee.property && node.decorators[i].expression.callee.property.name === 'decorate' && node.decorators[i].expression.arguments && node.decorators[i].expression.arguments.length && node.decorators[i].expression.arguments[0].name === 'PureRenderMixin') {
			return true;
					}
		}
			}

			return false;
	};
	var hasCustomDecorator = function hasCustomDecorator(node) {
			var allowLength = allowDecorators.length;

			if (allowLength && node.decorators && node.decorators.length) {
		for (var i = 0; i < allowLength; i++) {
					for (var j = 0, l = node.decorators.length; j < l; j++) {
			if (node.decorators[j].expression && node.decorators[j].expression.name === allowDecorators[i]) {
							return true;
			}
					}
		}
			}

			return false;
	};
	var isSCUDeclarеd = function isSCUDeclarеd(node) {
			return Boolean(node && node.name === 'shouldComponentUpdate');
	};
	var isPureRenderDeclared = function isPureRenderDeclared(node) {
			var hasPR = false;
			if (node.value && node.value.elements) {
		for (var i = 0, l = node.value.elements.length; i < l; i++) {
					if (node.value.elements[i].name === 'PureRenderMixin') {
			hasPR = true;
			break;
					}
		}
			}

			return Boolean(node && node.key.name === 'mixins' && hasPR);
	};
	var markSCUAsDeclared = function markSCUAsDeclared(node) {
			components.set(node, {
		hasSCU: true
			});
	};
	var reportMissingOptimization = function reportMissingOptimization(component) {
			context.report({
		node: component.node,
		message: MISSING_MESSAGE,
		data: {
					component: component.name
		}
			});
	};
	var isFunctionInClass = function isFunctionInClass() {
			var blockNode = void 0;
			var scope = context.getScope();
			while (scope) {
		blockNode = scope.block;
		if (blockNode && blockNode.type === 'ClassDeclaration') {
					return true;
		}
		scope = scope.upper;
			}

			return false;
	};

	return {
			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
		markSCUAsDeclared(node);
			},

			ClassDeclaration: function ClassDeclaration(node) {
		if (!(hasPureRenderDecorator(node) || hasCustomDecorator(node) || utils.isPureComponent(node))) {
					return;
		}
		markSCUAsDeclared(node);
			},

			FunctionDeclaration: function FunctionDeclaration(node) {
		if (isFunctionInClass()) {
					return;
		}
		markSCUAsDeclared(node);
			},

			FunctionExpression: function FunctionExpression(node) {
		if (isFunctionInClass()) {
					return;
		}
		markSCUAsDeclared(node);
			},

			MethodDefinition: function MethodDefinition(node) {
		if (!isSCUDeclarеd(node.key)) {
					return;
		}
		markSCUAsDeclared(node);
			},

			ObjectExpression: function ObjectExpression(node) {
		for (var i = 0, l = node.properties.length; i < l; i++) {
					if (!node.properties[i].key || !isSCUDeclarеd(node.properties[i].key) && !isPureRenderDeclared(node.properties[i])) {
			continue;
					}
					markSCUAsDeclared(node);
		}
			},

			'Program:exit': function ProgramExit() {
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || list[component].hasSCU) {
			continue;
					}
					reportMissingOptimization(list[component]);
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce ES5 or ES6 class for returning value in render function',
			category: 'Possible Errors',
			recommended: true
	},
	schema: [{}]
  },

  create: Components.detect(function (context, components, utils) {
	function markReturnStatementPresent(node) {
			components.set(node, {
		hasReturnStatement: true
			});
	}
	function getComponentProperties(node) {
			switch (node.type) {
		case 'ClassDeclaration':
					return node.body.body;
		case 'ObjectExpression':
					return node.properties;
		default:
					return [];
			}
	}
	function getPropertyName(node) {
			if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
			} else if (['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {
		return node.key.name;
			}
			return '';
	}
	function hasRenderMethod(node) {
			var properties = getComponentProperties(node);
			for (var i = 0, j = properties.length; i < j; i++) {
		if (getPropertyName(properties[i]) !== 'render' || !properties[i].value) {
					continue;
		}
		return (/FunctionExpression$/.test(properties[i].value.type)
		);
			}
			return false;
	}

	return {
			ReturnStatement: function ReturnStatement(node) {
		var ancestors = context.getAncestors(node).reverse();
		var depth = 0;
		for (var i = 0, j = ancestors.length; i < j; i++) {
					if (/Function(Expression|Declaration)$/.test(ancestors[i].type)) {
			depth++;
					}
					if (!/(MethodDefinition|(Class)?Property)$/.test(ancestors[i].type) || getPropertyName(ancestors[i]) !== 'render' || depth > 1) {
			continue;
					}
					markReturnStatementPresent(node);
		}
			},

			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
		if (node.expression === false || getPropertyName(node.parent) !== 'render') {
					return;
		}
		markReturnStatementPresent(node);
			},

			'Program:exit': function ProgramExit() {
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || !hasRenderMethod(list[component].node) || list[component].hasReturnStatement || !utils.isES5Component(list[component].node) && !utils.isES6Component(list[component].node)) {
			continue;
					}
					context.report({
			node: list[component].node,
			message: 'Your render method should have return statement'
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Prevent extra closing tags for components without children',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			type: 'object',
			properties: {
		component: {
					default: true,
					type: 'boolean'
		},
		html: {
					default: true,
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var tagConvention = /^[a-z]|\-/;
	function isTagName(name) {
			return tagConvention.test(name);
	}

	function isComponent(node) {
			return node.name && node.name.type === 'JSXIdentifier' && !isTagName(node.name.name);
	}

	function hasChildren(node) {
			var childrens = node.parent.children;
			if (!childrens.length || childrens.length === 1 && childrens[0].type === 'Literal' && !childrens[0].value.replace(/(?!\xA0)\s/g, '')) {
		return false;
			}
			return true;
	}

	function isShouldBeSelfClosed(node) {
			var configuration = context.options[0] || { component: true, html: true };
			return (configuration.component && isComponent(node) || configuration.html && isTagName(node.name.name)) && !node.selfClosing && !hasChildren(node);
	}
	return {

			JSXOpeningElement: function JSXOpeningElement(node) {
		if (!isShouldBeSelfClosed(node)) {
					return;
		}
		context.report({
					node: node,
					message: 'Empty components are self-closing',
					fix: function fix(fixer) {
			var openingElementEnding = node.end - 1;
			var closingElementEnding = node.parent.closingElement.end;
			var range = [openingElementEnding, closingElementEnding];
			return fixer.replaceTextRange(range, ' />');
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var util = __webpack_require__(108);

var Components = __webpack_require__(8);
function getMethodsOrder(defaultConfig, userConfig) {
  userConfig = userConfig || {};

  var groups = util._extend(defaultConfig.groups, userConfig.groups);
  var order = userConfig.order || defaultConfig.order;

  var config = [];
  var entry = void 0;
  for (var i = 0, j = order.length; i < j; i++) {
	entry = order[i];
	if (has(groups, entry)) {
			config = config.concat(groups[entry]);
	} else {
			config.push(entry);
	}
  }

  return config;
}
module.exports = {
  meta: {
	docs: {
			description: 'Enforce component methods order',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		order: {
					type: 'array',
					items: {
			type: 'string'
					}
		},
		groups: {
					type: 'object',
					patternProperties: {
			'^.*$': {
							type: 'array',
							items: {
				type: 'string'
							}
			}
					}
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components) {
	var errors = {};

	var MISPOSITION_MESSAGE = '{{propA}} should be placed {{position}} {{propB}}';

	var methodsOrder = getMethodsOrder({
			order: ['static-methods', 'lifecycle', 'everything-else', 'render'],
			groups: {
		lifecycle: ['displayName', 'propTypes', 'contextTypes', 'childContextTypes', 'mixins', 'statics', 'defaultProps', 'constructor', 'getDefaultProps', 'state', 'getInitialState', 'getChildContext', 'componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate', 'componentWillUnmount']
			}
	}, context.options[0]);
	var regExpRegExp = /\/(.*)\/([g|y|i|m]*)/;
	function getRefPropIndexes(method) {
			var isRegExp = void 0;
			var matching = void 0;
			var i = void 0;
			var j = void 0;
			var indexes = [];

			if (method.static) {
		var staticIndex = methodsOrder.indexOf('static-methods');
		if (staticIndex >= 0) {
					indexes.push(staticIndex);
		}
			}

			if (method.getter) {
		var getterIndex = methodsOrder.indexOf('getters');
		if (getterIndex >= 0) {
					indexes.push(getterIndex);
		}
			}

			if (method.setter) {
		var setterIndex = methodsOrder.indexOf('setters');
		if (setterIndex >= 0) {
					indexes.push(setterIndex);
		}
			}

			if (method.typeAnnotation) {
		var annotationIndex = methodsOrder.indexOf('type-annotations');
		if (annotationIndex >= 0) {
					indexes.push(annotationIndex);
		}
			}
			if (indexes.length === 0) {
		for (i = 0, j = methodsOrder.length; i < j; i++) {
					isRegExp = methodsOrder[i].match(regExpRegExp);
					if (isRegExp) {
			matching = new RegExp(isRegExp[1], isRegExp[2]).test(method.name);
					} else {
			matching = methodsOrder[i] === method.name;
					}
					if (matching) {
			indexes.push(i);
					}
		}
			}
			if (indexes.length === 0) {
		for (i = 0, j = methodsOrder.length; i < j; i++) {
					if (methodsOrder[i] === 'everything-else') {
			indexes.push(i);
			break;
					}
		}
			}
			if (indexes.length === 0) {
		indexes.push(Infinity);
			}

			return indexes;
	}
	function getPropertyName(node) {
			if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
			}

			if (node.kind === 'get') {
		return 'getter functions';
			}

			if (node.kind === 'set') {
		return 'setter functions';
			}

			return node.key.name;
	}
	function storeError(propA, propB) {
			if (!errors[propA.index]) {
		errors[propA.index] = {
					node: propA.node,
					score: 0,
					closest: {
			distance: Infinity,
			ref: {
							node: null,
							index: 0
			}
					}
		};
			}
			errors[propA.index].score++;
			if (getPropertyName(errors[propA.index].node) !== getPropertyName(propA.node)) {
		return;
			}
			if (Math.abs(propA.index - propB.index) > errors[propA.index].closest.distance) {
		return;
			}
			errors[propA.index].closest.distance = Math.abs(propA.index - propB.index);
			errors[propA.index].closest.ref.node = propB.node;
			errors[propA.index].closest.ref.index = propB.index;
	}
	function dedupeErrors() {
			for (var i in errors) {
		if (!has(errors, i)) {
					continue;
		}
		var index = errors[i].closest.ref.index;
		if (!errors[index]) {
					continue;
		}
		if (errors[i].score > errors[index].score) {
					delete errors[index];
		} else {
					delete errors[i];
		}
			}
	}
	function reportErrors() {
			dedupeErrors();

			var nodeA = void 0;
			var nodeB = void 0;
			var indexA = void 0;
			var indexB = void 0;
			for (var i in errors) {
		if (!has(errors, i)) {
					continue;
		}

		nodeA = errors[i].node;
		nodeB = errors[i].closest.ref.node;
		indexA = i;
		indexB = errors[i].closest.ref.index;

		context.report({
					node: nodeA,
					message: MISPOSITION_MESSAGE,
					data: {
			propA: getPropertyName(nodeA),
			propB: getPropertyName(nodeB),
			position: indexA < indexB ? 'before' : 'after'
					}
		});
			}
	}
	function getComponentProperties(node) {
			switch (node.type) {
		case 'ClassExpression':
		case 'ClassDeclaration':
					return node.body.body;
		case 'ObjectExpression':
					return node.properties.filter(function (property) {
			return property.type === 'Property';
					});
		default:
					return [];
			}
	}
	function comparePropsOrder(propertiesInfos, propA, propB) {
			var i = void 0;
			var j = void 0;
			var k = void 0;
			var l = void 0;
			var refIndexA = void 0;
			var refIndexB = void 0;
			var refIndexesA = getRefPropIndexes(propA);
			var refIndexesB = getRefPropIndexes(propB);
			var classIndexA = propertiesInfos.indexOf(propA);
			var classIndexB = propertiesInfos.indexOf(propB);
			for (i = 0, j = refIndexesA.length; i < j; i++) {
		refIndexA = refIndexesA[i];
		for (k = 0, l = refIndexesB.length; k < l; k++) {
					refIndexB = refIndexesB[k];

					if (
					refIndexA === refIndexB ||
					refIndexA < refIndexB && classIndexA < classIndexB ||
					refIndexA > refIndexB && classIndexA > classIndexB) {
			return {
							correct: true,
							indexA: classIndexA,
							indexB: classIndexB
			};
					}
		}
			}
			return {
		correct: false,
		indexA: refIndexA,
		indexB: refIndexB
			};
	}
	function checkPropsOrder(properties) {
			var propertiesInfos = properties.map(function (node) {
		return {
					name: getPropertyName(node),
					getter: node.kind === 'get',
					setter: node.kind === 'set',
					static: node.static,
					typeAnnotation: !!node.typeAnnotation && node.value === null
		};
			});

			var i = void 0;
			var j = void 0;
			var k = void 0;
			var l = void 0;
			var propA = void 0;
			var propB = void 0;
			var order = void 0;
			for (i = 0, j = propertiesInfos.length; i < j; i++) {
		propA = propertiesInfos[i];
		for (k = 0, l = propertiesInfos.length; k < l; k++) {
					propB = propertiesInfos[k];
					order = comparePropsOrder(propertiesInfos, propA, propB);
					if (order.correct === true) {
			continue;
					}
					storeError({
			node: properties[i],
			index: order.indexA
					}, {
			node: properties[k],
			index: order.indexB
					});
		}
			}
	}

	return {
			'Program:exit': function ProgramExit() {
		var list = components.list();
		for (var component in list) {
					if (!has(list, component)) {
			continue;
					}
					var properties = getComponentProperties(list[component].node);
					checkPropsOrder(properties);
		}

		reportErrors();
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var variableUtil = __webpack_require__(27);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce propTypes declarations alphabetical sorting',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		requiredFirst: {
					type: 'boolean'
		},
		callbacksLast: {
					type: 'boolean'
		},
		ignoreCase: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();
	var configuration = context.options[0] || {};
	var requiredFirst = configuration.requiredFirst || false;
	var callbacksLast = configuration.callbacksLast || false;
	var ignoreCase = configuration.ignoreCase || false;
	var propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
	function isPropTypesDeclaration(node) {
			if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[0] && tokens[0].value === 'propTypes' || tokens[1] && tokens[1].value === 'propTypes';
			}

			return Boolean(node && node.name === 'propTypes');
	}

	function getKey(node) {
			return sourceCode.getText(node.key || node.argument);
	}

	function getValueName(node) {
			return node.type === 'Property' && node.value.property && node.value.property.name;
	}

	function isCallbackPropName(propName) {
			return (/^on[A-Z]/.test(propName)
			);
	}

	function isRequiredProp(node) {
			return getValueName(node) === 'isRequired';
	}
	function findVariableByName(name) {
			var variable = variableUtil.variablesInScope(context).find(function (item) {
		return item.name === name;
			});

			if (!variable || !variable.defs[0] || !variable.defs[0].node) {
		return null;
			}

			if (variable.defs[0].node.type === 'TypeAlias') {
		return variable.defs[0].node.right;
			}

			return variable.defs[0].node.init;
	}
	function checkSorted(declarations) {
			declarations.reduce(function (prev, curr, idx, decls) {
		if (/SpreadProperty$/.test(curr.type)) {
					return decls[idx + 1];
		}

		var prevPropName = getKey(prev);
		var currentPropName = getKey(curr);
		var previousIsRequired = isRequiredProp(prev);
		var currentIsRequired = isRequiredProp(curr);
		var previousIsCallback = isCallbackPropName(prevPropName);
		var currentIsCallback = isCallbackPropName(currentPropName);

		if (ignoreCase) {
					prevPropName = prevPropName.toLowerCase();
					currentPropName = currentPropName.toLowerCase();
		}

		if (requiredFirst) {
					if (previousIsRequired && !currentIsRequired) {
			return curr;
					}
					if (!previousIsRequired && currentIsRequired) {
			context.report({
							node: curr,
							message: 'Required prop types must be listed before all other prop types'
			});
			return curr;
					}
		}

		if (callbacksLast) {
					if (!previousIsCallback && currentIsCallback) {
			return curr;
					}
					if (previousIsCallback && !currentIsCallback) {
			context.report({
							node: prev,
							message: 'Callback prop types must be listed after all other prop types'
			});
			return prev;
					}
		}

		if (currentPropName < prevPropName) {
					context.report({
			node: curr,
			message: 'Prop types declarations should be sorted alphabetically'
					});
					return prev;
		}

		return curr;
			}, declarations[0]);
	}

	function checkNode(node) {
			switch (node && node.type) {
		case 'ObjectExpression':
					checkSorted(node.properties);
					break;
		case 'Identifier':
					var propTypesObject = findVariableByName(node.name);
					if (propTypesObject && propTypesObject.properties) {
			checkSorted(propTypesObject.properties);
					}
					break;
		case 'CallExpression':
					var innerNode = node.arguments && node.arguments[0];
					if (propWrapperFunctions.has(node.callee.name) && innerNode) {
			checkNode(innerNode);
					}
					break;
		default:
					break;
			}
	}

	return {
			ClassProperty: function ClassProperty(node) {
		if (!isPropTypesDeclaration(node)) {
					return;
		}
		checkNode(node.value);
			},

			MemberExpression: function MemberExpression(node) {
		if (!isPropTypesDeclaration(node.property)) {
					return;
		}

		checkNode(node.parent.right);
			},

			ObjectExpression: function ObjectExpression(node) {
		node.properties.forEach(function (property) {
					if (!property.key) {
			return;
					}

					if (!isPropTypesDeclaration(property.key)) {
			return;
					}
					if (property.value.type === 'ObjectExpression') {
			checkSorted(property.value.properties);
					}
		});
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var variableUtil = __webpack_require__(27);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce style prop value is an object',
			category: '',
			recommended: false
	},
	schema: []
  },

  create: function create(context) {
	function isNonNullaryLiteral(expression) {
			return expression.type === 'Literal' && expression.value !== null;
	}
	function checkIdentifiers(node) {
			var variable = variableUtil.variablesInScope(context).find(function (item) {
		return item.name === node.name;
			});

			if (!variable || !variable.defs[0] || !variable.defs[0].node.init) {
		return;
			}

			if (isNonNullaryLiteral(variable.defs[0].node.init)) {
		context.report(node, 'Style prop value must be an object');
			}
	}

	return {
			CallExpression: function CallExpression(node) {
		if (node.callee && node.callee.type === 'MemberExpression' && node.callee.property.name === 'createElement' && node.arguments.length > 1) {
					if (node.arguments[1].type === 'ObjectExpression') {
			var style = node.arguments[1].properties.find(function (property) {
							return property.key && property.key.name === 'style' && !property.computed;
			});
			if (style) {
							if (style.value.type === 'Identifier') {
				checkIdentifiers(style.value);
							} else if (isNonNullaryLiteral(style.value)) {
				context.report(style.value, 'Style prop value must be an object');
							}
			}
					}
		}
			},

			JSXAttribute: function JSXAttribute(node) {
		if (!node.value || node.name.name !== 'style') {
					return;
		}

		if (node.value.type !== 'JSXExpressionContainer' || isNonNullaryLiteral(node.value.expression)) {
					context.report(node, 'Style prop value must be an object');
		} else if (node.value.expression.type === 'Identifier') {
					checkIdentifiers(node.value.expression);
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);

var Components = __webpack_require__(8);
var VOID_DOM_ELEMENTS = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  menuitem: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

function isVoidDOMElement(elementName) {
  return has(VOID_DOM_ELEMENTS, elementName);
}

function errorMessage(elementName) {
  return 'Void DOM element <' + elementName + ' /> cannot receive children.';
}
module.exports = {
  meta: {
	docs: {
			description: 'Prevent passing of children to void DOM elements (e.g. <br />).',
			category: 'Best Practices',
			recommended: false
	},
	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	return {
			JSXElement: function JSXElement(node) {
		var elementName = node.openingElement.name.name;

		if (!isVoidDOMElement(elementName)) {
					return;
		}

		if (node.children.length > 0) {
					context.report({
			node: node,
			message: errorMessage(elementName)
					});
		}

		var attributes = node.openingElement.attributes;

		var hasChildrenAttributeOrDanger = attributes.some(function (attribute) {
					if (!attribute.name) {
			return false;
					}

					return attribute.name.name === 'children' || attribute.name.name === 'dangerouslySetInnerHTML';
		});

		if (hasChildrenAttributeOrDanger) {
					context.report({
			node: node,
			message: errorMessage(elementName)
					});
		}
			},

			CallExpression: function CallExpression(node) {
		if (node.callee.type !== 'MemberExpression' && node.callee.type !== 'Identifier') {
					return;
		}

		if (!utils.isReactCreateElement(node)) {
					return;
		}

		var args = node.arguments;

		if (args.length < 1) {
					return;
		}

		var elementName = args[0].value;

		if (!isVoidDOMElement(elementName)) {
					return;
		}

		if (args.length < 2 || args[1].type !== 'ObjectExpression') {
					return;
		}

		var firstChild = args[2];
		if (firstChild) {
					context.report({
			node: node,
			message: errorMessage(elementName)
					});
		}

		var props = args[1].properties;

		var hasChildrenPropOrDanger = props.some(function (prop) {
					if (!prop.key) {
			return false;
					}

					return prop.key.name === 'children' || prop.key.name === 'dangerouslySetInnerHTML';
		});

		if (hasChildrenPropOrDanger) {
					context.report({
			node: node,
			message: errorMessage(elementName)
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports) {

module.exports = {"rules":{"generator-star":["generator-star-spacing"],"global-strict":["strict"],"no-arrow-condition":["no-confusing-arrow","no-constant-condition"],"no-comma-dangle":["comma-dangle"],"no-empty-class":["no-empty-character-class"],"no-empty-label":["no-labels"],"no-extra-strict":["strict"],"no-reserved-keys":["quote-props"],"no-space-before-semi":["semi-spacing"],"no-wrap-func":["no-extra-parens"],"space-after-function-name":["space-before-function-paren"],"space-after-keywords":["keyword-spacing"],"space-before-function-parentheses":["space-before-function-paren"],"space-before-keywords":["keyword-spacing"],"space-in-brackets":["object-curly-spacing","array-bracket-spacing","computed-property-spacing"],"space-return-throw-case":["keyword-spacing"],"space-unary-word-ops":["space-unary-ops"],"spaced-line-comment":["spaced-comment"]}}
 }),
 (function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 753;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {/**
 * @fileoverview Tracks performance of individual rules.
 * @author Brandon Mills
 */

function alignLeft(str, len, ch) {
	return str + new Array(len - str.length + 1).join(ch || " ");
}
function alignRight(str, len, ch) {
	return new Array(len - str.length + 1).join(ch || " ") + str;
}
var enabled = !!process.env.TIMING;

var HEADERS = ["Rule", "Time (ms)", "Relative"];
var ALIGN = [alignLeft, alignRight, alignRight];
function display(data) {
	var total = 0;
	var rows = Object.keys(data).map(function (key) {
		var time = data[key];

		total += time;
		return [key, time];
	}).sort(function (a, b) {
		return b[1] - a[1];
	}).slice(0, 10);

	rows.forEach(function (row) {
		row.push((row[1] * 100 / total).toFixed(1) + "%");
		row[1] = row[1].toFixed(3);
	});

	rows.unshift(HEADERS);

	var widths = [];

	rows.forEach(function (row) {
		var len = row.length;

		for (var i = 0; i < len; i++) {
			var n = row[i].length;

			if (!widths[i] || n > widths[i]) {
				widths[i] = n;
			}
		}
	});

	var table = rows.map(function (row) {
		return row.map(function (cell, index) {
			return ALIGN[index](cell, widths[index]);
		}).join(" | ");
	});

	table.splice(1, 0, widths.map(function (w, index) {
		if (index !== 0 && index !== widths.length - 1) {
			w++;
		}

		return ALIGN[index](":", w + 1, "-");
	}).join("|"));

	console.log(table.join("\n")); // eslint-disable-line no-console
}
module.exports = function () {

	var data = Object.create(null);
	function time(key, fn) {
		if (typeof data[key] === "undefined") {
			data[key] = 0;
		}

		return function () {
			var t = process.hrtime();

			fn.apply(null, Array.prototype.slice.call(arguments));
			t = process.hrtime(t);
			data[key] += t[0] * 1e3 + t[1] / 1e6;
		};
	}

	if (enabled) {
		process.on("exit", function () {
			display(data);
		});
	}

	return {
		time: time,
		enabled: enabled
	};
}();
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports) {

module.exports = {"_from":"eslint@^4.12.0","_id":"eslint@4.13.1","_inBundle":false,"_integrity":"sha512-UCJVV50RtLHYzBp1DZ8CMPtRSg4iVZvjgO9IJHIKyWU/AnJVjtdRikoUPLB29n5pzMB7TnsLQWf0V6VUJfoPfw==","_location":"/eslint","_phantomChildren":{"color-convert":"1.9.1","escape-string-regexp":"1.0.5","has-flag":"2.0.0","ms":"2.0.0"},"_requested":{"type":"range","registry":true,"raw":"eslint@^4.12.0","name":"eslint","escapedName":"eslint","rawSpec":"^4.12.0","saveSpec":null,"fetchSpec":"^4.12.0"},"_requiredBy":["/"],"_resolved":"https://registry.npmjs.org/eslint/-/eslint-4.13.1.tgz","_shasum":"0055e0014464c7eb7878caf549ef2941992b444f","_spec":"eslint@^4.12.0","_where":"J:\\Chromium\\newclient\\plugins\\c9.ide.language.javascript.eslint\\packager","author":{"name":"Nicholas C. Zakas","email":"nicholas+npm@nczconsulting.com"},"bin":{"eslint":"./bin/eslint.js"},"bugs":{"url":"https://github.com/eslint/eslint/issues/"},"bundleDependencies":false,"dependencies":{"ajv":"^5.3.0","babel-code-frame":"^6.22.0","chalk":"^2.1.0","concat-stream":"^1.6.0","cross-spawn":"^5.1.0","debug":"^3.0.1","doctrine":"^2.0.2","eslint-scope":"^3.7.1","espree":"^3.5.2","esquery":"^1.0.0","estraverse":"^4.2.0","esutils":"^2.0.2","file-entry-cache":"^2.0.0","functional-red-black-tree":"^1.0.1","glob":"^7.1.2","globals":"^11.0.1","ignore":"^3.3.3","imurmurhash":"^0.1.4","inquirer":"^3.0.6","is-resolvable":"^1.0.0","js-yaml":"^3.9.1","json-stable-stringify-without-jsonify":"^1.0.1","levn":"^0.3.0","lodash":"^4.17.4","minimatch":"^3.0.2","mkdirp":"^0.5.1","natural-compare":"^1.4.0","optionator":"^0.8.2","path-is-inside":"^1.0.2","pluralize":"^7.0.0","progress":"^2.0.0","require-uncached":"^1.0.3","semver":"^5.3.0","strip-ansi":"^4.0.0","strip-json-comments":"~2.0.1","table":"^4.0.1","text-table":"~0.2.0"},"deprecated":false,"description":"An AST-based pattern checker for JavaScript.","devDependencies":{"babel-polyfill":"^6.23.0","babel-preset-es2015":"^6.24.1","babelify":"^7.3.0","beefy":"^2.1.8","brfs":"1.4.3","browserify":"^14.4.0","chai":"^4.0.1","cheerio":"^0.22.0","coveralls":"^2.13.1","dateformat":"^2.0.0","ejs":"^2.5.6","eslint-plugin-eslint-plugin":"^1.2.0","eslint-plugin-node":"^5.1.0","eslint-plugin-rulesdir":"^0.1.0","eslint-release":"^0.10.1","eslint-rule-composer":"^0.1.0","eslump":"1.6.0","esprima":"^4.0.0","esprima-fb":"^15001.1001.0-dev-harmony-fb","istanbul":"^0.4.5","jsdoc":"^3.4.3","karma":"^1.7.0","karma-babel-preprocessor":"^6.0.1","karma-mocha":"^1.3.0","karma-mocha-reporter":"^2.2.3","karma-phantomjs-launcher":"^1.0.4","leche":"^2.1.2","load-perf":"^0.2.0","markdownlint":"^0.6.1","mocha":"^3.4.2","mock-fs":"^4.3.0","npm-license":"^0.3.3","phantomjs-prebuilt":"^2.1.14","proxyquire":"^1.8.0","shelljs":"^0.7.7","sinon":"^3.2.1","temp":"^0.8.3","through":"^2.3.8"},"engines":{"node":">=4"},"files":["LICENSE","README.md","bin","conf","lib","messages"],"homepage":"https://eslint.org","keywords":["ast","lint","javascript","ecmascript","espree"],"license":"MIT","main":"./lib/api.js","name":"eslint","repository":{"type":"git","url":"git+https://github.com/eslint/eslint.git"},"scripts":{"alpharelease":"node Makefile.js prerelease -- alpha","betarelease":"node Makefile.js prerelease -- beta","browserify":"node Makefile.js browserify","ci-release":"node Makefile.js ciRelease","coveralls":"cat ./coverage/lcov.info | coveralls","docs":"node Makefile.js docs","fuzz":"node Makefile.js fuzz","gensite":"node Makefile.js gensite","lint":"node Makefile.js lint","perf":"node Makefile.js perf","profile":"beefy tests/bench/bench.js --open -- -t brfs -t ./tests/bench/xform-rules.js -r espree","release":"node Makefile.js release","test":"node Makefile.js test"},"version":"4.13.1"}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var debug = __webpack_require__(67)("eslint:text-fixer");
var BOM = "\uFEFF";
function compareMessagesByFixRange(a, b) {
	return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];
}
function compareMessagesByLocation(a, b) {
	return a.line - b.line || a.column - b.column;
}
function SourceCodeFixer() {
	Object.freeze(this);
}
SourceCodeFixer.applyFixes = function (sourceText, messages, shouldFix) {
	debug("Applying fixes");

	if (shouldFix === false) {
		debug("shouldFix parameter was false, not attempting fixes");
		return {
			fixed: false,
			messages: messages,
			output: sourceText
		};
	}
	var remainingMessages = [],
		fixes = [],
		bom = sourceText.startsWith(BOM) ? BOM : "",
		text = bom ? sourceText.slice(1) : sourceText;
	var lastPos = Number.NEGATIVE_INFINITY,
		output = bom;
	function attemptFix(problem) {
		var fix = problem.fix;
		var start = fix.range[0];
		var end = fix.range[1];
		if (lastPos >= start || start > end) {
			remainingMessages.push(problem);
			return false;
		}
		if (start < 0 && end >= 0 || start === 0 && fix.text.startsWith(BOM)) {
			output = "";
		}
		output += text.slice(Math.max(0, lastPos), Math.max(0, start));
		output += fix.text;
		lastPos = end;
		return true;
	}

	messages.forEach(function (problem) {
		if (problem.hasOwnProperty("fix")) {
			fixes.push(problem);
		} else {
			remainingMessages.push(problem);
		}
	});

	if (fixes.length) {
		debug("Found fixes to apply");
		var fixesWereApplied = false;

		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = fixes.sort(compareMessagesByFixRange)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var problem = _step.value;

				if (typeof shouldFix !== "function" || shouldFix(problem)) {
					attemptFix(problem);
					fixesWereApplied = true;
				} else {
					remainingMessages.push(problem);
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		output += text.slice(Math.max(0, lastPos));

		return {
			fixed: fixesWereApplied,
			messages: remainingMessages.sort(compareMessagesByLocation),
			output: output
		};
	}

	debug("No fixes to apply");
	return {
		fixed: false,
		messages: messages,
		output: bom + text
	};
};

module.exports = SourceCodeFixer;
 })
 ])});;

define("plugins/c9.ide.language.javascript.eslint/worker/js-yaml",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.jsyaml=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';


var loader = require('./js-yaml/loader');
var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = require('./js-yaml/type');
module.exports.Schema              = require('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require('./js-yaml/exception');
module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/dumper":3,"./js-yaml/exception":4,"./js-yaml/loader":5,"./js-yaml/schema":7,"./js-yaml/schema/core":8,"./js-yaml/schema/default_full":9,"./js-yaml/schema/default_safe":10,"./js-yaml/schema/failsafe":11,"./js-yaml/schema/json":12,"./js-yaml/type":13}],2:[function(require,module,exports){
'use strict';


function isNothing(subject) {
  return (undefined === subject) || (null === subject);
}


function isObject(subject) {
  return ('object' === typeof subject) && (null !== subject);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) {
    return sequence;
  } else if (isNothing(sequence)) {
    return [];
  } else {
    return [ sequence ];
  }
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],3:[function(require,module,exports){
'use strict';


var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');


var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */


var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';


var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];


function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (null === map) {
    return {};
  }

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if ('!!' === tag.slice(0, 2)) {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap[tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}


function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


function State(options) {
  this.schema      = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent      = Math.max(1, (options['indent'] || 2));
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}


function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

function writeScalar(state, object) {
  var isQuoted, checkpoint, position, length, character, first;

  state.dump = '';
  isQuoted = false;
  checkpoint = 0;
  first = object.charCodeAt(0) || 0;

  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
    isQuoted = true;
  } else if (0 === object.length) {
    isQuoted = true;
  } else if (CHAR_SPACE    === first ||
             CHAR_SPACE    === object.charCodeAt(object.length - 1)) {
    isQuoted = true;
  } else if (CHAR_MINUS    === first ||
             CHAR_QUESTION === first) {
    isQuoted = true;
  }

  for (position = 0, length = object.length; position < length; position += 1) {
    character = object.charCodeAt(position);

    if (!isQuoted) {
      if (CHAR_TAB                  === character ||
          CHAR_LINE_FEED            === character ||
          CHAR_CARRIAGE_RETURN      === character ||
          CHAR_COMMA                === character ||
          CHAR_LEFT_SQUARE_BRACKET  === character ||
          CHAR_RIGHT_SQUARE_BRACKET === character ||
          CHAR_LEFT_CURLY_BRACKET   === character ||
          CHAR_RIGHT_CURLY_BRACKET  === character ||
          CHAR_SHARP                === character ||
          CHAR_AMPERSAND            === character ||
          CHAR_ASTERISK             === character ||
          CHAR_EXCLAMATION          === character ||
          CHAR_VERTICAL_LINE        === character ||
          CHAR_GREATER_THAN         === character ||
          CHAR_SINGLE_QUOTE         === character ||
          CHAR_DOUBLE_QUOTE         === character ||
          CHAR_PERCENT              === character ||
          CHAR_COMMERCIAL_AT        === character ||
          CHAR_COLON                === character ||
          CHAR_GRAVE_ACCENT         === character) {
        isQuoted = true;
      }
    }

    if (ESCAPE_SEQUENCES[character] ||
        !((0x00020 <= character && character <= 0x00007E) ||
          (0x00085 === character)                         ||
          (0x000A0 <= character && character <= 0x00D7FF) ||
          (0x0E000 <= character && character <= 0x00FFFD) ||
          (0x10000 <= character && character <= 0x10FFFF))) {
      state.dump += object.slice(checkpoint, position);
      state.dump += ESCAPE_SEQUENCES[character] || encodeHex(character);
      checkpoint = position + 1;
      isQuoted = true;
    }
  }

  if (checkpoint < position) {
    state.dump += object.slice(checkpoint, position);
  }

  if (!isQuoted && testImplicitResolving(state, state.dump)) {
    isQuoted = true;
  }

  if (isQuoted) {
    state.dump = '"' + state.dump + '"';
  }
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    if (writeNode(state, level, object[index], false, false)) {
      if (0 !== index) {
        _result += ', ';
      }
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || 0 !== index) {
        _result += generateNextLine(state, level);
      }
      _result += '- ' + state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (0 !== index) {
      pairBuffer += ', ';
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) {
      pairBuffer += '? ';
    }

    pairBuffer += state.dump + ': ';

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || 0 !== index) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (null !== state.tag && '?' !== state.tag) ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if ('[object Function]' === _toString.call(type.represent)) {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}
//
function writeNode(state, level, object, block, compact) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (0 > state.flowLevel || state.flowLevel > level);
  }

  if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {
    compact = false;
  }

  var objectOrArray = '[object Object]' === type || '[object Array]' === type,
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if ('[object Object]' === type) {
      if (block && (0 !== Object.keys(state.dump).length)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object Array]' === type) {
      if (block && (0 !== state.dump.length)) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object String]' === type) {
      if ('?' !== state.tag) {
        writeScalar(state, state.dump);
      }
    } else if (state.skipInvalid) {
      return false;
    } else {
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (null !== state.tag && '?' !== state.tag) {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var type = _toString.call(object),
      objectKeyList,
      index,
      length;

  if (null !== object && 'object' === typeof object) {
    index = objects.indexOf(object);
    if (-1 !== index) {
      if (-1 === duplicatesIndexes.indexOf(index)) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
    
      if(Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) {
    return state.dump + '\n';
  } else {
    return '';
  }
}


function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{"./common":2,"./exception":4,"./schema/default_full":9,"./schema/default_safe":10}],4:[function(require,module,exports){
'use strict';


function YAMLException(reason, mark) {
  this.name    = 'YAMLException';
  this.reason  = reason;
  this.mark    = mark;
  this.message = this.toString(false);
}


YAMLException.prototype.toString = function toString(compact) {
  var result;

  result = 'JS-YAML: ' + (this.reason || '(unknown reason)');

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],5:[function(require,module,exports){
'use strict';


var common              = require('./common');
var YAMLException       = require('./exception');
var Mark                = require('./mark');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uD800-\uDFFF\uFFFE\uFFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return 0x2C/* , */ === c ||
         0x5B/* [ */ === c ||
         0x5D/* ] */ === c ||
         0x7B/* { */ === c ||
         0x7D/* } */ === c;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  lc = c | 0x20;
  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
 return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  var error = generateError(state, message);

  if (state.onWarning) {
    state.onWarning.call(null, error);
  } else {
    throw error;
  }
}


var directiveHandlers = {

  'YAML': function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (null !== state.version) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (1 !== args.length) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (null === match) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (1 !== major) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (1 !== minor && 2 !== minor) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

  'TAG': function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (2 !== args.length) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      state.tagMap[handle] = prefix;
    }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length;
           _position < _length;
           _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(0x09 === _character ||
              0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
    }
  }
}

function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
  var index, quantity;

  keyNode = String(keyNode);

  if (null === _result) {
    _result = {};
  }

  if ('tag:yaml.org,2002:merge' === keyTag) {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index]);
      }
    } else {
      mergeMappings(state, _result, valueNode);
    }
  } else {
    _result[keyNode] = valueNode;
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (0x0A/* LF */ === ch) {
    state.position++;
  } else if (0x0D/* CR */ === ch) {
    state.position++;
    if (0x0A/* LF */ === state.input.charCodeAt(state.position)) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && 0x23/* # */ === ch) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && 0 !== ch);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (0x20/* Space */ === ch) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }

      if (state.lineIndent < checkIndent) {
        throwWarning(state, 'deficient indentation');
      }
    } else {
      break;
    }
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);
  if ((0x2D/* - */ === ch || 0x2E/* . */ === ch) &&
      state.input.charCodeAt(_position + 1) === ch &&
      state.input.charCodeAt(_position+ 2) === ch) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (1 === count) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)             ||
      is_FLOW_INDICATOR(ch)        ||
      0x23/* # */           === ch ||
      0x26/* & */           === ch ||
      0x2A/* * */           === ch ||
      0x21/* ! */           === ch ||
      0x7C/* | */           === ch ||
      0x3E/* > */           === ch ||
      0x27/* ' */           === ch ||
      0x22/* " */           === ch ||
      0x25/* % */           === ch ||
      0x40/* @ */           === ch ||
      0x60/* ` */           === ch) {
    return false;
  }

  if (0x3F/* ? */ === ch || 0x2D/* - */ === ch) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (0 !== ch) {
    if (0x3A/* : */ === ch) {
      following = state.input.charCodeAt(state.position+1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (0x23/* # */ === ch) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  } else {
    state.kind = _kind;
    state.result = _result;
    return false;
  }
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (0x27/* ' */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x27/* ' */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (0x27/* ' */ === ch) {
        captureStart = captureEnd = state.position;
        state.position++;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp, tmpEsc,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x22/* " */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x22/* " */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (0x5C/* \ */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += String.fromCharCode(hexResult);
        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D/* ] */;
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D/* } */;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (0 !== ch) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (0x3F/* ? */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && 0x3A/* : */ === ch) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (0x2C/* , */ === ch) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (0 !== ch) {
    ch = state.input.charCodeAt(++state.position);

    if (0x2B/* + */ === ch || 0x2D/* - */ === ch) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (0x2B/* + */ === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (0x23/* # */ === ch) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (0 !== ch));
    }
  }

  while (0 !== ch) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (0x20/* Space */ === ch)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (detectedIndent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat('\n', emptyLines + 1);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);
      } else if (0 === emptyLines) {
        if (detectedIndent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }
      } else {
        state.result += common.repeat('\n', emptyLines);
      }
    } else {
      if (detectedIndent) {
        state.result += common.repeat('\n', emptyLines + 1);
      } else {
        state.result += common.repeat('\n', emptyLines);
      }
    }

    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (0 !== ch))
    { ch = state.input.charCodeAt(++state.position); }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {

    if (0x2D/* - */ !== ch) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  } else {
    return false;
  }
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    //
    if ((0x3F/* ? */ === ch || 0x3A/* : */  === ch) && is_WS_OR_EOL(following)) {

      if (0x3F/* ? */ === ch) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
      }

      state.position += 1;
      ch = following;

    //
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (0x3A/* : */ === ch) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, keyTag, keyNode, valueNode);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (0 !== ch)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  //
  if (atExplicitKey) {
    storeMappingPair(state, _result, keyTag, keyNode, null);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x21/* ! */ !== ch) {
    return false;
  }

  if (null !== state.tag) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (0x3C/* < */ === ch) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (0x21/* ! */ === ch) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (0 !== ch && 0x3E/* > */ !== ch);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (0 !== ch && !is_WS_OR_EOL(ch)) {

      if (0x21/* ! */ === ch) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if ('!' === tagHandle) {
    state.tag = '!' + tagName;

  } else if ('!!' === tagHandle) {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x26/* & */ !== ch) {
    return false;
  }

  if (null !== state.anchor) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      len = state.length,
      input = state.input,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x2A/* * */ !== ch) {
    return false;
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      atNewLine  = false,
      isIndented = true,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent,
      _result;

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent === parentIndent) {
        isIndented = false;

      } else if (state.lineIndent > parentIndent) {
        isIndented = true;

      } else {
        return false;
      }
    }
  }

  if (isIndented) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;

        if (state.lineIndent > parentIndent) {
          isIndented = true;
          allowBlockCollections = allowBlockStyles;

        } else if (state.lineIndent === parentIndent) {
          isIndented = false;
          allowBlockCollections = allowBlockStyles;

        } else {
          return true;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (isIndented || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (isIndented) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (null !== state.tag || null !== state.anchor) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (null === state.tag) {
            state.tag = '?';
          }
        }

        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (null !== state.tag && '!' !== state.tag) {
    if ('?' === state.tag) {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
           typeIndex < typeQuantity;
           typeIndex += 1) {
        type = state.implicitTypes[typeIndex];
        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (null !== state.anchor) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
      type = state.typeMap[state.tag];

      if (null !== state.result && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwWarning(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  return null !== state.tag || null !== state.anchor || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || 0x25/* % */ !== ch) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (0 !== ch && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (0 !== ch) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (0x23/* # */ === ch) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (0 !== ch && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) {
        break;
      }

      _position = state.position;

      while (0 !== ch && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (0 !== ch) {
      readLineBreak(state);
    }

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (0 === state.lineIndent &&
      0x2D/* - */ === state.input.charCodeAt(state.position) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 1) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 2)) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (0x2E/* . */ === state.input.charCodeAt(state.position)) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (0 !== input.length &&
      0x0A/* LF */ !== input.charCodeAt(input.length - 1) &&
      0x0D/* CR */ !== input.charCodeAt(input.length - 1)) {
    input += '\n';
  }

  var state = new State(input, options);

  if (PATTERN_NON_PRINTABLE.test(state.input)) {
    throwError(state, 'the stream contains non-printable characters');
  }
  state.input += '\0';

  while (0x20/* Space */ === state.input.charCodeAt(state.position)) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options), index, length;

  if (0 === documents.length) {
    return undefined;
  } else if (1 === documents.length) {
    return documents[0];
  } else {
    throw new YAMLException('expected a single document in the stream, but found more');
  }
}


function safeLoadAll(input, output, options) {
  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":2,"./exception":4,"./mark":6,"./schema/default_full":9,"./schema/default_safe":10}],6:[function(require,module,exports){
'use strict';


var common = require('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) {
    return null;
  }

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":2}],7:[function(require,module,exports){
'use strict';


var common        = require('./common');
var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return -1 === exclude.indexOf(index);
  });
}


function compileMap(/* lists... */) {
  var result = {}, index, length;

  function collectType(type) {
    result[type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && 'scalar' !== type.loadKind) {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
  case 1:
    schemas = Schema.DEFAULT;
    types = arguments[0];
    break;

  case 2:
    schemas = arguments[0];
    types = arguments[1];
    break;

  default:
    throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":2,"./exception":4,"./type":13}],8:[function(require,module,exports){
//

'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./json')
  ]
});

},{"../schema":7,"./json":12}],9:[function(require,module,exports){
//
//

'use strict';


var Schema = require('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require('./default_safe')
  ],
  explicit: [
    require('../type/js/undefined'),
    require('../type/js/regexp'),
    require('../type/js/function')
  ]
});

},{"../schema":7,"../type/js/function":18,"../type/js/regexp":19,"../type/js/undefined":20,"./default_safe":10}],10:[function(require,module,exports){
//

'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./core')
  ],
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../schema":7,"../type/binary":14,"../type/merge":22,"../type/omap":24,"../type/pairs":25,"../type/set":27,"../type/timestamp":29,"./core":8}],11:[function(require,module,exports){

'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":7,"../type/map":21,"../type/seq":26,"../type/str":28}],12:[function(require,module,exports){
//

'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./failsafe')
  ],
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../schema":7,"../type/bool":15,"../type/float":16,"../type/int":17,"../type/null":23,"./failsafe":11}],13:[function(require,module,exports){
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (null !== map) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":4}],14:[function(require,module,exports){
'use strict';
var NodeBuffer = require('buffer').Buffer;
var Type       = require('../type');
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;
  for (idx = 0; idx < max; idx ++) {
    code = map.indexOf(data.charAt(idx));
    if (code > 64) { continue; }
    if (code < 0) { return false; }

    bitlen += 6;
  }
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var code, idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];
  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }
  tailbits = (max % 4)*6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }
  if (NodeBuffer) {
    return new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":13,"buffer":30}],15:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return '[object Boolean]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":13}],16:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
  '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  '|[-+]?\\.(?:inf|Inf|INF)' +
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  var value, sign, base, digits;

  if (!YAML_FLOAT_PATTERN.test(data)) {
    return false;
  }
  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = '-' === value[0] ? -1 : 1;
  digits = [];

  if (0 <= '+-'.indexOf(value[0])) {
    value = value.slice(1);
  }

  if ('.inf' === value) {
    return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if ('.nan' === value) {
    return NaN;

  } else if (0 <= value.indexOf(':')) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  } else {
    return sign * parseFloat(value, 10);
  }
}

function representYamlFloat(object, style) {
  if (isNaN(object)) {
    switch (style) {
    case 'lowercase':
      return '.nan';
    case 'uppercase':
      return '.NAN';
    case 'camelcase':
      return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '.inf';
    case 'uppercase':
      return '.INF';
    case 'camelcase':
      return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '-.inf';
    case 'uppercase':
      return '-.INF';
    case 'camelcase':
      return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  } else {
    return object.toString(10);
  }
}

function isFloat(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 !== object % 1 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":2,"../type":13}],17:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) { return false; }

  ch = data[index];
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    if (index+1 === max) { return true; }
    ch = data[++index];
    if (ch === 'b') {
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (ch !== '0' && ch !== '1') {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }


    if (ch === 'x') {
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (!isHexCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') { continue; }
      if (!isOctCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    return hasDigits;
  }
  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') { continue; }
    if (ch === ':') { break; }
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  if (!hasDigits) { return false; }
  if (ch !== ':') { return true; }
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') { sign = -1; }
    value = value.slice(1);
    ch = value[0];
  }

  if ('0' === value) {
    return 0;
  }

  if (ch === '0') {
    if (value[1] === 'b') {
      return sign * parseInt(value.slice(2), 2);
    }
    if (value[1] === 'x') {
      return sign * parseInt(value, 16);
    }
    return sign * parseInt(value, 8);

  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 === object % 1 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (object) { return '0b' + object.toString(2); },
    octal:       function (object) { return '0'  + object.toString(8); },
    decimal:     function (object) { return        object.toString(10); },
    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":2,"../type":13}],18:[function(require,module,exports){
'use strict';

var esprima;
//
//
var Type = require('../../type');

function resolveJavascriptFunction(data) {
  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true }),
        params = [],
        body;

    if ('Program'             !== ast.type         ||
        1                     !== ast.body.length  ||
        'ExpressionStatement' !== ast.body[0].type ||
        'FunctionExpression'  !== ast.body[0].expression.type) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if ('Program'             !== ast.type         ||
      1                     !== ast.body.length  ||
      'ExpressionStatement' !== ast.body[0].type ||
      'FunctionExpression'  !== ast.body[0].expression.type) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;
  return new Function(params, source.slice(body[0]+1, body[1]-1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return '[object Function]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":13,"esprima":"esprima"}],19:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }

    if (modifiers.length > 3) { return false; }
    if (regexp[regexp.length - modifiers.length - 1] !== '/') { return false; }

    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  try {
    var dummy = new RegExp(regexp, modifiers);
    return true;
  } catch (error) {
    return false;
  }
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) {
    result += 'g';
  }

  if (object.multiline) {
    result += 'm';
  }

  if (object.ignoreCase) {
    result += 'i';
  }

  return result;
}

function isRegExp(object) {
  return '[object RegExp]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":13}],20:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return 'undefined' === typeof object;
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":13}],21:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping'
});

},{"../type":13}],22:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return '<<' === data;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge,
});

},{"../type":13}],23:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return null === object;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":13}],24:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) {
          pairHasKey = true;
        } else {
          return false;
        }
      }
    }

    if (!pairHasKey) {
      return false;
    }

    if (-1 === objectKeys.indexOf(pairKey)) {
      objectKeys.push(pairKey);
    } else {
      return false;
    }
  }

  return true;
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap
});

},{"../type":13}],25:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    keys = Object.keys(pair);

    if (1 !== keys.length) {
      return false;
    }

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":13}],26:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence'
});

},{"../type":13}],27:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (null !== object[key]) {
        return false;
      }
    }
  }

  return true;
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet
});

},{"../type":13}],28:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar'
});

},{"../type":13}],29:[function(require,module,exports){
'use strict';

var Type = require('../type');

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:(?:[Tt]|[ \\t]+)'              + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute

function resolveYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    return false;
  }

  return true;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    throw new Error('Date resolve error');
  }
  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }
  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if ('-' === match[9]) {
      delta = -delta;
    }
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) {
    date.setTime(date.getTime() - delta);
  }

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":13}],30:[function(require,module,exports){

},{}],"/":[function(require,module,exports){
'use strict';


var yaml = require('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":1}]},{},[])("/")
});
});

define("plugins/c9.ide.language.javascript.eslint/worker/strip-json-comments",[], function(require, exports, module) {

	function stripJsonComments(str) {
		var currentChar;
		var nextChar;
		var insideString = false;
		var insideComment = false;
		var ret = '';

		for (var i = 0; i < str.length; i++) {
			currentChar = str[i];
			nextChar = str[i + 1];

			if (!insideComment && str[i - 1] !== '\\' && currentChar === '"') {
				insideString = !insideString;
			}

			if (insideString) {
				ret += currentChar;
				continue;
			}

			if (!insideComment && currentChar + nextChar === '//') {
				insideComment = 'single';
				i++;
			} else if (insideComment === 'single' && currentChar + nextChar === '\r\n') {
				insideComment = false;
				i++;
				ret += currentChar;
				ret += nextChar;
				continue;
			} else if (insideComment === 'single' && currentChar === '\n') {
				insideComment = false;
			} else if (!insideComment && currentChar + nextChar === '/*') {
				insideComment = 'multi';
				i++;
				continue;
			} else if (insideComment === 'multi' && currentChar + nextChar === '*/') {
				insideComment = false;
				i++;
				continue;
			}

			if (insideComment) {
				continue;
			}

			ret += currentChar;
		}

		return ret;
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = stripJsonComments;
	} else {
		window.stripJsonComments = stripJsonComments;
	}
	
});

define("plugins/c9.ide.language.javascript.eslint/worker/eslint_worker",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var workerUtil = require('plugins/c9.ide.language/worker_util');
var Linter = require("./eslint_browserified");
var linter = new Linter();
var handler = module.exports = Object.create(baseLanguageHandler);
var util = require("plugins/c9.ide.language/worker_util");
var yaml = require("./js-yaml");
var stripJsonComments = require("./strip-json-comments");

var defaultRules;
var defaultEnv = {
    "browser": false,
    "amd": true,
    "builtin": true,
    "node": true,
    "jasmine": false,
    "mocha": true,
    "es6": true,
    "jquery": false,
    "meteor": false,
};
var defaultParserOptions = {
    ecmaFeatures: {
        globalReturn: true, // allow return statements in the global scope
        jsx: true, // enable JSX
        experimentalObjectRestSpread: true
    },
    ecmaVersion: 8,
};
var defaultGlobals = require("plugins/c9.ide.language.javascript/scope_analyzer").GLOBALS;
var userConfig;
var userConfigRaw;

handler.init = function(callback) {
    var rules = defaultRules = {};
    
    rules["handle-callback-err"] = 1;
    rules["no-debugger"] = 1;
    rules["no-undef"] = 1;
    rules["no-inner-declarations"] = [1, "functions"];
    rules["no-native-reassign"] = 1;
    rules["no-new-func"] = 1;
    rules["no-new-wrappers"] = 1;
    rules["no-cond-assign"] = [1, "except-parens"];
    rules["no-debugger"] = 3;
    rules["no-dupe-keys"] = 3;
    rules["no-eval"] = 1;
    rules["no-func-assign"] = 1;
    rules["no-extra-semi"] = 3;
    rules["no-invalid-regexp"] = 1;
    rules["no-irregular-whitespace"] = 3;
    rules["no-negated-in-lhs"] = 1;
    rules["no-regex-spaces"] = 3;
    rules["quote-props"] = 0;
    rules["no-unreachable"] = 1;
    rules["use-isnan"] = 2;
    rules["valid-typeof"] = 1;
    rules["no-redeclare"] = 3;
    rules["no-with"] = 1;
    rules["radix"] = 3;
    rules["no-delete-var"] = 2;
    rules["no-label-var"] = 3;
    rules["no-console"] = 0;
    rules["no-shadow-restricted-names"] = 2;
    rules["handle-callback-err"] = 1;
    rules["no-new-require"] = 2;

    loadConfigFile(true, function(err) {
        if (err) console.error(err);
        util.$watchDir("/", handler);
        util.$onWatchDirChange(onWorkspaceDirChange);
    });
    
    callback();
};

function onWorkspaceDirChange(e) {
    e.data.files.forEach(function(f) {
        if (f.name === ".eslintrc")
            loadConfigFile();
    });
}

function loadConfigFile(initialLoad, callback) {
    util.readFile("/.eslintrc", "utf-8", function onResult(err, data) {
        if (err) return loadConfig(err);
        
        if (data === userConfigRaw)
            return callback && callback();

        userConfigRaw = data;
        var result;
        try {
            result = yaml.safeLoad(stripJsonComments(data));
        }
        catch (e) {
            return loadConfig(e);
        }
        loadConfig(null, result);
    });
    
    function loadConfig(err, result) {
        if (err && !callback)
            util.showError(err);
        userConfig = result;
        if (userConfig && userConfig.rules && userConfig.rules["semi"] != undefined)
            userConfig.semi = true;
        if (!initialLoad)
            util.refreshAllMarkers();
        callback && callback();
    }
}

handler.handlesLanguage = function(language) {
    return language === "javascript" || language == "jsx";
};

handler.analyze = function(value, ast, options, callback) {
    if (options.minimalAnalysis)
        return callback();
    callback(handler.analyzeSync(value, ast, options.path));
};

handler.getMaxFileSizeSupported = function() {
    return .5 * 10 * 1000 * 80;
};

handler.analyzeSync = function(value, ast, path) {
    var doc = this.doc;
    var markers = [];
    if (!workerUtil.isFeatureEnabled("hints"))
        return markers;

    var config = this.isFeatureEnabled("eslintrc") && userConfig || {};

    delete config.parser; // we only support espree

    config.rules = config.rules || defaultRules;
    config.env = config.env || defaultEnv;
    config.globals = config.globals || defaultGlobals;
    config.parserOptions = config.parserOptions || defaultParserOptions;
    if (config.parserOptions.ecmaVersion == null)
        config.parserOptions.ecmaVersion = 8;
    if (config.parserOptions.ecmaFeatures == null)
        config.parserOptions.ecmaFeatures = defaultParserOptions.ecmaFeatures;
    if (config.parserOptions.ecmaFeatures.experimentalObjectRestSpread == null)
        config.parserOptions.ecmaFeatures.experimentalObjectRestSpread = true;

    config.rules["no-unused-vars"] = [
        3,
        {
            vars: "all",
            args: handler.isFeatureEnabled("unusedFunctionArgs") ? "all" : "none"
        }
    ];
    config.rules["react/jsx-uses-vars"] = 2;
    config.rules["no-undef"] =
        handler.isFeatureEnabled("undeclaredVars") ? 1 : 0;
    
    if (!config.semi) {
        config.rules["semi"] =
            handler.isFeatureEnabled("semi") ? 3 : 0;
    }

    var isJson = this.path.match(/\.(json|run|settings|build)$/);
    if (isJson)
        value = "!" + value;

    try {
        var messages = linter.verify(value, config);
    }
    catch (e) {
        console.error(e.stack);
        if (e.message && e.message.match(/rule .* was not found/))
            workerUtil.showError("eslint: " + e.message);
        return [];
    }
    
    messages.forEach(function(m) {
        var level;
        if (m.severity === 2)
            level = "error";
        else if (m.severity === 1)
            level = "warning";
        else
            level = "info";
        
        if (isJson && level !== "error")
            return;
        m.column--;
        m.line--;
        m.endLine--;
        m.endColumn--;
        
        if (m.message.match(/but never used/)) {
            var line = doc.getLine(m.line);
            var target = line.slice(m.column, m.endColumn)
            if (target.toUpperCase() === target && target.toLowerCase() !== target)
                return; // ignore unused constants
            if (target === "h")
                return; // ignore 'h', used in preact
            if (m.severity === 1)
                level = "info";
        }
        if (m.ruleId && m.ruleId.match(/space|spacing/) && m.severity === 1)
            level = "info";
        
        var ec;
        if (m.message.match(/is not defined|was used before it was defined|is already declared|is already defined|unexpected identifier|but never used/i)) {
            var line = doc.getLine(m.line);
            var id = workerUtil.getFollowingIdentifier(line, m.column);
            if (m.message.match(/is already defined/) && line.match("for \\(var " + id))
                return;
            ec = m.column + id.length;
        }
        if (m.message.match(/'([^']*)' is not defined/)) {
            m.message = RegExp.$1 + " is not defined; please fix or add /*global " + RegExp.$1 + "*/";
        }
        if (m.message.match(/missing semicolon/i)) {
            var line = doc.getLine(m.line);
            if (line.substr(m.column).match(/\s*}/))
                return; // allow missing semi at end of block
            if ((m.line === doc.getLength() || m.line === doc.getLength() - 1)
                && line.match(/^\s*\}\)\s*$/))
                return;
            if (m.severity === 1)
                level = "info";
        }
            
        markers.push({
            pos: {
                sl: m.line,
                sc: m.column,
                ec: ec
            },
            type: level,
            level: level !== "info" && level,
            message: m.message
        });
    });
    return markers;
};
    
});

define("acorn/dist/walk",["require", "exports", "module", "./acorn"], function(require, exports, module) {

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).walk = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/src\\walk\\index.js":[function(_dereq_,module,exports){
//
//
//
"use strict";

exports.__esModule = true;
exports.simple = simple;
exports.ancestor = ancestor;
exports.recursive = recursive;
exports.findNodeAt = findNodeAt;
exports.findNodeAround = findNodeAround;
exports.findNodeAfter = findNodeAfter;
exports.findNodeBefore = findNodeBefore;
exports.make = make;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function simple(node, visitors, base, state, override) {
  if (!base) base = exports.base;(function c(node, st, override) {
    var type = override || node.type,
        found = visitors[type];
    base[type](node, st, c);
    if (found) found(node, st);
  })(node, state, override);
}
function ancestor(node, visitors, base, state) {
  if (!base) base = exports.base;
  if (!state) state = [];(function c(node, st, override) {
    var type = override || node.type,
        found = visitors[type];
    if (node != st[st.length - 1]) {
      st = st.slice();
      st.push(node);
    }
    base[type](node, st, c);
    if (found) found(node, st);
  })(node, state);
}
function recursive(node, state, funcs, base, override) {
  var visitor = funcs ? exports.make(funcs, base) : base;(function c(node, st, override) {
    visitor[override || node.type](node, st, c);
  })(node, state, override);
}

function makeTest(test) {
  if (typeof test == "string") return function (type) {
    return type == test;
  };else if (!test) return function () {
    return true;
  };else return test;
}

var Found = function Found(node, state) {


  this.node = node;this.state = state;
};
function findNodeAt(node, start, end, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      var type = override || node.type;
      if ((start == null || node.start <= start) && (end == null || node.end >= end)) base[type](node, st, c);
      if ((start == null || node.start == start) && (end == null || node.end == end) && test(type, node)) throw new Found(node, st);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) return e;
    throw e;
  }
}
function findNodeAround(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      var type = override || node.type;
      if (node.start > pos || node.end < pos) return;
      base[type](node, st, c);
      if (test(type, node)) throw new Found(node, st);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) return e;
    throw e;
  }
}
function findNodeAfter(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      if (node.end < pos) return;
      var type = override || node.type;
      if (node.start >= pos && test(type, node)) throw new Found(node, st);
      base[type](node, st, c);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) return e;
    throw e;
  }
}
function findNodeBefore(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  var max = undefined;(function c(node, st, override) {
    if (node.start > pos) return;
    var type = override || node.type;
    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) max = new Found(node, st);
    base[type](node, st, c);
  })(node, state);
  return max;
}
function make(funcs, base) {
  if (!base) base = exports.base;
  var visitor = {};
  for (var type in base) visitor[type] = base[type];
  for (var type in funcs) visitor[type] = funcs[type];
  return visitor;
}

function skipThrough(node, st, c) {
  c(node, st);
}
function ignore(_node, _st, _c) {}
var base = {};

exports.base = base;
base.Program = base.BlockStatement = function (node, st, c) {
  for (var i = 0; i < node.body.length; ++i) {
    c(node.body[i], st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = function (node, st, c) {
  return c(node.expression, st, "Expression");
};
base.IfStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Statement");
  if (node.alternate) c(node.alternate, st, "Statement");
};
base.LabeledStatement = function (node, st, c) {
  return c(node.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function (node, st, c) {
  c(node.object, st, "Expression");
  c(node.body, st, "Statement");
};
base.SwitchStatement = function (node, st, c) {
  c(node.discriminant, st, "Expression");
  for (var i = 0; i < node.cases.length; ++i) {
    var cs = node.cases[i];
    if (cs.test) c(cs.test, st, "Expression");
    for (var j = 0; j < cs.consequent.length; ++j) {
      c(cs.consequent[j], st, "Statement");
    }
  }
};
base.ReturnStatement = base.YieldExpression = function (node, st, c) {
  if (node.argument) c(node.argument, st, "Expression");
};
base.ThrowStatement = base.SpreadElement = function (node, st, c) {
  return c(node.argument, st, "Expression");
};
base.TryStatement = function (node, st, c) {
  c(node.block, st, "Statement");
  if (node.handler) {
    c(node.handler.param, st, "Pattern");
    c(node.handler.body, st, "ScopeBody");
  }
  if (node.finalizer) c(node.finalizer, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForStatement = function (node, st, c) {
  if (node.init) c(node.init, st, "ForInit");
  if (node.test) c(node.test, st, "Expression");
  if (node.update) c(node.update, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function (node, st, c) {
  c(node.left, st, "ForInit");
  c(node.right, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInit = function (node, st, c) {
  if (node.type == "VariableDeclaration") c(node, st);else c(node, st, "Expression");
};
base.DebuggerStatement = ignore;

base.FunctionDeclaration = function (node, st, c) {
  return c(node, st, "Function");
};
base.VariableDeclaration = function (node, st, c) {
  for (var i = 0; i < node.declarations.length; ++i) {
    c(node.declarations[i], st);
  }
};
base.VariableDeclarator = function (node, st, c) {
  c(node.id, st, "Pattern");
  if (node.init) c(node.init, st, "Expression");
};

base.Function = function (node, st, c) {
  if (node.id) c(node.id, st, "Pattern");
  for (var i = 0; i < node.params.length; i++) {
    c(node.params[i], st, "Pattern");
  }c(node.body, st, node.expression ? "ScopeExpression" : "ScopeBody");
};
base.ScopeBody = function (node, st, c) {
  return c(node, st, "Statement");
};
base.ScopeExpression = function (node, st, c) {
  return c(node, st, "Expression");
};

base.Pattern = function (node, st, c) {
  if (node.type == "Identifier") c(node, st, "VariablePattern");else if (node.type == "MemberExpression") c(node, st, "MemberPattern");else c(node, st);
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function (node, st, c) {
  return c(node.argument, st, "Pattern");
};
base.ArrayPattern = function (node, st, c) {
  for (var i = 0; i < node.elements.length; ++i) {
    var elt = node.elements[i];
    if (elt) c(elt, st, "Pattern");
  }
};
base.ObjectPattern = function (node, st, c) {
  for (var i = 0; i < node.properties.length; ++i) {
    c(node.properties[i].value, st, "Pattern");
  }
};

base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function (node, st, c) {
  for (var i = 0; i < node.elements.length; ++i) {
    var elt = node.elements[i];
    if (elt) c(elt, st, "Expression");
  }
};
base.ObjectExpression = function (node, st, c) {
  for (var i = 0; i < node.properties.length; ++i) {
    c(node.properties[i], st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {
  for (var i = 0; i < node.expressions.length; ++i) {
    c(node.expressions[i], st, "Expression");
  }
};
base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
  c(node.argument, st, "Expression");
};
base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
  c(node.left, st, "Expression");
  c(node.right, st, "Expression");
};
base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
  c(node.left, st, "Pattern");
  c(node.right, st, "Expression");
};
base.ConditionalExpression = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Expression");
  c(node.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function (node, st, c) {
  c(node.callee, st, "Expression");
  if (node.arguments) for (var i = 0; i < node.arguments.length; ++i) {
    c(node.arguments[i], st, "Expression");
  }
};
base.MemberExpression = function (node, st, c) {
  c(node.object, st, "Expression");
  if (node.computed) c(node.property, st, "Expression");
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
  if (node.declaration) c(node.declaration, st, node.type == "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
  if (node.source) c(node.source, st, "Expression");
};
base.ExportAllDeclaration = function (node, st, c) {
  c(node.source, st, "Expression");
};
base.ImportDeclaration = function (node, st, c) {
  for (var i = 0; i < node.specifiers.length; i++) {
    c(node.specifiers[i], st);
  }c(node.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;

base.TaggedTemplateExpression = function (node, st, c) {
  c(node.tag, st, "Expression");
  c(node.quasi, st);
};
base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
  return c(node, st, "Class");
};
base.Class = function (node, st, c) {
  if (node.id) c(node.id, st, "Pattern");
  if (node.superClass) c(node.superClass, st, "Expression");
  for (var i = 0; i < node.body.body.length; i++) {
    c(node.body.body[i], st);
  }
};
base.MethodDefinition = base.Property = function (node, st, c) {
  if (node.computed) c(node.key, st, "Expression");
  c(node.value, st, "Expression");
};

},{}]},{},["/src\\walk\\index.js"])("/src\\walk\\index.js")
});
});

define("tern/lib/def",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
//
//
//
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return exports.init = mod;
  if (typeof define == "function" && define.amd) // AMD
    return define({init: mod});
  tern.def = {init: mod};
})(function(exports, infer) {
  "use strict";

  function hop(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var TypeParser = exports.TypeParser = function(spec, start, base, forceNew) {
    this.pos = start || 0;
    this.spec = spec;
    this.base = base;
    this.forceNew = forceNew;
  };

  function unwrapType(type, self, args) {
    return type.call ? type(self, args) : type;
  }

  function extractProp(type, prop) {
    if (prop == "!ret") {
      if (type.retval) return type.retval;
      var rv = new infer.AVal;
      type.propagate(new infer.IsCallee(infer.ANull, [], null, rv));
      return rv;
    } else {
      return type.getProp(prop);
    }
  }

  function computedFunc(name, args, retType, generator) {
    return function(self, cArgs) {
      var realArgs = [];
      for (var i = 0; i < args.length; i++) realArgs.push(unwrapType(args[i], self, cArgs));
      return new infer.Fn(name, infer.ANull, realArgs, unwrapType(retType, self, cArgs), generator);
    };
  }
  function computedUnion(types) {
    return function(self, args) {
      var union = new infer.AVal;
      for (var i = 0; i < types.length; i++) unwrapType(types[i], self, args).propagate(union);
      union.maxWeight = 1e5;
      return union;
    };
  }
  function computedArray(inner) {
    return function(self, args) {
      return new infer.Arr(inner(self, args));
    };
  }
  function computedTuple(types) {
    return function(self, args) {
      return new infer.Arr(types.map(function(tp) { return unwrapType(tp, self, args) }))
    }
  }

  TypeParser.prototype = {
    eat: function(str) {
      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {
        this.pos += str.length;
        return true;
      }
    },
    word: function(re) {
      var word = "", ch, re = re || /[\w$]/;
      while ((ch = this.spec.charAt(this.pos)) && re.test(ch)) { word += ch; ++this.pos; }
      return word;
    },
    error: function() {
      throw new Error("Unrecognized type spec: " + this.spec + " (at " + this.pos + ")");
    },
    parseFnType: function(comp, name, top, generator) {
      var args = [], names = [], computed = false;
      if (!this.eat(")")) for (var i = 0; ; ++i) {
        var colon = this.spec.indexOf(": ", this.pos), argname;
        if (colon != -1) {
          argname = this.spec.slice(this.pos, colon);
          if (/^[$\w?]+$/.test(argname))
            this.pos = colon + 2;
          else
            argname = null;
        }
        names.push(argname);
        var argType = this.parseType(comp);
        if (argType.call) computed = true;
        args.push(argType);
        if (!this.eat(", ")) {
          this.eat(")") || this.error();
          break;
        }
      }
      var retType, computeRet, computeRetStart, fn;
      if (this.eat(" -> ")) {
        var retStart = this.pos;
        retType = this.parseType(true);
        if (retType.call && !computed) {
          computeRet = retType;
          retType = infer.ANull;
          computeRetStart = retStart;
        }
      } else {
        retType = infer.ANull;
      }
      if (computed) return computedFunc(name, args, retType, generator);

      if (top && (fn = this.base))
        infer.Fn.call(this.base, name, infer.ANull, args, names, retType, generator);
      else
        fn = new infer.Fn(name, infer.ANull, args, names, retType, generator);
      if (computeRet) fn.computeRet = computeRet;
      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);
      return fn;
    },
    parseType: function(comp, name, top) {
      var main = this.parseTypeMaybeProp(comp, name, top);
      if (!this.eat("|")) return main;
      var types = [main], computed = main.call;
      for (;;) {
        var next = this.parseTypeMaybeProp(comp, name, top);
        types.push(next);
        if (next.call) computed = true;
        if (!this.eat("|")) break;
      }
      if (computed) return computedUnion(types);
      var union = new infer.AVal;
      for (var i = 0; i < types.length; i++) types[i].propagate(union);
      union.maxWeight = 1e5;
      return union;
    },
    parseTypeMaybeProp: function(comp, name, top) {
      var result = this.parseTypeInner(comp, name, top);
      while (comp && this.eat(".")) result = this.extendWithProp(result);
      return result;
    },
    extendWithProp: function(base) {
      var propName = this.word(/[\w<>$!:]/) || this.error();
      if (base.apply) return function(self, args) {
        return extractProp(base(self, args), propName);
      };
      return extractProp(base, propName);
    },
    parseTypeInner: function(comp, name, top) {
      var gen
      if (this.eat("fn(") || (gen = this.eat("fn*("))) {
        return this.parseFnType(comp, name, top, gen);
      } else if (this.eat("[")) {
        var inner = this.parseType(comp), types, computed = inner.call
        while (this.eat(", ")) {
          if (!types) types = [inner]
          var next = this.parseType(comp)
          types.push(next)
          computed = computed || next.call
        }
        this.eat("]") || this.error()
        if (computed) return types ? computedTuple(types) : computedArray(inner)
        if (top && this.base) {
          infer.Arr.call(this.base, types || inner)
          return this.base
        }
        return new infer.Arr(types || inner)
      } else if (this.eat("+")) {
        var path = this.word(/[\w$<>\.:!]/)
        var base = infer.cx().localDefs[path + ".prototype"]
        if (!base) {
          var base = parsePath(path);
          if (!(base instanceof infer.Obj)) return base;
          var proto = descendProps(base, ["prototype"])
          if (proto && (proto = proto.getObjType()))
            base = proto
        }
        if (comp && this.eat("[")) return this.parsePoly(base);
        if (top && this.forceNew) return new infer.Obj(base);
        return infer.getInstance(base);
      } else if (this.eat(":")) {
        var name = this.word(/[\w$\.]/)
        return infer.getSymbol(name)
      } else if (comp && this.eat("!")) {
        var arg = this.word(/\d/);
        if (arg) {
          arg = Number(arg);
          return function(_self, args) {return args[arg] || infer.ANull;};
        } else if (this.eat("this")) {
          return function(self) {return self;};
        } else if (this.eat("custom:")) {
          var fname = this.word(/[\w$]/);
          return customFunctions[fname] || function() { return infer.ANull; };
        } else {
          return this.fromWord("!" + this.word(/[\w$<>\.!:]/));
        }
      } else if (this.eat("?")) {
        return infer.ANull;
      } else {
        return this.fromWord(this.word(/[\w$<>\.!:`]/));
      }
    },
    fromWord: function(spec) {
      var cx = infer.cx();
      switch (spec) {
      case "number": return cx.num;
      case "string": return cx.str;
      case "bool": return cx.bool;
      case "<top>": return cx.topScope;
      }
      if (cx.localDefs && spec in cx.localDefs) return cx.localDefs[spec];
      return parsePath(spec);
    },
    parsePoly: function(base) {
      var propName = "<i>", match;
      if (match = this.spec.slice(this.pos).match(/^\s*([\w$:]+)\s*=\s*/)) {
        propName = match[1];
        this.pos += match[0].length;
      }
      var value = this.parseType(true);
      if (!this.eat("]")) this.error();
      if (value.call) return function(self, args) {
        var instance = new infer.Obj(base);
        value(self, args).propagate(instance.defProp(propName));
        return instance;
      };
      var instance = new infer.Obj(base);
      value.propagate(instance.defProp(propName));
      return instance;
    }
  };

  function parseType(spec, name, base, forceNew) {
    var type = new TypeParser(spec, null, base, forceNew).parseType(false, name, true);
    if (/^fn\(/.test(spec)) for (var i = 0; i < type.args.length; ++i) (function(i) {
      var arg = type.args[i];
      if (arg instanceof infer.Fn && arg.args && arg.args.length) addEffect(type, function(_self, fArgs) {
        var fArg = fArgs[i];
        if (fArg) fArg.propagate(new infer.IsCallee(infer.cx().topScope, arg.args, null, infer.ANull));
      });
    })(i);
    return type;
  }

  function addEffect(fn, handler, replaceRet) {
    var oldCmp = fn.computeRet, rv = fn.retval;
    fn.computeRet = function(self, args, argNodes) {
      var handled = handler(self, args, argNodes);
      var old = oldCmp ? oldCmp(self, args, argNodes) : rv;
      return replaceRet ? handled : old;
    };
  }

  var parseEffect = exports.parseEffect = function(effect, fn) {
    var m;
    if (effect.indexOf("propagate ") == 0) {
      var p = new TypeParser(effect, 10);
      var origin = p.parseType(true);
      if (!p.eat(" ")) p.error();
      var target = p.parseType(true);
      addEffect(fn, function(self, args) {
        unwrapType(origin, self, args).propagate(unwrapType(target, self, args));
      });
    } else if (effect.indexOf("call ") == 0) {
      var andRet = effect.indexOf("and return ", 5) == 5;
      var p = new TypeParser(effect, andRet ? 16 : 5);
      var getCallee = p.parseType(true), getSelf = null, getArgs = [];
      if (p.eat(" this=")) getSelf = p.parseType(true);
      while (p.eat(" ")) getArgs.push(p.parseType(true));
      addEffect(fn, function(self, args) {
        var callee = unwrapType(getCallee, self, args);
        var slf = getSelf ? unwrapType(getSelf, self, args) : infer.ANull, as = [];
        for (var i = 0; i < getArgs.length; ++i) as.push(unwrapType(getArgs[i], self, args));
        var result = andRet ? new infer.AVal : infer.ANull;
        callee.propagate(new infer.IsCallee(slf, as, null, result));
        return result;
      }, andRet);
    } else if (m = effect.match(/^custom (\S+)\s*(.*)/)) {
      var customFunc = customFunctions[m[1]];
      if (customFunc) addEffect(fn, m[2] ? customFunc(m[2]) : customFunc);
    } else if (effect.indexOf("copy ") == 0) {
      var p = new TypeParser(effect, 5);
      var getFrom = p.parseType(true);
      p.eat(" ");
      var getTo = p.parseType(true);
      addEffect(fn, function(self, args) {
        var from = unwrapType(getFrom, self, args), to = unwrapType(getTo, self, args);
        from.forAllProps(function(prop, val, local) {
          if (local && prop != "<i>")
            to.propagate(new infer.DefProp(prop, val));
        });
      });
    } else {
      throw new Error("Unknown effect type: " + effect);
    }
  };

  var currentTopScope;

  var parsePath = exports.parsePath = function(path, scope) {
    var cx = infer.cx(), cached = cx.paths[path], origPath = path;
    if (cached != null) return cached;
    cx.paths[path] = infer.ANull;

    var base = scope || currentTopScope || cx.topScope;

    if (cx.localDefs) for (var name in cx.localDefs) {
      if (path.indexOf(name) == 0) {
        if (path == name) return cx.paths[path] = cx.localDefs[path];
        if (path.charAt(name.length) == ".") {
          base = cx.localDefs[name];
          path = path.slice(name.length + 1);
          break;
        }
      }
    }

    var result = descendProps(base, path.split("."))
    cx.paths[origPath] = result == infer.ANull ? null : result
    return result
  }

  function descendProps(base, parts) {
    for (var i = 0; i < parts.length && base != infer.ANull; ++i) {
      var prop = parts[i];
      if (prop.charAt(0) == "!") {
        if (prop == "!proto") {
          base = (base instanceof infer.Obj && base.proto) || infer.ANull;
        } else {
          var fn = base.getFunctionType();
          if (!fn) {
            base = infer.ANull;
          } else if (prop == "!ret") {
            base = fn.retval && fn.retval.getType(false) || infer.ANull;
          } else {
            var arg = fn.args && fn.args[Number(prop.slice(1))];
            base = (arg && arg.getType(false)) || infer.ANull;
          }
        }
      } else if (base instanceof infer.Obj &&
                 (prop == "prototype" && base instanceof infer.Fn || base.hasProp(prop))) {
        var propVal = base.getProp(prop);
        if (!propVal || propVal.isEmpty())
          base = infer.ANull;
        else
          base = propVal.types[0];
      } else {
        base = infer.ANull;
      }
    }
    return base;
  }

  function emptyObj(ctor) {
    var empty = Object.create(ctor.prototype);
    empty.props = Object.create(null);
    empty.isShell = true;
    return empty;
  }

  function isSimpleAnnotation(spec) {
    if (!spec["!type"] || /^(fn\(|\[)/.test(spec["!type"])) return false;
    for (var prop in spec)
      if (prop != "!type" && prop != "!doc" && prop != "!url" && prop != "!span" && prop != "!data")
        return false;
    return true;
  }

  function passOne(base, spec, path) {
    if (!base) {
      var tp = spec["!type"];
      if (tp) {
        if (/^fn\(/.test(tp)) base = emptyObj(infer.Fn);
        else if (tp.charAt(0) == "[") base = emptyObj(infer.Arr);
        else throw new Error("Invalid !type spec: " + tp);
      } else if (spec["!stdProto"]) {
        base = infer.cx().protos[spec["!stdProto"]];
      } else {
        base = emptyObj(infer.Obj);
      }
      base.name = path;
    }

    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
      var inner = spec[name];
      if (typeof inner == "string" || isSimpleAnnotation(inner)) continue;
      var prop = base.defProp(name);
      passOne(prop.getObjType(), inner, path ? path + "." + name : name).propagate(prop);
    }
    return base;
  }

  function passTwo(base, spec, path) {
    if (base.isShell) {
      delete base.isShell;
      var tp = spec["!type"];
      if (tp) {
        parseType(tp, path, base);
      } else {
        var proto = spec["!proto"] && parseType(spec["!proto"]);
        infer.Obj.call(base, proto instanceof infer.Obj ? proto : true, path);
      }
    }

    var effects = spec["!effects"];
    if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i)
      parseEffect(effects[i], base);
    copyInfo(spec, base);

    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
      var inner = spec[name], known = base.defProp(name), innerPath = path ? path + "." + name : name;
      if (typeof inner == "string") {
        if (known.isEmpty()) parseType(inner, innerPath).propagate(known);
      } else {
        if (!isSimpleAnnotation(inner))
          passTwo(known.getObjType(), inner, innerPath);
        else if (known.isEmpty())
          parseType(inner["!type"], innerPath, null, true).propagate(known);
        else
          continue;
        if (inner["!doc"]) known.doc = inner["!doc"];
        if (inner["!url"]) known.url = inner["!url"];
        if (inner["!span"]) known.span = inner["!span"];
      }
    }
    return base;
  }

  function copyInfo(spec, type) {
    if (spec["!doc"]) type.doc = spec["!doc"];
    if (spec["!url"]) type.url = spec["!url"];
    if (spec["!span"]) type.span = spec["!span"];
    if (spec["!data"]) type.metaData = spec["!data"];
  }

  function doLoadEnvironment(data, scope) {
    var cx = infer.cx(), server = cx.parent

    infer.addOrigin(cx.curOrigin = data["!name"] || "env#" + cx.origins.length);
    cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);

    if (server) server.signal("preLoadDef", data)

    passOne(scope, data);

    var def = data["!define"];
    if (def) {
      for (var name in def) {
        var spec = def[name];
        cx.localDefs[name] = typeof spec == "string" ? parsePath(spec) : passOne(null, spec, name);
      }
      for (var name in def) {
        var spec = def[name];
        if (typeof spec != "string") passTwo(cx.localDefs[name], def[name], name);
      }
    }

    passTwo(scope, data);

    if (server) server.signal("postLoadDef", data)

    cx.curOrigin = cx.localDefs = null;
  }

  exports.load = function(data, scope) {
    if (!scope) scope = infer.cx().topScope;
    var oldScope = currentTopScope;
    currentTopScope = scope;
    try {
      doLoadEnvironment(data, scope);
    } finally {
      currentTopScope = oldScope;
    }
  };

  exports.parse = function(data, origin, path) {
    var cx = infer.cx();
    if (origin) {
      cx.origin = origin;
      cx.localDefs = cx.definitions[origin];
    }

    try {
      if (typeof data == "string")
        return parseType(data, path);
      else
        return passTwo(passOne(null, data, path), data, path);
    } finally {
      if (origin) cx.origin = cx.localDefs = null;
    }
  };
  var customFunctions = Object.create(null);
  infer.registerFunction = function(name, f) { customFunctions[name] = f; };

  var IsCreated = infer.constraint({
    construct: function(created, target, spec) {
      this.created = created;
      this.target = target;
      this.spec = spec;
    },
    addType: function(tp) {
      if (tp instanceof infer.Obj && this.created++ < 5) {
        var derived = new infer.Obj(tp), spec = this.spec;
        if (spec instanceof infer.AVal) spec = spec.getObjType(false);
        if (spec instanceof infer.Obj) for (var prop in spec.props) {
          var cur = spec.props[prop].types[0];
          var p = derived.defProp(prop);
          if (cur && cur instanceof infer.Obj && cur.props.value) {
            var vtp = cur.props.value.getType(false);
            if (vtp) p.addType(vtp);
          }
        }
        this.target.addType(derived);
      }
    }
  });

  infer.registerFunction("Object_create", function(_self, args, argNodes) {
    if (argNodes && argNodes.length && argNodes[0].type == "Literal" && argNodes[0].value == null)
      return new infer.Obj();

    var result = new infer.AVal;
    if (args[0]) args[0].propagate(new IsCreated(0, result, args[1]));
    return result;
  });

  var PropSpec = infer.constraint({
    construct: function(target) { this.target = target; },
    addType: function(tp) {
      if (!(tp instanceof infer.Obj)) return;
      if (tp.hasProp("value"))
        tp.getProp("value").propagate(this.target);
      else if (tp.hasProp("get"))
        tp.getProp("get").propagate(new infer.IsCallee(infer.ANull, [], null, this.target));
    }
  });

  infer.registerFunction("Object_defineProperty", function(_self, args, argNodes) {
    if (argNodes && argNodes.length >= 3 && argNodes[1].type == "Literal" &&
        typeof argNodes[1].value == "string") {
      var obj = args[0], connect = new infer.AVal;
      obj.propagate(new infer.DefProp(argNodes[1].value, connect, argNodes[1]));
      args[2].propagate(new PropSpec(connect));
    }
    return infer.ANull;
  });

  infer.registerFunction("Object_defineProperties", function(_self, args, argNodes) {
    if (args.length >= 2) {
      var obj = args[0];
      args[1].forAllProps(function(prop, val, local) {
        if (!local) return;
        var connect = new infer.AVal;
        obj.propagate(new infer.DefProp(prop, connect, argNodes && argNodes[1]));
        val.propagate(new PropSpec(connect));
      });
    }
    return infer.ANull;
  });

  var IsBound = infer.constraint({
    construct: function(self, args, target) {
      this.self = self; this.args = args; this.target = target;
    },
    addType: function(tp) {
      if (!(tp instanceof infer.Fn)) return;
      this.target.addType(new infer.Fn(tp.name, infer.ANull, tp.args.slice(this.args.length),
                                       tp.argNames.slice(this.args.length), tp.retval, tp.generator));
      this.self.propagate(tp.self);
      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i)
        this.args[i].propagate(tp.args[i]);
    }
  });

  infer.registerFunction("Function_bind", function(self, args) {
    if (!args.length) return infer.ANull;
    var result = new infer.AVal;
    self.propagate(new IsBound(args[0], args.slice(1), result));
    return result;
  });

  infer.registerFunction("Array_ctor", function(_self, args) {
    var arr = new infer.Arr;
    if (args.length != 1 || !args[0].hasType(infer.cx().num)) {
      var content = arr.getProp("<i>");
      for (var i = 0; i < args.length; ++i) args[i].propagate(content);
    }
    return arr;
  });

  infer.registerFunction("Promise_ctor", function(_self, args, argNodes) {
    var defs6 = infer.cx().definitions.ecma6
    if (!defs6 || args.length < 1) return infer.ANull;
    var self = new infer.Obj(defs6["Promise.prototype"]);
    var valProp = self.defProp(":t", argNodes && argNodes[0]);
    var valArg = new infer.AVal;
    valArg.propagate(valProp);
    var exec = new infer.Fn("execute", infer.ANull, [valArg], ["value"], infer.ANull);
    var reject = defs6.Promise_reject;
    args[0].propagate(new infer.IsCallee(infer.ANull, [exec, reject], null, infer.ANull));
    return self;
  });

  var PromiseResolvesTo = infer.constraint({
    construct: function(output) { this.output = output; },
    addType: function(tp) {
      if (tp.constructor == infer.Obj && tp.name == "Promise" && tp.hasProp(":t"))
        tp.getProp(":t").propagate(this.output);
      else
        tp.propagate(this.output);
    }
  });

  var WG_PROMISE_KEEP_VALUE = 50;

  infer.registerFunction("Promise_then", function(self, args, argNodes) {
    var fn = args.length && args[0].getFunctionType();
    var defs6 = infer.cx().definitions.ecma6
    if (!fn || !defs6) return self;

    var result = new infer.Obj(defs6["Promise.prototype"]);
    var value = result.defProp(":t", argNodes && argNodes[0]), ty;
    if (fn.retval.isEmpty() && (ty = self.getType()) instanceof infer.Obj && ty.hasProp(":t"))
      ty.getProp(":t").propagate(value, WG_PROMISE_KEEP_VALUE);
    fn.retval.propagate(new PromiseResolvesTo(value));
    return result;
  });

  infer.registerFunction("getOwnPropertySymbols", function(_self, args) {
    if (!args.length) return infer.ANull
    var result = new infer.AVal
    args[0].forAllProps(function(prop, _val, local) {
      if (local && prop.charAt(0) == ":") result.addType(infer.getSymbol(prop.slice(1)))
    })
    return result
  })

  infer.registerFunction("getSymbol", function(_self, _args, argNodes) {
    if (argNodes.length && argNodes[0].type == "Literal" && typeof argNodes[0].value == "string")
      return infer.getSymbol(argNodes[0].value)
    else
      return infer.ANull
  })

  return exports;
});

});

define("tern/lib/signal",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports);
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports"], mod);
  mod((root.tern || (root.tern = {})).signal = {}); // Plain browser env
})(this, function(exports) {

  function on(type, f) {
    var handlers = this._handlers || (this._handlers = Object.create(null));
    (handlers[type] || (handlers[type] = [])).push(f);
  }

  function off(type, f) {
    var arr = this._handlers && this._handlers[type];
    if (arr) for (var i = 0; i < arr.length; ++i)
      if (arr[i] == f) { arr.splice(i, 1); break; }
  }

  var noHandlers = []
  function getHandlers(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length ? arr.slice() : noHandlers
  }

  function signal(type, a1, a2, a3, a4) {
    var arr = getHandlers(this, type)
    for (var i = 0; i < arr.length; ++i) arr[i].call(this, a1, a2, a3, a4)
  }

  function signalReturnFirst(type, a1, a2, a3, a4) {
    var arr = getHandlers(this, type)
    for (var i = 0; i < arr.length; ++i) {
      var result = arr[i].call(this, a1, a2, a3, a4)
      if (result) return result
    }
  }

  function hasHandler(type) {
    var arr = this._handlers && this._handlers[type]
    return arr && arr.length > 0 && arr
  }

  exports.mixin = function(obj) {
    obj.on = on; obj.off = off;
    obj.signal = signal;
    obj.signalReturnFirst = signalReturnFirst;
    obj.hasHandler = hasHandler;
    return obj;
  };
});

});

define("tern/lib/infer",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports, require("acorn"), require("acorn/dist/acorn_loose"), require("acorn/dist/walk"),
               require("./def"), require("./signal"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports", "acorn/dist/acorn", "acorn/dist/acorn_loose", "acorn/dist/walk", "./def", "./signal"], mod);
  mod(root.tern || (root.tern = {}), acorn, acorn, acorn.walk, tern.def, tern.signal); // Plain browser env
})(this, function(exports, acorn, acorn_loose, walk, def, signal) {
  "use strict";

  var toString = exports.toString = function(type, maxDepth, parent) {
    if (!type || type == parent || maxDepth && maxDepth < -3) return "?";
    return type.toString(maxDepth, parent);
  };
  var ANull = exports.ANull = signal.mixin({
    addType: function() {},
    propagate: function() {},
    getProp: function() { return ANull; },
    forAllProps: function() {},
    hasType: function() { return false; },
    isEmpty: function() { return true; },
    getFunctionType: function() {},
    getObjType: function() {},
    getSymbolType: function() {},
    getType: function() {},
    gatherProperties: function() {},
    propagatesTo: function() {},
    typeHint: function() {},
    propHint: function() {},
    toString: function() { return "?"; }
  });

  function extend(proto, props) {
    var obj = Object.create(proto);
    if (props) for (var prop in props) obj[prop] = props[prop];
    return obj;
  }
  var WG_DEFAULT = 100, WG_NEW_INSTANCE = 90, WG_MADEUP_PROTO = 10,
      WG_MULTI_MEMBER = 6, WG_CATCH_ERROR = 6,
      WG_PHANTOM_OBJ = 1,
      WG_GLOBAL_THIS = 90, WG_SPECULATIVE_THIS = 2, WG_SPECULATIVE_PROTO_THIS = 4;

  var AVal = exports.AVal = function() {
    this.types = [];
    this.forward = null;
    this.maxWeight = 0;
  };
  AVal.prototype = extend(ANull, {
    addType: function(type, weight) {
      weight = weight || WG_DEFAULT;
      if (this.maxWeight < weight) {
        this.maxWeight = weight;
        if (this.types.length == 1 && this.types[0] == type) return;
        this.types.length = 0;
      } else if (this.maxWeight > weight || this.types.indexOf(type) > -1) {
        return;
      }
      if (this.types.length > 5) {
        return;
      }
      this.signal("addType", type);
      this.types.push(type);
      var forward = this.forward;
      if (forward) withWorklist(function(add) {
        for (var i = 0; i < forward.length; ++i) add(type, forward[i], weight);
      });
    },

    propagate: function(target, weight) {
      if (target == ANull || (target instanceof Type && this.forward && this.forward.length > 2)) return;
      if (weight && weight != WG_DEFAULT) target = new Muffle(target, weight);
      (this.forward || (this.forward = [])).push(target);
      var types = this.types;
      if (types.length) withWorklist(function(add) {
        for (var i = 0; i < types.length; ++i) add(types[i], target, weight);
      });
    },

    getProp: function(prop) {
      if (prop == "__proto__" || prop == "✖") return ANull;
      var found = (this.props || (this.props = Object.create(null)))[prop];
      if (!found) {
        found = this.props[prop] = new AVal;
        this.propagate(new GetProp(prop, found));
      }
      return found;
    },

    forAllProps: function(c) {
      this.propagate(new ForAllProps(c));
    },

    hasType: function(type) {
      return this.types.indexOf(type) > -1;
    },
    isEmpty: function() { return this.types.length === 0; },
    getFunctionType: function() {
      for (var i = this.types.length - 1; i >= 0; --i)
        if (this.types[i] instanceof Fn) return this.types[i];
    },
    getObjType: function() {
      var seen = null;
      for (var i = this.types.length - 1; i >= 0; --i) {
        var type = this.types[i];
        if (!(type instanceof Obj)) continue;
        if (type.name) return type;
        if (!seen) seen = type;
      }
      return seen;
    },

    getSymbolType: function() {
      for (var i = this.types.length - 1; i >= 0; --i)
        if (this.types[i] instanceof Sym) return this.types[i]
    },

    getType: function(guess) {
      if (this.types.length === 0 && guess !== false) return this.makeupType();
      if (this.types.length === 1) return this.types[0];
      return canonicalType(this.types);
    },

    toString: function(maxDepth, parent) {
      if (this.types.length == 1) return toString(this.types[0], maxDepth, parent);
      var simplified = simplifyTypes(this.types);
      if (simplified.length > 2) return "?";
      return simplified.map(function(tp) { return toString(tp, maxDepth, parent); }).join("|");
    },

    makeupPropType: function(obj) {
      var propName = this.propertyName;

      var protoProp = obj.proto && obj.proto.hasProp(propName);
      if (protoProp) {
        var fromProto = protoProp.getType();
        if (fromProto) return fromProto;
      }

      if (propName != "<i>") {
        var computedProp = obj.hasProp("<i>");
        if (computedProp) return computedProp.getType();
      } else if (obj.props["<i>"] != this) {
        for (var prop in obj.props) {
          var val = obj.props[prop];
          if (!val.isEmpty()) return val.getType();
        }
      }
    },

    makeupType: function() {
      var computed = this.propertyOf && this.makeupPropType(this.propertyOf);
      if (computed) return computed;

      if (!this.forward) return null;
      for (var i = this.forward.length - 1; i >= 0; --i) {
        var hint = this.forward[i].typeHint();
        if (hint && !hint.isEmpty()) {guessing = true; return hint;}
      }

      var props = Object.create(null), foundProp = null;
      for (var i = 0; i < this.forward.length; ++i) {
        var prop = this.forward[i].propHint();
        if (prop && prop != "length" && prop != "<i>" && prop != "✖" && prop != cx.completingProperty) {
          props[prop] = true;
          foundProp = prop;
        }
      }
      if (!foundProp) return null;

      var objs = objsWithProp(foundProp);
      if (objs) {
        var matches = [];
        search: for (var i = 0; i < objs.length; ++i) {
          var obj = objs[i];
          for (var prop in props) if (!obj.hasProp(prop)) continue search;
          if (obj.hasCtor) obj = getInstance(obj);
          matches.push(obj);
        }
        var canon = canonicalType(matches);
        if (canon) {guessing = true; return canon;}
      }
    },

    typeHint: function() { return this.types.length ? this.getType() : null; },
    propagatesTo: function() { return this; },

    gatherProperties: function(f, depth) {
      for (var i = 0; i < this.types.length; ++i)
        this.types[i].gatherProperties(f, depth);
    },

    guessProperties: function(f) {
      var forward = this.forward;
      if (forward) for (var i = 0; i < forward.length; ++i) {
        var prop = forward[i].propHint();
        if (prop) f(prop, null, 0, function(rec) { if (forward[i].args) rec.type = "fn()?"; });
      }
      var guessed = this.makeupType();
      if (guessed) guessed.gatherProperties(f);
    }
  });

  function similarAVal(a, b, depth) {
    var typeA = a.getType(false), typeB = b.getType(false);
    if (!typeA || !typeB) return true;
    return similarType(typeA, typeB, depth);
  }

  function similarType(a, b, depth) {
    if (!a || depth >= 5) return b;
    if (!a || a == b) return a;
    if (!b) return a;
    if (a.constructor != b.constructor) return false;
    if (a.constructor == Arr) {
      var innerA = a.getProp("<i>").getType(false);
      if (!innerA) return b;
      var innerB = b.getProp("<i>").getType(false);
      if (!innerB || similarType(innerA, innerB, depth + 1)) return b;
    } else if (a.constructor == Obj) {
      var propsA = 0, propsB = 0, same = 0;
      for (var prop in a.props) {
        propsA++;
        if (prop in b.props && similarAVal(a.props[prop], b.props[prop], depth + 1))
          same++;
      }
      for (var prop in b.props) propsB++;
      if (propsA && propsB && same < Math.max(propsA, propsB) / 2) return false;
      return propsA > propsB ? a : b;
    } else if (a.constructor == Fn) {
      if (a.args.length != b.args.length ||
          !a.args.every(function(tp, i) { return similarAVal(tp, b.args[i], depth + 1); }) ||
          !similarAVal(a.retval, b.retval, depth + 1) || !similarAVal(a.self, b.self, depth + 1))
        return false;
      return a;
    } else {
      return false;
    }
  }

  var simplifyTypes = exports.simplifyTypes = function(types) {
    var found = [];
    outer: for (var i = 0; i < types.length; ++i) {
      var tp = types[i];
      for (var j = 0; j < found.length; j++) {
        var similar = similarType(tp, found[j], 0);
        if (similar) {
          found[j] = similar;
          continue outer;
        }
      }
      found.push(tp);
    }
    return found;
  };

  function canonicalType(types) {
    var arrays = 0, fns = 0, objs = 0, prim = null;
    for (var i = 0; i < types.length; ++i) {
      var tp = types[i];
      if (tp instanceof Arr) ++arrays;
      else if (tp instanceof Fn) ++fns;
      else if (tp instanceof Obj) ++objs;
      else if (tp instanceof Prim) {
        if (prim && tp.name != prim.name) return null;
        prim = tp;
      }
    }
    var kinds = (arrays && 1) + (fns && 1) + (objs && 1) + (prim && 1);
    if (kinds > 1) return null;
    if (prim) return prim;

    var maxScore = 0, maxTp = null;
    for (var i = 0; i < types.length; ++i) {
      var tp = types[i], score = 0;
      if (arrays) {
        score = tp.getProp("<i>").isEmpty() ? 1 : 2;
      } else if (fns) {
        score = 1;
        for (var j = 0; j < tp.args.length; ++j) if (!tp.args[j].isEmpty()) ++score;
        if (!tp.retval.isEmpty()) ++score;
      } else if (objs) {
        score = tp.name ? 100 : 2;
      }
      if (score >= maxScore) { maxScore = score; maxTp = tp; }
    }
    return maxTp;
  }
  var constraint = exports.constraint = function(methods) {
    var ctor = function() {
      this.origin = cx.curOrigin;
      this.construct.apply(this, arguments);
    };
    ctor.prototype = Object.create(ANull);
    for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];
    return ctor;
  };

  var GetProp = constraint({
    construct: function(prop, target) {
      this.prop = prop; this.target = target;
    },
    addType: function(type, weight) {
      if (type.getProp)
        type.getProp(this.prop).propagate(this.target, weight);
    },
    propHint: function() { return this.prop; },
    propagatesTo: function() {
      if (this.prop == "<i>" || !/[^\w_]/.test(this.prop))
        return {target: this.target, pathExt: "." + this.prop};
    }
  });

  var DefProp = exports.PropHasSubset = exports.DefProp = constraint({
    construct: function(prop, type, originNode) {
      this.prop = prop; this.type = type; this.originNode = originNode;
    },
    addType: function(type, weight) {
      if (!(type instanceof Obj)) return;
      var prop = type.defProp(this.prop, this.originNode);
      if (!prop.origin) prop.origin = this.origin;
      this.type.propagate(prop, weight);
    },
    propHint: function() { return this.prop; }
  });

  var ForAllProps = constraint({
    construct: function(c) { this.c = c; },
    addType: function(type) {
      if (!(type instanceof Obj)) return;
      type.forAllProps(this.c);
    }
  });

  function withDisabledComputing(fn, body) {
    cx.disabledComputing = {fn: fn, prev: cx.disabledComputing};
    var result = body();
    cx.disabledComputing = cx.disabledComputing.prev;
    return result;
  }
  var IsCallee = exports.IsCallee = constraint({
    construct: function(self, args, argNodes, retval) {
      this.self = self; this.args = args; this.argNodes = argNodes; this.retval = retval;
      this.disabled = cx.disabledComputing;
    },
    addType: function(fn, weight) {
      if (!(fn instanceof Fn)) return;
      for (var i = 0; i < this.args.length; ++i) {
        if (i < fn.args.length) this.args[i].propagate(fn.args[i], weight);
        if (fn.arguments) this.args[i].propagate(fn.arguments, weight);
      }
      this.self.propagate(fn.self, this.self == cx.topScope ? WG_GLOBAL_THIS : weight);
      var compute = fn.computeRet, result = fn.retval
      if (compute) for (var d = this.disabled; d; d = d.prev)
        if (d.fn == fn || fn.originNode && d.fn.originNode == fn.originNode) compute = null;
      if (compute) {
        var old = cx.disabledComputing;
        cx.disabledComputing = this.disabled;
        result = compute(this.self, this.args, this.argNodes)
        cx.disabledComputing = old;
      }
      maybeIterator(fn, result).propagate(this.retval, weight)
    },
    typeHint: function() {
      var names = [];
      for (var i = 0; i < this.args.length; ++i) names.push("?");
      return new Fn(null, this.self, this.args, names, ANull);
    },
    propagatesTo: function() {
      return {target: this.retval, pathExt: ".!ret"};
    }
  });

  var HasMethodCall = constraint({
    construct: function(propName, args, argNodes, retval) {
      this.propName = propName; this.args = args; this.argNodes = argNodes; this.retval = retval;
      this.disabled = cx.disabledComputing;
    },
    addType: function(obj, weight) {
      var callee = new IsCallee(obj, this.args, this.argNodes, this.retval);
      callee.disabled = this.disabled;
      obj.getProp(this.propName).propagate(callee, weight);
    },
    propHint: function() { return this.propName; }
  });

  var IsCtor = exports.IsCtor = constraint({
    construct: function(target, noReuse) {
      this.target = target; this.noReuse = noReuse;
    },
    addType: function(f, weight) {
      if (!(f instanceof Fn)) return;
      if (cx.parent && !cx.parent.options.reuseInstances) this.noReuse = true;
      f.getProp("prototype").propagate(new IsProto(this.noReuse ? false : f, this.target), weight);
    }
  });

  var getInstance = exports.getInstance = function(obj, ctor) {
    if (ctor === false) return new Obj(obj);

    if (!ctor) ctor = obj.hasCtor;
    if (!obj.instances) obj.instances = [];
    for (var i = 0; i < obj.instances.length; ++i) {
      var cur = obj.instances[i];
      if (cur.ctor == ctor) return cur.instance;
    }
    var instance = new Obj(obj, ctor && ctor.name);
    instance.origin = obj.origin;
    obj.instances.push({ctor: ctor, instance: instance});
    return instance;
  };

  var IsProto = exports.IsProto = constraint({
    construct: function(ctor, target) {
      this.ctor = ctor; this.target = target;
    },
    addType: function(o, _weight) {
      if (!(o instanceof Obj)) return;
      if ((this.count = (this.count || 0) + 1) > 8) return;
      if (o == cx.protos.Array)
        this.target.addType(new Arr);
      else
        this.target.addType(getInstance(o, this.ctor));
    }
  });

  var FnPrototype = constraint({
    construct: function(fn) { this.fn = fn; },
    addType: function(o, _weight) {
      if (o instanceof Obj && !o.hasCtor) {
        o.hasCtor = this.fn;
        var adder = new SpeculativeThis(o, this.fn);
        adder.addType(this.fn);
        o.forAllProps(function(_prop, val, local) {
          if (local) val.propagate(adder);
        });
      }
    }
  });

  var IsAdded = constraint({
    construct: function(other, target) {
      this.other = other; this.target = target;
    },
    addType: function(type, weight) {
      if (type == cx.str)
        this.target.addType(cx.str, weight);
      else if (type == cx.num && this.other.hasType(cx.num))
        this.target.addType(cx.num, weight);
    },
    typeHint: function() { return this.other; }
  });

  var IfObj = exports.IfObj = constraint({
    construct: function(target) { this.target = target; },
    addType: function(t, weight) {
      if (t instanceof Obj) this.target.addType(t, weight);
    },
    propagatesTo: function() { return this.target; }
  });

  var SpeculativeThis = constraint({
    construct: function(obj, ctor) { this.obj = obj; this.ctor = ctor; },
    addType: function(tp) {
      if (tp instanceof Fn && tp.self)
        tp.self.addType(getInstance(this.obj, this.ctor), WG_SPECULATIVE_PROTO_THIS);
    }
  });

  var HasProto = constraint({
    construct: function(obj) { this.obj = obj },
    addType: function(tp) {
      if (tp instanceof Obj && this.obj.proto == cx.protos.Object)
        this.obj.replaceProto(tp)
    }
  });

  var Muffle = constraint({
    construct: function(inner, weight) {
      this.inner = inner; this.weight = weight;
    },
    addType: function(tp, weight) {
      this.inner.addType(tp, Math.min(weight, this.weight));
    },
    propagatesTo: function() { return this.inner.propagatesTo(); },
    typeHint: function() { return this.inner.typeHint(); },
    propHint: function() { return this.inner.propHint(); }
  });
  var Type = exports.Type = function() {};
  Type.prototype = extend(ANull, {
    constructor: Type,
    propagate: function(c, w) { c.addType(this, w); },
    hasType: function(other) { return other == this; },
    isEmpty: function() { return false; },
    typeHint: function() { return this; },
    getType: function() { return this; }
  });

  var Prim = exports.Prim = function(proto, name) { this.name = name; this.proto = proto; };
  Prim.prototype = extend(Type.prototype, {
    constructor: Prim,
    toString: function() { return this.name; },
    getProp: function(prop) {return this.proto.hasProp(prop) || ANull;},
    gatherProperties: function(f, depth) {
      if (this.proto) this.proto.gatherProperties(f, depth);
    }
  });

  function isInteger(str) {
    var c0 = str.charCodeAt(0)
    if (c0 >= 48 && c0 <= 57) return !/\D/.test(str)
    else return false
  }

  var Obj = exports.Obj = function(proto, name) {
    if (!this.props) this.props = Object.create(null);
    this.proto = proto === true ? cx.protos.Object : proto;
    if (this.proto && !(this.proto instanceof Obj)) {
      throw new Error("bad " + Object.keys(this.proto).join())
    }
    if (proto && !name && proto.name && !(this instanceof Fn)) {
      var match = /^(.*)\.prototype$/.exec(this.proto.name);
      if (match) name = match[1];
    }
    this.name = name;
    this.maybeProps = null;
    this.origin = cx.curOrigin;
  };
  Obj.prototype = extend(Type.prototype, {
    constructor: Obj,
    toString: function(maxDepth) {
      if (maxDepth == null) maxDepth = 0;
      if (maxDepth <= 0 && this.name) return this.name;
      var props = [], etc = false;
      for (var prop in this.props) if (prop != "<i>") {
        if (props.length > 5) { etc = true; break; }
        if (maxDepth)
          props.push(prop + ": " + toString(this.props[prop], maxDepth - 1, this));
        else
          props.push(prop);
      }
      props.sort();
      if (etc) props.push("...");
      return "{" + props.join(", ") + "}";
    },
    hasProp: function(prop, searchProto) {
      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)
      var found = this.props[prop];
      if (searchProto !== false)
        for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];
      return found;
    },
    defProp: function(prop, originNode) {
      var found = this.hasProp(prop, false);
      if (found) {
        if (originNode && !found.originNode) found.originNode = originNode;
        return found;
      }
      if (prop == "__proto__" || prop == "✖") return ANull;
      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)

      var av = this.maybeProps && this.maybeProps[prop];
      if (av) {
        delete this.maybeProps[prop];
        this.maybeUnregProtoPropHandler();
      } else {
        av = new AVal;
        av.propertyOf = this;
        av.propertyName = prop;
      }

      this.props[prop] = av;
      av.originNode = originNode;
      av.origin = cx.curOrigin;
      this.broadcastProp(prop, av, true);
      return av;
    },
    getProp: function(prop) {
      var found = this.hasProp(prop, true) || (this.maybeProps && this.maybeProps[prop]);
      if (found) return found;
      if (prop == "__proto__" || prop == "✖") return ANull;
      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)
      var av = this.ensureMaybeProps()[prop] = new AVal;
      av.propertyOf = this;
      av.propertyName = prop;
      return av;
    },
    normalizeIntegerProp: function(_) { return "<i>" },
    broadcastProp: function(prop, val, local) {
      if (local) {
        this.signal("addProp", prop, val);
        if (!(this instanceof Scope)) registerProp(prop, this);
      }

      if (this.onNewProp) for (var i = 0; i < this.onNewProp.length; ++i) {
        var h = this.onNewProp[i];
        h.onProtoProp ? h.onProtoProp(prop, val, local) : h(prop, val, local);
      }
    },
    onProtoProp: function(prop, val, _local) {
      var maybe = this.maybeProps && this.maybeProps[prop];
      if (maybe) {
        delete this.maybeProps[prop];
        this.maybeUnregProtoPropHandler();
        this.proto.getProp(prop).propagate(maybe);
      }
      this.broadcastProp(prop, val, false);
    },
    replaceProto: function(proto) {
      if (this.proto && this.maybeProps)
        this.proto.unregPropHandler(this)
      this.proto = proto
      if (this.maybeProps)
        this.proto.forAllProps(this)
    },
    ensureMaybeProps: function() {
      if (!this.maybeProps) {
        if (this.proto) this.proto.forAllProps(this);
        this.maybeProps = Object.create(null);
      }
      return this.maybeProps;
    },
    removeProp: function(prop) {
      var av = this.props[prop];
      delete this.props[prop];
      this.ensureMaybeProps()[prop] = av;
      av.types.length = 0;
    },
    forAllProps: function(c) {
      if (!this.onNewProp) {
        this.onNewProp = [];
        if (this.proto) this.proto.forAllProps(this);
      }
      this.onNewProp.push(c);
      for (var o = this; o; o = o.proto) for (var prop in o.props) {
        if (c.onProtoProp)
          c.onProtoProp(prop, o.props[prop], o == this);
        else
          c(prop, o.props[prop], o == this);
      }
    },
    maybeUnregProtoPropHandler: function() {
      if (this.maybeProps) {
        for (var _n in this.maybeProps) return;
        this.maybeProps = null;
      }
      if (!this.proto || this.onNewProp && this.onNewProp.length) return;
      this.proto.unregPropHandler(this);
    },
    unregPropHandler: function(handler) {
      for (var i = 0; i < this.onNewProp.length; ++i)
        if (this.onNewProp[i] == handler) { this.onNewProp.splice(i, 1); break; }
      this.maybeUnregProtoPropHandler();
    },
    gatherProperties: function(f, depth) {
      for (var prop in this.props) if (prop != "<i>" && prop.charAt(0) != ":")
        f(prop, this, depth);
      if (this.proto) this.proto.gatherProperties(f, depth + 1);
    },
    getObjType: function() { return this; }
  });

  var Fn = exports.Fn = function(name, self, args, argNames, retval, generator) {
    Obj.call(this, cx.protos.Function, name);
    this.self = self;
    this.args = args;
    this.argNames = argNames;
    this.retval = retval;
    this.generator = generator
  };
  Fn.prototype = extend(Obj.prototype, {
    constructor: Fn,
    toString: function(maxDepth) {
      if (maxDepth == null) maxDepth = 0;
      var str = this.generator ? "fn*(" : "fn(";
      for (var i = 0; i < this.args.length; ++i) {
        if (i) str += ", ";
        var name = this.argNames[i];
        if (name && name != "?") str += name + ": ";
        str += maxDepth > -3 ? toString(this.args[i], maxDepth - 1, this) : "?";
      }
      str += ")";
      if (!this.retval.isEmpty())
        str += " -> " + (maxDepth > -3 ? toString(this.retval, maxDepth - 1, this) : "?");
      return str;
    },
    getProp: function(prop) {
      if (prop == "prototype") {
        var known = this.hasProp(prop, false);
        if (!known) {
          known = this.defProp(prop);
          var proto = new Obj(true, this.name && this.name + ".prototype");
          proto.origin = this.origin;
          known.addType(proto, WG_MADEUP_PROTO);
        }
        return known;
      }
      return Obj.prototype.getProp.call(this, prop);
    },
    defProp: function(prop, originNode) {
      if (prop == "prototype") {
        var found = this.hasProp(prop, false);
        if (found) return found;
        found = Obj.prototype.defProp.call(this, prop, originNode);
        found.origin = this.origin;
        found.propagate(new FnPrototype(this));
        return found;
      }
      return Obj.prototype.defProp.call(this, prop, originNode);
    },
    getFunctionType: function() { return this; }
  });

  var Arr = exports.Arr = function(contentType) {
    Obj.call(this, cx.protos.Array)
    var content = this.defProp("<i>")
    if (Array.isArray(contentType)) {
      this.tuple = contentType.length
      for (var i = 0; i < contentType.length; i++) {
        var prop = this.defProp(String(i))
        contentType[i].propagate(prop)
        prop.propagate(content)
      }
    } else if (contentType) {
      this.tuple = 0
      contentType.propagate(content)
    }
  };
  Arr.prototype = extend(Obj.prototype, {
    constructor: Arr,
    toString: function(maxDepth) {
      if (maxDepth == null) maxDepth = 0
      if (maxDepth <= -3) return "[?]"
      var content = ""
      if (this.tuple) {
        var similar
        for (var i = 0; i in this.props; i++) {
          var type = toString(this.getProp(String(i)), maxDepth - 1, this)
          if (similar == null)
            similar = type
          else if (similar != type)
            similar = false
          else
            similar = type
          content += (content ? ", " : "") + type
        }
        if (similar) content = similar
      } else {
        content = toString(this.getProp("<i>"), maxDepth - 1, this)
      }
      return "[" + content + "]"
    },
    normalizeIntegerProp: function(prop) {
      if (+prop < this.tuple) return prop
      else return "<i>"
    }
  });

  var Sym = exports.Sym = function(name, originNode) {
    Prim.call(this, cx.protos.Symbol, "Symbol")
    this.symName = name
    this.originNode = originNode
  }
  Sym.prototype = extend(Prim.prototype, {
    constructor: Sym,
    asPropName: function() { return ":" + this.symName },
    getSymbolType: function() { return this }
  })

  exports.getSymbol = function(name, originNode) {
    var cleanName = name.replace(/[^\w$\.]/g, "_")
    var known = cx.symbols[cleanName]
    if (known) {
      if (originNode && !known.originNode) known.originNode = originNode
      return known
    }
    return cx.symbols[cleanName] = new Sym(cleanName, originNode)
  }
  function registerProp(prop, obj) {
    var data = cx.props[prop] || (cx.props[prop] = []);
    data.push(obj);
  }

  function objsWithProp(prop) {
    return cx.props[prop];
  }
  exports.Context = function(defs, parent) {
    this.parent = parent;
    this.props = Object.create(null);
    this.protos = Object.create(null);
    this.origins = [];
    this.curOrigin = "ecma5";
    this.paths = Object.create(null);
    this.definitions = Object.create(null);
    this.purgeGen = 0;
    this.workList = null;
    this.disabledComputing = null;
    this.curSuperCtor = this.curSuper = null;
    this.symbols = Object.create(null)

    exports.withContext(this, function() {
      cx.protos.Object = new Obj(null, "Object.prototype");
      cx.topScope = new Scope();
      cx.topScope.name = "<top>";
      cx.protos.Array = new Obj(true, "Array.prototype");
      cx.protos.Function = new Fn("Function.prototype", ANull, [], [], ANull);
      cx.protos.Function.proto = cx.protos.Object;
      cx.protos.RegExp = new Obj(true, "RegExp.prototype");
      cx.protos.String = new Obj(true, "String.prototype");
      cx.protos.Number = new Obj(true, "Number.prototype");
      cx.protos.Boolean = new Obj(true, "Boolean.prototype");
      cx.protos.Symbol = new Obj(true, "Symbol.prototype");
      cx.str = new Prim(cx.protos.String, "string");
      cx.bool = new Prim(cx.protos.Boolean, "bool");
      cx.num = new Prim(cx.protos.Number, "number");
      cx.curOrigin = null;

      if (defs) for (var i = 0; i < defs.length; ++i)
        def.load(defs[i]);
    });
  };

  exports.Context.prototype.startAnalysis = function() {
    this.disabledComputing = this.workList = this.curSuperCtor = this.curSuper = null;
  };

  var cx = null;
  exports.cx = function() { return cx; };

  exports.withContext = function(context, f) {
    var old = cx;
    cx = context;
    try { return f(); }
    finally { cx = old; }
  };

  exports.TimedOut = function() {
    this.message = "Timed out";
    this.stack = (new Error()).stack;
  };
  exports.TimedOut.prototype = Object.create(Error.prototype);
  exports.TimedOut.prototype.name = "infer.TimedOut";

  var timeout;
  exports.withTimeout = function(ms, f) {
    var end = +new Date + ms;
    var oldEnd = timeout;
    if (oldEnd && oldEnd < end) return f();
    timeout = end;
    try { return f(); }
    finally { timeout = oldEnd; }
  };

  exports.addOrigin = function(origin) {
    if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);
  };

  var baseMaxWorkDepth = 20, reduceMaxWorkDepth = 0.0001;
  function withWorklist(f) {
    if (cx.workList) return f(cx.workList);

    var list = [], depth = 0;
    var add = cx.workList = function(type, target, weight) {
      if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length)
        list.push(type, target, weight, depth);
    };
    var ret = f(add);
    for (var i = 0; i < list.length; i += 4) {
      if (timeout && +new Date >= timeout)
        throw new exports.TimedOut();
      depth = list[i + 3] + 1;
      list[i + 1].addType(list[i], list[i + 2]);
    }
    cx.workList = null;
    return ret;
  }

  function withSuper(ctor, obj, f) {
    var oldCtor = cx.curSuperCtor, oldObj = cx.curSuper
    cx.curSuperCtor = ctor; cx.curSuper = obj
    var result = f()
    cx.curSuperCtor = oldCtor; cx.curSuper = oldObj
    return result
  }
  var Scope = exports.Scope = function(prev, originNode, isBlock) {
    Obj.call(this, prev || true);
    this.prev = prev;
    this.originNode = originNode
    this.isBlock = !!isBlock
  };
  Scope.prototype = extend(Obj.prototype, {
    constructor: Scope,
    defVar: function(name, originNode) {
      for (var s = this; ; s = s.proto) {
        var found = s.props[name];
        if (found) return found;
        if (!s.prev) return s.defProp(name, originNode);
      }
    }
  });

  function functionScope(scope) {
    while (scope.isBlock) scope = scope.prev
    return scope
  }
  function maybeInstantiate(scope, score) {
    var fn = functionScope(scope).fnType
    if (fn) fn.instantiateScore = (fn.instantiateScore || 0) + score;
  }

  var NotSmaller = {};
  function nodeSmallerThan(node, n) {
    try {
      walk.simple(node, {Expression: function() { if (--n <= 0) throw NotSmaller; }});
      return true;
    } catch(e) {
      if (e == NotSmaller) return false;
      throw e;
    }
  }

  function maybeTagAsInstantiated(node, fn) {
    var score = fn.instantiateScore;
    if (!cx.disabledComputing && score && fn.args.length && nodeSmallerThan(node, score * 5)) {
      maybeInstantiate(functionScope(fn.originNode.scope.prev), score / 2);
      setFunctionInstantiated(node, fn);
      return true;
    } else {
      fn.instantiateScore = null;
    }
  }

  function setFunctionInstantiated(node, fn) {
    for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal;
    fn.self = new AVal;
    fn.computeRet = function(self, args) {
      return withDisabledComputing(fn, function() {
        var oldOrigin = cx.curOrigin;
        cx.curOrigin = fn.origin;
        var scope = node.scope
        var scopeCopy = new Scope(scope.prev, scope.originNode);
        for (var v in scope.props) {
          var local = scopeCopy.defProp(v, scope.props[v].originNode);
          for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length)
            args[i].propagate(local);
        }
        var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;
        while (argNames.length < args.length) argNames.push("?");
        scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull, fn.generator);
        scopeCopy.fnType.originNode = fn.originNode;
        if (fn.arguments) {
          var argset = scopeCopy.fnType.arguments = new AVal;
          scopeCopy.defProp("arguments").addType(new Arr(argset));
          for (var i = 0; i < args.length; ++i) args[i].propagate(argset);
        }
        node.scope = scopeCopy;
        walk.recursive(node.body, scopeCopy, null, scopeGatherer);
        walk.recursive(node.body, scopeCopy, null, inferWrapper);
        cx.curOrigin = oldOrigin;
        return scopeCopy.fnType.retval;
      });
    };
  }

  function maybeTagAsGeneric(fn) {
    var target = fn.retval;
    if (target == ANull) return;
    var targetInner, asArray;
    if (!target.isEmpty() && (targetInner = target.getType()) instanceof Arr)
      target = asArray = targetInner.getProp("<i>");

    function explore(aval, path, depth) {
      if (depth > 3 || !aval.forward) return;
      for (var i = 0; i < aval.forward.length; ++i) {
        var prop = aval.forward[i].propagatesTo();
        if (!prop) continue;
        var newPath = path, dest;
        if (prop instanceof AVal) {
          dest = prop;
        } else if (prop.target instanceof AVal) {
          newPath += prop.pathExt;
          dest = prop.target;
        } else continue;
        if (dest == target) return newPath;
        var found = explore(dest, newPath, depth + 1);
        if (found) return found;
      }
    }

    var foundPath = explore(fn.self, "!this", 0);
    for (var i = 0; !foundPath && i < fn.args.length; ++i)
      foundPath = explore(fn.args[i], "!" + i, 0);

    if (foundPath) {
      if (asArray) foundPath = "[" + foundPath + "]";
      var p = new def.TypeParser(foundPath);
      var parsed = p.parseType(true);
      fn.computeRet = parsed.apply ? parsed : function() { return parsed; };
      fn.computeRetSource = foundPath;
      return true;
    }
  }
  function addVar(scope, nameNode) {
    return scope.defProp(nameNode.name, nameNode);
  }
  function patternName(node) {
    if (node.type == "Identifier") return node.name
    if (node.type == "AssignmentPattern") return patternName(node.left)
    if (node.type == "ObjectPattern") return "{" + node.properties.map(function(e) { return patternName(e.value) }).join(", ") + "}"
    if (node.type == "ArrayPattern") return "[" + node.elements.map(patternName).join(", ") + "]"
    if (node.type == "RestElement") return "..." + patternName(node.argument)
    return "_"
  }

  function isBlockScopedDecl(node) {
    return node.type == "VariableDeclaration" && node.kind != "var" ||
      node.type == "FunctionDeclaration" ||
      node.type == "ClassDeclaration";
  }

  function patternScopes(inner, outer) {
    return {inner: inner, outer: outer || inner}
  }

  var scopeGatherer = exports.scopeGatherer = walk.make({
    VariablePattern: function(node, scopes) {
      if (scopes.inner) addVar(scopes.inner, node)
    },
    AssignmentPattern: function(node, scopes, c) {
      c(node.left, scopes, "Pattern")
      c(node.right, scopes.outer, "Expression")
    },
    AssignmentExpression: function(node, scope, c) {
      if (node.left.type == "MemberExpression")
        c(node.left, scope, "Expression")
      else
        c(node.left, patternScopes(false, scope), "Pattern")
      c(node.right, scope, "Expression")
    },
    Function: function(node, scope, c) {
      if (scope.inner) throw new Error("problem at " + node.start + " " + node.type)
      var inner = node.scope = new Scope(scope, node)
      var argVals = [], argNames = []
      for (var i = 0; i < node.params.length; ++i) {
        var param = node.params[i]
        argNames.push(patternName(param))
        if (param.type == "Identifier") {
          argVals.push(addVar(inner, param))
        } else {
          var arg = new AVal
          argVals.push(arg)
          arg.originNode = param
          c(param, patternScopes(inner), "Pattern")
        }
      }
      inner.fnType = new Fn(node.id && node.id.name, new AVal, argVals, argNames, ANull, node.generator)
      inner.fnType.originNode = node;
      if (node.id) {
        var decl = node.type == "FunctionDeclaration";
        addVar(decl ? scope : inner, node.id);
      }
      c(node.body, inner, node.expression ? "Expression" : "Statement");
    },
    BlockStatement: function(node, scope, c) {
      if (!node.scope && node.body.some(isBlockScopedDecl))
        scope = node.scope = new Scope(scope, node, true)
      walk.base.BlockStatement(node, scope, c)
    },
    TryStatement: function(node, scope, c) {
      c(node.block, scope, "Statement");
      if (node.handler) {
        if (node.handler.param.type == "Identifier") {
          var v = addVar(scope, node.handler.param);
          c(node.handler.body, scope, "Statement");
          var e5 = cx.definitions.ecma5;
          if (e5 && v.isEmpty()) getInstance(e5["Error.prototype"]).propagate(v, WG_CATCH_ERROR);
        } else {
          c(node.handler.param, patternScopes(scope), "Pattern")
        }
      }
      if (node.finalizer) c(node.finalizer, scope, "Statement");
    },
    VariableDeclaration: function(node, scope, c) {
      var targetScope = node.kind == "var" ? functionScope(scope) : scope
      for (var i = 0; i < node.declarations.length; ++i) {
        var decl = node.declarations[i];
        c(decl.id, patternScopes(targetScope, scope), "Pattern")
        if (decl.init) c(decl.init, scope, "Expression");
      }
    },
    ClassDeclaration: function(node, scope, c) {
      addVar(scope, node.id)
      if (node.superClass) c(node.superClass, scope, "Expression")
      for (var i = 0; i < node.body.body.length; i++)
        c(node.body.body[i], scope)
    },
    ForInStatement: function(node, scope, c) {
      if (!node.scope && isBlockScopedDecl(node.left))
        scope = node.scope = new Scope(scope, node, true)
      walk.base.ForInStatement(node, scope, c)
    },
    ForStatement: function(node, scope, c) {
      if (!node.scope && node.init && isBlockScopedDecl(node.init))
        scope = node.scope = new Scope(scope, node, true)
      walk.base.ForStatement(node, scope, c)
    },
    ImportDeclaration: function(node, scope) {
      for (var i = 0; i < node.specifiers.length; i++)
        addVar(scope, node.specifiers[i].local)
    }
  });
  scopeGatherer.ForOfStatement = scopeGatherer.ForInStatement
  var propName = exports.propName = function(node, inferInScope) {
    var key = node.property || node.key;
    if (!node.computed && key.type == "Identifier") return key.name;
    if (key.type == "Literal") {
      if (typeof key.value == "string") return key.value
      if (typeof key.value == "number") return String(key.value)
    }
    if (inferInScope) {
      var symName = symbolName(infer(key, inferInScope))
      if (symName) return node.propName = symName
    } else if (node.propName) {
      return node.propName
    }
    return "<i>";
  }
  function symbolName(val) {
    var sym = val.getSymbolType()
    if (sym) return sym.asPropName()
  }

  function unopResultType(op) {
    switch (op) {
    case "+": case "-": case "~": return cx.num;
    case "!": return cx.bool;
    case "typeof": return cx.str;
    case "void": case "delete": return ANull;
    }
  }
  function binopIsBoolean(op) {
    switch (op) {
    case "==": case "!=": case "===": case "!==": case "<": case ">": case ">=": case "<=":
    case "in": case "instanceof": return true;
    }
  }
  function literalType(node) {
    if (node.regex) return getInstance(cx.protos.RegExp);
    switch (typeof node.value) {
    case "boolean": return cx.bool;
    case "number": return cx.num;
    case "string": return cx.str;
    case "object":
    case "function":
      if (!node.value) return ANull;
      return getInstance(cx.protos.RegExp);
    }
  }

  function join(a, b) {
    if (a == b || b == ANull) return a
    if (a == ANull) return b
    var joined = new AVal
    a.propagate(joined)
    b.propagate(joined)
    return joined
  }

  function connectParams(node, scope) {
    for (var i = 0; i < node.params.length; i++) {
      var param = node.params[i]
      if (param.type == "Identifier") continue
      connectPattern(param, scope, node.scope.fnType.args[i])
    }
  }

  function ensureVar(node, scope) {
    return scope.hasProp(node.name) || cx.topScope.defProp(node.name, node)
  }

  var inferPatternVisitor = exports.inferPatternVisitor = {
    Identifier: function(node, scope, source) {
      source.propagate(ensureVar(node, scope))
    },
    MemberExpression: function(node, scope, source) {
      var obj = infer(node.object, scope)
      var pName = propName(node, scope)
      obj.propagate(new DefProp(pName, source, node.property))
    },
    RestElement: function(node, scope, source) {
      connectPattern(node.argument, scope, new Arr(source))
    },
    ObjectPattern: function(node, scope, source) {
      for (var i = 0; i < node.properties.length; ++i) {
        var prop = node.properties[i]
        connectPattern(prop.value, scope, source.getProp(prop.key.name))
      }
    },
    ArrayPattern: function(node, scope, source) {
      for (var i = 0; i < node.elements.length; i++)
        if (node.elements[i])
          connectPattern(node.elements[i], scope, source.getProp(String(i)))
    },
    AssignmentPattern: function(node, scope, source) {
      connectPattern(node.left, scope, join(source, infer(node.right, scope)))
    }
  }

  function connectPattern(node, scope, source) {
    var connecter = inferPatternVisitor[node.type]
    if (connecter) connecter(node, scope, source)
  }

  function getThis(scope) {
    var fnScope = functionScope(scope)
    return fnScope.fnType ? fnScope.fnType.self : fnScope
  }

  function maybeAddPhantomObj(obj) {
    if (!obj.isEmpty() || !obj.propertyOf) return
    obj.propertyOf.getProp(obj.propertyName).addType(new Obj, WG_PHANTOM_OBJ)
    maybeAddPhantomObj(obj.propertyOf)
  }

  function inferClass(node, scope, name) {
    if (!name && node.id) name = node.id.name

    var sup = cx.protos.Object, supCtor, delayed
    if (node.superClass) {
      if (node.superClass.type == "Literal" && node.superClass.value == null) {
        sup = null
      } else {
        var supVal = infer(node.superClass, scope), supProto
        supCtor = supVal.getFunctionType()
        if (supCtor && (supProto = supCtor.getProp("prototype").getObjType())) {
          sup = supProto
        } else {
          supCtor = supVal
          delayed = supVal.getProp("prototype")
        }
      }
    }
    var proto = new Obj(sup, name && name + ".prototype")
    if (delayed) delayed.propagate(new HasProto(proto))

    return withSuper(supCtor, delayed || sup, function() {
      var ctor, body = node.body.body
      for (var i = 0; i < body.length; i++)
        if (body[i].kind == "constructor") ctor = body[i].value
      var fn = node.objType = ctor ? infer(ctor, scope) : new Fn(name, ANull, [], null, ANull)
      fn.originNode = node.id || ctor || node

      var inst = getInstance(proto, fn)
      fn.self.addType(inst)
      fn.defProp("prototype", node).addType(proto)
      for (var i = 0; i < body.length; i++) {
        var method = body[i], target
        if (method.kind == "constructor") continue
        var pName = propName(method, scope)
        if (pName == "<i>" || method.kind == "set") {
          target = ANull
        } else {
          target = (method.static ? fn : proto).defProp(pName, method.key)
          target.initializer = true
          if (method.kind == "get") target = new IsCallee(inst, [], null, target)
        }
        infer(method.value, scope, target)
        var methodFn = target.getFunctionType()
        if (methodFn) methodFn.self.addType(inst)
      }
      return fn
    })
  }

  function arrayLiteralType(elements, scope, inner) {
    var tuple = elements.length > 1 && elements.length < 6
    if (tuple) {
      var homogenous = true, litType
      for (var i = 0; i < elements.length; i++) {
        var elt = elements[i]
        if (!elt)
          tuple = false
        else if (elt.type != "Literal" || (litType && litType != typeof elt.value))
          homogenous = false
        else
          litType = typeof elt.value
      }
      if (homogenous) tuple = false
    }

    if (tuple) {
      var types = []
      for (var i = 0; i < elements.length; ++i)
        types.push(inner(elements[i], scope))
      return new Arr(types)
    } else if (elements.length < 2) {
      return new Arr(elements[0] && inner(elements[0], scope))
    } else {
      var eltVal = new AVal
      for (var i = 0; i < elements.length; i++)
        if (elements[i]) inner(elements[i], scope).propagate(eltVal)
      return new Arr(eltVal)
    }
  }

  function ret(f) {
    return function(node, scope, out, name) {
      var r = f(node, scope, name);
      if (out) r.propagate(out);
      return r;
    };
  }
  function fill(f) {
    return function(node, scope, out, name) {
      if (!out) out = new AVal;
      f(node, scope, out, name);
      return out;
    };
  }

  var inferExprVisitor = exports.inferExprVisitor = {
    ArrayExpression: ret(function(node, scope) {
      return arrayLiteralType(node.elements, scope, infer)
    }),
    ObjectExpression: ret(function(node, scope, name) {
      var proto = true, waitForProto
      for (var i = 0; i < node.properties.length; ++i) {
        var prop = node.properties[i]
        if (prop.key.name == "__proto__") {
          if (prop.value.type == "Literal" && prop.value.value == null) {
            proto = null
          } else {
            var protoVal = infer(prop.value, scope), known = protoVal.getObjType()
            if (known) proto = known
            else waitForProto = protoVal
          }
        }
      }

      var obj = node.objType = new Obj(proto, name);
      if (waitForProto) waitForProto.propagate(new HasProto(obj))
      obj.originNode = node;

      withSuper(null, waitForProto || proto, function() {
        for (var i = 0; i < node.properties.length; ++i) {
          var prop = node.properties[i], key = prop.key;
          if (prop.value.name == "✖" || prop.key.name == "__proto__") continue;

          var name = propName(prop, scope), target
          if (name == "<i>" || prop.kind == "set") {
            target = ANull;
          } else {
            var val = target = obj.defProp(name, key);
            val.initializer = true;
            if (prop.kind == "get")
              target = new IsCallee(obj, [], null, val);
          }
          infer(prop.value, scope, target, name);
          if (prop.value.type == "FunctionExpression")
            prop.value.scope.fnType.self.addType(obj, WG_SPECULATIVE_THIS);
        }
      })
      return obj;
    }),
    FunctionExpression: ret(function(node, scope, name) {
      var inner = node.scope, fn = inner.fnType;
      if (name && !fn.name) fn.name = name;
      connectParams(node, inner)
      if (node.expression)
        infer(node.body, inner, inner.fnType.retval = new AVal)
      else
        walk.recursive(node.body, inner, null, inferWrapper, "Statement")
      if (node.type == "ArrowFunctionExpression") {
        getThis(scope).propagate(fn.self)
        fn.self = ANull
      }
      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);
      if (node.id) inner.getProp(node.id.name).addType(fn);
      return fn;
    }),
    ClassExpression: ret(inferClass),
    SequenceExpression: ret(function(node, scope) {
      for (var i = 0, l = node.expressions.length - 1; i < l; ++i)
        infer(node.expressions[i], scope, ANull);
      return infer(node.expressions[l], scope);
    }),
    UnaryExpression: ret(function(node, scope) {
      infer(node.argument, scope, ANull);
      return unopResultType(node.operator);
    }),
    SpreadExpression: ret(function(node, scope) {
      return infer(node.argument, scope, ANull); // TODO: fixme
    }),
    SpreadElement: ret(function(node, scope) {
      return infer(node.argument, scope, ANull); // TODO: fixme
    }),
    UpdateExpression: ret(function(node, scope) {
      infer(node.argument, scope, ANull);
      return cx.num;
    }),
    BinaryExpression: ret(function(node, scope) {
      if (node.operator == "+") {
        var lhs = infer(node.left, scope);
        var rhs = infer(node.right, scope);
        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
        if (lhs.hasType(cx.num) && rhs.hasType(cx.num)) return cx.num;
        var result = new AVal;
        lhs.propagate(new IsAdded(rhs, result));
        rhs.propagate(new IsAdded(lhs, result));
        return result;
      } else {
        infer(node.left, scope, ANull);
        infer(node.right, scope, ANull);
        return binopIsBoolean(node.operator) ? cx.bool : cx.num;
      }
    }),
    AssignmentExpression: ret(function(node, scope, name) {
      var rhs, pName;
      if (node.left.type == "MemberExpression") {
        pName = propName(node.left, scope)
        if (!name)
          name = node.left.object.type == "Identifier" ? node.left.object.name + "." + pName : pName
      } else if (!name && node.left.type == "Identifier") {
        name = node.left.name
      }

      if (node.operator && node.operator != "=" && node.operator != "+=") {
        infer(node.right, scope, ANull);
        rhs = cx.num;
      } else {
        rhs = infer(node.right, scope, null, name);
      }

      if (node.left.type == "MemberExpression") {
        var obj = infer(node.left.object, scope);
        if (pName == "prototype") maybeInstantiate(scope, 20);
        if (pName == "<i>") {
          var v = node.left.property.name, local = scope.props[v], over = local && local.iteratesOver;
          if (over) {
            maybeInstantiate(scope, 20);
            var fromRight = node.right.type == "MemberExpression" && node.right.computed && node.right.property.name == v;
            over.forAllProps(function(prop, val, local) {
              if (local && prop != "prototype" && prop != "<i>")
                obj.propagate(new DefProp(prop, fromRight ? val : ANull));
            });
            return rhs;
          }
        }

        obj.propagate(new DefProp(pName, rhs, node.left.property));
        maybeAddPhantomObj(obj)
        if (node.right.type == "FunctionExpression")
          obj.propagate(node.right.scope.fnType.self, WG_SPECULATIVE_THIS);
      } else {
        connectPattern(node.left, scope, rhs)
      }
      return rhs;
    }),
    LogicalExpression: fill(function(node, scope, out) {
      infer(node.left, scope, out);
      infer(node.right, scope, out);
    }),
    ConditionalExpression: fill(function(node, scope, out) {
      infer(node.test, scope, ANull);
      infer(node.consequent, scope, out);
      infer(node.alternate, scope, out);
    }),
    NewExpression: fill(function(node, scope, out, name) {
      if (node.callee.type == "Identifier" && node.callee.name in scope.props)
        maybeInstantiate(scope, 20);

      for (var i = 0, args = []; i < node.arguments.length; ++i)
        args.push(infer(node.arguments[i], scope));
      var callee = infer(node.callee, scope);
      var self = new AVal;
      callee.propagate(new IsCtor(self, name && /\.prototype$/.test(name)));
      self.propagate(out, WG_NEW_INSTANCE);
      callee.propagate(new IsCallee(self, args, node.arguments, new IfObj(out)));
    }),
    CallExpression: fill(function(node, scope, out) {
      for (var i = 0, args = []; i < node.arguments.length; ++i)
        args.push(infer(node.arguments[i], scope));
      var outerFn = functionScope(scope).fnType
      if (node.callee.type == "MemberExpression") {
        var self = infer(node.callee.object, scope);
        var pName = propName(node.callee, scope)
        if (outerFn && (pName == "call" || pName == "apply") &&
            outerFn.args.indexOf(self) > -1)
          maybeInstantiate(scope, 30);
        self.propagate(new HasMethodCall(pName, args, node.arguments, out));
      } else if (node.callee.type == "Super" && cx.curSuperCtor) {
        cx.curSuperCtor.propagate(new IsCallee(getThis(scope), args, node.arguments, out))
      } else {
        var callee = infer(node.callee, scope);
        if (outerFn && outerFn.args.indexOf(callee) > -1)
          maybeInstantiate(scope, 30);
        var knownFn = callee.getFunctionType();
        if (knownFn && knownFn.instantiateScore && outerFn)
          maybeInstantiate(scope, knownFn.instantiateScore / 5);
        callee.propagate(new IsCallee(cx.topScope, args, node.arguments, out));
      }
    }),
    MemberExpression: fill(function(node, scope, out) {
      var name = propName(node), wg;
      if (name == "<i>") {
        var propType = infer(node.property, scope)
        var symName = symbolName(propType)
        if (symName)
          name = node.propName = symName
        else if (!propType.hasType(cx.num))
          wg = WG_MULTI_MEMBER
      }
      infer(node.object, scope).getProp(name).propagate(out, wg)
    }),
    Identifier: ret(function(node, scope) {
      if (node.name == "arguments") {
        var fnScope = functionScope(scope)
        if (fnScope.fnType && !(node.name in fnScope.props))
          scope.defProp(node.name, fnScope.fnType.originNode)
            .addType(new Arr(fnScope.fnType.arguments = new AVal));
      }
      return scope.getProp(node.name);
    }),
    ThisExpression: ret(function(_node, scope) {
      return getThis(scope)
    }),
    Super: ret(function(node) {
      return node.superType = cx.curSuper || ANull
    }),
    Literal: ret(function(node) {
      return literalType(node);
    }),
    TemplateLiteral: ret(function(node, scope) {
      for (var i = 0; i < node.expressions.length; ++i)
        infer(node.expressions[i], scope, ANull)
      return cx.str
    }),
    TaggedTemplateExpression: fill(function(node, scope, out) {
      var args = [new Arr(cx.str)]
      for (var i = 0; i < node.quasi.expressions.length; ++i)
        args.push(infer(node.quasi.expressions[i], scope))
      infer(node.tag, scope, new IsCallee(cx.topScope, args, node.quasi.expressions, out))
    }),
    YieldExpression: ret(function(node, scope) {
      var output = ANull, fn = functionScope(scope).fnType
      if (fn) {
        if (fn.retval == ANull) fn.retval = new AVal
        if (!fn.yieldval) fn.yieldval = new AVal
        output = fn.retval
      }
      if (node.argument) {
        if (node.delegate) {
          infer(node.argument, scope, new HasMethodCall("next", [], null,
                                                        new GetProp("value", output)))
        } else {
          infer(node.argument, scope, output)
        }
      }
      return fn ? fn.yieldval : ANull
    })
  };
  inferExprVisitor.ArrowFunctionExpression = inferExprVisitor.FunctionExpression

  function infer(node, scope, out, name) {
    var handler = inferExprVisitor[node.type];
    return handler ? handler(node, scope, out, name) : ANull;
  }

  function loopPattern(init) {
    return init.type == "VariableDeclaration" ? init.declarations[0].id : init
  }

  var inferWrapper = exports.inferWrapper = walk.make({
    Expression: function(node, scope) {
      infer(node, node.scope || scope, ANull);
    },

    FunctionDeclaration: function(node, scope, c) {
      var inner = node.scope, fn = inner.fnType;
      connectParams(node, inner)
      c(node.body, inner, "Statement");
      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);
      scope.getProp(node.id.name).addType(fn)
    },

    Statement: function(node, scope, c) {
      c(node, node.scope || scope)
    },

    VariableDeclaration: function(node, scope) {
      for (var i = 0; i < node.declarations.length; ++i) {
        var decl = node.declarations[i];
        if (decl.id.type == "Identifier") {
          var prop = scope.getProp(decl.id.name);
          if (decl.init)
            infer(decl.init, scope, prop, decl.id.name);
        } else if (decl.init) {
          connectPattern(decl.id, scope, infer(decl.init, scope))
        }
      }
    },

    ClassDeclaration: function(node, scope) {
      scope.getProp(node.id.name).addType(inferClass(node, scope, node.id.name))
    },

    ReturnStatement: function(node, scope) {
      if (!node.argument) return;
      var output = ANull, fn = functionScope(scope).fnType
      if (fn) {
        if (fn.retval == ANull) fn.retval = new AVal;
        output = fn.retval;
      }
      infer(node.argument, scope, output);
    },

    ForInStatement: function(node, scope, c) {
      var source = infer(node.right, scope);
      if ((node.right.type == "Identifier" && node.right.name in scope.props) ||
          (node.right.type == "MemberExpression" && node.right.property.name == "prototype")) {
        maybeInstantiate(scope, 5);
        var pattern = loopPattern(node.left)
        if (pattern.type == "Identifier") {
          if (pattern.name in scope.props)
            scope.getProp(pattern.name).iteratesOver = source
          source.getProp("<i>").propagate(ensureVar(pattern, scope))
        } else {
          connectPattern(pattern, scope, source.getProp("<i>"))
        }
      }
      c(node.body, scope, "Statement");
    },

    ForOfStatement: function(node, scope, c) {
      var pattern = loopPattern(node.left), target
      if (pattern.type == "Identifier")
        target = ensureVar(pattern, scope)
      else
        connectPattern(pattern, scope, target = new AVal)
      infer(node.right, scope, new HasMethodCall(":Symbol.iterator", [], null,
                                                 new HasMethodCall("next", [], null,
                                                                   new GetProp("value", target))))
      c(node.body, scope, "Statement")
    }
  });
  var parse = exports.parse = function(text, options, thirdArg) {
    if (!options || Array.isArray(options)) options = thirdArg
    var ast;
    try { ast = acorn.parse(text, options); }
    catch(e) { ast = acorn_loose.parse_dammit(text, options); }
    return ast;
  };
  exports.analyze = function(ast, name, scope) {
    if (typeof ast == "string") ast = parse(ast);

    if (!name) name = "file#" + cx.origins.length;
    exports.addOrigin(cx.curOrigin = name);

    if (!scope) scope = cx.topScope;
    cx.startAnalysis();

    walk.recursive(ast, scope, null, scopeGatherer);
    if (cx.parent) cx.parent.signal("preInfer", ast, scope)
    walk.recursive(ast, scope, null, inferWrapper);
    if (cx.parent) cx.parent.signal("postInfer", ast, scope)

    cx.curOrigin = null;
  };
  exports.purge = function(origins, start, end) {
    var test = makePredicate(origins, start, end);
    ++cx.purgeGen;
    cx.topScope.purge(test);
    for (var prop in cx.props) {
      var list = cx.props[prop];
      for (var i = 0; i < list.length; ++i) {
        var obj = list[i], av = obj.props[prop];
        if (!av || test(av, av.originNode)) list.splice(i--, 1);
      }
      if (!list.length) delete cx.props[prop];
    }
  };

  function makePredicate(origins, start, end) {
    var arr = Array.isArray(origins);
    if (arr && origins.length == 1) { origins = origins[0]; arr = false; }
    if (arr) {
      if (end == null) return function(n) { return origins.indexOf(n.origin) > -1; };
      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && origins.indexOf(n.origin) > -1; };
    } else {
      if (end == null) return function(n) { return n.origin == origins; };
      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && n.origin == origins; };
    }
  }

  AVal.prototype.purge = function(test) {
    if (this.purgeGen == cx.purgeGen) return;
    this.purgeGen = cx.purgeGen;
    for (var i = 0; i < this.types.length; ++i) {
      var type = this.types[i];
      if (test(type, type.originNode))
        this.types.splice(i--, 1);
      else
        type.purge(test);
    }
    if (!this.types.length) this.maxWeight = 0;

    if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
      var f = this.forward[i];
      if (test(f)) {
        this.forward.splice(i--, 1);
        if (this.props) this.props = null;
      } else if (f.purge) {
        f.purge(test);
      }
    }
  };
  ANull.purge = function() {};
  Obj.prototype.purge = function(test) {
    if (this.purgeGen == cx.purgeGen) return true;
    this.purgeGen = cx.purgeGen;
    for (var p in this.props) {
      var av = this.props[p];
      if (test(av, av.originNode))
        this.removeProp(p);
      av.purge(test);
    }
  };
  Fn.prototype.purge = function(test) {
    if (Obj.prototype.purge.call(this, test)) return;
    this.self.purge(test);
    this.retval.purge(test);
    for (var i = 0; i < this.args.length; ++i) this.args[i].purge(test);
  };
  function findByPropertyName(name) {
    guessing = true;
    var found = objsWithProp(name);
    if (found) for (var i = 0; i < found.length; ++i) {
      var val = found[i].getProp(name);
      if (!val.isEmpty()) return val;
    }
    return ANull;
  }

  function generatorResult(input, output) {
    var retObj = new Obj(true)
    retObj.defProp("done").addType(cx.bool)
    output.propagate(retObj.defProp("value"))
    var method = new Fn(null, ANull, input ? [input] : [], input ? ["?"] : [], retObj)
    var result = new Obj(cx.definitions.ecma6 && cx.definitions.ecma6.generator_prototype || true)
    result.defProp("next").addType(method)
    return result
  }

  function maybeIterator(fn, output) {
    if (!fn.generator) return output
    if (!fn.computeRet) { // Reuse iterator objects for non-computed return types
      if (fn.generator === true) fn.generator = generatorResult(fn.yieldval, output)
      return fn.generator
    }
    return generatorResult(fn.yieldval, output)
  }

  function computeReturnType(funcNode, argNodes, scope) {
    var fn = findType(funcNode, scope).getFunctionType()
    if (!fn) return ANull
    var result = fn.retval
    if (fn.computeRet) {
      for (var i = 0, args = []; i < argNodes.length; ++i)
        args.push(findType(argNodes[i], scope))
      var self = ANull
      if (funcNode.type == "MemberExpression")
        self = findType(funcNode.object, scope)
      result = fn.computeRet(self, args, argNodes);
    }
    return maybeIterator(fn, result)
  }

  var typeFinder = exports.typeFinder = {
    ArrayExpression: function(node, scope) {
      return arrayLiteralType(node.elements, scope, findType)
    },
    ObjectExpression: function(node) {
      return node.objType;
    },
    ClassExpression: function(node) {
      return node.objType;
    },
    FunctionExpression: function(node) {
      return node.scope.fnType;
    },
    ArrowFunctionExpression: function(node) {
      return node.scope.fnType;
    },
    SequenceExpression: function(node, scope) {
      return findType(node.expressions[node.expressions.length-1], scope);
    },
    UnaryExpression: function(node) {
      return unopResultType(node.operator);
    },
    UpdateExpression: function() {
      return cx.num;
    },
    BinaryExpression: function(node, scope) {
      if (binopIsBoolean(node.operator)) return cx.bool;
      if (node.operator == "+") {
        var lhs = findType(node.left, scope);
        var rhs = findType(node.right, scope);
        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
      }
      return cx.num;
    },
    AssignmentExpression: function(node, scope) {
      return findType(node.right, scope);
    },
    LogicalExpression: function(node, scope) {
      var lhs = findType(node.left, scope);
      return lhs.isEmpty() ? findType(node.right, scope) : lhs;
    },
    ConditionalExpression: function(node, scope) {
      var lhs = findType(node.consequent, scope);
      return lhs.isEmpty() ? findType(node.alternate, scope) : lhs;
    },
    NewExpression: function(node, scope) {
      var f = findType(node.callee, scope).getFunctionType();
      var proto = f && f.getProp("prototype").getObjType();
      if (!proto) return ANull;
      return getInstance(proto, f);
    },
    CallExpression: function(node, scope) {
      return computeReturnType(node.callee, node.arguments, scope)
    },
    MemberExpression: function(node, scope) {
      var propN = propName(node), obj = findType(node.object, scope).getType();
      if (obj) return obj.getProp(propN);
      if (propN == "<i>") return ANull;
      return findByPropertyName(propN);
    },
    Identifier: function(node, scope) {
      return scope.hasProp(node.name) || ANull;
    },
    ThisExpression: function(_node, scope) {
      return getThis(scope)
    },
    Literal: function(node) {
      return literalType(node);
    },
    Super: ret(function(node) {
      return node.superType
    }),
    TemplateLiteral: function() {
      return cx.str
    },
    TaggedTemplateExpression: function(node, scope) {
      return computeReturnType(node.tag, node.quasi.expressions, scope)
    },
    YieldExpression: function(_node, scope) {
      var fn = functionScope(scope).fnType
      return fn ? fn.yieldval : ANull
    }
  };

  function findType(node, scope) {
    var finder = typeFinder[node.type];
    return finder ? finder(node, scope) : ANull;
  }

  var searchVisitor = exports.searchVisitor = walk.make({
    Function: function(node, _st, c) {
      walk.base.Function(node, node.scope, c)
    },
    Property: function(node, st, c) {
      if (node.computed) c(node.key, st, "Expression");
      if (node.key != node.value) c(node.value, st, "Expression");
    },
    Statement: function(node, st, c) {
      c(node, node.scope || st)
    },
    ImportSpecifier: function(node, st, c) {
      c(node.local, st)
    },
    ImportDefaultSpecifier: function(node, st, c) {
      c(node.local, st)
    },
    ImportNamespaceSpecifier: function(node, st, c) {
      c(node.local, st)
    }
  });
  exports.fullVisitor = walk.make({
    MemberExpression: function(node, st, c) {
      c(node.object, st, "Expression");
      c(node.property, st, node.computed ? "Expression" : null);
    },
    ObjectExpression: function(node, st, c) {
      for (var i = 0; i < node.properties.length; ++i) {
        c(node.properties[i].value, st, "Expression");
        c(node.properties[i].key, st);
      }
    }
  }, searchVisitor);

  exports.findExpressionAt = function(ast, start, end, defaultScope, filter) {
    var test = filter || function(_t, node) {
      if (node.type == "Identifier" && node.name == "✖") return false;
      return typeFinder.hasOwnProperty(node.type);
    };
    return walk.findNodeAt(ast, start, end, test, searchVisitor, defaultScope || cx.topScope);
  };

  exports.findExpressionAround = function(ast, start, end, defaultScope, filter) {
    var test = filter || function(_t, node) {
      if (start != null && node.start > start) return false;
      if (node.type == "Identifier" && node.name == "✖") return false;
      return typeFinder.hasOwnProperty(node.type);
    };
    return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);
  };

  exports.expressionType = function(found) {
    return findType(found.node, found.state);
  };
  exports.parentNode = function(child, ast) {
    var stack = [];
    function c(node, st, override) {
      if (node.start <= child.start && node.end >= child.end) {
        var top = stack[stack.length - 1];
        if (node == child) throw {found: top};
        if (top != node) stack.push(node);
        walk.base[override || node.type](node, st, c);
        if (top != node) stack.pop();
      }
    }
    try {
      c(ast, null);
    } catch (e) {
      if (e.found) return e.found;
      throw e;
    }
  };

  var findTypeFromContext = exports.findTypeFromContext = {
    ArrayExpression: function(parent, _, get) { return get(parent, true).getProp("<i>"); },
    ObjectExpression: function(parent, node, get) {
      for (var i = 0; i < parent.properties.length; ++i) {
        var prop = node.properties[i];
        if (prop.value == node)
          return get(parent, true).getProp(prop.key.name);
      }
    },
    UnaryExpression: function(parent) { return unopResultType(parent.operator); },
    UpdateExpression: function() { return cx.num; },
    BinaryExpression: function(parent) { return binopIsBoolean(parent.operator) ? cx.bool : cx.num; },
    AssignmentExpression: function(parent, _, get) { return get(parent.left); },
    LogicalExpression: function(parent, _, get) { return get(parent, true); },
    ConditionalExpression: function(parent, node, get) {
      if (parent.consequent == node || parent.alternate == node) return get(parent, true);
    },
    CallExpression: function(parent, node, get) {
      for (var i = 0; i < parent.arguments.length; i++) {
        var arg = parent.arguments[i];
        if (arg == node) {
          var calleeType = get(parent.callee).getFunctionType();
          if (calleeType instanceof Fn)
            return calleeType.args[i];
          break;
        }
      }
    },
    ReturnStatement: function(_parent, node, get) {
      var fnNode = walk.findNodeAround(node.sourceFile.ast, node.start, "Function");
      if (fnNode) {
        var fnType = fnNode.node.type != "FunctionDeclaration"
          ? get(fnNode.node, true).getFunctionType()
          : fnNode.node.scope.fnType;
        if (fnType) return fnType.retval.getType();
      }
    },
    VariableDeclarator: function(parent, node, get) {
      if (parent.init == node) return get(parent.id)
    }
  };
  findTypeFromContext.NewExpression = findTypeFromContext.CallExpression

  exports.typeFromContext = function(ast, found) {
    var parent = exports.parentNode(found.node, ast);
    var type = null;
    if (findTypeFromContext.hasOwnProperty(parent.type)) {
      var finder = findTypeFromContext[parent.type];
      type = finder && finder(parent, found.node, function(node, fromContext) {
        var obj = {node: node, state: found.state};
        var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);
        return tp || ANull;
      });
    }
    return type || exports.expressionType(found);
  };
  var guessing = false;

  exports.resetGuessing = function(val) { guessing = val; };
  exports.didGuess = function() { return guessing; };

  exports.forAllPropertiesOf = function(type, f) {
    type.gatherProperties(f, 0);
  };

  var refFindWalker = walk.make({}, searchVisitor);

  exports.findRefs = function(ast, baseScope, name, refScope, f) {
    refFindWalker.Identifier = refFindWalker.VariablePattern = function(node, scope) {
      if (node.name != name) return;
      for (var s = scope; s; s = s.prev) {
        if (s == refScope) f(node, scope);
        if (name in s.props) return;
      }
    };
    walk.recursive(ast, baseScope, null, refFindWalker);
  };

  var simpleWalker = walk.make({
    Function: function(node, _scope, c) {
      c(node.body, node.scope, node.expression ? "Expression" : "Statement")
    },
    Statement: function(node, scope, c) {
      c(node, node.scope || scope)
    }
  });

  exports.findPropRefs = function(ast, scope, objType, propName, f) {
    walk.simple(ast, {
      MemberExpression: function(node, scope) {
        if (node.computed || node.property.name != propName) return;
        if (findType(node.object, scope).getType() == objType) f(node.property);
      },
      ObjectExpression: function(node, scope) {
        if (findType(node, scope).getType() != objType) return;
        for (var i = 0; i < node.properties.length; ++i)
          if (node.properties[i].key.name == propName) f(node.properties[i].key);
      }
    }, simpleWalker, scope);
  };
  var scopeAt = exports.scopeAt = function(ast, pos, defaultScope) {
    var found = walk.findNodeAround(ast, pos, function(_, node) {
      return node.scope;
    });
    if (found) return found.node.scope;
    else return defaultScope || cx.topScope;
  };

  exports.forAllLocalsAt = function(ast, pos, defaultScope, f) {
    var scope = scopeAt(ast, pos, defaultScope);
    scope.gatherProperties(f, 0);
  };
  def = exports.def = def.init({}, exports);
});

});

define("tern/lib/tern",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports, require("./infer"), require("./signal"),
               require("acorn"), require("acorn/dist/walk"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports", "./infer", "./signal", "acorn/dist/acorn", "acorn/dist/walk"], mod);
  mod(root.tern || (root.tern = {}), tern, tern.signal, acorn, acorn.walk); // Plain browser env
})(this, function(exports, infer, signal, acorn, walk) {
  "use strict";

  var plugins = Object.create(null);
  exports.registerPlugin = function(name, init) { plugins[name] = init; };

  var defaultOptions = exports.defaultOptions = {
    debug: false,
    async: false,
    getFile: function(_f, c) { if (this.async) c(null, null); },
    normalizeFilename: function(name) { return name },
    defs: [],
    plugins: {},
    fetchTimeout: 1000,
    dependencyBudget: 20000,
    reuseInstances: true,
    stripCRs: false,
    ecmaVersion: 6,
    projectDir: "/",
    parent: null
  };

  var queryTypes = {
    completions: {
      takesFile: true,
      run: findCompletions
    },
    properties: {
      run: findProperties
    },
    type: {
      takesFile: true,
      run: findTypeAt
    },
    documentation: {
      takesFile: true,
      run: findDocs
    },
    definition: {
      takesFile: true,
      run: findDef
    },
    refs: {
      takesFile: true,
      fullFile: true,
      run: findRefs
    },
    rename: {
      takesFile: true,
      fullFile: true,
      run: buildRename
    },
    files: {
      run: listFiles
    }
  };

  exports.defineQueryType = function(name, desc) { queryTypes[name] = desc; };

  function File(name, parent) {
    this.name = name;
    this.parent = parent;
    this.scope = this.text = this.ast = this.lineOffsets = null;
  }
  File.prototype.asLineChar = function(pos) { return asLineChar(this, pos); };
  
  exports.File = File;

  function parseFile(srv, file) {
    var options = {
      directSourceFile: file,
      allowReturnOutsideFunction: true,
      allowImportExportEverywhere: true,
      ecmaVersion: srv.options.ecmaVersion
    }
    var text = srv.signalReturnFirst("preParse", file.text, options) || file.text
    var ast = infer.parse(text, options)
    srv.signal("postParse", ast, text)
    return ast
  }

  function updateText(file, text, srv) {
    file.text = srv.options.stripCRs ? text.replace(/\r\n/g, "\n") : text;
    infer.withContext(srv.cx, function() {
      file.ast = parseFile(srv, file)
    });
    file.lineOffsets = null;
  }

  var Server = exports.Server = function(options) {
    this.cx = null;
    this.options = options || {};
    for (var o in defaultOptions) if (!options.hasOwnProperty(o))
      options[o] = defaultOptions[o];

    this.projectDir = options.projectDir.replace(/\\/g, "/")
    if (!/\/$/.test(this.projectDir)) this.projectDir += "/"

    this.parent = options.parent;
    this.handlers = Object.create(null);
    this.files = [];
    this.fileMap = Object.create(null);
    this.needsPurge = [];
    this.budgets = Object.create(null);
    this.uses = 0;
    this.pending = 0;
    this.asyncError = null;
    this.mod = {}

    this.defs = options.defs.slice(0)
    this.plugins = Object.create(null)
    for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))
      this.loadPlugin(plugin, options.plugins[plugin])

    this.reset();
  };
  Server.prototype = signal.mixin({
    addFile: function(name, /*optional*/ text, parent) {
      if (parent && !(parent in this.fileMap)) parent = null;
      if (!(name in this.fileMap))
        name = this.normalizeFilename(name)
      ensureFile(this, name, parent, text);
    },
    delFile: function(name) {
      var file = this.findFile(name);
      if (file) {
        this.needsPurge.push(file.name);
        this.files.splice(this.files.indexOf(file), 1);
        delete this.fileMap[name];
      }
    },
    reset: function() {
      this.signal("reset");
      this.cx = new infer.Context(this.defs, this);
      this.uses = 0;
      this.budgets = Object.create(null);
      for (var i = 0; i < this.files.length; ++i) {
        var file = this.files[i];
        file.scope = null;
      }
      this.signal("postReset");
    },

    request: function(doc, c) {
      var inv = invalidDoc(doc);
      if (inv) return c(inv);

      var self = this;
      doRequest(this, doc, function(err, data) {
        c(err, data);
        if (self.uses > 40) {
          self.reset();
          analyzeAll(self, null, function(){});
        }
      });
    },

    findFile: function(name) {
      return this.fileMap[name];
    },

    flush: function(c) {
      var cx = this.cx;
      analyzeAll(this, null, function(err) {
        if (err) return c(err);
        infer.withContext(cx, c);
      });
    },

    startAsyncAction: function() {
      ++this.pending;
    },
    finishAsyncAction: function(err) {
      if (err) this.asyncError = err;
      if (--this.pending === 0) this.signal("everythingFetched");
    },

    addDefs: function(defs, toFront) {
      if (toFront) this.defs.unshift(defs)
      else this.defs.push(defs)

      if (this.cx) this.reset()
    },

    deleteDefs: function(name) {
      for (var i = 0; i < this.defs.length; i++) if (this.defs[i]["!name"] == name) {
        this.defs.splice(i, 1);
        if (this.cx) this.reset();
        return;
      }
    },

    loadPlugin: function(name, options) {
      if (arguments.length == 1) options = this.options.plugins[name] || true
      if (name in this.plugins || !(name in plugins) || !options) return
      this.plugins[name] = true
      var init = plugins[name](this, options)
      if (!init) return
      if (init.defs) this.addDefs(init.defs, init.loadFirst)
      if (init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))
        this.on(type, init.passes[type])
    },

    normalizeFilename: function(name) {
      var norm = this.options.normalizeFilename(name).replace(/\\/g, "/")
      if (norm.indexOf(this.projectDir) == 0) norm = norm.slice(this.projectDir.length)
      return norm
    }
  });

  function doRequest(srv, doc, c) {
    if (doc.query && !queryTypes.hasOwnProperty(doc.query.type))
      return c("No query type '" + doc.query.type + "' defined");

    var query = doc.query;
    if (!query) c(null, {});

    var files = doc.files || [];
    if (files.length) ++srv.uses;
    for (var i = 0; i < files.length; ++i) {
      var file = files[i];
      if (file.type == "delete")
        srv.delFile(file.name);
      else
        ensureFile(srv, file.name, null, file.type == "full" ? file.text : null);
    }

    var timeBudget = typeof doc.timeout == "number" ? [doc.timeout] : null;
    if (!query) {
      analyzeAll(srv, timeBudget, function(){});
      return;
    }

    var queryType = queryTypes[query.type];
    if (queryType.takesFile) {
      if (typeof query.file != "string") return c(".query.file must be a string");
      if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);
    }

    analyzeAll(srv, timeBudget, function(err) {
      if (err) return c(err);
      var file = queryType.takesFile && resolveFile(srv, files, query.file);
      if (queryType.fullFile && file.type == "part")
        return c("Can't run a " + query.type + " query on a file fragment");

      function run() {
        var result;
        try {
          result = queryType.run(srv, query, file);
        } catch (e) {
          if (srv.options.debug && e.name != "TernError") console.error(e.stack);
          return c(e);
        }
        c(null, result);
      }
      infer.resetGuessing()
      infer.withContext(srv.cx, timeBudget ? function() { infer.withTimeout(timeBudget[0], run); } : run);
    });
  }

  function analyzeFile(srv, file) {
    infer.withContext(srv.cx, function() {
      file.scope = srv.cx.topScope;
      srv.signal("beforeLoad", file);
      infer.analyze(file.ast, file.name, file.scope);
      srv.signal("afterLoad", file);
    });
    return file;
  }

  function ensureFile(srv, name, parent, text) {
    var known = srv.findFile(name);
    if (known) {
      if (text != null) {
        if (known.scope) {
          srv.needsPurge.push(name);
          known.scope = null;
        }
        updateText(known, text, srv);
      }
      if (parentDepth(srv, known.parent) > parentDepth(srv, parent)) {
        known.parent = parent;
        if (known.excluded) known.excluded = null;
      }
      return;
    }

    var file = new File(name, parent);
    srv.files.push(file);
    srv.fileMap[name] = file;
    if (text != null) {
      updateText(file, text, srv);
    } else if (srv.options.async) {
      srv.startAsyncAction();
      srv.options.getFile(name, function(err, text) {
        updateText(file, text || "", srv);
        srv.finishAsyncAction(err);
      });
    } else {
      updateText(file, srv.options.getFile(name) || "", srv);
    }
  }

  function fetchAll(srv, c) {
    var done = true, returned = false;
    srv.files.forEach(function(file) {
      if (file.text != null) return;
      if (srv.options.async) {
        done = false;
        srv.options.getFile(file.name, function(err, text) {
          if (err && !returned) { returned = true; return c(err); }
          updateText(file, text || "", srv);
          fetchAll(srv, c);
        });
      } else {
        try {
          updateText(file, srv.options.getFile(file.name) || "", srv);
        } catch (e) { return c(e); }
      }
    });
    if (done) c();
  }

  function waitOnFetch(srv, timeBudget, c) {
    var done = function() {
      srv.off("everythingFetched", done);
      clearTimeout(timeout);
      analyzeAll(srv, timeBudget, c);
    };
    srv.on("everythingFetched", done);
    var timeout = setTimeout(done, srv.options.fetchTimeout);
  }

  function analyzeAll(srv, timeBudget, c) {
    if (srv.pending) return waitOnFetch(srv, timeBudget, c);

    var e = srv.fetchError;
    if (e) { srv.fetchError = null; return c(e); }

    if (srv.needsPurge.length > 0) infer.withContext(srv.cx, function() {
      infer.purge(srv.needsPurge);
      srv.needsPurge.length = 0;
    });

    var done = true;
    for (var i = 0; i < srv.files.length;) {
      var toAnalyze = [];
      for (; i < srv.files.length; ++i) {
        var file = srv.files[i];
        if (file.text == null) done = false;
        else if (file.scope == null && !file.excluded) toAnalyze.push(file);
      }
      toAnalyze.sort(function(a, b) {
        return parentDepth(srv, a.parent) - parentDepth(srv, b.parent);
      });
      for (var j = 0; j < toAnalyze.length; j++) {
        var file = toAnalyze[j];
        if (file.parent && !chargeOnBudget(srv, file)) {
          file.excluded = true;
        } else if (timeBudget) {
          var startTime = +new Date;
          infer.withTimeout(timeBudget[0], function() { analyzeFile(srv, file); });
          timeBudget[0] -= +new Date - startTime;
        } else {
          analyzeFile(srv, file);
        }
      }
    }
    if (done) c();
    else waitOnFetch(srv, timeBudget, c);
  }

  function firstLine(str) {
    var end = str.indexOf("\n");
    if (end < 0) return str;
    return str.slice(0, end);
  }

  function findMatchingPosition(line, file, near) {
    var pos = Math.max(0, near - 500), closest = null;
    if (!/^\s*$/.test(line)) for (;;) {
      var found = file.indexOf(line, pos);
      if (found < 0 || found > near + 500) break;
      if (closest == null || Math.abs(closest - near) > Math.abs(found - near))
        closest = found;
      pos = found + line.length;
    }
    return closest;
  }

  function scopeDepth(s) {
    for (var i = 0; s; ++i, s = s.prev) {}
    return i;
  }

  function ternError(msg) {
    var err = new Error(msg);
    err.name = "TernError";
    return err;
  }

  function resolveFile(srv, localFiles, name) {
    var isRef = name.match(/^#(\d+)$/);
    if (!isRef) return srv.findFile(name);

    var file = localFiles[isRef[1]];
    if (!file || file.type == "delete") throw ternError("Reference to unknown file " + name);
    if (file.type == "full") return srv.findFile(file.name);
    var realFile = file.backing = srv.findFile(file.name);
    var offset = file.offset;
    if (file.offsetLines) offset = {line: file.offsetLines, ch: 0};
    file.offset = offset = resolvePos(realFile, file.offsetLines == null ? file.offset : {line: file.offsetLines, ch: 0}, true);
    var line = firstLine(file.text);
    var foundPos = findMatchingPosition(line, realFile.text, offset);
    var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf("\n", offset)) : foundPos;
    var inObject, atFunction;

    infer.withContext(srv.cx, function() {
      infer.purge(file.name, pos, pos + file.text.length);

      var text = file.text, m;
      if (m = text.match(/(?:"([^"]*)"|([\w$]+))\s*:\s*function\b/)) {
        var objNode = walk.findNodeAround(file.backing.ast, pos, "ObjectExpression");
        if (objNode && objNode.node.objType)
          inObject = {type: objNode.node.objType, prop: m[2] || m[1]};
      }
      if (foundPos && (m = line.match(/^(.*?)\bfunction\b/))) {
        var cut = m[1].length, white = "";
        for (var i = 0; i < cut; ++i) white += " ";
        file.text = white + text.slice(cut);
        atFunction = true;
      }

      var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);
      var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);
      var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;
      file.ast = parseFile(srv, file)
      infer.analyze(file.ast, file.name, scope);
      tieTogether: if (inObject || atFunction) {
        var newInner = infer.scopeAt(file.ast, line.length, scopeStart);
        if (!newInner.fnType) break tieTogether;
        if (inObject) {
          var prop = inObject.type.getProp(inObject.prop);
          prop.addType(newInner.fnType);
        } else if (atFunction) {
          var inner = infer.scopeAt(realFile.ast, pos + line.length, realFile.scope);
          if (inner == scopeStart || !inner.fnType) break tieTogether;
          var fOld = inner.fnType, fNew = newInner.fnType;
          if (!fNew || (fNew.name != fOld.name && fOld.name)) break tieTogether;
          for (var i = 0, e = Math.min(fOld.args.length, fNew.args.length); i < e; ++i)
            fOld.args[i].propagate(fNew.args[i]);
          fOld.self.propagate(fNew.self);
          fNew.retval.propagate(fOld.retval);
        }
      }
    });
    return file;
  }
  function astSize(node) {
    var size = 0;
    walk.simple(node, {Expression: function() { ++size; }});
    return size;
  }

  function parentDepth(srv, parent) {
    var depth = 0;
    while (parent) {
      ++depth;
      var file = srv.findFile(parent);
      if (!file)
        return;
      parent = file.parent;
    }
    return depth;
  }

  function budgetName(srv, file) {
    for (;;) {
      var parent = srv.findFile(file.parent);
      if (!parent || !parent.parent) break;
      file = parent;
    }
    return file.name;
  }

  function chargeOnBudget(srv, file) {
    var bName = budgetName(srv, file);
    var size = astSize(file.ast);
    var known = srv.budgets[bName];
    if (known == null)
      known = srv.budgets[bName] = srv.options.dependencyBudget;
    if (known < size) return false;
    srv.budgets[bName] = known - size;
    return true;
  }
  function isPosition(val) {
    return typeof val == "number" || typeof val == "object" &&
      typeof val.line == "number" && typeof val.ch == "number";
  }
  function invalidDoc(doc) {
    if (doc.query) {
      if (typeof doc.query.type != "string") return ".query.type must be a string";
      if (doc.query.start && !isPosition(doc.query.start)) return ".query.start must be a position";
      if (doc.query.end && !isPosition(doc.query.end)) return ".query.end must be a position";
    }
    if (doc.files) {
      if (!Array.isArray(doc.files)) return "Files property must be an array";
      for (var i = 0; i < doc.files.length; ++i) {
        var file = doc.files[i];
        if (typeof file != "object") return ".files[n] must be objects";
        else if (typeof file.name != "string") return ".files[n].name must be a string";
        else if (file.type == "delete") continue;
        else if (typeof file.text != "string") return ".files[n].text must be a string";
        else if (file.type == "part") {
          if (!isPosition(file.offset) && typeof file.offsetLines != "number")
            return ".files[n].offset must be a position";
        } else if (file.type != "full") return ".files[n].type must be \"full\" or \"part\"";
      }
    }
  }

  var offsetSkipLines = 25;

  function findLineStart(file, line) {
    var text = file.text, offsets = file.lineOffsets || (file.lineOffsets = [0]);
    var pos = 0, curLine = 0;
    var storePos = Math.min(Math.floor(line / offsetSkipLines), offsets.length - 1);
    var pos = offsets[storePos], curLine = storePos * offsetSkipLines;

    while (curLine < line) {
      ++curLine;
      pos = text.indexOf("\n", pos) + 1;
      if (pos === 0) return null;
      if (curLine % offsetSkipLines === 0) offsets.push(pos);
    }
    return pos;
  }

  var resolvePos = exports.resolvePos = function(file, pos, tolerant) {
    if (typeof pos != "number") {
      var lineStart = findLineStart(file, pos.line);
      if (lineStart == null) {
        if (tolerant) pos = file.text.length;
        else throw ternError("File doesn't contain a line " + pos.line);
      } else {
        pos = lineStart + pos.ch;
      }
    }
    if (pos > file.text.length) {
      if (tolerant) pos = file.text.length;
      else throw ternError("Position " + pos + " is outside of file.");
    }
    return pos;
  };

  function asLineChar(file, pos) {
    if (!file) return {line: 0, ch: 0};
    var offsets = file.lineOffsets || (file.lineOffsets = [0]);
    var text = file.text, line, lineStart;
    for (var i = offsets.length - 1; i >= 0; --i) if (offsets[i] <= pos) {
      line = i * offsetSkipLines;
      lineStart = offsets[i];
    }
    for (;;) {
      var eol = text.indexOf("\n", lineStart);
      if (eol >= pos || eol < 0) break;
      lineStart = eol + 1;
      ++line;
    }
    return {line: line, ch: pos - lineStart};
  }

  var outputPos = exports.outputPos = function(query, file, pos) {
    if (query.lineCharPositions) {
      var out = asLineChar(file, pos);
      if (file.type == "part")
        out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;
      return out;
    } else {
      return pos + (file.type == "part" ? file.offset : 0);
    }
  };
  function clean(obj) {
    for (var prop in obj) if (obj[prop] == null) delete obj[prop];
    return obj;
  }
  function maybeSet(obj, prop, val) {
    if (val != null) obj[prop] = val;
  }
  function compareCompletions(a, b) {
    if (typeof a != "string") { a = a.name; b = b.name; }
    var aUp = /^[A-Z]/.test(a), bUp = /^[A-Z]/.test(b);
    if (aUp == bUp) return a < b ? -1 : a == b ? 0 : 1;
    else return aUp ? 1 : -1;
  }

  function isStringAround(node, start, end) {
    return node.type == "Literal" && typeof node.value == "string" &&
      node.start == start - 1 && node.end <= end + 1;
  }

  function pointInProp(objNode, point) {
    for (var i = 0; i < objNode.properties.length; i++) {
      var curProp = objNode.properties[i];
      if (curProp.key.start <= point && curProp.key.end >= point)
        return curProp;
    }
  }

  var jsKeywords = ("break do instanceof typeof case else new var " +
    "catch finally return void continue for switch while debugger " +
    "function this with default if throw delete in try").split(" ");

  var addCompletion = exports.addCompletion = function(query, completions, name, aval, depth) {
    var typeInfo = query.types || query.docs || query.urls || query.origins;
    var wrapAsObjs = typeInfo || query.depths;

    for (var i = 0; i < completions.length; ++i) {
      var c = completions[i];
      if ((wrapAsObjs ? c.name : c) == name) return;
    }
    var rec = wrapAsObjs ? {name: name} : name;
    completions.push(rec);

    if (aval && typeInfo) {
      infer.resetGuessing();
      var type = aval.getType(false);
      rec.guess = infer.didGuess();
      if (query.types)
        rec.type = infer.toString(aval);
      if (query.docs)
        maybeSet(rec, "doc", parseDoc(query, aval.doc || type && type.doc));
      if (query.urls)
        maybeSet(rec, "url", aval.url || type && type.url);
      if (query.origins)
        maybeSet(rec, "origin", aval.origin || type && type.origin);
    }
    if (query.depths) rec.depth = depth || 0;
    return rec;
  };

  function findCompletions(srv, query, file) {
    if (query.end == null) throw ternError("missing .query.end field");
    var fromPlugin = srv.signalReturnFirst("completion", file, query)
    if (fromPlugin) return fromPlugin

    var wordStart = resolvePos(file, query.end), wordEnd = wordStart, text = file.text;
    while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;
    if (query.expandWordForward !== false)
      while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;
    var word = text.slice(wordStart, wordEnd), completions = [], ignoreObj;
    if (query.caseInsensitive) word = word.toLowerCase();

    function gather(prop, obj, depth, addInfo) {
      if ((objLit || query.omitObjectPrototype !== false) && obj == srv.cx.protos.Object && !word) return;
      if (query.filter !== false && word &&
          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return;
      if (ignoreObj && ignoreObj.props[prop]) return;
      var result = addCompletion(query, completions, prop, obj && obj.props[prop], depth);
      if (addInfo && result && typeof result != "string") addInfo(result);
    }

    var hookname, prop, objType, isKey;

    var exprAt = infer.findExpressionAround(file.ast, null, wordStart, file.scope);
    var memberExpr, objLit;
    if (exprAt) {
      var exprNode = exprAt.node;
      if (exprNode.type == "MemberExpression" && exprNode.object.end < wordStart) {
        memberExpr = exprAt;
      } else if (isStringAround(exprNode, wordStart, wordEnd)) {
        var parent = infer.parentNode(exprNode, file.ast);
        if (parent.type == "MemberExpression" && parent.property == exprNode)
          memberExpr = {node: parent, state: exprAt.state};
      } else if (exprNode.type == "ObjectExpression") {
        var objProp = pointInProp(exprNode, wordEnd);
        if (objProp) {
          objLit = exprAt;
          prop = isKey = objProp.key.name;
        } else if (!word && !/:\s*$/.test(file.text.slice(0, wordStart))) {
          objLit = exprAt;
          prop = isKey = true;
        }
      }
    }

    if (objLit) {
      objType = infer.typeFromContext(file.ast, objLit);
      ignoreObj = objLit.node.objType;
    } else if (memberExpr) {
      prop = memberExpr.node.property;
      prop = prop.type == "Literal" ? prop.value.slice(1) : prop.name;
      memberExpr.node = memberExpr.node.object;
      objType = infer.expressionType(memberExpr);
    } else if (text.charAt(wordStart - 1) == ".") {
      var pathStart = wordStart - 1;
      while (pathStart && (text.charAt(pathStart - 1) == "." || acorn.isIdentifierChar(text.charCodeAt(pathStart - 1)))) pathStart--;
      var path = text.slice(pathStart, wordStart - 1);
      if (path) {
        objType = infer.def.parsePath(path, file.scope).getObjType();
        prop = word;
      }
    }

    if (prop != null) {
      srv.cx.completingProperty = prop;

      if (objType) infer.forAllPropertiesOf(objType, gather);

      if (!completions.length && query.guess !== false && objType && objType.guessProperties)
        objType.guessProperties(function(p, o, d, a) {if (p != prop && p != "✖") gather(p, o, d, a);});
      if (!completions.length && word.length >= 2 && query.guess !== false)
        for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0, function(rec) { rec.guess = true; });
      hookname = "memberCompletion";
    } else {
      infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);
      if (query.includeKeywords) jsKeywords.forEach(function(kw) {
        gather(kw, null, 0, function(rec) { rec.isKeyword = true; });
      });
      hookname = "variableCompletion";
    }
    srv.signal(hookname, file, wordStart, wordEnd, gather)

    if (query.sort !== false) completions.sort(compareCompletions);
    srv.cx.completingProperty = null;

    return {start: outputPos(query, file, wordStart),
            end: outputPos(query, file, wordEnd),
            isProperty: !!prop,
            isObjectKey: !!isKey,
            completions: completions};
  }

  function findProperties(srv, query) {
    var prefix = query.prefix, found = [];
    for (var prop in srv.cx.props)
      if (prop != "<i>" && (!prefix || prop.indexOf(prefix) === 0)) found.push(prop);
    if (query.sort !== false) found.sort(compareCompletions);
    return {completions: found};
  }

  var findExpr = exports.findQueryExpr = function(file, query, wide) {
    if (query.end == null) throw ternError("missing .query.end field");

    if (query.variable) {
      var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);
      return {node: {type: "Identifier", name: query.variable, start: query.end, end: query.end + 1},
              state: scope};
    } else {
      var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);
      var expr = infer.findExpressionAt(file.ast, start, end, file.scope);
      if (expr) return expr;
      expr = infer.findExpressionAround(file.ast, start, end, file.scope);
      if (expr && (expr.node.type == "ObjectExpression" || wide ||
                   (start == null ? end : start) - expr.node.start < 20 || expr.node.end - end < 20))
        return expr;
      return null;
    }
  };

  function findExprOrThrow(file, query, wide) {
    var expr = findExpr(file, query, wide);
    if (expr) return expr;
    throw ternError("No expression at the given position.");
  }

  function ensureObj(tp) {
    if (!tp || !(tp = tp.getType()) || !(tp instanceof infer.Obj)) return null;
    return tp;
  }

  function findExprType(srv, query, file, expr) {
    var type;
    if (expr) {
      infer.resetGuessing();
      type = infer.expressionType(expr);
    }
    var typeHandlers = srv.hasHandler("typeAt")
    if (typeHandlers) {
      var pos = resolvePos(file, query.end)
      for (var i = 0; i < typeHandlers.length; i++)
        type = typeHandlers[i](file, pos, expr, type)
    }
    if (!type) throw ternError("No type found at the given position.");

    var objProp;
    if (expr.node.type == "ObjectExpression" && query.end != null &&
        (objProp = pointInProp(expr.node, resolvePos(file, query.end)))) {
      var name = objProp.key.name;
      var fromCx = ensureObj(infer.typeFromContext(file.ast, expr));
      if (fromCx && fromCx.hasProp(name)) {
        type = fromCx.hasProp(name);
      } else {
        var fromLocal = ensureObj(type);
        if (fromLocal && fromLocal.hasProp(name))
          type = fromLocal.hasProp(name);
      }
    }
    return type;
  };

  function findTypeAt(srv, query, file) {
    var expr = findExpr(file, query), exprName;
    var type = findExprType(srv, query, file, expr), exprType = type;
    if (query.preferFunction)
      type = type.getFunctionType() || type.getType(query.guess === true);
    else
      type = type.getType(query.guess === true);

    if (expr) {
      if (expr.node.type == "Identifier")
        exprName = expr.node.name;
      else if (expr.node.type == "MemberExpression" && !expr.node.computed)
        exprName = expr.node.property.name;
    }

    if (query.depth != null && typeof query.depth != "number")
      throw ternError(".query.depth must be a number");

    var result = {guess: infer.didGuess(),
                  type: infer.toString(exprType, query.depth),
                  name: type && type.name,
                  exprName: exprName,
                  doc: exprType.doc,
                  url: exprType.url};
    if (type) storeTypeDocs(query, type, result);

    return clean(result);
  }

  function parseDoc(query, doc) {
    if (!doc) return null;
 return doc;
    var parabreak = /.\n[\s@\n]/.exec(doc);
    if (parabreak) doc = doc.slice(0, parabreak.index + 1);
    doc = doc.replace(/\n\s*/g, " ");
    if (doc.length < 100) return doc;
    var sentenceEnd = /[\.!?] [A-Z]/g;
    sentenceEnd.lastIndex = 80;
    var found = sentenceEnd.exec(doc);
    if (found) doc = doc.slice(0, found.index + 1);
    return doc;
  }

  function findDocs(srv, query, file) {
    var expr = findExpr(file, query);
    var type = findExprType(srv, query, file, expr);
    var result = {url: type.url, doc: parseDoc(query, type.doc), type: infer.toString(type)};
    var inner = type.getType();
    if (inner) storeTypeDocs(query, inner, result);
    return clean(result);
  }

  function storeTypeDocs(query, type, out) {
    if (!out.url) out.url = type.url;
    if (!out.doc) out.doc = parseDoc(query, type.doc);
    if (!out.origin) out.origin = type.origin;
    var ctor, boring = infer.cx().protos;
    if (!out.url && !out.doc && type.proto && (ctor = type.proto.hasCtor) &&
        type.proto != boring.Object && type.proto != boring.Function && type.proto != boring.Array) {
      out.url = ctor.url;
      out.doc = parseDoc(query, ctor.doc);
    }
  }

  var getSpan = exports.getSpan = function(obj) {
    if (!obj.origin) return;
    if (obj.originNode) {
      var node = obj.originNode;
      if (/^Function/.test(node.type) && node.id) node = node.id;
      return {origin: obj.origin, node: node};
    }
    if (obj.span) return {origin: obj.origin, span: obj.span};
  };

  var storeSpan = exports.storeSpan = function(srv, query, span, target) {
    target.origin = span.origin;
    if (span.span) {
      var m = /^(\d+)\[(\d+):(\d+)\]-(\d+)\[(\d+):(\d+)\]$/.exec(span.span);
      target.start = query.lineCharPositions ? {line: Number(m[2]), ch: Number(m[3])} : Number(m[1]);
      target.end = query.lineCharPositions ? {line: Number(m[5]), ch: Number(m[6])} : Number(m[4]);
    } else {
      var file = srv.findFile(span.origin);
      target.start = outputPos(query, file, span.node.start);
      target.end = outputPos(query, file, span.node.end);
    }
  };

  function findDef(srv, query, file) {
    var expr = findExpr(file, query);
    var type = findExprType(srv, query, file, expr);
    if (infer.didGuess()) return {};

    var span = getSpan(type);
    var result = {url: type.url, doc: parseDoc(query, type.doc), origin: type.origin};

    if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {
      var tp = type.types[i];
      storeTypeDocs(query, tp, result);
      if (!span) span = getSpan(tp);
    }

    if (span && span.node) { // refers to a loaded file
      var spanFile = span.node.sourceFile || srv.findFile(span.origin);
      var start = outputPos(query, spanFile, span.node.start), end = outputPos(query, spanFile, span.node.end);
      result.start = start; result.end = end;
      result.file = span.origin;
      var cxStart = Math.max(0, span.node.start - 50);
      result.contextOffset = span.node.start - cxStart;
      result.context = spanFile.text.slice(cxStart, cxStart + 50);
    } else if (span) { // external
      result.file = span.origin;
      storeSpan(srv, query, span, result);
    }
    return clean(result);
  }

  function findRefsToVariable(srv, query, file, expr, checkShadowing) {
    var name = expr.node.name;

    for (var scope = expr.state; scope && !(name in scope.props); scope = scope.prev) {}
    if (!scope) throw ternError("Could not find a definition for " + name);

    var type, refs = [];
    function storeRef(file) {
      return function(node, scopeHere) {
        if (checkShadowing) for (var s = scopeHere; s != scope; s = s.prev) {
          var exists = s.hasProp(checkShadowing);
          if (exists)
            throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would make a variable at line " +
                            (asLineChar(file, node.start).line + 1) + " point to the definition at line " +
                            (asLineChar(file, exists.name.start).line + 1));
        }
        refs.push({file: file.name,
                   start: outputPos(query, file, node.start),
                   end: outputPos(query, file, node.end)});
      };
    }

    if (scope.originNode) {
      type = "local";
      if (checkShadowing) {
        for (var prev = scope.prev; prev; prev = prev.prev)
          if (checkShadowing in prev.props) break;
        if (prev) infer.findRefs(scope.originNode, scope, checkShadowing, prev, function(node) {
          throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would shadow the definition used at line " +
                          (asLineChar(file, node.start).line + 1));
        });
      }
      infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));
    } else {
      type = "global";
      for (var i = 0; i < srv.files.length; ++i) {
        var cur = srv.files[i];
        infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));
      }
    }

    return {refs: refs, type: type, name: name};
  }

  function findRefsToProperty(srv, query, expr, prop) {
    var objType = infer.expressionType(expr).getObjType();
    if (!objType) throw ternError("Couldn't determine type of base object.");

    var refs = [];
    function storeRef(file) {
      return function(node) {
        refs.push({file: file.name,
                   start: outputPos(query, file, node.start),
                   end: outputPos(query, file, node.end)});
      };
    }
    for (var i = 0; i < srv.files.length; ++i) {
      var cur = srv.files[i];
      infer.findPropRefs(cur.ast, cur.scope, objType, prop.name, storeRef(cur));
    }

    return {refs: refs, name: prop.name};
  }

  function findRefs(srv, query, file) {
    var expr = findExprOrThrow(file, query, true);
    if (expr && expr.node.type == "Identifier") {
      return findRefsToVariable(srv, query, file, expr);
    } else if (expr && expr.node.type == "MemberExpression" && !expr.node.computed) {
      var p = expr.node.property;
      expr.node = expr.node.object;
      return findRefsToProperty(srv, query, expr, p);
    } else if (expr && expr.node.type == "ObjectExpression") {
      var pos = resolvePos(file, query.end);
      for (var i = 0; i < expr.node.properties.length; ++i) {
        var k = expr.node.properties[i].key;
        if (k.start <= pos && k.end >= pos)
          return findRefsToProperty(srv, query, expr, k);
      }
    }
    throw ternError("Not at a variable or property name.");
  }

  function buildRename(srv, query, file) {
    if (typeof query.newName != "string") throw ternError(".query.newName should be a string");
    var expr = findExprOrThrow(file, query);
    if (!expr || expr.node.type != "Identifier") throw ternError("Not at a variable.");

    var data = findRefsToVariable(srv, query, file, expr, query.newName), refs = data.refs;
    delete data.refs;
    data.files = srv.files.map(function(f){return f.name;});

    var changes = data.changes = [];
    for (var i = 0; i < refs.length; ++i) {
      var use = refs[i];
      use.text = query.newName;
      changes.push(use);
    }

    return data;
  }

  function listFiles(srv) {
    return {files: srv.files.map(function(f){return f.name;})};
  }

  exports.version = "0.16.1";
});

});

define("tern/lib/comment",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports);
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports"], mod);
  mod(tern.comment || (tern.comment = {}));
})(function(exports) {
  function isSpace(ch) {
    return (ch < 14 && ch > 8) || ch === 32 || ch === 160;
  }

  function onOwnLine(text, pos) {
    for (; pos > 0; --pos) {
      var ch = text.charCodeAt(pos - 1);
      if (ch == 10) break;
      if (!isSpace(ch)) return false;
    }
    return true;
  }
  exports.commentsBefore = function(text, pos) {
    var found = null, emptyLines = 0, topIsLineComment;
    out: while (pos > 0) {
      var prev = text.charCodeAt(pos - 1);
      if (prev == 10) {
        for (var scan = --pos, sawNonWS = false; scan > 0; --scan) {
          prev = text.charCodeAt(scan - 1);
          if (prev == 47 && text.charCodeAt(scan - 2) == 47) {
            if (!onOwnLine(text, scan - 2)) break out;
            var content = text.slice(scan, pos);
            if (!emptyLines && topIsLineComment) found[0] = content + "\n" + found[0];
            else (found || (found = [])).unshift(content);
            topIsLineComment = true;
            emptyLines = 0;
            pos = scan - 2;
            break;
          } else if (prev == 10) {
            if (!sawNonWS && ++emptyLines > 1) break out;
            break;
          } else if (!sawNonWS && !isSpace(prev)) {
            sawNonWS = true;
          }
        }
      } else if (prev == 47 && text.charCodeAt(pos - 2) == 42) {
        for (var scan = pos - 2; scan > 1; --scan) {
          if (text.charCodeAt(scan - 1) == 42 && text.charCodeAt(scan - 2) == 47) {
            if (!onOwnLine(text, scan - 2)) break out;
            (found || (found = [])).unshift(text.slice(scan, pos - 2));
            topIsLineComment = false;
            emptyLines = 0;
            break;
          }
        }
        pos = scan - 2;
      } else if (isSpace(prev)) {
        --pos;
      } else {
        break;
      }
    }
    return found;
  };

  exports.commentAfter = function(text, pos) {
    while (pos < text.length) {
      var next = text.charCodeAt(pos);
      if (next == 47) {
        var after = text.charCodeAt(pos + 1), end;
        if (after == 47) // line comment
          end = text.indexOf("\n", pos + 2);
        else if (after == 42) // block comment
          end = text.indexOf("*/", pos + 2);
        else
          return;
        return text.slice(pos + 2, end < 0 ? text.length : end);
      } else if (isSpace(next)) {
        ++pos;
      }
    }
  };

  exports.ensureCommentsBefore = function(text, node) {
    if (node.hasOwnProperty("commentsBefore")) return node.commentsBefore;
    return node.commentsBefore = exports.commentsBefore(text, node.start);
  };
});

});

define("plugins/c9.ide.language.javascript.tern/worker/architect_resolver_tern_plugin",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(
        require("../lib/infer"),
        require("../lib/tern"),
        require("../lib/comment"),
        require("acorn/util/walk"),
        require
    );
  if (typeof define == "function" && define.amd) // AMD
    return define([
        "tern/lib/infer",
        "tern/lib/tern",
        "tern/lib/comment",
        "acorn/dist/walk",
        "require",
        "exports"
    ], mod);
  mod(tern, tern);
})(function(infer, tern, comment, walk, require, exports) {

var architectPlugins;
var warnedPlugins = {};

if (exports)
    exports.setArchitectPlugins = function(value) {
        architectPlugins = value;
    };

tern.registerPlugin("architect_resolver", function(ternWorker, options) {
    ternWorker._architect = {
        modules: Object.create(null)
    };
    ternWorker.on("afterLoad", function(file) {
        var provides;
        walk.simple(file.ast, {
            AssignmentExpression: function(node) {
                if (!isDependencyAssign(node, "provides"))
                    return;
                provides = node.right.elements.map(function(e) {
                    return e.value;
                }).filter(function(e) {
                    return e;
                });
            },
            FunctionDeclaration: function(node) {
                if ((node.id.name !== "main" && node.id.name !== "plugin")
                    || node.params.length !== 3
                    || node.params[1].name !== "imports"
                    || node.params[2].name !== "register")
                    return;
                
                var seen = {};

                walk.simple(node, {
                    CallExpression: function(node) {
                        if (node.callee.name === "register"
                            && node.arguments.length >= 2
                            && node.arguments[1].type === "ObjectExpression") {
                            var arg = node.arguments[1];
                            arg.properties.forEach(function(prop) {
                                var name = prop.key.name;
                                var value = arg.objType.props[name] && arg.objType.props[name].types && arg.objType.props[name].types[0];
                                if (!value || seen["_" + name])
                                    return;
                                ternWorker._architect.modules["_" + name] = value;
                            });
                        }
                        if (node.callee.type === "MemberExpression"
                            && node.callee.property.name === "freezePublicAPI"
                            && node.arguments.length >= 1
                            && node.arguments[0].type === "ObjectExpression") {
                            var name = provides[0];
                            if (provides.length !== 1
                                && !(provides.length === 2 && name === "ext" && !seen["_" + name]))
                                return console.warn("[architect_resolver_worker] exporting multiple client-side plugins with freezePublicAPI() not supported: " + node.sourceFile.name);
                            var type = node.arguments[0].objType;
                            ternWorker._architect.modules["_" + name] = type;
                            seen["_" + name] = true;
                            delete type.props._events;
                            
                            comment.ensureCommentsBefore(node.sourceFile.text, node);
                            if (node.commentsBefore)
                                type.doc = type.doc || node.commentsBefore[node.commentsBefore.length - 1];
                        }
                    }
                });
            }
        });
    });
    function onPostInfer(ast, scope) {
        var path = ternWorker.cx.curOrigin;
        var baseDirMatch = path.match(/(.*\/)?plugins\//);
        if (!architectPlugins)
            return console.error("[architect_resolver_worker] architectPlugins not available");

        var consumes;
        walk.simple(ast, {
            AssignmentExpression: function(node) {
                if (!isDependencyAssign(node, "consumes"))
                    return;
                consumes = node.right.elements.map(function(e) {
                    return e.value;
                }).filter(function(e) {
                    return e;
                });
            },
            FunctionDeclaration: function(node) {
                if (node.id.name !== "main"
                    || node.params.length !== 3
                    || node.params[1].name !== "imports"
                    || node.params[2].name !== "register"
                    || !node.body.scope)
                    return;

                var importsVal = node.body.scope.prev.props.imports;
                var type = new infer.Obj();
                importsVal.addType(type);
                importsVal.gatherProperties = function(f) {
                    consumes.forEach(function(m) {
                        return f(m, importsVal, 0);
                    });
                };

                if (!consumes)
                    return console.warn("[architect_resolver_worker] main.consumes not defined");
                    
                if (!baseDirMatch) {
                    if (!warnedPlugins[path])
                        console.warn("[architect_resolver_worker] expected plugin to be in plugins/ dir: " + path);
                    warnedPlugins[path] = true;
                    return;
                }

                consumes.forEach(function(name) {
                    var path = getPath(name);
                    var def = ternWorker._architect.modules["_" + name];
                    if (!path && !def) {
                        if (!warnedPlugins[name])
                            console.warn("[architect_resolver_worker] could not resolve \"" + name + "\" plugin");
                        warnedPlugins[name] = true;
                        return;
                    }
                    if (path && baseDirMatch)
                        ternWorker.addFile(path, null, ternWorker.cx.curOrigin);
                    if (!def)
                        return;
                    
                    importsVal.getProp(name).addType(def);
                    type.getProp(name).addType(def);
                });
            }
        });

        function getPath(name) {
            var result = architectPlugins["_" + name];
            if (!result)
                return;
            return baseDirMatch[1] + result + ".js";
        }
    }

    function isDependencyAssign(node, kind) {
        return node.left.type === "MemberExpression"
            && (node.left.object.name === "main" || node.left.object.name === "plugin")
            && node.left.property.name === kind
            && node.right.type === "ArrayExpression";
    }

    return {
        passes: {
            postInfer: onPostInfer
        }
    };
});

});
});

define("plugins/c9.ide.language.javascript.tern/worker/architect_resolver_worker",[], function(require, exports, module) {

var plugin = require("./architect_resolver_tern_plugin");
var worker = require("plugins/c9.ide.language.core/worker");
var util = require("plugins/c9.ide.language/worker_util");
var completeUtil = require("plugins/c9.ide.language/complete_util");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var handler = module.exports = Object.create(baseLanguageHandler);

var ready;
var pluginNames;

worker.sender.emit("architectPlugins");
worker.sender.on("architectPluginsResult", function(e) {
    plugin.setArchitectPlugins(e.data);
    pluginNames = Object.keys(e.data).map(function(key) {
        return key.substr(1);
    });
    ready = true;
});

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.onceReady = function(callback) {
    if (ready)
        return callback();
    
    worker.sender.once("architectPluginsResult", function() {
        setTimeout(callback);
    });
};

handler.complete = function(doc, fullAst, pos, options, callback) {
    var node = options.node;
    if (!ready
        || !node
        || node.cons !== "String"
        || !node.parent
        || !node.parent.parent
        || node.parent.parent.cons !== "Array"
        || !node.parent.parent.parent
        || node.parent.parent.parent.cons !== "Assign"
        )
        return callback();
    
    var lhs = node.parent.parent.parent[0];
    if (lhs.cons !== "PropAccess"
        || lhs[1].value !== "consumes")
        return callback();
    
    var line = doc.getLine(pos.row);
    var id = util.getPrecedingIdentifier(line, pos.column);
    var completions = completeUtil.findCompletions(id, pluginNames);

    callback(completions.map(function(c) {
        return {
            name: c,
            icon: "package",
            identifierRegex: /[a-zA-Z_0-9\$\/\.]/,
            replaceText: c,
            priority: 5
        };
    }));
};

});

define("plugins/c9.ide.language.javascript.tern/worker/acorn_helper",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("acorn/acorn"), require("acorn/acorn_loose"), require);
  if (typeof define == "function" && define.amd) // AMD
    return define(["acorn/dist/acorn", "acorn/dist/acorn_loose", "require", "exports"], mod);
  mod(tern, tern);
})(function(acorn, acornLoose, require, exports) {
var File = function() {}; // TODO? use require("tern/lib/tern").File
var parse = acorn.parse;
var parse_dammit = acornLoose.parse_dammit;

var lastInput;
var lastOutput;
var lastInputLoose;
var lastOutputLoose;
var language;

if (exports)
    exports.setLanguage = function(value) {
        language = value;
    };

acorn.parse = function(input, options) {
    return acornLoose.parse_dammit(input, options);
};

acornLoose.parse_dammit = function(input, options) {
    if (language === "jsx") {
        input = input.replace(/\/>|<\//g, " -").replace(/[<>]/g, "-");
    }
    if (input === lastInputLoose) {
        if (options.directSourceFile && lastOutputLoose.sourceFile != options.directSourceFile) {
            for (var i in options.directSourceFile)
                lastOutputLoose.sourceFile[i] = options.directSourceFile[i];
            lastOutputLoose.sourceFile.ast = lastOutputLoose;
        }
        return lastOutputLoose;
    }
    if (!options.directSourceFile) {
        options.directSourceFile = new File();
        options.directSourceFile;
    }
    lastOutputLoose = filterDefine(parse_dammit(input, options));
    lastInputLoose = input;
    return lastOutputLoose;
};

function filterDefine(ast) {
    ast.body.forEach(function(statement) {
        if (statement.type === "ExpressionStatement"
            && statement.expression.type === "CallExpression"
            && statement.expression.callee.name === "define"
            && statement.expression.arguments.length
            && statement.expression.arguments[0].type === "FunctionExpression") {
            var func = statement.expression.arguments[0];
            func.params = func.params.filter(function(p) {
                return ["require", "exports", "module"].indexOf(p.name) === -1;
            });
        }
    });
    return ast;
}

});
});

define("plugins/c9.ide.language.javascript.infer/values",[], function(require, exports, module) {

var PROPER = require('plugins/c9.ide.language.javascript/scope_analyzer').PROPER;
var MAYBE_PROPER = require('plugins/c9.ide.language.javascript/scope_analyzer').MAYBE_PROPER;
var NOT_PROPER = require('plugins/c9.ide.language.javascript/scope_analyzer').NOT_PROPER;
var MAX_VALUES_LENGTH = 15;

var valueRegistry = {};

var contextStack = [];

function Property(values, confidence, path, row) {
    this.values = values;
    this.confidence = confidence;
    this.path = path;
    this.row = row;
}

function Value(name, node) {
    this.init(name, node);
}

Value.enterContext = function(name) {
    contextStack.push([name, 0]);
};

Value.leaveContext = function() {
    contextStack.pop();
};

Value.prototype.init = function(name, node) {
    var guid = '';
    for (var i = 0; i < contextStack.length; i++) {
        guid += contextStack[i][0] + '[' + contextStack[i][1] + ']/';
    }
    var top = contextStack[contextStack.length - 1];
    if (top) {
        top[1]++;
    }
    if (name) {
        guid += name;
    } else {
        guid = guid.substring(0, guid.length - 1);
    }
    this.guid = guid;
    this.properties = {};
    this.doc = null;
    this.docUrl = null;
    if (node) {
        this.pos = node.getPos();
    }
    valueRegistry[guid] = this;
};

Value.prototype.get = function(name) {
    var coll = new ValueCollection();
    if (this.properties['_' + name]) {
        coll.extend(this.properties['_' + name].values);
    }

    if (name !== '__proto__') {
        this.get('__proto__').forEach(function(p) {
            coll.extendPrototype(p.get(name).toArray());
        });
    }
    coll.deref();
    return coll;
};

Value.prototype.getPropertyNames = function() {
    var results = Object.keys(this.properties).map(function(s) {
        return s.substr(1);
    });
    this.get('__proto__').forEach(function(p) {
        return Object.keys(p.properties).forEach(function (s) {
            results.push(s.substr(1));
        });
    });
    return results;
};

Value.prototype.toJSON = function() {
    var fieldJSON = {};
    var properties = this.properties;
    for (var p in properties) {
        if (properties.hasOwnProperty(p)) {
            var prop = properties[p];
            return new Property(prop.values.map(function(v) { return v.guid; }), prop.confidence, prop.path, prop.row);
        }
    }
    return {
        guid: this.guid,
        doc: this.doc,
        properties: fieldJSON,
        pos: this.pos
    };
};

Value.prototype.markProperDeclaration = function(uname, confidence, path, row) {
    if (!this.properties[uname])
        return;    
    if (path)
        this.properties[uname].path = path;
    if (row)
        this.properties[uname].row = row;    
    if (confidence && this.properties[uname].confidence < PROPER)
        this.properties[uname].confidence += confidence;
};

Value.prototype.isProperDeclaration = function(name) {
    if (!this.properties['_' + name])
        return false;
    if (this.properties['_' + name].confidence > MAYBE_PROPER)
        return true;
    var result;
    if (name !== '__proto__') {
        this.get('__proto__').forEach(function(p) {
            if (p.isProperDeclaration(name))
                result = true;
        });
    }
    return result;
};

Value.prototype.hint = function(name, v, declarationConfidence, path, row) {
    if (!v)
        throw Error("Hinting an empty value!");
    if (!this.properties['_' + name]) {
        this.properties['_' + name] = new Property([v], declarationConfidence, path, row);
    }
    else {
        var currentValues = this.properties['_' + name].values;
        this.markProperDeclaration('_' + name, declarationConfidence, row);
        for (var i = 0; i < currentValues.length; i++) {
            if (currentValues[i].guid === v.guid) {
                return;
            }
        }
        currentValues.push(v);
    }
};

Value.prototype.hintMultiple = function(name, valueColl, declarationConfidence, path, row) {
    var _self = this;
    valueColl.forEach(function(v) {
        _self.hint(name, v, NOT_PROPER);
    });
    this.markProperDeclaration('_' + name, declarationConfidence, path, row);
};

function ValueCollection(values, prototypeValues) {
    this.values = values || [];
    this.prototypeValues = prototypeValues || [];
}

ValueCollection.prototype.extend = function(coll) {
    if (coll instanceof ValueCollection) {
        for (var i = 0; i < coll.values.length; i++) {
            this.add(coll.values[i]);
        }
        for (var i = 0; i < coll.prototypeValues.length; i++) {
            this.addFromPrototype(coll.prototypeValues[i]);
        }
    } else {
        for (var i = 0; i < coll.length; i++) {
            this.add(coll[i]);
        }
    }
};

ValueCollection.prototype.extendPrototype = function(coll) {
    this.prototypeValues = this.prototypeValues.concat(coll);
};

ValueCollection.prototype.toArray = function() {
    return this.values.concat(this.prototypeValues);
};

ValueCollection.prototype.add = function(value) {
    if (!value)
        throw Error("Adding empty value!");
    if (this.values.length > MAX_VALUES_LENGTH)
        return;
    this.values.push(value);
};

ValueCollection.prototype.addFromPrototype = function(value) {
    if (this.prototypeValues.length > MAX_VALUES_LENGTH)
        return;
    this.prototypeValues.push(value);
};

ValueCollection.prototype.forEach = function(fn) {
    this.values.forEach(fn);
    this.prototypeValues.forEach(fn);
};

ValueCollection.prototype.deref = function() {
    var values = this.values;
    for (var i = 0; i < values.length; i++)
        if (typeof values[i] === 'string')
            values[i] = valueRegistry[values[i]];
    values = this.prototypeValues;
    for (var i = 0; i < values.length; i++)
        if (typeof values[i] === 'string')
            values[i] = valueRegistry[values[i]];
};

ValueCollection.prototype.isEmpty = function() {
    return this.values.length === 0 && this.prototypeValues.length === 0;
};

function FunctionValue(name, node, callOnly) {
    this.init(name, node);
    this.node = node;
    this.callOnly = callOnly;
    if (name || node) {
        this.hintMultiple('__proto__', lookupValue("es5:Function").get('prototype'));
    }
}

FunctionValue.prototype = new Value('<ignore>');

FunctionValue.prototype.getFargs = function() {
    if (this.fargs)
        return this.fargs;
    else if (this.node) {
        var fargs = [];
        var fargsNode = this.node[1];
        for (var i = 0; i < fargsNode.length; i++) {
            fargs.push(fargsNode[i][0].value);
        }
        this.fargs = fargs;
        return fargs;
    }
    else
        return [];
};

FunctionValue.prototype.toJSON = function() {
    var json = Value.prototype.toJSON.call(this);
    json.fargs = this.getFargs();
    return json;
};

function SerializedFunctionValue(name) {
    this.init(name);
}

SerializedFunctionValue.prototype = new FunctionValue();

function instantiate(fn, initVal, node, name) {
    var value = initVal || new Value(name, node);
    value.hintMultiple('__proto__', fn.get('prototype'));
    value.hint('constructor', fn, PROPER);
    return value;
}

function lookupValue(guid) {
    if (!valueRegistry[guid])
        throw Error("Could not find " + guid);
    return valueRegistry[guid];
}

function fromJSON(json) {
    if (typeof json === "string")
        return json;
    
    var properties = json.properties || {};
    var value;

    if (properties._return !== undefined) {
        value = new SerializedFunctionValue();
        if (json.fargs) {
            value.fargs = json.fargs;
            for (var i = 0; i < value.fargs.length; i++) {
                if (!value.fargs[i].type)
                    value.fargs[i].type = ["es5:Object"];
            }
        }
    }
    else {
        value = new Value();
    }
    
    for (var p in properties) {
        var prop = properties[p];
        if (!prop.forEach) {
            (prop.values || []).forEach(function(v) {
                value.hint(p.substr(1), fromJSON(v), PROPER, v.path || json.path, v.row);
            });
        }
        else {
            prop.forEach(function(v) {
                value.hint(p.substr(1), fromJSON(v), PROPER, v.path || json.path, v.row);
            });
        }
    }

    if (json.guid) {
        valueRegistry[json.guid] = value;
    }
    value.guid = json.guid;
    value.doc = json.doc;
    value.docUrl = json.docUrl;
    value.path = json.path;
    value.row = json.row;
    
    return value;
}
    
exports.Value = Value;
exports.ValueCollection = ValueCollection;
exports.FunctionValue = FunctionValue;
exports.instantiate = instantiate;
exports.fromJSON = fromJSON;
exports.lookupValue = lookupValue;

exports.getRegistry = function() { return valueRegistry; };

exports.reset = function() {
    valueRegistry = {};
    contextStack = [];
};

});

define("plugins/c9.ide.language.javascript.infer/infer",[], function(require, exports, module) {

var values = require("./values");
var Value = values.Value;
var ValueCollection = values.ValueCollection;
var FunctionValue = values.FunctionValue;
var instantiate = values.instantiate;
var valueFromJSON = values.fromJSON;
var lookupValue = values.lookupValue;
var scopeAnalyzer = require("plugins/c9.ide.language.javascript/scope_analyzer");
var Scope = scopeAnalyzer.Scope;
var Variable = scopeAnalyzer.Variable;
var PROPER = scopeAnalyzer.PROPER;
var MAYBE_PROPER = scopeAnalyzer.MAYBE_PROPER;
var NOT_PROPER = scopeAnalyzer.NOT_PROPER;
var KIND_PACKAGE = scopeAnalyzer.KIND_PACKAGE;
var KIND_DEFAULT = scopeAnalyzer.KIND_DEFAULT;
var path = require("./path");
var completeUtil = require("plugins/c9.ide.language/complete_util");
require('treehugger/traverse');

var registeredSummaries = {};

if (typeof window !== "undefined") {
    completeUtil.fetchText("plugins/c9.ide.language.javascript.infer/builtin.jst", function(err, result) {
        if (err) return console.error(err);
        registeredSummaries.$builtin1$ = JSON.parse(result);
    });
}

var filePath;
var basePath;

function registerSummary(guid, summary) {
    if (!summary) {
        if (registeredSummaries[guid])
            delete registeredSummaries[guid];
        return;
    }
    
    registeredSummaries[guid] = summary;
}

Variable.prototype.addValue = function(value) {
    var values = this.values;
    for (var i = 0; i < values.length; i++) {
        if (values[i].guid === value.guid) {
            return;
        }
    }
    values.push(value);
};
Scope.prototype.hint = function(name, v, declarationConfidence, path, row, kind) {
    var variable = this.get(name, kind);
    if (!variable) {
        variable = this.declare(name);
    }
    for (var i = 0; i < variable.values.length; i++) {
        if (variable.values[i].guid === v.guid) {
            return;
        }
    }
    variable.addValue(v);
    return v;
};

Scope.prototype.hintMultiple = function(name, valueColl, declarationConfidence, path, row) {
    var variable = this.get(name);
    if (!variable) {
        variable = this.declare(name);
    }
    valueColl.forEach(function(v) {
        for (var i = 0; i < variable.values.length; i++) {
            if (variable.values[i].guid === v.guid) {
                return;
            }
        }
        variable.addValue(v);
    });
};
function evalFunction(scope, node, thisValues) {
    node.rewrite(
        'Function(name, fargs, body)', function(b, node) {
            var val = new FunctionValue(b.name.value, node);
            if (b.name.value)
                scope.hint(b.name.value, val, PROPER, filePath, tryGetRow(node));
            var proto = new Value("prototype", node);
            val.hint('prototype', proto);
            var localScope = this.getAnnotation("localScope");
            localScope.fn = val;
            localScope.declare("this", undefined, PROPER);
            localScope.hint("this", proto, PROPER, filePath, tryGetRow(node));
            if (thisValues)
                localScope.hintMultiple("this", thisValues, PROPER);
            b.fargs.forEach(function(farg, idx) {
                var fargName = farg[0].value;
                var fargVal;
                if (localScope.fnFargs && localScope.fnFargs[idx] && localScope.fnFargs[idx].type) {
                    fargVal = lookupValue(localScope.fnFargs[idx].type);
                }
                else {
                    fargVal = new Value(fargName);
                }
                val.hint("arg" + idx, fargVal, NOT_PROPER);
                localScope.declare(fargName);
                localScope.hint(fargName, fargVal, PROPER);
            });
            Value.enterContext(b.name.value || 'fn');
            staticEval(localScope, b.body);
            Value.leaveContext();
        }
    );
}

function hintValue(node, asV, declarationConfidence) {
    node.rewrite(
        'Var(x)', function(b) {
            var scope = this.getAnnotation("scope");
            scope.hint(b.x.value, asV, declarationConfidence);
        },
        'PropAccess(e, x)', function(b) {
            var vals = inferValues(b.e);
            vals.forEach(function(v) {
                v.hint(b.x.value, asV, declarationConfidence);
            });
        }
    );
}
function staticEval(scope, node, newFilePath, newBasePath) {
    if (newFilePath || newFilePath === "")
        filePath = newFilePath;
    if (newBasePath || newBasePath === "")
        basePath = newBasePath;
        
    node.traverseTopDown(
        "Function(_, _, _)", function() {
            evalFunction(scope, this);
            return this; // Stop traversal
        },
        "VarDeclInit(name, e)", "ConstDeclInit(name, e)", "LetDeclInit(name, e)", function(b, node) {
            staticEval(scope, b.e);
            scope.hintMultiple(b.name.value, inferValues(b.e), PROPER, filePath, tryGetRow(node));
            return this; // Stop traversal
        }, 
        'Assign(PropAccess(e1, prop), e2)', function(b, node) {
            staticEval(scope, b.e1);
            var vs = inferValues(b.e1);
            var isImportant = false;
            if (b.e2.cons === 'Function') {
                evalFunction(scope, b.e2, vs);
                isImportant = true;
            }
            else if (b.e2.cons === 'ObjectInit') {
                staticEval(scope, this[0]); // PropAccess(e1, prop)
                var vs2 = inferValues(this[0]);
                b.e2[0].filter(
                    'PropertyInit(_, Function(_, _, _))', function(b) {
                        evalFunction(scope, this[1], vs2);
                        return this;
                    },
                    function(b) {
                        staticEval(scope, this);
                    }
                );
                isImportant = true;
            }
            else {
                staticEval(scope, b.e2);
            }
            var vs3 = inferValues(b.e2);
            if (isImportant) {
                vs.values.forEach(function(v) {
                    v.hintMultiple(b.prop.value, vs3, MAYBE_PROPER, filePath, tryGetRow(node));
                });
            }
            else {
                vs.values.forEach(function(v) {
                    v.hintMultiple(b.prop.value, vs3, MAYBE_PROPER);
                });
            }
            return this;
        },
        "Assign(Var(name), e)", function(b) {
            staticEval(scope, this[0]);
            staticEval(scope, b.e);
            scope.hintMultiple(b.name.value, inferValues(b.e), MAYBE_PROPER);
            return this;
        },
        "ObjectInit(inits)", function(b) {
            var v = new Value("objLit");
            var vals = new ValueCollection([v]);
            b.inits.filter(
                'PropertyInit(prop, Function(_, _, _))', function(b) {
                    evalFunction(scope, this[1], vals);
                    v.hintMultiple(b.prop.value, inferValues(this[1]), PROPER, filePath, tryGetRow(this));
                },
                'PropertyInit(prop, e)', function(b) {
                    staticEval(scope, b.e);
                    v.hintMultiple(b.prop.value, inferValues(b.e), PROPER, filePath, tryGetRow(this));
                }
            );
            return this;
        },
        "OpAssign(op, Var(name), e)", function(b) {
            staticEval(scope, this[1]);
            staticEval(scope, b.e);
            scope.hintMultiple(b.name.value, inferValues(b.e), MAYBE_PROPER);
            if (b.op.value === '*' || b.op.value === '/' || b.op.value === '%' || b.op.value === '-') {
                scope.hint(b.name.value, lookupValue('es5:Number/prototype'));
            } else if (b.op.value === '+') {
                scope.hint(b.name.value, lookupValue('es5:Number/prototype'));
                scope.hint(b.name.value, lookupValue('es5:String/prototype'));
            }
            return this;
        },
        "PropAccess(e, prop)", function(b) {
            staticEval(scope, b.e);
            var vs = inferValues(this);
            if (!vs.isEmpty()) {
                return; // property is defined
            }
            vs = inferValues(b.e);
            vs.forEach(function(v) {
                v.hint(b.prop.value, new Value(b.prop.value), MAYBE_PROPER);
            });
            return this;
        },
        'Call(PropAccess(Function(name, fargs, body), "call"), args)', function(b) {
            var fnNode = this[0][0]; // Function(name, ...)
            staticEval(scope, b.args);
            var objectValues = inferValues(b.args[0]);
            var funScope = fnNode.getAnnotation("localScope");
            var fargs = b.fargs;
            evalFunction(scope, fnNode, objectValues);
            for (var i = 0; i < b.args.length - 1; i++) {
                inferValues(b.args[i + 1]).forEach(function(v) {
                    if (i < fargs.length)
                        funScope.hint(fargs[i].value, v, NOT_PROPER);
                    objectValues.forEach(function(objV) {
                        objV.hint('arg' + i, v, NOT_PROPER);
                    });
                });
            }
            return this;
        },
        "Call(Var(name), args)", function(b) {
            var variable = scope.get(b.name.value);
            if (!variable) {
                variable = scope.declare(b.name.value);
                scope.hint(b.name.value, new FunctionValue(b.name.value, null, true), MAYBE_PROPER);
            } 
            else {
                var foundFunction = false;
                variable.values.forEach(function(v) {
                    if (v instanceof FunctionValue)
                        foundFunction = true;
                });
                if (!foundFunction)
                    scope.hint(b.name.value, new FunctionValue(b.name.value, null, true), MAYBE_PROPER);
            }
            staticEval(scope, b.args);
            for (var i = 0; i < b.args.length; i++) {
                inferValues(b.args[i]).forEach(function(v) {
                    variable.values.forEach(function(fn) {
                        if (fn instanceof FunctionValue) {
                            fn.hint('arg' + i, v, NOT_PROPER);
                        }
                    });
                });
            }
            variable.values.forEach(function(fn) {
                if (fn instanceof FunctionValue && fn.get("return").isEmpty())
                    fn.hint('return', new Value("implReturn"), PROPER);
            });
            return this;
        },
        "Call(PropAccess(e, prop), args)", function(b) {
            staticEval(scope, b.e);
            var eValues = inferValues(b.e);
            var fnValues = inferValuesPropAccess(eValues, b.prop.value, new ValueCollection());
            fnValues.forEach(function(fn) {
                if (fn instanceof FunctionValue) {
                    for (var i = 0; i < b.args.length; i++) {
                        var fargFargs = fn.fargs && fn.fargs[i] && fn.fargs[i].fargs;
                        var localScope = b.args[i].getAnnotation("localScope");
                        if (localScope)
                            localScope.fnFargs = fargFargs;
                    }
                }
            });
            staticEval(scope, b.args);
            if (fnValues.isEmpty()) {
                eValues.forEach(function(v) {
                    v.hint(b.prop.value, new FunctionValue(b.prop.value, null, true), MAYBE_PROPER);
                });
            }
            fnValues.forEach(function(fn) {
                if (fn instanceof FunctionValue) {
                    for (var i = 0; i < b.args.length; i++) {
                        var vs = inferValues(b.args[i]);
                        vs.forEach(function(v) {
                            fn.hint('arg' + i, v, NOT_PROPER);
                        });
                    }
                    if (fn.get("return").isEmpty())
                        fn.hint('return', new Value("implReturn"), PROPER);
                }    
            });
            return this;
        },
        "Return(e)", function(b) {
            staticEval(scope, b.e);
            scope.fn && scope.fn.hintMultiple('return', inferValues(b.e), PROPER);
            return this;
        },
        "Var(name)", function(b) {
            var vs = scope.get(b.name.value);
            if (!vs) {
                scope.declare(b.name.value);
                scope.hint(b.name.value, new Value(b.name.value, this), MAYBE_PROPER);
            }
            return this;
        },
        "ForIn(iter, _, _)", function(b) {
            b.iter.rewrite(
                "Var(x)", function(b) {
                    scope.hint(b.x.value, lookupValue("es5:String"));
                },
                "VarDecls([VarDecl(x)])", function(b) {
                    scope.hint(b.x.value, lookupValue("es5:String"));
                }
            );
        },
        "Op(op, e1, e2)", function(b) {
            staticEval(scope, b.e1);
            staticEval(scope, b.e2);
            switch (b.op.value) {
                case '<':
                case '<=':
                case '>':
                case '>=':
                    hintValue(b.e1, lookupValue("es5:Number"), NOT_PROPER);
                    hintValue(b.e1, lookupValue("es5:String"), NOT_PROPER);
                    hintValue(b.e2, lookupValue("es5:Number"), NOT_PROPER);
                    hintValue(b.e2, lookupValue("es5:String"), NOT_PROPER);
                    break;
            }
            return this;
        }
    );
    return scope;
}
function inferValues(e) {
    var values = new ValueCollection();
    e.rewrite(
        "String(_)", function() {
            values.add(lookupValue("es5:String/prototype"));
            return this;
        },
        "RegExp(_,_)", function() {
            values.add(lookupValue("es5:RegExp/prototype"));
            return this;
        },
        "Num(_)", function() {
            values.add(lookupValue("es5:Number/prototype"));
            return this;
        },
        "Var(\"true\")", function() {
            values.add(lookupValue("es5:Boolean/prototype"));
            return this;
        },
        "Var(\"false\")", function() {
            values.add(lookupValue("es5:Boolean/prototype"));
            return this;
        },
        "Array(_)", function() {
            values.add(lookupValue("es5:Array/prototype"));
            return this;
        },
        "Var(nm)", function(b) {
            var scope = this.getAnnotation("scope");
            if (!scope) {
                for (var root = this; root.parent;) root = root.parent;
                console.error("[infer] Cannot find scope of " + b.nm + "; analysis "
                    + (root.getAnnotation("scope") ? "incomplete" : "may not have been performed yet"));
                return;
            }
            var v = scope.get(b.nm.value) || scope.declare(b.nm.value);
            if (v.kind === KIND_DEFAULT)
                values.extend(v.values);
            return this;
        },
        "ObjectInit(inits)", function(b) {
            var v = instantiate(lookupValue("es5:Object"), undefined, this);
            b.inits.filter('PropertyInit(prop, e)', function(b) {
                v.hintMultiple(b.prop.value, inferValues(b.e), PROPER, filePath, tryGetRow(this));
            });
            values.add(v);
            return this;
        },
        "New(e, args)", function(b) {
            var vs = inferValues(b.e);
            vs.forEach(function(fn) {
                var value = instantiate(fn, undefined, undefined, b.e.cons === 'Var' && b.e[0].value);
                values.add(value);
            });
            return this;
        },
        "Call(Var(\"require\"), [String(name)])", function(b) {
            var scope = this[0].getAnnotation("scope");
            if (!scope)
                return;
            var required = b.name.value;
            if (path.isRelativePath(required) || path.isRelativePath(required)) {
                required = path.canonicalizePath(required, basePath).replace(/^\//, "");
                if (!required.match(/\.js$/))
                    required += ".js";
            }
            var result = scope.get(required, KIND_PACKAGE);
            if (!result)
                return;
            values.extend(result.values);
            return this;
        },
        "Call(PropAccess(e, method), args)", function(b) {
            var objectValues = inferValues(b.e);
            objectValues.forEach(function(objectValue) {
                var methods = objectValue.get(b.method.value);
                methods.forEach(function(fn) {
                    if (fn instanceof FunctionValue) {
                        values.extend(fn.get('return'));
                    }
                });
            });
            if (values.isEmpty())
                values.add(new Value("implRet"));
            return this;
        },
        "Call(e, args)", function(b) {
            var vs = inferValues(b.e);
            vs.forEach(function(fn) {
                if (fn instanceof FunctionValue) {
                    values.extend(fn.get('return'));
                }
            });
            if (values.isEmpty())
                values.add(new Value("implRet"));
            return this;
        },
        "PropAccess(e, prop)", function(b) {
            inferValuesPropAccess(inferValues(b.e), b.prop.value, values);
            return this;
        },
        "Function(name, fargs, _)", function(b) {
            values.add(this.getAnnotation("localScope").fn);
            return this;
        },
        'Assign(e1, e2)', function(b) {
            values = inferValues(b.e2);
        },
        'Op(op, e1, e2)', function(b) {
            switch (b.op.value) {
                case '*':
                case '/':
                case '%':
                case '-':
                    values.add(lookupValue('es5:Number/prototype'));
                    break;
                case '+':
                    values.add(lookupValue('es5:String/prototype'));
                    values.add(lookupValue('es5:Number/prototype'));
                    break;
                case '==':
                case '===':
                case '!==':
                case '!=':
                case '>':
                case '>=':
                case '<':
                case '<=':
                    values.add(lookupValue('es5:Boolean/prototype'));
                    break;
                case '||':
                case '&&':
                    values.extend(inferValues(b.e1));
                    values.extend(inferValues(b.e2));
                    break;
                default:
                    return false;
            }
            return this;
        },
        'PrefixOp(op, e)', function(b) {
            switch (b.op.value) {
                case '+':
                case '-':
                case '~':
                    values.add(lookupValue('es5:Number/prototype'));
                    break;
                case '!':
                    values.add(lookupValue('es5:Boolean/prototype'));
                    break;
                default:
                    return false;
            }
            return this;
        }
    );
    return values;
}

function inferValuesPropAccess(values, propName, results) {
    values.forEach(function(val) {
        results.extend(val.get(propName));
    });
    return results;
}

function createRootScope(scope, summaries) {
    if (!summaries)
        summaries = registeredSummaries;
    for (var p in summaries) {
        if (!summaries.hasOwnProperty(p))
            continue;
        var summarySet = summaries[p];
        for (var uri in summarySet) {
            if (!summarySet.hasOwnProperty(uri))
                continue;
            var summary = summarySet[uri];
            var TypeName = uri.split(':')[1];
            if (summary.kind === "default")
                summary.kind = KIND_DEFAULT;
            scope.declare(TypeName, undefined, PROPER, summary.kind);
            var value = valueFromJSON(summary);
            scope.hint(TypeName, value, PROPER, summary.path, summary.row, summary.kind);
    
            for (var j = 0; summary.altGuids && j < summary.altGuids.length; j++) {
                var guid = summary.altGuids[j].split(':')[1];
                scope.declare(guid, undefined, PROPER, summary.kind);
                scope.hint(guid, value, PROPER, summary.path, summary.row, summary.kind);   
            }
            
            if (summary.path) {
                scope.declareAlias(summary.kind, TypeName, summary.path);   
            }
        }
    }
    return scope;
}

function analyze(doc, ast, filePath, basePath, callback) {
    scopeAnalyzer.analyze(doc.getValue(), ast, function() {
        Value.enterContext('es5:unnamed');
        var scope = ast.getAnnotation("scope");
        values.reset();
        createRootScope(scope);
        Value.leaveContext();
        Value.enterContext("local:");
        staticEval(scope, ast, filePath, basePath);
        callback();
    }, true);
}

function tryGetRow(node) {
    var pos = node.getPos();
    return pos ? pos.sl : undefined;
}

exports.registerSummary = registerSummary;
exports.staticEval = staticEval;
exports.inferValues = inferValues;
exports.Scope = Scope;
exports.createRootScope = createRootScope;
exports.analyze = analyze;

});

define("plugins/c9.ide.language.javascript.infer/infer_arguments",[], function(require, exports, module) {

var tree = require("treehugger/tree");
var FunctionValue = require('./values').FunctionValue;
var ValueCollection = require('./values').ValueCollection;
module.exports.getArgIndex = function(node, doc, cursorPos) {
    var cursorTreePos = { line: cursorPos.row, col: cursorPos.column };
    var result = -1;
    node.rewrite(
        'Call(e, args)', function(b) {
            result = -1;
            var line = doc.getLine(cursorPos.row);
            if (line[b.args.getPos().ec + 1] && line[b.args.getPos().ec + 1].match(/[ ,]/))
                b.args.getPos().ec++;

            if (b.args.length === 0 && this.getPos().ec - 1 === cursorPos.column) {
                result = 0;
            }
            else if (b.args.length === 0 && line.substr(cursorPos.column).match(/^\s*\)/)) {
                result = 0;
            }
            else if (!tree.inRange(this.getPos(), cursorTreePos, true)) {
                return this;
            }
            else if (cursorPos.row === this.getPos().sl && line.substr(0, cursorPos.column + 1).match(/,\s*\)$/)) {
                result = b.args.length;
                return this;
            }
            for (var i = 0; i < b.args.length; i++) {
                if (b.args[i].cons === "ERROR" && result === -1) {
                    result = i;
                    break;
                }
                b.args[i].traverseTopDown(function() {
                    var pos = this.getPos();
                    if (this === node) {
                        result = i;
                        return this;
                    }
                    else if (pos && pos.sl <= cursorPos.row && pos.sc <= cursorPos.column) {
                        if (pos.sl === cursorPos.row && pos.ec === cursorPos.column - 1 && line[pos.ec] === ")")
                            return result = -1;
                        result = i;
                    }
                });
            }
            return this;
        }
    );
    return result;
};

module.exports.extractArgumentNames = function(v, showOptionals) {
    var args = [];
    var argsCode = [];
    var inferredArguments = v.callOnly;
    var opt;
    var fargs = v instanceof FunctionValue ? v.getFargs() : [];
    var argColl = extractArgumentValues(v, fargs, 0);
    for (var idx = 0; fargs.length ? idx < fargs.length : !argColl.isEmpty(); idx++) {
        var argName;
        if (fargs[idx]) {
            argName = fargs[idx].id || fargs[idx];
            if (showOptionals && fargs[idx].opt) {
                argName = "[" + argName + "]";
                opt = opt || idx;
            }
        }
        else {
            argName = "arg" + idx;
            inferredArguments = true;
        }
        args.push(argName);
        argsCode.push(fargToClosure(fargs[idx]) || valueCollToClosure(argName, argColl));
        argColl = extractArgumentValues(v, fargs, idx + 1);
    }
    return {
        argNames: args,
        argValueCodes: argsCode,
        inferredNames: inferredArguments,
        opt: opt
    };
};

var extractArgumentValues = function(v, fargs, index) {
    var result;
    if (fargs[index] && fargs[index].id) {
        result = new ValueCollection();
        if (fargs[index].type)
            result.extend(fargs[index].type);
    }
    else {
        result = v.get("arg" + index);
    }
    return result;
};

function fargToClosure(farg) {
    if (!farg || !farg.fargs)
        return null;
    var args = [];
    for (var i = 0; i < farg.fargs.length; i++) {
        args.push(farg.fargs[i].id || farg.fargs[i]);
    }
    return "function(" + args.join(", ") + ") {\n    ^^\n}";
}

function valueCollToClosure(name, coll) {
    var result;
    coll.forEach(function(v) {
        if (result)
            return;
        if (v instanceof FunctionValue) {
            var args = [];
            var fargs = v.getFargs();
            var argColl = extractArgumentValues(v, fargs, idx);
            for (var idx = 0; !argColl.isEmpty() || idx < fargs.length; idx++) {
                var argName;
                if (fargs[idx])
                    argName = fargs[idx].id || fargs[idx];
                else
                    argName = "arg" + idx;
                args.push(argName);
                argColl = extractArgumentValues(v, fargs, idx + 1);
            }
            result = "function(" + args.join(", ") + ") {\n    ^^\n}";
        }
    });
    return result;
}

});

define("plugins/c9.ide.language.javascript.infer/ast_updater",[], function(require, exports, module) {

    var infer = require("./infer");
    var assert = require("c9/assert");
    var tree = require("treehugger/tree");
    var REGEX_SAFE_CHANGE = /^[\(\)\s\.\/\*+;,A-Za-z-0-9_$]*$/;
    
    var lastAST;
    var lastDocValue;
    module.exports.updateOrReanalyze = function(doc, ast, filePath, basePath, pos, callback) {
        var docValue = doc.getValue();
        var updatedAST = tryUpdateAST(doc, docValue, ast);
        if (updatedAST) {
            if (ast.getAnnotation("scope")) {
                lastDocValue = docValue;
                lastAST = updatedAST;
            }
            return callback(updatedAST, findNode(updatedAST, pos));
        }
        var start = new Date().getTime();
        return infer.analyze(doc, ast, filePath, basePath, function() {
            lastDocValue = docValue;
            lastAST = ast;
            callback(ast, findNode(ast, pos));
        }, true);
    };
   
    function tryUpdateAST(doc, docValue, ast) {
        if (lastAST && (!lastAST.annos || !lastAST.annos.scope)) {
            console.error("Warning: Source does not appear to be analyzed yet; restarting analysis");
            return false;
        }
        if (lastDocValue === docValue) {
            return lastAST;
        }
        if (!isUpdateableAST(doc, docValue, ast))
            return null;
        
        if (!copyAnnosTop(lastAST, ast, true))
            return null;
        copyAnnosTop(lastAST, ast);
        assert(ast.annos.scope, "Target is empty");
        return ast;
    }
    function isUpdateableAST(doc, docValue, ast) {
        if (!lastDocValue)
            return false;

        var diff = getDiff(lastDocValue, docValue) || getDiff(docValue, lastDocValue);
        
        return diff && diff.text.match(REGEX_SAFE_CHANGE);
    }
    
    function copyAnnosTop(oldAST, newAST, dryRun) {
        if (!dryRun) copyAnnos(oldAST, newAST);
            
        for (var i = 0, j = 0; j < newAST.length; i++, j++) {
            if (!oldAST[i]) {
                if (newAST[j].cons !== "Var")
                    return false;
                copyAnnos(findScopeNode(oldAST), newAST[j]);
                if (!newAST[j].annos)
                    return false;
                continue;
            }
            if (oldAST[i].cons !== newAST[j].cons) {
                if (oldAST[i].cons === "Var" && newAST[j].isMatch("PropAccess(Var(_),_)")) {
                    copyAnnos(oldAST[i], newAST[j][0]);
                    continue;
                }
                if (newAST[j].cons === "Var" && oldAST[i].isMatch("PropAccess(Var(_),_)")) {
                    copyAnnos(oldAST[i][0], newAST[j]);
                    continue;
                }
                if (oldAST[i].isMatch("PropAccess(Var(_),_)") && newAST[j].isMatch("Call(PropAccess(Var(_),_),_)")) {
                    copyAnnos(oldAST[i][0], newAST[j][0][0]);
                    var oldTemplate = new tree.ListNode([oldAST[i][0]]);
                    oldTemplate.parent = oldAST;
                    copyAnnosTop(oldTemplate, newAST[j][1], dryRun);
                    continue;
                }
                if (newAST[j].isMatch("PropAccess(Var(_),_)") && oldAST[i].isMatch("Call(PropAccess(Var(_),_),_)")) {
                    copyAnnos(oldAST[i][0][0], newAST[j][0]);
                    continue;
                }
                if (newAST[j].cons === "Var" && newAST[j + 1] && newAST[j + 1].cons === oldAST[i].cons) {
                    copyAnnos(findScopeNode(oldAST), newAST[j]);
                    if (!newAST[j].annos)
                        return false;
                    i--;
                    continue;
                }
                if (oldAST[i].cons === "None" && newAST[j].cons === "Var") {
                    copyAnnos(findScopeNode(oldAST), newAST[j]);
                    if (!newAST[j].annos)
                        return false;
                    i--;
                    continue;
                }
                if (oldAST[i].cons === "Var" && oldAST[i + 1] && oldAST[i + 1].cons === newAST[i].cons) {
                    j--;
                    continue;
                }
                if (["If", "Return", "Throw"].indexOf(newAST[j].cons) > -1 && (!newAST[j][1] || newAST[j][1].isMatch("Block([])"))) {
                    var cond = newAST[j][0].toString();
                    if (cond === oldAST[i].toString()) {
                        copyAnnos(oldAST[i], newAST[j][0]);
                        continue;
                    }
                    else if (!oldAST[i + 1]) {
                        continue;
                    }
                    else if (cond === oldAST[i + 1].toString()) {
                        i++;
                        copyAnnos(oldAST[i], newAST[j][0]);
                        continue;
                    }
                }
                if (oldAST.cons === "If" && newAST.cons === "If" && newAST[0].cons === "Var" && oldAST[1].isMatch("Block([])")) {
                    var oldCond = oldAST[0];
                    var newCond = newAST[0];
                    var newBody = newAST[1];
                    if (oldCond.toString() === newBody.toString()) {
                        copyAnnos(findScopeNode(oldAST), newCond);
                        if (!newCond.annos)
                            return false;
                        copyAnnos(oldCond, newBody);
                        continue;
                    }
                }
                return false;
            }
            if (newAST[j].length) {
                if (!copyAnnosTop(oldAST[i], newAST[j], dryRun))
                    return false;
            } else if (!dryRun && newAST[j].$pos) {
                copyAnnos(oldAST[i], newAST[j]);
            }
            
        }
        return true;
    }
    
    function copyAnnos(oldNode, newNode) {
        newNode.oldNode = oldNode.oldNode || oldNode;
        newNode.oldNode.$pos = newNode.$pos;
        
        if (!oldNode.annos)
            return;
        newNode.annos = oldNode.annos;
    }
    
    function findScopeNode(ast) {
        if (!ast)
            return null;
        if (ast.annos && ast.annos.scope)
            return ast;
        return findScopeNode(ast.parent);
    }
    
    function getDiff(oldDoc, newDoc) {
        if (oldDoc.length > newDoc.length)
            return null;
        
        var diffLeft = -1;
        var diffRight = 0;
        
        for (var i = 0; i < newDoc.length; i++) {
            if (oldDoc[i] !== newDoc[i]) {
                diffLeft = i;
                break;
            }
        }
        
        for (var i = newDoc.length, j = oldDoc.length; j >= 0; i--, j--) {
            if (oldDoc[j] !== newDoc[i]) {
                diffRight = i + 1;
                break;
            }
        }
        
        assert(diffLeft != -1, "Inputs can't be equal");
        
        return {
            start: diffLeft,
            end: diffRight,
            text: newDoc.substring(diffLeft, diffRight)
        };
    }
    
    function findNode(ast, pos) {
        var treePos = { line: pos.row, col: pos.column };
        return ast.findNode(treePos);
    }
    
    
});

define("plugins/c9.ide.language.javascript.infer/infer_completer",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var infer = require('./infer');
var path = require('./path');
var KIND_DEFAULT = require('plugins/c9.ide.language.javascript/scope_analyzer').KIND_DEFAULT;
var KIND_PACKAGE = require('plugins/c9.ide.language.javascript/scope_analyzer').KIND_PACKAGE;
var KIND_EVENT = require('plugins/c9.ide.language.javascript/scope_analyzer').KIND_EVENT;
var PROPER = require('plugins/c9.ide.language.javascript/scope_analyzer').PROPER;
var EXPAND_STRING = 1;
var EXPAND_REQUIRE = 2;
var EXPAND_REQUIRE_LIMIT = 5;
var REQUIRE_PROPOSALS_MAX = 80;
var REQUIRE_ID_REGEX = /(?!["'])./;
var FunctionValue = require('./values').FunctionValue;
var completeUtil = require("plugins/c9.ide.language/complete_util");
var traverse = require("treehugger/traverse");
var args = require("./infer_arguments");
var astUpdater = require("./ast_updater");
var PRIORITY_INFER_LOW = 3;
var PRIORITY_INFER = 4;
var PRIORITY_INFER_TERN = 5;
var PRIORITY_INFER_HIGH = 6;

var completer = module.exports = Object.create(baseLanguageHandler);
var extraModuleCompletions;
    
completer.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

completer.getIdentifierRegex = function() {
    return (/[a-zA-Z_0-9\$\/]/);
};

completer.getCompletionRegex = function() {
    return (/^[\.]$/);
};

completer.getCacheCompletionRegex = function() {
    return new RegExp(
        "(\\b(if|while|for|switch)\\s*\\("
        + "|\\b\\w+\\s+"
        + "|(===?|!==?|[-+]=|[-+*%<>?!|&{[])"
        + "|\\s)+"
    );
};

completer.getMaxFileSizeSupported = function() {
    return .25 * 10 * 1000 * 80;
};

completer.setExtraModules = function(extraModules) {
    extraModuleCompletions = extraModules;
};

function valueToMatch(container, v, name, isPackage, isContextual) {
    if (isPackage)
        name = name.replace(/\.js$/, "");
    if ((v instanceof FunctionValue || v.properties._return) && !isPackage) {
        var showArgs = args.extractArgumentNames(v, true);
        var insertArgs = "opt" in showArgs ? args.extractArgumentNames(v, false) : showArgs;
        return {
            id: name,
            guid: v.guid + "[0" + name + "]",
            name: name + "(" + showArgs.argNames.join(", ") + ")",
            replaceText: name + (insertArgs.argNames.length === 0 && v.guid && v.guid.indexOf("es5:") !== 0 ? "()" : "(^^)"),
            icon: "method",
            priority: PRIORITY_INFER,
            inferredNames: showArgs.inferredNames,
            doc: v.doc,
            docUrl: v.docUrl,
            isFunction: true,
            type: v.properties._return && getGuid(v.properties._return.values[0]),
            isContextual: isContextual
        };
    }
    else {
        var isHighConfidence = 
            container && container.properties && container.properties["_" + name]
            && container.properties["_" + name].confidence >= 1;
        return {
            id: name,
            guid: container ? container.guid + "/" + name : v.guid + "[0" + name + "]",
            name: name,
            replaceText: name,
            doc: v.doc,
            docUrl: v.docUrl,
            icon: "property",
            priority: name === "__proto__" ? PRIORITY_INFER_LOW : PRIORITY_INFER,
            type: !isPackage && getGuid(v.properties.___proto__ ? v.properties.___proto__.values[0] : v.guid),
            isContextual: isHighConfidence
        };
    }
}

function getGuid(valueOrGuid) {
    if (!valueOrGuid)
        return;
    var result = valueOrGuid.guid || valueOrGuid;
    return result.substr && result.substr(-11) !== "/implReturn" ? result : undefined;
}

completer.predictNextCompletion = function(doc, fullAst, pos, options, callback) {
    if (!options.matches.length) {
        if (options.line[pos.column - 1] && /(?![{;})\]\s"'\+\-\*])./.test(options.line[pos.column - 1]))
            return callback(null, { predicted: "" });
    }
    var predicted = options.matches.filter(function(m) {
        return m.priority >= PRIORITY_INFER;
    });
    if (predicted.length !== 1 || predicted[0].icon === "method")
        return callback();
    callback(null, {
        predicted: predicted[0].replaceText + ".",
        showEarly: predicted[0].icon === "property" && !/\./.test(options.line)
    });
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    if (!options.node)
        return callback();
    var line = options.line;
    var identifier = options.identifierPrefix;
    var basePath = path.getBasePath(completer.path, completer.workspaceDir);
    var filePath = path.canonicalizePath(completer.path, basePath);
    if (fullAst.parent === undefined) {
        traverse.addParentPointers(fullAst);
        fullAst.parent = null;
    }
    astUpdater.updateOrReanalyze(doc, fullAst, filePath, basePath, pos, function(fullAst, currentNode) {
        var completions = {};
        var duplicates = {};
        currentNode.rewrite(
            'PropAccess(e, x)', function(b) {
                var allIdentifiers = [];
                var values = infer.inferValues(b.e);
                values.forEach(function(v) {
                    var propNames = v.getPropertyNames();
                    for (var i = 0; i < propNames.length; i++) {
                        if (propNames[i] !== b.x.value || v.isProperDeclaration(propNames[i]))
                            allIdentifiers.push(propNames[i]);
                    }
                });
                var matches = completeUtil.findCompletions(identifier, allIdentifiers);
                for (var i = 0; i < matches.length; i++) {
                    values.forEach(function(v) {
                        v.get(matches[i]).forEach(function(propVal) {
                            var match = valueToMatch(v, propVal, matches[i], false, true);
                            var duplicate = duplicates["_" + match.id];
                            if (duplicate && duplicate.inferredNames)
                                delete completions["_" + duplicate.guid];
                            if (duplicate && match.inferredNames)
                                return;
                            duplicates["_" + match.id] = completions["_" + match.guid] = match;
                        });
                    });
                }
                return this;
            },
            'FArg(_)', 'Function(_,_,_)', 'VarDeclInit(_,_)', 'VarDecl(_,_)',
            'ConstDeclInit(_,_)', 'ConstDecl(_,_)', function() { return this; },
            '_', function() {
                var me = this;
                if (this.traverseUp(
                    "Call(Var(\"require\"), args)",
                    function(b) {
                        if (b.args[0] !== me && this !== me)
                            return;
                        var scope = this[0].getAnnotation("scope");
                        var expand = b.args[0] && b.args[0].cons === "String" ? null : EXPAND_STRING;
                        identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, REQUIRE_ID_REGEX);

                        var useBasePath = path.isRelativePath(identifier) || path.isAbsolutePath(identifier) ? basePath : null;
                        completer.proposeRequire(identifier, expand, scope, completions, useBasePath);
                    }))
                    return this;
            },
            'ERROR()', 'PropertyInit(x,e)', 'ObjectInit(ps)', function(b, node) {
                if (b.ps) {
                    completer.proposeObjectProperty(node, identifier, completions);
                }
                else if (!b.x) {
                    if (currentNode.parent.cons !== "PropertyInit")
                        return; // Fallthrough
                    currentNode = currentNode.parent;
                    b.x = currentNode[0];
                    b.e = currentNode[1];
                }
                var objectInit = currentNode.parent.parent;
                if (!objectInit.parent || !objectInit.parent.parent || objectInit.parent.parent.cons !== "Call")
                    return node;
                completer.proposeObjectProperty(objectInit, identifier, completions);
                return node;
            },
            'Call(_, _)', function(b) {
                if ("function".indexOf(identifier) === 0)
                    completer.proposeClosure(this, doc, pos, completions);
            },
            'Var(_)', function(b) {
                if (this.parent.parent && this.parent.parent.isMatch('Call(_, _)') && "function".indexOf(identifier) === 0)
                    completer.proposeClosure(this.parent.parent, doc, pos, completions);
            },
            'Var(_)', function(b) {
                this.parent.rewrite('VarDeclInit(x, _)', 'ConstDeclInit(x, _)', function(b) {
                    if ("require".indexOf(identifier) !== 0)
                        return;
                    var scope = this.getAnnotation("scope");
                    completer.proposeRequire(b.x.value, EXPAND_REQUIRE, scope, completions);
                    completer.proposeRequire(b.x.value, EXPAND_REQUIRE, scope, completions, basePath);
                });
            },
            function() {
                var scope;
                this.traverseUp(function() {
                    if (!scope) scope = this.getAnnotation("scope");
                    if (this.rewrite("String(_)")) return this;
                });
                if (!scope)
                    return;
                var variableNames = scope.getVariableNames();
                if (this.cons === 'Var') { // Delete current var from proposals if not properly declared anywhere
                    var varName = this[0].value;
                    if (variableNames.indexOf(varName) !== -1 && (!scope.get(varName) || !scope.get(varName).isProperDeclaration()))
                        variableNames.splice(variableNames.indexOf(varName), 1);
                }
                var matches = completeUtil.findCompletions(identifier, variableNames);
                for (var i = 0; i < matches.length; i++) {
                    var v = scope.get(matches[i]);
                    if (!v)
                        continue;
                    if (!v.values.length && v.properDeclarationConfidence >= PROPER && currentNode.cons === "Var") {
                        completions[matches[i]] = {
                            id: matches[i],
                            name: matches[i],
                            replaceText: matches[i],
                            icon: "property",
                            priority: PRIORITY_INFER_TERN
                        };
                    }
                    v.values.forEach(function(propVal) {
                        var match = valueToMatch(null, propVal, matches[i]);
                        if (!match.name)
                            return;
                        var duplicate = duplicates["_" + match.id];
                        if (duplicate && duplicate.inferredNames)
                            delete completions["_" + duplicate.guid];
                        if (duplicate && match.inferredNames)
                            return;
                        duplicates["_" + match.id] = completions["_" + match.guid] = match;
                    });
                }
            }
        );
        var completionsArray = [];
        for (var id in completions) {
            completionsArray.push(completions[id]);
        }
        callback(completionsArray);
    });
};
completer.proposeRequire = function(identifier, expand, scope, completions, basePath) {
    var names = scope.getNamesByKind(KIND_PACKAGE);
    
    if (basePath || basePath === "")
        identifier = path.canonicalizePath(identifier, basePath).replace(/^\.$/, "");
    
    if (expand === EXPAND_REQUIRE && extraModuleCompletions)
        names = names.concat(Object.keys(extraModuleCompletions));

    var matches = expand === EXPAND_REQUIRE
        ? filterRequireSubstring(identifier, names)
        : completeUtil.findCompletions(identifier === "/" ? "" : identifier, names);
    
    if (basePath || basePath === "")
        matches = matches.filter(function(v) { return v.match(/\.js$/) && !v.match(/(\/|^)node_modules\//); });
    else
        matches = matches.filter(function(v) { return !v.match(/\.js$/); });
    
    if (expand === EXPAND_REQUIRE && matches.length > EXPAND_REQUIRE_LIMIT)
        return;

    matches = matches.slice(0, REQUIRE_PROPOSALS_MAX);

    for (var i = 0; i < matches.length; i++) {
        var match = matches[i];
        var v = scope.get(match, KIND_PACKAGE);
        if (!v && expand === EXPAND_REQUIRE) {
            return completions["_" + match] = {
                id: match,
                icon: "package",
                name: 'require("' + match + '")',
                replaceText: 'require("' + match + '")',
                doc: "Origin: node<br/>"
                    + (extraModuleCompletions[match].doc || ""),
                priority: PRIORITY_INFER_HIGH
            };
        }
        v.values.forEach(function(propVal) {
            var match = valueToMatch(null, propVal, matches[i], true, expand);
            match.icon = "package";
            if (identifier.match(/^\//))
                match.replaceText = match.name = "/" + match.replaceText;
            else if (basePath || basePath === "")
                match.replaceText = match.name = path.uncanonicalizePath(match.replaceText, basePath);
            completions["_" + match.guid] = match;
            if (expand === EXPAND_REQUIRE) {
                match.replaceText = 'require("' + match.replaceText + '")';
                match.name = 'require("' + match.name + '")';
            }
            if (expand === EXPAND_STRING)
                match.replaceText = '"' + match.replaceText + '"';
            if (expand !== EXPAND_REQUIRE)
                match.identifierRegex = REQUIRE_ID_REGEX;
        });
    }
};

completer.proposeClosure = function(node, doc, pos, completions) {
    node.rewrite('Call(f, args)', function(b) {
        var argIndex = args.getArgIndex(this, doc, pos);
        var id = 0;
        infer.inferValues(b.f).forEach(function(v) {
            var argNames = args.extractArgumentNames(v, false);
            var code = argNames.argValueCodes[argIndex];
            if (!code)
                return;
            var codeName = code.split(/\n/)[0] + "}";
            var guid = v.guid + "-argfun" + (id++);
            completions[guid] = {
                id: codeName,
                guid: guid,
                name: codeName,
                replaceText: code,
                doc: v.fargs && v.fargs.doc,
                docUrl: v.fargs && v.fargs.docUrl,
                icon: "method",
                priority: PRIORITY_INFER_HIGH
            };
        });
    });
};
completer.proposeObjectProperty = function(objectInit, identifier, completions) {
    var listIndex;
    for (var i = 0; i < objectInit.parent.length; i++)
        if (objectInit.parent[i] === objectInit) listIndex = i;
    var call = objectInit.parent.parent;
    infer.inferValues(call[0]).forEach(function(v) {
        if (!v.fargs || !v.fargs[listIndex] || !v.fargs[listIndex].properties)
            return;
        v.fargs[listIndex].properties.forEach(function(property) {
            completions["_$p$" + property.id] = {
                id: property.id,
                name: property.id,
                replaceText: property.id,
                doc: property.doc,
                docUrl: property.docUrl,
                icon: "property",
                priority: PRIORITY_INFER
            };
        });
    });
};

function filterRequireSubstring(name, names) {
    var nameClean = name.replace(/[^A-Za-z0-9_-]/g, ".");
    var nameRegex = new RegExp("^" + nameClean + "\\b|\\b" + nameClean + "$");
    return names.filter(function(n) {
        return nameRegex.test(n);
    });
}

});

define("tern/plugin/doc_comment",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("../lib/comment"),
               require("acorn"), require("acorn/dist/walk"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "../lib/comment", "acorn/dist/acorn", "acorn/dist/walk"], mod);
  mod(tern, tern, tern.comment, acorn, acorn.walk);
})(function(infer, tern, comment, acorn, walk) {
  "use strict";

  var WG_MADEUP = 1, WG_STRONG = 101;

  tern.registerPlugin("doc_comment", function(server, options) {
    server.mod.jsdocTypedefs = Object.create(null);
    server.on("reset", function() {
      server.mod.jsdocTypedefs = Object.create(null);
    });
    server.mod.docComment = {
      weight: options && options.strong ? WG_STRONG : undefined,
      fullDocs: options && options.fullDocs
    };

    server.on("postParse", postParse)
    server.on("postInfer", postInfer)
    server.on("postLoadDef", postLoadDef)
  });

  function postParse(ast, text) {
    function attachComments(node) { comment.ensureCommentsBefore(text, node); }

    walk.simple(ast, {
      VariableDeclaration: attachComments,
      FunctionDeclaration: attachComments,
      MethodDefinition: attachComments,
      Property: attachComments,
      AssignmentExpression: function(node) {
        if (node.operator == "=") attachComments(node);
      },
      CallExpression: function(node) {
        if (isDefinePropertyCall(node)) attachComments(node);
      }
    });
  }

  function isDefinePropertyCall(node) {
    return node.callee.type == "MemberExpression" &&
      node.callee.object.name == "Object" &&
      node.callee.property.name == "defineProperty" &&
      node.arguments.length >= 3 &&
      typeof node.arguments[1].value == "string";
  }

  function postInfer(ast, scope) {
    jsdocParseTypedefs(ast.sourceFile.text, scope);

    walk.simple(ast, {
      VariableDeclaration: function(node, scope) {
        var decl = node.declarations[0].id
        if (node.commentsBefore && decl.type == "Identifier")
          interpretComments(node, node.commentsBefore, scope,
                            scope.getProp(node.declarations[0].id.name));
      },
      FunctionDeclaration: function(node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
                            scope.getProp(node.id.name),
                            node.scope.fnType);
      },
      ClassDeclaration: function(node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
                            scope.getProp(node.id.name),
                            node.objType);
      },
      AssignmentExpression: function(node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
                            infer.expressionType({node: node.left, state: scope}));
      },
      ObjectExpression: function(node, scope) {
        for (var i = 0; i < node.properties.length; ++i) {
          var prop = node.properties[i], name = infer.propName(prop)
          if (name != "<i>" && prop.commentsBefore)
            interpretComments(prop, prop.commentsBefore, scope, node.objType.getProp(name))
        }
      },
      Class: function(node, scope) {
        var proto = node.objType.getProp("prototype").getObjType()
        if (!proto) return
        for (var i = 0; i < node.body.body.length; i++) {
          var method = node.body.body[i], name
          if (!method.commentsBefore) continue
          if (method.kind == "constructor")
            interpretComments(method, method.commentsBefore, scope, node.objType)
          else if ((name = infer.propName(method)) != "<i>")
            interpretComments(method, method.commentsBefore, scope, proto.getProp(name))
        }
      },
      CallExpression: function(node, scope) {
        if (node.commentsBefore && isDefinePropertyCall(node)) {
          var type = infer.expressionType({node: node.arguments[0], state: scope}).getObjType();
          if (type && type instanceof infer.Obj) {
            var prop = type.props[node.arguments[1].value];
            if (prop) interpretComments(node, node.commentsBefore, scope, prop);
          }
        }
      }
    }, infer.searchVisitor, scope);
  }

  function postLoadDef(data) {
    var defs = data["!typedef"];
    var cx = infer.cx(), orig = data["!name"];
    if (defs) for (var name in defs)
      cx.parent.mod.jsdocTypedefs[name] =
        maybeInstance(infer.def.parse(defs[name], orig, name), name);
  }
  function stripLeadingChars(lines) {
    for (var head, i = 1; i < lines.length; i++) {
      var line = lines[i], lineHead = line.match(/^[\s\*]*/)[0];
      if (lineHead != line) {
        if (head == null) {
          head = lineHead;
        } else {
          var same = 0;
          while (same < head.length && head.charCodeAt(same) == lineHead.charCodeAt(same)) ++same;
          if (same < head.length) head = head.slice(0, same)
        }
      }
    }
    lines = lines.map(function(line, i) {
      line = line.replace(/\s+$/, "");
      if (i == 0 && head != null) {
        for (var j = 0; j < head.length; j++) {
          var found = line.indexOf(head.slice(j));
          if (found == 0) return line.slice(head.length - j);
        }
      }
      if (head == null || i == 0) return line.replace(/^[\s\*]*/, "");
      if (line.length < head.length) return "";
      return line.slice(head.length);
    });
    while (lines.length && !lines[lines.length - 1]) lines.pop();
    while (lines.length && !lines[0]) lines.shift();
    return lines;
  }

  function interpretComments(node, comments, scope, aval, type) {
    jsdocInterpretComments(node, scope, aval, comments);
    var cx = infer.cx();

    if (!type && aval instanceof infer.AVal && aval.types.length) {
      type = aval.types[aval.types.length - 1];
      if (!(type instanceof infer.Obj) || type.origin != cx.curOrigin || type.doc)
        type = null;
    }

    for (var i = comments.length - 1; i >= 0; i--) {
      var text = stripLeadingChars(comments[i].split(/\r\n?|\n/)).join("\n");
      if (text) {
        if (aval instanceof infer.AVal) aval.doc = text;
        if (type) type.doc = text;
        break;
      }
    }
  }
  function skipSpace(str, pos) {
    while (/\s/.test(str.charAt(pos))) ++pos;
    return pos;
  }

  function isIdentifier(string) {
    if (!acorn.isIdentifierStart(string.charCodeAt(0))) return false;
    for (var i = 1; i < string.length; i++)
      if (!acorn.isIdentifierChar(string.charCodeAt(i))) return false;
    return true;
  }

  function parseLabelList(scope, str, pos, close) {
    var labels = [], types = [], madeUp = false;
    for (var first = true; ; first = false) {
      pos = skipSpace(str, pos);
      if (first && str.charAt(pos) == close) break;
      var colon = str.indexOf(":", pos);
      if (colon < 0) return null;
      var label = str.slice(pos, colon);
      if (!isIdentifier(label)) return null;
      labels.push(label);
      pos = colon + 1;
      var type = parseType(scope, str, pos);
      if (!type) return null;
      pos = type.end;
      madeUp = madeUp || type.madeUp;
      types.push(type.type);
      pos = skipSpace(str, pos);
      var next = str.charAt(pos);
      ++pos;
      if (next == close) break;
      if (next != ",") return null;
    }
    return {labels: labels, types: types, end: pos, madeUp: madeUp};
  }

  function parseTypeAtom(scope, str, pos) {
    var result = parseTypeInner(scope, str, pos)
    if (!result) return null
    if (str.slice(result.end, result.end + 2) == "[]")
      return {madeUp: result.madeUp, end: result.end + 2, type: new infer.Arr(result.type)}
    else return result
  }

  function parseType(scope, str, pos) {
    var type, union = false, madeUp = false;
    for (;;) {
      var inner = parseTypeAtom(scope, str, pos);
      if (!inner) return null;
      madeUp = madeUp || inner.madeUp;
      if (union) inner.type.propagate(union);
      else type = inner.type;
      pos = skipSpace(str, inner.end);
      if (str.charAt(pos) != "|") break;
      pos++;
      if (!union) {
        union = new infer.AVal;
        type.propagate(union);
        type = union;
      }
    }
    var isOptional = false;
    if (str.charAt(pos) == "=") {
      ++pos;
      isOptional = true;
    }
    return {type: type, end: pos, isOptional: isOptional, madeUp: madeUp};
  }

  function parseTypeInner(scope, str, pos) {
    pos = skipSpace(str, pos);
    var type, madeUp = false;

    if (str.indexOf("function(", pos) == pos) {
      var args = parseLabelList(scope, str, pos + 9, ")"), ret = infer.ANull;
      if (!args) return null;
      pos = skipSpace(str, args.end);
      if (str.charAt(pos) == ":") {
        ++pos;
        var retType = parseType(scope, str, pos + 1);
        if (!retType) return null;
        pos = retType.end;
        ret = retType.type;
        madeUp = retType.madeUp;
      }
      type = new infer.Fn(null, infer.ANull, args.types, args.labels, ret);
    } else if (str.charAt(pos) == "[") {
      var inner = parseType(scope, str, pos + 1);
      if (!inner) return null;
      pos = skipSpace(str, inner.end);
      madeUp = inner.madeUp;
      if (str.charAt(pos) != "]") return null;
      ++pos;
      type = new infer.Arr(inner.type);
    } else if (str.charAt(pos) == "{") {
      var fields = parseLabelList(scope, str, pos + 1, "}");
      if (!fields) return null;
      type = new infer.Obj(true);
      for (var i = 0; i < fields.types.length; ++i) {
        var field = type.defProp(fields.labels[i]);
        field.initializer = true;
        fields.types[i].propagate(field);
      }
      pos = fields.end;
      madeUp = fields.madeUp;
    } else if (str.charAt(pos) == "(") {
      var inner = parseType(scope, str, pos + 1);
      if (!inner) return null;
      pos = skipSpace(str, inner.end);
      if (str.charAt(pos) != ")") return null;
      ++pos;
      type = inner.type;
    } else {
      var start = pos;
      if (!acorn.isIdentifierStart(str.charCodeAt(pos))) return null;
      while (acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;
      if (start == pos) return null;
      var word = str.slice(start, pos);
      if (/^(number|integer)$/i.test(word)) type = infer.cx().num;
      else if (/^bool(ean)?$/i.test(word)) type = infer.cx().bool;
      else if (/^string$/i.test(word)) type = infer.cx().str;
      else if (/^(null|undefined)$/i.test(word)) type = infer.ANull;
      else if (/^array$/i.test(word)) {
        var inner = null;
        if (str.charAt(pos) == "." && str.charAt(pos + 1) == "<") {
          var inAngles = parseType(scope, str, pos + 2);
          if (!inAngles) return null;
          pos = skipSpace(str, inAngles.end);
          madeUp = inAngles.madeUp;
          if (str.charAt(pos++) != ">") return null;
          inner = inAngles.type;
        }
        type = new infer.Arr(inner);
      } else if (/^object$/i.test(word)) {
        type = new infer.Obj(true);
        if (str.charAt(pos) == "." && str.charAt(pos + 1) == "<") {
          var key = parseType(scope, str, pos + 2);
          if (!key) return null;
          pos = skipSpace(str, key.end);
          madeUp = madeUp || key.madeUp;
          if (str.charAt(pos++) != ",") return null;
          var val = parseType(scope, str, pos);
          if (!val) return null;
          pos = skipSpace(str, val.end);
          madeUp = key.madeUp || val.madeUp;
          if (str.charAt(pos++) != ">") return null;
          val.type.propagate(type.defProp("<i>"));
        }
      } else {
        while (str.charCodeAt(pos) == 46 ||
               acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;
        var path = str.slice(start, pos);
        var cx = infer.cx(), defs = cx.parent && cx.parent.mod.jsdocTypedefs, found;
        if (defs && (path in defs)) {
          type = defs[path];
        } else if (found = infer.def.parsePath(path, scope).getObjType()) {
          type = maybeInstance(found, path);
        } else {
          if (!cx.jsdocPlaceholders) cx.jsdocPlaceholders = Object.create(null);
          if (!(path in cx.jsdocPlaceholders))
            type = cx.jsdocPlaceholders[path] = new infer.Obj(null, path);
          else
            type = cx.jsdocPlaceholders[path];
          madeUp = true;
        }
      }
    }

    return {type: type, end: pos, madeUp: madeUp};
  }

  function maybeInstance(type, path) {
    if (type instanceof infer.Fn && /(?:^|\.)[A-Z][^\.]*$/.test(path)) {
      var proto = type.getProp("prototype").getObjType();
      if (proto instanceof infer.Obj) return infer.getInstance(proto);
    }
    return type;
  }

  function parseTypeOuter(scope, str, pos) {
    pos = skipSpace(str, pos || 0);
    if (str.charAt(pos) != "{") return null;
    var result = parseType(scope, str, pos + 1);
    if (!result) return null;
    var end = skipSpace(str, result.end);
    if (str.charAt(end) != "}") return null;
    result.end = end + 1;
    return result;
  }

  function jsdocInterpretComments(node, scope, aval, comments) {
    var type, args, ret, foundOne, self, parsed;

    for (var i = 0; i < comments.length; ++i) {
      var comment = comments[i];
      var decl = /(?:\n|$|\*)\s*@(type|param|arg(?:ument)?|returns?|this|class|constructor)\s+(.*)/g, m;
      while (m = decl.exec(comment)) {
        if (m[1] == "class" || m[1] == "constructor") {
          self = foundOne = true;
          continue;
        }

        if (m[1] == "this" && (parsed = parseType(scope, m[2], 0))) {
          self = parsed;
          foundOne = true;
          continue;
        }

        if (!(parsed = parseTypeOuter(scope, m[2]))) continue;
        foundOne = true;

        switch(m[1]) {
        case "returns": case "return":
          ret = parsed; break;
        case "type":
          type = parsed; break;
        case "param": case "arg": case "argument":
            var name = m[2].slice(parsed.end).match(/^\s*(\[?)\s*([^\]\s=]+)\s*(?:=[^\]]+\s*)?(\]?).*/);
            if (!name) continue;
            var argname = name[2] + (parsed.isOptional || (name[1] === '[' && name[3] === ']') ? "?" : "");
          (args || (args = Object.create(null)))[argname] = parsed;
          break;
        }
      }
    }

    if (foundOne) applyType(type, self, args, ret, node, aval);
  };

  function jsdocParseTypedefs(text, scope) {
    var cx = infer.cx();

    var re = /\s@typedef\s+(.*)/g, m;
    while (m = re.exec(text)) {
      var parsed = parseTypeOuter(scope, m[1]);
      var name = parsed && m[1].slice(parsed.end).match(/^\s*(\S+)/);
      if (name && parsed.type instanceof infer.Obj) {
        var rest = text.slice(m.index + m[0].length)
        while (m = /\s+@prop(?:erty)?\s+(.*)/.exec(rest)) {
          var propType = parseTypeOuter(scope, m[1]), propName
          if (propType && (propName = m[1].slice(propType.end).match(/^\s*(\S+)/)))
            propType.type.propagate(parsed.type.defProp(propName[1]))
          rest = rest.slice(m[0].length)
        }
        cx.parent.mod.jsdocTypedefs[name[1]] = parsed.type;
      }
    }
  }

  function propagateWithWeight(type, target) {
    var weight = infer.cx().parent.mod.docComment.weight;
    type.type.propagate(target, weight || (type.madeUp ? WG_MADEUP : undefined));
  }

  function isFunExpr(node) { return node.type == "FunctionExpression" || node.type == "ArrowFunctionExpression" }

  function applyType(type, self, args, ret, node, aval) {
    var fn;
    if (node.type == "VariableDeclaration") {
      var decl = node.declarations[0];
      if (decl.init && isFunExpr(decl.init)) fn = decl.init.scope.fnType;
    } else if (node.type == "FunctionDeclaration") {
      fn = node.scope.fnType;
    } else if (node.type == "AssignmentExpression") {
      if (isFunExpr(node.right))
        fn = node.right.scope.fnType;
    } else if (node.type == "CallExpression") {
    } else { // An object property
      if (isFunExpr(node.value)) fn = node.value.scope.fnType;
      else if (fn = aval.types && aval.types[0] && aval.types[0].args)
        fn = aval.types[0];
    }

    if (fn && (args || ret || self)) {
      if (args) for (var i = 0; i < fn.argNames.length; ++i) {
        var name = fn.argNames[i], known = args[name];
        if (!known && (known = args[name + "?"]))
          fn.argNames[i] += "?";
        if (known) propagateWithWeight(known, fn.args[i]);
      }
      if (ret) {
        if (fn.retval == infer.ANull) fn.retval = new infer.AVal;
        propagateWithWeight(ret, fn.retval);
      }
      if (self === true) {
        var proto = fn.getProp("prototype").getObjType();
        self = proto && {type: infer.getInstance(proto, fn)};
      }
      if (self) propagateWithWeight(self, fn.self);
    } else if (type) {
      propagateWithWeight(type, aval);
    }
  };
});

});

define("tern/plugin/modules",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("../lib/signal"), require)
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "../lib/signal"], mod)
  mod(tern, tern, tern.signal)
})(function(infer, tern, signal, require) {
  "use strict"

  function Modules(server, options) {
    this.server = server
    this.options = options || {}
    this.modules = Object.create(null)
    this.nonRelative = Object.create(null)
    this.knownModules = Object.create(null)
    this.resolvers = []
    this.modNameTests = []
    this.importTests = []
  }

  Modules.prototype = signal.mixin({
    buildWrappingScope: function(parent, origin, node) {
      var scope = new infer.Scope(parent, node)
      scope.origin = origin
      this.signal("wrapScope", scope)
      return scope
    },

    maybeOverride: function(name) {
      if (!this.options.modules || !this.options.modules.hasOwnProperty(name))
        return false
      if (this.modules[name]) return this.modules[name]

      var override = this.options.modules[name]
      if (typeof(override) == "string" && override.charAt(0) == "=")
        return infer.def.parsePath(override.slice(1))

      var scope = this.buildWrappingScope(infer.cx().topScope, name)
      infer.def.load(override, scope)
      return this.modules[name] = scope.exports
    },

    resolveModule: function(name, parentFile) {
      var over = this.maybeOverride(name)
      if (over) return over
      var known = this.knownModules[name]
      if (known) return known
      if (this.options.dontLoad == true ||
          this.options.dontLoad && new RegExp(this.options.dontLoad).test(name) ||
          this.options.load && !new RegExp(this.options.load).test(name))
        return infer.ANull

      var resolved, relative = isRelative(name)
      for (var i = 0; !resolved && i < this.resolvers.length; i++)
        resolved = this.resolvers[i](name, parentFile)
      if (!resolved) resolved = defaultResolver(name, parentFile)
      if (!resolved) return infer.ANull
      if (typeof resolved != "string") {
        if (!relative) this.nonRelative[name] = true
        return resolved
      }

      var known = this.modules[resolved]
      if (known) return known

      if (/\.js$|(?:^\/)[^\.]+$/.test(resolved))
        this.server.addFile(resolved, null, parentFile)
      if (!relative) this.nonRelative[name] = resolved
      return this.modules[resolved] = new infer.AVal
    },

    findIn: function(array, node) {
      for (var i = 0; i < array.length; i++) {
        var name = array[i](node)
        if (name != null) return name
      }
    },

    isModName: function(node) { return this.findIn(this.modNameTests, node) },
    isImport: function(node) { return this.findIn(this.importTests, node) },

    get: function(name) {
      return this.modules[name] || (this.modules[name] = new infer.AVal)
    },

    completeModuleName: function(completions, query, word) {
      function fromObj(obj, useVal) {
        for (var name in obj)
          if (filter(word, name, query))
            tern.addCompletion(query, completions, name, useVal && obj[name])
      }

      fromObj(this.knownModules, true)
      if (this.options.modules) fromObj(this.options.modules, false)

      var pathsSeen = Object.create(null)
      for (var prop in this.nonRelative) {
        var val = this.nonRelative[prop]
        if (val == true || prop.indexOf("/") == -1) {
          if (filter(word, prop, query)) tern.addCompletion(query, completions, prop)
        } else if (prop.indexOf(word) == 0 && word.indexOf("/") > -1) {
          var afterSlash = /.*?\/(.*)/.exec(prop)[1]
          var found = val.indexOf(afterSlash)
          if (found > -1) {
            var dir = val.slice(0, found) + (/.*?\/(.*\/)?/.exec(word)[1] || "")
            if (dir in pathsSeen) continue
            pathsSeen[dir] = true
            this.completeFileName(completions, query, null, word, dir)
          }
        }
      }
    },

    completeFileName: function(completions, query, parentFile, word, _dir) {
      var path = parentFile ? resolvePath(dirName(parentFile), word) : baseName(word)
      for (var prop in this.modules) {
        if (prop != parentFile && filter(path, prop, query)) {
          if (/\.js$/.test(prop)) prop = prop.slice(0, prop.length - 3)
          var added = prop.slice(path.length)
          tern.addCompletion(query, completions, word + added, this.modules[prop])
        }
      }
    },

    getModType: function(node) {
      var modName = this.isModName(node), imp, prop
      if (modName == null && (imp = this.isImport(node))) {
        modName = imp.name
        prop = imp.prop
      }
      if (modName == null) return

      var modType = this.resolveModule(modName, node.sourceFile.name)
      return (prop ? modType.getProp(prop) : modType).getType()
    }
  })

  function resolvePath(parent, sub) {
    if (/^https?:|^\//.test(sub)) return sub
    if (parent && !/\/$/.test(parent)) parent = parent + "/"
    var m
    while (m = /^\.(\.)?\//.exec(sub)) {
      if (m[1] && parent.length > 1) {
        var lastSlash = parent.lastIndexOf("/", parent.length - 2)
        parent = lastSlash == -1 ? "" : parent.slice(0, lastSlash + 1)
      }
      sub = sub.slice(m[0].length)
    }
    return parent + sub
  }

  function dirName(path) {
    var lastSlash = path.lastIndexOf("/")
    if (lastSlash == -1) return ""
    return path.slice(0, lastSlash + 1)
  }
  function baseName(path) {
    var lastSlash = path.lastIndexOf("/")
    if (lastSlash == -1) return path
    else return path.slice(lastSlash + 1)
  }

  function defaultResolver(name, parentFile) {
    if (!/^\.\.?\//.test(name)) return
    var path = resolvePath(dirName(parentFile), name)
    var server = infer.cx().parent
    if (server.findFile(path)) return path
    if (server.findFile(path + ".js")) return path + ".js"
  }
  if (require) (function() {
    var fs = require("fs"), path = require("path")

    Modules.prototype.completeFileName = function(completions, query, parentFile, word, dir) {
      var pDir = this.server.projectDir
      var endSlash = /\/$/.test(word)
      if (parentFile) {
        var pt = path.resolve(pDir, path.dirname(parentFile), word)
        dir = endSlash ? pt : path.dirname(pt)
      }
      var base = endSlash ? word : path.dirname(word) + "/"
      var filePart = endSlash ? "" : path.basename(word)

      var me = this
      fs.readdirSync(dir).forEach(function(file) {
        if (/^\./.test(file)) return
        if (filter(filePart, file, query)) {
          var projectPath = me.server.normalizeFilename(path.relative(pDir, path.resolve(dir, file)))
          if (projectPath == parentFile) return
          var value = me.modules[projectPath]
          if (/\.js$/.test(file)) file = file.slice(0, file.length - 3)
          tern.addCompletion(query, completions, base + file, value)
        }
      })
    }
  }())

  function isRelative(path) {
    return /^\.\.?\//.test(path)
  }

  function filter(word, string, query) {
    return query.filter === false || !word ||
      (query.caseInsensitive ? string.toLowerCase() : string).indexOf(word) == 0
  }

  function preCondenseReach(state) {
    var mods = infer.cx().parent.mod.modules.modules
    var node = state.roots["!modules"] = new infer.Obj(null)
    for (var name in mods) {
      var mod = mods[name]
      var id = mod.origin || name
      var prop = node.defProp(id.replace(/\./g, "`"))
      prop.origin = mod.origin
      mod.propagate(prop)
    }
  }

  function postLoadDef(data) {
    var cx = infer.cx(), me = cx.parent.mod.modules
    var mods = cx.definitions[data["!name"]]["!modules"]
    if (mods) for (var name in mods.props) {
      var origin = name.replace(/`/g, ".")
      var mod = me.get(origin)
      mod.origin = origin
      mods.props[name].propagate(mod)
    }
    var known = cx.definitions[data["!name"]]["!known_modules"]
    if (known) for (var name in known.props)
      me.knownModules[name.replace(/`/g, ".")] = known.props[name]
  }

  function findTypeAt(_file, _pos, expr, type) {
    if (!expr) return type
    var me = infer.cx().parent.mod.modules
    var modType = me.getModType(expr.node)
    if (!modType) return type
    type = Object.create(type)
    type.origin = modType.origin
    type.originNode = modType.originNode
    if (modType.doc) type.doc = modType.doc
    if (modType.url) type.url = modType.url
    return type
  }
  function findCompletions(file, query) {
    var wordEnd = tern.resolvePos(file, query.end)
    var expr = infer.findExpressionAround(file.ast, null, wordEnd, file.scope)
    if (!expr) return null
    var me = infer.cx().parent.mod.modules

    if (me.isModName(expr.node) != null)
      return findModuleCompletions(me, file, query, expr.node, wordEnd)

    var imp = me.isImport(expr.node)
    if (imp && imp.name && imp.prop != null)
      return findImportCompletions(me, file, query, expr.node, imp, wordEnd)
  }

  function findImportCompletions(me, file, query, node, imp, wordEnd) {
    var completions = []
    var word = node.name.slice(0, wordEnd - node.start)
    if (query.caseInsensitive) word = word.toLowerCase()

    var modType = me.resolveModule(imp.name, node.sourceFile.name).getType()
    if (!modType) return null
    infer.forAllPropertiesOf(modType, function(prop, obj, depth) {
      if (obj == infer.cx().protos.Object) return
      if (query.filter !== false && word &&
          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return
      tern.addCompletion(query, completions, prop, obj && obj.props[prop], depth)
    })
    return {
      start: tern.outputPos(query, file, node.start),
      end: tern.outputPos(query, file, wordEnd),
      completions: completions,
      isSpecifier: true
    }
  }

  function findModuleCompletions(me, file, query, argNode, wordEnd) {
    if (argNode.type != "Literal" || typeof argNode.value != "string" ||
        argNode.start > wordEnd || argNode.end < wordEnd) return

    var word = argNode.raw.slice(1, wordEnd - argNode.start), quote = argNode.raw.charAt(0)
    if (word && word.charAt(word.length - 1) == quote)
      word = word.slice(0, word.length - 1)
    if (query.caseInsensitive) word = word.toLowerCase()

    var completions = []
    if (isRelative(word)) me.completeFileName(completions, query, file.name, word)
    else me.completeModuleName(completions, query, word)

    if (argNode.end == wordEnd + 1 && file.text.charAt(wordEnd) == quote)
      ++wordEnd
    return {
      start: tern.outputPos(query, file, argNode.start),
      end: tern.outputPos(query, file, wordEnd),
      isProperty: false,
      completions: completions.map(function(rec) {
        var name = typeof rec == "string" ? rec : rec.name
        var string = JSON.stringify(name)
        if (quote == "'") string = quote + string.slice(1, string.length -1).replace(/'/g, "\\'") + quote
        if (typeof rec == "string") return string
        rec.displayName = name
        rec.name = string
        return rec
      })
    }
  }

  tern.registerPlugin("modules", function(server, options) {
    server.mod.modules = new Modules(server, options)

    server.on("beforeLoad", function(file) {
      file.scope = this.mod.modules.buildWrappingScope(file.scope, file.name, file.ast)
    })

    server.on("afterLoad", function(file) {
      var mod = this.mod.modules.get(file.name)
      mod.origin = file.name
      this.mod.modules.signal("getExports", file, mod)
    })

    server.on("reset", function() {
      this.mod.modules.modules = Object.create(null)
    })

    server.on("preCondenseReach", preCondenseReach)
    server.on("postLoadDef", postLoadDef)
    server.on("typeAt", findTypeAt)
    server.on("completion", findCompletions)
  })

  tern.defineQueryType("exports", {
    takesFile: true,
    run: function(server, query, file) {
      function describe(aval) {
        var target = {}, type = aval.getType(false)
        target.type = infer.toString(type, 3)
        var doc = aval.doc || (type && type.doc), url = aval.url || (type && type.url)
        if (doc) target.doc = doc
        if (url) target.url = url
        var span = tern.getSpan(aval) || (type && tern.getSpan(type))
        if (span) tern.storeSpan(server, query, span, target)
        return target
      }

      var mod = server.mod.modules, known = mod && mod.modules[file.name]
      if (!known) return {}
      var resp = describe(known);
      var type = known.getType(false)
      if (type instanceof infer.Obj) {
        var props = resp.props = {}
        for (var prop in type.props)
          props[prop] = describe(type.props[prop])
      }
      return resp
    }
  })
})

});

define("tern/plugin/es_modules",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("acorn/dist/walk"), require("./modules"))
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "acorn/dist/walk", "./modules"], mod)
  mod(tern, tern, acorn.walk)
})(function(infer, tern, walk) {
  "use strict"

  var WG_IMPORT_DEFAULT_FALLBACK = 80

  function connectModule(file, out) {
    var modules = infer.cx().parent.mod.modules
    var outObj = null
    function exp(prop, type, originNode) {
      if (!outObj) {
        outObj = new infer.Obj(true)
        outObj.origin = file.name
        outObj.originNode = file.ast
        out.addType(outObj)
      }
      type.propagate(outObj.defProp(prop, originNode))
    }

    walk.simple(file.ast, {
      ImportDeclaration: function(node) {
        var input = modules.resolveModule(node.source.value, file.name)
        for (var i = 0; i < node.specifiers.length; i++) {
          var spec = node.specifiers[i]
          var aval = file.scope.getProp(spec.local.name)
          if (spec.type == "ImportNamespaceSpecifier") {
            input.propagate(aval)
          } else if (spec.type == "ImportDefaultSpecifier") {
            input.getProp("default").propagate(aval)
            input.propagate(aval, WG_IMPORT_DEFAULT_FALLBACK)
          } else {
            input.getProp(spec.imported.name).propagate(aval)
          }
        }
      },
      ExportAllDeclaration: function(node) {
        var input = modules.resolveModule(node.source.value, file.name)
        input.forAllProps(function(prop, val, local) {
          if (local) exp(prop, val, val.originNode)
        })
      },
      ExportDefaultDeclaration: function(node) {
        var decl = node.declaration.id || node.declaration
        exp("default", infer.expressionType({node: decl, state: file.scope}), decl)
      },
      ExportNamedDeclaration: function(node) {
        var decl = node.declaration
        if (decl) {
          if (decl.type == "VariableDeclaration") {
            for (var i = 0; i < decl.declarations.length; ++i) {
              var cur = decl.declarations[i]
              if (cur.id.type == "Identifier")
                exp(cur.id.name, file.scope.getProp(cur.id.name), cur.id)
            }
          } else {
            exp(decl.id.name, file.scope.getProp(decl.id.name), decl.id)
          }
        }
        if (node.specifiers.length) {
          var src = node.source ? modules.resolveModule(node.source.value, file.name) : file.scope
          for (var i = 0; i < node.specifiers.length; i++) {
            var spec = node.specifiers[i]
            exp(spec.exported.name, src.getProp(spec.local.name), spec.local)
          }
        }
      }
    })
  }

  function isModuleName(node) {
    if (node.type != "Literal" || typeof node.value != "string") return

    var decl = infer.findExpressionAround(node.sourceFile.ast, null, node.end, null, function(_, node) {
      return node.type == "ImportDeclaration" || /Export(All|Named)Declaration/.test(node.type)
    })
    if (!decl || decl.node.source != node) return
    return node.value
  }

  function isImport(node) {
    if (node.type != "Identifier") return
    var imp = infer.findExpressionAround(node.sourceFile.ast, null, node.end, null, "ImportDeclaration")
    if (!imp) return
    var specs = imp.node.specifiers
    for (var i = 0; i < specs.length; i++) {
      var spec = specs[i]
      if (spec.local != node) continue
      var result = {name: imp.node.source.value, prop: null}
      if (spec.type == "ImportDefaultSpecifier") result.prop = "default"
      else if (spec.type == "ImportSpecifier") result.prop = spec.imported.name
      return result
    }
  }

  tern.registerPlugin("es_modules", function(server) {
    server.loadPlugin("modules")
    server.mod.modules.on("getExports", connectModule)
    server.mod.modules.modNameTests.push(isModuleName)
    server.mod.modules.importTests.push(isImport)
  })
})

});

define("tern/plugin/commonjs",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("./modules"))
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "./modules"], mod)
  mod(tern, tern)
})(function(infer, tern) {
  "use strict"

  var WG_DEFAULT_EXPORT = 95

  function initScope(scope) {
    var defs = infer.cx().definitions.commonjs
    defs.require.propagate(scope.defProp("require"))
    var module = new infer.Obj(defs.Module.getProp("prototype").getType())
    module.propagate(scope.defProp("module"))
    var exports = new infer.Obj(true)
    module.origin = exports.origin = scope.origin
    module.originNode = exports.originNode = scope.originNode
    exports.propagate(scope.defProp("exports"))
    var moduleExports = scope.exports = module.defProp("exports")
    exports.propagate(moduleExports, WG_DEFAULT_EXPORT)
  }

  infer.registerFunction("require", function(_self, _args, argNodes) {
    if (!argNodes || !argNodes.length || argNodes[0].type != "Literal" || typeof argNodes[0].value != "string")
      return infer.ANull
    var cx = infer.cx(), server = cx.parent
    var currentFile = argNodes[0].sourceFile.name

    var name = argNodes[0].value
    var resolved = server.mod.modules.resolveModule(name, currentFile)
    return resolved
  })

  function isStaticRequire(node) {
    if (node.type != "CallExpression" || node.callee.type != "Identifier" || node.callee.name != "require") return
    var arg = node.arguments[0]
    if (arg && arg.type == "Literal" && typeof arg.value == "string") return arg.value
  }

  function isModuleName(node) {
    if (node.type != "Literal" || typeof node.value != "string") return

    var call = infer.findExpressionAround(node.sourceFile.ast, null, node.end, null,
                                          function(_, n) { return isStaticRequire(n) != null })
    if (call && call.node.arguments[0] == node) return node.value
  }

  function isImport(node) {
    if (node.type != "Identifier") return
    var decl = infer.findExpressionAround(node.sourceFile.ast, null, node.end, null, "VariableDeclarator"), name
    if (!decl || decl.node.id != node) return
    var init = decl.node.init
    if (init && (name = isStaticRequire(init)) != null)
      return {name: name, prop: null}
    if (init && init.type == "MemberExpression" && !init.computed && (name = isStaticRequire(init.object)) != null)
      return {name: name, prop: init.property.name}
  }

  function hasProps(obj) {
    if (obj) for (var _prop in obj) return true
  }

  tern.registerPlugin("commonjs", function(server) {
    server.loadPlugin("modules")
    server.mod.modules.on("wrapScope", initScope)
    server.mod.modules.on("getExports", function(file, mod) {
      var exports = file.scope.exports
      if (exports.types.length > 1 || hasProps(exports.getObjType()))
        exports.propagate(mod)
    })

    server.mod.modules.modNameTests.push(isModuleName)
    server.mod.modules.importTests.push(isImport)

    server.addDefs(defs)
  })

  var defs = {
    "!name": "commonjs",
    "!define": {
      require: {
        "!type": "fn(id: string) -> !custom:require",
        resolve: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/globals.html#globals_require_resolve",
          "!doc": "Use the internal require() machinery to look up the location of a module, but rather than loading the module, just return the resolved filename."
        },
        cache: {
          "!url": "https://nodejs.org/api/globals.html#globals_require_cache",
          "!doc": "Modules are cached in this object when they are required. By deleting a key value from this object, the next require will reload the module."
        },
        extensions: {
          "!url": "https://nodejs.org/api/globals.html#globals_require_extensions",
          "!doc": "Instruct require on how to handle certain file extensions."
        },
        "!url": "https://nodejs.org/api/globals.html#globals_require",
        "!doc": "To require modules."
      },
      Module: {
        "!type": "fn()",
        "!url": "https://nodejs.org/api/modules.html",
        "!doc": "Node has a simple module loading system. In Node, files and modules are in one-to-one correspondence.",
        prototype: {
          exports: {
            "!type": "?",
            "!url": "https://nodejs.org/api/modules.html#modules_module_exports",
            "!doc": "The exports object is created by the Module system. Sometimes this is not acceptable, many want their module to be an instance of some class. To do this assign the desired export object to module.exports. For example suppose we were making a module called a.js"
          },
          require: {
            "!type": "require",
            "!url": "https://nodejs.org/api/modules.html#modules_module_require_id",
            "!doc": "The module.require method provides a way to load a module as if require() was called from the original module."
          },
          id: {
            "!type": "string",
            "!url": "https://nodejs.org/api/modules.html#modules_module_id",
            "!doc": "The identifier for the module. Typically this is the fully resolved filename."
          },
          filename: {
            "!type": "string",
            "!url": "https://nodejs.org/api/modules.html#modules_module_filename",
            "!doc": "The fully resolved filename to the module."
          },
          loaded: {
            "!type": "bool",
            "!url": "https://nodejs.org/api/modules.html#modules_module_loaded",
            "!doc": "Whether or not the module is done loading, or is in the process of loading."
          },
          parent: {
            "!type": "+Module",
            "!url": "https://nodejs.org/api/modules.html#modules_module_parent",
            "!doc": "The module that required this one."
          },
          children: {
            "!type": "[+Module]",
            "!url": "https://nodejs.org/api/modules.html#modules_module_children",
            "!doc": "The module objects required by this one."
          }
        }
      },
      module: {}
    },
    module: {
      "!type": "+Module",
      "!url": "https://nodejs.org/api/globals.html#globals_module",
      "!doc": "A reference to the current module. In particular module.exports is the same as the exports object. module isn't actually a global but rather local to each module."
    }
  }
})

});

define("tern/plugin/node_resolve",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("./commonjs"), require)
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "./commonjs"], mod)
  mod(tern, tern)
})(function(infer, tern, _, require) {
  "use strict"

  function resolve(name, parentFile) {
    var resolved = resolveToFile(name, parentFile)
    return resolved && infer.cx().parent.normalizeFilename(resolved)
  }

  function findDeclaredDeps() {}

  var resolveToFile
  if (require) (function() {
    var module_ = require("module"), path = require("path"), fs = require("fs")

    resolveToFile = function(name, parentFile) {
      var projectDir = infer.cx().parent.projectDir
      var fullParent = path.resolve(projectDir, parentFile)
      var parentDir = path.dirname(fullParent)
      if (/^\.\.?\//.test(name))
        name = path.resolve(projectDir, parentDir, name)

      var parentModule = {
        id: fullParent,
        paths: module_._nodeModulePaths(parentDir)
      }
      try {
        return module_._resolveFilename(name, parentModule)
      } catch(e) {
        return null
      }
    }

    function findPackageFile(dir) {
      for (;;) {
        try {
          return JSON.parse(fs.readFileSync(path.resolve(dir, "package.json")))
        } catch(e) {}
        var shorter = path.dirname(dir)
        if (shorter == dir) return null
        dir = shorter
      }
    }

    findDeclaredDeps = function(path, knownModules) {
      var packageFile = findPackageFile(path)
      if (!packageFile) return null

      function add(obj) {
        for (var name in obj) if (!(name in knownModules)) knownModules[name] = null
      }
      add(packageFile.dependencies)
      add(packageFile.devDependencies)
      add(packageFile.peerDependencies)
    }

  })(); else (function() {
    function resolvePath(base, path) {
      if (path[0] == "/") return path;
      var slash = base.lastIndexOf("/"), m;
      if (slash >= 0) path = base.slice(0, slash + 1) + path;
      while (m = /[^\/]*[^\/\.][^\/]*\/\.\.\//.exec(path))
        path = path.slice(0, m.index) + path.slice(m.index + m[0].length);
      return path.replace(/(^|[^\.])\.\//g, "$1");
    }

    resolveToFile = function(name, parentFile) {
      return /^\.\.?\//.test(name) ? resolvePath(parentFile, name) : name
    }
  })()

  tern.registerPlugin("node_resolve", function(server) {
    server.loadPlugin("commonjs")
    server.mod.modules.resolvers.push(resolve)
    findDeclaredDeps(server.projectDir, server.mod.modules.knownModules)
  })
})

});

define("events",[], function(require, exports, module) {

var EventEmitter = module.exports = function() {};
EventEmitter.EventEmitter = EventEmitter;

var toString = Object.prototype.toString;

var isArray = Array.isArray || function(obj) {
    return toString.call(obj) === '[object Array]';
};
//
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
    if (!this._events) this._events = {};
    this._events.maxListeners = n;
};
EventEmitter.prototype.emit = function(type) {
    if (!this._events) 
        return;

    var handler = this._events[type];
    if (!handler) 
        return;
    
    var returnValue;

    if (typeof handler == 'function') {
        switch (arguments.length) {
        case 1:
            return handler.call(this);
        case 2:
            return handler.call(this, arguments[1]);
        case 3:
            return handler.call(this, arguments[1], arguments[2]);
        default:
            var args = Array.prototype.slice.call(arguments, 1);
            returnValue = handler.apply(this, args);
        }
    }
    else if (isArray(handler)) {
        var args = Array.prototype.slice.call(arguments, 1);

        var listeners = handler.slice(), temp;
        for (var i = 0, l = listeners.length; i < l; i++) {
            temp = listeners[i].apply(this, args);
            if (temp !== undefined) 
                returnValue = temp;
        }
    }
    
    return returnValue;
};
EventEmitter.prototype.addListener = function(type, listener, plugin) {
    if ('function' !== typeof listener) {
        throw new Error('addListener only takes instances of Function');
    }

    if (!this._events) this._events = {};

    var eventList = this._events[type];

    if (!eventList) {
        this._events[type] = listener;
    }
    else if (isArray(eventList)) {
        if (!eventList.warned) {
            var m;
            if (this._events.maxListeners !== undefined) {
                m = this._events.maxListeners;
            }
            else {
                m = defaultMaxListeners;
            }

            if (m && m > 0 && eventList.length > m) {
                eventList.warned = true;
                console.error('warning: possible EventEmitter memory '
                    + 'leak detected. " + eventList.length + " listeners of type "' + type + '" added. '
                    + 'Use emitter.setMaxListeners() to increase limit.'
                );
                console.trace();
            }
        }
        eventList.push(listener);
    }
    else {
        this._events[type] = [eventList, listener];
    }
    
    if (type != "newListener") 
        this.emit('newListener', type, listener);
    
    plugin && plugin.addEvent(this, type, listener);

    return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener, plugin) {
    var self = this;
    
    var wrapped = function() {
        self.removeListener(type, listener);
        return listener.apply(self, arguments);
    };
    wrapped.listener = listener;
    
    self.on(type, wrapped, plugin);

    return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
    if ('function' !== typeof listener) {
        throw new Error('removeListener only takes instances of Function');
    }
    if (!this._events || !this._events[type]) return this;

    var list = this._events[type];

    if (isArray(list)) {
        if (!list.some(function(l, i) {
            if ((l.listener || l) == listener) {
                list.splice(i, 1);
                return true;
            }
        })) return this;
        
        if (list.length === 0) 
            delete this._events[type];
    }
    else if ((this._events[type].listener || this._events[type]) === listener) {
        delete this._events[type];
    }
    
    if (type != "removeListener")
        this.emit('removeListener', type, listener);

    return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function(type) {
    if (type && this._events && this._events[type]) this._events[type] = null;
    return this;
};

EventEmitter.prototype.listeners = function(type) {
    if (!this._events) this._events = {};
    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
        this._events[type] = [this._events[type]];
    }
    return this._events[type];
};
 
});

define("tern/plugin/node",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/tern"), require("./node_resolve"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/tern", "./node_resolve"], mod);
  mod(tern, tern);
})(function(tern) {
  "use strict"

  tern.registerPlugin("node", function(server) {
    server.loadPlugin("node_resolve")
    server.on("postReset", function() {
      var mods = server.mod.modules, locals = server.cx.definitions.node
      for (var name in locals) if (/^[a-z_]*$/.test(name))
        mods.knownModules[name] = locals[name]
    })
    server.addDefs(defs)
  })

  var defs = {
    "!name": "node",
    "!define": {
      events: {
        "!url": "https://nodejs.org/api/events.html",
        "!doc": "Many objects in Node emit events: a net.Server emits an event each time a peer connects to it, a fs.readStream emits an event when the file is opened. All objects which emit events are instances of events.EventEmitter.",
        EventEmitter: {
          prototype: {
            addListener: {
              "!type": "fn(event: string, listener: fn())",
              "!url": "https://nodejs.org/api/events.html#events_emitter_addlistener_event_listener",
              "!doc": "Adds a listener to the end of the listeners array for the specified event."
            },
            on: {
              "!type": "fn(event: string, listener: fn())",
              "!url": "https://nodejs.org/api/events.html#events_emitter_on_event_listener",
              "!doc": "Adds a listener to the end of the listeners array for the specified event."
            },
            once: {
              "!type": "fn(event: string, listener: fn())",
              "!url": "https://nodejs.org/api/events.html#events_emitter_once_event_listener",
              "!doc": "Adds a one time listener for the event. This listener is invoked only the next time the event is fired, after which it is removed."
            },
            removeListener: {
              "!type": "fn(event: string, listener: fn())",
              "!url": "https://nodejs.org/api/events.html#events_emitter_removelistener_event_listener",
              "!doc": "Remove a listener from the listener array for the specified event. Caution: changes array indices in the listener array behind the listener."
            },
            removeAllListeners: {
              "!type": "fn(event: string)",
              "!url": "https://nodejs.org/api/events.html#events_emitter_removealllisteners_event",
              "!doc": "Removes all listeners, or those of the specified event."
            },
            setMaxListeners: {
              "!type": "fn(n: number)",
              "!url": "https://nodejs.org/api/events.html#events_emitter_setmaxlisteners_n",
              "!doc": "By default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default which helps finding memory leaks. Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited."
            },
            listeners: {
              "!type": "fn(event: string) -> [fn()]",
              "!url": "https://nodejs.org/api/events.html#events_emitter_listeners_event",
              "!doc": "Returns an array of listeners for the specified event."
            },
            emit: {
              "!type": "fn(event: string)",
              "!url": "https://nodejs.org/api/events.html#events_emitter_emit_event_arg1_arg2",
              "!doc": "Execute each of the listeners in order with the supplied arguments."
            }
          },
          "!url": "https://nodejs.org/api/events.html#events_class_events_eventemitter",
          "!doc": "To access the EventEmitter class, require('events').EventEmitter."
        }
      },
      stream: {
        "!type": "fn()",
        prototype: {
          "!proto": "events.EventEmitter.prototype",
          pipe: {
            "!type": "fn(destination: +stream.Writable, options?: ?)",
            "!url": "https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options",
            "!doc": "Connects this readable stream to destination WriteStream. Incoming data on this stream gets written to destination. Properly manages back-pressure so that a slow destination will not be overwhelmed by a fast readable stream."
          }
        },
        Writable: {
          "!type": "fn(options?: ?)",
          prototype: {
            "!proto": "stream.prototype",
            write: {
              "!type": "fn(chunk: string|+Buffer, encoding?: string, callback?: fn()) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback_1",
              "!doc": "Writes chunk to the stream. Returns true if the data has been flushed to the underlying resource. Returns false to indicate that the buffer is full, and the data will be sent out in the future. The 'drain' event will indicate when the buffer is empty again."
            },
            cork: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_cork",
              "!doc": "Forces buffering of all writes. Buffered data will be flushed either at .uncork() or at .end() call."
            },
            uncork: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_uncork",
              "!doc": "Flush all data, buffered since .cork() call."
            },
            setDefaultEncoding: {
              "!type": "fn(encoding: string) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_setdefaultencoding_encoding",
              "!doc": "Sets the default encoding for a writable stream. Returns true if the encoding is valid and is set. Otherwise returns false."
            },
            end: {
              "!type": "fn(chunk?: string|+Buffer, encoding?: string, callback?: fn()) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_end_chunk_encoding_callback",
              "!doc": "Call this method to signal the end of the data being written to the stream."
            }
          },
          "!url": "https://nodejs.org/api/stream.html#stream_class_stream_writable",
          "!doc": "A Writable Stream has the following methods, members, and events."
        },
        Readable: {
          "!type": "fn(options?: ?)",
          prototype: {
            "!proto": "stream.prototype",
            setEncoding: {
              "!type": "fn(encoding: string)",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_setencoding_encoding",
              "!doc": "Makes the 'data' event emit a string instead of a Buffer. encoding can be 'utf8', 'utf16le' ('ucs2'), 'ascii', or 'hex'."
            },
            pause: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_pause",
              "!doc": "Switches the readable stream into \"old mode\", where data is emitted using a 'data' event rather than being buffered for consumption via the read() method."
            },
            resume: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_resume",
              "!doc": "Switches the readable stream into \"old mode\", where data is emitted using a 'data' event rather than being buffered for consumption via the read() method."
            },
            destroy: "fn()",
            unpipe: {
              "!type": "fn(dest?: +stream.Writable)",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_unpipe_destination",
              "!doc": "Undo a previously established pipe(). If no destination is provided, then all previously established pipes are removed."
            },
            push: {
              "!type": "fn(chunk: +Buffer) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_push_chunk",
              "!doc": "Explicitly insert some data into the read queue. If called with null, will signal the end of the data."
            },
            unshift: {
              "!type": "fn(chunk: +Buffer) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_unshift_chunk",
              "!doc": "This is the corollary of readable.push(chunk). Rather than putting the data at the end of the read queue, it puts it at the front of the read queue."
            },
            wrap: {
              "!type": "fn(stream: ?) -> +stream.Readable",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_wrap_stream",
              "!doc": "If you are using an older Node library that emits 'data' events and has a pause() method that is advisory only, then you can use the wrap() method to create a Readable stream that uses the old stream as its data source."
            },
            read: {
              "!type": "fn(size?: number) -> +Buffer",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_read_size_1",
              "!doc": "Call this method to consume data once the 'readable' event is emitted."
            }
          },
          "!url": "https://nodejs.org/api/stream.html#stream_class_stream_readable",
          "!doc": "A Readable Stream has the following methods, members, and events."
        },
        Duplex: {
          "!type": "fn(options?: ?)",
          prototype: {
            "!proto": "stream.Readable.prototype",
            write: "fn(chunk: +Buffer, encoding?: string, callback?: fn()) -> bool",
            end: "fn(chunk: +Buffer, encoding?: string, callback?: fn()) -> bool"
          },
          "!url": "https://nodejs.org/api/stream.html#stream_class_stream_duplex",
          "!doc": "A \"duplex\" stream is one that is both Readable and Writable, such as a TCP socket connection."
        },
        Transform: {
          "!type": "fn(options?: ?)",
          prototype: {
            "!proto": "stream.Duplex.prototype"
          },
          "!url": "https://nodejs.org/api/stream.html#stream_class_stream_transform",
          "!doc": "A \"transform\" stream is a duplex stream where the output is causally connected in some way to the input, such as a zlib stream or a crypto stream."
        },
        PassThrough: "stream.Transform",
        "!url": "https://nodejs.org/api/stream.html#stream_stream",
        "!doc": "A stream is an abstract interface implemented by various objects in Node. For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of EventEmitter"
      },
      querystring: {
        "!url": "https://nodejs.org/api/querystring.html",
        "!doc": "This module provides utilities for dealing with query strings.",
        stringify: {
          "!type": "fn(obj: ?, sep?: string, eq?: string) -> string",
          "!url": "https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq",
          "!doc": "Serialize an object to a query string. Optionally override the default separator ('&') and assignment ('=') characters."
        },
        parse: {
          "!type": "fn(str: string, sep?: string, eq?: string, options?: ?) -> ?",
          "!url": "https://nodejs.org/api/querystring.html#querystring_querystring_parse_str_sep_eq_options",
          "!doc": "Deserialize a query string to an object. Optionally override the default separator ('&') and assignment ('=') characters."
        },
        escape: {
          "!type": "fn(string) -> string",
          "!url": "https://nodejs.org/api/querystring.html#querystring_querystring_escape",
          "!doc": "The escape function used by querystring.stringify, provided so that it could be overridden if necessary."
        },
        unescape: {
          "!type": "fn(string) -> string",
          "!url": "https://nodejs.org/api/querystring.html#querystring_querystring_unescape",
          "!doc": "The unescape function used by querystring.parse, provided so that it could be overridden if necessary."
        }
      },
      http: {
        "!url": "https://nodejs.org/api/http.html",
        "!doc": "The HTTP interfaces in Node are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses--the user is able to stream data.",
        STATUS_CODES: {},
        createServer: {
          "!type": "fn(listener?: fn(request: +http.IncomingMessage, response: +http.ServerResponse)) -> +http.Server",
          "!url": "https://nodejs.org/api/http.html#http_http_createserver_requestlistener",
          "!doc": "Returns a new web server object."
        },
        Server: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            listen: {
              "!type": "fn(port: number, hostname?: string, backlog?: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback",
              "!doc": "Begin accepting connections on the specified port and hostname. If the hostname is omitted, the server will accept connections directed to any IPv4 address (INADDR_ANY)."
            },
            close: {
              "!type": "fn(callback?: ?)",
              "!url": "https://nodejs.org/api/http.html#http_server_close_callback",
              "!doc": "Stops the server from accepting new connections."
            },
            maxHeadersCount: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_server_maxheaderscount",
              "!doc": "Limits maximum incoming headers count, equal to 1000 by default. If set to 0 - no limit will be applied."
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_server_settimeout_msecs_callback",
              "!doc": "Sets the timeout value for sockets, and emits a 'timeout' event on the Server object, passing the socket as an argument, if a timeout occurs."
            },
            timeout: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_server_timeout",
              "!doc": "The number of milliseconds of inactivity before a socket is presumed to have timed out."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_class_http_server",
          "!doc": "Class for HTTP server objects."
        },
        ServerResponse: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Writable.prototype",
            writeContinue: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/http.html#http_response_writecontinue",
              "!doc": "Sends a HTTP/1.1 100 Continue message to the client, indicating that the request body should be sent."
            },
            writeHead: {
              "!type": "fn(statusCode: number, headers?: ?)",
              "!url": "https://nodejs.org/api/http.html#http_response_writehead_statuscode_reasonphrase_headers",
              "!doc": "Sends a response header to the request. The status code is a 3-digit HTTP status code, like 404. The last argument, headers, are the response headers. Optionally one can give a human-readable reasonPhrase as the second argument."
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_response_settimeout_msecs_callback",
              "!doc": "Sets the Socket's timeout value to msecs. If a callback is provided, then it is added as a listener on the 'timeout' event on the response object."
            },
            statusCode: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_response_statuscode",
              "!doc": "When using implicit headers (not calling response.writeHead() explicitly), this property controls the status code that will be sent to the client when the headers get flushed."
            },
            setHeader: {
              "!type": "fn(name: string, value: string)",
              "!url": "https://nodejs.org/api/http.html#http_response_setheader_name_value",
              "!doc": "Sets a single header value for implicit headers. If this header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings here if you need to send multiple headers with the same name."
            },
            headersSent: {
              "!type": "bool",
              "!url": "https://nodejs.org/api/http.html#http_response_headerssent",
              "!doc": "Boolean (read-only). True if headers were sent, false otherwise."
            },
            sendDate: {
              "!type": "bool",
              "!url": "https://nodejs.org/api/http.html#http_response_senddate",
              "!doc": "When true, the Date header will be automatically generated and sent in the response if it is not already present in the headers. Defaults to true."
            },
            getHeader: {
              "!type": "fn(name: string) -> string",
              "!url": "https://nodejs.org/api/http.html#http_response_getheader_name",
              "!doc": "Reads out a header that's already been queued but not sent to the client. Note that the name is case insensitive. This can only be called before headers get implicitly flushed."
            },
            removeHeader: {
              "!type": "fn(name: string)",
              "!url": "https://nodejs.org/api/http.html#http_response_removeheader_name",
              "!doc": "Removes a header that's queued for implicit sending."
            },
            addTrailers: {
              "!type": "fn(headers: ?)",
              "!url": "https://nodejs.org/api/http.html#http_response_addtrailers_headers",
              "!doc": "This method adds HTTP trailing headers (a header but at the end of the message) to the response."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_class_http_serverresponse",
          "!doc": "This object is created internally by a HTTP server--not by the user. It is passed as the second parameter to the 'request' event."
        },
        request: {
          "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
          "!url": "https://nodejs.org/api/http.html#http_http_request_options_callback",
          "!doc": "Node maintains several connections per server to make HTTP requests. This function allows one to transparently issue requests."
        },
        get: {
          "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
          "!url": "https://nodejs.org/api/http.html#http_http_get_options_callback",
          "!doc": "Since most requests are GET requests without bodies, Node provides this convenience method. The only difference between this method and http.request() is that it sets the method to GET and calls req.end() automatically."
        },
        globalAgent: {
          "!type": "+http.Agent",
          "!url": "https://nodejs.org/api/http.html#http_http_globalagent",
          "!doc": "Global instance of Agent which is used as the default for all http client requests."
        },
        Agent: {
          "!type": "fn()",
          prototype: {
            maxSockets: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_agent_maxsockets",
              "!doc": "By default set to 5. Determines how many concurrent sockets the agent can have open per host."
            },
            sockets: {
              "!type": "[+net.Socket]",
              "!url": "https://nodejs.org/api/http.html#http_agent_sockets",
              "!doc": "An object which contains arrays of sockets currently in use by the Agent. Do not modify."
            },
            requests: {
              "!type": "[+http.ClientRequest]",
              "!url": "https://nodejs.org/api/http.html#http_agent_requests",
              "!doc": "An object which contains queues of requests that have not yet been assigned to sockets. Do not modify."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_class_http_agent",
          "!doc": "In node 0.5.3+ there is a new implementation of the HTTP Agent which is used for pooling sockets used in HTTP client requests."
        },
        ClientRequest: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Writable.prototype",
            abort: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/http.html#http_request_abort",
              "!doc": "Aborts a request. (New since v0.3.8.)"
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback",
              "!doc": "Once a socket is assigned to this request and is connected socket.setTimeout() will be called."
            },
            setNoDelay: {
              "!type": "fn(noDelay?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_request_setnodelay_nodelay",
              "!doc": "Once a socket is assigned to this request and is connected socket.setNoDelay() will be called."
            },
            setSocketKeepAlive: {
              "!type": "fn(enable?: bool, initialDelay?: number)",
              "!url": "https://nodejs.org/api/http.html#http_request_setsocketkeepalive_enable_initialdelay",
              "!doc": "Once a socket is assigned to this request and is connected socket.setKeepAlive() will be called."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_class_http_clientrequest",
          "!doc": "This object is created internally and returned from http.request(). It represents an in-progress request whose header has already been queued. The header is still mutable using the setHeader(name, value), getHeader(name), removeHeader(name) API. The actual header will be sent along with the first data chunk or when closing the connection."
        },
        IncomingMessage: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Readable.prototype",
            httpVersion: {
              "!type": "string",
              "!url": "https://nodejs.org/api/http.html#http_message_httpversion",
              "!doc": "In case of server request, the HTTP version sent by the client. In the case of client response, the HTTP version of the connected-to server. Probably either '1.1' or '1.0'."
            },
            headers: {
              "!type": "?",
              "!url": "https://nodejs.org/api/http.html#http_message_headers",
              "!doc": "The request/response headers object."
            },
            trailers: {
              "!type": "?",
              "!url": "https://nodejs.org/api/http.html#http_message_trailers",
              "!doc": "The request/response trailers object. Only populated after the 'end' event."
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_message_settimeout_msecs_callback",
              "!doc": "Calls message.connection.setTimeout(msecs, callback)."
            },
            setEncoding: {
              "!type": "fn(encoding?: string)",
              "!url": "https://nodejs.org/api/http.html#http_message_setencoding_encoding",
              "!doc": "Set the encoding for data emitted by the 'data' event."
            },
            pause: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/http.html#http_message_pause",
              "!doc": "Pauses request/response from emitting events. Useful to throttle back a download."
            },
            resume: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/http.html#http_message_resume",
              "!doc": "Resumes a paused request/response."
            },
            method: {
              "!type": "string",
              "!url": "https://nodejs.org/api/http.html#http_message_method",
              "!doc": "Only valid for request obtained from http.Server."
            },
            url: {
              "!type": "string",
              "!url": "https://nodejs.org/api/http.html#http_message_url",
              "!doc": "Only valid for request obtained from http.Server."
            },
            statusCode: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_message_statuscode",
              "!doc": "Only valid for response obtained from http.ClientRequest."
            },
            socket: {
              "!type": "+net.Socket",
              "!url": "https://nodejs.org/api/http.html#http_message_socket",
              "!doc": "The net.Socket object associated with the connection."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_http_incomingmessage",
          "!doc": "An IncomingMessage object is created by http.Server or http.ClientRequest and passed as the first argument to the 'request' and 'response' event respectively. It may be used to access response status, headers and data."
        }
      },
      https: {
        "!url": "https://nodejs.org/api/http.html",
        "!doc": "HTTPS is the HTTP protocol over TLS/SSL. In Node this is implemented as a separate module.",
        Server: "http.Server",
        createServer: {
          "!type": "fn(listener?: fn(request: +http.IncomingMessage, response: +http.ServerResponse)) -> +https.Server",
          "!url": "https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener",
          "!doc": "Returns a new HTTPS web server object. The options is similar to tls.createServer(). The requestListener is a function which is automatically added to the 'request' event."
        },
        request: {
          "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
          "!url": "https://nodejs.org/api/https.html#https_https_request_options_callback",
          "!doc": "Makes a request to a secure web server."
        },
        get: {
          "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
          "!url": "https://nodejs.org/api/https.html#https_https_get_options_callback",
          "!doc": "Like http.get() but for HTTPS."
        },
        Agent: "http.Agent",
        globalAgent: "http.globalAgent"
      },
      cluster: {
        "!proto": "events.EventEmitter.prototype",
        settings: {
          exec: "string",
          args: "[string]",
          silent: "bool",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_settings",
          "!doc": "All settings set by the .setupMaster is stored in this settings object. This object is not supposed to be changed or set manually, by you."
        },
        Worker: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            id: {
              "!type": "string",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_id",
              "!doc": "Each new worker is given its own unique id, this id is stored in the id."
            },
            process: {
              "!type": "+child_process.ChildProcess",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_process",
              "!doc": "All workers are created using child_process.fork(), the returned object from this function is stored in process."
            },
            suicide: {
              "!type": "bool",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_suicide",
              "!doc": "This property is a boolean. It is set when a worker dies after calling .kill() or immediately after calling the .disconnect() method. Until then it is undefined."
            },
            send: {
              "!type": "fn(message: ?, sendHandle?: ?)",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_send_message_sendhandle",
              "!doc": "This function is equal to the send methods provided by child_process.fork(). In the master you should use this function to send a message to a specific worker. However in a worker you can also use process.send(message), since this is the same function."
            },
            destroy: "fn()",
            disconnect: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_disconnect",
              "!doc": "When calling this function the worker will no longer accept new connections, but they will be handled by any other listening worker. Existing connection will be allowed to exit as usual. When no more connections exist, the IPC channel to the worker will close allowing it to die graceful. When the IPC channel is closed the disconnect event will emit, this is then followed by the exit event, there is emitted when the worker finally die."
            },
            kill: {
              "!type": "fn(signal?: string)",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_kill_signal_sigterm",
              "!doc": "This function will kill the worker, and inform the master to not spawn a new worker. The boolean suicide lets you distinguish between voluntary and accidental exit."
            }
          },
          "!url": "https://nodejs.org/api/cluster.html#cluster_class_worker",
          "!doc": "A Worker object contains all public information and method about a worker. In the master it can be obtained using cluster.workers. In a worker it can be obtained using cluster.worker."
        },
        isMaster: {
          "!type": "bool",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_ismaster",
          "!doc": "True if the process is a master. This is determined by the process.env.NODE_UNIQUE_ID. If process.env.NODE_UNIQUE_ID is undefined, then isMaster is true."
        },
        isWorker: {
          "!type": "bool",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_isworker",
          "!doc": "This boolean flag is true if the process is a worker forked from a master. If the process.env.NODE_UNIQUE_ID is set to a value, then isWorker is true."
        },
        setupMaster: {
          "!type": "fn(settings?: cluster.settings)",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_setupmaster_settings",
          "!doc": "setupMaster is used to change the default 'fork' behavior. The new settings are effective immediately and permanently, they cannot be changed later on."
        },
        fork: {
          "!type": "fn(env?: ?) -> +cluster.Worker",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_fork_env",
          "!doc": "Spawn a new worker process. This can only be called from the master process."
        },
        disconnect: {
          "!type": "fn(callback?: fn())",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_disconnect_callback",
          "!doc": "When calling this method, all workers will commit a graceful suicide. When they are disconnected all internal handlers will be closed, allowing the master process to die graceful if no other event is waiting."
        },
        worker: {
          "!type": "+cluster.Worker",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_worker",
          "!doc": "A reference to the current worker object. Not available in the master process."
        },
        workers: {
          "!type": "[+cluster.Worker]",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_workers",
          "!doc": "A hash that stores the active worker objects, keyed by id field. Makes it easy to loop through all the workers. It is only available in the master process."
        },
        "!url": "https://nodejs.org/api/cluster.html#cluster_cluster",
        "!doc": "A single instance of Node runs in a single thread. To take advantage of multi-core systems the user will sometimes want to launch a cluster of Node processes to handle the load."
      },
      zlib: {
        "!url": "https://nodejs.org/api/zlib.html",
        "!doc": "This provides bindings to Gzip/Gunzip, Deflate/Inflate, and DeflateRaw/InflateRaw classes. Each class takes the same options, and is a readable/writable Stream.",
        Zlib: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            flush: {
              "!type": "fn(callback: fn())",
              "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_flush_callback",
              "!doc": "Flush pending data. Don't call this frivolously, premature flushes negatively impact the effectiveness of the compression algorithm."
            },
            reset: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_reset",
              "!doc": "Reset the compressor/decompressor to factory defaults. Only applicable to the inflate and deflate algorithms."
            }
          },
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_zlib",
          "!doc": "Not exported by the zlib module. It is documented here because it is the base class of the compressor/decompressor classes."
        },
        deflate: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_deflate_buf_callback",
          "!doc": "Compress a string with Deflate."
        },
        deflateRaw: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_deflateraw_buf_callback",
          "!doc": "Compress a string with DeflateRaw."
        },
        gzip: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_gzip_buf_callback",
          "!doc": "Compress a string with Gzip."
        },
        gunzip: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_gunzip_buf_callback",
          "!doc": "Decompress a raw Buffer with Gunzip."
        },
        inflate: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_inflate_buf_callback",
          "!doc": "Decompress a raw Buffer with Inflate."
        },
        inflateRaw: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_inflateraw_buf_callback",
          "!doc": "Decompress a raw Buffer with InflateRaw."
        },
        unzip: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_unzip_buf_callback",
          "!doc": "Decompress a raw Buffer with Unzip."
        },
        Gzip: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_gzip",
          "!doc": "Compress data using gzip.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createGzip: {
          "!type": "fn(options: ?) -> +zlib.Zlib",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_creategzip_options",
          "!doc": "Returns a new Gzip object with an options."
        },
        Gunzip: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_gunzip",
          "!doc": "Decompress a gzip stream.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createGunzip: {
          "!type": "fn(options: ?) -> +zlib.Gunzip",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_creategunzip_options",
          "!doc": "Returns a new Gunzip object with an options."
        },
        Deflate: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_deflate",
          "!doc": "Compress data using deflate.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createDeflate: {
          "!type": "fn(options: ?) -> +zlib.Deflate",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createdeflate_options",
          "!doc": "Returns a new Deflate object with an options."
        },
        Inflate: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_inflate",
          "!doc": "Decompress a deflate stream.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createInflate: {
          "!type": "fn(options: ?) -> +zlib.Inflate",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createinflate_options",
          "!doc": "Returns a new Inflate object with an options."
        },
        InflateRaw: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_inflateraw",
          "!doc": "Decompress a raw deflate stream.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createInflateRaw: {
          "!type": "fn(options: ?) -> +zlib.InflateRaw",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createinflateraw_options",
          "!doc": "Returns a new InflateRaw object with an options."
        },
        DeflateRaw: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_deflateraw",
          "!doc": "Compress data using deflate, and do not append a zlib header.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createDeflateRaw: {
          "!type": "fn(options: ?) -> +zlib.DeflateRaw",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createdeflateraw_options",
          "!doc": "Returns a new DeflateRaw object with an options."
        },
        Unzip: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_unzip",
          "!doc": "Decompress either a Gzip- or Deflate-compressed stream by auto-detecting the header.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createUnzip: {
          "!type": "fn(options: ?) -> +zlib.Unzip",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createunzip_options",
          "!doc": "Returns a new Unzip object with an options."
        },
        Z_NO_FLUSH: "number",
        Z_PARTIAL_FLUSH: "number",
        Z_SYNC_FLUSH: "number",
        Z_FULL_FLUSH: "number",
        Z_FINISH: "number",
        Z_BLOCK: "number",
        Z_TREES: "number",
        Z_OK: "number",
        Z_STREAM_END: "number",
        Z_NEED_DICT: "number",
        Z_ERRNO: "number",
        Z_STREAM_ERROR: "number",
        Z_DATA_ERROR: "number",
        Z_MEM_ERROR: "number",
        Z_BUF_ERROR: "number",
        Z_VERSION_ERROR: "number",
        Z_NO_COMPRESSION: "number",
        Z_BEST_SPEED: "number",
        Z_BEST_COMPRESSION: "number",
        Z_DEFAULT_COMPRESSION: "number",
        Z_FILTERED: "number",
        Z_HUFFMAN_ONLY: "number",
        Z_RLE: "number",
        Z_FIXED: "number",
        Z_DEFAULT_STRATEGY: "number",
        Z_BINARY: "number",
        Z_TEXT: "number",
        Z_ASCII: "number",
        Z_UNKNOWN: "number",
        Z_DEFLATED: "number",
        Z_NULL: "number"
      },
      os: {
        "!url": "https://nodejs.org/api/os.html",
        "!doc": "Provides a few basic operating-system related utility functions.",
        tmpdir: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_tmpdir",
          "!doc": "Returns the operating system's default directory for temp files."
        },
        endianness: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_endianness",
          "!doc": "Returns the endianness of the CPU. Possible values are \"BE\" or \"LE\"."
        },
        hostname: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_hostname",
          "!doc": "Returns the hostname of the operating system."
        },
        type: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_type",
          "!doc": "Returns the operating system name."
        },
        platform: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_platform",
          "!doc": "Returns the operating system platform."
        },
        arch: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_arch",
          "!doc": "Returns the operating system CPU architecture."
        },
        release: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_release",
          "!doc": "Returns the operating system release."
        },
        uptime: {
          "!type": "fn() -> number",
          "!url": "https://nodejs.org/api/os.html#os_os_uptime",
          "!doc": "Returns the system uptime in seconds."
        },
        loadavg: {
          "!type": "fn() -> [number]",
          "!url": "https://nodejs.org/api/os.html#os_os_loadavg",
          "!doc": "Returns an array containing the 1, 5, and 15 minute load averages."
        },
        totalmem: {
          "!type": "fn() -> number",
          "!url": "https://nodejs.org/api/os.html#os_os_totalmem",
          "!doc": "Returns the total amount of system memory in bytes."
        },
        freemem: {
          "!type": "fn() -> number",
          "!url": "https://nodejs.org/api/os.html#os_os_freemem",
          "!doc": "Returns the amount of free system memory in bytes."
        },
        cpus: {
          "!type": "fn() -> [os.cpuSpec]",
          "!url": "https://nodejs.org/api/os.html#os_os_cpus",
          "!doc": "Returns an array of objects containing information about each CPU/core installed: model, speed (in MHz), and times (an object containing the number of milliseconds the CPU/core spent in: user, nice, sys, idle, and irq)."
        },
        networkInterfaces: {
          "!type": "fn() -> ?",
          "!url": "https://nodejs.org/api/os.html#os_os_networkinterfaces",
          "!doc": "Get a list of network interfaces."
        },
        EOL: {
          "!type": "string",
          "!url": "https://nodejs.org/api/os.html#os_os_eol",
          "!doc": "A constant defining the appropriate End-of-line marker for the operating system."
        }
      },
      punycode: {
        "!url": "https://nodejs.org/api/punycode.html",
        "!doc": "Punycode.js is bundled with Node.js v0.6.2+. Use require('punycode') to access it. (To use it with other Node.js versions, use npm to install the punycode module first.)",
        decode: {
          "!type": "fn(string: string) -> string",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_decode_string",
          "!doc": "Converts a Punycode string of ASCII code points to a string of Unicode code points."
        },
        encode: {
          "!type": "fn(string: string) -> string",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_encode_string",
          "!doc": "Converts a string of Unicode code points to a Punycode string of ASCII code points."
        },
        toUnicode: {
          "!type": "fn(domain: string) -> string",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_tounicode_domain",
          "!doc": "Converts a Punycode string representing a domain name to Unicode. Only the Punycoded parts of the domain name will be converted, i.e. it doesn't matter if you call it on a string that has already been converted to Unicode."
        },
        toASCII: {
          "!type": "fn(domain: string) -> string",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_toascii_domain",
          "!doc": "Converts a Unicode string representing a domain name to Punycode. Only the non-ASCII parts of the domain name will be converted, i.e. it doesn't matter if you call it with a domain that's already in ASCII."
        },
        ucs2: {
          decode: {
            "!type": "fn(string: string) -> string",
            "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_ucs2_decode_string",
            "!doc": "Creates an array containing the decimal code points of each Unicode character in the string. While JavaScript uses UCS-2 internally, this function will convert a pair of surrogate halves (each of which UCS-2 exposes as separate characters) into a single code point, matching UTF-16."
          },
          encode: {
            "!type": "fn(codePoints: [number]) -> string",
            "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_ucs2_encode_codepoints",
            "!doc": "Creates a string based on an array of decimal code points."
          }
        },
        version: {
          "!type": "?",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_version",
          "!doc": "A string representing the current Punycode.js version number."
        }
      },
      repl: {
        "!url": "https://nodejs.org/api/repl.html",
        "!doc": "A Read-Eval-Print-Loop (REPL) is available both as a standalone program and easily includable in other programs. The REPL provides a way to interactively run JavaScript and see the results. It can be used for debugging, testing, or just trying things out.",
        start: {
          "!type": "fn(options: ?) -> +events.EventEmitter",
          "!url": "https://nodejs.org/api/repl.html#repl_repl_start_options",
          "!doc": "Returns and starts a REPLServer instance."
        }
      },
      readline: {
        "!url": "https://nodejs.org/api/readline.html",
        "!doc": "Readline allows reading of a stream (such as process.stdin) on a line-by-line basis.",
        createInterface: {
          "!type": "fn(options: ?) -> +readline.Interface",
          "!url": "https://nodejs.org/api/readline.html#readline_readline_createinterface_options",
          "!doc": "Creates a readline Interface instance."
        },
        Interface: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            setPrompt: {
              "!type": "fn(prompt: string, length: number)",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_setprompt_prompt_length",
              "!doc": "Sets the prompt, for example when you run node on the command line, you see > , which is node's prompt."
            },
            prompt: {
              "!type": "fn(preserveCursor?: bool)",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_prompt_preservecursor",
              "!doc": "Readies readline for input from the user, putting the current setPrompt options on a new line, giving the user a new spot to write. Set preserveCursor to true to prevent the cursor placement being reset to 0."
            },
            question: {
              "!type": "fn(query: string, callback: fn())",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_question_query_callback",
              "!doc": "Prepends the prompt with query and invokes callback with the user's response. Displays the query to the user, and then invokes callback with the user's response after it has been typed."
            },
            pause: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_pause",
              "!doc": "Pauses the readline input stream, allowing it to be resumed later if needed."
            },
            resume: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_resume",
              "!doc": "Resumes the readline input stream."
            },
            close: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_close",
              "!doc": "Closes the Interface instance, relinquishing control on the input and output streams. The \"close\" event will also be emitted."
            },
            write: {
              "!type": "fn(data: ?, key?: ?)",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_write_data_key",
              "!doc": "Writes data to output stream. key is an object literal to represent a key sequence; available if the terminal is a TTY."
            }
          },
          "!url": "https://nodejs.org/api/readline.html#readline_class_interface",
          "!doc": "The class that represents a readline interface with an input and output stream."
        }
      },
      vm: {
        "!url": "https://nodejs.org/api/vm.html",
        "!doc": "JavaScript code can be compiled and run immediately or compiled, saved, and run later.",
        createContext: {
          "!type": "fn(initSandbox?: ?) -> ?",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_createcontext_initsandbox",
          "!doc": "vm.createContext creates a new context which is suitable for use as the 2nd argument of a subsequent call to vm.runInContext. A (V8) context comprises a global object together with a set of build-in objects and functions. The optional argument initSandbox will be shallow-copied to seed the initial contents of the global object used by the context."
        },
        Script: {
          "!type": "fn()",
          prototype: {
            runInThisContext: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/vm.html#vm_script_runinthiscontext",
              "!doc": "Similar to vm.runInThisContext but a method of a precompiled Script object. script.runInThisContext runs the code of script and returns the result. Running code does not have access to local scope, but does have access to the global object (v8: in actual context)."
            },
            runInNewContext: {
              "!type": "fn(sandbox?: ?)",
              "!url": "https://nodejs.org/api/vm.html#vm_script_runinnewcontext_sandbox",
              "!doc": "Similar to vm.runInNewContext a method of a precompiled Script object. script.runInNewContext runs the code of script with sandbox as the global object and returns the result. Running code does not have access to local scope. sandbox is optional."
            }
          },
          "!url": "https://nodejs.org/api/vm.html#vm_class_script",
          "!doc": "A class for running scripts. Returned by vm.createScript."
        },
        runInThisContext: {
          "!type": "fn(code: string, filename?: string)",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_runinthiscontext_code_filename",
          "!doc": "vm.runInThisContext() compiles code, runs it and returns the result. Running code does not have access to local scope. filename is optional, it's used only in stack traces."
        },
        runInNewContext: {
          "!type": "fn(code: string, sandbox?: ?, filename?: string)",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_runinnewcontext_code_sandbox_filename",
          "!doc": "vm.runInNewContext compiles code, then runs it in sandbox and returns the result. Running code does not have access to local scope. The object sandbox will be used as the global object for code. sandbox and filename are optional, filename is only used in stack traces."
        },
        runInContext: {
          "!type": "fn(code: string, context: ?, filename?: string)",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_runincontext_code_context_filename",
          "!doc": "vm.runInContext compiles code, then runs it in context and returns the result. A (V8) context comprises a global object, together with a set of built-in objects and functions. Running code does not have access to local scope and the global object held within context will be used as the global object for code. filename is optional, it's used only in stack traces."
        },
        createScript: {
          "!type": "fn(code: string, filename?: string) -> +vm.Script",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_createscript_code_filename",
          "!doc": "createScript compiles code but does not run it. Instead, it returns a vm.Script object representing this compiled code. This script can be run later many times using methods below. The returned script is not bound to any global object. It is bound before each run, just for that run. filename is optional, it's only used in stack traces."
        }
      },
      child_process: {
        "!url": "https://nodejs.org/api/child_process.html",
        "!doc": "Node provides a tri-directional popen(3) facility through the child_process module.",
        ChildProcess: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            stdin: {
              "!type": "+stream.Writable",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_stdin",
              "!doc": "A Writable Stream that represents the child process's stdin. Closing this stream via end() often causes the child process to terminate."
            },
            stdout: {
              "!type": "+stream.Readable",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_stdout",
              "!doc": "A Readable Stream that represents the child process's stdout."
            },
            stderr: {
              "!type": "+stream.Readable",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_stderr",
              "!doc": "A Readable Stream that represents the child process's stderr."
            },
            pid: {
              "!type": "number",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_pid",
              "!doc": "The PID of the child process."
            },
            kill: {
              "!type": "fn(signal?: string)",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_kill_signal",
              "!doc": "Send a signal to the child process. If no argument is given, the process will be sent 'SIGTERM'."
            },
            send: {
              "!type": "fn(message: ?, sendHandle?: ?)",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_send_message_sendhandle",
              "!doc": "When using child_process.fork() you can write to the child using child.send(message, [sendHandle]) and messages are received by a 'message' event on the child."
            },
            disconnect: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_disconnect",
              "!doc": "To close the IPC connection between parent and child use the child.disconnect() method. This allows the child to exit gracefully since there is no IPC channel keeping it alive. When calling this method the disconnect event will be emitted in both parent and child, and the connected flag will be set to false. Please note that you can also call process.disconnect() in the child process."
            }
          },
          "!url": "https://nodejs.org/api/child_process.html#child_process_class_childprocess",
          "!doc": "ChildProcess is an EventEmitter."
        },
        spawn: {
          "!type": "fn(command: string, args?: [string], options?: ?) -> +child_process.ChildProcess",
          "!url": "https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options",
          "!doc": "Launches a new process with the given command, with command line arguments in args. If omitted, args defaults to an empty Array."
        },
        exec: {
          "!type": "fn(command: string, callback: fn(error: ?, stdout: +Buffer, stderr: +Buffer)) -> +child_process.ChildProcess",
          "!url": "https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback",
          "!doc": "Runs a command in a shell and buffers the output."
        },
        execFile: {
          "!type": "fn(file: string, args: [string], options: ?, callback: fn(error: ?, stdout: +Buffer, stderr: +Buffer)) -> +child_process.ChildProcess",
          "!url": "https://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback",
          "!doc": "This is similar to child_process.exec() except it does not execute a subshell but rather the specified file directly. This makes it slightly leaner than child_process.exec. It has the same options."
        },
        fork: {
          "!type": "fn(modulePath: string, args?: [string], options?: ?) -> +child_process.ChildProcess",
          "!url": "https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options",
          "!doc": "This is a special case of the spawn() functionality for spawning Node processes. In addition to having all the methods in a normal ChildProcess instance, the returned object has a communication channel built-in."
        }
      },
      url: {
        "!url": "https://nodejs.org/api/url.html",
        "!doc": "This module has utilities for URL resolution and parsing. ",
        parse: {
          "!type": "fn(urlStr: string, parseQueryString?: bool, slashesDenoteHost?: bool) -> url.type",
          "!url": "https://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost",
          "!doc": "Take a URL string, and return an object."
        },
        format: {
          "!type": "fn(url: url.type) -> string",
          "!url": "https://nodejs.org/api/url.html#url_url_format_urlobj",
          "!doc": "Take a parsed URL object, and return a formatted URL string."
        },
        resolve: {
          "!type": "fn(from: string, to: string) -> string",
          "!url": "https://nodejs.org/api/url.html#url_url_resolve_from_to",
          "!doc": "Take a base URL, and a href URL, and resolve them as a browser would for an anchor tag."
        }
      },
      dns: {
        "!url": "https://nodejs.org/api/dns.html",
        "!doc": "This module contains functions that belong to two different categories:\n1) Functions that use the underlying operating system facilities to perform name resolution, and that do not necessarily do any network communication.\n2) Functions that connect to an actual DNS server to perform name resolution, and that always use the network to perform DNS queries.",
        lookup: {
          "!type": "fn(domain: string, callback: fn(err: +Error, address: string, family: number)) -> string",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_lookup_domain_family_callback",
          "!doc": "Resolves a domain (e.g. 'google.com') into the first found A (IPv4) or AAAA (IPv6) record. The family can be the integer 4 or 6. Defaults to null that indicates both Ip v4 and v6 address family."
        },
        resolve: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolve_domain_rrtype_callback",
          "!doc": "Resolves a domain (e.g. 'google.com') into an array of the record types specified by rrtype. Valid rrtypes are 'A' (IPV4 addresses, default), 'AAAA' (IPV6 addresses), 'MX' (mail exchange records), 'TXT' (text records), 'SRV' (SRV records), 'PTR' (used for reverse IP lookups), 'NS' (name server records) and 'CNAME' (canonical name records)."
        },
        resolve4: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolve4_domain_callback",
          "!doc": "The same as dns.resolve(), but only for IPv4 queries (A records). addresses is an array of IPv4 addresses (e.g. ['74.125.79.104', '74.125.79.105', '74.125.79.106'])."
        },
        resolve6: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolve6_domain_callback",
          "!doc": "The same as dns.resolve4() except for IPv6 queries (an AAAA query)."
        },
        resolveMx: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvemx_domain_callback",
          "!doc": "The same as dns.resolve(), but only for mail exchange queries (MX records)."
        },
        resolveTxt: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvetxt_domain_callback",
          "!doc": "The same as dns.resolve(), but only for text queries (TXT records). addresses is an array of the text records available for domain (e.g., ['v=spf1 ip4:0.0.0.0 ~all'])."
        },
        resolveSrv: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvesrv_domain_callback",
          "!doc": "The same as dns.resolve(), but only for service records (SRV records). addresses is an array of the SRV records available for domain. Properties of SRV records are priority, weight, port, and name (e.g., [{'priority': 10, {'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...])."
        },
        resolveNs: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvens_domain_callback",
          "!doc": "The same as dns.resolve(), but only for name server records (NS records). addresses is an array of the name server records available for domain (e.g., ['ns1.example.com', 'ns2.example.com'])."
        },
        resolveCname: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvecname_domain_callback",
          "!doc": "The same as dns.resolve(), but only for canonical name records (CNAME records). addresses is an array of the canonical name records available for domain (e.g., ['bar.example.com'])."
        },
        reverse: {
          "!type": "fn(ip: string, callback: fn(err: +Error, domains: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_reverse_ip_callback",
          "!doc": "Reverse resolves an ip address to an array of domain names."
        }
      },
      net: {
        "!url": "https://nodejs.org/api/net.html",
        "!doc": "The net module provides you with an asynchronous network wrapper. It contains methods for creating both servers and clients (called streams).",
        createServer: {
          "!type": "fn(options?: ?, connectionListener?: fn(socket: +net.Socket)) -> +net.Server",
          "!url": "https://nodejs.org/api/net.html#net_net_createserver_options_connectionlistener",
          "!doc": "Creates a new TCP server. The connectionListener argument is automatically set as a listener for the 'connection' event."
        },
        Server: {
          "!type": "fn()",
          prototype: {
            "!proto": "net.Socket.prototype",
            listen: {
              "!type": "fn(port: number, hostname?: string, backlog?: number, callback?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_server_listen_port_host_backlog_callback",
              "!doc": "Begin accepting connections on the specified port and host. If the host is omitted, the server will accept connections directed to any IPv4 address (INADDR_ANY). A port value of zero will assign a random port."
            },
            close: {
              "!type": "fn(callback?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_server_close_callback",
              "!doc": "Stops the server from accepting new connections and keeps existing connections. This function is asynchronous, the server is finally closed when all connections are ended and the server emits a 'close' event. Optionally, you can pass a callback to listen for the 'close' event."
            },
            maxConnections: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_server_maxconnections",
              "!doc": "Set this property to reject connections when the server's connection count gets high."
            },
            getConnections: {
              "!type": "fn(callback: fn(err: +Error, count: number))",
              "!url": "https://nodejs.org/api/net.html#net_server_getconnections_callback",
              "!doc": "Asynchronously get the number of concurrent connections on the server. Works when sockets were sent to forks."
            }
          },
          "!url": "https://nodejs.org/api/net.html#net_class_net_server",
          "!doc": "This class is used to create a TCP or UNIX server. A server is a net.Socket that can listen for new incoming connections."
        },
        Socket: {
          "!type": "fn(options: ?)",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            connect: {
              "!type": "fn(port: number, host?: string, connectionListener?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_socket_connect_port_host_connectlistener",
              "!doc": "Opens the connection for a given socket. If port and host are given, then the socket will be opened as a TCP socket, if host is omitted, localhost will be assumed. If a path is given, the socket will be opened as a unix socket to that path."
            },
            bufferSize: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_buffersize",
              "!doc": "net.Socket has the property that socket.write() always works. This is to help users get up and running quickly. The computer cannot always keep up with the amount of data that is written to a socket - the network connection simply might be too slow. Node will internally queue up the data written to a socket and send it out over the wire when it is possible. (Internally it is polling on the socket's file descriptor for being writable)."
            },
            setEncoding: {
              "!type": "fn(encoding?: string)",
              "!url": "https://nodejs.org/api/net.html#net_socket_setencoding_encoding",
              "!doc": "Set the encoding for the socket as a Readable Stream."
            },
            write: {
              "!type": "fn(data: +Buffer, encoding?: string, callback?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_socket_write_data_encoding_callback",
              "!doc": "Sends data on the socket. The second parameter specifies the encoding in the case of a string--it defaults to UTF8 encoding."
            },
            end: {
              "!type": "fn(data?: +Buffer, encoding?: string)",
              "!url": "https://nodejs.org/api/net.html#net_socket_end_data_encoding",
              "!doc": "Half-closes the socket. i.e., it sends a FIN packet. It is possible the server will still send some data."
            },
            destroy: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_destroy",
              "!doc": "Ensures that no more I/O activity happens on this socket. Only necessary in case of errors (parse error or so)."
            },
            pause: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_pause",
              "!doc": "Pauses the reading of data. That is, 'data' events will not be emitted. Useful to throttle back an upload."
            },
            resume: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_resume",
              "!doc": "Resumes reading after a call to pause()."
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback",
              "!doc": "Sets the socket to timeout after timeout milliseconds of inactivity on the socket. By default net.Socket do not have a timeout."
            },
            setKeepAlive: {
              "!type": "fn(enable?: bool, initialDelay?: number)",
              "!url": "https://nodejs.org/api/net.html#net_socket_setkeepalive_enable_initialdelay",
              "!doc": "Enable/disable keep-alive functionality, and optionally set the initial delay before the first keepalive probe is sent on an idle socket. enable defaults to false."
            },
            address: {
              "!type": "fn() -> net.address",
              "!url": "https://nodejs.org/api/net.html#net_socket_address",
              "!doc": "Returns the bound address, the address family name and port of the socket as reported by the operating system. Returns an object with three properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }"
            },
            unref: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_unref",
              "!doc": "Calling unref on a socket will allow the program to exit if this is the only active socket in the event system. If the socket is already unrefd calling unref again will have no effect."
            },
            ref: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_ref",
              "!doc": "Opposite of unref, calling ref on a previously unrefd socket will not let the program exit if it's the only socket left (the default behavior). If the socket is refd calling ref again will have no effect."
            },
            remoteAddress: {
              "!type": "string",
              "!url": "https://nodejs.org/api/net.html#net_socket_remoteaddress",
              "!doc": "The string representation of the remote IP address. For example, '74.125.127.100' or '2001:4860:a005::68'."
            },
            remotePort: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_remoteport",
              "!doc": "The numeric representation of the remote port. For example, 80 or 21."
            },
            localPort: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_localport",
              "!doc": "The numeric representation of the local port. For example, 80 or 21."
            },
            bytesRead: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_bytesread",
              "!doc": "The amount of received bytes."
            },
            bytesWritten: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_byteswritten",
              "!doc": "The amount of bytes sent."
            },
            setNoDelay: {
              "!type": "fn(noDelay?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_socket_setnodelay_nodelay",
              "!doc": "Disables the Nagle algorithm. By default TCP connections use the Nagle algorithm, they buffer data before sending it off. Setting true for noDelay will immediately fire off data each time socket.write() is called. noDelay defaults to true."
            },
            localAddress: {
              "!type": "string",
              "!url": "https://nodejs.org/api/net.html#net_socket_localaddress",
              "!doc": "The string representation of the local IP address the remote client is connecting on. For example, if you are listening on '0.0.0.0' and the client connects on '192.168.1.1', the value would be '192.168.1.1'."
            }
          },
          "!url": "https://nodejs.org/api/net.html#net_class_net_socket",
          "!doc": "This object is an abstraction of a TCP or UNIX socket. net.Socket instances implement a duplex Stream interface. They can be created by the user and used as a client (with connect()) or they can be created by Node and passed to the user through the 'connection' event of a server."
        },
        connect: {
          "!type": "fn(options: ?, connectionListener?: fn()) -> +net.Socket",
          "!url": "https://nodejs.org/api/net.html#net_net_connect_options_connectionlistener",
          "!doc": "Constructs a new socket object and opens the socket to the given location. When the socket is established, the 'connect' event will be emitted."
        },
        createConnection: {
          "!type": "fn(options: ?, connectionListener?: fn()) -> +net.Socket",
          "!url": "https://nodejs.org/api/net.html#net_net_createconnection_options_connectionlistener",
          "!doc": "Constructs a new socket object and opens the socket to the given location. When the socket is established, the 'connect' event will be emitted."
        },
        isIP: {
          "!type": "fn(input: string) -> number",
          "!url": "https://nodejs.org/api/net.html#net_net_isip_input",
          "!doc": "Tests if input is an IP address. Returns 0 for invalid strings, returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses."
        },
        isIPv4: {
          "!type": "fn(input: string) -> bool",
          "!url": "https://nodejs.org/api/net.html#net_net_isipv4_input",
          "!doc": "Returns true if input is a version 4 IP address, otherwise returns false."
        },
        isIPv6: {
          "!type": "fn(input: string) -> bool",
          "!url": "https://nodejs.org/api/net.html#net_net_isipv6_input",
          "!doc": "Returns true if input is a version 6 IP address, otherwise returns false."
        }
      },
      dgram: {
        "!url": "https://nodejs.org/api/dgram.html",
        "!doc": "UDP / Datagram Sockets",
        createSocket: {
          "!type": "fn(type: string, callback?: fn()) -> +dgram.Socket",
          "!url": "https://nodejs.org/api/dgram.html#dgram_dgram_createsocket_type_callback",
          "!doc": "Creates a datagram Socket of the specified types. Valid types are udp4 and udp6."
        },
        Socket: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            send: {
              "!type": "fn(buf: +Buffer, offset: number, length: number, port: number, address: string, callback?: fn())",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_send_buf_offset_length_port_address_callback",
              "!doc": "For UDP sockets, the destination port and IP address must be specified. A string may be supplied for the address parameter, and it will be resolved with DNS. An optional callback may be specified to detect any DNS errors and when buf may be re-used. Note that DNS lookups will delay the time that a send takes place, at least until the next tick. The only way to know for sure that a send has taken place is to use the callback."
            },
            bind: {
              "!type": "fn(port: number, address?: string)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_bind_port_address_callback",
              "!doc": "For UDP sockets, listen for datagrams on a named port and optional address. If address is not specified, the OS will try to listen on all addresses."
            },
            close: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_close",
              "!doc": "Close the underlying socket and stop listening for data on it."
            },
            address: {
              address: "string",
              family: "string",
              port: "number",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_address",
              "!doc": "Returns an object containing the address information for a socket. For UDP sockets, this object will contain address , family and port."
            },
            setBroadcast: {
              "!type": "fn(flag: bool)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_setbroadcast_flag",
              "!doc": "Sets or clears the SO_BROADCAST socket option. When this option is set, UDP packets may be sent to a local interface's broadcast address."
            },
            setTTL: {
              "!type": "fn(ttl: number)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_setttl_ttl",
              "!doc": "Sets the IP_TTL socket option. TTL stands for \"Time to Live,\" but in this context it specifies the number of IP hops that a packet is allowed to go through. Each router or gateway that forwards a packet decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded. Changing TTL values is typically done for network probes or when multicasting."
            },
            setMulticastTTL: {
              "!type": "fn(ttl: number)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_setmulticastttl_ttl",
              "!doc": "Sets the IP_MULTICAST_TTL socket option. TTL stands for \"Time to Live,\" but in this context it specifies the number of IP hops that a packet is allowed to go through, specifically for multicast traffic. Each router or gateway that forwards a packet decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded."
            },
            setMulticastLoopback: {
              "!type": "fn(flag: bool)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_setmulticastloopback_flag",
              "!doc": "Sets or clears the IP_MULTICAST_LOOP socket option. When this option is set, multicast packets will also be received on the local interface."
            },
            addMembership: {
              "!type": "fn(multicastAddress: string, multicastInterface?: string)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_addmembership_multicastaddress_multicastinterface",
              "!doc": "Tells the kernel to join a multicast group with IP_ADD_MEMBERSHIP socket option."
            },
            dropMembership: {
              "!type": "fn(multicastAddress: string, multicastInterface?: string)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_dropmembership_multicastaddress_multicastinterface",
              "!doc": "Opposite of addMembership - tells the kernel to leave a multicast group with IP_DROP_MEMBERSHIP socket option. This is automatically called by the kernel when the socket is closed or process terminates, so most apps will never need to call this."
            }
          },
          "!url": "https://nodejs.org/api/dgram.html#dgram_class_dgram_socket",
          "!doc": "The dgram Socket class encapsulates the datagram functionality. It should be created via dgram.createSocket(type, [callback])."
        }
      },
      fs: {
        "!url": "https://nodejs.org/api/fs.html",
        "!doc": "File I/O is provided by simple wrappers around standard POSIX functions. To use this module do require('fs').\nAll the methods have asynchronous and synchronous forms.",
        rename: {
          "!type": "fn(oldPath: string, newPath: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_rename_oldpath_newpath_callback",
          "!doc": "Asynchronous rename(2). No arguments other than a possible exception are given to the completion callback."
        },
        renameSync: {
          "!type": "fn(oldPath: string, newPath: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_renamesync_oldpath_newpath",
          "!doc": "Synchronous rename(2)."
        },
        ftruncate: {
          "!type": "fn(fd: number, len: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_ftruncate_fd_len_callback",
          "!doc": "Asynchronous ftruncate(2). No arguments other than a possible exception are given to the completion callback."
        },
        ftruncateSync: {
          "!type": "fn(fd: number, len: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_ftruncatesync_fd_len",
          "!doc": "Synchronous ftruncate(2)."
        },
        truncate: {
          "!type": "fn(path: string, len: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_truncate_path_len_callback",
          "!doc": "Asynchronous truncate(2). No arguments other than a possible exception are given to the completion callback."
        },
        truncateSync: {
          "!type": "fn(path: string, len: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_truncatesync_path_len",
          "!doc": "Synchronous truncate(2)."
        },
        chown: {
          "!type": "fn(path: string, uid: number, gid: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_chown_path_uid_gid_callback",
          "!doc": "Asynchronous chown(2). No arguments other than a possible exception are given to the completion callback."
        },
        chownSync: {
          "!type": "fn(path: string, uid: number, gid: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_chownsync_path_uid_gid",
          "!doc": "Synchronous chown(2)."
        },
        fchown: {
          "!type": "fn(fd: number, uid: number, gid: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fchown_fd_uid_gid_callback",
          "!doc": "Asynchronous fchown(2). No arguments other than a possible exception are given to the completion callback."
        },
        fchownSync: {
          "!type": "fn(fd: number, uid: number, gid: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fchownsync_fd_uid_gid",
          "!doc": "Synchronous fchown(2)."
        },
        lchown: {
          "!type": "fn(path: string, uid: number, gid: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lchown_path_uid_gid_callback",
          "!doc": "Asynchronous lchown(2). No arguments other than a possible exception are given to the completion callback."
        },
        lchownSync: {
          "!type": "fn(path: string, uid: number, gid: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lchownsync_path_uid_gid",
          "!doc": "Synchronous lchown(2)."
        },
        chmod: {
          "!type": "fn(path: string, mode: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_chmod_path_mode_callback",
          "!doc": "Asynchronous chmod(2). No arguments other than a possible exception are given to the completion callback."
        },
        chmodSync: {
          "!type": "fn(path: string, mode: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_chmodsync_path_mode",
          "!doc": "Synchronous chmod(2)."
        },
        fchmod: {
          "!type": "fn(fd: number, mode: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fchmod_fd_mode_callback",
          "!doc": "Asynchronous fchmod(2). No arguments other than a possible exception are given to the completion callback."
        },
        fchmodSync: {
          "!type": "fn(fd: number, mode: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fchmodsync_fd_mode",
          "!doc": "Synchronous fchmod(2)."
        },
        lchmod: {
          "!type": "fn(path: string, mode: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lchmod_path_mode_callback",
          "!doc": "Asynchronous lchmod(2). No arguments other than a possible exception are given to the completion callback."
        },
        lchmodSync: {
          "!type": "fn(path: string, mode: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lchmodsync_path_mode",
          "!doc": "Synchronous lchmod(2)."
        },
        stat: {
          "!type": "fn(path: string, callback?: fn(err: +Error, stats: +fs.Stats) -> ?) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_stat_path_callback",
          "!doc": "Asynchronous stat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object."
        },
        lstat: {
          "!type": "fn(path: string, callback?: fn(err: +Error, stats: +fs.Stats) -> ?) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lstat_path_callback",
          "!doc": "Asynchronous lstat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object. lstat() is identical to stat(), except that if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to."
        },
        fstat: {
          "!type": "fn(fd: number, callback?: fn(err: +Error, stats: +fs.Stats) -> ?) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fstat_fd_callback",
          "!doc": "Asynchronous fstat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object. fstat() is identical to stat(), except that the file to be stat-ed is specified by the file descriptor fd."
        },
        statSync: {
          "!type": "fn(path: string) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_statsync_path",
          "!doc": "Synchronous stat(2). Returns an instance of fs.Stats."
        },
        lstatSync: {
          "!type": "fn(path: string) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lstatsync_path",
          "!doc": "Synchronous lstat(2). Returns an instance of fs.Stats."
        },
        fstatSync: {
          "!type": "fn(fd: number) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fstatsync_fd",
          "!doc": "Synchronous fstat(2). Returns an instance of fs.Stats."
        },
        link: {
          "!type": "fn(srcpath: string, dstpath: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_link_srcpath_dstpath_callback",
          "!doc": "Asynchronous link(2). No arguments other than a possible exception are given to the completion callback."
        },
        linkSync: {
          "!type": "fn(srcpath: string, dstpath: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_linksync_srcpath_dstpath",
          "!doc": "Synchronous link(2)."
        },
        symlink: {
          "!type": "fn(srcpath: string, dstpath: string, type?: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_symlink_srcpath_dstpath_type_callback",
          "!doc": "Asynchronous symlink(2). No arguments other than a possible exception are given to the completion callback. type argument can be either 'dir', 'file', or 'junction' (default is 'file'). It is only used on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute. When using 'junction', the destination argument will automatically be normalized to absolute path."
        },
        symlinkSync: {
          "!type": "fn(srcpath: string, dstpath: string, type?: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_symlinksync_srcpath_dstpath_type",
          "!doc": "Synchronous symlink(2)."
        },
        readlink: {
          "!type": "fn(path: string, callback?: fn(err: +Error, linkString: string))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readlink_path_callback",
          "!doc": "Asynchronous readlink(2). The callback gets two arguments (err, linkString)."
        },
        readlinkSync: {
          "!type": "fn(path: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readlinksync_path",
          "!doc": "Synchronous readlink(2). Returns the symbolic link's string value."
        },
        realpath: {
          "!type": "fn(path: string, cache: bool, callback: fn(err: +Error, resolvedPath: string))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_realpath_path_cache_callback",
          "!doc": "Asynchronous realpath(2). The callback gets two arguments (err, resolvedPath). May use process.cwd to resolve relative paths. cache is an object literal of mapped paths that can be used to force a specific path resolution or avoid additional fs.stat calls for known real paths."
        },
        realpathSync: {
          "!type": "fn(path: string, cache?: bool) -> string",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_cache",
          "!doc": "Synchronous realpath(2). Returns the resolved path."
        },
        unlink: {
          "!type": "fn(path: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_unlink_path_callback",
          "!doc": "Asynchronous unlink(2). No arguments other than a possible exception are given to the completion callback."
        },
        unlinkSync: {
          "!type": "fn(path: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_unlinksync_path",
          "!doc": "Synchronous unlink(2)."
        },
        rmdir: {
          "!type": "fn(path: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_rmdir_path_callback",
          "!doc": "Asynchronous rmdir(2). No arguments other than a possible exception are given to the completion callback."
        },
        rmdirSync: {
          "!type": "fn(path: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_rmdirsync_path",
          "!doc": "Synchronous rmdir(2)."
        },
        mkdir: {
          "!type": "fn(path: string, mode?: ?, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_mkdir_path_mode_callback",
          "!doc": "Asynchronous mkdir(2). No arguments other than a possible exception are given to the completion callback. mode defaults to 0777."
        },
        mkdirSync: {
          "!type": "fn(path: string, mode?: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_mkdirsync_path_mode",
          "!doc": "Synchronous mkdir(2)."
        },
        readdir: {
          "!type": "fn(path: string, callback?: fn(err: +Error, files: [string]))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readdir_path_callback",
          "!doc": "Asynchronous readdir(3). Reads the contents of a directory. The callback gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'."
        },
        readdirSync: {
          "!type": "fn(path: string) -> [string]",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readdirsync_path",
          "!doc": "Synchronous readdir(3). Returns an array of filenames excluding '.' and '..'."
        },
        close: {
          "!type": "fn(fd: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_close_fd_callback",
          "!doc": "Asynchronous close(2). No arguments other than a possible exception are given to the completion callback."
        },
        closeSync: {
          "!type": "fn(fd: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_closesync_fd",
          "!doc": "Synchronous close(2)."
        },
        open: {
          "!type": "fn(path: string, flags: string, mode?: string, callback?: fn(err: +Error, fd: number))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback",
          "!doc": "Asynchronous file open."
        },
        openSync: {
          "!type": "fn(path: string, flags: string, mode?: string) -> number",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_opensync_path_flags_mode",
          "!doc": "Synchronous open(2)."
        },
        utimes: {
          "!type": "fn(path: string, atime: number, mtime: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_utimes_path_atime_mtime_callback",
          "!doc": "Change file timestamps of the file referenced by the supplied path."
        },
        utimesSync: {
          "!type": "fn(path: string, atime: number, mtime: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_utimessync_path_atime_mtime",
          "!doc": "Change file timestamps of the file referenced by the supplied path."
        },
        futimes: {
          "!type": "fn(fd: number, atime: number, mtime: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_futimes_fd_atime_mtime_callback",
          "!doc": "Change the file timestamps of a file referenced by the supplied file descriptor."
        },
        futimesSync: {
          "!type": "fn(fd: number, atime: number, mtime: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_futimessync_fd_atime_mtime",
          "!doc": "Change the file timestamps of a file referenced by the supplied file descriptor."
        },
        fsync: {
          "!type": "fn(fd: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fsync_fd_callback",
          "!doc": "Asynchronous fsync(2). No arguments other than a possible exception are given to the completion callback."
        },
        fsyncSync: {
          "!type": "fn(fd: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fsyncsync_fd",
          "!doc": "Synchronous fsync(2)."
        },
        write: {
          "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number, callback?: fn(err: +Error, written: number, buffer: +Buffer))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_write_fd_buffer_offset_length_position_callback",
          "!doc": "Write buffer to the file specified by fd."
        },
        writeSync: {
          "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number) -> number",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_writesync_fd_buffer_offset_length_position",
          "!doc": "Synchronous version of fs.write(). Returns the number of bytes written."
        },
        read: {
          "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number, callback?: fn(err: +Error, bytesRead: number, buffer: +Buffer))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback",
          "!doc": "Read data from the file specified by fd."
        },
        readSync: {
          "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number) -> number",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readsync_fd_buffer_offset_length_position",
          "!doc": "Synchronous version of fs.read. Returns the number of bytesRead."
        },
        readFile: {
          "!type": "fn(filename: string, callback: fn(err: +Error, data: +Buffer))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readfile_filename_options_callback",
          "!doc": "Asynchronously reads the entire contents of a file."
        },
        readFileSync: {
          "!type": "fn(filename: string, encoding: string) -> +Buffer",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readfilesync_filename_options",
          "!doc": "Synchronous version of fs.readFile. Returns the contents of the filename."
        },
        writeFile: {
          "!type": "fn(filename: string, data: string|+Buffer, encoding?: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_writefile_filename_data_options_callback",
          "!doc": "Asynchronously writes data to a file, replacing the file if it already exists. data can be a string or a buffer."
        },
        writeFileSync: {
          "!type": "fn(filename: string, data: string|+Buffer, encoding?: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_writefilesync_filename_data_options",
          "!doc": "The synchronous version of fs.writeFile."
        },
        appendFile: {
          "!type": "fn(filename: string, data: string|+Buffer, encoding?: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_appendfile_filename_data_options_callback",
          "!doc": "Asynchronously append data to a file, creating the file if it not yet exists. data can be a string or a buffer."
        },
        appendFileSync: {
          "!type": "fn(filename: string, data: string|+Buffer, encoding?: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_appendfilesync_filename_data_options",
          "!doc": "The synchronous version of fs.appendFile."
        },
        watchFile: {
          "!type": "fn(filename: string, options: ?, listener: fn(current: +fs.Stats, prev: +fs.Stats))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_watchfile_filename_options_listener",
          "!doc": "Watch for changes on filename. The callback listener will be called each time the file is accessed."
        },
        unwatchFile: {
          "!type": "fn(filename: string, listener?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_unwatchfile_filename_listener",
          "!doc": "Stop watching for changes on filename. If listener is specified, only that particular listener is removed. Otherwise, all listeners are removed and you have effectively stopped watching filename."
        },
        watch: {
          "!type": "fn(filename: string, options?: ?, listener?: fn(event: string, filename: string)) -> +fs.FSWatcher",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_watch_filename_options_listener",
          "!doc": "Watch for changes on filename, where filename is either a file or a directory. The returned object is a fs.FSWatcher."
        },
        exists: {
          "!type": "fn(path: string, callback?: fn(exists: bool))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_exists_path_callback",
          "!doc": "Test whether or not the given path exists by checking with the file system. Then call the callback argument with either true or false."
        },
        existsSync: {
          "!type": "fn(path: string) -> bool",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_existssync_path",
          "!doc": "Synchronous version of fs.exists."
        },
        Stats: {
          "!type": "fn()",
          prototype: {
            isFile: "fn() -> bool",
            isDirectory: "fn() -> bool",
            isBlockDevice: "fn() -> bool",
            isCharacterDevice: "fn() -> bool",
            isSymbolicLink: "fn() -> bool",
            isFIFO: "fn() -> bool",
            isSocket: "fn() -> bool",
            dev: "number",
            ino: "number",
            mode: "number",
            nlink: "number",
            uid: "number",
            gid: "number",
            rdev: "number",
            size: "number",
            blksize: "number",
            blocks: "number",
            atime: "+Date",
            mtime: "+Date",
            ctime: "+Date"
          },
          "!url": "https://nodejs.org/api/fs.html#fs_class_fs_stats",
          "!doc": "Objects returned from fs.stat(), fs.lstat() and fs.fstat() and their synchronous counterparts are of this type."
        },
        createReadStream: {
          "!type": "fn(path: string, options?: ?) -> +stream.Readable",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options",
          "!doc": "Returns a new ReadStream object."
        },
        createWriteStream: {
          "!type": "fn(path: string, options?: ?) -> +stream.Writable",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options",
          "!doc": "Returns a new WriteStream object."
        },
        FSWatcher: {
          "!type": "fn()",
          prototype: {
            close: "fn()"
          },
          "!url": "https://nodejs.org/api/fs.html#fs_class_fs_fswatcher",
          "!doc": "Objects returned from fs.watch() are of this type."
        }
      },
      path: {
        "!url": "https://nodejs.org/api/path.html",
        "!doc": "This module contains utilities for handling and transforming file paths. Almost all these methods perform only string transformations. The file system is not consulted to check whether paths are valid.",
        normalize: {
          "!type": "fn(p: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_normalize_p",
          "!doc": "Normalize a string path, taking care of '..' and '.' parts."
        },
        join: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_join_path1_path2",
          "!doc": "Join all arguments together and normalize the resulting path."
        },
        resolve: {
          "!type": "fn(from: string, from2: string, from3: string, from4: string, from5: string, to: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_resolve_from_to",
          "!doc": "Resolves to to an absolute path."
        },
        relative: {
          "!type": "fn(from: string, to: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_relative_from_to",
          "!doc": "Solve the relative path from from to to."
        },
        dirname: {
          "!type": "fn(p: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_dirname_p",
          "!doc": "Return the directory name of a path. Similar to the Unix dirname command."
        },
        basename: {
          "!type": "fn(p: string, ext?: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_basename_p_ext",
          "!doc": "Return the last portion of a path. Similar to the Unix basename command."
        },
        extname: {
          "!type": "fn(p: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_extname_p",
          "!doc": "Return the extension of the path, from the last '.' to end of string in the last portion of the path. If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string."
        },
        sep: {
          "!type": "string",
          "!url": "https://nodejs.org/api/path.html#path_path_sep",
          "!doc": "The platform-specific file separator. '\\\\' or '/'."
        },
        delimiter: {
          "!type": "string",
          "!url": "https://nodejs.org/api/path.html#path_path_delimiter",
          "!doc": "The platform-specific path delimiter, ; or ':'."
        }
      },
      string_decoder: {
        "!url": "https://nodejs.org/api/string_decoder.html",
        "!doc": "StringDecoder decodes a buffer to a string. It is a simple interface to buffer.toString() but provides additional support for utf8.",
        StringDecoder: {
          "!type": "fn(encoding?: string)",
          prototype: {
            write: {
              "!type": "fn(buffer: +Buffer) -> string",
              "!url": "https://nodejs.org/api/string_decoder.html#string_decoder_decoder_write_buffer",
              "!doc": "Returns a decoded string."
            },
            end: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/string_decoder.html#string_decoder_decoder_end",
              "!doc": "Returns any trailing bytes that were left in the buffer."
            }
          },
          "!url": "https://nodejs.org/api/string_decoder.html#string_decoder_class_stringdecoder",
          "!doc": "Accepts a single argument, encoding which defaults to utf8."
        }
      },
      tls: {
        "!url": "https://nodejs.org/api/tls.html",
        "!doc": "The tls module uses OpenSSL to provide Transport Layer Security and/or Secure Socket Layer: encrypted stream communication.",
        CLIENT_RENEG_LIMIT: "number",
        CLIENT_RENEG_WINDOW: "number",
        SLAB_BUFFER_SIZE: "number",
        getCiphers: {
          "!type": "fn() -> [string]",
          "!url": "https://nodejs.org/api/tls.html#tls_tls_getciphers",
          "!doc": "Returns an array with the names of the supported SSL ciphers."
        },
        Server: {
          "!type": "fn()",
          prototype: {
            "!proto": "net.Server.prototype",
            listen: {
              "!type": "fn(port: number, host?: string, callback?: fn())",
              "!url": "https://nodejs.org/api/tls.html#tls_server_listen_port_host_callback",
              "!doc": "Begin accepting connections on the specified port and host. If the host is omitted, the server will accept connections directed to any IPv4 address (INADDR_ANY)."
            },
            close: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/tls.html#tls_server_close",
              "!doc": "Stops the server from accepting new connections. This function is asynchronous, the server is finally closed when the server emits a 'close' event."
            },
            addContext: {
              "!type": "fn(hostName: string, credentials: tls.Server.credentials)",
              "!url": "https://nodejs.org/api/tls.html#tls_server_addcontext_hostname_credentials",
              "!doc": "Add secure context that will be used if client request's SNI hostname is matching passed hostname (wildcards can be used). credentials can contain key, cert and ca."
            }
          },
          "!url": "https://nodejs.org/api/tls.html#tls_class_tls_server",
          "!doc": "This class is a subclass of net.Server and has the same methods on it. Instead of accepting just raw TCP connections, this accepts encrypted connections using TLS or SSL."
        },
        createServer: {
          "!type": "fn(options?: ?, connectionListener?: fn(stream: +tls.CleartextStream)) -> +tls.Server",
          "!url": "https://nodejs.org/api/tls.html#tls_tls_createserver_options_secureconnectionlistener",
          "!doc": "Creates a new tls.Server. The connectionListener argument is automatically set as a listener for the secureConnection event."
        },
        CleartextStream: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            authorized: {
              "!type": "bool",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_authorized",
              "!doc": "A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false"
            },
            authorizationError: {
              "!type": "+Error",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_authorizationerror",
              "!doc": "The reason why the peer's certificate has not been verified. This property becomes available only when cleartextStream.authorized === false."
            },
            getPeerCertificate: {
              "!type": "fn() -> ?",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_getpeercertificate",
              "!doc": "Returns an object representing the peer's certificate. The returned object has some properties corresponding to the field of the certificate."
            },
            getCipher: {
              "!type": "fn() -> tls.cipher",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_getcipher",
              "!doc": "Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection."
            },
            address: {
              "!type": "net.address",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_address",
              "!doc": "Returns the bound address, the address family name and port of the underlying socket as reported by the operating system. Returns an object with three properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }"
            },
            remoteAddress: {
              "!type": "string",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_remoteaddress",
              "!doc": "The string representation of the remote IP address. For example, '74.125.127.100' or '2001:4860:a005::68'."
            },
            remotePort: {
              "!type": "number",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_remoteport",
              "!doc": "The numeric representation of the remote port. For example, 443."
            }
          },
          "!url": "https://nodejs.org/api/tls.html#tls_class_tls_cleartextstream",
          "!doc": "This is a stream on top of the Encrypted stream that makes it possible to read/write an encrypted data as a cleartext data."
        },
        connect: {
          "!type": "fn(port: number, host?: string, options: ?, listener: fn()) -> +tls.CleartextStream",
          "!url": "https://nodejs.org/api/tls.html#tls_tls_connect_options_callback",
          "!doc": "Creates a new client connection to the given port and host (old API) or options.port and options.host. (If host is omitted, it defaults to localhost.)"
        },
        createSecurePair: {
          "!type": "fn(credentials?: crypto.credentials, isServer?: bool, requestCert?: bool, rejectUnauthorized?: bool) -> +tls.SecurePair",
          "!url": "https://nodejs.org/api/tls.html#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized",
          "!doc": "Creates a new secure pair object with two streams, one of which reads/writes encrypted data, and one reads/writes cleartext data. Generally the encrypted one is piped to/from an incoming encrypted data stream, and the cleartext one is used as a replacement for the initial encrypted stream."
        },
        SecurePair: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            cleartext: {
              "!type": "+tls.CleartextStream",
              "!url": "https://nodejs.org/api/tls.html#tls_class_securepair",
              "!doc": "Returned by tls.createSecurePair."
            },
            encrypted: {
              "!type": "+stream.Duplex",
              "!url": "https://nodejs.org/api/tls.html#tls_class_securepair",
              "!doc": "Returned by tls.createSecurePair."
            }
          },
          "!url": "https://nodejs.org/api/tls.html#tls_class_securepair",
          "!doc": "Returned by tls.createSecurePair."
        }
      },
      crypto: {
        "!url": "https://nodejs.org/api/crypto.html",
        "!doc": "The crypto module offers a way of encapsulating secure credentials to be used as part of a secure HTTPS net or http connection.\nIt also offers a set of wrappers for OpenSSL's hash, hmac, cipher, decipher, sign and verify methods.",
        getCiphers: {
          "!type": "fn() -> [string]",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_getciphers",
          "!doc": "Returns an array with the names of the supported ciphers."
        },
        getHashes: {
          "!type": "fn() -> [string]",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_gethashes",
          "!doc": "Returns an array with the names of the supported hash algorithms."
        },
        createCredentials: {
          "!type": "fn(details?: ?) -> crypto.credentials",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createcredentials_details",
          "!doc": "Creates a credentials object."
        },
        createHash: {
          "!type": "fn(algorithm: string) -> +crypto.Hash",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm",
          "!doc": "Creates and returns a hash object, a cryptographic hash with the given algorithm which can be used to generate hash digests."
        },
        Hash: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            update: {
              "!type": "fn(data: +Buffer, encoding?: string)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_hash_update_data_input_encoding",
              "!doc": "Updates the hash content with the given data, the encoding of which is given in input_encoding and can be 'utf8', 'ascii' or 'binary'. If no encoding is provided, then a buffer is expected."
            },
            digest: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding",
              "!doc": "Calculates the digest of all of the passed data to be hashed. The encoding can be 'hex', 'binary' or 'base64'. If no encoding is provided, then a buffer is returned."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_hash",
          "!doc": "The class for creating hash digests of data."
        },
        createHmac: {
          "!type": "fn(algorithm: string, key: string) -> +crypto.Hmac",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createhmac_algorithm_key",
          "!doc": "Creates and returns a hmac object, a cryptographic hmac with the given algorithm and key."
        },
        Hmac: {
          "!type": "fn()",
          prototype: {
            update: {
              "!type": "fn(data: +Buffer)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_hmac_update_data",
              "!doc": "Update the hmac content with the given data. This can be called many times with new data as it is streamed."
            },
            digest: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_hmac_digest_encoding",
              "!doc": "Calculates the digest of all of the passed data to the hmac. The encoding can be 'hex', 'binary' or 'base64'. If no encoding is provided, then a buffer is returned."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_hmac",
          "!doc": "Class for creating cryptographic hmac content."
        },
        createCipher: {
          "!type": "fn(algorithm: string, password: string) -> +crypto.Cipher",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createcipher_algorithm_password",
          "!doc": "Creates and returns a cipher object, with the given algorithm and password."
        },
        createCipheriv: {
          "!type": "fn(algorithm: string, password: string, iv: string) -> +crypto.Cipher",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv",
          "!doc": "Creates and returns a cipher object, with the given algorithm, key and iv."
        },
        Cipher: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            update: {
              "!type": "fn(data: +Buffer, input_encoding?: string, output_encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_cipher_update_data_input_encoding_output_encoding",
              "!doc": "Updates the cipher with data, the encoding of which is given in input_encoding and can be 'utf8', 'ascii' or 'binary'. If no encoding is provided, then a buffer is expected."
            },
            "final": {
              "!type": "fn(output_encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_cipher_final_output_encoding",
              "!doc": "Returns any remaining enciphered contents, with output_encoding being one of: 'binary', 'base64' or 'hex'. If no encoding is provided, then a buffer is returned."
            },
            setAutoPadding: {
              "!type": "fn(auto_padding: bool)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_cipher_setautopadding_auto_padding_true",
              "!doc": "You can disable automatic padding of the input data to block size. If auto_padding is false, the length of the entire input data must be a multiple of the cipher's block size or final will fail. Useful for non-standard padding, e.g. using 0x0 instead of PKCS padding. You must call this before cipher.final."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_cipher",
          "!doc": "Class for encrypting data."
        },
        createDecipher: {
          "!type": "fn(algorithm: string, password: string) -> +crypto.Decipher",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createdecipher_algorithm_password",
          "!doc": "Creates and returns a decipher object, with the given algorithm and key. This is the mirror of the createCipher() above."
        },
        createDecipheriv: {
          "!type": "fn(algorithm: string, key: string, iv: string) -> +crypto.Decipher",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv",
          "!doc": "Creates and returns a decipher object, with the given algorithm, key and iv. This is the mirror of the createCipheriv() above."
        },
        Decipher: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            update: {
              "!type": "fn(data: +Buffer, input_encoding?: string, output_encoding?: string)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_decipher_update_data_input_encoding_output_encoding",
              "!doc": "Updates the decipher with data, which is encoded in 'binary', 'base64' or 'hex'. If no encoding is provided, then a buffer is expected."
            },
            "final": {
              "!type": "fn(output_encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_decipher_final_output_encoding",
              "!doc": "Returns any remaining plaintext which is deciphered, with output_encoding being one of: 'binary', 'ascii' or 'utf8'. If no encoding is provided, then a buffer is returned."
            },
            setAutoPadding: {
              "!type": "fn(auto_padding: bool)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_decipher_setautopadding_auto_padding_true",
              "!doc": "You can disable auto padding if the data has been encrypted without standard block padding to prevent decipher.final from checking and removing it. Can only work if the input data's length is a multiple of the ciphers block size. You must call this before streaming data to decipher.update."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_decipher",
          "!doc": "Class for decrypting data."
        },
        createSign: {
          "!type": "fn(algorithm: string) -> +crypto.Sign",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createsign_algorithm",
          "!doc": "Creates and returns a signing object, with the given algorithm. On recent OpenSSL releases, openssl list-public-key-algorithms will display the available signing algorithms. Examples are 'RSA-SHA256'."
        },
        Sign: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Writable.prototype",
            update: {
              "!type": "fn(data: +Buffer)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_sign_update_data",
              "!doc": "Updates the sign object with data. This can be called many times with new data as it is streamed."
            },
            sign: {
              "!type": "fn(private_key: string, output_format: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format",
              "!doc": "Calculates the signature on all the updated data passed through the sign. private_key is a string containing the PEM encoded private key for signing."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_sign",
          "!doc": "Class for generating signatures."
        },
        createVerify: {
          "!type": "fn(algorith: string) -> +crypto.Verify",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createverify_algorithm",
          "!doc": "Creates and returns a verification object, with the given algorithm. This is the mirror of the signing object above."
        },
        Verify: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Writable.prototype",
            update: {
              "!type": "fn(data: +Buffer)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_verifier_update_data",
              "!doc": "Updates the verifier object with data. This can be called many times with new data as it is streamed."
            },
            verify: {
              "!type": "fn(object: string, signature: string, signature_format?: string) -> bool",
              "!url": "https://nodejs.org/api/crypto.html#crypto_verifier_verify_object_signature_signature_format",
              "!doc": "Verifies the signed data by using the object and signature. object is a string containing a PEM encoded object, which can be one of RSA public key, DSA public key, or X.509 certificate. signature is the previously calculated signature for the data, in the signature_format which can be 'binary', 'hex' or 'base64'. If no encoding is specified, then a buffer is expected."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_verify",
          "!doc": "Class for verifying signatures."
        },
        createDiffieHellman: {
          "!type": "fn(prime: number, encoding?: string) -> +crypto.DiffieHellman",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_creatediffiehellman_prime_length",
          "!doc": "Creates a Diffie-Hellman key exchange object and generates a prime of the given bit length. The generator used is 2."
        },
        DiffieHellman: {
          "!type": "fn()",
          prototype: {
            generateKeys: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_generatekeys_encoding",
              "!doc": "Generates private and public Diffie-Hellman key values, and returns the public key in the specified encoding. This key should be transferred to the other party. Encoding can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            computeSecret: {
              "!type": "fn(other_public_key: +Buffer, input_encoding?: string, output_encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding",
              "!doc": "Computes the shared secret using other_public_key as the other party's public key and returns the computed shared secret. Supplied key is interpreted using specified input_encoding, and secret is encoded using specified output_encoding. Encodings can be 'binary', 'hex', or 'base64'. If the input encoding is not provided, then a buffer is expected."
            },
            getPrime: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_getprime_encoding",
              "!doc": "Returns the Diffie-Hellman prime in the specified encoding, which can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            getGenerator: {
              "!type": "fn(encoding: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_getgenerator_encoding",
              "!doc": "Returns the Diffie-Hellman prime in the specified encoding, which can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            getPublicKey: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_getpublickey_encoding",
              "!doc": "Returns the Diffie-Hellman public key in the specified encoding, which can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            getPrivateKey: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_getprivatekey_encoding",
              "!doc": "Returns the Diffie-Hellman private key in the specified encoding, which can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            setPublicKey: {
              "!type": "fn(public_key: +Buffer, encoding?: string)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_setpublickey_public_key_encoding",
              "!doc": "Sets the Diffie-Hellman public key. Key encoding can be 'binary', 'hex' or 'base64'. If no encoding is provided, then a buffer is expected."
            },
            setPrivateKey: {
              "!type": "fn(public_key: +Buffer, encoding?: string)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_setprivatekey_private_key_encoding",
              "!doc": "Sets the Diffie-Hellman private key. Key encoding can be 'binary', 'hex' or 'base64'. If no encoding is provided, then a buffer is expected."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_diffiehellman",
          "!doc": "The class for creating Diffie-Hellman key exchanges."
        },
        getDiffieHellman: {
          "!type": "fn(group_name: string) -> +crypto.DiffieHellman",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_getdiffiehellman_group_name",
          "!doc": "Creates a predefined Diffie-Hellman key exchange object. The supported groups are: 'modp1', 'modp2', 'modp5' (defined in RFC 2412) and 'modp14', 'modp15', 'modp16', 'modp17', 'modp18' (defined in RFC 3526). The returned object mimics the interface of objects created by crypto.createDiffieHellman() above, but will not allow to change the keys (with diffieHellman.setPublicKey() for example). The advantage of using this routine is that the parties don't have to generate nor exchange group modulus beforehand, saving both processor and communication time."
        },
        pbkdf2: {
          "!type": "fn(password: string, salt: string, iterations: number, keylen: number, callback: fn(err: +Error, derivedKey: string))",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2_password_salt_iterations_keylen_callback",
          "!doc": "Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive a key of given length from the given password, salt and iterations. The callback gets two arguments (err, derivedKey)."
        },
        pbkdf2Sync: {
          "!type": "fn(password: string, salt: string, iterations: number, keylen: number) -> string",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen",
          "!doc": "Synchronous PBKDF2 function. Returns derivedKey or throws error."
        },
        randomBytes: {
          "!type": "fn(size: number, callback?: fn(err: +Error, buf: +Buffer))",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback",
          "!doc": "Generates cryptographically strong pseudo-random data."
        },
        pseudoRandomBytes: {
          "!type": "fn(size: number, callback?: fn(err: +Error, buf: +Buffer))",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_pseudorandombytes_size_callback",
          "!doc": "Generates non-cryptographically strong pseudo-random data. The data returned will be unique if it is sufficiently long, but is not necessarily unpredictable. For this reason, the output of this function should never be used where unpredictability is important, such as in the generation of encryption keys."
        },
        DEFAULT_ENCODING: "string"
      },
      util: {
        "!url": "https://nodejs.org/api/util.html",
        "!doc": "The util module is primarily designed to support the needs of Node's internal APIs. Many of these utilities are useful for your own programs. If you find that these functions are lacking for your purposes, however, you are encouraged to write your own utilities. We are not interested in any future additions to the util module that are unnecessary for Node's internal functionality.",
        format: {
          "!type": "fn(format: string) -> string",
          "!url": "https://nodejs.org/api/util.html#util_util_format_format",
          "!doc": "Returns a formatted string using the first argument as a printf-like format."
        },
        debug: {
          "!type": "fn(msg: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_debug_string",
          "!doc": "A synchronous output function. Will block the process and output string immediately to stderr."
        },
        error: {
          "!type": "fn(msg: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_error",
          "!doc": "Same as util.debug() except this will output all arguments immediately to stderr."
        },
        puts: {
          "!type": "fn(data: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_puts",
          "!doc": "A synchronous output function. Will block the process and output all arguments to stdout with newlines after each argument."
        },
        print: {
          "!type": "fn(data: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_print",
          "!doc": "A synchronous output function. Will block the process, cast each argument to a string then output to stdout. Does not place newlines after each argument."
        },
        log: {
          "!type": "fn(string: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_log_string",
          "!doc": "Output with timestamp on stdout."
        },
        inspect: {
          "!type": "fn(object: ?, options: ?) -> string",
          "!url": "https://nodejs.org/api/util.html#util_util_inspect_object_options",
          "!doc": "Return a string representation of object, which is useful for debugging."
        },
        isArray: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isarray_object",
          "!doc": "Returns true if the given \"object\" is an Array. false otherwise."
        },
        isRegExp: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isregexp_object",
          "!doc": "Returns true if the given \"object\" is a RegExp. false otherwise."
        },
        isDate: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isdate_object",
          "!doc": "Returns true if the given \"object\" is a Date. false otherwise."
        },
        isError: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_iserror_object",
          "!doc": "Returns true if the given \"object\" is an Error. false otherwise."
        },
        isBoolean: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isboolean_object",
          "!doc": "Returns true if the given \"object\" is a Boolean. false otherwise."
        },
        isNull: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isnull_object",
          "!doc": "Returns true if the given \"object\" is strictly null. false otherwise."
        },
        isNullOrUndefined: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isnullorundefined_object",
          "!doc": "Returns true if the given \"object\" is null or undefined. false otherwise."
        },
        isNumber: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isnumber_object",
          "!doc": "Returns true if the given \"object\" is a Number. false otherwise."
        },
        isString: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isstring_object",
          "!doc": "Returns true if the given \"object\" is a String. false otherwise."
        },
        isSymbol: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_issymbol_object",
          "!doc": "Returns true if the given \"object\" is a Symbol. false otherwise."
        },
        isUndefined: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isundefined_object",
          "!doc": "Returns true if the given \"object\" is undefined. false otherwise."
        },
        isObject: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isobject_object",
          "!doc": "Returns true if the given \"object\" is strictly an Object and not a Function. false otherwise."
        },
        isFunction: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isfunction_object",
          "!doc": "Returns true if the given \"object\" is a Function. false otherwise."
        },
        isPrimitive: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isprimitive_object",
          "!doc": "Returns true if the given \"object\" is a primitive type. false otherwise."
        },
        isBuffer: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isbuffer_object",
          "!doc": "Returns true if the given \"object\" is a Buffer. false otherwise."
        },
        inherits: {
          "!type": "fn(constructor: ?, superConstructor: ?)",
          "!url": "https://nodejs.org/api/util.html#util_util_inherits_constructor_superconstructor",
          "!doc": "Inherit the prototype methods from one constructor into another. The prototype of constructor will be set to a new object created from superConstructor."
        }
      },
      assert: {
        "!type": "fn(value: ?, message?: string)",
        fail: {
          "!type": "fn(actual: ?, expected: ?, message: string, operator: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_fail_actual_expected_message_operator",
          "!doc": "Throws an exception that displays the values for actual and expected separated by the provided operator."
        },
        ok: {
          "!type": "fn(value: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert",
          "!doc": "This module is used for writing unit tests for your applications, you can access it with require('assert')."
        },
        equal: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_equal_actual_expected_message",
          "!doc": "Tests shallow, coercive equality with the equal comparison operator ( == )."
        },
        notEqual: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_notequal_actual_expected_message",
          "!doc": "Tests shallow, coercive non-equality with the not equal comparison operator ( != )."
        },
        deepEqual: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_deepequal_actual_expected_message",
          "!doc": "Tests for deep equality."
        },
        notDeepEqual: {
          "!type": "fn(acutal: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_notdeepequal_actual_expected_message",
          "!doc": "Tests for any deep inequality."
        },
        strictEqual: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_strictequal_actual_expected_message",
          "!doc": "Tests strict equality, as determined by the strict equality operator ( === )"
        },
        notStrictEqual: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_notstrictequal_actual_expected_message",
          "!doc": "Tests strict non-equality, as determined by the strict not equal operator ( !== )"
        },
        "throws": {
          "!type": "fn(block: fn(), error?: ?, messsage?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_throws_block_error_message",
          "!doc": "Expects block to throw an error. error can be constructor, regexp or validation function."
        },
        doesNotThrow: {
          "!type": "fn(block: fn(), error?: ?, messsage?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_doesnotthrow_block_message",
          "!doc": "Expects block not to throw an error."
        },
        ifError: {
          "!type": "fn(value: ?)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_iferror_value",
          "!doc": "Tests if value is not a false value, throws if it is a true value. Useful when testing the first argument, error in callbacks."
        },
        "!url": "https://nodejs.org/api/assert.html#assert_assert",
        "!doc": "This module is used for writing unit tests for your applications, you can access it with require('assert')."
      },
      tty: {
        "!url": "https://nodejs.org/api/tty.html",
        "!doc": "The tty module houses the tty.ReadStream and tty.WriteStream classes. In most cases, you will not need to use this module directly.",
        isatty: {
          "!type": "fn(fd: number) -> bool",
          "!url": "https://nodejs.org/api/tty.html#tty_tty_isatty_fd",
          "!doc": "Returns true or false depending on if the fd is associated with a terminal."
        }
      },
      domain: {
        "!url": "https://nodejs.org/api/domain.html",
        "!doc": "Domains provide a way to handle multiple different IO operations as a single group. If any of the event emitters or callbacks registered to a domain emit an error event, or throw an error, then the domain object will be notified, rather than losing the context of the error in the process.on('uncaughtException') handler, or causing the program to exit immediately with an error code.",
        create: {
          "!type": "fn() -> +events.EventEmitter",
          "!url": "https://nodejs.org/api/domain.html#domain_domain_create",
          "!doc": "Returns a new Domain object."
        },
        Domain: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            run: {
              "!type": "fn(fn: fn())",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_run_fn",
              "!doc": "Run the supplied function in the context of the domain, implicitly binding all event emitters, timers, and lowlevel requests that are created in that context."
            },
            members: {
              "!type": "[+events.EventEmitter]",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_members",
              "!doc": "An array of timers and event emitters that have been explicitly added to the domain."
            },
            add: {
              "!type": "fn(emitter: +events.EventEmitter)",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_add_emitter",
              "!doc": "Explicitly adds an emitter to the domain. If any event handlers called by the emitter throw an error, or if the emitter emits an error event, it will be routed to the domain's error event, just like with implicit binding."
            },
            remove: {
              "!type": "fn(emitter: +events.EventEmitter)",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_remove_emitter",
              "!doc": "The opposite of domain.add(emitter). Removes domain handling from the specified emitter."
            },
            bind: {
              "!type": "fn(callback: fn(err: +Error, data: ?)) -> !0",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_bind_callback",
              "!doc": "The returned function will be a wrapper around the supplied callback function. When the returned function is called, any errors that are thrown will be routed to the domain's error event."
            },
            intercept: {
              "!type": "fn(cb: fn(data: ?)) -> !0",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_intercept_callback",
              "!doc": "This method is almost identical to domain.bind(callback). However, in addition to catching thrown errors, it will also intercept Error objects sent as the first argument to the function."
            },
            dispose: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_dispose",
              "!doc": "The dispose method destroys a domain, and makes a best effort attempt to clean up any and all IO that is associated with the domain. Streams are aborted, ended, closed, and/or destroyed. Timers are cleared. Explicitly bound callbacks are no longer called. Any error events that are raised as a result of this are ignored."
            }
          },
          "!url": "https://nodejs.org/api/domain.html#domain_class_domain",
          "!doc": "The Domain class encapsulates the functionality of routing errors and uncaught exceptions to the active Domain object."
        }
      },
      "os.cpuSpec": {
        model: "string",
        speed: "number",
        times: {
          user: "number",
          nice: "number",
          sys: "number",
          idle: "number",
          irq: "number"
        }
      },
      "process.memoryUsage.type": {
        rss: "number",
        heapTotal: "?",
        number: "?",
        heapUsed: "number"
      },
      "net.address": {
        port: "number",
        family: "string",
        address: "string"
      },
      "url.type": {
        href: "string",
        protocol: "string",
        auth: "string",
        hostname: "string",
        port: "string",
        host: "string",
        pathname: "string",
        search: "string",
        query: "string",
        slashes: "bool",
        hash: "string"
      },
      "tls.Server.credentials": {
        key: "string",
        cert: "string",
        ca: "string"
      },
      "tls.cipher": {
        name: "string",
        version: "string"
      },
      "crypto.credentials": {
        pfx: "string",
        key: "string",
        passphrase: "string",
        cert: "string",
        ca: "string",
        crl: "string",
        ciphers: "string"
      },
      buffer: {
        Buffer: "Buffer",
        INSPECT_MAX_BYTES: "number",
        SlowBuffer: "Buffer"
      },
      module: {},
      timers: {
        setTimeout: {
          "!type": "fn(callback: fn(), ms: number) -> timers.Timer",
          "!url": "https://nodejs.org/api/globals.html#globals_settimeout_cb_ms",
          "!doc": "Run callback cb after at least ms milliseconds. The actual delay depends on external factors like OS timer granularity and system load."
        },
        clearTimeout: {
          "!type": "fn(id: timers.Timer)",
          "!url": "https://nodejs.org/api/globals.html#globals_cleartimeout_t",
          "!doc": "Stop a timer that was previously created with setTimeout(). The callback will not execute."
        },
        setInterval: {
          "!type": "fn(callback: fn(), ms: number) -> timers.Timer",
          "!url": "https://nodejs.org/api/globals.html#globals_setinterval_cb_ms",
          "!doc": "Run callback cb repeatedly every ms milliseconds. Note that the actual interval may vary, depending on external factors like OS timer granularity and system load. It's never less than ms but it may be longer."
        },
        clearInterval: {
          "!type": "fn(id: timers.Timer)",
          "!url": "https://nodejs.org/api/globals.html#globals_clearinterval_t",
          "!doc": "Stop a timer that was previously created with setInterval(). The callback will not execute."
        },
        setImmediate: {
          "!type": "fn(callback: fn()) -> timers.Timer",
          "!url": "https://nodejs.org/api/timers.html#timers_setimmediate_callback_arg",
          "!doc": "Schedule the 'immediate' execution of callback after I/O events callbacks."
        },
        clearImmediate: {
          "!type": "fn(id: timers.Timer)",
          "!url": "https://nodejs.org/api/timers.html#timers_clearimmediate_immediateid",
          "!doc": "Stops an immediate from triggering."
        },
        Timer: {
          unref: {
            "!type": "fn()",
            "!url": "https://nodejs.org/api/timers.html#timers_unref",
            "!doc": "Create a timer that is active but if it is the only item left in the event loop won't keep the program running."
          },
          ref: {
            "!type": "fn()",
            "!url": "https://nodejs.org/api/timers.html#timers_unref",
            "!doc": "Explicitly request the timer hold the program open (cancel the effect of 'unref')."
          }
        }
      }
    },
    process: {
      stdout: {
        "!type": "+stream.Writable",
        "!url": "https://nodejs.org/api/process.html#process_process_stdout",
        "!doc": "A Writable Stream to stdout."
      },
      stderr: {
        "!type": "+stream.Writable",
        "!url": "https://nodejs.org/api/process.html#process_process_stderr",
        "!doc": "A writable stream to stderr."
      },
      stdin: {
        "!type": "+stream.Readable",
        "!url": "https://nodejs.org/api/process.html#process_process_stdin",
        "!doc": "A Readable Stream for stdin. The stdin stream is paused by default, so one must call process.stdin.resume() to read from it."
      },
      argv: {
        "!type": "[string]",
        "!url": "https://nodejs.org/api/process.html#process_process_argv",
        "!doc": "An array containing the command line arguments. The first element will be 'node', the second element will be the name of the JavaScript file. The next elements will be any additional command line arguments."
      },
      execPath: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_execpath",
        "!doc": "This is the absolute pathname of the executable that started the process."
      },
      abort: {
        "!type": "fn()",
        "!url": "https://nodejs.org/api/process.html#process_process_abort",
        "!doc": "This causes node to emit an abort. This will cause node to exit and generate a core file."
      },
      chdir: {
        "!type": "fn(directory: string)",
        "!url": "https://nodejs.org/api/process.html#process_process_chdir_directory",
        "!doc": "Changes the current working directory of the process or throws an exception if that fails."
      },
      cwd: {
        "!type": "fn()",
        "!url": "https://nodejs.org/api/process.html#process_process_cwd",
        "!doc": "Returns the current working directory of the process."
      },
      env: {
        "!url": "https://nodejs.org/api/process.html#process_process_env",
        "!doc": "An object containing the user environment."
      },
      exit: {
        "!type": "fn(code?: number)",
        "!url": "https://nodejs.org/api/process.html#process_process_exit_code",
        "!doc": "Ends the process with the specified code. If omitted, exit uses the 'success' code 0."
      },
      getgid: {
        "!type": "fn() -> number",
        "!url": "https://nodejs.org/api/process.html#process_process_getgid",
        "!doc": "Gets the group identity of the process. This is the numerical group id, not the group name."
      },
      setgid: {
        "!type": "fn(id: number)",
        "!url": "https://nodejs.org/api/process.html#process_process_setgid_id",
        "!doc": "Sets the group identity of the process. This accepts either a numerical ID or a groupname string. If a groupname is specified, this method blocks while resolving it to a numerical ID."
      },
      getuid: {
        "!type": "fn() -> number",
        "!url": "https://nodejs.org/api/process.html#process_process_getuid",
        "!doc": "Gets the user identity of the process. This is the numerical userid, not the username."
      },
      setuid: {
        "!type": "fn(id: number)",
        "!url": "https://nodejs.org/api/process.html#process_process_setuid_id",
        "!doc": "Sets the user identity of the process. This accepts either a numerical ID or a username string. If a username is specified, this method blocks while resolving it to a numerical ID."
      },
      version: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_version",
        "!doc": "A compiled-in property that exposes NODE_VERSION."
      },
      versions: {
        http_parser: "string",
        node: "string",
        v8: "string",
        ares: "string",
        uv: "string",
        zlib: "string",
        openssl: "string",
        "!url": "https://nodejs.org/api/process.html#process_process_versions",
        "!doc": "A property exposing version strings of node and its dependencies."
      },
      config: {
        target_defaults: {
          cflags: "[?]",
          default_configuration: "string",
          defines: "[string]",
          include_dirs: "[string]",
          libraries: "[string]"
        },
        variables: {
          clang: "number",
          host_arch: "string",
          node_install_npm: "bool",
          node_install_waf: "bool",
          node_prefix: "string",
          node_shared_openssl: "bool",
          node_shared_v8: "bool",
          node_shared_zlib: "bool",
          node_use_dtrace: "bool",
          node_use_etw: "bool",
          node_use_openssl: "bool",
          target_arch: "string",
          v8_no_strict_aliasing: "number",
          v8_use_snapshot: "bool",
          visibility: "string"
        },
        "!url": "https://nodejs.org/api/process.html#process_process_config",
        "!doc": "An Object containing the JavaScript representation of the configure options that were used to compile the current node executable. This is the same as the \"config.gypi\" file that was produced when running the ./configure script."
      },
      kill: {
        "!type": "fn(pid: number, signal?: string)",
        "!url": "https://nodejs.org/api/process.html#process_process_kill_pid_signal",
        "!doc": "Send a signal to a process. pid is the process id and signal is the string describing the signal to send. Signal names are strings like 'SIGINT' or 'SIGUSR1'. If omitted, the signal will be 'SIGTERM'."
      },
      pid: {
        "!type": "number",
        "!url": "https://nodejs.org/api/process.html#process_process_pid",
        "!doc": "The PID of the process."
      },
      title: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_title",
        "!doc": "Getter/setter to set what is displayed in 'ps'."
      },
      arch: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_arch",
        "!doc": "What processor architecture you're running on: 'arm', 'ia32', or 'x64'."
      },
      platform: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_platform",
        "!doc": "What platform you're running on: 'darwin', 'freebsd', 'linux', 'sunos' or 'win32'"
      },
      memoryUsage: {
        "!type": "fn() -> process.memoryUsage.type",
        "!url": "https://nodejs.org/api/process.html#process_process_memoryusage",
        "!doc": "Returns an object describing the memory usage of the Node process measured in bytes."
      },
      nextTick: {
        "!type": "fn(callback: fn())",
        "!url": "https://nodejs.org/api/process.html#process_process_nexttick_callback",
        "!doc": "On the next loop around the event loop call this callback. This is not a simple alias to setTimeout(fn, 0), it's much more efficient. It typically runs before any other I/O events fire, but there are some exceptions."
      },
      maxTickDepth: {
        "!type": "number",
        "!url": "https://nodejs.org/api/process.html#process_process_maxtickdepth",
        "!doc": "The maximum depth of nextTick-calling nextTick-callbacks that will be evaluated before allowing other forms of I/O to occur."
      },
      umask: {
        "!type": "fn(mask?: number) -> number",
        "!url": "https://nodejs.org/api/process.html#process_process_umask_mask",
        "!doc": "Sets or reads the process's file mode creation mask. Child processes inherit the mask from the parent process. Returns the old mask if mask argument is given, otherwise returns the current mask."
      },
      uptime: {
        "!type": "fn() -> number",
        "!url": "https://nodejs.org/api/process.html#process_process_uptime",
        "!doc": "Number of seconds Node has been running."
      },
      hrtime: {
        "!type": "fn() -> [number]",
        "!url": "https://nodejs.org/api/process.html#process_process_hrtime",
        "!doc": "Returns the current high-resolution real time in a [seconds, nanoseconds] tuple Array. It is relative to an arbitrary time in the past. It is not related to the time of day and therefore not subject to clock drift. The primary use is for measuring performance between intervals."
      },
      "!url": "https://nodejs.org/api/globals.html#globals_process",
      "!doc": "The process object."
    },
    global: {
      "!type": "<top>",
      "!url": "https://nodejs.org/api/globals.html#globals_global",
      "!doc": "In browsers, the top-level scope is the global scope. That means that in browsers if you're in the global scope var something will define a global variable. In Node this is different. The top-level scope is not the global scope; var something inside a Node module will be local to that module."
    },
    console: {
      log: {
        "!type": "fn(text: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_log_data",
        "!doc": "Prints to stdout with newline. This function can take multiple arguments in a printf()-like way."
      },
      info: {
        "!type": "fn(text: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_info_data",
        "!doc": "Same as console.log."
      },
      error: {
        "!type": "fn(text: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_error_data",
        "!doc": "Same as console.log but prints to stderr."
      },
      warn: {
        "!type": "fn(text: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_warn_data",
        "!doc": "Same as console.error."
      },
      dir: {
        "!type": "fn(obj: ?)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_dir_obj",
        "!doc": "Uses util.inspect on obj and prints resulting string to stdout."
      },
      time: {
        "!type": "fn(label: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_time_label",
        "!doc": "Mark a time."
      },
      timeEnd: {
        "!type": "fn(label: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_timeend_label",
        "!doc": "Finish timer, record output."
      },
      trace: {
        "!type": "fn(label: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_trace_label",
        "!doc": "Print a stack trace to stderr of the current position."
      },
      assert: {
        "!type": "fn(expression: bool)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_assert_expression_message",
        "!doc": "Same as assert.ok() where if the expression evaluates as false throw an AssertionError with message."
      },
      "!url": "https://nodejs.org/api/globals.html#globals_console",
      "!doc": "Used to print to stdout and stderr."
    },
    __filename: {
      "!type": "string",
      "!url": "https://nodejs.org/api/globals.html#globals_filename",
      "!doc": "The filename of the code being executed. This is the resolved absolute path of this code file. For a main program this is not necessarily the same filename used in the command line. The value inside a module is the path to that module file."
    },
    __dirname: {
      "!type": "string",
      "!url": "https://nodejs.org/api/globals.html#globals_dirname",
      "!doc": "The name of the directory that the currently executing script resides in."
    },
    setTimeout: "timers.setTimeout",
    clearTimeout: "timers.clearTimeout",
    setInterval: "timers.setInterval",
    clearInterval: "timers.clearInterval",
    Buffer: {
      "!type": "fn(str: string, encoding?: string) -> +Buffer",
      prototype: {
        "!proto": "String.prototype",
        write: "fn(string: string, offset?: number, length?: number, encoding?: string) -> number",
        toString: "fn(encoding?: string, start?: number, end?: number) -> string",
        length: "number",
        copy: "fn(targetBuffer: +Buffer, targetStart?: number, sourceStart?: number, sourceEnd?: number)",
        slice: "fn(start?: number, end?: number) -> +Buffer",
        readUInt8: "fn(offset: number, noAssert?: bool) -> number",
        readUInt16LE: "fn(offset: number, noAssert?: bool) -> number",
        readUInt16BE: "fn(offset: number, noAssert?: bool) -> number",
        readUInt32LE: "fn(offset: number, noAssert?: bool) -> number",
        readUInt32BE: "fn(offset: number, noAssert?: bool) -> number",
        readInt8: "fn(offset: number, noAssert?: bool) -> number",
        readInt16LE: "fn(offset: number, noAssert?: bool) -> number",
        readInt16BE: "fn(offset: number, noAssert?: bool) -> number",
        readInt32LE: "fn(offset: number, noAssert?: bool) -> number",
        readInt32BE: "fn(offset: number, noAssert?: bool) -> number",
        readFloatLE: "fn(offset: number, noAssert?: bool) -> number",
        readFloatBE: "fn(offset: number, noAssert?: bool) -> number",
        readDoubleLE: "fn(offset: number, noAssert?: bool) -> number",
        readDoubleBE: "fn(offset: number, noAssert?: bool) -> number",
        writeUInt8: "fn(value: number, offset: number, noAssert?: bool)",
        writeUInt16LE: "fn(value: number, offset: number, noAssert?: bool)",
        writeUInt16BE: "fn(value: number, offset: number, noAssert?: bool)",
        writeUInt32LE: "fn(value: number, offset: number, noAssert?: bool)",
        writeUInt32BE: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt8: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt16LE: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt16BE: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt32LE: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt32BE: "fn(value: number, offset: number, noAssert?: bool)",
        writeFloatLE: "fn(value: number, offset: number, noAssert?: bool)",
        writeFloatBE: "fn(value: number, offset: number, noAssert?: bool)",
        writeDoubleLE: "fn(value: number, offset: number, noAssert?: bool)",
        writeDoubleBE: "fn(value: number, offset: number, noAssert?: bool)",
        fill: "fn(value: ?, offset?: number, end?: number)"
      },
      isBuffer: "fn(obj: ?) -> bool",
      byteLength: "fn(string: string, encoding?: string) -> number",
      concat: "fn(list: [+Buffer], totalLength?: number) -> +Buffer",
      "!url": "https://nodejs.org/api/globals.html#globals_class_buffer",
      "!doc": "Used to handle binary data."
    }
  };
});

});

define("tern/plugin/requirejs",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern"], mod);
  mod(tern, tern);
})(function(infer, tern) {
  "use strict";

  function flattenPath(path) {
    if (!/(^|\/)(\.\/|[^\/]+\/\.\.\/)/.test(path)) return path;
    var parts = path.split("/");
    for (var i = 0; i < parts.length; ++i) {
      if (parts[i] == "." || !parts[i]) parts.splice(i--, 1);
      else if (i && parts[i] == "..") parts.splice(i-- - 1, 2);
    }
    return parts.join("/");
  }

  function resolveName(name, data) {
    var excl = name.indexOf("!");
    if (excl > -1) name = name.slice(0, excl);

    var opts = data.options;
    var hasExt = /\.js$/.test(name);
    if (hasExt || /^(?:\w+:|\/)/.test(name))
      return name + (hasExt ? "" : ".js");

    var base = opts.baseURL || "";
    if (base && base.charAt(base.length - 1) != "/") base += "/";
    if (opts.paths) {
      var known = opts.paths[name];
      if (known) return flattenPath(base + known + ".js");
      var dir = name.match(/^([^\/]+)(\/.*)$/);
      if (dir) {
        var known = opts.paths[dir[1]];
        if (known) return flattenPath(base + known + dir[2] + ".js");
      }
    }
    return flattenPath(base + name + ".js");
  }

  function getRequire(data) {
    if (!data.require) {
      data.require = new infer.Fn("require", infer.ANull, [infer.cx().str], ["module"], new infer.AVal);
      data.require.computeRet = function(_self, _args, argNodes) {
        if (argNodes.length && argNodes[0].type == "Literal" && typeof argNodes[0].value == "string")
          return getInterface(path.join(path.dirname(data.currentFile), argNodes[0].value), data);
        return infer.ANull;
      };
    }
    return data.require;
  }

  function getModuleInterface(data, exports) {
    var mod = new infer.Obj(infer.cx().definitions.requirejs.module, "module");
    var expProp = mod.defProp("exports");
    expProp.propagate(getModule(data.currentFile, data));
    exports.propagate(expProp, EXPORT_OBJ_WEIGHT);
    return mod;
  }

  function getExports(data) {
    var exports = new infer.Obj(true, "exports");
    getModule(data.currentFile, data).addType(exports, EXPORT_OBJ_WEIGHT);
    return exports;
  }

  function getInterface(name, data) {
    if (data.options.override && Object.prototype.hasOwnProperty.call(data.options.override, name)) {
      var over = data.options.override[name];
      if (typeof over == "string" && over.charAt(0) == "=") return infer.def.parsePath(over.slice(1));
      if (typeof over == "object") {
        var known = getKnownModule(name, data);
        if (known) return known;
        var scope = data.interfaces[stripJSExt(name)] = new infer.Obj(null, stripJSExt(name));
        infer.def.load(over, scope);
        return scope;
      }
      name = over;
    }

    if (!/^(https?:|\/)|\.js$/.test(name))
      name = resolveName(name, data);
    name = flattenPath(name);

    var known = getKnownModule(name, data);

    if (!known) {
      known = getModule(name, data);
      data.server.addFile(name, null, data.currentFile);
    }
    return known;
  }

  function getKnownModule(name, data) {
    return data.interfaces[stripJSExt(name)];
  }

  function getModule(name, data) {
    var known = getKnownModule(name, data);
    if (!known) {
      known = data.interfaces[stripJSExt(name)] = new infer.AVal;
      known.origin = name;
    }
    return known;
  }

  var EXPORT_OBJ_WEIGHT = 50;

  function stripJSExt(f) {
    return f.replace(/\.js$/, '');
  }

  var path = {
    dirname: function(path) {
      var lastSep = path.lastIndexOf("/");
      return lastSep == -1 ? "" : path.slice(0, lastSep);
    },
    relative: function(from, to) {
      if (to.indexOf(from) == 0) return to.slice(from.length);
      else return to;
    },
    join: function(a, b) {
      if (b && b.charAt(0) != ".") return b;
      if (a && b) return a + "/" + b;
      else return (a || "") + (b || "");
    }
  };

  function runModule(server, args, argNodes, out) {
    var data = server.mod.requireJS;
    var deps = [], fn, exports, mod;

    function interf(name) {
      if (name == "require") return getRequire(data);
      if (name == "exports") return exports || (exports = getExports(data));
      if (name == "module") return mod || (mod = getModuleInterface(data, exports || (exports = getExports(data))));
      return getInterface(name, data);
    }

    if (argNodes && args.length > 1) {
      var node = argNodes[args.length == 2 ? 0 : 1];
      var base = path.relative(server.projectDir, path.dirname(node.sourceFile.name));
      if (node.type == "Literal" && typeof node.value == "string") {
        node.required = interf(path.join(base, node.value), data);
        deps.push(node.required);
      } else if (node.type == "ArrayExpression") for (var i = 0; i < node.elements.length; ++i) {
        var elt = node.elements[i];
        if (elt.type == "Literal" && typeof elt.value == "string") {
          elt.required = interf(path.join(base, elt.value), data);
          deps.push(elt.required);
        }
      }
    } else if (argNodes && args.length == 1 &&
               /FunctionExpression/.test(argNodes[0].type) &&
               argNodes[0].params.length) {
      deps.push(interf("require", data), interf("exports", data), interf("module", data));
      fn = args[0];
    }

    if (!fn) {
      fn = args[Math.min(args.length - 1, 2)];
      if (!fn.isEmpty() && !fn.getFunctionType()) fn = null;
    }

    if (fn) {
      fn.propagate(new infer.IsCallee(infer.ANull, deps, null, out || infer.ANull));
      if (out) out.originNode = fn.originNode;
    } else if (out) {
      args[0].propagate(out)
    }

    return infer.ANull;
  }

  infer.registerFunction("requirejs_define", function(_self, args, argNodes) {
    if (!args.length) return infer.ANull

    var server = infer.cx().parent, data = server.mod.requireJS
    return runModule(server, args, argNodes, getModule(data.currentFile, data))
  });

  infer.registerFunction("requirejs_require", function(_self, args, argNodes) {
    if (!args.length) return infer.ANull
    return runModule(infer.cx().parent, args, argNodes)
  });
  function parseExprNode(node) {
    switch (node.type) {
    case "ArrayExpression":
      return node.elements.map(parseExprNode);
    case "Literal":
      return node.value;
    case "ObjectExpression":
      var obj = {};
      node.properties.forEach(function(prop) {
        var key = prop.key.name || prop.key.value;
        obj[key] = parseExprNode(prop.value);
      });
      return obj;
    }
  }

  infer.registerFunction("requirejs_config", function(_self, _args, argNodes) {
    var server = infer.cx().parent, data = server && server.mod.requireJS;
    if (data && argNodes && argNodes.length && argNodes[0].type == "ObjectExpression") {
      var config = parseExprNode(argNodes[0]);
      for (var key in config) if (config.hasOwnProperty(key)) {
        var value = config[key], exists = data.options[key];
        if (!exists) {
          data.options[key] = value;
        } else if (key == "paths") {
          for (var path in value) if (value.hasOwnProperty(path) && !data.options.paths[path])
            data.options.paths[path] = value[path];
        }
      }
    }
    return infer.ANull;
  });

  function preCondenseReach(state) {
    var interfaces = infer.cx().parent.mod.requireJS.interfaces;
    var rjs = state.roots["!requirejs"] = new infer.Obj(null);
    for (var name in interfaces) {
      var prop = rjs.defProp(name.replace(/\./g, "`"));
      interfaces[name].propagate(prop);
      prop.origin = interfaces[name].origin;
    }
  }

  function postLoadDef(data) {
    var cx = infer.cx(), interfaces = cx.definitions[data["!name"]]["!requirejs"];
    var data = cx.parent.mod.requireJS;
    if (interfaces) for (var name in interfaces.props) {
      interfaces.props[name].propagate(getInterface(name, data));
    }
  }

  tern.registerPlugin("requirejs", function(server, options) {
    server.mod.requireJS = {
      interfaces: Object.create(null),
      options: options || {},
      currentFile: null,
      server: server
    };

    server.on("beforeLoad", function(file) {
      this.mod.requireJS.currentFile = file.name;
    });
    server.on("reset", function() {
      this.mod.requireJS.interfaces = Object.create(null);
      this.mod.requireJS.require = null;
    });

    server.on("preCondenseReach", preCondenseReach)
    server.on("postLoadDef", postLoadDef)
    server.on("typeAt", findTypeAt)
    server.on("completion", findCompletions)

    server.addDefs(defs)
  });

  function findTypeAt(_file, _pos, expr, type) {
    if (!expr || expr.node.type != "Literal" ||
        typeof expr.node.value != "string" || !expr.node.required)
      return type;
    type = Object.create(type);
    var exportedType = expr.node.required;
    type.origin = exportedType.origin;
    type.originNode = exportedType.originNode;
    if (exportedType.doc) type.doc = exportedType.doc
    if (exportedType.url) type.url = exportedType.url
    return type;
  }

  function findCompletions(file, query) {
    var wordEnd = tern.resolvePos(file, query.end);
    var callExpr = infer.findExpressionAround(file.ast, null, wordEnd, file.scope, "CallExpression");
    if (!callExpr) return;
    var callNode = callExpr.node;
    if (callNode.callee.type != "Identifier" ||
        !(callNode.callee.name == "define" || callNode.callee.name == "require" || callNode.callee.name == "requirejs")||
        callNode.arguments.length < 1 || callNode.arguments[0].type != "ArrayExpression") return;
    var argNode = findRequireModule(callNode.arguments[0].elements, wordEnd);
    if (!argNode) return;
    var word = argNode.raw.slice(1, wordEnd - argNode.start), quote = argNode.raw.charAt(0);
    if (word && word.charAt(word.length - 1) == quote)
      word = word.slice(0, word.length - 1);
    var completions = completeModuleName(query, word, file.name);
    if (argNode.end == wordEnd + 1 && file.text.charAt(wordEnd) == quote)
      ++wordEnd;
    return {
      start: tern.outputPos(query, file, argNode.start),
      end: tern.outputPos(query, file, wordEnd),
      isProperty: false,
      isObjectKey: false,
      completions: completions.map(function(rec) {
        var name = typeof rec == "string" ? rec : rec.name;
        var string = JSON.stringify(name);
        if (quote == "'") string = quote + string.slice(1, string.length -1).replace(/'/g, "\\'") + quote;
        if (typeof rec == "string") return string;
        rec.displayName = name;
        rec.name = string;
        return rec;
      })
    };
  }

  function findRequireModule(argsNode, wordEnd) {
    for (var i = 0; i < argsNode.length; i++) {
      var argNode = argsNode[i];
      if (argNode.type == "Literal" && typeof argNode.value == "string" &&
          argNode.start < wordEnd && argNode.end > wordEnd) return argNode;
    }
  }

  function completeModuleName(query, word, parentFile) {
    var cx = infer.cx(), server = cx.parent, data = server.mod.requireJS;
    var currentName = stripJSExt(parentFile);
    var base = data.options.baseURL || "";
    if (base && base.charAt(base.length - 1) != "/") base += "/";

    if (query.caseInsensitive) word = word.toLowerCase();

    var completions = [], modules = data.interfaces;
    for (var name in modules) {
      if (name == currentName || !modules[name].getType()) continue;

      var moduleName = name.substring(base.length, name.length);
      if (moduleName &&
          !(query.filter !== false && word &&
            (query.caseInsensitive ? moduleName.toLowerCase() : moduleName).indexOf(word) !== 0))
        tern.addCompletion(query, completions, moduleName, modules[name]);
    }
    return completions;
  }

  var defs = {
    "!name": "requirejs",
    "!define": {
      module: {
        id: "string",
        uri: "string",
        config: "fn() -> ?"
      },
      config: {
        "!url": "http://requirejs.org/docs/api.html#config",
        baseUrl: {
          "!type": "string",
          "!doc": "the root path to use for all module lookups",
          "!url": "http://requirejs.org/docs/api.html#config-baseUrl"
        },
        paths: {
          "!type": "?",
          "!doc": "path mappings for module names not found directly under baseUrl. The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a '/' or has a URL protocol in it ('like http:').",
          "!url": "http://requirejs.org/docs/api.html#config-paths"
        },
        shim: {
          "!type": "?",
          "!doc": "Configure the dependencies, exports, and custom initialization for older, traditional 'browser globals' scripts that do not use define() to declare the dependencies and set a module value.",
          "!url": "http://requirejs.org/docs/api.html#config-shim"
        },
        map: {
          "!type": "?",
          "!doc": "For the given module prefix, instead of loading the module with the given ID, substitute a different module ID.",
          "!url": "http://requirejs.org/docs/api.html#config-map"
        },
        config: {
          "!type": "?",
          "!doc": "There is a common need to pass configuration info to a module. That configuration info is usually known as part of the application, and there needs to be a way to pass that down to a module. In RequireJS, that is done with the config option for requirejs.config(). Modules can then read that info by asking for the special dependency 'module' and calling module.config().",
          "!url": "http://requirejs.org/docs/api.html#config-moduleconfig"
        },
        packages: {
          "!type": "?",
          "!doc": "configures loading modules from CommonJS packages. See the packages topic for more information.",
          "!url": "http://requirejs.org/docs/api.html#config-packages"
        },
        nodeIdCompat: {
          "!type": "?",
          "!doc": "Node treats module ID example.js and example the same. By default these are two different IDs in RequireJS. If you end up using modules installed from npm, then you may need to set this config value to true to avoid resolution issues.",
          "!url": "http://requirejs.org/docs/api.html#config-nodeIdCompat"
        },
        waitSeconds: {
          "!type": "number",
          "!doc": "The number of seconds to wait before giving up on loading a script. Setting it to 0 disables the timeout. The default is 7 seconds.",
          "!url": "http://requirejs.org/docs/api.html#config-waitSeconds"
        },
        context: {
          "!type": "number",
          "!doc": "A name to give to a loading context. This allows require.js to load multiple versions of modules in a page, as long as each top-level require call specifies a unique context string. To use it correctly, see the Multiversion Support section.",
          "!url": "http://requirejs.org/docs/api.html#config-context"
        },
        deps: {
          "!type": "?",
          "!doc": "An array of dependencies to load. Useful when require is defined as a config object before require.js is loaded, and you want to specify dependencies to load as soon as require() is defined. Using deps is just like doing a require([]) call, but done as soon as the loader has processed the configuration. It does not block any other require() calls from starting their requests for modules, it is just a way to specify some modules to load asynchronously as part of a config block.",
          "!url": "http://requirejs.org/docs/api.html#config-deps"
        },
        callback: {
          "!type": "fn()",
          "!doc": "A function to execute after deps have been loaded. Useful when require is defined as a config object before require.js is loaded, and you want to specify a function to require after the configuration's deps array has been loaded.",
          "!url": "http://requirejs.org/docs/api.html#config-callback"
        },
        enforceDefine: {
          "!type": "bool",
          "!doc": "If set to true, an error will be thrown if a script loads that does not call define() or have a shim exports string value that can be checked. See Catching load failures in IE for more information.",
          "!url": "http://requirejs.org/docs/api.html#config-enforceDefine"
        },
        xhtml: {
          "!type": "bool",
          "!doc": "If set to true, document.createElementNS() will be used to create script elements.",
          "!url": "http://requirejs.org/docs/api.html#config-xhtml"
        },
        urlArgs: {
          "!type": "string",
          "!doc": "Extra query string arguments appended to URLs that RequireJS uses to fetch resources. Most useful to cache bust when the browser or server is not configured correctly.",
          "!url": "http://requirejs.org/docs/api.html#config-urlArgs"
        },
        scriptType: {
          "!type": "string",
          "!doc": "Specify the value for the type='' attribute used for script tags inserted into the document by RequireJS. Default is 'text/javascript'. To use Firefox's JavaScript 1.8 features, use 'text/javascript;version=1.8'.",
          "!url": "http://requirejs.org/docs/api.html#config-scriptType"
        },
        skipDataMain: {
          "!type": "bool",
          "!doc": "Introduced in RequireJS 2.1.9: If set to true, skips the data-main attribute scanning done to start module loading. Useful if RequireJS is embedded in a utility library that may interact with other RequireJS library on the page, and the embedded version should not do data-main loading.",
          "!url": "http://requirejs.org/docs/api.html#config-skipDataMain"
        }
      },
      RequireJSError: {
        "prototype" : {
          "!proto": "Error.prototype",
          "requireType": {
            "!type": "string",
            "!doc": "A string value with a general classification, like 'timeout', 'nodefine', 'scripterror'.",
            "!url": "http://requirejs.org/docs/api.html#errors"
          },
          "requireModules": {
            "!type": "[string]",
            "!doc": "An array of module names/URLs that timed out.",
            "!url": "http://requirejs.org/docs/api.html#errors"
          }
        }
      }
    },
    requirejs: {
      "!type": "fn(deps: [string], callback: fn(), errback?: fn(err: +RequireJSError)) -> !custom:requirejs_require",
      onError: {
        "!type": "fn(err: +RequireJSError)",
        "!doc": "To detect errors that are not caught by local errbacks, you can override requirejs.onError()",
        "!url": "http://requirejs.org/docs/api.html#requirejsonerror"
      },
      load: {
        "!type": "fn(context: ?, moduleName: string, url: string)"
      },
      config: "fn(config: config) -> !custom:requirejs_config",
      version: "string",
      isBrowser: "bool"
    },
    require: "requirejs",
    define: {
      "!type": "fn(deps: [string], callback: fn()) -> !custom:requirejs_define",
      amd: {
        jQuery: "bool"
      }
    }
  };
});

});

define("plugins/c9.ide.language.javascript.tern/worker/tern_worker",[], function(require, exports, module) {
var acornHelper = require("./acorn_helper");
var tern = require("tern/lib/tern");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var handler = module.exports = Object.create(baseLanguageHandler);
var tree = require("treehugger/tree");
var util = require("plugins/c9.ide.language/worker_util");
var completeUtil = require("plugins/c9.ide.language/complete_util");
var filterDocumentation = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util").filterDocumentation;
var getParameterDocs = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util").getParameterDocs;
var architectResolver = null;
var inferCompleter = require("plugins/c9.ide.language.javascript.infer/infer_completer");

var TERN_DEFS = [];
var BUILTIN_PLUGINS = {
    doc_comment: require("tern/plugin/doc_comment"),
    es_modules: require("tern/plugin/es_modules"),
    modules: require("tern/plugin/modules"),
    node: require("tern/plugin/node"),
    node_resolve: require("tern/plugin/node_resolve"),
    requirejs: require("tern/plugin/requirejs"),
    architect_resolver: architectResolver,
};

var ternWorker;
var ternServerOptions = {};
var ternRequestOptions = {};
var fileCache = {};
var dirCache = {};
var firstClassDefs = [];
var lastAddPath;
var lastAddValue;
var lastCacheRead = 0;
var MAX_CACHE_AGE = 60 * 1000 * 10;
var MAX_FILE_SIZE = 200 * 1024;
var PRIORITY_DEFAULT = 5;
var PRIORITY_LIBRARY_GLOBAL = 0;
function mix() {
    var arg, prop, child = {};
    for (arg = 0; arg < arguments.length; arg += 1) {
        if (!arguments[arg]) {
            continue;
        }
        for (prop in arguments[arg]) {
            if (arguments[arg].hasOwnProperty(prop)) {
                child[prop] = arguments[arg][prop];
            }
        }
    }
    return child;
}


handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.getCompletionRegex = function() {
    return (/^[\.]$/);
};

handler.getMaxFileSizeSupported = function() {
    return .25 * 10 * 1000 * 80;
};

handler.$recacheCompletionLength = 3;

handler.init = function(callback) {
    initTern();
    inferCompleter.setExtraModules(ternWorker.cx.definitions.node);

    ternWorker.on("beforeLoad", function(e) {
        var file = e.name;
        var dir = dirname(e.name);

        if (dir[0] != "/")
            return;

        if (!dirCache[dir])
            util.$watchDir(dir, handler);

        fileCache[file] = fileCache[file] || {};
        dirCache[dir] = dirCache[dir] || {};
        dirCache[dir].used = Date.now();
        dirCache[dir][file] = true;
        lastCacheRead = Date.now();
    });

    handler.sender.on("tern_set_def_enabled", function(e) {
        setDefEnabled(e.data.name, e.data.def, e.data.enabled, e.data.options);
    });

    handler.sender.on("tern_set_server_options", function(e) {
        setOptions(e.data);
    });

    handler.sender.on("tern_set_request_options", function(e) {
        if (e.data) {
            ternRequestOptions = e.data;
        }
    });

    handler.sender.on("tern_get_plugins", function(e) {
        var pluginName;
        var plugins = [];
        var pluginToList;
        for (pluginName in ternWorker.options.plugins) {
            pluginToList = {
                name: pluginName,
                enabled: ternWorker.options.plugins[pluginName]
            };
            plugins.push(pluginToList);
        }
        handler.sender.emit("tern_read_plugins", plugins);
    });

    handler.sender.on("tern_update_plugins", function(e) {
        updatePlugins(e.data);
    });

    util.$onWatchDirChange(onWatchDirChange);
    setInterval(garbageCollect, 60000);
    callback();
};

function initTern() {
    ternWorker = new tern.Server({
        async: ternServerOptions.async !== undefined ? ternServerOptions.async : true,
        defs: ternServerOptions.defs !== undefined ? ternServerOptions.defs : TERN_DEFS,
        plugins: ternServerOptions.plugins !== undefined ? ternServerOptions.plugins : {},
        dependencyBudget: ternServerOptions.dependencyBudget !== undefined ? ternServerOptions.dependencyBudget : MAX_FILE_SIZE,
        reuseInstances: ternServerOptions.reuseInstances !== undefined ? ternServerOptions.reuseInstances : true,
        normalizeFilename: function(file) {
            if (file[0] != "/")
                file = "/" + file;
            if (!file.match(/[\/\\][^/\\]*\.[^/\\]*$/))
                file += ".js";
            return file;
        },
        getFile: ternServerOptions.getFile !== undefined ? ternServerOptions.getFile : function(file, callback) {
            if (file == handler.path)
                return done(null, handler.doc.getValue());

            util.stat(file, function(err, stat) {
                if (stat && stat.size > MAX_FILE_SIZE) {
                    err = new Error("File is too large to include");
                    err.code = "ESIZE";
                }

                if (err)
                    return done(err);

                fileCache[file] = fileCache[file] || {};
                fileCache[file].mtime = stat.mtime;

                util.readFile(file, { allowUnsaved: true }, function(err, data) {
                    if (err) return done(err);

                    lastAddPath = null; // invalidate cache
                    done(null, data);
                });
            });

            function done(err, result) {
                try {
                    callback(err, result);
                }
                catch (err) {
                    console.error(err.stack);
                }
            }
        }
    });
}

var setOptions = module.exports.setOptions = function(options) {
    for (var o in options) {
        ternWorker.options[o] = ternServerOptions[o] = options[o];
    }
};
var updatePlugins = module.exports.updatePlugins = function(plugins) {
    var requiresReset = false;
    for (var p in plugins) {
        var targetPlugin = plugins[p];
        var plugin = ternWorker.options.plugins[targetPlugin.name];
        if (targetPlugin.name == "angular")
            continue;
        if (targetPlugin.firstClass)
            firstClassDefs.push(targetPlugin.name);
        if (typeof plugin === "undefined" && typeof targetPlugin.path === "string") {
            var loaded = require(targetPlugin.path);
            if (!loaded) {
                console.error("Could not load", targetPlugin.path);
                continue;
            }
            
            ternServerOptions.plugins = ternServerOptions.plugins || {};
            ternServerOptions.plugins[targetPlugin.name] = targetPlugin.enabled;

            if (targetPlugin.name === "architect_resolver")
                architectResolver = loaded;

            requiresReset = true;
        }
        else {
            if (plugin !== targetPlugin.enabled) {
                ternServerOptions.plugins = ternServerOptions.plugins || {};
                ternServerOptions.plugins[targetPlugin.name] = targetPlugin.enabled;
                requiresReset = true;
            }
        }
    }
    if (requiresReset)
        initTern();
    ternWorker.defs.forEach(function(d) {
        if (d["!name"] === "node")
            delete d.console;
    });
};

function onWatchDirChange(e) {
    var dir = e.data.path.replace(/\/?$/, "/");
    e.data.files.forEach(function(stat) {
        var file = dir + stat.name;
        if (!fileCache[file] || fileCache[file].mtime >= stat.mtime)
            return;
        ternWorker.delFile(file);
        delete fileCache[file];
        lastAddPath = null; // invalidate local file cache
    });
}

function garbageCollect() {
    var minAge = lastCacheRead - MAX_CACHE_AGE;

    for (var file in fileCache) {
        if (fileCache[file].used < minAge) {
            ternWorker.delFile(file);
            delete fileCache[file];
            if (lastAddPath === file)
                lastAddPath = null;
        }
    }

    for (var dir in dirCache) {
        if (dirCache[dir].used < minAge) {
            handler.sender.emit("unwatchDir", { path: dir });
            delete dirCache[file];
        }
    }
}

handler.onDocumentOpen = function(path, doc, oldPath, callback) {
    setJSXMode(path);
    callback();
};

handler.analyze = function(value, ast, options, callback) {
    if (fileCache[this.path])
        return callback();
    fileCache[this.path] = {
        mtime: 0, // prefer reloading since we may be unsaved
        used: Date.now()
    };
    addTernFile(this.path, value);

    if (!architectResolver)
        return callback();

    architectResolver.onceReady(function() {
        handler.$flush(function(err) {
            if (err) console.error(err.stack || err);
            callback();
        });
    });
};

handler.complete = function(doc, fullAst, pos, options, callback) {
    var node = options.node;
    if (!node ||
        ["FArg", "Function", "Arrow", "VarDecl", "VarDeclInit", "ConstDecl", "ConstDeclInit",
        "LetDecl", "LetDeclInit", "PropertyInit", "Label", "String"].indexOf(node.cons) > -1)
        return callback();

    addTernFile(this.path, doc.getValue());

    var line = doc.getLine(pos.row);
    var prefix = util.getPrecedingIdentifier(line, pos.column);
    var defaultOptions = {
        type: "completions",
        pos: pos,
        types: true,
        origins: true,
        docs: true,
        urls: true,
        guess: true,
        caseInsensitive: false,
    };
    var ternOptions = mix(defaultOptions, ternRequestOptions[defaultOptions.type]);
    handler.$request(ternOptions, function(err, result) {
        if (err) {
            console.error(err.stack || err);
            return callback();
        }

        callback(result.completions.map(function(match) {
            if (match.guess && match.type && match.type !== "fn()?)")
               return;
            if (match.type === "?")
                delete match.type;

            var isContextual = node.cons === "PropAccess" && !match.guess;

            if (!isContextual && match.origin === "browser" && prefix.length < 3)
                return; // skip completions like onchange (from window.onchange)

            var isFromLibrary = match.origin && match.origin[0] !== "/" && firstClassDefs.indexOf(match.origin) === -1;
            var priority = PRIORITY_DEFAULT;
            var icon = getIcon(match, priority);
            if (match.name[0] === '"') {
                if (match.origin !== "node")
                    return;
                match.name = match.name.replace(/"(.*)"/, "$1");
                icon = "package";
            }

            var isFunction = match.type && match.type.match(/^fn\(/);
            var isAnonymous = match.type && match.type.match(/^{/);
            var fullName;
            var fullNameTyped;
            if (isFunction) {
                var sig = getSignature(match);
                var parameters = sig.parameters;
                fullName = match.name + "(" + parameters.map(function(p) {
                    return p.name;
                }).join(", ") + ")";
                fullNameTyped = match.name + "(" + parameters.map(function(p) {
                    return p.name + (p.type ? " : " + p.type : "");
                }).join(", ") + ")";
                if (sig.returnType)
                    fullNameTyped = fullNameTyped + " : " + sig.returnType;
            }
            else {
                fullName = fullNameTyped = match.name;
                if (match.type)
                    fullNameTyped = fullNameTyped + " : " + match.type;
            }

            var doc = (match.type && !isFunction && !isAnonymous ? "Type: " + match.type + "<p>" : "")
                    + (match.doc ? filterDocumentation(match.doc) : "");
            if (match.doc === "Every function in JavaScript is actually a Function object.")
                doc = "";
            return {
                id: match.name,
                name: fullName,
                replaceText: match.name + (isFunction ? "(^^)" : ""),
                icon: icon,
                priority: priority,
                isContextual: isContextual,
                docHead: fullNameTyped,
                doc: (match.origin && isFromLibrary ? "Origin: " + match.origin + "<p>" : "") + doc,
                docUrl: match.url,
                isFunction: isFunction,
                url: match.url
            };
        }).filter(function(c) {
            return c;
        }));
    });
};

handler.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    addTernFile(this.path, doc.getValue());
    var defaultOptions = {
        type: "definition",
        pos: pos,
        types: true,
        origins: true,
        docs: true,
        urls: true,
        caseInsensitive: false,
    };
    var ternOptions = mix(defaultOptions, ternRequestOptions[defaultOptions.type]);
    this.$request(ternOptions, function(err, result) {
        if (err) {
            console.error(err.stack || err);
            return callback();
        }
        if (!result.file)
            return callback();
        if (!result.file.match(/[\/\\][^/\\]*\.[^/\\]*$/))
            result.file += ".js";
        callback({
            path: result.file,
            row: result.start.line,
            column: result.start.ch,
            icon: getIcon(result, PRIORITY_DEFAULT)
        });
    });
};

handler.tooltip = function(doc, fullAst, cursorPos, options, callback) {
    var node = options.node;
    if (!node)
        return callback();
    var argIndex = -1;

    var callNode = getCallNode(node, cursorPos);
    var displayPos;

    if (callNode) {
        var argPos = { row: callNode[1].getPos().sl, column: callNode[1].getPos().sc };
        if (argPos.row >= 9999999999)
            argPos = cursorPos;

        var endLine = callNode.getPos().el;
        if (callNode[1].length && callNode[1].getPos().el !== callNode.getPos().el)
            endLine--; // put tooltip near end of arguments, not end of call
        displayPos = { row: endLine, column: callNode[1].getPos().sc };
        argIndex = this.getArgIndex(callNode, doc, cursorPos);
    }
    else if (node.isMatch('Var(_)')) {
        displayPos = { row: node.getPos().sl, column: node.getPos().sc };
        argIndex = -1;
        if (cursorPos.column === node.getPos().ec)
            return callback();
    }
    else {
        return callback();
    }

    if (argIndex === -1 && callNode)
        return callback();

    if (!callNode)
        return callback(); // TODO: support this case??

    addTernFile(this.path, doc.getValue());
    var defaultOptions = {
        type: "type",
        pos: { row: callNode[0].getPos().el, column: callNode[0].getPos().ec },
        types: true,
        origins: true,
        docs: true,
        urls: true,
        caseInsensitive: false,
        preferFunction: true,
    };
    var ternOptions = mix(defaultOptions, ternRequestOptions[defaultOptions.type]);
    this.$request(ternOptions, function(err, result) {
        if (err) {
            console.error(err.stack || err);
            return callback();
        }
        if (!result.type || !result.name || !result.type.match(/^fn\(/))
            return callback();

        var rangeNode = callNode && callNode.getPos().sc < 99999 ? callNode : node;
        var sig = getSignature(result);
        if (sig.parameters[argIndex])
            sig.parameters[argIndex].active = true;

        var parameterDocs = getParameterDocs(result.doc);
        sig.parameters.forEach(function(p) {
            if (p.type === "?")
                delete p.type;
            if (parameterDocs["_" + p.name])
                p.docHtml = parameterDocs["_" + p.name];
        });
        if (sig.returnType === "?")
            delete sig.returnType;
        if (sig.returnType === "[]")
            sig.returnType = "Array";

        callback({
            hint: {
                signatures: [{
                    name: result.name.replace(/.*\./, ""),
                    docHtml: result.doc && result.doc.replace(/^\* /g, ""),
                    parameters: sig.parameters,
                    returnType: sig.returnType
                }],
            },
            displayPos: displayPos,
            pos: rangeNode.getPos()
        });
    });
};
handler.getArgIndex = function(node, doc, cursorPos) {
    var cursorTreePos = { line: cursorPos.row, col: cursorPos.column };
    var result = -1;
    node.rewrite(
        'Call(e, args)', "New(e, args)", function(b) {
            result = -1;
            var line = doc.getLine(cursorPos.row);
            if (line[b.args.getPos().ec + 1] && line[b.args.getPos().ec + 1].match(/[ ,]/))
                b.args.getPos().ec++;

            if (b.args.length === 0 && this.getPos().ec - 1 === cursorPos.column) {
                result = 0;
            }
            else if (b.args.length === 0 && line.substr(cursorPos.column).match(/^\s*\)/)) {
                result = 0;
            }
            else if (!tree.inRange(this.getPos(), cursorTreePos, true)) {
                return this;
            }
            else if (cursorPos.row === this.getPos().sl && line.substr(0, cursorPos.column + 1).match(/,\s*\)$/)) {
                result = b.args.length;
                return this;
            }
            for (var i = 0; i < b.args.length; i++) {
                if (b.args[i].cons === "ERROR" && result === -1) {
                    result = i;
                    break;
                }
                b.args[i].traverseTopDown(function() {
                    var pos = this.getPos();
                    if (this === node) {
                        result = i;
                        return this;
                    }
                    else if (pos && pos.sl <= cursorPos.row && pos.sc <= cursorPos.column) {
                        if (pos.sl === cursorPos.row && pos.ec === cursorPos.column - 1 && line[pos.ec] === ")")
                            return result = -1;
                        result = i;
                    }
                });
            }
            return this;
        }
    );
    return result;
};

function getCallNode(currentNode, cursorPos) {
    var result;
    var previous;
    currentNode.traverseUp(
        'Call(e, args)', 'New(e, args)', function(b, node) {
            if (b.e === previous)
                return;
            result = node;
            return node;
        },
        'Function(x, args, body)', 'Arrow(args, body)', function(b, node) {
            if (node !== currentNode)
                return node;
            previous = node;
        },
        'PropertyInit(x, _)', 'Method(x, body)', function(b, node) {
            return node;
        },
        function(node) {
            previous = node;
        }
    );
    return result;
}

function getIcon(property, priority) {
    if (property.guess || !property.type || property.type === "fn()?") {
        return property.type ? "method2" : "property2";
    }
    else if (property.type.match(/^fn\(/)) {
        return priority ? "method" : "method2";
    }
    else {
        return priority ? "property" : "property2";
    }
}

function addTernFile(path, value) {
    if (lastAddPath === path && lastAddValue === value)
        return;
    lastAddPath = path;
    lastAddValue = value;
    setJSXMode(path);
    ternWorker.addFile(path, value);
}

function dirname(path) {
    return path.replace(/[\/\\][^\/\\]*$/, "");
}
function getSignature(property) {
    if (!property.type || !property.type.match(/^fn\(/))
        return { parameters: []};
    var sig = property.type;
    var parameters = [{ name: "", type: "" }];
    var parameterIndex = 0;
    var returnType = "";
    var depth = 0;
    var inType = false;
    var inReturn = false;
    for (var i = "fn(".length; i < sig.length; i++) {
        switch (sig[i]) {
            case "(": case "{":
                depth++; break;
            case ")": case "}":
                depth--; break;
            case ":":
                inType = true; break;
            case ",":
                if (depth)
                    break;
                inType = false;
                parameters.push({ name: "", type: "" });
                parameterIndex++;
                break;
            case " ":
                break;
            case "-": // ->
                if (depth >= 0)
                    break;
                i++;
                depth++;
                inType = false;
                inReturn = true;
                break;
            case "?":
                if (!depth && inType && parameters[parameterIndex].type)
                    parameters[parameterIndex].name = "[" + parameters[parameterIndex].name + "]";
                break;
            default:
                if (sig[i] === "]")
                    depth--;
                if (!depth && inReturn)
                    returnType += sig[i];
                else if (!depth && !inType)
                    parameters[parameterIndex].name += sig[i];
                else if (!depth && inType)
                    parameters[parameterIndex].type += sig[i];
                if (sig[i] === "[")
                    depth++;
        }
    }

    parameters.forEach(function(p) {
        if (p.type === "?")
            delete p.type;
        if (p.type === "[]")
            p.type = "Array";
        if (p.type)
            p.type = p.type.replace(/\.prototype$/, "").replace(/.*\./, "");
    });


    if (parameters[0].name === "")
        parameters.shift();

    return {
        parameters: parameters,
        returnType: returnType && returnType.replace(/\.prototype$/, "").replace(/.*\./, "")
    };
}

handler.$request = function(query, callback) {
    query.file = this.path;
    setJSXMode(this.path);

    if (query.pos)
        query.end = query.start = {
            line: query.pos.row || query.pos.sl || 0,
            ch: query.pos.column || query.pos.sc || 0
        };
    query.lineCharPositions = true;

    try {
        ternWorker.request(
            {
                query: query,
            },
            done
        );
    }
    catch (err) {
        if (isDone) throw err;
        return done(err);
    }

    var isDone;
    function done(err, result) {
        isDone = true;
        callback(err, result);
    }
};

handler.$flush = function(callback) {
    try {
        ternWorker.flush(done);
    }
    catch (err) {
        if (isDone) throw err;
        return done(err);
    }

    var isDone;
    function done(err, result) {
        isDone = true;
        callback(err, result);
    }
};
function setDefEnabled(name, def, enabled, options) {
    if (options && options.firstClass)
        firstClassDefs.push(name);
    
    var i;
    if (!enabled) {
        ternWorker.defs = ternWorker.defs.filter(function(d) {
            return d["!name"] !== name;
        });
        ternWorker.reset();
        ternServerOptions.defs = ternWorker.defs;
        return;
    }

    var defs = def instanceof Array ? def : [def];
    var downloaded = 0;
    defs.forEach(function(def) {
        if (typeof def !== "string") {
            ternWorker.defs.push(def);
            return checkDone();
        }
            
        completeUtil.fetchText(def, function(err, result) {
            if (err) console.error(err);
            try {
                result = JSON.parse(result);
            }
            catch (err) {
                console.error(err);
                result = null;
            }

            ternWorker.defs.push(result);
            checkDone();
        });
    });
    function checkDone() {
        if (++downloaded < defs.length)
            return;
        ternServerOptions.defs = ternWorker.defs;
        ternWorker.reset();
    }
}

function setJSXMode(path) {
    acornHelper.setLanguage(/\.jsx$/.test(path) ? "jsx" : null);
}

});

define("ace/mode/css/csslint",[], function(require, exports, module) {
var parserlib = {};
(function(){
function EventTarget(){
    this._listeners = {};
}

EventTarget.prototype = {
    constructor: EventTarget,
    addListener: function(type, listener){
        if (!this._listeners[type]){
            this._listeners[type] = [];
        }

        this._listeners[type].push(listener);
    },
    fire: function(event){
        if (typeof event == "string"){
            event = { type: event };
        }
        if (typeof event.target != "undefined"){
            event.target = this;
        }

        if (typeof event.type == "undefined"){
            throw new Error("Event object missing 'type' property.");
        }

        if (this._listeners[event.type]){
            var listeners = this._listeners[event.type].concat();
            for (var i=0, len=listeners.length; i < len; i++){
                listeners[i].call(this, event);
            }
        }
    },
    removeListener: function(type, listener){
        if (this._listeners[type]){
            var listeners = this._listeners[type];
            for (var i=0, len=listeners.length; i < len; i++){
                if (listeners[i] === listener){
                    listeners.splice(i, 1);
                    break;
                }
            }


        }
    }
};
function StringReader(text){
    this._input = text.replace(/\n\r?/g, "\n");
    this._line = 1;
    this._col = 1;
    this._cursor = 0;
}

StringReader.prototype = {
    constructor: StringReader,
    getCol: function(){
        return this._col;
    },
    getLine: function(){
        return this._line ;
    },
    eof: function(){
        return (this._cursor == this._input.length);
    },
    peek: function(count){
        var c = null;
        count = (typeof count == "undefined" ? 1 : count);
        if (this._cursor < this._input.length){
            c = this._input.charAt(this._cursor + count - 1);
        }

        return c;
    },
    read: function(){
        var c = null;
        if (this._cursor < this._input.length){
            if (this._input.charAt(this._cursor) == "\n"){
                this._line++;
                this._col=1;
            } else {
                this._col++;
            }
            c = this._input.charAt(this._cursor++);
        }

        return c;
    },
    mark: function(){
        this._bookmark = {
            cursor: this._cursor,
            line:   this._line,
            col:    this._col
        };
    },

    reset: function(){
        if (this._bookmark){
            this._cursor = this._bookmark.cursor;
            this._line = this._bookmark.line;
            this._col = this._bookmark.col;
            delete this._bookmark;
        }
    },
    readTo: function(pattern){

        var buffer = "",
            c;
        while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) != buffer.length - pattern.length){
            c = this.read();
            if (c){
                buffer += c;
            } else {
                throw new Error("Expected \"" + pattern + "\" at line " + this._line  + ", col " + this._col + ".");
            }
        }

        return buffer;

    },
    readWhile: function(filter){

        var buffer = "",
            c = this.read();

        while(c !== null && filter(c)){
            buffer += c;
            c = this.read();
        }

        return buffer;

    },
    readMatch: function(matcher){

        var source = this._input.substring(this._cursor),
            value = null;
        if (typeof matcher == "string"){
            if (source.indexOf(matcher) === 0){
                value = this.readCount(matcher.length);
            }
        } else if (matcher instanceof RegExp){
            if (matcher.test(source)){
                value = this.readCount(RegExp.lastMatch.length);
            }
        }

        return value;
    },
    readCount: function(count){
        var buffer = "";

        while(count--){
            buffer += this.read();
        }

        return buffer;
    }

};
function SyntaxError(message, line, col){
    this.col = col;
    this.line = line;
    this.message = message;

}
SyntaxError.prototype = new Error();
function SyntaxUnit(text, line, col, type){
    this.col = col;
    this.line = line;
    this.text = text;
    this.type = type;
}
SyntaxUnit.fromToken = function(token){
    return new SyntaxUnit(token.value, token.startLine, token.startCol);
};

SyntaxUnit.prototype = {
    constructor: SyntaxUnit,
    valueOf: function(){
        return this.text;
    },
    toString: function(){
        return this.text;
    }

};
function TokenStreamBase(input, tokenData){
    this._reader = input ? new StringReader(input.toString()) : null;
    this._token = null;
    this._tokenData = tokenData;
    this._lt = [];
    this._ltIndex = 0;

    this._ltIndexCache = [];
}
TokenStreamBase.createTokenData = function(tokens){

    var nameMap     = [],
        typeMap     = {},
        tokenData     = tokens.concat([]),
        i            = 0,
        len            = tokenData.length+1;

    tokenData.UNKNOWN = -1;
    tokenData.unshift({name:"EOF"});

    for (; i < len; i++){
        nameMap.push(tokenData[i].name);
        tokenData[tokenData[i].name] = i;
        if (tokenData[i].text){
            typeMap[tokenData[i].text] = i;
        }
    }

    tokenData.name = function(tt){
        return nameMap[tt];
    };

    tokenData.type = function(c){
        return typeMap[c];
    };

    return tokenData;
};

TokenStreamBase.prototype = {
    constructor: TokenStreamBase,
    match: function(tokenTypes, channel){
        if (!(tokenTypes instanceof Array)){
            tokenTypes = [tokenTypes];
        }

        var tt  = this.get(channel),
            i   = 0,
            len = tokenTypes.length;

        while(i < len){
            if (tt == tokenTypes[i++]){
                return true;
            }
        }
        this.unget();
        return false;
    },
    mustMatch: function(tokenTypes, channel){

        var token;
        if (!(tokenTypes instanceof Array)){
            tokenTypes = [tokenTypes];
        }

        if (!this.match.apply(this, arguments)){
            token = this.LT(1);
            throw new SyntaxError("Expected " + this._tokenData[tokenTypes[0]].name +
                " at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
        }
    },
    advance: function(tokenTypes, channel){

        while(this.LA(0) !== 0 && !this.match(tokenTypes, channel)){
            this.get();
        }

        return this.LA(0);
    },
    get: function(channel){

        var tokenInfo   = this._tokenData,
            reader      = this._reader,
            value,
            i           =0,
            len         = tokenInfo.length,
            found       = false,
            token,
            info;
        if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length){

            i++;
            this._token = this._lt[this._ltIndex++];
            info = tokenInfo[this._token.type];
            while((info.channel !== undefined && channel !== info.channel) &&
                    this._ltIndex < this._lt.length){
                this._token = this._lt[this._ltIndex++];
                info = tokenInfo[this._token.type];
                i++;
            }
            if ((info.channel === undefined || channel === info.channel) &&
                    this._ltIndex <= this._lt.length){
                this._ltIndexCache.push(i);
                return this._token.type;
            }
        }
        token = this._getToken();
        if (token.type > -1 && !tokenInfo[token.type].hide){
            token.channel = tokenInfo[token.type].channel;
            this._token = token;
            this._lt.push(token);
            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);
            if (this._lt.length > 5){
                this._lt.shift();
            }
            if (this._ltIndexCache.length > 5){
                this._ltIndexCache.shift();
            }
            this._ltIndex = this._lt.length;
        }
        info = tokenInfo[token.type];
        if (info &&
                (info.hide ||
                (info.channel !== undefined && channel !== info.channel))){
            return this.get(channel);
        } else {
            return token.type;
        }
    },
    LA: function(index){
        var total = index,
            tt;
        if (index > 0){
            if (index > 5){
                throw new Error("Too much lookahead.");
            }
            while(total){
                tt = this.get();
                total--;
            }
            while(total < index){
                this.unget();
                total++;
            }
        } else if (index < 0){

            if(this._lt[this._ltIndex+index]){
                tt = this._lt[this._ltIndex+index].type;
            } else {
                throw new Error("Too much lookbehind.");
            }

        } else {
            tt = this._token.type;
        }

        return tt;

    },
    LT: function(index){
        this.LA(index);
        return this._lt[this._ltIndex+index-1];
    },
    peek: function(){
        return this.LA(1);
    },
    token: function(){
        return this._token;
    },
    tokenName: function(tokenType){
        if (tokenType < 0 || tokenType > this._tokenData.length){
            return "UNKNOWN_TOKEN";
        } else {
            return this._tokenData[tokenType].name;
        }
    },
    tokenType: function(tokenName){
        return this._tokenData[tokenName] || -1;
    },
    unget: function(){
        if (this._ltIndexCache.length){
            this._ltIndex -= this._ltIndexCache.pop();//--;
            this._token = this._lt[this._ltIndex - 1];
        } else {
            throw new Error("Too much lookahead.");
        }
    }

};


parserlib.util = {
StringReader: StringReader,
SyntaxError : SyntaxError,
SyntaxUnit  : SyntaxUnit,
EventTarget : EventTarget,
TokenStreamBase : TokenStreamBase
};
})();
(function(){
var EventTarget = parserlib.util.EventTarget,
TokenStreamBase = parserlib.util.TokenStreamBase,
StringReader = parserlib.util.StringReader,
SyntaxError = parserlib.util.SyntaxError,
SyntaxUnit  = parserlib.util.SyntaxUnit;

var Colors = {
    aliceblue       :"#f0f8ff",
    antiquewhite    :"#faebd7",
    aqua            :"#00ffff",
    aquamarine      :"#7fffd4",
    azure           :"#f0ffff",
    beige           :"#f5f5dc",
    bisque          :"#ffe4c4",
    black           :"#000000",
    blanchedalmond  :"#ffebcd",
    blue            :"#0000ff",
    blueviolet      :"#8a2be2",
    brown           :"#a52a2a",
    burlywood       :"#deb887",
    cadetblue       :"#5f9ea0",
    chartreuse      :"#7fff00",
    chocolate       :"#d2691e",
    coral           :"#ff7f50",
    cornflowerblue  :"#6495ed",
    cornsilk        :"#fff8dc",
    crimson         :"#dc143c",
    cyan            :"#00ffff",
    darkblue        :"#00008b",
    darkcyan        :"#008b8b",
    darkgoldenrod   :"#b8860b",
    darkgray        :"#a9a9a9",
    darkgrey        :"#a9a9a9",
    darkgreen       :"#006400",
    darkkhaki       :"#bdb76b",
    darkmagenta     :"#8b008b",
    darkolivegreen  :"#556b2f",
    darkorange      :"#ff8c00",
    darkorchid      :"#9932cc",
    darkred         :"#8b0000",
    darksalmon      :"#e9967a",
    darkseagreen    :"#8fbc8f",
    darkslateblue   :"#483d8b",
    darkslategray   :"#2f4f4f",
    darkslategrey   :"#2f4f4f",
    darkturquoise   :"#00ced1",
    darkviolet      :"#9400d3",
    deeppink        :"#ff1493",
    deepskyblue     :"#00bfff",
    dimgray         :"#696969",
    dimgrey         :"#696969",
    dodgerblue      :"#1e90ff",
    firebrick       :"#b22222",
    floralwhite     :"#fffaf0",
    forestgreen     :"#228b22",
    fuchsia         :"#ff00ff",
    gainsboro       :"#dcdcdc",
    ghostwhite      :"#f8f8ff",
    gold            :"#ffd700",
    goldenrod       :"#daa520",
    gray            :"#808080",
    grey            :"#808080",
    green           :"#008000",
    greenyellow     :"#adff2f",
    honeydew        :"#f0fff0",
    hotpink         :"#ff69b4",
    indianred       :"#cd5c5c",
    indigo          :"#4b0082",
    ivory           :"#fffff0",
    khaki           :"#f0e68c",
    lavender        :"#e6e6fa",
    lavenderblush   :"#fff0f5",
    lawngreen       :"#7cfc00",
    lemonchiffon    :"#fffacd",
    lightblue       :"#add8e6",
    lightcoral      :"#f08080",
    lightcyan       :"#e0ffff",
    lightgoldenrodyellow  :"#fafad2",
    lightgray       :"#d3d3d3",
    lightgrey       :"#d3d3d3",
    lightgreen      :"#90ee90",
    lightpink       :"#ffb6c1",
    lightsalmon     :"#ffa07a",
    lightseagreen   :"#20b2aa",
    lightskyblue    :"#87cefa",
    lightslategray  :"#778899",
    lightslategrey  :"#778899",
    lightsteelblue  :"#b0c4de",
    lightyellow     :"#ffffe0",
    lime            :"#00ff00",
    limegreen       :"#32cd32",
    linen           :"#faf0e6",
    magenta         :"#ff00ff",
    maroon          :"#800000",
    mediumaquamarine:"#66cdaa",
    mediumblue      :"#0000cd",
    mediumorchid    :"#ba55d3",
    mediumpurple    :"#9370d8",
    mediumseagreen  :"#3cb371",
    mediumslateblue :"#7b68ee",
    mediumspringgreen   :"#00fa9a",
    mediumturquoise :"#48d1cc",
    mediumvioletred :"#c71585",
    midnightblue    :"#191970",
    mintcream       :"#f5fffa",
    mistyrose       :"#ffe4e1",
    moccasin        :"#ffe4b5",
    navajowhite     :"#ffdead",
    navy            :"#000080",
    oldlace         :"#fdf5e6",
    olive           :"#808000",
    olivedrab       :"#6b8e23",
    orange          :"#ffa500",
    orangered       :"#ff4500",
    orchid          :"#da70d6",
    palegoldenrod   :"#eee8aa",
    palegreen       :"#98fb98",
    paleturquoise   :"#afeeee",
    palevioletred   :"#d87093",
    papayawhip      :"#ffefd5",
    peachpuff       :"#ffdab9",
    peru            :"#cd853f",
    pink            :"#ffc0cb",
    plum            :"#dda0dd",
    powderblue      :"#b0e0e6",
    purple          :"#800080",
    red             :"#ff0000",
    rosybrown       :"#bc8f8f",
    royalblue       :"#4169e1",
    saddlebrown     :"#8b4513",
    salmon          :"#fa8072",
    sandybrown      :"#f4a460",
    seagreen        :"#2e8b57",
    seashell        :"#fff5ee",
    sienna          :"#a0522d",
    silver          :"#c0c0c0",
    skyblue         :"#87ceeb",
    slateblue       :"#6a5acd",
    slategray       :"#708090",
    slategrey       :"#708090",
    snow            :"#fffafa",
    springgreen     :"#00ff7f",
    steelblue       :"#4682b4",
    tan             :"#d2b48c",
    teal            :"#008080",
    thistle         :"#d8bfd8",
    tomato          :"#ff6347",
    turquoise       :"#40e0d0",
    violet          :"#ee82ee",
    wheat           :"#f5deb3",
    white           :"#ffffff",
    whitesmoke      :"#f5f5f5",
    yellow          :"#ffff00",
    yellowgreen     :"#9acd32",
    activeBorder        :"Active window border.",
    activecaption       :"Active window caption.",
    appworkspace        :"Background color of multiple document interface.",
    background          :"Desktop background.",
    buttonface          :"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonhighlight     :"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonshadow        :"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttontext          :"Text on push buttons.",
    captiontext         :"Text in caption, size box, and scrollbar arrow box.",
    graytext            :"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.",
    greytext            :"Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.",
    highlight           :"Item(s) selected in a control.",
    highlighttext       :"Text of item(s) selected in a control.",
    inactiveborder      :"Inactive window border.",
    inactivecaption     :"Inactive window caption.",
    inactivecaptiontext :"Color of text in an inactive caption.",
    infobackground      :"Background color for tooltip controls.",
    infotext            :"Text color for tooltip controls.",
    menu                :"Menu background.",
    menutext            :"Text in menus.",
    scrollbar           :"Scroll bar gray area.",
    threeddarkshadow    :"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedface          :"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedhighlight     :"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedlightshadow   :"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedshadow        :"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    window              :"Window background.",
    windowframe         :"Window frame.",
    windowtext          :"Text in windows."
};
function Combinator(text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);
    this.type = "unknown";
    if (/^\s+$/.test(text)){
        this.type = "descendant";
    } else if (text == ">"){
        this.type = "child";
    } else if (text == "+"){
        this.type = "adjacent-sibling";
    } else if (text == "~"){
        this.type = "sibling";
    }

}

Combinator.prototype = new SyntaxUnit();
Combinator.prototype.constructor = Combinator;
function MediaFeature(name, value){

    SyntaxUnit.call(this, "(" + name + (value !== null ? ":" + value : "") + ")", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);
    this.name = name;
    this.value = value;
}

MediaFeature.prototype = new SyntaxUnit();
MediaFeature.prototype.constructor = MediaFeature;
function MediaQuery(modifier, mediaType, features, line, col){

    SyntaxUnit.call(this, (modifier ? modifier + " ": "") + (mediaType ? mediaType : "") + (mediaType && features.length > 0 ? " and " : "") + features.join(" and "), line, col, Parser.MEDIA_QUERY_TYPE);
    this.modifier = modifier;
    this.mediaType = mediaType;
    this.features = features;

}

MediaQuery.prototype = new SyntaxUnit();
MediaQuery.prototype.constructor = MediaQuery;
function Parser(options){
    EventTarget.call(this);


    this.options = options || {};

    this._tokenStream = null;
}
Parser.DEFAULT_TYPE = 0;
Parser.COMBINATOR_TYPE = 1;
Parser.MEDIA_FEATURE_TYPE = 2;
Parser.MEDIA_QUERY_TYPE = 3;
Parser.PROPERTY_NAME_TYPE = 4;
Parser.PROPERTY_VALUE_TYPE = 5;
Parser.PROPERTY_VALUE_PART_TYPE = 6;
Parser.SELECTOR_TYPE = 7;
Parser.SELECTOR_PART_TYPE = 8;
Parser.SELECTOR_SUB_PART_TYPE = 9;

Parser.prototype = function(){

    var proto = new EventTarget(),  //new prototype
        prop,
        additions =  {
            constructor: Parser,
            DEFAULT_TYPE : 0,
            COMBINATOR_TYPE : 1,
            MEDIA_FEATURE_TYPE : 2,
            MEDIA_QUERY_TYPE : 3,
            PROPERTY_NAME_TYPE : 4,
            PROPERTY_VALUE_TYPE : 5,
            PROPERTY_VALUE_PART_TYPE : 6,
            SELECTOR_TYPE : 7,
            SELECTOR_PART_TYPE : 8,
            SELECTOR_SUB_PART_TYPE : 9,
            _stylesheet: function(){

                var tokenStream = this._tokenStream,
                    charset     = null,
                    count,
                    token,
                    tt;

                this.fire("startstylesheet");
                this._charset();

                this._skipCruft();
                while (tokenStream.peek() == Tokens.IMPORT_SYM){
                    this._import();
                    this._skipCruft();
                }
                while (tokenStream.peek() == Tokens.NAMESPACE_SYM){
                    this._namespace();
                    this._skipCruft();
                }
                tt = tokenStream.peek();
                while(tt > Tokens.EOF){

                    try {

                        switch(tt){
                            case Tokens.MEDIA_SYM:
                                this._media();
                                this._skipCruft();
                                break;
                            case Tokens.PAGE_SYM:
                                this._page();
                                this._skipCruft();
                                break;
                            case Tokens.FONT_FACE_SYM:
                                this._font_face();
                                this._skipCruft();
                                break;
                            case Tokens.KEYFRAMES_SYM:
                                this._keyframes();
                                this._skipCruft();
                                break;
                            case Tokens.VIEWPORT_SYM:
                                this._viewport();
                                this._skipCruft();
                                break;
                            case Tokens.UNKNOWN_SYM:  //unknown @ rule
                                tokenStream.get();
                                if (!this.options.strict){
                                    this.fire({
                                        type:       "error",
                                        error:      null,
                                        message:    "Unknown @ rule: " + tokenStream.LT(0).value + ".",
                                        line:       tokenStream.LT(0).startLine,
                                        col:        tokenStream.LT(0).startCol
                                    });
                                    count=0;
                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) == Tokens.LBRACE){
                                        count++;    //keep track of nesting depth
                                    }

                                    while(count){
                                        tokenStream.advance([Tokens.RBRACE]);
                                        count--;
                                    }

                                } else {
                                    throw new SyntaxError("Unknown @ rule.", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                                }
                                break;
                            case Tokens.S:
                                this._readWhitespace();
                                break;
                            default:
                                if(!this._ruleset()){
                                    switch(tt){
                                        case Tokens.CHARSET_SYM:
                                            token = tokenStream.LT(1);
                                            this._charset(false);
                                            throw new SyntaxError("@charset not allowed here.", token.startLine, token.startCol);
                                        case Tokens.IMPORT_SYM:
                                            token = tokenStream.LT(1);
                                            this._import(false);
                                            throw new SyntaxError("@import not allowed here.", token.startLine, token.startCol);
                                        case Tokens.NAMESPACE_SYM:
                                            token = tokenStream.LT(1);
                                            this._namespace(false);
                                            throw new SyntaxError("@namespace not allowed here.", token.startLine, token.startCol);
                                        default:
                                            tokenStream.get();  //get the last token
                                            this._unexpectedToken(tokenStream.token());
                                    }

                                }
                        }
                    } catch(ex) {
                        if (ex instanceof SyntaxError && !this.options.strict){
                            this.fire({
                                type:       "error",
                                error:      ex,
                                message:    ex.message,
                                line:       ex.line,
                                col:        ex.col
                            });
                        } else {
                            throw ex;
                        }
                    }

                    tt = tokenStream.peek();
                }

                if (tt != Tokens.EOF){
                    this._unexpectedToken(tokenStream.token());
                }

                this.fire("endstylesheet");
            },

            _charset: function(emit){
                var tokenStream = this._tokenStream,
                    charset,
                    token,
                    line,
                    col;

                if (tokenStream.match(Tokens.CHARSET_SYM)){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.STRING);

                    token = tokenStream.token();
                    charset = token.value;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.SEMICOLON);

                    if (emit !== false){
                        this.fire({
                            type:   "charset",
                            charset:charset,
                            line:   line,
                            col:    col
                        });
                    }
                }
            },

            _import: function(emit){

                var tokenStream = this._tokenStream,
                    tt,
                    uri,
                    importToken,
                    mediaList   = [];
                tokenStream.mustMatch(Tokens.IMPORT_SYM);
                importToken = tokenStream.token();
                this._readWhitespace();

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                uri = tokenStream.token().value.replace(/^(?:url\()?["']?([^"']+?)["']?\)?$/, "$1");

                this._readWhitespace();

                mediaList = this._media_query_list();
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false){
                    this.fire({
                        type:   "import",
                        uri:    uri,
                        media:  mediaList,
                        line:   importToken.startLine,
                        col:    importToken.startCol
                    });
                }

            },

            _namespace: function(emit){

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    prefix,
                    uri;
                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();
                if (tokenStream.match(Tokens.IDENT)){
                    prefix = tokenStream.token().value;
                    this._readWhitespace();
                }

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                uri = tokenStream.token().value.replace(/(?:url\()?["']([^"']+)["']\)?/, "$1");

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false){
                    this.fire({
                        type:   "namespace",
                        prefix: prefix,
                        uri:    uri,
                        line:   line,
                        col:    col
                    });
                }

            },

            _media: function(){
                var tokenStream     = this._tokenStream,
                    line,
                    col,
                    mediaList;//       = [];
                tokenStream.mustMatch(Tokens.MEDIA_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                mediaList = this._media_query_list();

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type:   "startmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });

                while(true) {
                    if (tokenStream.peek() == Tokens.PAGE_SYM){
                        this._page();
                    } else if (tokenStream.peek() == Tokens.FONT_FACE_SYM){
                        this._font_face();
                    } else if (tokenStream.peek() == Tokens.VIEWPORT_SYM){
                        this._viewport();
                    } else if (!this._ruleset()){
                        break;
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

                this.fire({
                    type:   "endmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });
            },
            _media_query_list: function(){
                var tokenStream = this._tokenStream,
                    mediaList   = [];


                this._readWhitespace();

                if (tokenStream.peek() == Tokens.IDENT || tokenStream.peek() == Tokens.LPAREN){
                    mediaList.push(this._media_query());
                }

                while(tokenStream.match(Tokens.COMMA)){
                    this._readWhitespace();
                    mediaList.push(this._media_query());
                }

                return mediaList;
            },
            _media_query: function(){
                var tokenStream = this._tokenStream,
                    type        = null,
                    ident       = null,
                    token       = null,
                    expressions = [];

                if (tokenStream.match(Tokens.IDENT)){
                    ident = tokenStream.token().value.toLowerCase();
                    if (ident != "only" && ident != "not"){
                        tokenStream.unget();
                        ident = null;
                    } else {
                        token = tokenStream.token();
                    }
                }

                this._readWhitespace();

                if (tokenStream.peek() == Tokens.IDENT){
                    type = this._media_type();
                    if (token === null){
                        token = tokenStream.token();
                    }
                } else if (tokenStream.peek() == Tokens.LPAREN){
                    if (token === null){
                        token = tokenStream.LT(1);
                    }
                    expressions.push(this._media_expression());
                }

                if (type === null && expressions.length === 0){
                    return null;
                } else {
                    this._readWhitespace();
                    while (tokenStream.match(Tokens.IDENT)){
                        if (tokenStream.token().value.toLowerCase() != "and"){
                            this._unexpectedToken(tokenStream.token());
                        }

                        this._readWhitespace();
                        expressions.push(this._media_expression());
                    }
                }

                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
            },
            _media_type: function(){
                return this._media_feature();
            },
            _media_expression: function(){
                var tokenStream = this._tokenStream,
                    feature     = null,
                    token,
                    expression  = null;

                tokenStream.mustMatch(Tokens.LPAREN);
                this._readWhitespace();

                feature = this._media_feature();
                this._readWhitespace();

                if (tokenStream.match(Tokens.COLON)){
                    this._readWhitespace();
                    token = tokenStream.LT(1);
                    expression = this._expression();
                }

                tokenStream.mustMatch(Tokens.RPAREN);
                this._readWhitespace();

                return new MediaFeature(feature, (expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null));
            },
            _media_feature: function(){
                var tokenStream = this._tokenStream;

                tokenStream.mustMatch(Tokens.IDENT);

                return SyntaxUnit.fromToken(tokenStream.token());
            },
            _page: function(){
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    identifier  = null,
                    pseudoPage  = null;
                tokenStream.mustMatch(Tokens.PAGE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                if (tokenStream.match(Tokens.IDENT)){
                    identifier = tokenStream.token().value;
                    if (identifier.toLowerCase() === "auto"){
                        this._unexpectedToken(tokenStream.token());
                    }
                }
                if (tokenStream.peek() == Tokens.COLON){
                    pseudoPage = this._pseudo_page();
                }

                this._readWhitespace();

                this.fire({
                    type:   "startpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true, true);

                this.fire({
                    type:   "endpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

            },
            _margin: function(){
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    marginSym   = this._margin_sym();

                if (marginSym){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this.fire({
                        type: "startpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type: "endpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });
                    return true;
                } else {
                    return false;
                }
            },
            _margin_sym: function(){

                var tokenStream = this._tokenStream;

                if(tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,
                        Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,
                        Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,
                        Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,
                        Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,
                        Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,
                        Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM]))
                {
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else {
                    return null;
                }

            },

            _pseudo_page: function(){

                var tokenStream = this._tokenStream;

                tokenStream.mustMatch(Tokens.COLON);
                tokenStream.mustMatch(Tokens.IDENT);
                return tokenStream.token().value;
            },

            _font_face: function(){
                var tokenStream = this._tokenStream,
                    line,
                    col;
                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                this.fire({
                    type:   "startfontface",
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endfontface",
                    line:   line,
                    col:    col
                });
            },

            _viewport: function(){
                 var tokenStream = this._tokenStream,
                    line,
                    col;

                    tokenStream.mustMatch(Tokens.VIEWPORT_SYM);
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();

                    this.fire({
                        type:   "startviewport",
                        line:   line,
                        col:    col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type:   "endviewport",
                        line:   line,
                        col:    col
                    });

            },

            _operator: function(inFunction){

                var tokenStream = this._tokenStream,
                    token       = null;

                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||
                    (inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))){
                    token =  tokenStream.token();
                    this._readWhitespace();
                }
                return token ? PropertyValuePart.fromToken(token) : null;

            },

            _combinator: function(){

                var tokenStream = this._tokenStream,
                    value       = null,
                    token;

                if(tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])){
                    token = tokenStream.token();
                    value = new Combinator(token.value, token.startLine, token.startCol);
                    this._readWhitespace();
                }

                return value;
            },

            _unary_operator: function(){

                var tokenStream = this._tokenStream;

                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])){
                    return tokenStream.token().value;
                } else {
                    return null;
                }
            },

            _property: function(){

                var tokenStream = this._tokenStream,
                    value       = null,
                    hack        = null,
                    tokenValue,
                    token,
                    line,
                    col;
                if (tokenStream.peek() == Tokens.STAR && this.options.starHack){
                    tokenStream.get();
                    token = tokenStream.token();
                    hack = token.value;
                    line = token.startLine;
                    col = token.startCol;
                }

                if(tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();
                    tokenValue = token.value;
                    if (tokenValue.charAt(0) == "_" && this.options.underscoreHack){
                        hack = "_";
                        tokenValue = tokenValue.substring(1);
                    }

                    value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));
                    this._readWhitespace();
                }

                return value;
            },
            _ruleset: function(){

                var tokenStream = this._tokenStream,
                    tt,
                    selectors;
                try {
                    selectors = this._selectors_group();
                } catch (ex){
                    if (ex instanceof SyntaxError && !this.options.strict){
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });
                        tt = tokenStream.advance([Tokens.RBRACE]);
                        if (tt == Tokens.RBRACE){
                        } else {
                            throw ex;
                        }

                    } else {
                        throw ex;
                    }
                    return true;
                }
                if (selectors){

                    this.fire({
                        type:       "startrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type:       "endrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                }

                return selectors;

            },
            _selectors_group: function(){
                var tokenStream = this._tokenStream,
                    selectors   = [],
                    selector;

                selector = this._selector();
                if (selector !== null){

                    selectors.push(selector);
                    while(tokenStream.match(Tokens.COMMA)){
                        this._readWhitespace();
                        selector = this._selector();
                        if (selector !== null){
                            selectors.push(selector);
                        } else {
                            this._unexpectedToken(tokenStream.LT(1));
                        }
                    }
                }

                return selectors.length ? selectors : null;
            },
            _selector: function(){

                var tokenStream = this._tokenStream,
                    selector    = [],
                    nextSelector = null,
                    combinator  = null,
                    ws          = null;
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null){
                    return null;
                }

                selector.push(nextSelector);

                do {
                    combinator = this._combinator();

                    if (combinator !== null){
                        selector.push(combinator);
                        nextSelector = this._simple_selector_sequence();
                        if (nextSelector === null){
                            this._unexpectedToken(tokenStream.LT(1));
                        } else {
                            selector.push(nextSelector);
                        }
                    } else {
                        if (this._readWhitespace()){
                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);
                            combinator = this._combinator();
                            nextSelector = this._simple_selector_sequence();
                            if (nextSelector === null){
                                if (combinator !== null){
                                    this._unexpectedToken(tokenStream.LT(1));
                                }
                            } else {

                                if (combinator !== null){
                                    selector.push(combinator);
                                } else {
                                    selector.push(ws);
                                }

                                selector.push(nextSelector);
                            }
                        } else {
                            break;
                        }

                    }
                } while(true);

                return new Selector(selector, selector[0].line, selector[0].col);
            },
            _simple_selector_sequence: function(){

                var tokenStream = this._tokenStream,
                    elementName = null,
                    modifiers   = [],
                    selectorText= "",
                    components  = [
                        function(){
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo,
                        this._negation
                    ],
                    i           = 0,
                    len         = components.length,
                    component   = null,
                    found       = false,
                    line,
                    col;
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                elementName = this._type_selector();
                if (!elementName){
                    elementName = this._universal();
                }

                if (elementName !== null){
                    selectorText += elementName;
                }

                while(true){
                    if (tokenStream.peek() === Tokens.S){
                        break;
                    }
                    while(i < len && component === null){
                        component = components[i++].call(this);
                    }

                    if (component === null){
                        if (selectorText === ""){
                            return null;
                        } else {
                            break;
                        }
                    } else {
                        i = 0;
                        modifiers.push(component);
                        selectorText += component.toString();
                        component = null;
                    }
                }


                return selectorText !== "" ?
                        new SelectorPart(elementName, modifiers, selectorText, line, col) :
                        null;
            },
            _type_selector: function(){

                var tokenStream = this._tokenStream,
                    ns          = this._namespace_prefix(),
                    elementName = this._element_name();

                if (!elementName){
                    if (ns){
                        tokenStream.unget();
                        if (ns.length > 1){
                            tokenStream.unget();
                        }
                    }

                    return null;
                } else {
                    if (ns){
                        elementName.text = ns + elementName.text;
                        elementName.col -= ns.length;
                    }
                    return elementName;
                }
            },
            _class: function(){

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.DOT)){
                    tokenStream.mustMatch(Tokens.IDENT);
                    token = tokenStream.token();
                    return new SelectorSubPart("." + token.value, "class", token.startLine, token.startCol - 1);
                } else {
                    return null;
                }

            },
            _element_name: function(){

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();
                    return new SelectorSubPart(token.value, "elementName", token.startLine, token.startCol);

                } else {
                    return null;
                }
            },
            _namespace_prefix: function(){
                var tokenStream = this._tokenStream,
                    value       = "";
                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE){

                    if(tokenStream.match([Tokens.IDENT, Tokens.STAR])){
                        value += tokenStream.token().value;
                    }

                    tokenStream.mustMatch(Tokens.PIPE);
                    value += "|";

                }

                return value.length ? value : null;
            },
            _universal: function(){
                var tokenStream = this._tokenStream,
                    value       = "",
                    ns;

                ns = this._namespace_prefix();
                if(ns){
                    value += ns;
                }

                if(tokenStream.match(Tokens.STAR)){
                    value += "*";
                }

                return value.length ? value : null;

           },
            _attrib: function(){

                var tokenStream = this._tokenStream,
                    value       = null,
                    ns,
                    token;

                if (tokenStream.match(Tokens.LBRACKET)){
                    token = tokenStream.token();
                    value = token.value;
                    value += this._readWhitespace();

                    ns = this._namespace_prefix();

                    if (ns){
                        value += ns;
                    }

                    tokenStream.mustMatch(Tokens.IDENT);
                    value += tokenStream.token().value;
                    value += this._readWhitespace();

                    if(tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,
                            Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])){

                        value += tokenStream.token().value;
                        value += this._readWhitespace();

                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                        value += tokenStream.token().value;
                        value += this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACKET);

                    return new SelectorSubPart(value + "]", "attribute", token.startLine, token.startCol);
                } else {
                    return null;
                }
            },
            _pseudo: function(){

                var tokenStream = this._tokenStream,
                    pseudo      = null,
                    colons      = ":",
                    line,
                    col;

                if (tokenStream.match(Tokens.COLON)){

                    if (tokenStream.match(Tokens.COLON)){
                        colons += ":";
                    }

                    if (tokenStream.match(Tokens.IDENT)){
                        pseudo = tokenStream.token().value;
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol - colons.length;
                    } else if (tokenStream.peek() == Tokens.FUNCTION){
                        line = tokenStream.LT(1).startLine;
                        col = tokenStream.LT(1).startCol - colons.length;
                        pseudo = this._functional_pseudo();
                    }

                    if (pseudo){
                        pseudo = new SelectorSubPart(colons + pseudo, "pseudo", line, col);
                    }
                }

                return pseudo;
            },
            _functional_pseudo: function(){

                var tokenStream = this._tokenStream,
                    value = null;

                if(tokenStream.match(Tokens.FUNCTION)){
                    value = tokenStream.token().value;
                    value += this._readWhitespace();
                    value += this._expression();
                    tokenStream.mustMatch(Tokens.RPAREN);
                    value += ")";
                }

                return value;
            },
            _expression: function(){

                var tokenStream = this._tokenStream,
                    value       = "";

                while(tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,
                        Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,
                        Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,
                        Tokens.RESOLUTION, Tokens.SLASH])){

                    value += tokenStream.token().value;
                    value += this._readWhitespace();
                }

                return value.length ? value : null;

            },
            _negation: function(){

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    value       = "",
                    arg,
                    subpart     = null;

                if (tokenStream.match(Tokens.NOT)){
                    value = tokenStream.token().value;
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                    value += this._readWhitespace();
                    arg = this._negation_arg();
                    value += arg;
                    value += this._readWhitespace();
                    tokenStream.match(Tokens.RPAREN);
                    value += tokenStream.token().value;

                    subpart = new SelectorSubPart(value, "not", line, col);
                    subpart.args.push(arg);
                }

                return subpart;
            },
            _negation_arg: function(){

                var tokenStream = this._tokenStream,
                    args        = [
                        this._type_selector,
                        this._universal,
                        function(){
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo
                    ],
                    arg         = null,
                    i           = 0,
                    len         = args.length,
                    elementName,
                    line,
                    col,
                    part;

                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                while(i < len && arg === null){

                    arg = args[i].call(this);
                    i++;
                }
                if (arg === null){
                    this._unexpectedToken(tokenStream.LT(1));
                }
                if (arg.type == "elementName"){
                    part = new SelectorPart(arg, [], arg.toString(), line, col);
                } else {
                    part = new SelectorPart(null, [arg], arg.toString(), line, col);
                }

                return part;
            },

            _declaration: function(){

                var tokenStream = this._tokenStream,
                    property    = null,
                    expr        = null,
                    prio        = null,
                    error       = null,
                    invalid     = null,
                    propertyName= "";

                property = this._property();
                if (property !== null){

                    tokenStream.mustMatch(Tokens.COLON);
                    this._readWhitespace();

                    expr = this._expr();
                    if (!expr || expr.length === 0){
                        this._unexpectedToken(tokenStream.LT(1));
                    }

                    prio = this._prio();
                    propertyName = property.toString();
                    if (this.options.starHack && property.hack == "*" ||
                            this.options.underscoreHack && property.hack == "_") {

                        propertyName = property.text;
                    }

                    try {
                        this._validateProperty(propertyName, expr);
                    } catch (ex) {
                        invalid = ex;
                    }

                    this.fire({
                        type:       "property",
                        property:   property,
                        value:      expr,
                        important:  prio,
                        line:       property.line,
                        col:        property.col,
                        invalid:    invalid
                    });

                    return true;
                } else {
                    return false;
                }
            },

            _prio: function(){

                var tokenStream = this._tokenStream,
                    result      = tokenStream.match(Tokens.IMPORTANT_SYM);

                this._readWhitespace();
                return result;
            },

            _expr: function(inFunction){

                var tokenStream = this._tokenStream,
                    values      = [],
                    value       = null,
                    operator    = null;

                value = this._term(inFunction);
                if (value !== null){

                    values.push(value);

                    do {
                        operator = this._operator(inFunction);
                        if (operator){
                            values.push(operator);
                        } /*else {
                            values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                            valueParts = [];
                        }*/

                        value = this._term(inFunction);

                        if (value === null){
                            break;
                        } else {
                            values.push(value);
                        }
                    } while(true);
                }

                return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
            },

            _term: function(inFunction){

                var tokenStream = this._tokenStream,
                    unary       = null,
                    value       = null,
                    endChar     = null,
                    token,
                    line,
                    col;
                unary = this._unary_operator();
                if (unary !== null){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                }
                if (tokenStream.peek() == Tokens.IE_FUNCTION && this.options.ieFilters){

                    value = this._ie_function();
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])){

                    token = tokenStream.token();
                    endChar = token.endChar;
                    value = token.value + this._expr(inFunction).text;
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    tokenStream.mustMatch(Tokens.type(endChar));
                    value += endChar;
                    this._readWhitespace();
                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,
                        Tokens.ANGLE, Tokens.TIME,
                        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])){

                    value = tokenStream.token().value;
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    this._readWhitespace();
                } else {
                    token = this._hexcolor();
                    if (token === null){
                        if (unary === null){
                            line = tokenStream.LT(1).startLine;
                            col = tokenStream.LT(1).startCol;
                        }
                        if (value === null){
                            if (tokenStream.LA(3) == Tokens.EQUALS && this.options.ieFilters){
                                value = this._ie_function();
                            } else {
                                value = this._function();
                            }
                        }

                    } else {
                        value = token.value;
                        if (unary === null){
                            line = token.startLine;
                            col = token.startCol;
                        }
                    }

                }

                return value !== null ?
                        new PropertyValuePart(unary !== null ? unary + value : value, line, col) :
                        null;

            },

            _function: function(){

                var tokenStream = this._tokenStream,
                    functionText = null,
                    expr        = null,
                    lt;

                if (tokenStream.match(Tokens.FUNCTION)){
                    functionText = tokenStream.token().value;
                    this._readWhitespace();
                    expr = this._expr(true);
                    functionText += expr;
                    if (this.options.ieFilters && tokenStream.peek() == Tokens.EQUALS){
                        do {

                            if (this._readWhitespace()){
                                functionText += tokenStream.token().value;
                            }
                            if (tokenStream.LA(0) == Tokens.COMMA){
                                functionText += tokenStream.token().value;
                            }

                            tokenStream.match(Tokens.IDENT);
                            functionText += tokenStream.token().value;

                            tokenStream.match(Tokens.EQUALS);
                            functionText += tokenStream.token().value;
                            lt = tokenStream.peek();
                            while(lt != Tokens.COMMA && lt != Tokens.S && lt != Tokens.RPAREN){
                                tokenStream.get();
                                functionText += tokenStream.token().value;
                                lt = tokenStream.peek();
                            }
                        } while(tokenStream.match([Tokens.COMMA, Tokens.S]));
                    }
                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _ie_function: function(){

                var tokenStream = this._tokenStream,
                    functionText = null,
                    expr        = null,
                    lt;
                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])){
                    functionText = tokenStream.token().value;

                    do {

                        if (this._readWhitespace()){
                            functionText += tokenStream.token().value;
                        }
                        if (tokenStream.LA(0) == Tokens.COMMA){
                            functionText += tokenStream.token().value;
                        }

                        tokenStream.match(Tokens.IDENT);
                        functionText += tokenStream.token().value;

                        tokenStream.match(Tokens.EQUALS);
                        functionText += tokenStream.token().value;
                        lt = tokenStream.peek();
                        while(lt != Tokens.COMMA && lt != Tokens.S && lt != Tokens.RPAREN){
                            tokenStream.get();
                            functionText += tokenStream.token().value;
                            lt = tokenStream.peek();
                        }
                    } while(tokenStream.match([Tokens.COMMA, Tokens.S]));

                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _hexcolor: function(){

                var tokenStream = this._tokenStream,
                    token = null,
                    color;

                if(tokenStream.match(Tokens.HASH)){
                    token = tokenStream.token();
                    color = token.value;
                    if (!/#[a-f0-9]{3,6}/i.test(color)){
                        throw new SyntaxError("Expected a hex color but found '" + color + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
                    }
                    this._readWhitespace();
                }

                return token;
            },
            _keyframes: function(){
                var tokenStream = this._tokenStream,
                    token,
                    tt,
                    name,
                    prefix = "";

                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                name = this._keyframe_name();

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.LBRACE);

                this.fire({
                    type:   "startkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tt = tokenStream.peek();
                while(tt == Tokens.IDENT || tt == Tokens.PERCENTAGE) {
                    this._keyframe_rule();
                    this._readWhitespace();
                    tt = tokenStream.peek();
                }

                this.fire({
                    type:   "endkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.RBRACE);

            },

            _keyframe_name: function(){
                var tokenStream = this._tokenStream,
                    token;

                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                return SyntaxUnit.fromToken(tokenStream.token());
            },

            _keyframe_rule: function(){
                var tokenStream = this._tokenStream,
                    token,
                    keyList = this._key_list();

                this.fire({
                    type:   "startkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

            },

            _key_list: function(){
                var tokenStream = this._tokenStream,
                    token,
                    key,
                    keyList = [];
                keyList.push(this._key());

                this._readWhitespace();

                while(tokenStream.match(Tokens.COMMA)){
                    this._readWhitespace();
                    keyList.push(this._key());
                    this._readWhitespace();
                }

                return keyList;
            },

            _key: function(){

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.PERCENTAGE)){
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else if (tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();

                    if (/from|to/i.test(token.value)){
                        return SyntaxUnit.fromToken(token);
                    }

                    tokenStream.unget();
                }
                this._unexpectedToken(tokenStream.LT(1));
            },
            _skipCruft: function(){
                while(this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])){
                }
            },
            _readDeclarations: function(checkStart, readMargins){
                var tokenStream = this._tokenStream,
                    tt;


                this._readWhitespace();

                if (checkStart){
                    tokenStream.mustMatch(Tokens.LBRACE);
                }

                this._readWhitespace();

                try {

                    while(true){

                        if (tokenStream.match(Tokens.SEMICOLON) || (readMargins && this._margin())){
                        } else if (this._declaration()){
                            if (!tokenStream.match(Tokens.SEMICOLON)){
                                break;
                            }
                        } else {
                            break;
                        }
                        this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACE);
                    this._readWhitespace();

                } catch (ex) {
                    if (ex instanceof SyntaxError && !this.options.strict){
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });
                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
                        if (tt == Tokens.SEMICOLON){
                            this._readDeclarations(false, readMargins);
                        } else if (tt != Tokens.RBRACE){
                            throw ex;
                        }

                    } else {
                        throw ex;
                    }
                }

            },
            _readWhitespace: function(){

                var tokenStream = this._tokenStream,
                    ws = "";

                while(tokenStream.match(Tokens.S)){
                    ws += tokenStream.token().value;
                }

                return ws;
            },
            _unexpectedToken: function(token){
                throw new SyntaxError("Unexpected token '" + token.value + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
            },
            _verifyEnd: function(){
                if (this._tokenStream.LA(1) != Tokens.EOF){
                    this._unexpectedToken(this._tokenStream.LT(1));
                }
            },
            _validateProperty: function(property, value){
                Validation.validate(property, value);
            },
            parse: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                this._stylesheet();
            },

            parseStyleSheet: function(input){
                return this.parse(input);
            },

            parseMediaQuery: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                var result = this._media_query();
                this._verifyEnd();
                return result;
            },
            parsePropertyValue: function(input){

                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._expr();
                this._readWhitespace();
                this._verifyEnd();
                return result;
            },
            parseRule: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._ruleset();
                this._readWhitespace();
                this._verifyEnd();
                return result;
            },
            parseSelector: function(input){

                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._selector();
                this._readWhitespace();
                this._verifyEnd();
                return result;
            },
            parseStyleAttribute: function(input){
                input += "}"; // for error recovery in _readDeclarations()
                this._tokenStream = new TokenStream(input, Tokens);
                this._readDeclarations();
            }
        };
    for (prop in additions){
        if (additions.hasOwnProperty(prop)){
            proto[prop] = additions[prop];
        }
    }

    return proto;
}();
var Properties = {
    "align-items"                   : "flex-start | flex-end | center | baseline | stretch",
    "align-content"                 : "flex-start | flex-end | center | space-between | space-around | stretch",
    "align-self"                    : "auto | flex-start | flex-end | center | baseline | stretch",
    "-webkit-align-items"           : "flex-start | flex-end | center | baseline | stretch",
    "-webkit-align-content"         : "flex-start | flex-end | center | space-between | space-around | stretch",
    "-webkit-align-self"            : "auto | flex-start | flex-end | center | baseline | stretch",
    "alignment-adjust"              : "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>",
    "alignment-baseline"            : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "animation"                     : 1,
    "animation-delay"               : { multi: "<time>", comma: true },
    "animation-direction"           : { multi: "normal | reverse | alternate | alternate-reverse", comma: true },
    "animation-duration"            : { multi: "<time>", comma: true },
    "animation-fill-mode"           : { multi: "none | forwards | backwards | both", comma: true },
    "animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "animation-name"                : { multi: "none | <ident>", comma: true },
    "animation-play-state"          : { multi: "running | paused", comma: true },
    "animation-timing-function"     : 1,
    "-moz-animation-delay"               : { multi: "<time>", comma: true },
    "-moz-animation-direction"           : { multi: "normal | reverse | alternate | alternate-reverse", comma: true },
    "-moz-animation-duration"            : { multi: "<time>", comma: true },
    "-moz-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-moz-animation-name"                : { multi: "none | <ident>", comma: true },
    "-moz-animation-play-state"          : { multi: "running | paused", comma: true },

    "-ms-animation-delay"               : { multi: "<time>", comma: true },
    "-ms-animation-direction"           : { multi: "normal | reverse | alternate | alternate-reverse", comma: true },
    "-ms-animation-duration"            : { multi: "<time>", comma: true },
    "-ms-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-ms-animation-name"                : { multi: "none | <ident>", comma: true },
    "-ms-animation-play-state"          : { multi: "running | paused", comma: true },

    "-webkit-animation-delay"               : { multi: "<time>", comma: true },
    "-webkit-animation-direction"           : { multi: "normal | reverse | alternate | alternate-reverse", comma: true },
    "-webkit-animation-duration"            : { multi: "<time>", comma: true },
    "-webkit-animation-fill-mode"           : { multi: "none | forwards | backwards | both", comma: true },
    "-webkit-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-webkit-animation-name"                : { multi: "none | <ident>", comma: true },
    "-webkit-animation-play-state"          : { multi: "running | paused", comma: true },

    "-o-animation-delay"               : { multi: "<time>", comma: true },
    "-o-animation-direction"           : { multi: "normal | reverse | alternate | alternate-reverse", comma: true },
    "-o-animation-duration"            : { multi: "<time>", comma: true },
    "-o-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-o-animation-name"                : { multi: "none | <ident>", comma: true },
    "-o-animation-play-state"          : { multi: "running | paused", comma: true },

    "appearance"                    : "icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit",
    "azimuth"                       : function (expression) {
        var simple      = "<angle> | leftwards | rightwards | inherit",
            direction   = "left-side | far-left | left | center-left | center | center-right | right | far-right | right-side",
            behind      = false,
            valid       = false,
            part;

        if (!ValidationTypes.isAny(expression, simple)) {
            if (ValidationTypes.isAny(expression, "behind")) {
                behind = true;
                valid = true;
            }

            if (ValidationTypes.isAny(expression, direction)) {
                valid = true;
                if (!behind) {
                    ValidationTypes.isAny(expression, "behind");
                }
            }
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (<'azimuth'>) but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "backface-visibility"           : "visible | hidden",
    "background"                    : 1,
    "background-attachment"         : { multi: "<attachment>", comma: true },
    "background-clip"               : { multi: "<box>", comma: true },
    "background-color"              : "<color> | inherit",
    "background-image"              : { multi: "<bg-image>", comma: true },
    "background-origin"             : { multi: "<box>", comma: true },
    "background-position"           : { multi: "<bg-position>", comma: true },
    "background-repeat"             : { multi: "<repeat-style>" },
    "background-size"               : { multi: "<bg-size>", comma: true },
    "baseline-shift"                : "baseline | sub | super | <percentage> | <length>",
    "behavior"                      : 1,
    "binding"                       : 1,
    "bleed"                         : "<length>",
    "bookmark-label"                : "<content> | <attr> | <string>",
    "bookmark-level"                : "none | <integer>",
    "bookmark-state"                : "open | closed",
    "bookmark-target"               : "none | <uri> | <attr>",
    "border"                        : "<border-width> || <border-style> || <color>",
    "border-bottom"                 : "<border-width> || <border-style> || <color>",
    "border-bottom-color"           : "<color> | inherit",
    "border-bottom-left-radius"     :  "<x-one-radius>",
    "border-bottom-right-radius"    :  "<x-one-radius>",
    "border-bottom-style"           : "<border-style>",
    "border-bottom-width"           : "<border-width>",
    "border-collapse"               : "collapse | separate | inherit",
    "border-color"                  : { multi: "<color> | inherit", max: 4 },
    "border-image"                  : 1,
    "border-image-outset"           : { multi: "<length> | <number>", max: 4 },
    "border-image-repeat"           : { multi: "stretch | repeat | round", max: 2 },
    "border-image-slice"            : function(expression) {

        var valid   = false,
            numeric = "<number> | <percentage>",
            fill    = false,
            count   = 0,
            max     = 4,
            part;

        if (ValidationTypes.isAny(expression, "fill")) {
            fill = true;
            valid = true;
        }

        while (expression.hasNext() && count < max) {
            valid = ValidationTypes.isAny(expression, numeric);
            if (!valid) {
                break;
            }
            count++;
        }


        if (!fill) {
            ValidationTypes.isAny(expression, "fill");
        } else {
            valid = true;
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected ([<number> | <percentage>]{1,4} && fill?) but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "border-image-source"           : "<image> | none",
    "border-image-width"            : { multi: "<length> | <percentage> | <number> | auto", max: 4 },
    "border-left"                   : "<border-width> || <border-style> || <color>",
    "border-left-color"             : "<color> | inherit",
    "border-left-style"             : "<border-style>",
    "border-left-width"             : "<border-width>",
    "border-radius"                 : function(expression) {

        var valid   = false,
            simple = "<length> | <percentage> | inherit",
            slash   = false,
            fill    = false,
            count   = 0,
            max     = 8,
            part;

        while (expression.hasNext() && count < max) {
            valid = ValidationTypes.isAny(expression, simple);
            if (!valid) {

                if (expression.peek() == "/" && count > 0 && !slash) {
                    slash = true;
                    max = count + 5;
                    expression.next();
                } else {
                    break;
                }
            }
            count++;
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (<'border-radius'>) but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "border-right"                  : "<border-width> || <border-style> || <color>",
    "border-right-color"            : "<color> | inherit",
    "border-right-style"            : "<border-style>",
    "border-right-width"            : "<border-width>",
    "border-spacing"                : { multi: "<length> | inherit", max: 2 },
    "border-style"                  : { multi: "<border-style>", max: 4 },
    "border-top"                    : "<border-width> || <border-style> || <color>",
    "border-top-color"              : "<color> | inherit",
    "border-top-left-radius"        : "<x-one-radius>",
    "border-top-right-radius"       : "<x-one-radius>",
    "border-top-style"              : "<border-style>",
    "border-top-width"              : "<border-width>",
    "border-width"                  : { multi: "<border-width>", max: 4 },
    "bottom"                        : "<margin-width> | inherit",
    "-moz-box-align"                : "start | end | center | baseline | stretch",
    "-moz-box-decoration-break"     : "slice |clone",
    "-moz-box-direction"            : "normal | reverse | inherit",
    "-moz-box-flex"                 : "<number>",
    "-moz-box-flex-group"           : "<integer>",
    "-moz-box-lines"                : "single | multiple",
    "-moz-box-ordinal-group"        : "<integer>",
    "-moz-box-orient"               : "horizontal | vertical | inline-axis | block-axis | inherit",
    "-moz-box-pack"                 : "start | end | center | justify",
    "-webkit-box-align"             : "start | end | center | baseline | stretch",
    "-webkit-box-decoration-break"  : "slice |clone",
    "-webkit-box-direction"         : "normal | reverse | inherit",
    "-webkit-box-flex"              : "<number>",
    "-webkit-box-flex-group"        : "<integer>",
    "-webkit-box-lines"             : "single | multiple",
    "-webkit-box-ordinal-group"     : "<integer>",
    "-webkit-box-orient"            : "horizontal | vertical | inline-axis | block-axis | inherit",
    "-webkit-box-pack"              : "start | end | center | justify",
    "box-shadow"                    : function (expression) {
        var result      = false,
            part;

        if (!ValidationTypes.isAny(expression, "none")) {
            Validation.multiProperty("<shadow>", expression, true, Infinity);
        } else {
            if (expression.hasNext()) {
                part = expression.next();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "box-sizing"                    : "content-box | border-box | inherit",
    "break-after"                   : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-before"                  : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-inside"                  : "auto | avoid | avoid-page | avoid-column",
    "caption-side"                  : "top | bottom | inherit",
    "clear"                         : "none | right | left | both | inherit",
    "clip"                          : 1,
    "color"                         : "<color> | inherit",
    "color-profile"                 : 1,
    "column-count"                  : "<integer> | auto",                      //http://www.w3.org/TR/css3-multicol/
    "column-fill"                   : "auto | balance",
    "column-gap"                    : "<length> | normal",
    "column-rule"                   : "<border-width> || <border-style> || <color>",
    "column-rule-color"             : "<color>",
    "column-rule-style"             : "<border-style>",
    "column-rule-width"             : "<border-width>",
    "column-span"                   : "none | all",
    "column-width"                  : "<length> | auto",
    "columns"                       : 1,
    "content"                       : 1,
    "counter-increment"             : 1,
    "counter-reset"                 : 1,
    "crop"                          : "<shape> | auto",
    "cue"                           : "cue-after | cue-before | inherit",
    "cue-after"                     : 1,
    "cue-before"                    : 1,
    "cursor"                        : 1,
    "direction"                     : "ltr | rtl | inherit",
    "display"                       : "inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex",
    "dominant-baseline"             : 1,
    "drop-initial-after-adjust"     : "central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>",
    "drop-initial-after-align"      : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-before-adjust"    : "before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>",
    "drop-initial-before-align"     : "caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-size"             : "auto | line | <length> | <percentage>",
    "drop-initial-value"            : "initial | <integer>",
    "elevation"                     : "<angle> | below | level | above | higher | lower | inherit",
    "empty-cells"                   : "show | hide | inherit",
    "filter"                        : 1,
    "fit"                           : "fill | hidden | meet | slice",
    "fit-position"                  : 1,
    "flex"                          : "<flex>",
    "flex-basis"                    : "<width>",
    "flex-direction"                : "row | row-reverse | column | column-reverse",
    "flex-flow"                     : "<flex-direction> || <flex-wrap>",
    "flex-grow"                     : "<number>",
    "flex-shrink"                   : "<number>",
    "flex-wrap"                     : "nowrap | wrap | wrap-reverse",
    "-webkit-flex"                  : "<flex>",
    "-webkit-flex-basis"            : "<width>",
    "-webkit-flex-direction"        : "row | row-reverse | column | column-reverse",
    "-webkit-flex-flow"             : "<flex-direction> || <flex-wrap>",
    "-webkit-flex-grow"             : "<number>",
    "-webkit-flex-shrink"           : "<number>",
    "-webkit-flex-wrap"             : "nowrap | wrap | wrap-reverse",
    "-ms-flex"                      : "<flex>",
    "-ms-flex-align"                : "start | end | center | stretch | baseline",
    "-ms-flex-direction"            : "row | row-reverse | column | column-reverse | inherit",
    "-ms-flex-order"                : "<number>",
    "-ms-flex-pack"                 : "start | end | center | justify",
    "-ms-flex-wrap"                 : "nowrap | wrap | wrap-reverse",
    "float"                         : "left | right | none | inherit",
    "float-offset"                  : 1,
    "font"                          : 1,
    "font-family"                   : 1,
    "font-size"                     : "<absolute-size> | <relative-size> | <length> | <percentage> | inherit",
    "font-size-adjust"              : "<number> | none | inherit",
    "font-stretch"                  : "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit",
    "font-style"                    : "normal | italic | oblique | inherit",
    "font-variant"                  : "normal | small-caps | inherit",
    "font-weight"                   : "normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit",
    "grid-cell-stacking"            : "columns | rows | layer",
    "grid-column"                   : 1,
    "grid-columns"                  : 1,
    "grid-column-align"             : "start | end | center | stretch",
    "grid-column-sizing"            : 1,
    "grid-column-span"              : "<integer>",
    "grid-flow"                     : "none | rows | columns",
    "grid-layer"                    : "<integer>",
    "grid-row"                      : 1,
    "grid-rows"                     : 1,
    "grid-row-align"                : "start | end | center | stretch",
    "grid-row-span"                 : "<integer>",
    "grid-row-sizing"               : 1,
    "hanging-punctuation"           : 1,
    "height"                        : "<margin-width> | <content-sizing> | inherit",
    "hyphenate-after"               : "<integer> | auto",
    "hyphenate-before"              : "<integer> | auto",
    "hyphenate-character"           : "<string> | auto",
    "hyphenate-lines"               : "no-limit | <integer>",
    "hyphenate-resource"            : 1,
    "hyphens"                       : "none | manual | auto",
    "icon"                          : 1,
    "image-orientation"             : "angle | auto",
    "image-rendering"               : 1,
    "image-resolution"              : 1,
    "inline-box-align"              : "initial | last | <integer>",
    "justify-content"               : "flex-start | flex-end | center | space-between | space-around",
    "-webkit-justify-content"       : "flex-start | flex-end | center | space-between | space-around",
    "left"                          : "<margin-width> | inherit",
    "letter-spacing"                : "<length> | normal | inherit",
    "line-height"                   : "<number> | <length> | <percentage> | normal | inherit",
    "line-break"                    : "auto | loose | normal | strict",
    "line-stacking"                 : 1,
    "line-stacking-ruby"            : "exclude-ruby | include-ruby",
    "line-stacking-shift"           : "consider-shifts | disregard-shifts",
    "line-stacking-strategy"        : "inline-line-height | block-line-height | max-height | grid-height",
    "list-style"                    : 1,
    "list-style-image"              : "<uri> | none | inherit",
    "list-style-position"           : "inside | outside | inherit",
    "list-style-type"               : "disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit",
    "margin"                        : { multi: "<margin-width> | inherit", max: 4 },
    "margin-bottom"                 : "<margin-width> | inherit",
    "margin-left"                   : "<margin-width> | inherit",
    "margin-right"                  : "<margin-width> | inherit",
    "margin-top"                    : "<margin-width> | inherit",
    "mark"                          : 1,
    "mark-after"                    : 1,
    "mark-before"                   : 1,
    "marks"                         : 1,
    "marquee-direction"             : 1,
    "marquee-play-count"            : 1,
    "marquee-speed"                 : 1,
    "marquee-style"                 : 1,
    "max-height"                    : "<length> | <percentage> | <content-sizing> | none | inherit",
    "max-width"                     : "<length> | <percentage> | <content-sizing> | none | inherit",
    "max-zoom"                      : "<number> | <percentage> | auto",
    "min-height"                    : "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
    "min-width"                     : "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
    "min-zoom"                      : "<number> | <percentage> | auto",
    "move-to"                       : 1,
    "nav-down"                      : 1,
    "nav-index"                     : 1,
    "nav-left"                      : 1,
    "nav-right"                     : 1,
    "nav-up"                        : 1,
    "opacity"                       : "<number> | inherit",
    "order"                         : "<integer>",
    "-webkit-order"                 : "<integer>",
    "orphans"                       : "<integer> | inherit",
    "outline"                       : 1,
    "outline-color"                 : "<color> | invert | inherit",
    "outline-offset"                : 1,
    "outline-style"                 : "<border-style> | inherit",
    "outline-width"                 : "<border-width> | inherit",
    "overflow"                      : "visible | hidden | scroll | auto | inherit",
    "overflow-style"                : 1,
    "overflow-wrap"                 : "normal | break-word",
    "overflow-x"                    : 1,
    "overflow-y"                    : 1,
    "padding"                       : { multi: "<padding-width> | inherit", max: 4 },
    "padding-bottom"                : "<padding-width> | inherit",
    "padding-left"                  : "<padding-width> | inherit",
    "padding-right"                 : "<padding-width> | inherit",
    "padding-top"                   : "<padding-width> | inherit",
    "page"                          : 1,
    "page-break-after"              : "auto | always | avoid | left | right | inherit",
    "page-break-before"             : "auto | always | avoid | left | right | inherit",
    "page-break-inside"             : "auto | avoid | inherit",
    "page-policy"                   : 1,
    "pause"                         : 1,
    "pause-after"                   : 1,
    "pause-before"                  : 1,
    "perspective"                   : 1,
    "perspective-origin"            : 1,
    "phonemes"                      : 1,
    "pitch"                         : 1,
    "pitch-range"                   : 1,
    "play-during"                   : 1,
    "pointer-events"                : "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
    "position"                      : "static | relative | absolute | fixed | inherit",
    "presentation-level"            : 1,
    "punctuation-trim"              : 1,
    "quotes"                        : 1,
    "rendering-intent"              : 1,
    "resize"                        : 1,
    "rest"                          : 1,
    "rest-after"                    : 1,
    "rest-before"                   : 1,
    "richness"                      : 1,
    "right"                         : "<margin-width> | inherit",
    "rotation"                      : 1,
    "rotation-point"                : 1,
    "ruby-align"                    : 1,
    "ruby-overhang"                 : 1,
    "ruby-position"                 : 1,
    "ruby-span"                     : 1,
    "size"                          : 1,
    "speak"                         : "normal | none | spell-out | inherit",
    "speak-header"                  : "once | always | inherit",
    "speak-numeral"                 : "digits | continuous | inherit",
    "speak-punctuation"             : "code | none | inherit",
    "speech-rate"                   : 1,
    "src"                           : 1,
    "stress"                        : 1,
    "string-set"                    : 1,

    "table-layout"                  : "auto | fixed | inherit",
    "tab-size"                      : "<integer> | <length>",
    "target"                        : 1,
    "target-name"                   : 1,
    "target-new"                    : 1,
    "target-position"               : 1,
    "text-align"                    : "left | right | center | justify | inherit" ,
    "text-align-last"               : 1,
    "text-decoration"               : 1,
    "text-emphasis"                 : 1,
    "text-height"                   : 1,
    "text-indent"                   : "<length> | <percentage> | inherit",
    "text-justify"                  : "auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida",
    "text-outline"                  : 1,
    "text-overflow"                 : 1,
    "text-rendering"                : "auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit",
    "text-shadow"                   : 1,
    "text-transform"                : "capitalize | uppercase | lowercase | none | inherit",
    "text-wrap"                     : "normal | none | avoid",
    "top"                           : "<margin-width> | inherit",
    "-ms-touch-action"              : "auto | none | pan-x | pan-y",
    "touch-action"                  : "auto | none | pan-x | pan-y",
    "transform"                     : 1,
    "transform-origin"              : 1,
    "transform-style"               : 1,
    "transition"                    : 1,
    "transition-delay"              : 1,
    "transition-duration"           : 1,
    "transition-property"           : 1,
    "transition-timing-function"    : 1,
    "unicode-bidi"                  : "normal | embed | isolate | bidi-override | isolate-override | plaintext | inherit",
    "user-modify"                   : "read-only | read-write | write-only | inherit",
    "user-select"                   : "none | text | toggle | element | elements | all | inherit",
    "user-zoom"                     : "zoom | fixed",
    "vertical-align"                : "auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length>",
    "visibility"                    : "visible | hidden | collapse | inherit",
    "voice-balance"                 : 1,
    "voice-duration"                : 1,
    "voice-family"                  : 1,
    "voice-pitch"                   : 1,
    "voice-pitch-range"             : 1,
    "voice-rate"                    : 1,
    "voice-stress"                  : 1,
    "voice-volume"                  : 1,
    "volume"                        : 1,
    "white-space"                   : "normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap", //http://perishablepress.com/wrapping-content/
    "white-space-collapse"          : 1,
    "widows"                        : "<integer> | inherit",
    "width"                         : "<length> | <percentage> | <content-sizing> | auto | inherit",
    "word-break"                    : "normal | keep-all | break-all",
    "word-spacing"                  : "<length> | normal | inherit",
    "word-wrap"                     : "normal | break-word",
    "writing-mode"                  : "horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb | inherit",
    "z-index"                       : "<integer> | auto | inherit",
    "zoom"                          : "<number> | <percentage> | normal"
};
function PropertyName(text, hack, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);
    this.hack = hack;

}

PropertyName.prototype = new SyntaxUnit();
PropertyName.prototype.constructor = PropertyName;
PropertyName.prototype.toString = function(){
    return (this.hack ? this.hack : "") + this.text;
};
function PropertyValue(parts, line, col){

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.PROPERTY_VALUE_TYPE);
    this.parts = parts;

}

PropertyValue.prototype = new SyntaxUnit();
PropertyValue.prototype.constructor = PropertyValue;
function PropertyValueIterator(value){
    this._i = 0;
    this._parts = value.parts;
    this._marks = [];
    this.value = value;

}
PropertyValueIterator.prototype.count = function(){
    return this._parts.length;
};
PropertyValueIterator.prototype.isFirst = function(){
    return this._i === 0;
};
PropertyValueIterator.prototype.hasNext = function(){
    return (this._i < this._parts.length);
};
PropertyValueIterator.prototype.mark = function(){
    this._marks.push(this._i);
};
PropertyValueIterator.prototype.peek = function(count){
    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;
};
PropertyValueIterator.prototype.next = function(){
    return this.hasNext() ? this._parts[this._i++] : null;
};
PropertyValueIterator.prototype.previous = function(){
    return this._i > 0 ? this._parts[--this._i] : null;
};
PropertyValueIterator.prototype.restore = function(){
    if (this._marks.length){
        this._i = this._marks.pop();
    }
};
function PropertyValuePart(text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);
    this.type = "unknown";
    var temp;
    if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)){  //dimension
        this.type = "dimension";
        this.value = +RegExp.$1;
        this.units = RegExp.$2;
        switch(this.units.toLowerCase()){

            case "em":
            case "rem":
            case "ex":
            case "px":
            case "cm":
            case "mm":
            case "in":
            case "pt":
            case "pc":
            case "ch":
            case "vh":
            case "vw":
            case "vmax":
            case "vmin":
                this.type = "length";
                break;

            case "deg":
            case "rad":
            case "grad":
                this.type = "angle";
                break;

            case "ms":
            case "s":
                this.type = "time";
                break;

            case "hz":
            case "khz":
                this.type = "frequency";
                break;

            case "dpi":
            case "dpcm":
                this.type = "resolution";
                break;
        }

    } else if (/^([+\-]?[\d\.]+)%$/i.test(text)){  //percentage
        this.type = "percentage";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?\d+)$/i.test(text)){  //integer
        this.type = "integer";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?[\d\.]+)$/i.test(text)){  //number
        this.type = "number";
        this.value = +RegExp.$1;

    } else if (/^#([a-f0-9]{3,6})/i.test(text)){  //hexcolor
        this.type = "color";
        temp = RegExp.$1;
        if (temp.length == 3){
            this.red    = parseInt(temp.charAt(0)+temp.charAt(0),16);
            this.green  = parseInt(temp.charAt(1)+temp.charAt(1),16);
            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2),16);
        } else {
            this.red    = parseInt(temp.substring(0,2),16);
            this.green  = parseInt(temp.substring(2,4),16);
            this.blue   = parseInt(temp.substring(4,6),16);
        }
    } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)){ //rgb() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
    } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)){ //rgb() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
    } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //rgba() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
        this.alpha  = +RegExp.$4;
    } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //rgba() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)){ //hsl()
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
    } else if (/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //hsla() color with percentages
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^url\(["']?([^\)"']+)["']?\)/i.test(text)){ //URI
        this.type   = "uri";
        this.uri    = RegExp.$1;
    } else if (/^([^\(]+)\(/i.test(text)){
        this.type   = "function";
        this.name   = RegExp.$1;
        this.value  = text;
    } else if (/^["'][^"']*["']/.test(text)){    //string
        this.type   = "string";
        this.value  = eval(text);
    } else if (Colors[text.toLowerCase()]){  //named color
        this.type   = "color";
        temp        = Colors[text.toLowerCase()].substring(1);
        this.red    = parseInt(temp.substring(0,2),16);
        this.green  = parseInt(temp.substring(2,4),16);
        this.blue   = parseInt(temp.substring(4,6),16);
    } else if (/^[\,\/]$/.test(text)){
        this.type   = "operator";
        this.value  = text;
    } else if (/^[a-z\-_\u0080-\uFFFF][a-z0-9\-_\u0080-\uFFFF]*$/i.test(text)){
        this.type   = "identifier";
        this.value  = text;
    }

}

PropertyValuePart.prototype = new SyntaxUnit();
PropertyValuePart.prototype.constructor = PropertyValuePart;
PropertyValuePart.fromToken = function(token){
    return new PropertyValuePart(token.value, token.startLine, token.startCol);
};
var Pseudos = {
    ":first-letter": 1,
    ":first-line":   1,
    ":before":       1,
    ":after":        1
};

Pseudos.ELEMENT = 1;
Pseudos.CLASS = 2;

Pseudos.isElement = function(pseudo){
    return pseudo.indexOf("::") === 0 || Pseudos[pseudo.toLowerCase()] == Pseudos.ELEMENT;
};
function Selector(parts, line, col){

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.SELECTOR_TYPE);
    this.parts = parts;
    this.specificity = Specificity.calculate(this);

}

Selector.prototype = new SyntaxUnit();
Selector.prototype.constructor = Selector;
function SelectorPart(elementName, modifiers, text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);
    this.elementName = elementName;
    this.modifiers = modifiers;

}

SelectorPart.prototype = new SyntaxUnit();
SelectorPart.prototype.constructor = SelectorPart;
function SelectorSubPart(text, type, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);
    this.type = type;
    this.args = [];

}

SelectorSubPart.prototype = new SyntaxUnit();
SelectorSubPart.prototype.constructor = SelectorSubPart;
function Specificity(a, b, c, d){
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}

Specificity.prototype = {
    constructor: Specificity,
    compare: function(other){
        var comps = ["a", "b", "c", "d"],
            i, len;

        for (i=0, len=comps.length; i < len; i++){
            if (this[comps[i]] < other[comps[i]]){
                return -1;
            } else if (this[comps[i]] > other[comps[i]]){
                return 1;
            }
        }

        return 0;
    },
    valueOf: function(){
        return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;
    },
    toString: function(){
        return this.a + "," + this.b + "," + this.c + "," + this.d;
    }

};
Specificity.calculate = function(selector){

    var i, len,
        part,
        b=0, c=0, d=0;

    function updateValues(part){

        var i, j, len, num,
            elementName = part.elementName ? part.elementName.text : "",
            modifier;

        if (elementName && elementName.charAt(elementName.length-1) != "*") {
            d++;
        }

        for (i=0, len=part.modifiers.length; i < len; i++){
            modifier = part.modifiers[i];
            switch(modifier.type){
                case "class":
                case "attribute":
                    c++;
                    break;

                case "id":
                    b++;
                    break;

                case "pseudo":
                    if (Pseudos.isElement(modifier.text)){
                        d++;
                    } else {
                        c++;
                    }
                    break;

                case "not":
                    for (j=0, num=modifier.args.length; j < num; j++){
                        updateValues(modifier.args[j]);
                    }
            }
         }
    }

    for (i=0, len=selector.parts.length; i < len; i++){
        part = selector.parts[i];

        if (part instanceof SelectorPart){
            updateValues(part);
        }
    }

    return new Specificity(0, b, c, d);
};

var h = /^[0-9a-fA-F]$/,
    nonascii = /^[\u0080-\uFFFF]$/,
    nl = /\n|\r\n|\r|\f/;

function isHexDigit(c){
    return c !== null && h.test(c);
}

function isDigit(c){
    return c !== null && /\d/.test(c);
}

function isWhitespace(c){
    return c !== null && /\s/.test(c);
}

function isNewLine(c){
    return c !== null && nl.test(c);
}

function isNameStart(c){
    return c !== null && (/[a-z_\u0080-\uFFFF\\]/i.test(c));
}

function isNameChar(c){
    return c !== null && (isNameStart(c) || /[0-9\-\\]/.test(c));
}

function isIdentStart(c){
    return c !== null && (isNameStart(c) || /\-\\/.test(c));
}

function mix(receiver, supplier){
    for (var prop in supplier){
        if (supplier.hasOwnProperty(prop)){
            receiver[prop] = supplier[prop];
        }
    }
    return receiver;
}
function TokenStream(input){
    TokenStreamBase.call(this, input, Tokens);
}

TokenStream.prototype = mix(new TokenStreamBase(), {
    _getToken: function(channel){

        var c,
            reader = this._reader,
            token   = null,
            startLine   = reader.getLine(),
            startCol    = reader.getCol();

        c = reader.read();


        while(c){
            switch(c){
                case "/":

                    if(reader.peek() == "*"){
                        token = this.commentToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case "|":
                case "~":
                case "^":
                case "$":
                case "*":
                    if(reader.peek() == "="){
                        token = this.comparisonToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case "\"":
                case "'":
                    token = this.stringToken(c, startLine, startCol);
                    break;
                case "#":
                    if (isNameChar(reader.peek())){
                        token = this.hashToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case ".":
                    if (isDigit(reader.peek())){
                        token = this.numberToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case "-":
                    if (reader.peek() == "-"){  //could be closing HTML-style comment
                        token = this.htmlCommentEndToken(c, startLine, startCol);
                    } else if (isNameStart(reader.peek())){
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;
                case "!":
                    token = this.importantToken(c, startLine, startCol);
                    break;
                case "@":
                    token = this.atRuleToken(c, startLine, startCol);
                    break;
                case ":":
                    token = this.notToken(c, startLine, startCol);
                    break;
                case "<":
                    token = this.htmlCommentStartToken(c, startLine, startCol);
                    break;
                case "U":
                case "u":
                    if (reader.peek() == "+"){
                        token = this.unicodeRangeToken(c, startLine, startCol);
                        break;
                    }
                default:
                    if (isDigit(c)){
                        token = this.numberToken(c, startLine, startCol);
                    } else
                    if (isWhitespace(c)){
                        token = this.whitespaceToken(c, startLine, startCol);
                    } else
                    if (isIdentStart(c)){
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else
                    {
                        token = this.charToken(c, startLine, startCol);
                    }






            }
            break;
        }

        if (!token && c === null){
            token = this.createToken(Tokens.EOF,null,startLine,startCol);
        }

        return token;
    },
    createToken: function(tt, value, startLine, startCol, options){
        var reader = this._reader;
        options = options || {};

        return {
            value:      value,
            type:       tt,
            channel:    options.channel,
            endChar:    options.endChar,
            hide:       options.hide || false,
            startLine:  startLine,
            startCol:   startCol,
            endLine:    reader.getLine(),
            endCol:     reader.getCol()
        };
    },
    atRuleToken: function(first, startLine, startCol){
        var rule    = first,
            reader  = this._reader,
            tt      = Tokens.CHAR,
            valid   = false,
            ident,
            c;
        reader.mark();
        ident = this.readName();
        rule = first + ident;
        tt = Tokens.type(rule.toLowerCase());
        if (tt == Tokens.CHAR || tt == Tokens.UNKNOWN){
            if (rule.length > 1){
                tt = Tokens.UNKNOWN_SYM;
            } else {
                tt = Tokens.CHAR;
                rule = first;
                reader.reset();
            }
        }

        return this.createToken(tt, rule, startLine, startCol);
    },
    charToken: function(c, startLine, startCol){
        var tt = Tokens.type(c);
        var opts = {};

        if (tt == -1){
            tt = Tokens.CHAR;
        } else {
            opts.endChar = Tokens[tt].endChar;
        }

        return this.createToken(tt, c, startLine, startCol, opts);
    },
    commentToken: function(first, startLine, startCol){
        var reader  = this._reader,
            comment = this.readComment(first);

        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
    },
    comparisonToken: function(c, startLine, startCol){
        var reader  = this._reader,
            comparison  = c + reader.read(),
            tt      = Tokens.type(comparison) || Tokens.CHAR;

        return this.createToken(tt, comparison, startLine, startCol);
    },
    hashToken: function(first, startLine, startCol){
        var reader  = this._reader,
            name    = this.readName(first);

        return this.createToken(Tokens.HASH, name, startLine, startCol);
    },
    htmlCommentStartToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(3);

        if (text == "<!--"){
            return this.createToken(Tokens.CDO, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },
    htmlCommentEndToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(2);

        if (text == "-->"){
            return this.createToken(Tokens.CDC, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },
    identOrFunctionToken: function(first, startLine, startCol){
        var reader  = this._reader,
            ident   = this.readName(first),
            tt      = Tokens.IDENT;
        if (reader.peek() == "("){
            ident += reader.read();
            if (ident.toLowerCase() == "url("){
                tt = Tokens.URI;
                ident = this.readURI(ident);
                if (ident.toLowerCase() == "url("){
                    tt = Tokens.FUNCTION;
                }
            } else {
                tt = Tokens.FUNCTION;
            }
        } else if (reader.peek() == ":"){  //might be an IE function
            if (ident.toLowerCase() == "progid"){
                ident += reader.readTo("(");
                tt = Tokens.IE_FUNCTION;
            }
        }

        return this.createToken(tt, ident, startLine, startCol);
    },
    importantToken: function(first, startLine, startCol){
        var reader      = this._reader,
            important   = first,
            tt          = Tokens.CHAR,
            temp,
            c;

        reader.mark();
        c = reader.read();

        while(c){
            if (c == "/"){
                if (reader.peek() != "*"){
                    break;
                } else {
                    temp = this.readComment(c);
                    if (temp === ""){    //broken!
                        break;
                    }
                }
            } else if (isWhitespace(c)){
                important += c + this.readWhitespace();
            } else if (/i/i.test(c)){
                temp = reader.readCount(8);
                if (/mportant/i.test(temp)){
                    important += c + temp;
                    tt = Tokens.IMPORTANT_SYM;

                }
                break;  //we're done
            } else {
                break;
            }

            c = reader.read();
        }

        if (tt == Tokens.CHAR){
            reader.reset();
            return this.charToken(first, startLine, startCol);
        } else {
            return this.createToken(tt, important, startLine, startCol);
        }


    },
    notToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(4);

        if (text.toLowerCase() == ":not("){
            return this.createToken(Tokens.NOT, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },
    numberToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = this.readNumber(first),
            ident,
            tt      = Tokens.NUMBER,
            c       = reader.peek();

        if (isIdentStart(c)){
            ident = this.readName(reader.read());
            value += ident;

            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)){
                tt = Tokens.LENGTH;
            } else if (/^deg|^rad$|^grad$/i.test(ident)){
                tt = Tokens.ANGLE;
            } else if (/^ms$|^s$/i.test(ident)){
                tt = Tokens.TIME;
            } else if (/^hz$|^khz$/i.test(ident)){
                tt = Tokens.FREQ;
            } else if (/^dpi$|^dpcm$/i.test(ident)){
                tt = Tokens.RESOLUTION;
            } else {
                tt = Tokens.DIMENSION;
            }

        } else if (c == "%"){
            value += reader.read();
            tt = Tokens.PERCENTAGE;
        }

        return this.createToken(tt, value, startLine, startCol);
    },
    stringToken: function(first, startLine, startCol){
        var delim   = first,
            string  = first,
            reader  = this._reader,
            prev    = first,
            tt      = Tokens.STRING,
            c       = reader.read();

        while(c){
            string += c;
            if (c == delim && prev != "\\"){
                break;
            }
            if (isNewLine(reader.peek()) && c != "\\"){
                tt = Tokens.INVALID;
                break;
            }
            prev = c;
            c = reader.read();
        }
        if (c === null){
            tt = Tokens.INVALID;
        }

        return this.createToken(tt, string, startLine, startCol);
    },

    unicodeRangeToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = first,
            temp,
            tt      = Tokens.CHAR;
        if (reader.peek() == "+"){
            reader.mark();
            value += reader.read();
            value += this.readUnicodeRangePart(true);
            if (value.length == 2){
                reader.reset();
            } else {

                tt = Tokens.UNICODE_RANGE;
                if (value.indexOf("?") == -1){

                    if (reader.peek() == "-"){
                        reader.mark();
                        temp = reader.read();
                        temp += this.readUnicodeRangePart(false);
                        if (temp.length == 1){
                            reader.reset();
                        } else {
                            value += temp;
                        }
                    }

                }
            }
        }

        return this.createToken(tt, value, startLine, startCol);
    },
    whitespaceToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = first + this.readWhitespace();
        return this.createToken(Tokens.S, value, startLine, startCol);
    },
    readUnicodeRangePart: function(allowQuestionMark){
        var reader  = this._reader,
            part = "",
            c       = reader.peek();
        while(isHexDigit(c) && part.length < 6){
            reader.read();
            part += c;
            c = reader.peek();
        }
        if (allowQuestionMark){
            while(c == "?" && part.length < 6){
                reader.read();
                part += c;
                c = reader.peek();
            }
        }
        return part;
    },

    readWhitespace: function(){
        var reader  = this._reader,
            whitespace = "",
            c       = reader.peek();

        while(isWhitespace(c)){
            reader.read();
            whitespace += c;
            c = reader.peek();
        }

        return whitespace;
    },
    readNumber: function(first){
        var reader  = this._reader,
            number  = first,
            hasDot  = (first == "."),
            c       = reader.peek();


        while(c){
            if (isDigit(c)){
                number += reader.read();
            } else if (c == "."){
                if (hasDot){
                    break;
                } else {
                    hasDot = true;
                    number += reader.read();
                }
            } else {
                break;
            }

            c = reader.peek();
        }

        return number;
    },
    readString: function(){
        var reader  = this._reader,
            delim   = reader.read(),
            string  = delim,
            prev    = delim,
            c       = reader.peek();

        while(c){
            c = reader.read();
            string += c;
            if (c == delim && prev != "\\"){
                break;
            }
            if (isNewLine(reader.peek()) && c != "\\"){
                string = "";
                break;
            }
            prev = c;
            c = reader.peek();
        }
        if (c === null){
            string = "";
        }

        return string;
    },
    readURI: function(first){
        var reader  = this._reader,
            uri     = first,
            inner   = "",
            c       = reader.peek();

        reader.mark();
        while(c && isWhitespace(c)){
            reader.read();
            c = reader.peek();
        }
        if (c == "'" || c == "\""){
            inner = this.readString();
        } else {
            inner = this.readURL();
        }

        c = reader.peek();
        while(c && isWhitespace(c)){
            reader.read();
            c = reader.peek();
        }
        if (inner === "" || c != ")"){
            uri = first;
            reader.reset();
        } else {
            uri += inner + reader.read();
        }

        return uri;
    },
    readURL: function(){
        var reader  = this._reader,
            url     = "",
            c       = reader.peek();
        while (/^[!#$%&\\*-~]$/.test(c)){
            url += reader.read();
            c = reader.peek();
        }

        return url;

    },
    readName: function(first){
        var reader  = this._reader,
            ident   = first || "",
            c       = reader.peek();

        while(true){
            if (c == "\\"){
                ident += this.readEscape(reader.read());
                c = reader.peek();
            } else if(c && isNameChar(c)){
                ident += reader.read();
                c = reader.peek();
            } else {
                break;
            }
        }

        return ident;
    },

    readEscape: function(first){
        var reader  = this._reader,
            cssEscape = first || "",
            i       = 0,
            c       = reader.peek();

        if (isHexDigit(c)){
            do {
                cssEscape += reader.read();
                c = reader.peek();
            } while(c && isHexDigit(c) && ++i < 6);
        }

        if (cssEscape.length == 3 && /\s/.test(c) ||
            cssEscape.length == 7 || cssEscape.length == 1){
                reader.read();
        } else {
            c = "";
        }

        return cssEscape + c;
    },

    readComment: function(first){
        var reader  = this._reader,
            comment = first || "",
            c       = reader.read();

        if (c == "*"){
            while(c){
                comment += c;
                if (comment.length > 2 && c == "*" && reader.peek() == "/"){
                    comment += reader.read();
                    break;
                }

                c = reader.read();
            }

            return comment;
        } else {
            return "";
        }

    }
});

var Tokens  = [
    { name: "CDO"},
    { name: "CDC"},
    { name: "S", whitespace: true/*, channel: "ws"*/},
    { name: "COMMENT", comment: true, hide: true, channel: "comment" },
    { name: "INCLUDES", text: "~="},
    { name: "DASHMATCH", text: "|="},
    { name: "PREFIXMATCH", text: "^="},
    { name: "SUFFIXMATCH", text: "$="},
    { name: "SUBSTRINGMATCH", text: "*="},
    { name: "STRING"},
    { name: "IDENT"},
    { name: "HASH"},
    { name: "IMPORT_SYM", text: "@import"},
    { name: "PAGE_SYM", text: "@page"},
    { name: "MEDIA_SYM", text: "@media"},
    { name: "FONT_FACE_SYM", text: "@font-face"},
    { name: "CHARSET_SYM", text: "@charset"},
    { name: "NAMESPACE_SYM", text: "@namespace"},
    { name: "VIEWPORT_SYM", text: ["@viewport", "@-ms-viewport"]},
    { name: "UNKNOWN_SYM" },
    { name: "KEYFRAMES_SYM", text: [ "@keyframes", "@-webkit-keyframes", "@-moz-keyframes", "@-o-keyframes" ] },
    { name: "IMPORTANT_SYM"},
    { name: "LENGTH"},
    { name: "ANGLE"},
    { name: "TIME"},
    { name: "FREQ"},
    { name: "DIMENSION"},
    { name: "PERCENTAGE"},
    { name: "NUMBER"},
    { name: "URI"},
    { name: "FUNCTION"},
    { name: "UNICODE_RANGE"},
    { name: "INVALID"},
    { name: "PLUS", text: "+" },
    { name: "GREATER", text: ">"},
    { name: "COMMA", text: ","},
    { name: "TILDE", text: "~"},
    { name: "NOT"},
    { name: "TOPLEFTCORNER_SYM", text: "@top-left-corner"},
    { name: "TOPLEFT_SYM", text: "@top-left"},
    { name: "TOPCENTER_SYM", text: "@top-center"},
    { name: "TOPRIGHT_SYM", text: "@top-right"},
    { name: "TOPRIGHTCORNER_SYM", text: "@top-right-corner"},
    { name: "BOTTOMLEFTCORNER_SYM", text: "@bottom-left-corner"},
    { name: "BOTTOMLEFT_SYM", text: "@bottom-left"},
    { name: "BOTTOMCENTER_SYM", text: "@bottom-center"},
    { name: "BOTTOMRIGHT_SYM", text: "@bottom-right"},
    { name: "BOTTOMRIGHTCORNER_SYM", text: "@bottom-right-corner"},
    { name: "LEFTTOP_SYM", text: "@left-top"},
    { name: "LEFTMIDDLE_SYM", text: "@left-middle"},
    { name: "LEFTBOTTOM_SYM", text: "@left-bottom"},
    { name: "RIGHTTOP_SYM", text: "@right-top"},
    { name: "RIGHTMIDDLE_SYM", text: "@right-middle"},
    { name: "RIGHTBOTTOM_SYM", text: "@right-bottom"},
    { name: "RESOLUTION", state: "media"},
    { name: "IE_FUNCTION" },
    { name: "CHAR" },
    {
        name: "PIPE",
        text: "|"
    },
    {
        name: "SLASH",
        text: "/"
    },
    {
        name: "MINUS",
        text: "-"
    },
    {
        name: "STAR",
        text: "*"
    },

    {
        name: "LBRACE",
        endChar: "}",
        text: "{"
    },
    {
        name: "RBRACE",
        text: "}"
    },
    {
        name: "LBRACKET",
        endChar: "]",
        text: "["
    },
    {
        name: "RBRACKET",
        text: "]"
    },
    {
        name: "EQUALS",
        text: "="
    },
    {
        name: "COLON",
        text: ":"
    },
    {
        name: "SEMICOLON",
        text: ";"
    },

    {
        name: "LPAREN",
        endChar: ")",
        text: "("
    },
    {
        name: "RPAREN",
        text: ")"
    },
    {
        name: "DOT",
        text: "."
    }
];

(function(){

    var nameMap = [],
        typeMap = {};

    Tokens.UNKNOWN = -1;
    Tokens.unshift({name:"EOF"});
    for (var i=0, len = Tokens.length; i < len; i++){
        nameMap.push(Tokens[i].name);
        Tokens[Tokens[i].name] = i;
        if (Tokens[i].text){
            if (Tokens[i].text instanceof Array){
                for (var j=0; j < Tokens[i].text.length; j++){
                    typeMap[Tokens[i].text[j]] = i;
                }
            } else {
                typeMap[Tokens[i].text] = i;
            }
        }
    }

    Tokens.name = function(tt){
        return nameMap[tt];
    };

    Tokens.type = function(c){
        return typeMap[c] || -1;
    };

})();
var Validation = {

    validate: function(property, value){
        var name        = property.toString().toLowerCase(),
            parts       = value.parts,
            expression  = new PropertyValueIterator(value),
            spec        = Properties[name],
            part,
            valid,
            j, count,
            msg,
            types,
            last,
            literals,
            max, multi, group;

        if (!spec) {
            if (name.indexOf("-") !== 0){    //vendor prefixed are ok
                throw new ValidationError("Unknown property '" + property + "'.", property.line, property.col);
            }
        } else if (typeof spec != "number"){
            if (typeof spec == "string"){
                if (spec.indexOf("||") > -1) {
                    this.groupProperty(spec, expression);
                } else {
                    this.singleProperty(spec, expression, 1);
                }

            } else if (spec.multi) {
                this.multiProperty(spec.multi, expression, spec.comma, spec.max || Infinity);
            } else if (typeof spec == "function") {
                spec(expression);
            }

        }

    },

    singleProperty: function(types, expression, max, partial) {

        var result      = false,
            value       = expression.value,
            count       = 0,
            part;

        while (expression.hasNext() && count < max) {
            result = ValidationTypes.isAny(expression, types);
            if (!result) {
                break;
            }
            count++;
        }

        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                 throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }

    },

    multiProperty: function (types, expression, comma, max) {

        var result      = false,
            value       = expression.value,
            count       = 0,
            sep         = false,
            part;

        while(expression.hasNext() && !result && count < max) {
            if (ValidationTypes.isAny(expression, types)) {
                count++;
                if (!expression.hasNext()) {
                    result = true;

                } else if (comma) {
                    if (expression.peek() == ",") {
                        part = expression.next();
                    } else {
                        break;
                    }
                }
            } else {
                break;

            }
        }

        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                part = expression.previous();
                if (comma && part == ",") {
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                } else {
                    throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
                }
            }

        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }

    },

    groupProperty: function (types, expression, comma) {

        var result      = false,
            value       = expression.value,
            typeCount   = types.split("||").length,
            groups      = { count: 0 },
            partial     = false,
            name,
            part;

        while(expression.hasNext() && !result) {
            name = ValidationTypes.isAnyOfGroup(expression, types);
            if (name) {
                if (groups[name]) {
                    break;
                } else {
                    groups[name] = 1;
                    groups.count++;
                    partial = true;

                    if (groups.count == typeCount || !expression.hasNext()) {
                        result = true;
                    }
                }
            } else {
                break;
            }
        }

        if (!result) {
            if (partial && expression.hasNext()) {
                    part = expression.peek();
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }
    }



};
function ValidationError(message, line, col){
    this.col = col;
    this.line = line;
    this.message = message;

}
ValidationError.prototype = new Error();
var ValidationTypes = {

    isLiteral: function (part, literals) {
        var text = part.text.toString().toLowerCase(),
            args = literals.split(" | "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found; i++){
            if (text == args[i].toLowerCase()){
                found = true;
            }
        }

        return found;
    },

    isSimple: function(type) {
        return !!this.simple[type];
    },

    isComplex: function(type) {
        return !!this.complex[type];
    },
    isAny: function (expression, types) {
        var args = types.split(" | "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found && expression.hasNext(); i++){
            found = this.isType(expression, args[i]);
        }

        return found;
    },
    isAnyOfGroup: function(expression, types) {
        var args = types.split(" || "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found; i++){
            found = this.isType(expression, args[i]);
        }

        return found ? args[i-1] : false;
    },
    isType: function (expression, type) {
        var part = expression.peek(),
            result = false;

        if (type.charAt(0) != "<") {
            result = this.isLiteral(part, type);
            if (result) {
                expression.next();
            }
        } else if (this.simple[type]) {
            result = this.simple[type](part);
            if (result) {
                expression.next();
            }
        } else {
            result = this.complex[type](expression);
        }

        return result;
    },



    simple: {

        "<absolute-size>": function(part){
            return ValidationTypes.isLiteral(part, "xx-small | x-small | small | medium | large | x-large | xx-large");
        },

        "<attachment>": function(part){
            return ValidationTypes.isLiteral(part, "scroll | fixed | local");
        },

        "<attr>": function(part){
            return part.type == "function" && part.name == "attr";
        },

        "<bg-image>": function(part){
            return this["<image>"](part) || this["<gradient>"](part) ||  part == "none";
        },

        "<gradient>": function(part) {
            return part.type == "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?(?:repeating\-)?(?:radial\-|linear\-)?gradient/i.test(part);
        },

        "<box>": function(part){
            return ValidationTypes.isLiteral(part, "padding-box | border-box | content-box");
        },

        "<content>": function(part){
            return part.type == "function" && part.name == "content";
        },

        "<relative-size>": function(part){
            return ValidationTypes.isLiteral(part, "smaller | larger");
        },
        "<ident>": function(part){
            return part.type == "identifier";
        },

        "<length>": function(part){
            if (part.type == "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?calc/i.test(part)){
                return true;
            }else{
                return part.type == "length" || part.type == "number" || part.type == "integer" || part == "0";
            }
        },

        "<color>": function(part){
            return part.type == "color" || part == "transparent";
        },

        "<number>": function(part){
            return part.type == "number" || this["<integer>"](part);
        },

        "<integer>": function(part){
            return part.type == "integer";
        },

        "<line>": function(part){
            return part.type == "integer";
        },

        "<angle>": function(part){
            return part.type == "angle";
        },

        "<uri>": function(part){
            return part.type == "uri";
        },

        "<image>": function(part){
            return this["<uri>"](part);
        },

        "<percentage>": function(part){
            return part.type == "percentage" || part == "0";
        },

        "<border-width>": function(part){
            return this["<length>"](part) || ValidationTypes.isLiteral(part, "thin | medium | thick");
        },

        "<border-style>": function(part){
            return ValidationTypes.isLiteral(part, "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset");
        },

        "<content-sizing>": function(part){ // http://www.w3.org/TR/css3-sizing/#width-height-keywords
            return ValidationTypes.isLiteral(part, "fill-available | -moz-available | -webkit-fill-available | max-content | -moz-max-content | -webkit-max-content | min-content | -moz-min-content | -webkit-min-content | fit-content | -moz-fit-content | -webkit-fit-content");
        },

        "<margin-width>": function(part){
            return this["<length>"](part) || this["<percentage>"](part) || ValidationTypes.isLiteral(part, "auto");
        },

        "<padding-width>": function(part){
            return this["<length>"](part) || this["<percentage>"](part);
        },

        "<shape>": function(part){
            return part.type == "function" && (part.name == "rect" || part.name == "inset-rect");
        },

        "<time>": function(part) {
            return part.type == "time";
        },

        "<flex-grow>": function(part){
            return this["<number>"](part);
        },

        "<flex-shrink>": function(part){
            return this["<number>"](part);
        },

        "<width>": function(part){
            return this["<margin-width>"](part);
        },

        "<flex-basis>": function(part){
            return this["<width>"](part);
        },

        "<flex-direction>": function(part){
            return ValidationTypes.isLiteral(part, "row | row-reverse | column | column-reverse");
        },

        "<flex-wrap>": function(part){
            return ValidationTypes.isLiteral(part, "nowrap | wrap | wrap-reverse");
        }
    },

    complex: {

        "<bg-position>": function(expression){
            var types   = this,
                result  = false,
                numeric = "<percentage> | <length>",
                xDir    = "left | right",
                yDir    = "top | bottom",
                count = 0,
                hasNext = function() {
                    return expression.hasNext() && expression.peek() != ",";
                };

            while (expression.peek(count) && expression.peek(count) != ",") {
                count++;
            }

            if (count < 3) {
                if (ValidationTypes.isAny(expression, xDir + " | center | " + numeric)) {
                        result = true;
                        ValidationTypes.isAny(expression, yDir + " | center | " + numeric);
                } else if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, xDir + " | center");
                }
            } else {
                if (ValidationTypes.isAny(expression, xDir)) {
                    if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    } else if (ValidationTypes.isAny(expression, numeric)) {
                        if (ValidationTypes.isAny(expression, yDir)) {
                            result = true;
                            ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, "center")) {
                            result = true;
                        }
                    }
                } else if (ValidationTypes.isAny(expression, yDir)) {
                    if (ValidationTypes.isAny(expression, xDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    } else if (ValidationTypes.isAny(expression, numeric)) {
                        if (ValidationTypes.isAny(expression, xDir)) {
                                result = true;
                                ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, "center")) {
                            result = true;
                        }
                    }
                } else if (ValidationTypes.isAny(expression, "center")) {
                    if (ValidationTypes.isAny(expression, xDir + " | " + yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    }
                }
            }

            return result;
        },

        "<bg-size>": function(expression){
            var types   = this,
                result  = false,
                numeric = "<percentage> | <length> | auto",
                part,
                i, len;

            if (ValidationTypes.isAny(expression, "cover | contain")) {
                result = true;
            } else if (ValidationTypes.isAny(expression, numeric)) {
                result = true;
                ValidationTypes.isAny(expression, numeric);
            }

            return result;
        },

        "<repeat-style>": function(expression){
            var result  = false,
                values  = "repeat | space | round | no-repeat",
                part;

            if (expression.hasNext()){
                part = expression.next();

                if (ValidationTypes.isLiteral(part, "repeat-x | repeat-y")) {
                    result = true;
                } else if (ValidationTypes.isLiteral(part, values)) {
                    result = true;

                    if (expression.hasNext() && ValidationTypes.isLiteral(expression.peek(), values)) {
                        expression.next();
                    }
                }
            }

            return result;

        },

        "<shadow>": function(expression) {
            var result  = false,
                count   = 0,
                inset   = false,
                color   = false,
                part;

            if (expression.hasNext()) {

                if (ValidationTypes.isAny(expression, "inset")){
                    inset = true;
                }

                if (ValidationTypes.isAny(expression, "<color>")) {
                    color = true;
                }

                while (ValidationTypes.isAny(expression, "<length>") && count < 4) {
                    count++;
                }


                if (expression.hasNext()) {
                    if (!color) {
                        ValidationTypes.isAny(expression, "<color>");
                    }

                    if (!inset) {
                        ValidationTypes.isAny(expression, "inset");
                    }

                }

                result = (count >= 2 && count <= 4);

            }

            return result;
        },

        "<x-one-radius>": function(expression) {
            var result  = false,
                simple = "<length> | <percentage> | inherit";

            if (ValidationTypes.isAny(expression, simple)){
                result = true;
                ValidationTypes.isAny(expression, simple);
            }

            return result;
        },

        "<flex>": function(expression) {
            var part,
                result = false;
            if (ValidationTypes.isAny(expression, "none | inherit")) {
                result = true;
            } else {
                if (ValidationTypes.isType(expression, "<flex-grow>")) {
                    if (expression.peek()) {
                        if (ValidationTypes.isType(expression, "<flex-shrink>")) {
                            if (expression.peek()) {
                                result = ValidationTypes.isType(expression, "<flex-basis>");
                            } else {
                                result = true;
                            }
                        } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                            result = expression.peek() === null;
                        }
                    } else {
                        result = true;
                    }
                } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                    result = true;
                }
            }

            if (!result) {
                part = expression.peek();
                throw new ValidationError("Expected (none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]) but found '" + expression.value.text + "'.", part.line, part.col);
            }

            return result;
        }
    }
};

parserlib.css = {
Colors              :Colors,
Combinator          :Combinator,
Parser              :Parser,
PropertyName        :PropertyName,
PropertyValue       :PropertyValue,
PropertyValuePart   :PropertyValuePart,
MediaFeature        :MediaFeature,
MediaQuery          :MediaQuery,
Selector            :Selector,
SelectorPart        :SelectorPart,
SelectorSubPart     :SelectorSubPart,
Specificity         :Specificity,
TokenStream         :TokenStream,
Tokens              :Tokens,
ValidationError     :ValidationError
};
})();

(function(){
for(var prop in parserlib){
exports[prop] = parserlib[prop];
}
})();


function objectToString(o) {
  return Object.prototype.toString.call(o);
}
var util = {
  isArray: function (ar) {
    return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');
  },
  isDate: function (d) {
    return typeof d === 'object' && objectToString(d) === '[object Date]';
  },
  isRegExp: function (re) {
    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
  },
  getRegExpFlags: function (re) {
    var flags = '';
    re.global && (flags += 'g');
    re.ignoreCase && (flags += 'i');
    re.multiline && (flags += 'm');
    return flags;
  }
};


if (typeof module === 'object')
  module.exports = clone;

function clone(parent, circular, depth, prototype) {
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;
  function _clone(parent, depth) {
    if (parent === null)
      return null;

    if (depth == 0)
      return parent;

    var child;
    if (typeof parent != 'object') {
      return parent;
    }

    if (util.isArray(parent)) {
      child = [];
    } else if (util.isRegExp(parent)) {
      child = new RegExp(parent.source, util.getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (util.isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      child = new Buffer(parent.length);
      parent.copy(child);
      return child;
    } else {
      if (typeof prototype == 'undefined') child = Object.create(Object.getPrototypeOf(parent));
      else child = Object.create(prototype);
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    for (var i in parent) {
      child[i] = _clone(parent[i], depth - 1);
    }

    return child;
  }

  return _clone(parent, depth);
}
clone.clonePrototype = function(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

var CSSLint = (function(){

    var rules           = [],
        formatters      = [],
        embeddedRuleset = /\/\*csslint([^\*]*)\*\//,
        api             = new parserlib.util.EventTarget();

    api.version = "@VERSION@";
    api.addRule = function(rule){
        rules.push(rule);
        rules[rule.id] = rule;
    };
    api.clearRules = function(){
        rules = [];
    };
    api.getRules = function(){
        return [].concat(rules).sort(function(a,b){
            return a.id > b.id ? 1 : 0;
        });
    };
    api.getRuleset = function() {
        var ruleset = {},
            i = 0,
            len = rules.length;

        while (i < len){
            ruleset[rules[i++].id] = 1;    //by default, everything is a warning
        }

        return ruleset;
    };
    function applyEmbeddedRuleset(text, ruleset){
        var valueMap,
            embedded = text && text.match(embeddedRuleset),
            rules = embedded && embedded[1];

        if (rules) {
            valueMap = {
                "true": 2,  // true is error
                "": 1,      // blank is warning
                "false": 0, // false is ignore

                "2": 2,     // explicit error
                "1": 1,     // explicit warning
                "0": 0      // explicit ignore
            };

            rules.toLowerCase().split(",").forEach(function(rule){
                var pair = rule.split(":"),
                    property = pair[0] || "",
                    value = pair[1] || "";

                ruleset[property.trim()] = valueMap[value.trim()];
            });
        }

        return ruleset;
    }
    api.addFormatter = function(formatter) {
        formatters[formatter.id] = formatter;
    };
    api.getFormatter = function(formatId){
        return formatters[formatId];
    };
    api.format = function(results, filename, formatId, options) {
        var formatter = this.getFormatter(formatId),
            result = null;

        if (formatter){
            result = formatter.startFormat();
            result += formatter.formatResults(results, filename, options || {});
            result += formatter.endFormat();
        }

        return result;
    };
    api.hasFormat = function(formatId){
        return formatters.hasOwnProperty(formatId);
    };
    api.verify = function(text, ruleset){

        var i = 0,
            reporter,
            lines,
            report,
            parser = new parserlib.css.Parser({ starHack: true, ieFilters: true,
                                                underscoreHack: true, strict: false });
        lines = text.replace(/\n\r?/g, "$split$").split("$split$");

        if (!ruleset){
            ruleset = this.getRuleset();
        }

        if (embeddedRuleset.test(text)){
            ruleset = clone(ruleset);
            ruleset = applyEmbeddedRuleset(text, ruleset);
        }

        reporter = new Reporter(lines, ruleset);

        ruleset.errors = 2;       //always report parsing errors as errors
        for (i in ruleset){
            if(ruleset.hasOwnProperty(i) && ruleset[i]){
                if (rules[i]){
                    rules[i].init(parser, reporter);
                }
            }
        }
        try {
            parser.parse(text);
        } catch (ex) {
            reporter.error("Fatal error, cannot continue: " + ex.message, ex.line, ex.col, {});
        }

        report = {
            messages    : reporter.messages,
            stats       : reporter.stats,
            ruleset     : reporter.ruleset
        };
        report.messages.sort(function (a, b){
            if (a.rollup && !b.rollup){
                return 1;
            } else if (!a.rollup && b.rollup){
                return -1;
            } else {
                return a.line - b.line;
            }
        });

        return report;
    };
    return api;

})();
function Reporter(lines, ruleset){
    this.messages = [];
    this.stats = [];
    this.lines = lines;
    this.ruleset = ruleset;
}

Reporter.prototype = {
    constructor: Reporter,
    error: function(message, line, col, rule){
        this.messages.push({
            type    : "error",
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule || {}
        });
    },
    warn: function(message, line, col, rule){
        this.report(message, line, col, rule);
    },
    report: function(message, line, col, rule){
        this.messages.push({
            type    : this.ruleset[rule.id] === 2 ? "error" : "warning",
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule
        });
    },
    info: function(message, line, col, rule){
        this.messages.push({
            type    : "info",
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule
        });
    },
    rollupError: function(message, rule){
        this.messages.push({
            type    : "error",
            rollup  : true,
            message : message,
            rule    : rule
        });
    },
    rollupWarn: function(message, rule){
        this.messages.push({
            type    : "warning",
            rollup  : true,
            message : message,
            rule    : rule
        });
    },
    stat: function(name, value){
        this.stats[name] = value;
    }
};
CSSLint._Reporter = Reporter;
CSSLint.Util = {
    mix: function(receiver, supplier){
        var prop;

        for (prop in supplier){
            if (supplier.hasOwnProperty(prop)){
                receiver[prop] = supplier[prop];
            }
        }

        return prop;
    },
    indexOf: function(values, value){
        if (values.indexOf){
            return values.indexOf(value);
        } else {
            for (var i=0, len=values.length; i < len; i++){
                if (values[i] === value){
                    return i;
                }
            }
            return -1;
        }
    },
    forEach: function(values, func) {
        if (values.forEach){
            return values.forEach(func);
        } else {
            for (var i=0, len=values.length; i < len; i++){
                func(values[i], i, values);
            }
        }
    }
};

CSSLint.addRule({
    id: "adjoining-classes",
    name: "Disallow adjoining classes",
    desc: "Don't use adjoining classes.",
    browsers: "IE6",
    init: function(parser, reporter){
        var rule = this;
        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                classCount,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE){
                        classCount = 0;
                        for (k=0; k < part.modifiers.length; k++){
                            modifier = part.modifiers[k];
                            if (modifier.type === "class"){
                                classCount++;
                            }
                            if (classCount > 1){
                                reporter.report("Don't use adjoining classes.", part.line, part.col, rule);
                            }
                        }
                    }
                }
            }
        });
    }

});
CSSLint.addRule({
    id: "box-model",
    name: "Beware of broken box size",
    desc: "Don't use width or height when using padding or border.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            widthProperties = {
                border: 1,
                "border-left": 1,
                "border-right": 1,
                padding: 1,
                "padding-left": 1,
                "padding-right": 1
            },
            heightProperties = {
                border: 1,
                "border-bottom": 1,
                "border-top": 1,
                padding: 1,
                "padding-bottom": 1,
                "padding-top": 1
            },
            properties,
            boxSizing = false;

        function startRule(){
            properties = {};
            boxSizing = false;
        }

        function endRule(){
            var prop, value;

            if (!boxSizing) {
                if (properties.height){
                    for (prop in heightProperties){
                        if (heightProperties.hasOwnProperty(prop) && properties[prop]){
                            value = properties[prop].value;
                            if (!(prop === "padding" && value.parts.length === 2 && value.parts[0].value === 0)){
                                reporter.report("Using height with " + prop + " can sometimes make elements larger than you expect.", properties[prop].line, properties[prop].col, rule);
                            }
                        }
                    }
                }

                if (properties.width){
                    for (prop in widthProperties){
                        if (widthProperties.hasOwnProperty(prop) && properties[prop]){
                            value = properties[prop].value;

                            if (!(prop === "padding" && value.parts.length === 2 && value.parts[1].value === 0)){
                                reporter.report("Using width with " + prop + " can sometimes make elements larger than you expect.", properties[prop].line, properties[prop].col, rule);
                            }
                        }
                    }
                }
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();

            if (heightProperties[name] || widthProperties[name]){
                if (!/^0\S*$/.test(event.value) && !(name === "border" && event.value.toString() === "none")){
                    properties[name] = { line: event.property.line, col: event.property.col, value: event.value };
                }
            } else {
                if (/^(width|height)/i.test(name) && /^(length|percentage)/.test(event.value.parts[0].type)){
                    properties[name] = 1;
                } else if (name === "box-sizing") {
                    boxSizing = true;
                }
            }

        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule);
    }

});

CSSLint.addRule({
    id: "box-sizing",
    name: "Disallow use of box-sizing",
    desc: "The box-sizing properties isn't supported in IE6 and IE7.",
    browsers: "IE6, IE7",
    tags: ["Compatibility"],
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();

            if (name === "box-sizing"){
                reporter.report("The box-sizing property isn't supported in IE6 and IE7.", event.line, event.col, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "bulletproof-font-face",
    name: "Use the bulletproof @font-face syntax",
    desc: "Use the bulletproof @font-face syntax to avoid 404's in old IE (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax).",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            fontFaceRule = false,
            firstSrc     = true,
            ruleFailed    = false,
            line, col;
        parser.addListener("startfontface", function(){
            fontFaceRule = true;
        });

        parser.addListener("property", function(event){
            if (!fontFaceRule) {
                return;
            }

            var propertyName = event.property.toString().toLowerCase(),
                value        = event.value.toString();
            line = event.line;
            col  = event.col;
            if (propertyName === "src") {
                var regex = /^\s?url\(['"].+\.eot\?.*['"]\)\s*format\(['"]embedded-opentype['"]\).*$/i;
                if (!value.match(regex) && firstSrc) {
                    ruleFailed = true;
                    firstSrc = false;
                } else if (value.match(regex) && !firstSrc) {
                    ruleFailed = false;
                }
            }


        });
        parser.addListener("endfontface", function(){
            fontFaceRule = false;

            if (ruleFailed) {
                reporter.report("@font-face declaration doesn't follow the fontspring bulletproof syntax.", line, col, rule);
            }
        });
    }
});

CSSLint.addRule({
    id: "compatible-vendor-prefixes",
    name: "Require compatible vendor prefixes",
    desc: "Include all compatible vendor prefixes to reach a wider range of users.",
    browsers: "All",
    init: function (parser, reporter) {
        var rule = this,
            compatiblePrefixes,
            properties,
            prop,
            variations,
            prefixed,
            i,
            len,
            inKeyFrame = false,
            arrayPush = Array.prototype.push,
            applyTo = [];
        compatiblePrefixes = {
            "animation"                  : "webkit moz",
            "animation-delay"            : "webkit moz",
            "animation-direction"        : "webkit moz",
            "animation-duration"         : "webkit moz",
            "animation-fill-mode"        : "webkit moz",
            "animation-iteration-count"  : "webkit moz",
            "animation-name"             : "webkit moz",
            "animation-play-state"       : "webkit moz",
            "animation-timing-function"  : "webkit moz",
            "appearance"                 : "webkit moz",
            "border-end"                 : "webkit moz",
            "border-end-color"           : "webkit moz",
            "border-end-style"           : "webkit moz",
            "border-end-width"           : "webkit moz",
            "border-image"               : "webkit moz o",
            "border-radius"              : "webkit",
            "border-start"               : "webkit moz",
            "border-start-color"         : "webkit moz",
            "border-start-style"         : "webkit moz",
            "border-start-width"         : "webkit moz",
            "box-align"                  : "webkit moz ms",
            "box-direction"              : "webkit moz ms",
            "box-flex"                   : "webkit moz ms",
            "box-lines"                  : "webkit ms",
            "box-ordinal-group"          : "webkit moz ms",
            "box-orient"                 : "webkit moz ms",
            "box-pack"                   : "webkit moz ms",
            "box-sizing"                 : "webkit moz",
            "box-shadow"                 : "webkit moz",
            "column-count"               : "webkit moz ms",
            "column-gap"                 : "webkit moz ms",
            "column-rule"                : "webkit moz ms",
            "column-rule-color"          : "webkit moz ms",
            "column-rule-style"          : "webkit moz ms",
            "column-rule-width"          : "webkit moz ms",
            "column-width"               : "webkit moz ms",
            "hyphens"                    : "epub moz",
            "line-break"                 : "webkit ms",
            "margin-end"                 : "webkit moz",
            "margin-start"               : "webkit moz",
            "marquee-speed"              : "webkit wap",
            "marquee-style"              : "webkit wap",
            "padding-end"                : "webkit moz",
            "padding-start"              : "webkit moz",
            "tab-size"                   : "moz o",
            "text-size-adjust"           : "webkit ms",
            "transform"                  : "webkit moz ms o",
            "transform-origin"           : "webkit moz ms o",
            "transition"                 : "webkit moz o",
            "transition-delay"           : "webkit moz o",
            "transition-duration"        : "webkit moz o",
            "transition-property"        : "webkit moz o",
            "transition-timing-function" : "webkit moz o",
            "user-modify"                : "webkit moz",
            "user-select"                : "webkit moz ms",
            "word-break"                 : "epub ms",
            "writing-mode"               : "epub ms"
        };


        for (prop in compatiblePrefixes) {
            if (compatiblePrefixes.hasOwnProperty(prop)) {
                variations = [];
                prefixed = compatiblePrefixes[prop].split(" ");
                for (i = 0, len = prefixed.length; i < len; i++) {
                    variations.push("-" + prefixed[i] + "-" + prop);
                }
                compatiblePrefixes[prop] = variations;
                arrayPush.apply(applyTo, variations);
            }
        }

        parser.addListener("startrule", function () {
            properties = [];
        });

        parser.addListener("startkeyframes", function (event) {
            inKeyFrame = event.prefix || true;
        });

        parser.addListener("endkeyframes", function () {
            inKeyFrame = false;
        });

        parser.addListener("property", function (event) {
            var name = event.property;
            if (CSSLint.Util.indexOf(applyTo, name.text) > -1) {
                if (!inKeyFrame || typeof inKeyFrame !== "string" ||
                        name.text.indexOf("-" + inKeyFrame + "-") !== 0) {
                    properties.push(name);
                }
            }
        });

        parser.addListener("endrule", function () {
            if (!properties.length) {
                return;
            }

            var propertyGroups = {},
                i,
                len,
                name,
                prop,
                variations,
                value,
                full,
                actual,
                item,
                propertiesSpecified;

            for (i = 0, len = properties.length; i < len; i++) {
                name = properties[i];

                for (prop in compatiblePrefixes) {
                    if (compatiblePrefixes.hasOwnProperty(prop)) {
                        variations = compatiblePrefixes[prop];
                        if (CSSLint.Util.indexOf(variations, name.text) > -1) {
                            if (!propertyGroups[prop]) {
                                propertyGroups[prop] = {
                                    full : variations.slice(0),
                                    actual : [],
                                    actualNodes: []
                                };
                            }
                            if (CSSLint.Util.indexOf(propertyGroups[prop].actual, name.text) === -1) {
                                propertyGroups[prop].actual.push(name.text);
                                propertyGroups[prop].actualNodes.push(name);
                            }
                        }
                    }
                }
            }

            for (prop in propertyGroups) {
                if (propertyGroups.hasOwnProperty(prop)) {
                    value = propertyGroups[prop];
                    full = value.full;
                    actual = value.actual;

                    if (full.length > actual.length) {
                        for (i = 0, len = full.length; i < len; i++) {
                            item = full[i];
                            if (CSSLint.Util.indexOf(actual, item) === -1) {
                                propertiesSpecified = (actual.length === 1) ? actual[0] : (actual.length === 2) ? actual.join(" and ") : actual.join(", ");
                                reporter.report("The property " + item + " is compatible with " + propertiesSpecified + " and should be included as well.", value.actualNodes[0].line, value.actualNodes[0].col, rule);
                            }
                        }

                    }
                }
            }
        });
    }
});

CSSLint.addRule({
    id: "display-property-grouping",
    name: "Require properties appropriate for display",
    desc: "Certain properties shouldn't be used with certain display property values.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        var propertiesToCheck = {
                display: 1,
                "float": "none",
                height: 1,
                width: 1,
                margin: 1,
                "margin-left": 1,
                "margin-right": 1,
                "margin-bottom": 1,
                "margin-top": 1,
                padding: 1,
                "padding-left": 1,
                "padding-right": 1,
                "padding-bottom": 1,
                "padding-top": 1,
                "vertical-align": 1
            },
            properties;

        function reportProperty(name, display, msg){
            if (properties[name]){
                if (typeof propertiesToCheck[name] !== "string" || properties[name].value.toLowerCase() !== propertiesToCheck[name]){
                    reporter.report(msg || name + " can't be used with display: " + display + ".", properties[name].line, properties[name].col, rule);
                }
            }
        }

        function startRule(){
            properties = {};
        }

        function endRule(){

            var display = properties.display ? properties.display.value : null;
            if (display){
                switch(display){

                    case "inline":
                        reportProperty("height", display);
                        reportProperty("width", display);
                        reportProperty("margin", display);
                        reportProperty("margin-top", display);
                        reportProperty("margin-bottom", display);
                        reportProperty("float", display, "display:inline has no effect on floated elements (but may be used to fix the IE6 double-margin bug).");
                        break;

                    case "block":
                        reportProperty("vertical-align", display);
                        break;

                    case "inline-block":
                        reportProperty("float", display);
                        break;

                    default:
                        if (display.indexOf("table-") === 0){
                            reportProperty("margin", display);
                            reportProperty("margin-left", display);
                            reportProperty("margin-right", display);
                            reportProperty("margin-top", display);
                            reportProperty("margin-bottom", display);
                            reportProperty("float", display);
                        }
                }
            }

        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startkeyframerule", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startpage", startRule);

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();

            if (propertiesToCheck[name]){
                properties[name] = { value: event.value.text, line: event.property.line, col: event.property.col };
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endkeyframerule", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endpage", endRule);

    }

});

CSSLint.addRule({
    id: "duplicate-background-images",
    name: "Disallow duplicate background images",
    desc: "Every background-image should be unique. Use a common class for e.g. sprites.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            stack = {};

        parser.addListener("property", function(event){
            var name = event.property.text,
                value = event.value,
                i, len;

            if (name.match(/background/i)) {
                for (i=0, len=value.parts.length; i < len; i++) {
                    if (value.parts[i].type === "uri") {
                        if (typeof stack[value.parts[i].uri] === "undefined") {
                            stack[value.parts[i].uri] = event;
                        }
                        else {
                            reporter.report("Background image '" + value.parts[i].uri + "' was used multiple times, first declared at line " + stack[value.parts[i].uri].line + ", col " + stack[value.parts[i].uri].col + ".", event.line, event.col, rule);
                        }
                    }
                }
            }
        });
    }
});

CSSLint.addRule({
    id: "duplicate-properties",
    name: "Disallow duplicate properties",
    desc: "Duplicate properties must appear one after the other.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            properties,
            lastProperty;

        function startRule(){
            properties = {};
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);

        parser.addListener("property", function(event){
            var property = event.property,
                name = property.text.toLowerCase();

            if (properties[name] && (lastProperty !== name || properties[name] === event.value.text)){
                reporter.report("Duplicate property '" + event.property + "' found.", event.line, event.col, rule);
            }

            properties[name] = event.value.text;
            lastProperty = name;

        });


    }

});

CSSLint.addRule({
    id: "empty-rules",
    name: "Disallow empty rules",
    desc: "Rules without any properties specified should be removed.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            count = 0;

        parser.addListener("startrule", function(){
            count=0;
        });

        parser.addListener("property", function(){
            count++;
        });

        parser.addListener("endrule", function(event){
            var selectors = event.selectors;
            if (count === 0){
                reporter.report("Rule is empty.", selectors[0].line, selectors[0].col, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "errors",
    name: "Parsing Errors",
    desc: "This rule looks for recoverable syntax errors.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("error", function(event){
            reporter.error(event.message, event.line, event.col, rule);
        });

    }

});

CSSLint.addRule({
    id: "fallback-colors",
    name: "Require fallback colors",
    desc: "For older browsers that don't support RGBA, HSL, or HSLA, provide a fallback color.",
    browsers: "IE6,IE7,IE8",
    init: function(parser, reporter){
        var rule = this,
            lastProperty,
            propertiesToCheck = {
                color: 1,
                background: 1,
                "border-color": 1,
                "border-top-color": 1,
                "border-right-color": 1,
                "border-bottom-color": 1,
                "border-left-color": 1,
                border: 1,
                "border-top": 1,
                "border-right": 1,
                "border-bottom": 1,
                "border-left": 1,
                "background-color": 1
            },
            properties;

        function startRule(){
            properties = {};
            lastProperty = null;
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);

        parser.addListener("property", function(event){
            var property = event.property,
                name = property.text.toLowerCase(),
                parts = event.value.parts,
                i = 0,
                colorType = "",
                len = parts.length;

            if(propertiesToCheck[name]){
                while(i < len){
                    if (parts[i].type === "color"){
                        if ("alpha" in parts[i] || "hue" in parts[i]){

                            if (/([^\)]+)\(/.test(parts[i])){
                                colorType = RegExp.$1.toUpperCase();
                            }

                            if (!lastProperty || (lastProperty.property.text.toLowerCase() !== name || lastProperty.colorType !== "compat")){
                                reporter.report("Fallback " + name + " (hex or RGB) should precede " + colorType + " " + name + ".", event.line, event.col, rule);
                            }
                        } else {
                            event.colorType = "compat";
                        }
                    }

                    i++;
                }
            }

            lastProperty = event;
        });

    }

});

CSSLint.addRule({
    id: "floats",
    name: "Disallow too many floats",
    desc: "This rule tests if the float property is used too many times",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;
        var count = 0;
        parser.addListener("property", function(event){
            if (event.property.text.toLowerCase() === "float" &&
                    event.value.text.toLowerCase() !== "none"){
                count++;
            }
        });
        parser.addListener("endstylesheet", function(){
            reporter.stat("floats", count);
            if (count >= 10){
                reporter.rollupWarn("Too many floats (" + count + "), you're probably using them for layout. Consider using a grid system instead.", rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "font-faces",
    name: "Don't use too many web fonts",
    desc: "Too many different web fonts in the same stylesheet.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            count = 0;


        parser.addListener("startfontface", function(){
            count++;
        });

        parser.addListener("endstylesheet", function(){
            if (count > 5){
                reporter.rollupWarn("Too many @font-face declarations (" + count + ").", rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "font-sizes",
    name: "Disallow too many font sizes",
    desc: "Checks the number of font-size declarations.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            count = 0;
        parser.addListener("property", function(event){
            if (event.property.toString() === "font-size"){
                count++;
            }
        });
        parser.addListener("endstylesheet", function(){
            reporter.stat("font-sizes", count);
            if (count >= 10){
                reporter.rollupWarn("Too many font-size declarations (" + count + "), abstraction needed.", rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "gradients",
    name: "Require all gradient definitions",
    desc: "When using a vendor-prefixed gradient, make sure to use them all.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            gradients;

        parser.addListener("startrule", function(){
            gradients = {
                moz: 0,
                webkit: 0,
                oldWebkit: 0,
                o: 0
            };
        });

        parser.addListener("property", function(event){

            if (/\-(moz|o|webkit)(?:\-(?:linear|radial))\-gradient/i.test(event.value)){
                gradients[RegExp.$1] = 1;
            } else if (/\-webkit\-gradient/i.test(event.value)){
                gradients.oldWebkit = 1;
            }

        });

        parser.addListener("endrule", function(event){
            var missing = [];

            if (!gradients.moz){
                missing.push("Firefox 3.6+");
            }

            if (!gradients.webkit){
                missing.push("Webkit (Safari 5+, Chrome)");
            }

            if (!gradients.oldWebkit){
                missing.push("Old Webkit (Safari 4+, Chrome)");
            }

            if (!gradients.o){
                missing.push("Opera 11.1+");
            }

            if (missing.length && missing.length < 4){
                reporter.report("Missing vendor-prefixed CSS gradients for " + missing.join(", ") + ".", event.selectors[0].line, event.selectors[0].col, rule);
            }

        });

    }

});

CSSLint.addRule({
    id: "ids",
    name: "Disallow IDs in selectors",
    desc: "Selectors should not contain IDs.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;
        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                idCount,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                idCount = 0;

                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE){
                        for (k=0; k < part.modifiers.length; k++){
                            modifier = part.modifiers[k];
                            if (modifier.type === "id"){
                                idCount++;
                            }
                        }
                    }
                }

                if (idCount === 1){
                    reporter.report("Don't use IDs in selectors.", selector.line, selector.col, rule);
                } else if (idCount > 1){
                    reporter.report(idCount + " IDs in the selector, really?", selector.line, selector.col, rule);
                }
            }

        });
    }

});

CSSLint.addRule({
    id: "import",
    name: "Disallow @import",
    desc: "Don't use @import, use <link> instead.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("import", function(event){
            reporter.report("@import prevents parallel downloads, use <link> instead.", event.line, event.col, rule);
        });

    }

});

CSSLint.addRule({
    id: "important",
    name: "Disallow !important",
    desc: "Be careful when using !important declaration",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            count = 0;
        parser.addListener("property", function(event){
            if (event.important === true){
                count++;
                reporter.report("Use of !important", event.line, event.col, rule);
            }
        });
        parser.addListener("endstylesheet", function(){
            reporter.stat("important", count);
            if (count >= 10){
                reporter.rollupWarn("Too many !important declarations (" + count + "), try to use less than 10 to avoid specificity issues.", rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "known-properties",
    name: "Require use of known properties",
    desc: "Properties should be known (listed in CSS3 specification) or be a vendor-prefixed property.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("property", function(event){
            if (event.invalid) {
                reporter.report(event.invalid.message, event.line, event.col, rule);
            }

        });
    }

});
CSSLint.addRule({
    id: "order-alphabetical",
    name: "Alphabetical order",
    desc: "Assure properties are in alphabetical order",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            properties;

        var startRule = function () {
            properties = [];
        };

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);

        parser.addListener("property", function(event){
            var name = event.property.text,
                lowerCasePrefixLessName = name.toLowerCase().replace(/^-.*?-/, "");

            properties.push(lowerCasePrefixLessName);
        });

        parser.addListener("endrule", function(event){
            var currentProperties = properties.join(","),
                expectedProperties = properties.sort().join(",");

            if (currentProperties !== expectedProperties){
                reporter.report("Rule doesn't have all its properties in alphabetical ordered.", event.line, event.col, rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "outline-none",
    name: "Disallow outline: none",
    desc: "Use of outline: none or outline: 0 should be limited to :focus rules.",
    browsers: "All",
    tags: ["Accessibility"],
    init: function(parser, reporter){
        var rule = this,
            lastRule;

        function startRule(event){
            if (event.selectors){
                lastRule = {
                    line: event.line,
                    col: event.col,
                    selectors: event.selectors,
                    propCount: 0,
                    outline: false
                };
            } else {
                lastRule = null;
            }
        }

        function endRule(){
            if (lastRule){
                if (lastRule.outline){
                    if (lastRule.selectors.toString().toLowerCase().indexOf(":focus") === -1){
                        reporter.report("Outlines should only be modified using :focus.", lastRule.line, lastRule.col, rule);
                    } else if (lastRule.propCount === 1) {
                        reporter.report("Outlines shouldn't be hidden unless other visual changes are made.", lastRule.line, lastRule.col, rule);
                    }
                }
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase(),
                value = event.value;

            if (lastRule){
                lastRule.propCount++;
                if (name === "outline" && (value.toString() === "none" || value.toString() === "0")){
                    lastRule.outline = true;
                }
            }

        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule);

    }

});

CSSLint.addRule({
    id: "overqualified-elements",
    name: "Disallow overqualified elements",
    desc: "Don't use classes or IDs with elements (a.foo or a#foo).",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            classes = {};

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];

                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE){
                        for (k=0; k < part.modifiers.length; k++){
                            modifier = part.modifiers[k];
                            if (part.elementName && modifier.type === "id"){
                                reporter.report("Element (" + part + ") is overqualified, just use " + modifier + " without element name.", part.line, part.col, rule);
                            } else if (modifier.type === "class"){

                                if (!classes[modifier]){
                                    classes[modifier] = [];
                                }
                                classes[modifier].push({ modifier: modifier, part: part });
                            }
                        }
                    }
                }
            }
        });

        parser.addListener("endstylesheet", function(){

            var prop;
            for (prop in classes){
                if (classes.hasOwnProperty(prop)){
                    if (classes[prop].length === 1 && classes[prop][0].part.elementName){
                        reporter.report("Element (" + classes[prop][0].part + ") is overqualified, just use " + classes[prop][0].modifier + " without element name.", classes[prop][0].part.line, classes[prop][0].part.col, rule);
                    }
                }
            }
        });
    }

});

CSSLint.addRule({
    id: "qualified-headings",
    name: "Disallow qualified headings",
    desc: "Headings should not be qualified (namespaced).",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                i, j;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];

                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE){
                        if (part.elementName && /h[1-6]/.test(part.elementName.toString()) && j > 0){
                            reporter.report("Heading (" + part.elementName + ") should not be qualified.", part.line, part.col, rule);
                        }
                    }
                }
            }
        });
    }

});

CSSLint.addRule({
    id: "regex-selectors",
    name: "Disallow selectors that look like regexs",
    desc: "Selectors that look like regular expressions are slow and should be avoided.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE){
                        for (k=0; k < part.modifiers.length; k++){
                            modifier = part.modifiers[k];
                            if (modifier.type === "attribute"){
                                if (/([\~\|\^\$\*]=)/.test(modifier)){
                                    reporter.report("Attribute selectors with " + RegExp.$1 + " are slow!", modifier.line, modifier.col, rule);
                                }
                            }

                        }
                    }
                }
            }
        });
    }

});

CSSLint.addRule({
    id: "rules-count",
    name: "Rules Count",
    desc: "Track how many rules there are.",
    browsers: "All",
    init: function(parser, reporter){
        var count = 0;
        parser.addListener("startrule", function(){
            count++;
        });

        parser.addListener("endstylesheet", function(){
            reporter.stat("rule-count", count);
        });
    }

});

CSSLint.addRule({
    id: "selector-max-approaching",
    name: "Warn when approaching the 4095 selector limit for IE",
    desc: "Will warn when selector count is >= 3800 selectors.",
    browsers: "IE",
    init: function(parser, reporter) {
        var rule = this, count = 0;

        parser.addListener("startrule", function(event) {
            count += event.selectors.length;
        });

        parser.addListener("endstylesheet", function() {
            if (count >= 3800) {
                reporter.report("You have " + count + " selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.",0,0,rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "selector-max",
    name: "Error when past the 4095 selector limit for IE",
    desc: "Will error when selector count is > 4095.",
    browsers: "IE",
    init: function(parser, reporter){
        var rule = this, count = 0;

        parser.addListener("startrule", function(event) {
            count += event.selectors.length;
        });

        parser.addListener("endstylesheet", function() {
            if (count > 4095) {
                reporter.report("You have " + count + " selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.",0,0,rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "selector-newline",
    name: "Disallow new-line characters in selectors",
    desc: "New-line characters in selectors are usually a forgotten comma and not a descendant combinator.",
    browsers: "All",
    init: function(parser, reporter) {
        var rule = this;

        function startRule(event) {
            var i, len, selector, p, n, pLen, part, part2, type, currentLine, nextLine,
                selectors = event.selectors;

            for (i = 0, len = selectors.length; i < len; i++) {
                selector = selectors[i];
                for (p = 0, pLen = selector.parts.length; p < pLen; p++) {
                    for (n = p + 1; n < pLen; n++) {
                        part = selector.parts[p];
                        part2 = selector.parts[n];
                        type = part.type;
                        currentLine = part.line;
                        nextLine = part2.line;

                        if (type === "descendant" && nextLine > currentLine) {
                            reporter.report("newline character found in selector (forgot a comma?)", currentLine, selectors[i].parts[0].col, rule);
                        }
                    }
                }

            }
        }

        parser.addListener("startrule", startRule);

    }
});

CSSLint.addRule({
    id: "shorthand",
    name: "Require shorthand properties",
    desc: "Use shorthand properties where possible.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            prop, i, len,
            propertiesToCheck = {},
            properties,
            mapping = {
                "margin": [
                    "margin-top",
                    "margin-bottom",
                    "margin-left",
                    "margin-right"
                ],
                "padding": [
                    "padding-top",
                    "padding-bottom",
                    "padding-left",
                    "padding-right"
                ]
            };
        for (prop in mapping){
            if (mapping.hasOwnProperty(prop)){
                for (i=0, len=mapping[prop].length; i < len; i++){
                    propertiesToCheck[mapping[prop][i]] = prop;
                }
            }
        }

        function startRule(){
            properties = {};
        }
        function endRule(event){

            var prop, i, len, total;
            for (prop in mapping){
                if (mapping.hasOwnProperty(prop)){
                    total=0;

                    for (i=0, len=mapping[prop].length; i < len; i++){
                        total += properties[mapping[prop][i]] ? 1 : 0;
                    }

                    if (total === mapping[prop].length){
                        reporter.report("The properties " + mapping[prop].join(", ") + " can be replaced by " + prop + ".", event.line, event.col, rule);
                    }
                }
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("property", function(event){
            var name = event.property.toString().toLowerCase();

            if (propertiesToCheck[name]){
                properties[name] = 1;
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);

    }

});

CSSLint.addRule({
    id: "star-property-hack",
    name: "Disallow properties with a star prefix",
    desc: "Checks for the star property hack (targets IE6/7)",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;
        parser.addListener("property", function(event){
            var property = event.property;

            if (property.hack === "*") {
                reporter.report("Property with star prefix found.", event.property.line, event.property.col, rule);
            }
        });
    }
});

CSSLint.addRule({
    id: "text-indent",
    name: "Disallow negative text-indent",
    desc: "Checks for text indent less than -99px",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            textIndent,
            direction;


        function startRule(){
            textIndent = false;
            direction = "inherit";
        }
        function endRule(){
            if (textIndent && direction !== "ltr"){
                reporter.report("Negative text-indent doesn't work well with RTL. If you use text-indent for image replacement explicitly set direction for that item to ltr.", textIndent.line, textIndent.col, rule);
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("property", function(event){
            var name = event.property.toString().toLowerCase(),
                value = event.value;

            if (name === "text-indent" && value.parts[0].value < -99){
                textIndent = event.property;
            } else if (name === "direction" && value.toString() === "ltr"){
                direction = "ltr";
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);

    }

});

CSSLint.addRule({
    id: "underscore-property-hack",
    name: "Disallow properties with an underscore prefix",
    desc: "Checks for the underscore property hack (targets IE6)",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;
        parser.addListener("property", function(event){
            var property = event.property;

            if (property.hack === "_") {
                reporter.report("Property with underscore prefix found.", event.property.line, event.property.col, rule);
            }
        });
    }
});

CSSLint.addRule({
    id: "unique-headings",
    name: "Headings should only be defined once",
    desc: "Headings should be defined only once.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        var headings = {
                h1: 0,
                h2: 0,
                h3: 0,
                h4: 0,
                h5: 0,
                h6: 0
            };

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                pseudo,
                i, j;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                part = selector.parts[selector.parts.length-1];

                if (part.elementName && /(h[1-6])/i.test(part.elementName.toString())){

                    for (j=0; j < part.modifiers.length; j++){
                        if (part.modifiers[j].type === "pseudo"){
                            pseudo = true;
                            break;
                        }
                    }

                    if (!pseudo){
                        headings[RegExp.$1]++;
                        if (headings[RegExp.$1] > 1) {
                            reporter.report("Heading (" + part.elementName + ") has already been defined.", part.line, part.col, rule);
                        }
                    }
                }
            }
        });

        parser.addListener("endstylesheet", function(){
            var prop,
                messages = [];

            for (prop in headings){
                if (headings.hasOwnProperty(prop)){
                    if (headings[prop] > 1){
                        messages.push(headings[prop] + " " + prop + "s");
                    }
                }
            }

            if (messages.length){
                reporter.rollupWarn("You have " + messages.join(", ") + " defined in this stylesheet.", rule);
            }
        });
    }

});

CSSLint.addRule({
    id: "universal-selector",
    name: "Disallow universal selector",
    desc: "The universal selector (*) is known to be slow.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                i;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];

                part = selector.parts[selector.parts.length-1];
                if (part.elementName === "*"){
                    reporter.report(rule.desc, part.line, part.col, rule);
                }
            }
        });
    }

});

CSSLint.addRule({
    id: "unqualified-attributes",
    name: "Disallow unqualified attribute selectors",
    desc: "Unqualified attribute selectors are known to be slow.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("startrule", function(event){

            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];

                part = selector.parts[selector.parts.length-1];
                if (part.type === parser.SELECTOR_PART_TYPE){
                    for (k=0; k < part.modifiers.length; k++){
                        modifier = part.modifiers[k];
                        if (modifier.type === "attribute" && (!part.elementName || part.elementName === "*")){
                            reporter.report(rule.desc, part.line, part.col, rule);
                        }
                    }
                }

            }
        });
    }

});

CSSLint.addRule({
    id: "vendor-prefix",
    name: "Require standard property with vendor prefix",
    desc: "When using a vendor-prefixed property, make sure to include the standard one.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this,
            properties,
            num,
            propertiesToCheck = {
                "-webkit-border-radius": "border-radius",
                "-webkit-border-top-left-radius": "border-top-left-radius",
                "-webkit-border-top-right-radius": "border-top-right-radius",
                "-webkit-border-bottom-left-radius": "border-bottom-left-radius",
                "-webkit-border-bottom-right-radius": "border-bottom-right-radius",

                "-o-border-radius": "border-radius",
                "-o-border-top-left-radius": "border-top-left-radius",
                "-o-border-top-right-radius": "border-top-right-radius",
                "-o-border-bottom-left-radius": "border-bottom-left-radius",
                "-o-border-bottom-right-radius": "border-bottom-right-radius",

                "-moz-border-radius": "border-radius",
                "-moz-border-radius-topleft": "border-top-left-radius",
                "-moz-border-radius-topright": "border-top-right-radius",
                "-moz-border-radius-bottomleft": "border-bottom-left-radius",
                "-moz-border-radius-bottomright": "border-bottom-right-radius",

                "-moz-column-count": "column-count",
                "-webkit-column-count": "column-count",

                "-moz-column-gap": "column-gap",
                "-webkit-column-gap": "column-gap",

                "-moz-column-rule": "column-rule",
                "-webkit-column-rule": "column-rule",

                "-moz-column-rule-style": "column-rule-style",
                "-webkit-column-rule-style": "column-rule-style",

                "-moz-column-rule-color": "column-rule-color",
                "-webkit-column-rule-color": "column-rule-color",

                "-moz-column-rule-width": "column-rule-width",
                "-webkit-column-rule-width": "column-rule-width",

                "-moz-column-width": "column-width",
                "-webkit-column-width": "column-width",

                "-webkit-column-span": "column-span",
                "-webkit-columns": "columns",

                "-moz-box-shadow": "box-shadow",
                "-webkit-box-shadow": "box-shadow",

                "-moz-transform" : "transform",
                "-webkit-transform" : "transform",
                "-o-transform" : "transform",
                "-ms-transform" : "transform",

                "-moz-transform-origin" : "transform-origin",
                "-webkit-transform-origin" : "transform-origin",
                "-o-transform-origin" : "transform-origin",
                "-ms-transform-origin" : "transform-origin",

                "-moz-box-sizing" : "box-sizing",
                "-webkit-box-sizing" : "box-sizing"
            };
        function startRule(){
            properties = {};
            num = 1;
        }
        function endRule(){
            var prop,
                i,
                len,
                needed,
                actual,
                needsStandard = [];

            for (prop in properties){
                if (propertiesToCheck[prop]){
                    needsStandard.push({ actual: prop, needed: propertiesToCheck[prop]});
                }
            }

            for (i=0, len=needsStandard.length; i < len; i++){
                needed = needsStandard[i].needed;
                actual = needsStandard[i].actual;

                if (!properties[needed]){
                    reporter.report("Missing standard property '" + needed + "' to go along with '" + actual + "'.", properties[actual][0].name.line, properties[actual][0].name.col, rule);
                } else {
                    if (properties[needed][0].pos < properties[actual][0].pos){
                        reporter.report("Standard property '" + needed + "' should come after vendor-prefixed property '" + actual + "'.", properties[actual][0].name.line, properties[actual][0].name.col, rule);
                    }
                }
            }

        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();

            if (!properties[name]){
                properties[name] = [];
            }

            properties[name].push({ name: event.property, value : event.value, pos:num++ });
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule);
    }

});

CSSLint.addRule({
    id: "zero-units",
    name: "Disallow units for 0 values",
    desc: "You don't need to specify units when a value is 0.",
    browsers: "All",
    init: function(parser, reporter){
        var rule = this;
        parser.addListener("property", function(event){
            var parts = event.value.parts,
                i = 0,
                len = parts.length;

            while(i < len){
                if ((parts[i].units || parts[i].type === "percentage") && parts[i].value === 0 && parts[i].type !== "time"){
                    reporter.report("Values of 0 shouldn't have units specified.", parts[i].line, parts[i].col, rule);
                }
                i++;
            }

        });

    }

});

(function() {
    var xmlEscape = function(str) {
        if (!str || str.constructor !== String) {
            return "";
        }

        return str.replace(/[\"&><]/g, function(match) {
            switch (match) {
                case "\"":
                    return "&quot;";
                case "&":
                    return "&amp;";
                case "<":
                    return "&lt;";
                case ">":
                    return "&gt;";
            }
        });
    };

    CSSLint.addFormatter({
        id: "checkstyle-xml",
        name: "Checkstyle XML format",
        startFormat: function(){
            return "<?xml version=\"1.0\" encoding=\"utf-8\"?><checkstyle>";
        },
        endFormat: function(){
            return "</checkstyle>";
        },
        readError: function(filename, message) {
            return "<file name=\"" + xmlEscape(filename) + "\"><error line=\"0\" column=\"0\" severty=\"error\" message=\"" + xmlEscape(message) + "\"></error></file>";
        },
        formatResults: function(results, filename/*, options*/) {
            var messages = results.messages,
                output = [];
            var generateSource = function(rule) {
                if (!rule || !("name" in rule)) {
                    return "";
                }
                return "net.csslint." + rule.name.replace(/\s/g,"");
            };



            if (messages.length > 0) {
                output.push("<file name=\""+filename+"\">");
                CSSLint.Util.forEach(messages, function (message) {
                    if (!message.rollup) {
                        output.push("<error line=\"" + message.line + "\" column=\"" + message.col + "\" severity=\"" + message.type + "\"" +
                          " message=\"" + xmlEscape(message.message) + "\" source=\"" + generateSource(message.rule) +"\"/>");
                    }
                });
                output.push("</file>");
            }

            return output.join("");
        }
    });

}());

CSSLint.addFormatter({
    id: "compact",
    name: "Compact, 'porcelain' format",
    startFormat: function() {
        return "";
    },
    endFormat: function() {
        return "";
    },
    formatResults: function(results, filename, options) {
        var messages = results.messages,
            output = "";
        options = options || {};
        var capitalize = function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        };

        if (messages.length === 0) {
              return options.quiet ? "" : filename + ": Lint Free!";
        }

        CSSLint.Util.forEach(messages, function(message) {
            if (message.rollup) {
                output += filename + ": " + capitalize(message.type) + " - " + message.message + "\n";
            } else {
                output += filename + ": " + "line " + message.line +
                    ", col " + message.col + ", " + capitalize(message.type) + " - " + message.message + " (" + message.rule.id + ")\n";
            }
        });

        return output;
    }
});

CSSLint.addFormatter({
    id: "csslint-xml",
    name: "CSSLint XML format",
    startFormat: function(){
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><csslint>";
    },
    endFormat: function(){
        return "</csslint>";
    },
    formatResults: function(results, filename/*, options*/) {
        var messages = results.messages,
            output = [];
        var escapeSpecialCharacters = function(str) {
            if (!str || str.constructor !== String) {
                return "";
            }
            return str.replace(/\"/g, "'").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        };

        if (messages.length > 0) {
            output.push("<file name=\""+filename+"\">");
            CSSLint.Util.forEach(messages, function (message) {
                if (message.rollup) {
                    output.push("<issue severity=\"" + message.type + "\" reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                } else {
                    output.push("<issue line=\"" + message.line + "\" char=\"" + message.col + "\" severity=\"" + message.type + "\"" +
                        " reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                }
            });
            output.push("</file>");
        }

        return output.join("");
    }
});

CSSLint.addFormatter({
    id: "junit-xml",
    name: "JUNIT XML format",
    startFormat: function(){
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><testsuites>";
    },
    endFormat: function() {
        return "</testsuites>";
    },
    formatResults: function(results, filename/*, options*/) {

        var messages = results.messages,
            output = [],
            tests = {
                "error": 0,
                "failure": 0
            };
        var generateSource = function(rule) {
            if (!rule || !("name" in rule)) {
                return "";
            }
            return "net.csslint." + rule.name.replace(/\s/g,"");
        };
        var escapeSpecialCharacters = function(str) {

            if (!str || str.constructor !== String) {
                return "";
            }

            return str.replace(/\"/g, "'").replace(/</g, "&lt;").replace(/>/g, "&gt;");

        };

        if (messages.length > 0) {

            messages.forEach(function (message) {
                var type = message.type === "warning" ? "error" : message.type;
                if (!message.rollup) {
                    output.push("<testcase time=\"0\" name=\"" + generateSource(message.rule) + "\">");
                    output.push("<" + type + " message=\"" + escapeSpecialCharacters(message.message) + "\"><![CDATA[" + message.line + ":" + message.col + ":" + escapeSpecialCharacters(message.evidence)  + "]]></" + type + ">");
                    output.push("</testcase>");

                    tests[type] += 1;

                }

            });

            output.unshift("<testsuite time=\"0\" tests=\"" + messages.length + "\" skipped=\"0\" errors=\"" + tests.error + "\" failures=\"" + tests.failure + "\" package=\"net.csslint\" name=\"" + filename + "\">");
            output.push("</testsuite>");

        }

        return output.join("");

    }
});

CSSLint.addFormatter({
    id: "lint-xml",
    name: "Lint XML format",
    startFormat: function(){
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><lint>";
    },
    endFormat: function(){
        return "</lint>";
    },
    formatResults: function(results, filename/*, options*/) {
        var messages = results.messages,
            output = [];
        var escapeSpecialCharacters = function(str) {
            if (!str || str.constructor !== String) {
                return "";
            }
            return str.replace(/\"/g, "'").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        };

        if (messages.length > 0) {

            output.push("<file name=\""+filename+"\">");
            CSSLint.Util.forEach(messages, function (message) {
                if (message.rollup) {
                    output.push("<issue severity=\"" + message.type + "\" reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                } else {
                    output.push("<issue line=\"" + message.line + "\" char=\"" + message.col + "\" severity=\"" + message.type + "\"" +
                        " reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                }
            });
            output.push("</file>");
        }

        return output.join("");
    }
});

CSSLint.addFormatter({
    id: "text",
    name: "Plain Text",
    startFormat: function() {
        return "";
    },
    endFormat: function() {
        return "";
    },
    formatResults: function(results, filename, options) {
        var messages = results.messages,
            output = "";
        options = options || {};

        if (messages.length === 0) {
            return options.quiet ? "" : "\n\ncsslint: No errors in " + filename + ".";
        }

        output = "\n\ncsslint: There ";
        if (messages.length === 1) {
            output += "is 1 problem";
        } else {
            output += "are " + messages.length  +  " problems";
        }
        output += " in " + filename + ".";

        var pos = filename.lastIndexOf("/"),
            shortFilename = filename;

        if (pos === -1){
            pos = filename.lastIndexOf("\\");
        }
        if (pos > -1){
            shortFilename = filename.substring(pos+1);
        }

        CSSLint.Util.forEach(messages, function (message, i) {
            output = output + "\n\n" + shortFilename;
            if (message.rollup) {
                output += "\n" + (i+1) + ": " + message.type;
                output += "\n" + message.message;
            } else {
                output += "\n" + (i+1) + ": " + message.type + " at line " + message.line + ", col " + message.col;
                output += "\n" + message.message;
                output += "\n" + message.evidence;
            }
        });

        return output;
    }
});

module.exports.CSSLint = CSSLint;

});

define("plugins/c9.ide.language.css/css_handler",[], function(require, exports, module) {

var baseLanguageHandler = require("plugins/c9.ide.language/base_handler");
var CSSLint = require("ace/mode/css/csslint");
var handler = module.exports = Object.create(baseLanguageHandler);

handler.handlesLanguage = function(language) {
    return language === "css" || language === "less";
};

handler.analyze = function(value, ast, options, callback) {
    if (this.language === "less")
        return callback();
    
    callback(handler.analyzeSync(value, ast));
};
var CSSLint_RULESET = {
    "adjoining-classes": 0,
    "box-model": 1,
    "box-sizing": 1,
    "compatible-vendor-prefixes": 3,
    "display-property-grouping": 1,
    "duplicate-background-images": 1,
    "duplicate-properties": 1,
    "empty-rules": 1,
    "errors": 2,
    "fallback-colors": 3,
    "floats": 1,
    "font-faces": 1,
    "font-sizes": 1,
    "gradients": 3,
    "ids": 0,
    "import": 0,
    "important": 3,
    "known-properties": 1,
    "outline-none": 3,
    "overqualified-elements": 1,
    "qualified-headings": 3,
    "regex-selectors": 1,
    "rules-count": 1,
    "shorthand": 1,
    "star-property-hack": 1,
    "text-indent": 1,
    "underscore-property-hack": 1,
    "unique-headings": 1,
    "universal-selector": 1,
    "unqualified-attributes": 1,
    "vendor-prefix": 3,
    "zero-units": 0
};

handler.analyzeSync = function(value, ast) {
    value = value.replace(/^(#!.*\n)/, "//$1");

    var results = value && CSSLint.CSSLint.verify(value, CSSLint_RULESET);
    var warnings = results ? results.messages : [];

    return warnings.map(function(warning) {
        if (CSSLint_RULESET[warning.rule.id] === 3)
            warning.type = "info";
        return {
            pos: {
                sl: warning.line - 1,
                sc: warning.col - 1
            },
            type: warning.type,
            level: warning.type,
            message: warning.message
        };
    });
};

handler.getIdentifierRegex = function() {
    return (/[_a-zA-Z0-9-]/);
};

});

define("plugins/c9.ide.language.html/snippets",[], function(require, exports, module) {

module.exports = {
    "script": "<script type=\"text/javascript\" src=\"^^\"></script>",
    "csslink": "<link rel=\"stylesheet\" href=\"^^\" type=\"text/css\" />",
    "link": "<link rel=\"stylesheet\" href=\"^^\" type=\"text/css\" />",
    "style": "<style type=\"text/css\">\n\t^^\n</style>",
    "amailto": "<a href=\"mailto:^^\"></a>",
    "html": "<!DOCTYPE html>\n<html>\n\t^^\n</html>",
    "body": "<body>\n\t^^\n</body>",
    "head": "<head>\n\t^^\n</head>",
    "table": "<table>\n\t<tr>\n\t\t<td>^^</td>\n\t</tr>\n</table>",
    "th": "<th>\n\t^^\n</th>",
    "tr": "<tr>\n\t^^\n</tr>",
    "td": "<td>^^</td>",
    "divc": "<div class=\"^^\"></div>",
    "div": "<div>^^</div>",
    "spanc": "<span class=\"^^\"></span>",
    "span": "<span>^^</span>",
    "form": "<form>\n\t<input type=\"text\" name=\"^^\"/>\n\t<input type=\"submit\" value=\"Submit\"/>\n</form>",
    "input": "<input type=\"text\" name=\"^^\"/>",
    "password": "<input type=\"password\" name=\"^^\"/>",
    "textarea": "<input type=\"textarea\" name=\"^^\"/>",
    "img": "<img src=\"^^\"></img>",
    "label": "<label for=\"\">^^</label>",
    "lorem": "Lorem ipsum dolor sit amet, consectetuer adipiscing elit,\nsed diam nonummy nibh euismod tincidunt ut laoreet dolore\nmagna aliquam erat volutpat. Ut wisi enim ad minim veniam,\nquis nostrud exerci tation ullamcorper suscipit lobortis nisl\nut aliquip ex ea commodo consequat. Duis autem vel eum iriure\ndolor in hendrerit in vulputate velit esse molestie consequat,\nvel illum dolore eu feugiat nulla facilisis at vero eros et\naccumsan et iusto odio dignissim qui blandit praesent luptatum\nzzril delenit augue duis dolore te feugait nulla facilisi.\nNam liber tempor cum soluta nobis eleifend option congue\nnihil imperdiet doming id quod mazim placerat facer possim\nassum. Typi non habent claritatem insitam; est usus legentis\nin iis qui facit eorum claritatem. Investigationes\ndemonstraverunt lectores legere me lius quod ii legunt saepius.\nClaritas est etiam processus dynamicus, qui sequitur mutationem\nconsuetudium lectorum. Mirum est notare quam littera gothica,\nquam nunc putamus parum claram, anteposuerit litterarum formas\nhumanitatis per seacula quarta decima et quinta decima. Eodem\nmodo typi, qui nunc nobis videntur parum clari, fiant sollemnes\nin futurum.^^"
};

});

define("plugins/c9.ide.language.html/html_completer",[], function(require, exports, module) {

var completeUtil = require("plugins/c9.ide.language/complete_util");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var htmlSnippets = require("./snippets");

var completer = module.exports = Object.create(baseLanguageHandler);

completer.handlesLanguage = function(language) {
    return language === "html";
};

var JADE_REGEX = /.*?([a-zA-Z]*)([.#])([\w]+)/;
var JADE_ID_REGEX = /[a-zA-Z_0-9\$\_.#]/;

completer.getCompletionRegex = function() {
    return /[<=A-Za-z:_$\-]/;
};

completer.getIdentifierRegex = function() {
    return JADE_ID_REGEX;
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    var line = doc.getLine(pos.row);
    var match = JADE_REGEX.exec(line.substring(0, pos.column));
    if (match) {
        var replaceText;
        var snippet = htmlSnippets[match[1]];
        if (snippet) {
            replaceText = snippet.replace("<" + match[1] + ">",
                ["<", match[1], match[2] === "." ? " class=\"" : " id=\"",
                    match[3], "\">"].join(""));
        }
        else {
            replaceText = ["<", match[1] || "div",
                match[2] === "." ? " class=\"" : " id=\"", match[3],
                "\">^^", "</", match[1] || "div", ">"].join("");
        }
        callback([{
              name: match[1] + match[2] + match[3],
              replaceText: replaceText,
              doc: "<pre>" + replaceText.replace("\^\^", "&#9251;").replace(/</g, "&lt;") + "</pre>",
              icon: null,
              meta: "Jade-Haml",
              identifierRegex: JADE_ID_REGEX,
              priority: 100
        }]);
    }
    else {
        var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column);
        var allIdentifiers = Object.keys(htmlSnippets);
        var matches = completeUtil.findCompletions(identifier, allIdentifiers);
        callback(matches.map(function(m) {
            return {
              name: m,
              replaceText: htmlSnippets[m],
              doc: "<pre>" + htmlSnippets[m].replace("\^\^", "&#9251;").replace(/</g, "&lt;") + "</pre>",
              icon: null,
              meta: "snippet",
              priority: 2
            };
        }));
    }
};


});

define("plugins/c9.ide.language.codeintel/worker/codeintel_worker",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var workerUtil = require("plugins/c9.ide.language/worker_util");

var DAEMON_PORT = 10881;
var ERROR_PORT_IN_USE = 98;
var ERROR_NO_SERVER = 7;
var LANGUAGES = {
    c_cpp: "C++",
    css: "CSS",
    django: "Django",
    perl: "Perl",
    php: "PHP",
    ruby: "Ruby",
    tcl: "Tcl",
    html4: "HTML",
    html: "HTML5",
    rhtml: "RHTML",
    templatetoolkit: "TemplateToolkit",
    smarty: "Smarty",
    twig: "Twig",
    xslt: "XSLT",
    xul: "XUL",
    python: "Python",
    python3: "Python3",
    golang: "Go",
    javascript: "JavaScript",
    less: "Less",
    mason: "Mason",
    mustache: "Mustache",
    mxml: "MXML",
    nodejs: "Node.js",
    xbl: "XBL",
    xml: "XML",
};

var handler = module.exports = Object.create(baseHandler);
var languages = [];
var paths = {};
var server;
var launchCommand;
var enabled;
var daemon;
var lastInfoTimer;
var lastInfoPopup;

handler.handlesLanguage = function(language) {
    return languages.indexOf(language) > -1;
};

handler.addLanguage = function(language) {
    languages.push(language);
};

handler.$disableZeroLengthCompletion = true;

handler.init = function(callback) {
    var emitter = handler.getEmitter();
    emitter.on("setup", function(e) {
        server = e.server;
        launchCommand = e.launchCommand;
        paths = e.paths;
        enabled = e.enabled;
    });
    callback();
};

handler.onDocumentOpen = function(path, doc, oldPath, callback) {
    if (!launchCommand) return callback();
    
    ensureDaemon(callback);
};
handler.complete = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    if (options.language === "PHP" && !options.identifierPrefix && (!options.line[pos.column - 1] || " " === options.line[pos.column - 1]))
        return callback(new Error("Warning: codeintel doesn't support empty-prefix completions"));
    
    callDaemon("completions", handler.path, doc, pos, options, function(err, results, meta) {
        if (err) return callback(err);
        
        results && results.forEach(function beautifyCompletion(r) {
            r.isContextual = true;
            r.guessTooltip = true;
            r.nodoc = "always";
            r.replaceText = r.replaceText || r.name;
            r.priority = r.name[0] === "_" || r.replaceText === r.replaceText.toUpperCase() ? 3 : 4;
            r.icon = r.name[0] === "_" ? r.icon.replace(/2?$/, "2") : r.icon;
        });
        callback(null, results);
    });
};
handler.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    callDaemon("definitions", handler.path, doc, pos, options, callback);
};
function callDaemon(command, path, doc, pos, options, callback) {
    ensureDaemon(function(err, dontRetry) {
        if (daemon && daemon.notInstalled)
            handler.getEmitter().emit("not_installed", { language: options.language });
        if (err) return callback(err);
        
        var start = Date.now();
        workerUtil.execAnalysis(
            "curl",
            {
                mode: "stdin",
                json: true,
                args: [
                    "-H", "Expect:", // don't wait for "100-Continue"
                    "-s", "--data-binary", "@-", // get input from stdin
                    "localhost:" + DAEMON_PORT + "?mode=" + command
                    + "&row=" + pos.row + "&column=" + pos.column
                    + "&language=" + LANGUAGES[options.language]
                    + "&path=" + encodeURIComponent(path.replace(/^\//, ""))
                    + "&dirs=" + (paths[options.language] || "").replace(/:/g, ",")
                    + (options.noDoc ? "&nodoc=1" : ""),
                ],
            },
            function onResult(err, stdout, stderr, meta) {
                if (err) {
                    if (err.code === ERROR_NO_SERVER && !dontRetry)
                        return callDaemon(command, path, doc, pos, options, callback);
                        
                    return callback(new Error("codeintel_server failed, not responding, or not installed yet"));
                }
                
                if (typeof stdout !== "object")
                    return callback(new Error("Couldn't parse codeintel output: " + stdout));
                
                console.log("[codeintel_worker] " + command + " in " + (Date.now() - start)
                    + "ms (ci: " + meta.serverTime + "ms): "
                    + doc.getLine(pos.row).substr(0, pos.column));

                callback(null, stdout, meta);
            }
        );
    });
}
function ensureDaemon(callback) {
    if (daemon)
        return done(daemon.err, true);

    daemon = {
        err: new Error("Still starting daemon, enhance your calm"),
        kill: function() {
            this.killed = true;
        },
        notInstalled: false,
    };
    
    workerUtil.spawn(
        "bash",
        {
            args: [
                "-c", launchCommand,
                "--", "$PYTHON -c '" + server + "' daemon --port " + DAEMON_PORT
            ],
        },
        function(err, child) {
            var output = "";
            if (err) {
                daemon.err = err;
                return workerUtil.showError("Could not start python completion daemon. Please reload to try again.");
            }
            daemon = child;
            daemon.err = null;
            
            if (daemon.killed)
                daemon.kill();
            var killTimer = setTimeout(daemon.kill.bind(daemon), 30 * 60 * 1000);
            
            child.stderr.on("data", function(data) {
                output += data;
                if (/!!Daemon listening/.test(data)) {
                    done();
                }
                else if (/^!!(Updating .*|Installing .*)/.test(data)) {
                    var message = RegExp.$1;
                    clearTimeout(lastInfoTimer);
                    lastInfoTimer = setTimeout(function() {
                        lastInfoPopup = workerUtil.showInfo(message, 5000);
                    }, 3000);
                }
                else if (/^!!Done(.*)/.test(data)) {
                    if (lastInfoPopup)
                        workerUtil.showInfo(RegExp.$1, 3000);
                    lastInfoPopup = null;
                }
                else if (/^!!Not installed/.test(data)) {
                    daemon.notInstalled = true;
                }
                else if (/^!!/.test(data)) {
                    workerUtil.showError(data);
                }
                else {
                    console.log("[codeintel_worker] " + data);
                }
            });
            child.on("exit", function(code) {
                clearInfoPopup();
                if (code === ERROR_PORT_IN_USE) // someone else running daemon?
                    return done(null, true);
                if (!code || /Daemon listening/.test(output)) // everything ok, try again later
                    daemon = null;
                clearTimeout(killTimer);
                done(code && new Error("[codeintel_worker] Daemon failed: " + output), true);
            });
        }
    );
    
    function clearInfoPopup() {
        clearTimeout(lastInfoTimer);
        lastInfoPopup && lastInfoPopup.hide();
    }
    
    function done(err, dontRetry) {
        callback && callback(err, dontRetry);
        callback = null;
        handler.sender.emit("codeintel_ready", { err: err && err.stack });
    }
}

});

define("plugins/c9.ide.language.codeintel/worker/ruby_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var codeintel = require("plugins/c9.ide.language.codeintel/worker/codeintel_worker");

var handler = module.exports = Object.create(baseHandler);
codeintel.addLanguage("ruby");

handler.handlesLanguage = function(language) {
    return language === "ruby";
};

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z0-9_\x7f-\xff]/);
};

handler.getCompletionRegex = function() {
    return /[\.]/;
};

handler.getCacheCompletionRegex = function() {
    return new RegExp(
        "(\\b(if|while|for|switch)\\s*\\("
        + "|\\b\\w+\\s+"
        + "|(===?|!==?|[-+]=|[-+*%>?!|&{[])"
        + "|\\s)+"
    );
};

});

define("plugins/c9.ide.language.codeintel/worker/css_less_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var codeintel = require("plugins/c9.ide.language.codeintel/worker/codeintel_worker");

var handler = module.exports = Object.create(baseHandler);
codeintel.addLanguage("css");
codeintel.addLanguage("less");

handler.handlesLanguage = function(language) {
    return language === "css" || language === "less";
};

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z0-9_\x7f-\xff\-]/);
};

handler.getCompletionRegex = function() {
    return /: $/;
};

handler.predictNextCompletion = function(doc, ast, pos, options, callback) {
    if (options.line[pos.column - 1] === ":")
        return callback({ predicted: " " });
    callback();
};

handler.getCacheCompletionRegex = function() {
    return new RegExp(
        "(\\b[\\.@\\w]+\\s+"
        + "|\\s)+"
    );
};

});

define("plugins/c9.ide.language.codeintel/worker/php_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var codeintel = require("plugins/c9.ide.language.codeintel/worker/codeintel_worker");

var handler = module.exports = Object.create(baseHandler);
codeintel.addLanguage("php");

handler.handlesLanguage = function(language) {
    return language === "php";
};

handler.$recacheCompletionLength = 3;

handler.getIdentifierRegex = function() {
    return (/[$$a-zA-Z0-9_\x7f-\xff]/);
};

handler.getCompletionRegex = function() {
    return (/(\$|->|::)$/);
};

handler.getCacheCompletionRegex = function() {
    return new RegExp(
        "(\\b(if|while|for|switch)\\s*\\("
        + "|\\b\\w+\\s+"
        + "|(===?|!==?|[-+]=|[-+*%>?!|&{[])"
        + "|\\s)+"
    );
};

handler.predictNextCompletion = function(doc, ast, pos, options, callback) {
    if (/\$[a-zA-Z0-9_\x7f-\xff]+-/.test(options.line.substr(0, pos.colomn)))
        return callback({ predicted: ">" });
    if (/\$[a-zA-Z0-9_\x7f-\xff]+:/.test(options.line.substr(0, pos.colomn)))
        return callback({ predicted: ":" });
    callback();
};

});

define("plugins/c9.ide.language.go/worker/go_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var workerUtil = require("plugins/c9.ide.language/worker_util");

var handler = module.exports = Object.create(baseHandler);
var daemon;
var enabled = true;

handler.handlesLanguage = function(language) {
    return language === "golang";
};

handler.init = function(callback) {
    var emitter = handler.getEmitter();
    emitter.on("set_go_config", function(e) {
        enabled = e.enabled;
    });
    callback();
};

handler.onDocumentOpen = function(path, doc, oldPath, callback) {
    ensureDaemon(callback);
};
handler.getCompletionRegex = function() {
    return (/^[\.]$/);
};
handler.getExpressionPrefixRegex = function() {
    return new RegExp(
        "(\\b(if|while|for|switch)\\s*\\("
        + "|\\b\\w+\\s+"
        + "|(==|!=|[-+]=|[-+*%<>?!|&{[])\\s*)+"
    );
};
handler.complete = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    ensureDaemon(function(err) {
        if (err) return callback(err);
        
        var start = Date.now();
        workerUtil.execAnalysis(
            "bash", // TODO: don't use bash here, better GOPATH handling
            {
                args: [
                    "-c",
                    "GOPATH=$HOME/.c9/gocode:$GOPATH ~/.c9/gocode/bin/gocode -f=json autocomplete " + getOffset(doc, pos)
                ],
                mode: "stdin",
                json: true,
            },
            function(err, response, responseErr, meta) {
                if (err) return callback(err);
                
                var results = response && response[1] && response[1].map(
                    function beautifyCompletion(r) {
                        r.isContextual = true;
                        r.guessTooltip = true;
                        if (/func\(/.test(r.type)) {
                            r.replaceText = r.name + "(^^)";
                            r.name += "()";
                            r.icon = "method";
                        }
                        else if (r.class === "package") {
                            r.icon = "package";
                        }
                        else {
                            r.icon = "property";
                        }
                        r.docHead = r.type;
                        r.priority = 4;
                        return r;
                    }
                );
                
                console.log("[go_completer] completed in " + (Date.now() - start)
                    + "ms (gocode: " + meta.serverTime + "ms): "
                    + doc.getLine(pos.row).substr(0, pos.column));
                callback(null, results);
            }
        );
    });
};

function getOffset(doc, pos) {
    var result = 0;
    var lines = doc.getAllLines();
    for (var i = 0; i < lines.length; i++) {
        if (i === pos.row)
            return result + pos.column;
        
        result += lines[i].length + 1;
    }
}

handler.predictNextCompletion = function(doc, fullAst, pos, options, callback) {
    if (!options.matches.length) {
        if (options.line[pos.column - 1] && /(?![{;})\]\s"'\+\-\*])./.test(options.line[pos.column - 1]))
            return callback(null, { predicted: "" });
    }
    var predicted = options.matches.filter(function(m) {
        return m.isContextual;
    });
    if (predicted.length !== 1 || predicted[0].icon === "method")
        return callback();
    console.log("[go_completer] Predicted our next completion will be for " + predicted[0].replaceText + ".");
    callback(null, {
        predicted: predicted[0].replaceText + ".",
        showEarly: predicted[0].class === "package"
    });
};
function ensureDaemon(callback) {
    if (daemon)
        return done(daemon.err);

    var loadingErr = new Error("Still starting daemon, enhance your calm");
    loadingErr.code = "ELOADING";
    daemon = {
        err: loadingErr,
        kill: function() {
            this.killed = true;
        }
    };
    
    workerUtil.spawn(
        "bash",
        {
            args: [
                "-c", "mkdir -p ~/.c9/gocode; GOPATH=$HOME/.c9/gocode go get -u github.com/nsf/gocode && ~/.c9/gocode/bin/gocode"
            ]
        },
        function(err, child) {
            if (err) return done(err);
            
            daemon = child;
            daemon.err = null;
            
            if (daemon.killed)
                daemon.kill();
            
            child.stderr.on("data", function(data) {
                console.log("[stderr]", data);
            });
            child.on("exit", function(code) {
                var tip = code === 127 ? " Please make sure go is on your PATH for bash." : "";
                done(code && "Error " + code + " starting daemon. " + tip);
            });
        }
    );
    
    function done(err) {
        if (err) {
            daemon.err = err;
            if (err.code !== "ELOADING")
                workerUtil.showError("Could not setup or start Go completion daemon. Please reload to try again.");
            return callback(err);
        }
        callback();
    }
}

});

define("plugins/c9.ide.language.python/worker/python_jsonalyzer",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*class\s+([^ \(:]+)/g, kind: "unknown2" },
    { regex: /(?:^|\n)\s*def\s+(?!_)([^ \(:]+)/g, kind: "method2", indent: 1 },
    { regex: /(?:^|\n)\s*def\s+(?!__[^ \(:]+__)(_[^ \(]*)/g, kind: "method2", indent: 1 },
    { regex: /(?:^|\n)\s*def\s+(__[^ \(:]+__)/g, kind: "property2", indent: 1 },
    {
        regex: new RegExp(
            "(?:^|\\n)\\s*import\\s+([^ \\(]+)"
        ),
        kind: "import"
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["py"];

handler.extensions = ["py"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    return callback(null, { properties: results });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};

});

define("plugins/c9.ide.language.python/worker/python_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var workerUtil = require("plugins/c9.ide.language/worker_util");

var KEYWORD_REGEX = new RegExp(
    "^(and|as|assert|break|class|continue|def|del|elif|else|except|exec|"
    + "finally|for|from|global|if|import|in|is|lambda|not|or|pass|print|"
    + "raise|return|try|while|with|yield)$"
);
var DAEMON_PORT = 10880;
var ERROR_PORT_IN_USE = 98;
var ERROR_NO_SERVER = 7;

var handler = module.exports = Object.create(baseHandler);
var pythonVersion = "python2";
var enabled;
var pythonPath = "";
var jediServer;
var launchCommand;
var showedJediError;
var daemon;

handler.handlesLanguage = function(language) {
    return language === "python";
};

handler.init = function(callback) {
    var emitter = handler.getEmitter();
    emitter.on("set_python_config", function(e) {
        pythonVersion = e.pythonVersion;
        pythonPath = e.pythonPath;
        enabled = e.completion;
        if (daemon) {
            daemon.kill();
            daemon = null;
        }
    });
    emitter.on("set_python_scripts", function(e) {
        jediServer = e.jediServer;
        launchCommand = e.launchCommand;
    });
    callback();
};

handler.getIdentifierRegex = function() {
    return /\w/;
};

handler.getCompletionRegex = function() {
    return (/(\.|\b(import|from|if|while|from|raise|return) |% )$/); 
};

handler.getCacheCompletionRegex = function() {
    return / ?(\b\w+\s+|\b(if|while|for|print)\s*\(|([{[\-+*%<>!|&/,%]|==|!=)\s*)*/;
};

handler.onDocumentOpen = function(path, doc, oldPath, callback) {
    if (!enabled) return callback();
    ensureDaemon(callback);
};
handler.complete = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    callDaemon("completions", handler.path, doc, pos, options, function(err, results, meta) {
        if (err) return callback(err);
        
        results && results.forEach(function beautifyCompletion(r) {
            r.isContextual = true;
            r.guessTooltip = true;
            r.replaceText = r.replaceText || r.name;
            r.priority = r.name[0] === "_" || r.replaceText === r.replaceText.toUpperCase() ? 3 : 4;
            r.icon = r.icon || "property";
            r.icon = r.name[0] === "_" ? r.icon.replace(/2?$/, "2") : r.icon;
            r.noDoc = options.noDoc;
            if (!r.doc)
                return;
            if (r.replaceText === "print(^^)" && pythonVersion === "python2" && !/\.[^ ]*$/.test(options.line.substr(pos.column)))
                r.replaceText = "print";
            var docLines = r.doc.split(/\r\n|\n|\r/);
            var docBody = docLines.slice(2).join("\n");
            r.docHeadHtml = workerUtil.filterDocumentation(docLines[0]).replace(/^([A-Za-z0-9$_]+\()self, /, "$1");
            r.doc = workerUtil.filterDocumentation(docBody.replace(/``/g, "'"));
        });
        callback(null, results);
    });
};
handler.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    callDaemon("goto_definitions", handler.path, doc, pos, options, callback);
};
handler.predictNextCompletion = function(doc, fullAst, pos, options, callback) {
    var line = options.line;
    if (!options.matches.length) {
        if (line[pos.column - 1] && /(?![:)}\]\s"'\+\-\*])./.test(line[pos.column - 1]))
            return callback(null, { predicted: "" });
    }
    var predicted = options.matches.filter(function(m) {
        return m.isContextual
            && !m.replaceText.match(KEYWORD_REGEX);
    });
    if (predicted.length > 0 && "import".substr(0, line.length) === line)
        return callback(null, { predicted: "import " });
    if (predicted.length !== 1 || predicted[0].icon === "method")
        return callback();
    if (/^\s+import /.test(line))
        return callback();
    console.log("[python_completer] Predicted our next completion will be for " + predicted[0].replaceText + ".");
    callback(null, {
        predicted: predicted[0].replaceText + ".",
        showEarly: predicted[0].replaceText === "self" || predicted[0].icon === "package"
    });
};
function callDaemon(command, path, doc, pos, options, callback) {
    ensureDaemon(function(err, dontRetry) {
        if (err) return callback(err);
        
        var start = Date.now();
        workerUtil.execAnalysis(
            "curl",
            {
                mode: "stdin",
                json: true,
                args: [
                    "-s", "--data-binary", "@-", // get input from stdin
                    "-H", "Expect:", // don't wait for "100-Continue"
                    "localhost:" + DAEMON_PORT + "?mode=" + command
                    + "&row=" + (pos.row + 1) + "&column=" + pos.column
                    + "&path=" + encodeURIComponent(path.replace(/^\//, ""))
                    + (options.noDoc ? "&nodoc=1" : ""),
                ],
            },
            function onResult(err, stdout, stderr, meta) {
                if (err) {
                    if (err.code === ERROR_NO_SERVER && !dontRetry)
                        return callDaemon(command, path, doc, pos, options, callback);
                    return callback(new Error("jedi_server failed or not responding"));
                }
                
                if (typeof stdout !== "object")
                    return callback(new Error("Couldn't parse python-jedi output: " + stdout));
                
                console.log("[python_completer] " + command + " in " + (Date.now() - start)
                    + "ms (jedi: " + meta.serverTime + "ms): "
                    + doc.getLine(pos.row).substr(0, pos.column));

                callback(null, stdout, meta);
            }
        );
    });
}
function ensureDaemon(callback) {
    if (daemon)
        return done(daemon.err, true);

    daemon = {
        err: new Error("Still starting daemon, enhance your calm"),
        kill: function() {
            this.killed = true;
        }
    };
    
    workerUtil.spawn(
        "bash",
        {
            args: [
                "-c", launchCommand, "--", pythonVersion,
                "$PYTHON -c '" + jediServer + "' daemon --port " + DAEMON_PORT
            ],
            env: { PYTHONPATH: pythonPath },
        },
        function(err, child) {
            var output = "";
            if (err) {
                daemon.err = err;
                return workerUtil.showError("Could not start python completion daemon. Please reload to try again.");
            }
            daemon = child;
            daemon.err = null;
            
            if (daemon.killed)
                daemon.kill();
            var killTimer = setTimeout(daemon.kill.bind(daemon), 30 * 60 * 1000);
            
            child.stderr.on("data", function(data) {
                output += data;
                if (/Daemon listening/.test(data))
                    done();
            });
            child.on("exit", function(code) {
                if (code === ERROR_PORT_IN_USE) // someone else running daemon?
                    return done(null, true);
                if (!code || /Daemon listening/.test(output)) // everything ok, try again later
                    daemon = null;
                clearTimeout(killTimer);
                done(code && new Error("[python_completer] Daemon failed: " + output), true);
            });
        }
    );
    
    function done(err, dontRetry) {
        if (err && /No module named jedi/.test(err.message) && !showedJediError) {
            workerUtil.showError("Jedi not found. Please run 'pip install jedi' or 'sudo pip install jedi' to enable Python code completion.");
            showedJediError = true;
        }
        callback && callback(err, dontRetry);
        handler.sender.emit("python_completer_ready");
        callback = null;
    }
}

});

define("plugins/c9.ide.language.python/worker/python_linter",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var workerUtil = require("plugins/c9.ide.language/worker_util");

var handler = module.exports = Object.create(baseHandler);
var pythonVersion = "python2";
var pythonPath = "";
var pylintFlags = "";
var launchCommand;
var hosted;
var PYLINT_DEFAULTS = [
    "-d", "all",
    "-e", "E", 
    "-e", "F", 
    "-e", "W0101", // Unreachable code
    "-e", "W0109", // Duplicate key in dictionary
    "-e", "W0199", // Assert called on a 2-tuple. Did you mean \'assert x,y\'?
    "-e", "W0612", // Unused variable
    "-e", "W0602", // Used global without assignment
];
var PYLINT_CONFIG = [
    "-r", "n", 
    "--msg-template={line}:{column}:\\ [{msg_id}]\\ {msg}",
    "--load-plugins", "pylint_flask,pylint_django",
];

handler.handlesLanguage = function(language) {
    return language === "python";
};

handler.init = function(callback) {
    var emitter = handler.getEmitter();
    emitter.on("set_python_config", function(e) {
        pythonVersion = e.pythonVersion;
        pythonPath = e.pythonPath;
        pylintFlags = e.pylintFlags;
    });
    emitter.on("set_python_scripts", function(e) {
        launchCommand = e.launchCommand;
        hosted = e.hosted;
    });
    callback();
};

handler.analyze = function(docValue, fullAst, options, callback) {
    var commands = hosted
        ? ["-c", pythonVersion === "python2" ? "pylint2" : "pylint3"]
        : ["-c", launchCommand, "--", pythonVersion, "$ENV/bin/pylint"];
    commands[commands.length - 1] += " " + (pylintFlags || PYLINT_DEFAULTS.join(" "))
        + " " + PYLINT_CONFIG.join(" ")
        + " '$FILE'";
    if (!launchCommand)
        return callback(new Error("Warning: python_linter not initialized yet"));

    var hasStarImports = /from\s+[^\s]+\s+import\s+\*/.test(docValue);
    var markers = [];
    workerUtil.execAnalysis(
        "bash",
        {
            mode: "local-tempfile",
            args: commands,
            maxCallInterval: 800,
            env: {
                PYTHONPATH: pythonPath,
                PYLINTHOME: "/tmp/.pylint.d",
            }
        },
        function(err, stdout, stderr) {
            if (err && !stdout) return callback(err);

            stdout.split("\n").forEach(function(line) {
                var marker = parseLine(line, hasStarImports);
                marker && markers.push(marker);
            });
            
            callback(null, markers);
        }
    );
};

function parseLine(line, hasStarImports) {
    var match = line.match(/(\d+):(\d+): \[([^\]]+)\] (.*)/);
    if (!match)
        return;
    var row = match[1];
    var column = match[2];
    var code = match[3];
    var message = match[4];
    var level = getLevel(code);
    
    if (/print statement used/.test(message))
        return;
    if (hasStarImports && /undefined variable/i.test(message)) {
        level = "info";
        message += "?";
    }
    if (/E0632/.test(code))
        level = "info";
    if (/E1128|E0633/.test(code))
        level = "warning";
    if (/E0401/.test(code))
        return;
    if (/Django is not available on/.test(message))
        return;
        
    return {
        pos: {
            sl: parseInt(row, 10) - 1,
            sc: parseInt(column, 10)
        },
        message: message,
        code: code,
        level: level
    };
}

function getLevel(code) {
    if (code[0] === "E" || code[0] === "F")
        return "error";
    if (code === "W0612") // unused variable
        return "info";
    if (code === "W0602") // global without assignment
        return "info";
    return "warning";
}

});

define("plugins/c9.ide.language.javascript.infer/infer_jumptodef",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var handler = module.exports = Object.create(baseLanguageHandler);
var infer = require("./infer");
var path = require("./path");
var astUpdater = require("./ast_updater");

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    if (!fullAst || !options.node)
        return callback();
    
    var results = [];
    var basePath = path.getBasePath(handler.path, handler.workspaceDir);
    var filePath = path.canonicalizePath(handler.path, basePath);
    
    astUpdater.updateOrReanalyze(doc, fullAst, filePath, basePath, pos, function(fullAst, currentNode) {
        if (!currentNode)
            return callback();
        
        currentNode.rewrite(
            'PropAccess(o, p)', function(b, node) {
                var values = infer.inferValues(b.o);
                values.forEach(function(v) {
                    jumpToProperty(v, b.p.value, results);
                });
            },
            'Var(v)', function(b, node) {
                jumpToVar(node, results);
            },
            'Call(Var("require"), [String(_)])', function(b, node) {
                jumpToRequire(node, results);
            },
            'Var("require")', function(b, node) {
                if (node.parent &&
                    node.parent.isMatch('Call(Var("require"), [_])'))
                jumpToRequire(node.parent, results);
            },
            'String(_)', function(b, node) {
                if (node.parent && node.parent.parent &&
                    node.parent.parent.isMatch('Call(Var("require"), [_])'))
                jumpToRequire(node.parent.parent, results);
            }
        );
    });
        
    callback(results);
};

var jumpToRequire = function(node, results) {
    var values = infer.inferValues(node);
    values.forEach(function(v) {
        if (v.path)
            results.push({
                path: v.path,
                row: v.row,
                icon: "package"
            });
    });
};

var jumpToProperty = module.exports.jumpToProperty = function(value, property, results) {
    var prop = value.properties && value.properties["_" + property];
    if (prop && prop[0])
        prop = prop[0];
    if (!prop || (!value.path && !prop.path && !prop.row))
        return;
    results.push({
        row: prop.row,
        column: prop.column,
        path: prop.path || value.path,
        icon: "property"
    });
};

var jumpToVar = function(node, results) {
    var values = infer.inferValues(node);
    values.forEach(function(v) {
        if (!v.path && !v.row)
            return;
        results.push({
            row: v.row,
            path: v.path,
            icon: "property"
        });
    });
};

});

define("plugins/c9.ide.language.javascript.immediate/immediate_complete_static",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);

var scopeAnalyzer = require("plugins/c9.ide.language.javascript/scope_analyzer");
var inferCompleter = require("plugins/c9.ide.language.javascript.infer/infer_completer");
    
handler.handlesLanguage = function(language) {
    return language === "javascript";
};

handler.handlesEditor = function() {
    return this.HANDLES_IMMEDIATE;
};

handler.complete = function(doc, fullAst, pos, options, callback) {
    return scopeAnalyzer.complete(doc, fullAst, pos, options, function(results) {
        var allResults = results || [];
        inferCompleter.complete(doc, fullAst, pos, options, function(results) {
            callback(allResults.concat(results || []));
        });
    });
};

});

define("plugins/c9.ide.language.javascript.immediate/immediate_complete",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);
    
handler.handlesLanguage = function(language) {
    return language === "javascript";
};

handler.handlesEditor = function() {
    return this.HANDLES_IMMEDIATE;
};

var requestId = 0;
handler.complete = function(doc, fullAst, pos, options, callback) {
    var currentNode = options.node;
    if (!currentNode || !currentNode.getPos())
        return callback();
    
    if (!isSafe(currentNode))
        return callback();
    
    var expr = getExpression(doc, currentNode.getPos());
    var myRequestId = ++requestId;
    
    this.sender.once("js_immediate_complete_results", function(e) {
        if (myRequestId !== e.data.id)
            return;
        callback(e.data.results);
    });
    this.sender.emit(
        "js_immediate_complete",
        {
            immediateWindow: this.immediateWindow,
            expr: expr,
            id: myRequestId
        }
    );
};

function isSafe(node) {
    var badNodes = node.collectTopDown(
        "Call(x, _)", function(b) {
            return !b.x.rewrite('Var("require")');
        }
    );
    return !badNodes.length && ["Call", "PropAccess", "Var"].indexOf(node.cons) > -1;
}

function getExpression(doc, pos) {
    if (pos.sl === pos.el) {
        return doc.getLine(pos.sl).substring(pos.sc, pos.ec);
    }
    var result = doc.getLine(pos.sl).substr(pos.sc);
    for (var i = pos.sl + 1; i < pos.el; i++) {
        result += doc.getLine(i);
    }
    result += doc.getLine(pos.el).substr(0, pos.ec);
    return result;
}


});

define("plugins/c9.ide.language.javascript/jumptodef",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var handler = module.exports = Object.create(baseLanguageHandler);
var scopes = require("plugins/c9.ide.language.javascript/scope_analyzer");

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.jumpToDefinition = function(doc, ast, pos, options, callback) {
    if (!ast || !options.node)
        return callback();
    scopes.analyze(doc.getValue(), ast, function() {
        scopes.getRenamePositions(doc, ast, pos, options, function (data) {
            if (!data || !data.declarations || data.declarations.length === 0) {
                return callback(null);
            }
            
            callback(data.declarations);
        });
    }, true);
};

});

define("plugins/c9.ide.language.javascript/outline",[], function(require, exports, module) {

require("treehugger/traverse"); // add traversal functions to trees

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var outlineHandler = module.exports = Object.create(baseLanguageHandler);

var ID_REGEX = /[a-zA-Z_0-9\$\_]/;
var EVENT_REGEX = /[a-zA-Z_0-9\$\_\ \(\)\[\]\/@]/;

var NOT_EVENT_HANDLERS = {
    addMarker: true,
    traverseUp: true,
    traverse: true,
    topdown: true,
    traverseTopDown: true,
    rewrite: true,
    traverseAll: true
};

outlineHandler.handlesLanguage = function(language) {
    return language === "javascript";
};
    
outlineHandler.outline = function(doc, ast, callback) {
    if (!ast)
        return callback();
    callback({ items: outlineSync(doc, ast) });
};
    
function fargsToString(fargs) {
    var str = '(';
    for (var i = 0; i < fargs.length; i++) {
        str += fargs[i][0].value + ', ';
    }
    if (fargs.length > 0)
        str = str.substring(0, str.length - 2);
    str += ')';
    return str;
}

function expressionToName(node) {
    var name;
    node.rewrite(
        'Var(x)', function(b) { name = b.x.value; },
        'PropAccess(e, x)', function(b) { name = (b.e.cons === "Var" ? b.e[0].value + "." : "") + b.x.value; },
        'Index(e, x)', function(b) {
            var parent = (b.e[1] || b.e[0]).value || "";
            if (b.x[0])
                name = parent + "[" + b.x[0].value + "]";
        }
    );
    return name;
}
var outlineSync = outlineHandler.outlineSync = function(doc, node, includeProps) {
    var results = [];
    node.traverseTopDown(
        'Assign(e, Function(name, fargs, body))', function(b) {
            var name = expressionToName(b.e);
            if (!name) return false;
            results.push({
                icon: 'method',
                name: name + fargsToString(b.fargs),
                pos: this[1].getPos(),
                displayPos: (b.e[1] || b.e[0] || b.e).getPos(),
                items: outlineSync(doc, b.body, includeProps)
            });
            return this;
        },
        'VarDeclInit(x, Function(name, fargs, body))', 'ConstDeclInit(x, Function(name, fargs, body))',
        function(b) {
            results.push({
                icon: 'method',
                name: b.x.value + fargsToString(b.fargs),
                pos: this[1].getPos(),
                displayPos: b.x.getPos(),
                items: outlineSync(doc, b.body, includeProps)
            });
            return this;
        },
        'PropertyInit(x, Function(name, fargs, body))', 'Method(x, Function(name, fargs, body))', function(b) {
            results.push({
                icon: 'method',
                name: b.x.value + fargsToString(b.fargs),
                pos: this[1].getPos(),
                displayPos: b.x.getPos(),
                items: outlineSync(doc, b.body, includeProps)
            });
            return this;
        },
        'VarDeclInit(x, e)', 'ConstDeclInit(x, e)', function(b) {
            var items = outlineSync(doc, b.e, includeProps);
            if (items.length === 0)
                return this;
            results.push({
                icon: 'property',
                name: b.x.value,
                pos: this[1].getPos(),
                displayPos: b.x.getPos(),
                items: items
            });
            return this;
        },
        'PropertyInit(x, e)', function(b) {
            var items = outlineSync(doc, b.e, includeProps);
            if (items.length === 0 && !includeProps)
                return this;
            results.push({
                icon: 'property',
                name: b.x.value,
                pos: items.length ? this[1].getPos() : this.getPos(),
                displayPos: b.x.getPos(),
                items: items
            });
            return this;
        },
        'Assign(x, e)', function(b) {
            var name = expressionToName(b.x);
            if (!name)
                return false;
            var items = outlineSync(doc, b.e, includeProps);
            if (items.length === 0)
                return this;
            results.push({
                icon: 'property',
                name: name,
                pos: this[1].getPos(),
                displayPos: (b.x[1] || b.x[0] || b.x).getPos(),
                items: items
            });
            return this;
        },
        'Call(e, args)', function(b) {
            var eventHandler = tryExtractEventHandler(this);
            if (!eventHandler)
                return false;
            var object = b.e.rewrite("PropAccess(Var(x), _)", function(b) { return b.x.value; });
            results.push({
                icon: 'event',
                name: (object ? object + "." : "") + eventHandler.s[0].value,
                pos: this.getPos(),
                displayPos: eventHandler.s.getPos(),
                items: eventHandler.body && outlineSync(doc, eventHandler.body, includeProps)
            });
            return this;
        },
        'Class(x, y, body)', function(b) {
            results.push({
                icon: 'event',
                name: b.x.value + (b.y.value ? " extends " + b.y.value : ""),
                pos: this.getPos(),
                displayPos: b.x.getPos(),
                items: b.body && outlineSync(doc, b.body, includeProps)
            });
            return this;
        },
        'Function(name, fargs, body)', function(b) {
            if (!b.name.value)
                return false;
            results.push({
                icon: 'method',
                name: b.name.value + fargsToString(b.fargs),
                pos: this.getPos(),
                displayPos: b.name.getPos(),
                items: outlineSync(doc, b.body, includeProps)
            });
            return this;
        }
    );
    return results;
};

var tryExtractEventHandler = outlineHandler.tryExtractEventHandler = function(node, ignoreBind) {
    var result;
    node.rewrite('Call(e, args)', function(b) {
        var name = expressionToName(b.e);
        if (!name || b.args.length < 2 || NOT_EVENT_HANDLERS[name])
            return false;
        var s;
        var fun;
        if (b.args[0] && b.args[0].cons === 'String' && isCallbackArg(b.args[1], ignoreBind)) {
            s = b.args[0];
            fun = b.args[1];
        }
        else if (b.args[1] && b.args[1].cons === 'String' && isCallbackArg(b.args[2], ignoreBind)) {
            s = b.args[1];
            fun = b.args[2];
        }
        else {
            return false;
        }
        if (!s[0].value.match(EVENT_REGEX))
            return false;
        if (b.args.length >= 4 && b.args[2].cons === 'String' && b.args[3].cons === 'Function')
            return false;
        result = {
            s: s,
            fargs: fun[1],
            body: fun[2]
        };
    });
    return result;
};

var isCallbackArg = function(node, ignoreBind) {
    if (!node)
        return false;
    var result;
    node.rewrite(
        'Function(_, _, _)', function() { result = true; },
        'Call(PropAccess(_, "bind"), [_])', function() { result = !ignoreBind; }
    );
    return result;
};

});

define("plugins/c9.ide.language.javascript/debugger",[], function(require, exports, module) {

    var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
    
    var expressionBuilder = module.exports = Object.create(baseLanguageHandler);
    
    expressionBuilder.handlesLanguage = function(language) {
        return language === "javascript" || language === "jsx";
    };
    expressionBuilder.getInspectExpression = function(doc, fullAst, pos, options, callback) {
        if (!options.node) return callback();
        
        callback(getExpression(options.node));
    };
    var getExpression = function(node) {
        if (node.value)
            return { value: node.value, pos: node.getPos() };
        
        var result;
        node.rewrite(
            'VarDeclInit(x, _)', 'ConstDeclInit(x, _)', function(b) {
                node = b.x;
                result = b.x.value;
            },
            'VarDecl(x)', 'ConstDecl(x)', function(b) {
                node = b.x;
                result = b.x.value;
            },
            'PropAccess(e, x)', function(b) {
                result = getExpression(b.e) + "." + b.x.value;
            },
            'Var(x)', function(b) {
                result = b.x.value;
            },
            'Num(n)', function(b) {
                result = b.n.value;
            },
            'Index(e, idx)', function(b) {
                result = getExpression(b.e) + "[" + getExpression(b.idx) + "]";
            },
            'New(e, args)', function(b) {
                var method = getExpression(b.e);
                var args = b.args.toArray().map(getExpression).join(", ");
                result = "new " + method + "(" + args + ")";
            },
            'FArg(x)', function(b) {
                result = b.x.value;
            },
            'Op(op, e1, e2)', function(b) {
                result = getExpression(b.e1) + " " + b.op.value + " " + getExpression(b.e2);
            },
            function() {
                if (!result)
                    result = "";
            }
        );
        
        if (result === "")
            return;
        
        return { value: result, pos: node.getPos() };
    };

});

define("plugins/c9.ide.language.javascript/parse",[], function(require, exports, module) {

var parser = require("treehugger/js/parse");
var traverse = require("treehugger/traverse");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.handlesEditor = function() {
    return this.HANDLES_ANY;
};

handler.parse = function(code, callback) {
    var result;
    try {
        code = code.replace(/^(#!.*\n)/, "//$1");
        result = parser.parse(code);
        traverse.addParentPointers(result);
    } catch (e) {
        result = null;
    }
    
    callback(result);
};

handler.getMaxFileSizeSupported = function() {
    return .25 * 10 * 1000 * 80;
};

handler.findNode = function(ast, pos, callback) {
    var treePos = { line: pos.row, col: pos.column };
    callback(ast.findNode(treePos));
};

handler.getPos = function(node, callback) {
    callback(node.getPos());
};

handler.getMaxFileSizeSupported = function() {
    return 1000 * 1000;
};

});

define("plugins/c9.ide.language.generic/simple/shell",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);
    
handler.handlesLanguage = function(language) {
    return language === "sh";
};

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z_0-9\.\-\~]/);
};

handler.getCompletionRegex = function() {
    return (/\$/);
};


});

define("plugins/c9.ide.language.generic/simple/make",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);
    
handler.handlesLanguage = function(language) {
    return language === "makefile";
};

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z_0-9\/\.\-\~]/);
};


});

define("plugins/c9.ide.language.generic/mode_completer",[], function(require, exports, module) {

var completeUtil = require("plugins/c9.ide.language/complete_util");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var completer = module.exports = Object.create(baseLanguageHandler);

var modeCache = {}; // extension -> static data
var iconLanglist = ["php", "css"];

completer.handlesLanguage = function(language) {
    return ["css"/*, "php"*/].indexOf(language) !== -1;
};

completer.getMaxFileSizeSupported = function() {
    return Infinity;
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    var language = this.language;
    var line = doc.getLine(pos.row);
    var idRegex = workerUtil.getIdentifierRegex(pos);
    var identifier = options.identifierPrefix;
    if (line[pos.column - 1] === ".")
        return callback([]);

    var mode = modeCache[language];

    if (mode === undefined) {
        var text;
        if (language)
            text = completeUtil.fetchTextSync('plugins/c9.ide.language.generic/modes/' + this.language + '.json');
        try {
            mode = text ? JSON.parse(text) : {};
        } catch (e) {
            console.error(e);
            mode = {};
        }
        modeCache[language] = mode;
    }

    function getIcon(type) {
        if (iconLanglist.indexOf(language) === -1)
            return null;
        var iconMap = {
            "variable": "property",
            "type": "property2",
            "constant": "method2",
            "color": "method2",
            "font": "method2",
            "function": "method2",
            "pseudo.element": "event",
            "pseudo.class": "event"
        };
        var subs = Object.keys(iconMap);
        for (var i = 0; i < subs.length; i++)
            if (type.indexOf(subs[i]) !== -1)
                return iconMap[subs[i]];
        return null;
    }
    var types = Object.keys(mode);
    var matches = [];
    types.forEach(function (type) {
        var icon = getIcon(type);
        var nameAppend = "", replaceAppend = "";
        if (type.indexOf("function") !== -1) {
            nameAppend = "()";
            replaceAppend = "(^^)";
        }
        var deprecated = type.indexOf("deprecated") === -1 ? 0 : 1;
        var compls = completeUtil.findCompletions(identifier, mode[type]);
        matches.push.apply(matches, compls.map(function(m) {
            return {
                name: m + nameAppend,
                replaceText: m + replaceAppend,
                doc: deprecated ? ("Deprecated: <del>" + m + nameAppend + "</del>") : null,
                icon: icon,
                meta: type,
                identifierRegex: idRegex,
                priority: 2 - deprecated
            };
        }));
    });
    
    callback(matches);
};


});

define("plugins/c9.ide.language.generic/snippet_completer",[], function(require, exports, module) {

var completeUtil = require("plugins/c9.ide.language/complete_util");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var completer = module.exports = Object.create(baseLanguageHandler);

var snippetCache = {}; // extension -> snippets
    
completer.handlesLanguage = function(language) {
    language = language && language.slice(language.lastIndexOf("/") + 1);
    return snippetCache[language] || snippetCache._;
};

completer.getMaxFileSizeSupported = function() {
    return Infinity;
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    var line = doc.getLine(pos.row);
    var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, completer.$getIdentifierRegex());
    if (line[pos.column - identifier.length - 1] === '.') // No snippet completion after "."
        return callback([]);
    
    var language = this.language && this.language.slice(this.language.lastIndexOf("/") + 1);
    var snippets = snippetCache[language];
    
    var allIdentifiers = Object.keys(snippets || {});
    
    var matches = completeUtil.findCompletions(identifier, allIdentifiers);
    callback(matches.map(function(m) {
        var snippet = snippets[m];
        return {
            name: snippet.name,
            snippet: snippet.content,
            replaceText: snippet.name,
            doc: "<pre>" + snippet.content + "</pre>",
            icon: "package",
            meta: "snippet",
            isGeneric: true,
            priority: 0 // todo change this back to 2 once snippets are cleaned up
        };
    }));
};

completer.init = function(callback) {
    this.sender.on("loadSnippets", function(e) {
        snippetCache[e.data.language] = e.data.snippets;
    });
    callback();
};

});
